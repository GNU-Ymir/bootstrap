\section{Preamble}

\section{Function overloading}
\label{sec:function_overloading}

Two functions can share the same name if their parameters differ. This concept,
known as function overloading, permits two functions with the same name to be
defined within the same module under the same name, as long as their parameter
lists differ enough to allow the compiler to determine which function is
referenced during a call.

In the following example, three functions named \token{foo} are declared. The
first function takes an \token{i32} parameter, the second function takes an
\token{i64} parameter, and the third function takes an \token{f32} parameter.
When the first call is made at line 6, it references the function with the
closest matching type, which is the one defined at line 1. Similarly, the second
call at line 7, using an \token{i64} parameter, refers to the function defined
at line 2. Finally, the third call at line 8 uses an \token{f32} parameter, thus
referencing the definition at line 3. However, the call at line 10 uses an
\token{i8} parameter. Even though, in this case, the value is a literal and can
be implicitly casted into either an \token{i32} or an \token{i64}, there is no
definitive way to determine whether it would be better suited for the definition
at line 1 or line 2. Consequently, the compiler throws an error. Moreover, the
call at line 13 cannot implicitly cast the value of type \token{i8} since it is
not a literal value. Consequently, no function matches the correct type,
resulting in a compiler error.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
fn foo (i : i32);
fn foo (i : i64);
fn foo (f : f32);

foo (1); // calling /foo (i32)/
foo (1i64); // calling /foo (i64)/
foo (1.0f); // calling /foo (f32)/

@\hb{foo (1i8);}@// Error: /i8/ can be casted to /i32/ or /i64/, thus matching both function definitions.

let i = 1i8;
foo (i); // Error: /i8/ cannot be casted and does not match any function definition.
\end{lstlisting}

\vfill%
\pagebreak

\section{Function pointer}
\label{sec:function_pointers}

\vfill%
\pagebreak

\section{Lambda functions}
\label{sec:lambda}

\vfill%
\pagebreak

\section{Closure}
\label{sec:closure}

\vfill%
\pagebreak

\section{Lazy value implementation}
\label{sec:impl_lazy_closure}


\vfill%
\pagebreak

\section{Methods}
\label{sec:method_delegates}
