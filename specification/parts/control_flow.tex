\section{Preamble}

Control flows are generally determined dynamically at runtime, where the machine
code generated contains instructions for the control flow, and the specific
branches to traverse are decided during program execution. However, it is
possible to make these decisions statically at compile time using the keyword
\token{cte} for \textit{Compile Time Execution}, subject to certain
requirements. These requirements vary depending on the type of control flow
construct used, and they entail the compiler needing to possess specific values
at compile time. The utilization of cte control flow aligns with the concept of
conditional compilation introduced in
Chapter~\ref{chap:conditional_compilation}.

\section{Conditional branching}%
\label{sec:if_else}

A conditional control flow can be defined using the keywords \token{if} and
\token{else}. The syntax \token{if C V} defines that the value \token{V} is
evaluated if and only if the condition \token {C} of type \token {bool} is true.
Using the keyword \token{else} this construction can be extended to provide
another value to evaluate if the condition is not met. The if condition at line
2 in the next example generates a runtime conditional representation that can be
represented by the flow graph presented in Figure~\ref{fig:if_cond_simple}, or
by the YIL code in Listing~\ref{lst:if_cond_simple}.

\begin{lstlisting} [style=coloredverbatim, escapechar=@]
fn foo (cond : bool)-> i32 {
  if cond {
    89
  } else {
    11
  }
}

let x = foo (true); // /x/ evaluated to 89
let y = foo (false); // /y/ evaluated to 11
\end{lstlisting}

\begin{lstlisting}[style=lyilVerb, caption=Simple condition, label=lst:if_cond_simple]
frame :  _Y4main3fooFbZi32 (let cond(#1) : u8)-> i32 {
    let YI_2(#2) : i32;
#IF cond(#1)
#THEN_GOTO then(#1)
#ELSE_GOTO else(#3);
#LABEL then(#1);
    YI_2(#2) = 89;
#GOTO end(#2);
#LABEL else(#3);
    YI_2(#2) = 11;
#GOTO end(#2);
#LABEL end(#2);
    return YI_2(#2);
}
\end{lstlisting}

\input{images/if_cond_simple}

Conditional branching can be applied to any test that produces a \token{bool}
value that is unknown at compile time. However, they are not allowed if the
condition can be determined at compile time, as they would only complicate the
source code with useless control flows that can be determined statically. For
example, in the following code on line 2, the condition is always \token{true},
so the condition is useless and the code on line 3 is always evaluated, in
addition, on line 5 the condition is always \token{false}, creating dead code
that is never evaluated.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
let a = [1, 2, 3];
if (@\hb{a.len <= 3}@) { // error, len of /a/ is /cte/
  println (a [2]);
}

if (a.len >= 4) {
  @\hb{println (a [3]);}@ // error, dead code
}
\end{lstlisting}

\subsection {Conditional value}
\label{sec:cond_value_type}

A \token{if} construct has a result value if all branches have a result value.
The type of the expression is the type of the first branch, i.e. the type of the
value of the first \token{if}. The value of the \token{else} branch is
implicitly cast to the type of the first branch value, if this is not possible
the compiler returns an error.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
let a = if cond {
  12
@\hb{\};}@ // error, no else value

let b = if cond {
  12
} else {
  "str"
@\hb{\};}@ // error, incompatible i32 and [c8]

let d = if cond {
  12
} else {
  11u32
}; // ok, implicit cast of 11u32 to i32
\end{lstlisting}

\subsection{Mutable conditional value}

If the type of the \token{else} branch is compatible with the type of the first
branch, but does not match its mutability, the mutability of the result value of
the \token{if} construct is reduced to match the most restricted value. In the
next example, because the value of the \token{else} branch has a more
restricted mutability than the value of the \token{if} branch, the result type
of the expression takes the mutability of the \token{else} branch, and thus the
result value is of type \token{mut [i32]}.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
let a = copy [1, 2, 3];
let @\hb{dmut b = if cond \{}@// error, mutability does not fit in /b/
  copy [2, 3, 4] // mut [mut i32]
} else {
  a
\hb{\};}@ // mut [i32]
\end{lstlisting}

As for scope values when returning a mutable borrowed value, because
the \token{alias} contract is already accepted within the value of the
branches, it is not necessary to accept it again for the result value of the
\token{if} construct. Therefore, in the next example, the keyword
\token{alias} is not used before the keyword \token{if}, even though the
affectation to \token{b} moves borrowed mutable data.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
fn foo (cond : bool) {
  let dmut a = copy [1, 2, 3];
  let dmut b = if cond {
    alias a // alias is mandatory here
  } else {
    copy [2, 3, 4]
  };
}
\end{lstlisting}


\subsection{Chaining conditions}

Conditions can be chained by following the \token{else} with another
\token{if} condition. In fact, this does not really chain the condition, since
in this case the \token{if} condition following the \token{else} keyword is
the value that is evaluated in case the condition of the first \token{if} is
not true. To illustrate, the following source code presents two chained
\token{if} conditions that are exactly similar in semantics.


\begin{minipage}[t][][t]{0.47\linewidth}
\begin{lstlisting}[style=coloredverbatim, escapechar=@, caption=Using a \token{if} as the value of the \token{else} branch]
if cond {
  println ("First condition is true");
} else if cond2 {
  println ("Second condition is true");
} else {
  println ("None of the conditions were true");
}
\end{lstlisting}
\end{minipage}\hspace{10pt}%
\begin{minipage}[t][][t]{0.47\linewidth}
  \begin{lstlisting}[style=coloredverbatim, escapechar=@, caption=Using a block as the value of the \token{else} branch]
if cond {
  println ("First condition is true");
} else {
  if cond2 {
    println ("Second condition is true");
  } else {
    println ("None of the conditions were true");
  }
}
  \end{lstlisting}
\end{minipage}
\vspace{-10pt}%

\subsection{Early return branch}

We have seen in Section~\ref{sec:function_early_return} that a function can exit
early in three different ways (i.e., \token{return}, \token{throw}, or
\token{panic}). Such an early exit can happen inside a branch of a conditional
value. In this case, that particular branch is considered a return branch and
therefore has no value. In Section~\ref{sec:inf_loop} we will see a construction
that can also exit a branch of the flow graph without constructing a value (i.e.
\token{break}). As a result, the \token{if} construction can sometimes have a
result value even though not all branches construct a value.

%\smallskip

\input{images/if_cond_early_return}

\begin{lstlisting}[style=coloredverbatim, caption=Early return in \token{if} condition, label=lst:if_cond_early_return]
fn foo (cond : bool)-> i32 {
  let a = if cond {
    return 89; // exits the function
  } else {
    10
  }; // ok, all non-returning branches have a value

  a + 9
}
\end{lstlisting}

In the example presented in Listing~\ref{lst:if_cond_early_return}, the value of
the variable \token{a} can be constructed. In fact, if the condition is not
true, the value of \token{a} will be 10, and if the condition is true, then the
function exits, so the value of \token{a} does not need to be evaluated in this
case. Figure~\ref{fig:if_cond_early_exit} shows the flow graph resulting from
this source code. You can clearly see from this graph that in the flow that the
first branch follows (when the condition is met), the variable \token{a} is
never needed, and therefore does not need to be constructed for the code to be
correct.


\subsection {Conditional pattern}
\label{sec:cond_pattern}

We have seen in Section~\ref{sec:pattern_vdecl} that variables can be declared
using a pattern, and that the pattern might be refutable and needing runtime
validation. In that case, the pattern has to be coupled with a conditional
branch representation using the syntax \token{if let Pattern = Value V}, as
presented in the next example.

\input{images/if_cond_let_Ok}

\begin{lstlisting}[style=coloredverbatim, label=lst:if_cond_let_Ok, caption=Example of conditional pattern]
fn foo ()-> i32?;

if let Ok (x : i32) = foo () {
  println ("Foo returned the value : ", x);
}
\end{lstlisting}

In the previous example, the function \token{foo} could return a \token{none}
value, but the code would still be safe because the conditional ensures that the
variable \token{x} is created if and only if the function actually returns a
value. This example produces the YIL representation shown in
Figure~\ref{fig:if_cond_let_Ok}, as you can see the variable \token{x} is
actually created only if the value returned by \token{foo} is set. All kinds of
patterns can be used for conditional pattern declarations, those are described
in Section~\ref{sec:pattern_matching}.


Pattern conditional branching can be used for any pattern that requires run-time
validation, but is not allowed for patterns that are irrefutable (or always
wrong), as it would just make the code unnecessarily complex.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
let a = (1, 2, 3);

if @\hb{let (x, y, z) = a \{}@ // error, pattern is irrefutable
  println (x, ' ', y, ' ', z);
}
\end{lstlisting}

\subsubsection{Conditional pattern guard}

As we will see in the presentation of patterns in
Section~\ref{sec:pattern_matching}, using an identifier within a pattern
declares a new variable that must not be shadowed by another variable with the
same name. For example, in the next listing at line 4, the compiler returns an
error because the pattern declares a new variable \token{x} rather than
evaluating for equality, as it does in the second pattern condition at line 10.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
fn foo ()-> i32?;

let x = 2;
if let Ok (@\hb{x}@) = foo () { // error, shadowing declaration of /x/
  println ("foo () == ", x);
} else {
  println ("Either foo () returned none, or != x");
}

if let Ok (2) = foo () { // ok, value equality test
  println ("foo () returned the value 2")
}
\end{lstlisting}

To solve this problem, and to allow comparison with variables within pattern
matching, the pattern guard was introduced. The pattern guard allows two test
conditions in one line, using the token \token{\&\&} at the end of the syntax
\token{if let Pattern = Value \&\& Test V} to add an extra condition in which the
variables declared within the pattern are accessible. In the next example, the
declaration of the variable \token{y} does not overshadow any other variable and
can therefore be used to compare the value returned by \token{foo} with the
value stored in the variable \token{x} inside the pattern guard. Unlike a second
conditional branch, as presented in
Listing~\ref{lst:using_second_cond_no_guard}, the pattern guard allows the
\token{else} value to be evaluated in case the pattern guard test fails, and
therefore makes writing code easier and less redundant.

\notebox{ Because the pattern guard is introduced by the token \token{\&\&},
  operators of equal and lower precedence (e.g. \token{=}, \token{+=},
  \token{||}, ...) cannot be used directly inside the value accepted by the
  pattern and must be enclosed in parentheses (e.g. \token{if let Ok (x) = (foo ()
    || bar () \&\& baz ())? \&\& guard}).}


\begin{lstlisting}[style=coloredverbatim, caption=Using a pattern guard]
let x = 2;

if let Ok (y) = foo () && y == x {
  println ("foo () returned the value ", y, " which is equal to ", x);
} else {
  println ("Either none, or y != x");
}
\end{lstlisting}

\begin{lstlisting}[style=coloredverbatim, caption=Using a second condition instead of pattern guard, label=lst:using_second_cond_no_guard]
if let Ok (y) = foo () {
  if (y == x) {
    println ("foo () returned the value ", y, " which is equal to ", x);
  } else {
    println ("y != x");
  }
} else {
  println ("foo () returned none");
}
\end{lstlisting}

\vfill%
\pagebreak

\section{Infinite loop}%
\label{sec:inf_loop}

A loop can be defined with the keyword \token{loop}. A loop defined with this
keyword is an infinite loop that never stops unless it is broken with the
\token{break} keyword or terminated by an early function exit (i.e., returning
with the \token{return} keyword, throwing an exception, or panicking). This type
of loop can be useful for managing operations that have no real defined end
(e.g. a worker thread waiting for new tasks, a TCP server waiting for new
connections).

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
loop {
  println ("I will print this message indefinitely");
}
\end{lstlisting}

\subsubsection{Breaking a loop}
\label{sec:breaking_loops}

A break statement with the keyword \token{break} stops loop iterations and exits
its scope. The break statement only breaks one level of the loop, so if multiple
levels of loops are wrapped, then only the lowest level of the loop is broken,
and the iterations of the higher level loops continue. In the following example,
the output result of execution will be a sequence of pairs of \textit{Inner
  Loop} and \textit{Outer Loop}, as the inner loop will only iterate once before
breaking and returning to the upper loop.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
loop {
  loop {
    println ("Inner Loop");
    break;
  }
  println ("Outer Loop");
}
\end{lstlisting}

Any statement after an irrefutable break branch is inaccessible, so the compiler
will raise an error if dead code is found after a break statement.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
loop {
  break;
  println ("Post break"); // error, unreachable statement
}

println ("After loop"); // ok, break only breaks the loop, it does not exit the function
\end{lstlisting}

\subsection {Infinite loop value}

As mentioned earlier, an infinite loop can be broken using the \token{break}
keyword. The break construction can be associated with a value, this value will
be the value taken by the loop after exiting. If multiple breaks are defined in
the loop, they must all produce a value of compatible type. The type of the
loop's value is determined in the same way as the type of the value of an if
condition, by checking all possible branches and calculating the most common
type (cf. Section~\ref{sec:cond_value_type}). The control flow of the next
Listing~\ref{lst:simple_loop_break} is illustrated in
Figure~\ref{fig:simple_loop_break}.

\begin{lstlisting}[style=coloredverbatim, label=lst:simple_loop_break, caption=Breaking a loop with a value]
let mut count = 0;

let x = loop {
  if (count == 10) {
    break count + 1;
  }

  count += 1;
};

assert (x == 11);
\end{lstlisting}

\input{images/simple_loop_break}


In the next example, since the two values declared by the break
constructions are compatible but not equivalent, the type of the breaks is
implicitly cast to \token{\&A}, with the compiler defining the most common type
between the two breaks as the ancestor of the class objects. The same operations
would be done for other compatible types, such as int, char literals with
compatible but not equivalent types.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
class A {
  pub self () {}
}

class B over A {
  pub self () {}
}

class C over A {
  pub self () {}
}

let mut count = 0;
let x = loop {
  if count == 1 {
    break B::new ();
  } else if count = 10 {
    break C::new ();
  }

  count += 1;
};
\end{lstlisting}


\subsubsection {Mutable loop value}

As with the conditional value, the value of a loop construction can be made
mutable. If multiple breaks are defined within the loop, the mutability of the
type of the loop value is reduced to the most restricted mutability among the
break values. In the following example, the mutability of the value on line 8 is
more restricted than the value on line 6, so the mutability of the type of the
loop is the same as that of the break value on line 8.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
let mut count = 1;
let a = copy [2, 3, 4];

let x = loop {
  if count == 1 {
    break copy [1, 2, 3];
  } else if count == 10 {
    break a;
  }

  count += 1;
};
\end{lstlisting}

Since the mutability of the loop value is the same as the mutability of the most
restricted value among the break values, it can borrow mutable data and must
therefore respect the contract of mutable memory movement as defined for scope
values. No \token{alias} is needed above the loop itself, as this has
necessarily already been done on the break values.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
let mut count = 0;
let dmut a = copy [1, 2, 3];

let dmut x = loop { // no need for explicit /alias/
  if count == 10 {
    break alias a; // /alias/ is mandatory here
  }

  count += 1;
};
\end{lstlisting}

\vfill%
\pagebreak

\section{Conditional loop}%
\label{sec:while_loop}

Conditional loops continue iterating as long as a specified condition remains
true. They are initialized with the keyword \token{while} and follow the syntax
\token{while C V}, where \token{C} represents the condition that must be
satisfied, and \token{V} is the value evaluated while the condition remains
true. Similar to conditional branching, the condition \token{C} must be of type
\token{bool}. The following example showcases a while loop that iterates five
times before exiting. Its control flow is illustrated in
Figure~\ref{fig:simple_while_loop}

\begin{lstlisting}[style=coloredverbatim, caption=Simple while loop, label=lst:simple_while_loop]
let mut count = 0;

while count < 5 {
  count += 1;
}

assert (count == 5);
\end{lstlisting}

\input{images/simple_while_loop}

\subsection{Do-while loop}
\label{sec:do_while_loop}

While loops are activated if the associated condition is true from the outset.
In contrast, do-while loops, first execute the loop body before evaluating the
loop condition. This guarantees that the loop body runs at least once,
irrespective of whether the condition is initially false. Do-while loops are
defined with the syntax \token{do V while C;}, where \token{V} represents the
value evaluated upon entering the loop, and \token{C} is the condition that
halts the loop when it evaluates to \token{false}.

\begin{lstlisting}[style=coloredverbatim, caption=Simple do while loop, label=lst:simple_do_while_loop]
let mut count = 0;

do {
  count += 1;
} while count < 5;

assert (count == 5);
\end{lstlisting}

\input{images/simple_do_while_loop}

\subsection{While-let loop}
\label{sec:while_let_loop}

In conditional branching, as discussed in Section~\ref{sec:cond_pattern}, a
pattern can serve as the condition. This capability, similar to its usage in if
conditionals, is available for while loops. However, it is not applicable for
do-while loops. In the following given example, the loop continues as long as
the option contained within the variable \token{x} holds a value and halts
either when it doesn't hold a value or when its value exceeds \token{5}. The
code presented in Listing~\ref{lst:while_let_rewritten} exhibits identical
behavior, albeit implemented using a loop construct and an if let conditional,
as the compiler rewrites the code from Listing~\ref{lst:while_let_example}.

\begin{lstlisting}[style=coloredverbatim, caption=While-let example, label=lst:while_let_example]
fn foo (i : i32)-> i32?;

let mut x = foo (0);
let mut count = 0;

while let Ok (z) = x && z < 5 {
  count += 1;
  x = foo (count);
}
\end{lstlisting}

\begin{lstlisting}[style=coloredverbatim, caption=While-let rewritten using loop and if-let, label=lst:while_let_rewritten]
fn foo (i : i32)-> i32?;

let mut x = foo (0);
let mut count = 0;

loop {
  if let Ok (z) = x && z < 5 {
    count += 1;
    x = foo (count);
  } else break;
}
\end{lstlisting}

As one might expect, since while-let is merely a syntactic transformation into a
loop over an if pattern condition, all the pattern and guard systems discussed
in Section~\ref{sec:cond_pattern} are applicable to the while-let construction.

\subsection{While loop value}

While loops don't inherently produce any values, as there's no assurance that
the loop will be entered and a value constructed. Conversely, do-while loops are
guaranteed to be entered at least once, potentially allowing for a value to be
constructed. However, to maintain consistency with basic while loops, it was
decided not to allow value construction from do-while loops. In essence, only
infinite loops defined with the \token{loop} keyword have the capability to
construct a value. As a consequence, a \textit{break} statement within a
\textit{while} or \textit{do-while} loop cannot be linked with a value and must
always yield a \token{void} result.


\vfill%
\pagebreak

\section{Iteration loop}%
\label{sec:for_loop}

The keyword \token{for} initiates an iteration loop that traverses over a value.
As discussed in Chapter~\ref{chap:compound}, certain values such as arrays,
tuples, and slices can be iterated over using variables. The syntax of a
\textit{for} loop is as follows: \token{for i, j,... in V}, where \token{i, j,
  ...} represents a list of variable declarations, and \token{V} denotes the
value being iterated over. For loops are applicable to some native compound
types and to custom class types that implement the \textit{for loop} operator,
as detailed in Chapter~\ref{sec:class_override_for_loop}.

For clarity, throughout the rest of this section, the variable representing the
value at the current iteration will be denoted as a \textit{value iterator},
typically depicted by the variable \textit{v}. Similarly, the variable holding
the index will be termed an \textit{index iterator}, usually depicted by the
variable \textit{i}.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
let a = copy [1, 2, 3];

for i, v in a {
  println ("Value at index : ", i , " equals to : ", v);
}
\end{lstlisting}

The type of the iterator is automatically inferred, but it can be explicitly
specified by appending the token \token{:} followed by the desired type.
However, the specified type must match the type that would have been inferred.
The primary purpose of explicitly specifying the type is to allow for mutability
modifications.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
let a = copy [1, 2, 3];

for i : usize, v : i32 in a {
  println ("Value at index : ", i , " equals to : ", v);
}
\end{lstlisting}

The index iterator is inherently immutable, meaning decorators cannot be
attached to its declaration. Index iterators are accessible for all iterable
native compound types, such as range, tuple, array, and slices. For tuples,
slices, and arrays, a single iterator serves as the value iterator by default.
However, if two iterators are defined, the first one is the index iterator,
while the second one becomes the value iterator. Conversely, for ranges, only
one iterator can be declared, and it acts as the index iterator.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
for i in 0 .. 10 {
  println ("Index iteration : ", i);
}

for v in [1, 2, 3] {
  println ("Value iteration : ", v);
}

for i, v in [1, 2, 3] {
  println ("Value and index iteration : ", i, ' ', v);
}
\end{lstlisting}

\subsection {Mutable value iterator}
\label{sec:mut_value_iterators}

In line with any variable declaration, the value iterator is initially immutable
by default. However, it can be rendered mutable by using the keywords
\token{mut} or \token{dmut}. Because iterators index the values being iterated,
they don't behave like typical variables but rather resemble function
parameters. As discussed in Section~\ref{sec:mutable_parameter}, even though
function parameters can be mutable, they aren't \textit{lvalues} unless they're
reference parameters. This is because completely altering their value would
change the memory address of the value they're borrowing, thereby having no
impact on the initially assigned value.

For the same reason, value iterators can only be mutable if they are associated
with mutable borrowed data, explicitly aliased to them. In the following
example, the variable \token{v} is mutable and borrows the same memory segments
as the elements contained in \token{a[i]}. Because it is mutable, it can modify
the values that are borrowed but cannot be completely changed.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
let dmut a = dcopy [[1, 2], [3, 4]];
for dmut v in alias a {
  v [0] = 10; // ok, aliasing /a/
  @\hb{v = copy [8, 9];}@ // error, /v/ is not a lvalue
}

assert (a [0][0] == 10);
\end{lstlisting}

Because value iterators are not lvalues, they cannot be mutable if they do not
borrow mutable data. Without access to mutable elements to modify, the
mutability of the variable would be pointless, as it would have no effect on the
iterated value.

\begin{lstlisting}[style=coloredverbatim, escapechar=@, caption=Useless mutable iterator, label=lst:useless_mut_iterator]
let dmut a = copy [1, 2, 3];
for @\hb{mut}@ v in alias a { // error, x cannot be mutable, it does not borrow mutable data
  @\hb{v = 1;}@ // would have no effect on /a/
}
\end{lstlisting}

\subsection{Reference iterators}

The \token{ref} keyword can be applied as a decorator to the value iterator.
This decorator alters the behavior of the iterator, providing reference access
to the values being iterated rather than copying the value at each index. This
can be beneficial when iterating over large datasets contained within the
iterated value, such as a slice of arrays (e.g., \token{[[c8; 1024]]}). In the
following example, both loops exhibit the same behavior, but the second one is
expected to be faster. To be utilized as a reference value, the value being
iterated must be an lvalue and does not necessarily need to be mutable (as long
as the reference value iterator itself is not mutable; for details on mutable
reference value iterators, refer to the next subsection).

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
let a : [[i32 ; 1024]] = copy [[0 ; 1024], [1 ; 1024]];
for v in a { // copy 1024 i32, at each iteration
  println (v);
}

for ref v in a { // reference, copying only 1 pointer (8 bytes)
  println (v);
}
\end{lstlisting}

This type of reference value iterator can be utilized with tuples, arrays, or
slices. In the following example, the first for loop at line 2 creates a copy of
the values contained in the tuple, while the second loop at line 5 iterates
using references, thereby avoiding the need to copy 110 \textit{i32} values.
Similarly, the loops for an array value make copies at line 10 and iterate by
reference at line 13. The Ymir Semantic Language reveals these differences,
transforming the loop at line 2 into the one depicted in
Listing~\ref{lst:copy_value_iter_tu} and the loop at line 5 into the one shown
in Listing~\ref{lst:ref_value_iter_tu}.

\begin{lstlisting}[style=coloredverbatim, caption=iteration using reference value iterator, label=lst:ref_value_iter_ex]
let a = ([0 ; 100], [1 ; 10]);
for v in a {
  println (v);
}

for ref v in a {
  println (v);
}

let b : [[i32 ; 1024] ; 2] = [[0 ; 1024], [1 ; 1024]];
for v in b {
  println (v);
}

for ref v in b {
  println (v);
}
\end{lstlisting}

\begin{lstlisting}[style=myilVerb, caption=By copy iteration on a tuple, label=lst:copy_value_iter_tu]
cte for {
  {
    let v(#48) : [i32 ; 100us] = [0 ; 100us];
    {
      std::io::println!{[i32 ; 100us]}::println (v(#48));
      <unit-value>
    }
  };
  {
    let v(#s7) : [i32 ; 10us] = [1 ; 10us];
    {
      std::io::println!{[i32 ; 10us]}::println (v(#s7));
      <unit-value>
    }
  }
};
\end{lstlisting}

\begin{lstlisting}[style=myilVerb, caption=By reference iteration on a tuple, label=lst:ref_value_iter_tu]
cte for {
  {
    let ref v(#1gd) : [i32 ; 100us] = ref (a(#3t).0);
    {
      std::io::println!{[i32 ; 100us]}::println (v(#1gd));
      <unit-value>
    }
  };
  {
    let ref v(#1hd) : [i32 ; 10us] = ref (a(#3t).1);
    {
      std::io::println!{[i32 ; 10us]}::println (v(#1hd));
      <unit-value>
    }
  }
};
\end{lstlisting}

\subsection{Mutable reference iterator}

A reference iterator can be rendered mutable by decorating it with the keywords
\token{mut} or \token{dmut}. It adheres to the same guidelines as any mutable
reference variable or parameter (see Section~\ref{sec:mut_ret_param}),
indicating that the iterator variable itself is mutable, and any modifications
to it directly impact the referenced value. The value being iterated must
conform to the mutability level of the iterator, and the contract must be
acknowledged by decorating the iterated value with the keyword \token{ref}.

In the following example, the value iterator is a mutable reference to the
values contained in the slice value stored in the variable \token{a}. Because
the iterator is a mutable reference iterator, it is an lvalue (as opposed to a
simple mutable iterator, which would not be applicable here - see
Listing~\ref{lst:useless_mut_iterator}), and therefore can be modified. After
the end of the \textit{for} loop, the values contained in the slice stored in
\token{a} are modified.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
let dmut a = copy [1, 2, 3];

for i, ref mut v in ref a {
  //                ^^^ mandatory
  v = cast!i32 (i) + 9;
}

assert (a == [9, 10, 11]);
\end{lstlisting}

The iterator must be compatible with the mutability level of the iterated value.
In the following example, at line 4, the iterator is deeply mutable. However,
the variable \token{a} only has partial mutable access to the value it borrows,
meaning it can modify only the first level, but not the values stored in the
inner slices. On the other hand, at line 9, the iterator is only one level
mutable, matching the mutability level of \token{a}. As a result, it will modify
the values stored in \token{a} without altering the values stored within the
inner borrowed slices.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
let y = copy [3, 4];
let mut a : [mut [i32]] = dcopy [[1, 2], y];

for @\hb{ref dmut}@ v in ref a {
  //    ^^^, error, incompatible mut [i32] -> mut [mut i32]
  @\hb{v [0] = 9;}@ // would modify values that /a/ does not own
}

for ref mut v in ref a {
  //    ^^^ Ok, slice in /a/ is mutable
  v = copy [10, 11];
}

assert (a [0] == [10, 11]);
assert (a [1] == [10, 11]);
assert (y == [3, 4]); // /y/ is untouch as guaranteed

\end{lstlisting}

\vfill%
\pagebreak

\section{List comprehension}%
\label{sec:list_compr}

List comprehension is a concise method for creating arrays, slices, or tuples
using a single line of code. It applies an expression to each item in a list by
iterating over an iterable, similar to a standard for loop. The syntax \token{[V
    for i, j ... in Iter]} and \token{(V for i, j ... in Iter,)}. In the next
example at line 1, an array of size \textit{10} is created by iterating over a
range value. In this example, an array value can be created because the number
of iteration of the for loop can be computed at compile time. Because the size
is known, a tuple value can be created using the same principle as presented at
line 3.

\begin{lstlisting}[style=coloredverbatim]
let a = [i^^2 for i in 0 .. 10];

let b = (i^^2 for i in 0 .. 10,);
//      Note the coma         ^, which is mandatory to create a tuple
\end{lstlisting}

When the size cannot be known at compile time, for example when the iteration is
made on a slice value, then one cannot create a tuple or an array value, but can
still create a slice value, that is allocated during runtime. In the next
example, the keyword \token{copy} performs a dynamic allocation of the correct
size, that is computed during runtime. At line 6, the compiler being unable to
compute the size of the array at compile time, rejects the code by sending an
error, for the same reason the tuple list comprehension at line 7 is also
rejected.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
fn foo ()-> [i32];

let x = foo ();
let a = copy [i^^2 for i in x]; // compute the square of each element of the slice /x/

let b = @\hb{[i for i in x];}@ // error, size of array is not cte
let c = @\hb{(i for i in x,);}@ // error, arity of tuple not cte
\end{lstlisting}

To be used as an iterable value in a list comprehension, the value must be
iterable using a standard \token{for} loop and must have a computable length
before entering the loop. This size can be known at compile time (to create an
array or a tuple) or only at runtime (to create a slice). The four native
iterable values for list comprehension are slices, arrays, tuples, and ranges.
Custom class types can override the list comprehension operator, as discussed in
Chapter~\ref{sec:class_override_lst_compr}.

\subsection{Mutable and reference value iterators}

In the previous section on \token{for} loops, we discussed that iterators can be
references and mutable, depending on the type of the value being iterated. In
list comprehension, the value iterator can be a reference but cannot be mutable.
The primary purpose of list comprehension is to create new values, not to modify
existing ones. Allowing the modification of the iterated value during the
creation of another value would result in two operations happening
simultaneously, leading to potentially confusing programming patterns that we
believe should be avoided. However, the iterator can still be a reference to
avoid copying values during iterations, such as when iterating over a slice of
array values. In the following listing, the list comprehension is forbidden
because it attempts to modify the values contained in \token{a}.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
let dmut a = dcopy [[1, 2], [3, 4]];

let dmut b = copy [{
    @\hb{v[0] = 1;}@ // error, v cannot be mutable
    v[1]
} for @\hb{dmut}@ v in @\hb{alias}@ a]; // error, cannot make a mutable value iterator
\end{lstlisting}

One can still modify the value \token{a} by using a direct reference. This
approach does not hinder optimization. In the following example, a single loop
performs two operations at each iteration, rather than requiring two separate
loops as shown in the next Listing~\ref{lst:compr_two_loops}.

\begin{lstlisting}[style=coloredverbatim, caption=Modify existing value during list comprehension]
let dmut a = dcopy [[1, 2], [3, 4]];

let dmut b = copy [{
    a [i][0] = 9; // ok, /a/ is directly referenced
    v [1]
} for i, ref v in a]; // ok, iterating by const reference

assert (a [0] == [9, 2]);
assert (b == [2, 4]);
\end{lstlisting}

\begin{lstlisting}[style=coloredverbatim, caption=Using two loops]
let dmut a = dcopy [[1, 2], [3, 4]];

let dmut b = copy [v [1] for ref v in a]; // ok, iterating by const reference
for ref dmut v in ref a { // second loop to modify /a/
  v [0] = 9;
}

assert (a [0] == [9, 2]);
assert (b == [2, 4]);
\end{lstlisting}

\subsection {YIL representation}

List comprehensions that iterate over a tuple value or create a tuple value are
unfolded at compile time to generate a literal value. The following
Listings~\ref{lst:list_compr_tuple_iter} and~\ref{lst:list_compr_tuple_create}
produce the YIL (Ymir Intermediate Language) representation shown respectively
in Listings~\ref{lst:list_compr_tuple_iter_yil}
and~\ref{lst:list_compr_tuple_create_yil}.

\begin{lstlisting}[style=coloredverbatim, label=lst:list_compr_tuple_iter, caption=List comprehension iterating over a tuple]
let a = (1, 2, 3);
let b = [i for i in a];
\end{lstlisting}

\begin{lstlisting}[style=lyilVerb, label=lst:list_compr_tuple_iter_yil, caption=YIL representation of Listing~\ref{lst:list_compr_tuple_iter}]
a(#2) = (1, 2, 3);
i(#3) = a(#2)._0;
i(#5) = a(#2)._1;
i(#7) = a(#2)._2;
YI_9(#9) = [i(#3), i(#5), i(#6)];
\end{lstlisting}

\begin{lstlisting}[style=coloredverbatim, label=lst:list_compr_tuple_create, caption=List comprehension iterating over a tuple]
let a = [1, 2, 3];
let b = (i for i in a,);
\end{lstlisting}

\begin{lstlisting}[style=lyilVerb, label=lst:list_compr_tuple_create_yil, caption=YIL representation of Listing~\ref{lst:list_compr_tuple_iter}]
a(#1) = [1, 2, 3];
YI(#3) = (len-> 3, ptr-> &a(#2));
#_value(#4) = YI(#3);
#_iter(#5) = 0;
YI(#6) = 4 * #_iter(#5);
YI(#7) = #_value(#4).ptr + YI(#6);
YI(#8) = cast!{*(i32)} (YI(#7));
i(#9) = *YI(#8);
#_iter(#5) = 1;
YI(#b) = 4 * #_iter(#5);
YI(#c) = #_value(#4).ptr + YI(#b);
YI(#d) = cast!{*(i32)} (YI(#c));
i(#e) = *YI(#d);
#_iter(#5) = 2;
YI(#g) = 4 * #_iter(#5);
YI(#h) = #_value(#4).ptr + YI(#g);
YI(#i) = cast!{*(i32)} (YI(#h));
i(#j) = *YI(#i);
b(#l) = (i(#9), i(#e), i(#j))
\end{lstlisting}

On the other hand, list comprehensions that create a slice or an array from a
range, a slice, or an array value generate a loop that is executed at runtime.
The following Listings~\ref{lst:list_compr_range_iter}
and~\ref{lst:list_compr_array_iter} produce the YIL (Ymir Intermediate Language)
representation shown respectively in
Listings~\ref{lst:list_compr_range_iter_yil}
and~\ref{lst:list_compr_array_iter_yil}.

\begin{lstlisting}[style=coloredverbatim, label=lst:list_compr_range_iter, caption=List comprehension iterating over a range]
let a = [i for i in 0 .. 10];
\end{lstlisting}

\begin{lstlisting}[style=lyilVerb, label=lst:list_compr_range_iter_yil, caption=YIL representation of Listing~\ref{lst:list_compr_range_iter}]
    #_iter(#1) = 0;
#GOTO test(#3);
#LABEL beg(#2);
    i(#4) = cast!{i32} (#_iter(#1));
    #_value(#2)[#_iter(#1)] = i(#4);
    #_iter(#1) = #_iter(#1) + 1;
#LABEL test(#3);
    YI_3(#3) = #_iter(#1) < 10;
#IF YI_3(#3)
#THEN_GOTO beg(#2)
#ELSE_GOTO end(#1);
#LABEL end(#1);
    a(#8) = #_value(#2);
\end{lstlisting}

\begin{lstlisting}[style=coloredverbatim, label=lst:list_compr_array_iter, caption=List comprehension iterating over an array]
let mut a = [1, 2, 3];
let b = [i for i in a];
\end{lstlisting}

\begin{lstlisting}[style=lyilVerb, label=lst:list_compr_array_iter_yil, caption=YIL representation of Listing~\ref{lst:list_compr_array_iter}]
    a(#2) = [1, 2, 3];
    #_value(#4) = (len-> 3, ptr-> &a(#2));
    #_iter(#6) = 0;
#GOTO test(#3);
#LABEL beg(#2);
    YI_8(#8) = 4 * #_iter(#6);
    YI_9(#9) = #_value(#4).ptr + YI_8(#8);
    YI_10(#a) = cast!{*(i32)} (YI_9(#9));
    i(#b) = *YI_10(#a);
    #_out(#5)[#_iter(#6)] = i(#b);
    #_iter(#6) = #_iter(#6) + 1;
#LABEL test(#3);
    YI_7(#7) = #_iter(#6) < 3;
#IF YI_7(#7)
#THEN_GOTO beg(#2)
#ELSE_GOTO end(#1);
#LABEL end(#1);
    b(#e) = #_out(#5);
\end{lstlisting}

One can note from Listings~\ref{lst:list_compr_tuple_iter_yil}
and~\ref{lst:list_compr_array_iter_yil} that the iteration over an array value
actually creates a slice over the array value that is iterated. This allows to
use the exact same system for slice and array iterations (the same thing is
performed for \token{for} loops) as slices are pointer to an array value with a
specific length.

\subsection{Specifics to slice value iteration}

As discussed in Section~\ref{sec:slice_expansion}, slices can be expanded when
their size is forcibly defined using an index operated with a range operand.
This system can also be used to iterate over a slice value within a list
comprehension to create an array or a tuple, where the size must be known at
compile time. In practice, because the size of the slice cannot be effectively
checked at compile time, a runtime check is added to ensure that the slice
contains enough values to respect the index operation.

\begin{lstlisting}[style=coloredverbatim, label=lst:list_compr_slice_to_array, caption=List comprehension over a slice with cte size]
fn foo ()-> [i32];

let a = foo ();
let b = [i for i in a [0 .. 3]]; // ok, array of size 3
let c = (i for i in a [0 .. 2],); // ok, tuple of arity 2
let d = copy [i for i in a]; // ok, creates a new slice
\end{lstlisting}

In the above example, the \token{copy} operator is used to create a slice value
that is stored in the variable \token{d}. This copy operator does not actually
make a copy of the value returned by the list comprehension. Instead, it informs
the compiler that the list comprehension must create a heap allocation for the
value it will generate. This ensures that only one allocation is made, resulting
in a value that is exactly the same as \token{copy a}.

In addition, if the function \token{foo} returns a slice value with fewer than 3
elements, the program will panic at runtime. This occurs because the list
comprehension at line 4 requires at least 3 values. Since this check cannot be
performed at compile time, it is done at runtime, resulting in a panic if the
requirement is not met.

\vfill%
\pagebreak

\section{Scope guards}%
\label{sec:scope_guards}

Scope guards are a programming construct utilized to ensure that specific
operations are executed automatically upon exiting a scope. These guards are
commonly employed for tasks such as cleanup actions, error recovery, or managing
resources. There are two main types of scope guards: scope exiting and error
handling. The former, discussed in Section~\ref{sec:exit_guards}, is declared
following a scope declaration using one of three keywords: \token{exit},
\token{success}, or \token{failure} (e.g., \token{\{ ... \} exit \{ ... \}}). The
latter, discussed in Section~\ref{sec:catching_errors}, is declared with the
keyword catch and is utilized to handle exceptions thrown within a specific
scope, employing the syntax \token{\{...\} catch { Pattern => V }}


\begin{lstlisting}[style=coloredverbatim]
fn foo ()-> i32
  throws AssertError;

{
  foo ();
} exit {
  println ("Called foo");
} catch {
  AssertError () => {
    println ("Foo has failed!");
  }
}
\end{lstlisting}

\subsection{Exit guards}
\label{sec:exit_guards}

The \token{exit} guard serves as a scope guard designed to execute an action
when a scope is exited, regardless of the success or failure of the guarded
scope. In contrast, the scope guards \token{failure} and \token{success} are
activated under specific conditions upon exiting the scope. The guard
\token{failure} is triggered when the scope throws an exception, while the guard
\token{success} is triggered when the scope exits normally. These scope guards
can be highly beneficial for managing resources that require disposal or for
calling functions that must execute at the end of a scope.

\smallskip

In the provided example, the code at line 10 is executed irrespective of whether
the \token{foo} function succeeds or fails. Conversely, the code at line 14 is
executed solely if the \token{foo} function exits normally, whereas the code at
line 12 is exclusively executed in the event of \token{foo} failing.

\begin{lstlisting}[style=coloredverbatim]
fn foo ()-> i32
  throws AssertError
{
  // ...
}

{
  foo ();
} exit {
  println ("Foo was exited");
} failure {
  println ("Foo failed");
} success {
  println ("Foo succeeded");
}
\end{lstlisting}

Exit scope guards lack access to variables declared within the scope they guard.
Specifically, \token{exit} and \token{failure} cannot ensure that variables
declared within the guarded scope are constructed. While \token{success} could
potentially guarantee this access, it adheres to the same behavior as other
scope guards and also lacks access to variables declared within the guarded
scope. In the following example, line 4 is prohibited as the variable \token{a}
no longer exists (and might have never been constructed).

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
{
  let a = foo ();
} exit {
  println ("Foo returned : ", @\hb{a}@); // error, a does not exists here
}
\end{lstlisting}

Exit scope guards cannot throw exceptions, return early from functions, break
loops, or generate values. They may execute in contexts where the program is
already throwing an exception (e.g., the \token{failure} scope is only triggered
in such contexts) or in contexts that have already triggered a break or an early
function return. Allowing exit scope guards to throw exceptions, return early,
or break loops would result in two exceptions being thrown simultaneously or two
values being returned, which is nonsensical. Additionally, scope guards do not
generate values; the value of a guarded scope is the value generated by the
scope itself. Scope guards are solely used to execute actions once this value is
generated (or failed to be generated), not to handle errors or provide a
different value. For error handling, a \token{catch} scope guard can be
utilized, as will be presented in the subsequent subsection.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
let a = {
    1
} exit {
  @\hb{2}@ // error, scope guard value must be of type /void/
};
// If it was allowed, what would be the value of /a/ here?

{
  throw AssertError ("First exceptions");
} failure {
  @\hb{throw AssertError ("Second exception");}@ // error, scope guard can't throw exceptions
};
// If it was allowed, which would be the thrown error?

{
  return 1;
} success {
  @\hb{return 8}@; // error, exit scope guard cannot return a value
}
// And what would the function actually return ?
\end{lstlisting}

Exit scope guards can indeed be utilized to dispose of a class object, as
demonstrated in the following example. It's important to note that defining the
variable \token{f} within the scope guarded by the exit at line 6 wouldn't be
feasible, as it wouldn't be accessible within the scope guard and thus wouldn't
be disposable. However, it is not the preferred method. Instead, a disposing
scope declaration (refer to Section~\ref{sec:dispose_block}) is recommended for
such purposes.

\begin{lstlisting}[style=coloredverbatim]
use std::fs; // for File

let dmut f = File::create ("file.txt", write-> true);
{
  f.write ("content");
} exit {
  f.dispose ();
}

f.write ("other content"); // ok, but file was disposed so it will throw
\end{lstlisting}

For code clarity, the guards \token{failure} and \token{success} should only be
used if the guarded scope can throw exceptions. Otherwise, they would either
never be executed or be strictly equivalent to an \token{exit} guard.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
{
  println ("In scope");
} @\hb{failure}@ { // error, never used
  println ("Failed to print ??");
} @\hb{success}@ { // error, always executed, thus exit must be used instead
  println ("Succeed to print");
}
\end{lstlisting}

\vfill%
\pagebreak

\section{Handling exceptions}
\label{sec:catching_errors}

Exceptions are handled using a specific scope guard named \token{catch}. Unlike
other scope guards, this one has a distinct syntax and encloses a list of
patterns similar to those found in pattern matching expressions. The patterns in
\token{catch} scope guards are used to match the caught exception, allowing only
variable declarations and field deconstructors to be used, as these are the only
patterns relevant for matching over an object.


\begin{lstlisting}[style=coloredverbatim]
fn foo ()
  throws AssertError;

fn main () {
  {
    foo ();
  } catch {
    a : &AssertError => {
      println ("Caught an assert error with message : ", a.msg);
    }
  }

  println ("Continuing normally");
}
\end{lstlisting}

The types of exceptions that can be caught by the \token{catch} scope guard
include all exceptions thrown within the guarded scope. It is mandatory for the
scope guard to catch all exceptions; there is no automatic rethrowing of
uncaught exceptions as might be done in other programming languages.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
fn foo (x : i32?)
  throws AssertError, EmptyValOption;

fn main () {
  {
    foo (none);
  } catch {
    @\hb{EmptyErrOption ()}@ => { // error, foo cannot throw EmptyErrOption

    }
    EmptyValOption () => {
      println ("Option was empty");
    }
    @\hb{\}}@ // error, AssertError exception is not caught
  }
}
\end{lstlisting}

\subsection{Exception rethrowing}

Because exceptions are not rethrown automatically if not caught, a \token{catch}
scope guard that does not throw any exception is considered safe (in the sense
that it does not throw, though it might still panic or trigger unsafe
operations). A \token{catch} scope guard can throw an exception like any other
classical scope, using the keyword \token{throw} or by calling a function that
throws an exception. Unlike other scope guards (exit, success, and failure), a
\token{catch} scope guard is only triggered if the guarded scope fails to
produce a value, and since the exception is caught, only one path leads out of
the flow graph from the scope guard. For that reason, scopes declared within a
\token{catch} scope guard have the same properties as standard scopes (can
break, generate or return a value, throw exceptions, etc.).


\begin{lstlisting}[style=coloredverbatim]
{
  foo ();
} catch {
  EmptyValOption () => {
    println ("Recovering");
  }
  e => { // catch every other exceptions
    throw e; // and rethrow them
  }
}

println ("Foo succeeded, or we successfully recovered from the error");
\end{lstlisting}

Since scopes guarded by \token{catch} scope guards that are not rethrowing are
not throwing exceptions, they can be used inside a function that does not throw,
or within a context that does not allow for exception throwing (such as an exit
scope guard, lambda function, etc.). In the next example, even though the
exception \token{AssertError} is thrown at line 5, it is caught by the scope
guard at line 7, thus allowing it to be used within an \token{exit} scope guard.

\begin{lstlisting}[style=coloredverbatim]
{
  println ("Start");
} exit {
  {
    throw AssertError::new ("Error");
  } catch {
    AssertError (msg-> msg) => {
      println ("Catching msg : ", msg);
    }
  }

  println ("Exit");
}
\end{lstlisting}

\subsection{Guarded scope value}

When a scope that is supposed to generate a value fails (by throwing an
exception), a \token{catch} scope guard can be used to define the value that
will be generated instead. All scopes (triggered by the different patterns)
within a \token{catch} scope guard must define a value of the same type as the
value that would be generated by the guarded scope in the case of success (with
the exception of scopes that early break, return, or throw an exception, of
course). The same principle introduced in Section~\ref{sec:cond_value_type} is
used to infer the type of the value generated by the different branches. Indeed,
catch scope guards can be seen as \token{else} conditional branches that are
entered when an exception is thrown instead of a condition being unmet.

\begin{lstlisting}[style=coloredverbatim]
fn foo ()-> i32
  throws AssertError;

fn main () {
  let a = {
    foo () // value of foo, if foo succeeds
  } catch {
    _ => { 0 } // 0 if foo fails
  };

  println (a); // a is always correctly set
}
\end{lstlisting}


\subsection{Guarded scope mutable value}

As with the mutability inferred when dealing with conditional branches, the
value of a scope guarded by a \token{catch} scope guard adopts the mutability of
the branch with the fewest permissions. In the following example, because the
value generated by the \token{catch} pattern scope at line 11 is less mutable
than the type returned by the function \token{foo} at line 7, its mutability is
chosen. Essentially, everything related to value inference in branch values
applies to the \token{catch} scope guard.

\begin{lstlisting}[style=coloredverbatim]
fn foo ()-> dmut [i32]
  throws AssertError;

fn main () {
  let x = copy [1, 2, 3];
  let a = {
    foo ()
  } catch {
    AssertError (msg-> m) => {
      println ("Message of the assert error : ", m);
      x
    }
  };

  let dmut b = {
    foo ()
  } catch {
    _ => {
      copy x // ok, creates a dmut [i32]
    }
  };
}
\end{lstlisting}

\subsection{Breaking and early returns}

We have seen that since \token{catch} scope guards are triggered only when the
guarded scope has failed to continue, they can generate values and throw
exceptions. For the same reason, such scope guards can be used to break loops or
return from functions early, using the keywords \token{break} and
\token{return}, respectively. In these contexts, the rules presented in
Section~\ref{sec:function_early_return} and Section~\ref{sec:inf_loop} apply.

\begin{lstlisting}[style=coloredverbatim]
let mut i = 0;
let nbIters = loop {
  {
    foo ();
    i += 1;
  } catch {
    _ => break i;
  }
};

println ("Foo function ran ", nbIters, " times before failing");
\end{lstlisting}

\begin{lstlisting}[style=coloredverbatim]
fn bar ()-> i32 {
  let x = {
    foo ()
  } catch {
    _ => {
      println ("Foo failed, simply returning 1");
      return 1;
    }
  };

  println ("Value of foo : ", x);
  x + 1
}
\end{lstlisting}

\subsection{Scope guard priority}

Multiple scope guards can be attached to the same scope by declaring them one
after the other. Although they can be defined in any order, they are always
executed in the sequence: \token{catch}, \token{success} or \token{failure}, and
finally \token{exit}. The scope guards \token{catch} and \token{success} are
never executed together, as the \token{success} scope guards are executed only
when the scope they are guarding successfully finishes. For the same reason,
\token{failure} and \token{success} cannot be executed together, but the
\token{failure} scope guard is always executed after catching exceptions. In all
cases, the \token{exit} scope guard is always executed last.

\begin{lstlisting}[style=coloredverbatim]
{
  foo ();
} catch {
  e => println ("Caught an execption : ", e);
} failure {
  println ("Scope failed");
}
\end{lstlisting}

\vfill%
\pagebreak

\section{Threads synchronization}
\label{sec:thread_sync}

\vfill%
\pagebreak

\section{Disposing scope declaration}%
\label{sec:dispose_block}

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
use std::fs; // for File

with dmut f = File::create ("file.txt", write-> true) {
  f.write ("content");
} // call f.dispose ();

@\hb{f}@.write ("other content"); // error, /f/ variable does not exists
\end{lstlisting}
