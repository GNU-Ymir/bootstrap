\section{Preamble}

Variables can be declared at three different locations: 1) as a global variable,
as presented in Section~\ref{sec:global_variables}, 2) as a function parameter
variable, as presented in Section~\ref{sec:function_parameters} and 3) as a local
variable. In every case, the variable is identified by a symbolic name and has a
type that cannot be changed. This type describes the value associated with the
variable. The value can be located on the stack (for local variables and
function parameters), on the heap if the value is a borrowing value (for all
three kinds of variables), or in the text segment for global variables.

\section{Variable declaration}
\label{sec:local_variable_declaration}

This section presents how variables are declared within a source file,
describing their syntax and the purpose of each part.

\subsection{Grammar of a variable declaration}

There are three different kinds of variables that can be declared in Ymir:
local, parameter, and global variables. Global and parameter variables can be
declared using only one syntax. On the other hand, local variables can be
declared using four different syntaxes, each with a distinct purpose and
behavior, often used to deconstruct values in specific ways. The syntax
declarations for these types of variables are summarized in this subsection.

\subsubsection*{Global variable}

A global variable is declared at the global scope using the keyword
\token{lazy}. The keywords \token{mut} or \token{dmut} are optional and describe
the mutability property of the variable. Global variables, being lazy, have
specific mutability behaviors that are detailed in
Section~\ref{sec:variable_lazy_mut}. The identifier of a variable follows the
same syntax as any identifier in Ymir. The type part of the variable declaration
is optional (cf. Section~\ref{sec:variable_type}), and its syntax is any
expression that can describe a type. The value part of the declaration is
mandatory for a global variable (cf. Section~\ref{sec:variable_init_value}), and
its syntax is any expression that can describe a value.

\begin{lstlisting}[style=bashVerb]
global_variable := 'lazy' ('mut' | 'dmut')? Identifier (':' type)? '=' value ';'
\end{lstlisting}

\subsubsection*{Parameter variable}

A parameter variable is declared within the list of parameters of a function
declaration. The follow the syntax presented in the listing below. The
identifier of a variable follows the same syntax as any identifier in Ymir. The
type part of the variable declaration is mandatory (cf.
Section~\ref{sec:variable_type}), and its syntax is any expression that can
describe a type. The value part of the declaration is optional for a parameter
variable (cf. Section~\ref{sec:variable_init_value}), and its syntax is any
expression that can describe a value.

\begin{lstlisting}[style=bashVerb]
parameter_variable := decorator Identifier ':' type ('=' value)?
\end{lstlisting}

\subsubsection*{Local variable}
\subsubsection*{Iterator variable}
\subsubsection*{Pattern variable}
\subsubsection*{Disposable variable}

\subsection{Variable lifetime and shadowing}

The lifetime of a local and parameter variable begins when it is declared and
ends when the scope containing the variable declaration is exited. Two variables
with the same name cannot be alive at the same time. Defined by opening and
closing curly braces, a scope determines the lifetime of the variables declared
within it.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
fn main () { // start of a scope
  let a = 12;
  { // start of a second scope

    println (@\hb{b}@ + a); // error, /b/ is not defined yet
    let b = 24;

    println (b + a); // Ok, /b/ and a are defined

    let @\hb{a}@ = 89; // error, /a/ is already defined
  } // exiting the second scope

  println (@\hb{b}@ + a); // Error, /b/ does not exist anymore
  let b = 9; // ok, /b/ from second scope is not alive anymore
}
\end{lstlisting}

Global variables have no specific lifetime; they exist from the start of the
program until its end. Therefore, they are accessible at any point of time, and
from anywhere that has public access to them, as discussed in
Section~\ref{sec:symbol_protection}.

Because global variables are accessible from their parent symbol (the module in
which they are described), there is a way to avoid variable shadowing problems.
If two global variables with the same name cannot be declared within the same
module, a global variable never shadows the declaration of a local or a
parameter variable. In the following example, the local variable \token{pi}
declared at line 6 is allowed because it is not shadowed by the global variable
declared at line 3. However, the declaration of the local variable \token{tau}
at line 7 is not allowed because it is shadowed by the parameter variable
described at line 5.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
mod foo;

lazy pi = 3.1415926535; // global variable

fn calculate (tau : f64) {
  let pi = 3.14; // local variable (allowed, global pi is still accessible through the module foo)
  let @\hb{tau}@ = 6.28; // error, shadows parameter
}

\end{lstlisting}

\subsection{Scope value}

As presented in Section~\ref{sec:function_body}, a scope has a value if the last
expression contained in the scope is a value and does not end with the \token{;}
token. The value can be used as any other expression value (e.g. as the value of
a variable declaration).

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
let a = {
  let b = 12;
  b + 12
};

let c = {
  let b = 12;
  b + @\hb{c}@ // error, /c/ does not exist yet
};
\end{lstlisting}

\subsection{Variable initial value}
\label{sec:variable_init_value}

A local variable is always declared with an initial value. The goal is to ensure
that any data in the program came from somewhere, and is not initialized from a
random memory state of the machine running the program (as we can have in the C
language). One can argue that static verification can be used to ensure that a
variable is set before it is used, and argue that forcing an initial value on a
variable is not the best way to achieve data validity. While this is more a
matter of opinion than sound scientific reasoning at this point, we believe that
scattering the initialization of a variable makes programs harder to read. In
addition, immutable variables would initially be mutable, making the behavior of
a program even more difficult to understand. In the following listings, two
examples of source code with the same behavior are presented. On the left, a
valid source code that is accepted by the Ymir language, and on the right, a
source code that is not accepted based on the arguments we presented.

\hspace{-15pt}%
\begin{minipage}[t][][t]{0.47\linewidth}
  \begin{lstlisting}[style=coloredverbatim, escapechar=@, caption=Valid]
fn foo (cond : bool) {
  let i = if cond {
    42
  } else {
    7
  };
}
  \end{lstlisting}
\end{minipage}\hspace{10pt}%
\begin{minipage}[t][][t]{0.47\linewidth}
  \begin{lstlisting}[style=coloredverbatim, escapechar=@, caption=Invalid]
fn foo (cond : bool) {
  let i : i32;
  if cond {
    i = 42;
  } else {
    i = 7;
  };
}
  \end{lstlisting}
\end{minipage}

In the context of function call, a parameter variable is invariably associated
with a value. This stems from the fundamental requirement that when invoking a
function, each parameter must be initialized with a value; no parameter can
remain uninitialized. Thus, at the point of function call, all parameters
inherently possess a defined value. On the contrary, as for a local variable, a
global variable must be associated with a value. This value is constructed
lazily when the variable is first referenced in the program.

\begin{lstlisting}[style=coloredverbatim]
lazy X; // error, x has no initial value
lazy Z = foo (); // ok, will take the return value of foo when first referenced in the program
\end{lstlisting}

In the above listing, the global variable \token{Z} will takes on the return
value of the function \token{foo} when \token{Z} is first referenced in the
program. This lazy initialization ensures that Z is constructed only when its
value is needed, optimizing performance by delaying computation until necessary.
More information about lazy variables is presented in
Section~\ref{sec:variable_laziness}.

\subsection{Unused variable}
\label{sec:unused_variables}

A declared local or parameter variable has to be used during its lifetime,
otherwise the compiler will send an error, as the variable is useless and only
complexify the source code with dead code.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
{
  let a = 12;
@\hb{\}}@ // error, /a/ is defined but not used
\end{lstlisting}

There are two ways to force the compiler to ignore an unused variable, the first
is to use a special identifier for the variable, either by putting an underscore
at the beginning and end of the variable (e.g. \token{\_a\_}), or by naming the
variable directly \token{\_}. A variable named \token{\_} is anonymous and
cannot be used at all. The second way is to use the variable in a statement.
This statement can be empty (i.e. \token{a;}). Function parameters follow the
exact same semantic, and therefore must be used within the body of the function.
They can be used or ignored with the same system as local variables.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
{
  let _a_ = 12;
} // ok, /_a_/ is an ignorable variable

{
  let _ = 12;
} // ok, /_/ is anonymus

{
  let a = 12;
  a; // using the variable
} // ok, all variables were used
\end{lstlisting}

Global variables can remain unused. As explored further in this chapter, global
variables are inherently lazy in Ymir, meaning they are constructed only upon
first reference. Additionally, because global variables can be accessed from any
symbol with public access (cf. Section~\ref{sec:symbol_protection}), including
from external packages, it is impossible to guarantee that a global variable
will never be accessed. Consequently, there is no enforcement mechanism to
ensure that global variables are used, and they can be declared without being
referenced in the program.

\subsection{Variable type}
\label{sec:variable_type}

The type of the variable is automatically infered from the value that is
associated to it. Sometimes the compiler may fail the inference, or multiple
types can be associated to a specific value by implicit casting. To solve that
problem a type can be attached to a variable declaration using the token
\token{:}. The type specified must of course be compatible with the type of the
value.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
let a = 12; // automatically infering i32
let b : i32 = 12; // declaring i32

let c : i64 = 12; // ok, implicit cast to i64
let d : [c8 ; 5] = "Hello"; // ok implicit cast from [c8] to [c8 ; 5]
\end{lstlisting}

Some values needs an explicit type to be used as variable initialization values.
For example the value \token{none} that creates an empty option values has no
inner type on its own. In fact its inner type is deduced from the type of the
lvalue that will receive it during affectation. Other types such as \token{void}
can simply not be used for variable declaration as they do not contain a value.
To create a variable with no value, an empty tuple \token{()} can be used.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
let @\hb{a = none;}@ // error, cannot create a variable with type (none)?
let b : (i32)? = none; // ok, type is explicitely defined

let @\hb{c = {};}@ // error, cannot create a var of type void
let @\hb{d : void = {};}@ // error, even by explicitely writing it

let e = (); // ok empty tuple
let f : () = (); // ok, same as /e/
\end{lstlisting}


\vfill%
\pagebreak

\section{Variable mutability}
\label{sec:variable_mutability}

A variable is immutable by default, but can be made mutable using the
\token{mut} and \token{dmut} keywords. We saw in
Section~\ref{sec:preamble_compound_types} that values can borrow data depending
on their type. Since all the mutability information about specific types has
already been discussed in Chapter~\ref{chap:compound} for native compound types
and in Chapter~\ref{chap:custom_types} for user-defined types, we will not
discuss it further. Because type mutability is recursive, an inner type can only
be mutable if the type containing it is also mutable. Consequently, for a value
inside a local variable to be mutable, the variable itself must also be mutable.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
let a = 12;
@\hb{a = 9;}@ // error, /a/ is immutable

let mut b = 12;
b = 9; // ok, /b/ is mutable


let @\hb{c : [mut i32]}@ // error, /c/ is immutable, its inner value cannot be mutable
           = copy [1, 2, 3];

let mut d : [mut i32]  // ok, /d/ is of type mut [mut i32]
          = copy [1, 2, 3];


let dmut e = copy [1, 2, 3]; // same as /d/

d [0] = 9; // ok
e [0] = 10; // ok

let mut f = copy [1, 2, 3]; // /f/ is of type mut [i32]
@\hb{f [0] = 0;}@ // error, inner value of /f/ is immutable
f = copy [4, 5]; // ok, /f/ is mutable
\end{lstlisting}

\warningbox{
  The mutability of a variable exhibits specific behaviors when the variable is a
  reference or is lazy. These topics will be discussed in
  Sections~\ref{sec:ref_variable} and~\ref{sec:variable_laziness}.
}

\subsection{Mutability of a parameter variable}

A parameter whose type is borrowing data can be described as mutable. In this
case, because the parameter is borrowing mutable data, it must be explicitly
accepted when the function is called using the \token{alias} keyword. The
behavior is similar to assigning mutable borrowed data to a mutable variable,
and must follow the same rules regarding mutability levels.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
fn foo (dmut x : [i32]) {
  x [0] = 12; // ok, a is mutable
}

let dmut a = copy [1, 2, 3];
foo (alias a); // Ok, contract has been accepted

assert (a == [12, 2, 3]);

let dmut b = copy [1, 2, 3];
foo (@\hb{b}@); // forbidden, /b/ should be passed by alias

let c = copy [1, 2, 3];
foo (@\hb{alias c}@);// error, the mutability level of c is not high enough
\end{lstlisting}

Figure~\ref{fig:example_mut_params} shows the stack and heap memory state when
the \token{foo} function is called at line 6 in the previous code. Note that
the value of \token{x} borrows the same value as \token{a} from the
\token{main} function, but they don't share the same memory address.

\input{images/mut_parameter}

The parameter itself is not mutable, and we cannot change the value to which it
is associated. This is because mutable data is passed by value, not by
reference. Therefore, in the following example, modifying the value borrowed by
the variable \token{x} on line 3 would have no effect on the value borrowed by
the value \token{a}. However, on line 3, the value borrowed by \token{x} is the
same as the value borrowed by \token{a}, so modifying it will modify the value
of both variables. It was decided that the parameters should not be lvalues in
order to completely separate the concept of reference parameters and value
parameters.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
fn foo (dmut x : [i32]) {
  @\hb{x = [4, 5, 6];}@ // forbidden, x is not a lvalue
  x [0] = 3; // ok, x borrows mutable data
}

let dmut a = copy [1, 2, 3];
foo (alias a);
\end{lstlisting}

To be allowed to be mutable, the mutability of the parameter must be deep enough
to actually touch borrowed data - and therefore imply an explicit alias of the
value associated with it during the call. For example, in the next example, even
if the parameter actually borrows data, the mutable modifier is not deep enough
and does not affect it. In this case, the compiler will reject the code and
return an error to avoid useless mutable decorators for parameter variables that
cannot change data. This rule is specific to function value parameters and does
not apply to default variables or reference parameters.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
// forbidden, a [0] is not mutable, and neither is a
fn foo (@\hb{mut a : [i32]}@);

// forbidden as well, a [0] is not borrowed, and a[0][0] is const
fn bar (@\hb{mut a : [mut [i32] ; 2]}@);

// obviously forbidden, no data are borrowed
fn baz (@\hb{mut a : i32}@);
\end{lstlisting}

If a parameter is constant, it is forbidden to associate a mutable variable with
it using the keyword \token{alias}. This keyword is used to indicate that the
contract for a data movement of borrowed mutable data has been accepted.
Approving code that uses this keyword when no mutable data is being moved would
have the undesirable effect of encouraging the keyword to be used even when
unnecessary, and thus as a kind of mandatory decorator, which would ultimately
defeat its main purpose of preventing unwanted mutable movement.

In the example below, the keyword \token{alias} is used in two different
contexts, both of which are incorrect. The first instance is on line 5, where
the variable \token{x} does not have mutable access to the data it borrows.
Therefore, it does not have the right to give this permission to another
variable, and the keyword \token{alias} is not allowed. In the second case, on
line 6, variable \token{y} has mutable access to the borrowed data, but it is
being passed to a variable that does not need mutable access. Therefore, the
keyword is unnecessary and not allowed. It is important to avoid using it for
every data movement without considering its usefulness, as this is a bad
practice, for that reason it is enforced by the compiler.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
fn foo (mut a : [mut i32]);
fn bar (a : [i32]);

let x = copy [1, 2, 3];
let dmut y = copy [1, 2, 3];

foo (@\hb{alias x}@); // forbidden, x is const
bar (@\hb{alias y}@); // forbidden, passing to a const does not require /alias/
\end{lstlisting}

\vfill%
\pagebreak

\section {Reference variable}
\label{sec:ref_variable}

The \token{ref} keyword can be used to decorate a variable when constructing it
with the \token{let} construct, or when declaring a parameter variable. Only
lvalues can be referenced. A reference value is equivalent to a pointer value,
except that it can never be null and is always associated with a memory segment,
making it safe to use. This keyword can only be used to describe a variable, a
type cannot be described as a reference, and it is impossible to store a
reference inside another value.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
  let dmut a = [1, 2, 3];
  let ref b = a; // no copy of /a/

  println (b [0]); // 1

  a [0] = 89;
  println (b [0]); // 89

  @\hb{b [0] = 9;}@// error, /b/ is immutable
\end{lstlisting}

In the above example, \token{b} is a pointer to the value of \token{a},
meaning that when the value of \token{a} changes, so does the value of
\token{b}. The following listing shows the YIL representation of the above
code, and Figure~\ref{fig:ref_variable} illustrates the state of the stack when the
program is executed on a 64-bits system.

\begin{lstlisting}[style=lyilVerb]
  let a(#1) : [i32;3];
  let b(#2) : *([i32;3]);
  a(#1) = [1, 2, 3];
  b(#2) = &a(#2);
  _Y3std2io7printlnNi32Fi32Zv(*b(#2)[0]);
  a(#1)[0] = 89;
  _Y3std2io7printlnNi32Fi32Zv(*b(#2)[0]);
\end{lstlisting}

\input{images/ref_variable}

\subsection{Reference parameter variable}
\label{sec:ref_param}

The \token{ref} keyword can be used to decorate a parameter variable. This
decorator is used to pass a value by reference to a function. To pass a value by
reference to a function, nothing has to be done on the calling side if the
variable is not mutable and the referencing is made implicitely.

\begin{lstlisting}[style=coloredverbatim]
use std::io;
fn foo (ref x : i32) {
  println (x);
}

let a = 12;
foo (a); // ok, x is immutable in foo
\end{lstlisting}

\begin{lstlisting}[style=lyilVerb]
frame :  _Y4main3fooFRi32Zv (let x(#1) : *(i32))-> void {
    _Y3std2io7printlnNi32Fi32Zv(*x(#1));
}

frame :  _Y4main4mainFZv ()-> void {
    let a(#1) : i32;
    a(#1) = 12;
    _Y4main3fooFRi32Zv(&a(#1));
}
\end{lstlisting}

In the above example, the variable \token{a} is passed by reference to the
function \token{foo} however this reference is constant, and the function
\token{foo} cannot modified its value. It can be useful to pass a variable by
reference to avoid copying big datas, for example an array containing a lot of
elements and avoid copying all of them.

\input{images/ref_param_array}

In the Listing~\ref{lst:result_copy_v_ref_array}, the value is not copied when passed to the \token{foo}
function, but is copied when passed to the \token{bar} function. The abstract
result of both functions is the same, but calling \token{foo} should be faster.
Figure~\ref{fig:example_call_ref_array} and
Figure~\ref{fig:example_call_copy_array} show the state of the stack when
calling the \token{foo} function on line 10 and the \token{bar} function on
line 11, respectively. These images are the abstract representation of the Ymir
Intermediate Language presented in the following listing.

\begin{lstlisting}[style=coloredverbatim, label=lst:result_copy_v_ref_array, caption=Example of passing an array by reference vs. by value]
fn foo (ref x : [i32 ; 10]) {
  println (x [5]);
}

fn bar (x : [i32 ; 10]) {
  println (x [5]);
}

let a = [0 ; 10];
foo (a);
bar (a);
\end{lstlisting}

\begin{lstlisting}[style=lyilVerb, caption=YIL result of Listing~\ref{lst:result_copy_v_ref_array}]
frame :  _Y4main3barFA10_3i32Zv (let x(#1) : [i32;10])-> void {
    _Y3std2io7printlnNi32Fi32Zv(x(#1)[5]);
}
frame :  _Y4main3fooFRA10_3i32Zv (let x(#1) : *([i32;10]))-> void {
    _Y3std2io7printlnNi32Fi32Zv(*x(#1)[5]);
}
frame :  _Y4main4mainFZv ()-> void {
    let YI_1(#1) : [i32;10];
    let a(#2) : [i32;10];
    YI_1(#1) = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    a(#2) = YI_1(#1);
    _Y4main3fooFRA10_3i32Zv(&a(#2));
    _Y4main3barFA10_3i32Zv(a(#2));
}
\end{lstlisting}

Only a \textit{lvalue} can be passed to a function as a reference, otherwise it
does not really have a memory location, and therefore an address cannot be
assigned to it.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
fn foo (ref x : i32);

foo (@\hb{12}@); // error, 12 is not a lvalue
\end{lstlisting}

\subsection {Mutable reference variable}
\label{sec:mut_ref_param}

By default, a local reference variable and a parameter reference variable are
not mutable, but they can be made mutable using the \token{mut} and \token{dmut}
decorators.Unlike mutable value parameters, a mutable reference parameter can be
mutable even if it does not borrow any mutable data. In fact, as we saw in the
previous section, a reference parameter is a pointer that can never be null, so
it actually borrows data from another frame.

The contract of a function that presents a mutable reference parameter must be
accepted as it was mandatory for mutable parameters, but this time instead of
the keyword \token{alias} the keyword \token{ref} is used.

\begin{lstlisting}[style=coloredverbatim]
fn foo (ref mut x : i32) {
  x = 12;
}

let mut a = 1;
foo (ref a);
\end{lstlisting}

\begin {lstlisting}[style=lyilVerb]
frame :  _Y4main3fooFRi32Zv (let x(#1) : *(i32))-> void {
    *x(#1) = 12;
}
frame :  _Y4main4mainFZv ()-> void {
    let a(#1) : i32;
    a(#1) = 1;
    _Y4main3fooFRi32Zv(&a(#1));
}
\end{lstlisting}

As for the keyword \token{alias}, this keyword \token{ref} cannot be used in
vain and must be associated with a mutable reference parameter.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
fn foo (ref x : i32);

let mut a = 12;
foo (@\hb{ref}@ a); // forbidden, unecessary mutable reference

let b = 12;
foo (@\hb{ref}@ b); // forbidden, cannot create a mutable reference from a data that is not mutable
\end{lstlisting}

A local reference variable can be mutable as long as the value it references is
also mutable, and the contract has been accepted with the \token{ref} keyword.
It follows the same rules as those just presented for mutable reference
parameters.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
  let mut a = 12;
  let mut ref b = ref a; // ok

  b = 90;
  println (a); // 90
\end{lstlisting}

As for mutable reference parameters, the keyword \token{ref} is mandatory to
accept the mutable reference contract. This keyword can only be used on an
lvalue. In the next example, the contract is not respected at line 2. At line 5,
even if the variable is an lvalue and the keyword \token{ref} is used, because
the mutability of \token{c} is not deep enough to fit into the mutability of the
variable \token{d}, the compiler sends an error.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
  let mut a = 12;
  let @\hb{mut ref b = a;}@ // error, mutable reference requires ref keyword

  let mut c : [i32] = copy [1, 2, 3];
  let @\hb{dmut ref d = ref c;}@ // error, cannot fit mut [i32] into mut [mut i32]
\end{lstlisting}

\vfill%
\pagebreak

\section{Laziness}
\label{sec:variable_laziness}

A variable can be declared using the keyword \token{lazy}. Marking a variable as
lazy indicates that its value might not be utilized, and hence, if its creation
requires extensive computation, it can be beneficial to delay its construction
until it's actually needed.

\notebox{ Laziness can be applied to various kinds of constructs. In all these
  cases, laziness refers to the same behavior: the value is constructed only
  when it is needed. Laziness is a powerful construct that can significantly
  enhance a program's efficiency with minimal modifications. However, these
  enhancements come with certain costs, which will be thoroughly discussed in
  Section~\ref{sec:impl_lazy_closure}. }

\begin{lstlisting}[style=coloredverbatim]
/*
 * The value of 'b' might be unnecessary for the function to return a result
 */
fn foo (x : bool, a : i32, lazy b : i32) -> i32 {
  if (x) {
    a
  } else {
    a + b
  }
}

// Define a lazy variable
let lazy x = lazy bar ();

// Calling the function 'foo' with a lazy value
foo (true, 12, lazy baz ());
\end{lstlisting}

When associated to a local variable declaration, the keyword \token{lazy} can
only decorate a variable that is not part of a pattern declaration. This means
that an iterator, a variable within a pattern in pattern matching, and similar
constructs cannot be decorated with the keyword \token{lazy}.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
class A {
  pub let x = 12;
  /// ...
}

let A (x-> @\hb{lazy}@ x) = lazy A::new (); // error, lazy cannot decorate a variable in a pattern matching

for @\hb{lazy}@ i in [1, 2, 3] { // error, lazy cannot decorate a iterator
}

match foo () {
  @\hb{lazy}@ x => { // error, cannot decorate a variable with lazy in a pattern matching
  }
}
\end{lstlisting}

\subsection {Initial value of a lazy variable}
\label{sec:lazy_param}

The keyword \token{lazy} signals that the variable's value might not be used,
and thus, it might be unnecessary to construct it. Variables are not defined as
lazy by default because they require more memory space, an allocation, and the
compilation of a new function, which also increases the size of the generated
executable. The decision to make a parameter variable lazy is left to the
discretion of the developer and is generally reserved for values that require
heavy computation or significant time and resources (e.g., I/O operations,
network communications, etc.).

\begin{lstlisting}[style=coloredverbatim]
fn foo (useA : bool, lazy a : i32)-> i32 {
  if (useA) {
    a
  } else {
    0
  }
}
\end{lstlisting}

Laziness is a contract that must be acknowledged when working with a lazy
variable. In the next example, the function \token{foo} takes a lazy variable as
a parameter, so the contract must be accepted when setting up the function
call's arguments. This contract is essential to prevent unwanted behavior. Since
the value passed to the parameter \token{a} is only constructed within the
function \token{foo}, the function \token{bar} might never be called, depending
on the logic within \token{foo}. By explicitly using the \token{lazy} keyword
when constructing the value, the expected behavior is clearly evident at first
glance. The output of the program depicted in Listing~\ref{lst:accept_laziness}
is presented in Listing~\ref{lst:result_accept_laziness}, from that result one
can observe that the call to the function \token{bar} was made within the
function \token{foo}, and might have not be made at all as it is the case during
the second call of the function \token{foo}.

\begin{lstlisting}[style=coloredverbatim, label=lst:accept_laziness, caption=Example of laziness contract acceptance]
fn foo (useA : bool, lazy a : i32)-> i32 {
  println ("In foo");
  let x = if (useA) {
    a
  } else {
    0
  };

  println ("Exit foo");
  x
}

fn bar ()-> i32 {
  println ("In bar");
  12
}

let a = foo (true, lazy bar ());
println ("a = ", a);
let b = foo (false, lazy bar ());
println ("b = ", b);
\end{lstlisting}

\begin{lstlisting}[style=bashVerb, caption=Result of execution of Listing~\ref{lst:accept_laziness}, label=lst:result_accept_laziness]
In foo
In Bar
Exit foo
a = 12
In foo
Exit foo
b = 0
\end{lstlisting}

Implementation of lazy variable is not presented in this section. To understand
the details of its implementation, closure and function pointers have to be
introduced, therefore we'll come back to lazy variables and their technical
implementation in Section~\ref{sec:impl_lazy_closure}.

\subsubsection*{Global variable}

All global variables are lazy, and in fact the keyword \token{lazy} is mandatory
to define a global variable. The

\subsection {Lazy mutable variable}
\label{sec:variable_lazy_mut}

A lazy variable can be mutable if it creates a value that borrows data. However,
since the variable itself is used to generate a value, we cannot change the
value it is associated with, but we can change the value it is borrowing. In a
sense, the behavior of a lazy variable (local, global or parameter) is similar
to the behavior of a parameter variable that borrows mutable data.

There are two reasons for this restriction. First, specifically for parameter
variables, since the variable is not a reference, changing its value would not
affect the value that was used when calling the function â€” a value that might
not have a memory location anyway. Second, this restriction applies not only to
lazy parameters but to all lazy variables that can be constructed in Ymir (e.g.,
local lazy variables, global lazy variables, etc.). If the value of a lazy
variable could be changed, two different outcomes could occur: 1. the lazy value
is constructed, and then the result value is changed, 2. the lazy value is not
constructed, and the value is set by the assignment. Both behaviors could be
acceptable but seem unnecessary and can be resolved more straightforwardly by
introducing another variable that is not lazy. For these two reasons, a lazy
variable can borrow mutable data but is never mutable itself.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
fn foo (lazy dmut a : [i32]) {
  @\hb{a = copy [1, 2, 3];}@ // error, a is not a lvalue
  a [0] = 3; // ok, a borrows mutable data
}

fn main () {}
  let lazy dmut a = lazy {
    println ("Allocate");
    copy [1, 2, 3]
  };

  a @\hb{=}@ copy [2, 3]; // prints "Allocate" ?
  // so, it is not allowed

  a [0] = 9; // ok, a borrows mutable data
}
\end{lstlisting}

In the following example, the variable \token{a} is a lazy mutable parameter
that borrows a slice of \token{i32}. As with any lazy value, it is constructed
when the variable \token{a} is referenced for the first time, which happens at
line \token{2}. Because the parameter \token{a} is lazy and borrows data, two
different contracts must be accepted when calling the function \token{foo}. This
is why the call at line \token{6} that passes the variable \token{i} uses both
keywords \token{lazy} and \token{alias}.

\begin{lstlisting}[style=coloredverbatim, caption=Example of lazy mutable parameter]
fn foo (lazy dmut a : [i32]) { a [0] = 9; }

let dmut i = copy [1, 2, 3];
foo (lazy alias i);

assert (i [0] == 9);
\end{lstlisting}

\notebox { When the two keywords \token{lazy} and \token{alias} are used
  together, they are always written in the same order: first \token{lazy},
  followed by \token{alias} (i.e., \token{lazy alias i}). The reason for this
  order is explained in Section~\ref{sec:impl_lazy_closure}, which discusses the
  technical implementation of lazy values. A value enclosed within the lazy
  value can be an implicit alias, such as when it makes a copy, calls a
  function, or is a block. Further details on memory management are provided in
  Chapter~\ref{chap:memory_management}. }

\vfill%
\pagebreak

\section{Pattern variable declaration}
\label{sec:pattern_vdecl}

A local variable declaration can be done using a pattern instead of a single
variable declaration. Available patterns are fully described in
Section~\ref{sec:pattern_matching} about pattern matching. If the pattern is
irrefutable (the condition to match the pattern is known at compile time and is
always true), then the variables defined within the pattern can be declared.
Patterns can be used for many things, such as deconstructing tuples, arrays,
accessing class fields, etc.

\begin{lstlisting}[style=coloredverbatim, escapechar=@, caption=Tuple deconstruction]
let t = (1, 't', 12.0f);
let (x, y, z) = t;
let (w, _...) = t; // taking only the first value, ignoring the rest
\end{lstlisting}

\begin{lstlisting}[style=coloredverbatim, escapechar=@, caption=Array deconstruction]
let a = [1, 2, 3];
let [i, j, k] = a;
let [l, m, _...] = a; // taking only the first two values ignoring the rest
\end{lstlisting}

\begin{lstlisting}[style=coloredverbatim, caption=Class field access]
class A {
  pub let i : i32;
  pub self (i : i32) with i = i {}

  @field
  pub fn len (self)-> i32 {
    2
  }
}

let a = A::new (1);
let A (i-> x, len-> y) = a;

assert (x == a.i && y == a.len);
\end{lstlisting}

The lifetime of variables declared using pattern variable declaration is the
same as that of variables declared using standard declaration. In fact, there is
no standard declaration, a variable declared with the syntax \token{let a : i32
  = 12} uses the pattern \token{a : i32} with the matching value \token{12}
and is therefore irrefutable.

Refutable patterns (that are unknown at compile time) must be coupled with
conditional branching (cf. Section~\ref{sec:if_else}) as they may or may not
create new variables depending on the result of the pattern evaluation.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
fn foo ()-> i32?;

let @\hb{Ok (x : i32) = foo ();}@ // error, refutable since it may fail if /foo/ returns /none/
\end{lstlisting}

\subsection{Pattern variable mutability and references}

The value that is passed to pattern must respect mutability of borrowed values,
and therefore as any data movement must use the keyword \token{alias} to
perform mutable borrowed data movement. Because the keyword is recursive, an
inside pattern deconstruction may impact mutable access to inner values. In the
next example, the variable \token{a} has mutable access to borrowed data from
\token{t}, when the variable \token{b} has only const access to its second
field, however the keyword \token{alias} has to be used over the value
\token{t} to allow mutable access from \token{a}.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
let dmut t = (copy [1, 2], copy [2, 3]);
let (dmut a : [i32], b : [i32]) = alias t;
//     /alias/ is mandatory here  ^^^^^

a [0] = 9;
t.1 [0] = 9;
println (t); // ([9, 2], [9, 3])
println (b); // [9, 3]
\end{lstlisting}

As for any variable declaration the keyword \token{ref} can be used to create a
reference to a lvalue. In that case, instead of the keyword \token{alias}, the
keyword \token{ref} has to be used to decorate the value that is being
referenced. In the next example, the variable \token{a} is a reference to the
first field of the tuple value stored in \token{t}.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
let dmut t = (copy [1, 2], copy [2, 3]);
let (dmut ref a : [i32], _) = ref t;

a = copy [9, 8, 7];
println (t); // ([9, 8, 7], [2, 3]);
\end{lstlisting}

When values to variable associations are a mix of aliases and references, the
keyword \token{ref} must be used, in this unique case it allows for mutable
\token{alias}. The \token{alias} keyword can never be used to create a mutable
reference. In the next example, the variable \token{a} is a mutable reference
to the first field of the value stored in \token{t}, and the variable
\token{b} mutably borrows the same value as the second field of \token{t}. In
this case, a mutable reference and a mutable alias are created at the same time,
so the keyword \token{ref} is used to decorate the associated value to allow
this. However, in line \token{4}, the use of the keyword \token{ref} is not
allowed, since neither \token{c} nor \token{d} create a reference, the keyword
\token{alias} must be used.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
let dmut t = (copy [1, 2], copy [2, 3]);
let (dmut ref a, dmut b) = ref t; // ok, /ref/ replaces /alias/ in that case

let (dmut c, dmut d) = @\hb{ref}@ t; // error, no mutable references needed, thus /alias/ has to be used
\end{lstlisting}

If there is no mutable alias and no mutable reference, then the keyword is not
allowed to decorate the associated value, to avoid using the keywords by default
resulting in the opposite of their purpose (helping developers to easily spot
the locations of mutable memory movements, and possible side effects).

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
let dmut t = (copy [1, 2], copy [2, 3]);
let (a, b) = @\hb{alias}@ t; // error, /alias/ is useless
let (c, d) = @\hb{ref}@ t; // error, /ref/ is useless
\end{lstlisting}

\vfill%
\pagebreak

\section {Memory movement without variables}
\subsection{Borrowed memory implicit aliases}

Memory aliasing can sometimes be determined implicitly, as it may have already
been established (e.g., by returning from a function call, block, etc.). In such
cases, the contract is already accepted, and there is no need to use the keyword
\token{alias} again. A comprehensive list and examples of implicitly allowed
memory aliasing is presented in this section.

\subsubsection*{Mutable return value}

When a function is called, its return value is retrievable from the caller
function. If the return value borrows mutable data, it does not need to be
explicitly aliased, in fact it is already supposed to be done in the body of the
callee in order to return the value by alias, so it would only be redondant to
force the alias inside the caller as well.

\begin{lstlisting}[style=coloredverbatim]
// Function that return a dmut slice
fn foo (a : i32)-> dmut [i32] {
  let dmut x = copy [0 ; a]; // allocating a slice of size /a/

  // explicitely return a mutable alias of the value, to respect the return value contract
  alias x
}

let dmut x = foo (12); // no need for explicit alias the call of /foo/
\end{lstlisting}

\subsubsection*{Reference return value}

A function cannot return a reference. There is a guarantee in Ymir that all
aliasable and mutable borrowed values are on the heap, which is not the case for
reference values, which can be on the stack and therefore cease to exist when
the function is returned. To avoid this, it was decided not to allow reference
returns.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
fn foo ()-> @\hb{ref}@ i32 { // error, cannot return a reference
  let a = 12;
  a
}
\end{lstlisting}

\subsubsection*{Lazy return value}
\label{sec:lazy_return}

A function cannot return a lazy value. A lazy value is not intended to be passed
from function to function or from variable to variable. It is constructed once
and assigned to a variable, which will be the sole reference to that lazy value.

\begin{lstlisting}[style=coloredverbatim, escapechar=@
]fn bar ()-> i32;

fn foo (lazy a : i32)-> @\hb{lazy}@ i32 { // error, cannot return a lazy value
  println ("In foo");
  a // even, when constructed with lazy
}

let lazy x = lazy bar ();
foo (@\hb{x}@); // cannot pass a lazy variable, to a lazy parameter
let lazy z = foo (lazy bar ()); // would be ok, but is bar called in the end ?

z; // is bar called twice, once ?
\end{lstlisting}

While laziness can be useful for efficiency enhancement, it has a significant
drawback: it obscures many details, making it difficult to explain a program's
behavior. To address this, it was decided to forbid the copying of a lazy value
without dereferencing it. This simplification ensures that a lazy value can
serve only once.
