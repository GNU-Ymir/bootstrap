\section{YIL language}

Ymir is a high level programming language, meaning that a statement in Ymir can
represent multiple low level instructions. C programming language is closer to a
machine level representation (even if there are still some high level
instructions that can be found in that language). In this book, in order to
fully understand the behavior of the Ymir language when executed on a machine,
and the memory representation a source code is describing, low level source code
close to the C language will be used. These low level source code are using a
language named YIL (Ymir Intermediate Language), and are a direct representation
of the high level source code into a low level one. A middle level
representation will be also used. In this middle level, some higher level
operations are still presents, such as loops, or some high level memory
management. In general it won't be necessary to distinguish between the two
level representations, as they won't be used at the same time, however if
required, L-YIL and M-YIL terms for respectively \textit{low}, and
\textit{middle} YIL, will be used.

In this book, Ymir language source code are presented in listing whose
background are yellow, M-YIL source code are presented in listings whose
background are teal, and L-YIL in listings whose background are green.

\begin{lstlisting}[style=coloredverbatim, caption=Source file \textit{hello.yr}, label=lst:hello_world]
use std::io;

fn main () {
    println ("Hello World!");
}
\end{lstlisting}

As an example, the source code presented in the above listing is transformed by
the compiler into the following M-YIL and L-YIL representations. The contents of
these representations are not yet discussed, but will be presented in the course
of this document.

\begin{lstlisting}[style=myilVerb, caption=M-YIL reprensentation of \textit{hello.yr}]
frame : [weak] std::io::println!{[c8]}::println (a(#8h) : [c8])-> void {
    std::io::print (a(#8h));
    std::io::putchar ('\n'c8);
    <unit-value>
}
frame : hello::main ()-> void {
    std::io::println!{[c8]}::println ("Hello World!"s8);
    <unit-value>
}
\end{lstlisting}

\begin{lstlisting}[style=lyilVerb, caption=L-YIL reprensentation of \textit{hello.yr}]
frame :  [weak] _Y3std2io7printlnNS2c8FS2c8Zv (let a(#1) : (len-> u64, ptr-> *(u8)))-> void {
    _Y3std2io5printFS2c8Zv(a(#1));
    putchar(10);
}
frame :  _Y5hello4mainFZv ()-> void {
    _Y3std2io7printlnNS2c8FS2c8Zv((len-> 12, ptr-> "Hello World!"));
}
frame :  main (let argc(#1) : u32, let argv(#2) : *(void))-> i32 {
    _yrt_run_main(argc(#1), argc(#2), &_Y5hello4mainFZv);
    return 0;
}
\end{lstlisting}

YIL representations are automatically generated by the compiler, and are not
intended to be used as a programming language (in fact, there is no compiler to
convert their plain text representation into an executable). The
Ymir \textit{gyc} compiler generates the YIL representation when
the \textit{-fdump-ymir} option is specified. This option generates a set of
intermediate representations, among which two files with the
extensions \textit{.ydump-sem} and \textit{.ydump-yil} can be found, containing
the M-YIL and L-YIL representations of the compiled source file.

\begin{lstlisting}[style=bashVerb, escapechar=@+]
@+\textcolor{teal!80}{alice@dev}@+:~$ gyc -fdump-ymir hello.yr -o hello
@+\textcolor{teal!80}{alice@dev}@+:~$ ls
@+\textcolor{green!70!black}{hello}@+
hello.yr
hello.yr.ydump-decls.1
hello.yr.ydump-decls.2
hello.yr.ydump-opt
hello.yr.ydump-sem
hello.yr.ydump-yil
\end{lstlisting}

\vfill
\pagebreak
