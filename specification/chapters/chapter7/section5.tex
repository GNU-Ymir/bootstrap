\section{Iteration loop}%
\label{sec:for_loop}

The keyword \token{for} initiates an iteration loop that traverses over a value.
As discussed in Chapter~\ref{chap:compound}, certain values such as arrays,
tuples, and slices can be iterated over using variables. The syntax of a
\textit{for} loop is as follows: \token{for i, j,... in V}, where \token{i, j,
  ...} represents a list of variable declarations, and \token{V} denotes the
value being iterated over. For loops are applicable to some native compound
types and to custom class types that implement the \textit{for loop} operator,
as detailed in Chapter~\ref{sec:class_override_for_loop}.

For clarity, throughout the rest of this section, the variable representing the
value at the current iteration will be denoted as a \textit{value iterator},
typically depicted by the variable \textit{v}. Similarly, the variable holding
the index will be termed an \textit{index iterator}, usually depicted by the
variable \textit{i}.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
let a = copy [1, 2, 3];

for i, v in a {
  println ("Value at index : ", i , " equals to : ", v);
}
\end{lstlisting}

The type of the iterator is automatically inferred, but it can be explicitly
specified by appending the token \token{:} followed by the desired type.
However, the specified type must match the type that would have been inferred.
The primary purpose of explicitly specifying the type is to allow for mutability
modifications.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
let a = copy [1, 2, 3];

for i : usize, v : i32 in a {
  println ("Value at index : ", i , " equals to : ", v);
}
\end{lstlisting}

The index iterator is inherently immutable, meaning decorators cannot be
attached to its declaration. Index iterators are accessible for all iterable
native compound types, such as range, tuple, array, and slices. For tuples,
slices, and arrays, a single iterator serves as the value iterator by default.
However, if two iterators are defined, the first one is the index iterator,
while the second one becomes the value iterator. Conversely, for ranges, only
one iterator can be declared, and it acts as the index iterator.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
for i in 0 .. 10 {
  println ("Index iteration : ", i);
}

for v in [1, 2, 3] {
  println ("Value iteration : ", v);
}

for i, v in [1, 2, 3] {
  println ("Value and index iteration : ", i, ' ', v);
}
\end{lstlisting}

\subsection {Mutable value iterator}
\label{sec:mut_value_iterators}

In line with any variable declaration, the value iterator is initially immutable
by default. However, it can be rendered mutable by using the keywords
\token{mut} or \token{dmut}. Because iterators index the values being iterated,
they don't behave like typical variables but rather resemble function
parameters. As discussed in Section~\ref{sec:mutable_parameter}, even though
function parameters can be mutable, they aren't \textit{lvalues} unless they're
reference parameters. This is because completely altering their value would
change the memory address of the value they're borrowing, thereby having no
impact on the initially assigned value.

For the same reason, value iterators can only be mutable if they are associated
with mutable borrowed data, explicitly aliased to them. In the following
example, the variable \token{v} is mutable and borrows the same memory segments
as the elements contained in \token{a[i]}. Because it is mutable, it can modify
the values that are borrowed but cannot be completely changed.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
let dmut a = dcopy [[1, 2], [3, 4]];
for dmut v in alias a {
  v [0] = 10; // ok, aliasing /a/
  @\hb{v = copy [8, 9];}@ // error, /v/ is not a lvalue
}

assert (a [0][0] == 10);
\end{lstlisting}

Because value iterators are not lvalues, they cannot be mutable if they do not
borrow mutable data. Without access to mutable elements to modify, the
mutability of the variable would be pointless, as it would have no effect on the
iterated value.

\begin{lstlisting}[style=coloredverbatim, escapechar=@, caption=Useless mutable iterator, label=lst:(chap7):useless_mut_iterator]
let dmut a = copy [1, 2, 3];
for @\hb{mut}@ v in alias a { // error, x cannot be mutable, it does not borrow mutable data
  @\hb{v = 1;}@ // would have no effect on /a/
}
\end{lstlisting}

\subsection{Reference iterators}

The \token{ref} keyword can be applied as a decorator to the value iterator.
This decorator alters the behavior of the iterator, providing reference access
to the values being iterated rather than copying the value at each index. This
can be beneficial when iterating over large datasets contained within the
iterated value, such as a slice of arrays (e.g., \token{[[c8; 1024]]}). In the
following example, both loops exhibit the same behavior, but the second one is
expected to be faster. To be utilized as a reference value, the value being
iterated must be an lvalue and does not necessarily need to be mutable (as long
as the reference value iterator itself is not mutable; for details on mutable
reference value iterators, refer to the next subsection).

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
let a : [[i32 ; 1024]] = copy [[0 ; 1024], [1 ; 1024]];
for v in a { // copy 1024 i32, at each iteration
  println (v);
}

for ref v in a { // reference, copying only 1 pointer (8 bytes)
  println (v);
}
\end{lstlisting}

This type of reference value iterator can be utilized with tuples, arrays, or
slices. In the following example, the first for loop at line 2 creates a copy of
the values contained in the tuple, while the second loop at line 5 iterates
using references, thereby avoiding the need to copy 110 \textit{i32} values.
Similarly, the loops for an array value make copies at line 10 and iterate by
reference at line 13. The Ymir Semantic Language reveals these differences,
transforming the loop at line 2 into the one depicted in
Listing~\ref{lst:(chap7):copy_value_iter_tu} and the loop at line 5 into the one shown
in Listing~\ref{lst:(chap7):ref_value_iter_tu}.

\begin{lstlisting}[style=coloredverbatim, caption=iteration using reference value iterator, label=lst:(chap7):ref_value_iter_ex]
let a = ([0 ; 100], [1 ; 10]);
for v in a {
  println (v);
}

for ref v in a {
  println (v);
}

let b : [[i32 ; 1024] ; 2] = [[0 ; 1024], [1 ; 1024]];
for v in b {
  println (v);
}

for ref v in b {
  println (v);
}
\end{lstlisting}

\begin{lstlisting}[style=myilVerb, caption=By copy iteration on a tuple, label=lst:(chap7):copy_value_iter_tu]
cte for {
  {
    let v(#48) : [i32 ; 100us] = [0 ; 100us];
    {
      std::io::println!{[i32 ; 100us]}::println (v(#48));
      <unit-value>
    }
  };
  {
    let v(#s7) : [i32 ; 10us] = [1 ; 10us];
    {
      std::io::println!{[i32 ; 10us]}::println (v(#s7));
      <unit-value>
    }
  }
};
\end{lstlisting}

\begin{lstlisting}[style=myilVerb, caption=By reference iteration on a tuple, label=lst:(chap7):ref_value_iter_tu]
cte for {
  {
    let ref v(#1gd) : [i32 ; 100us] = ref (a(#3t).0);
    {
      std::io::println!{[i32 ; 100us]}::println (v(#1gd));
      <unit-value>
    }
  };
  {
    let ref v(#1hd) : [i32 ; 10us] = ref (a(#3t).1);
    {
      std::io::println!{[i32 ; 10us]}::println (v(#1hd));
      <unit-value>
    }
  }
};
\end{lstlisting}

\subsection{Mutable reference iterator}

A reference iterator can be rendered mutable by decorating it with the keywords
\token{mut} or \token{dmut}. It adheres to the same guidelines as any mutable
reference variable or parameter (see Section~\ref{sec:mut_ret_param}),
indicating that the iterator variable itself is mutable, and any modifications
to it directly impact the referenced value. The value being iterated must
conform to the mutability level of the iterator, and the contract must be
acknowledged by decorating the iterated value with the keyword \token{ref}.

In the following example, the value iterator is a mutable reference to the
values contained in the slice value stored in the variable \token{a}. Because
the iterator is a mutable reference iterator, it is an lvalue (as opposed to a
simple mutable iterator, which would not be applicable here - see
Listing~\ref{lst:(chap7):useless_mut_iterator}), and therefore can be modified. After
the end of the \textit{for} loop, the values contained in the slice stored in
\token{a} are modified.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
let dmut a = copy [1, 2, 3];

for i, ref mut v in ref a {
  //                ^^^ mandatory
  v = cast!i32 (i) + 9;
}

assert (a == [9, 10, 11]);
\end{lstlisting}

The iterator must be compatible with the mutability level of the iterated value.
In the following example, at line 4, the iterator is deeply mutable. However,
the variable \token{a} only has partial mutable access to the value it borrows,
meaning it can modify only the first level, but not the values stored in the
inner slices. On the other hand, at line 9, the iterator is only one level
mutable, matching the mutability level of \token{a}. As a result, it will modify
the values stored in \token{a} without altering the values stored within the
inner borrowed slices.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
let y = copy [3, 4];
let mut a : [mut [i32]] = dcopy [[1, 2], y];

for @\hb{ref dmut}@ v in ref a {
  //    ^^^, error, incompatible mut [i32] -> mut [mut i32]
  @\hb{v [0] = 9;}@ // would modify values that /a/ does not own
}

for ref mut v in ref a {
  //    ^^^ Ok, slice in /a/ is mutable
  v = copy [10, 11];
}

assert (a [0] == [10, 11]);
assert (a [1] == [10, 11]);
assert (y == [3, 4]); // /y/ is untouch as guaranteed

\end{lstlisting}

\vfill%
\pagebreak
