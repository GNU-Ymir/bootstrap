\section{Scope guards}%
\label{sec:scope_guards}

Scope guards are a programming construct utilized to ensure that specific
operations are executed automatically upon exiting a scope. These guards are
commonly employed for tasks such as cleanup actions, error recovery, or managing
resources. There are two main types of scope guards: scope exiting and error
handling. The former, discussed in Section~\ref{sec:exit_guards}, is declared
following a scope declaration using one of three keywords: \token{exit},
\token{success}, or \token{failure} (e.g., \token{\{ ... \} exit \{ ... \}}). The
latter, discussed in Section~\ref{sec:catching_errors}, is declared with the
keyword catch and is utilized to handle exceptions thrown within a specific
scope, employing the syntax \token{\{...\} catch \{ Pattern => V \}}


\begin{lstlisting}[style=coloredverbatim]
fn foo ()-> i32
  throws AssertError;

{
  foo ();
} exit {
  println ("Called foo");
} catch {
  AssertError () => {
    println ("Foo has failed!");
  }
}
\end{lstlisting}

\subsection{Exit guards}
\label{sec:exit_guards}

The \token{exit} guard serves as a scope guard designed to execute an action
when a scope is exited, regardless of the success or failure of the guarded
scope. In contrast, the scope guards \token{failure} and \token{success} are
activated under specific conditions upon exiting the scope. The guard
\token{failure} is triggered when the scope throws an exception, while the guard
\token{success} is triggered when the scope exits normally. These scope guards
can be highly beneficial for managing resources that require disposal or for
calling functions that must execute at the end of a scope.

\smallskip

In the provided example, the code at line 10 is executed irrespective of whether
the \token{foo} function succeeds or fails. Conversely, the code at line 14 is
executed solely if the \token{foo} function exits normally, whereas the code at
line 12 is exclusively executed in the event of \token{foo} failing.

\begin{lstlisting}[style=coloredverbatim]
fn foo ()-> i32
  throws AssertError
{
  // ...
}

{
  foo ();
} exit {
  println ("Foo was exited");
} failure {
  println ("Foo failed");
} success {
  println ("Foo succeeded");
}
\end{lstlisting}

Exit scope guards lack access to variables declared within the scope they guard.
Specifically, \token{exit} and \token{failure} cannot ensure that variables
declared within the guarded scope are constructed. While \token{success} could
potentially guarantee this access, it adheres to the same behavior as other
scope guards and also lacks access to variables declared within the guarded
scope. In the following example, line 4 is prohibited as the variable \token{a}
no longer exists (and might have never been constructed).

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
{
  let a = foo ();
} exit {
  println ("Foo returned : ", @\hb{a}@); // error, a does not exists here
}
\end{lstlisting}

Exit scope guards cannot throw exceptions, return early from functions, break
loops, or generate values. They may execute in contexts where the program is
already throwing an exception (e.g., the \token{failure} scope is only triggered
in such contexts) or in contexts that have already triggered a break or an early
function return. Allowing exit scope guards to throw exceptions, return early,
or break loops would result in two exceptions being thrown simultaneously or two
values being returned, which is nonsensical. Additionally, scope guards do not
generate values; the value of a guarded scope is the value generated by the
scope itself. Scope guards are solely used to execute actions once this value is
generated (or failed to be generated), not to handle errors or provide a
different value. For error handling, a \token{catch} scope guard can be
utilized, as will be presented in the subsequent subsection.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
let a = {
    1
} exit {
  @\hb{2}@ // error, scope guard value must be of type /void/
};
// If it was allowed, what would be the value of /a/ here?

{
  throw AssertError ("First exceptions");
} failure {
  @\hb{throw AssertError ("Second exception");}@ // error, scope guard can't throw exceptions
};
// If it was allowed, which would be the thrown error?

{
  return 1;
} success {
  @\hb{return 8}@; // error, exit scope guard cannot return a value
}
// And what would the function actually return ?
\end{lstlisting}

Exit scope guards can indeed be utilized to dispose of a class object, as
demonstrated in the following example. It's important to note that defining the
variable \token{f} within the scope guarded by the exit at line 6 wouldn't be
feasible, as it wouldn't be accessible within the scope guard and thus wouldn't
be disposable. However, it is not the preferred method. Instead, a disposing
scope declaration (refer to Section~\ref{sec:dispose_block}) is recommended for
such purposes.

\begin{lstlisting}[style=coloredverbatim]
use std::fs; // for File

let dmut f = File::create ("file.txt", write-> true);
{
  f.write ("content");
} exit {
  f.dispose ();
}

f.write ("other content"); // ok, but file was disposed so it will throw
\end{lstlisting}

For code clarity, the guards \token{failure} and \token{success} should only be
used if the guarded scope can throw exceptions. Otherwise, they would either
never be executed or be strictly equivalent to an \token{exit} guard.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
{
  println ("In scope");
} @\hb{failure}@ { // error, never used
  println ("Failed to print ??");
} @\hb{success}@ { // error, always executed, thus exit must be used instead
  println ("Succeed to print");
}
\end{lstlisting}

\vfill%
\pagebreak
