\section{Handling exceptions}
\label{sec:catching_errors}

Exceptions are handled using a specific scope guard named \token{catch}. Unlike
other scope guards, this one has a distinct syntax and encloses a list of
patterns similar to those found in pattern matching expressions. The patterns in
\token{catch} scope guards are used to match the caught exception, allowing only
variable declarations and field deconstructors to be used, as these are the only
patterns relevant for matching over an object.


\begin{lstlisting}[style=coloredverbatim]
fn foo ()
  throws AssertError;

fn main () {
  {
    foo ();
  } catch {
    a : &AssertError => {
      println ("Caught an assert error with message : ", a.msg);
    }
  }

  println ("Continuing normally");
}
\end{lstlisting}

The types of exceptions that can be caught by the \token{catch} scope guard
include all exceptions thrown within the guarded scope. It is mandatory for the
scope guard to catch all exceptions; there is no automatic rethrowing of
uncaught exceptions as might be done in other programming languages.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
fn foo (x : i32?)
  throws AssertError, EmptyValOption;

fn main () {
  {
    foo (none);
  } catch {
    @\hb{EmptyErrOption ()}@ => { // error, foo cannot throw EmptyErrOption

    }
    EmptyValOption () => {
      println ("Option was empty");
    }
    @\hb{\}}@ // error, AssertError exception is not caught
  }
}
\end{lstlisting}

\subsection{Exception rethrowing}

Because exceptions are not rethrown automatically if not caught, a \token{catch}
scope guard that does not throw any exception is considered safe (in the sense
that it does not throw, though it might still panic or trigger unsafe
operations). A \token{catch} scope guard can throw an exception like any other
classical scope, using the keyword \token{throw} or by calling a function that
throws an exception. Unlike other scope guards (exit, success, and failure), a
\token{catch} scope guard is only triggered if the guarded scope fails to
produce a value, and since the exception is caught, only one path leads out of
the flow graph from the scope guard. For that reason, scopes declared within a
\token{catch} scope guard have the same properties as standard scopes (can
break, generate or return a value, throw exceptions, etc.).


\begin{lstlisting}[style=coloredverbatim]
{
  foo ();
} catch {
  EmptyValOption () => {
    println ("Recovering");
  }
  e => { // catch every other exceptions
    throw e; // and rethrow them
  }
}

println ("Foo succeeded, or we successfully recovered from the error");
\end{lstlisting}

Since scopes guarded by \token{catch} scope guards that are not rethrowing are
not throwing exceptions, they can be used inside a function that does not throw,
or within a context that does not allow for exception throwing (such as an exit
scope guard, lambda function, etc.). In the next example, even though the
exception \token{AssertError} is thrown at line 5, it is caught by the scope
guard at line 7, thus allowing it to be used within an \token{exit} scope guard.

\begin{lstlisting}[style=coloredverbatim]
{
  println ("Start");
} exit {
  {
    throw AssertError::new ("Error");
  } catch {
    AssertError (msg-> msg) => {
      println ("Catching msg : ", msg);
    }
  }

  println ("Exit");
}
\end{lstlisting}

\subsection{Guarded scope value}

When a scope that is supposed to generate a value fails (by throwing an
exception), a \token{catch} scope guard can be used to define the value that
will be generated instead. All scopes (triggered by the different patterns)
within a \token{catch} scope guard must define a value of the same type as the
value that would be generated by the guarded scope in the case of success (with
the exception of scopes that early break, return, or throw an exception, of
course). The same principle introduced in Section~\ref{sec:cond_value_type} is
used to infer the type of the value generated by the different branches. Indeed,
catch scope guards can be seen as \token{else} conditional branches that are
entered when an exception is thrown instead of a condition being unmet.

\begin{lstlisting}[style=coloredverbatim]
fn foo ()-> i32
  throws AssertError;

fn main () {
  let a = {
    foo () // value of foo, if foo succeeds
  } catch {
    _ => { 0 } // 0 if foo fails
  };

  println (a); // a is always correctly set
}
\end{lstlisting}


\subsection{Guarded scope mutable value}

As with the mutability inferred when dealing with conditional branches, the
value of a scope guarded by a \token{catch} scope guard adopts the mutability of
the branch with the fewest permissions. In the following example, because the
value generated by the \token{catch} pattern scope at line 11 is less mutable
than the type returned by the function \token{foo} at line 7, its mutability is
chosen. Essentially, everything related to value inference in branch values
applies to the \token{catch} scope guard.

\begin{lstlisting}[style=coloredverbatim]
fn foo ()-> dmut [i32]
  throws AssertError;

fn main () {
  let x = copy [1, 2, 3];
  let a = {
    foo ()
  } catch {
    AssertError (msg-> m) => {
      println ("Message of the assert error : ", m);
      x
    }
  };

  let dmut b = {
    foo ()
  } catch {
    _ => {
      copy x // ok, creates a dmut [i32]
    }
  };
}
\end{lstlisting}

\subsection{Breaking and early returns}

We have seen that since \token{catch} scope guards are triggered only when the
guarded scope has failed to continue, they can generate values and throw
exceptions. For the same reason, such scope guards can be used to break loops or
return from functions early, using the keywords \token{break} and
\token{return}, respectively. In these contexts, the rules presented in
Section~\ref{sec:function_early_return} and Section~\ref{sec:inf_loop} apply.

\begin{lstlisting}[style=coloredverbatim]
let mut i = 0;
let nbIters = loop {
  {
    foo ();
    i += 1;
  } catch {
    _ => break i;
  }
};

println ("Foo function ran ", nbIters, " times before failing");
\end{lstlisting}

\begin{lstlisting}[style=coloredverbatim]
fn bar ()-> i32 {
  let x = {
    foo ()
  } catch {
    _ => {
      println ("Foo failed, simply returning 1");
      return 1;
    }
  };

  println ("Value of foo : ", x);
  x + 1
}
\end{lstlisting}

\subsection{Scope guard priority}

Multiple scope guards can be attached to the same scope by declaring them one
after the other. Although they can be defined in any order, they are always
executed in the sequence: \token{catch}, \token{success} or \token{failure}, and
finally \token{exit}. The scope guards \token{catch} and \token{success} are
never executed together, as the \token{success} scope guards are executed only
when the scope they are guarding successfully finishes. For the same reason,
\token{failure} and \token{success} cannot be executed together, but the
\token{failure} scope guard is always executed after catching exceptions. In all
cases, the \token{exit} scope guard is always executed last.

\begin{lstlisting}[style=coloredverbatim]
{
  foo ();
} catch {
  e => println ("Caught an execption : ", e);
} failure {
  println ("Scope failed");
}
\end{lstlisting}

\vfill%
\pagebreak
