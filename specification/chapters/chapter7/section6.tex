\section{List comprehension}%
\label{sec:list_compr}

List comprehension is a concise method for creating arrays, slices, or tuples
using a single line of code. It applies an expression to each item in a list by
iterating over an iterable, similar to a standard for loop. The syntax \token{[V
    for i, j ... in Iter]} and \token{(V for i, j ... in Iter,)}. In the next
example at line 1, an array of size \textit{10} is created by iterating over a
range value. In this example, an array value can be created because the number
of iteration of the for loop can be computed at compile time. Because the size
is known, a tuple value can be created using the same principle as presented at
line 3.

\begin{lstlisting}[style=coloredverbatim]
let a = [i^^2 for i in 0 .. 10];

let b = (i^^2 for i in 0 .. 10,);
//      Note the coma         ^, which is mandatory to create a tuple
\end{lstlisting}

When the size cannot be known at compile time, for example when the iteration is
made on a slice value, then one cannot create a tuple or an array value, but can
still create a slice value, that is allocated during runtime. In the next
example, the keyword \token{copy} performs a dynamic allocation of the correct
size, that is computed during runtime. At line 6, the compiler being unable to
compute the size of the array at compile time, rejects the code by sending an
error, for the same reason the tuple list comprehension at line 7 is also
rejected.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
fn foo ()-> [i32];

let x = foo ();
let a = copy [i^^2 for i in x]; // compute the square of each element of the slice /x/

let b = @\hb{[i for i in x];}@ // error, size of array is not cte
let c = @\hb{(i for i in x,);}@ // error, arity of tuple not cte
\end{lstlisting}

To be used as an iterable value in a list comprehension, the value must be
iterable using a standard \token{for} loop and must have a computable length
before entering the loop. This size can be known at compile time (to create an
array or a tuple) or only at runtime (to create a slice). The four native
iterable values for list comprehension are slices, arrays, tuples, and ranges.
Custom class types can override the list comprehension operator, as discussed in
Chapter~\ref{sec:class_override_lst_compr}.

\subsection{Mutable and reference value iterators}

In the previous section on \token{for} loops, we discussed that iterators can be
references and mutable, depending on the type of the value being iterated. In
list comprehension, the value iterator can be a reference but cannot be mutable.
The primary purpose of list comprehension is to create new values, not to modify
existing ones. Allowing the modification of the iterated value during the
creation of another value would result in two operations happening
simultaneously, leading to potentially confusing programming patterns that we
believe should be avoided. However, the iterator can still be a reference to
avoid copying values during iterations, such as when iterating over a slice of
array values. In the following listing, the list comprehension is forbidden
because it attempts to modify the values contained in \token{a}.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
let dmut a = dcopy [[1, 2], [3, 4]];

let dmut b = copy [{
    @\hb{v[0] = 1;}@ // error, v cannot be mutable
    v[1]
} for @\hb{dmut}@ v in @\hb{alias}@ a]; // error, cannot make a mutable value iterator
\end{lstlisting}

One can still modify the value \token{a} by using a direct reference. This
approach does not hinder optimization. In the following example, a single loop
performs two operations at each iteration, rather than requiring two separate
loops as shown in the next Listing~\ref{lst:(chap7):compr_two_loops}.

\begin{lstlisting}[style=coloredverbatim, caption=Modify existing value during list comprehension]
let dmut a = dcopy [[1, 2], [3, 4]];

let dmut b = copy [{
    a [i][0] = 9; // ok, /a/ is directly referenced
    v [1]
} for i, ref v in a]; // ok, iterating by const reference

assert (a [0] == [9, 2]);
assert (b == [2, 4]);
\end{lstlisting}

\begin{lstlisting}[style=coloredverbatim, caption=Using two loops]
let dmut a = dcopy [[1, 2], [3, 4]];

let dmut b = copy [v [1] for ref v in a]; // ok, iterating by const reference
for ref dmut v in ref a { // second loop to modify /a/
  v [0] = 9;
}

assert (a [0] == [9, 2]);
assert (b == [2, 4]);
\end{lstlisting}

\subsection {YIL representation}

List comprehensions that iterate over a tuple value or create a tuple value are
unfolded at compile time to generate a literal value. The following
Listings~\ref{lst:(chap7):list_compr_tuple_iter} and~\ref{lst:(chap7):list_compr_tuple_create}
produce the YIL (Ymir Intermediate Language) representation shown respectively
in Listings~\ref{lst:(chap7):list_compr_tuple_iter_yil}
and~\ref{lst:(chap7):list_compr_tuple_create_yil}.

\begin{lstlisting}[style=coloredverbatim, label=lst:(chap7):list_compr_tuple_iter, caption=List comprehension iterating over a tuple]
let a = (1, 2, 3);
let b = [i for i in a];
\end{lstlisting}

\begin{lstlisting}[style=lyilVerb, label=lst:(chap7):list_compr_tuple_iter_yil, caption=YIL representation of Listing~\ref{lst:(chap7):list_compr_tuple_iter}]
a(#2) = (1, 2, 3);
i(#3) = a(#2)._0;
i(#5) = a(#2)._1;
i(#7) = a(#2)._2;
YI_9(#9) = [i(#3), i(#5), i(#6)];
\end{lstlisting}

\begin{lstlisting}[style=coloredverbatim, label=lst:(chap7):list_compr_tuple_create, caption=List comprehension iterating over a tuple]
let a = [1, 2, 3];
let b = (i for i in a,);
\end{lstlisting}

\begin{lstlisting}[style=lyilVerb, label=lst:(chap7):list_compr_tuple_create_yil, caption=YIL representation of Listing~\ref{lst:(chap7):list_compr_tuple_iter}]
a(#1) = [1, 2, 3];
YI(#3) = (len-> 3, ptr-> &a(#2));
#_value(#4) = YI(#3);
#_iter(#5) = 0;
YI(#6) = 4 * #_iter(#5);
YI(#7) = #_value(#4).ptr + YI(#6);
YI(#8) = cast!{*(i32)} (YI(#7));
i(#9) = *YI(#8);
#_iter(#5) = 1;
YI(#b) = 4 * #_iter(#5);
YI(#c) = #_value(#4).ptr + YI(#b);
YI(#d) = cast!{*(i32)} (YI(#c));
i(#e) = *YI(#d);
#_iter(#5) = 2;
YI(#g) = 4 * #_iter(#5);
YI(#h) = #_value(#4).ptr + YI(#g);
YI(#i) = cast!{*(i32)} (YI(#h));
i(#j) = *YI(#i);
b(#l) = (i(#9), i(#e), i(#j))
\end{lstlisting}

On the other hand, list comprehensions that create a slice or an array from a
range, a slice, or an array value generate a loop that is executed at runtime.
The following Listings~\ref{lst:(chap7):list_compr_range_iter}
and~\ref{lst:(chap7):list_compr_array_iter} produce the YIL (Ymir Intermediate Language)
representation shown respectively in
Listings~\ref{lst:(chap7):list_compr_range_iter_yil}
and~\ref{lst:(chap7):list_compr_array_iter_yil}.

\begin{lstlisting}[style=coloredverbatim, label=lst:(chap7):list_compr_range_iter, caption=List comprehension iterating over a range]
let a = [i for i in 0 .. 10];
\end{lstlisting}

\begin{lstlisting}[style=lyilVerb, label=lst:(chap7):list_compr_range_iter_yil, caption=YIL representation of Listing~\ref{lst:(chap7):list_compr_range_iter}]
    #_iter(#1) = 0;
#GOTO test(#3);
#LABEL beg(#2);
    i(#4) = cast!{i32} (#_iter(#1));
    #_value(#2)[#_iter(#1)] = i(#4);
    #_iter(#1) = #_iter(#1) + 1;
#LABEL test(#3);
    YI_3(#3) = #_iter(#1) < 10;
#IF YI_3(#3)
#THEN_GOTO beg(#2)
#ELSE_GOTO end(#1);
#LABEL end(#1);
    a(#8) = #_value(#2);
\end{lstlisting}

\begin{lstlisting}[style=coloredverbatim, label=lst:(chap7):list_compr_array_iter, caption=List comprehension iterating over an array]
let mut a = [1, 2, 3];
let b = [i for i in a];
\end{lstlisting}

\begin{lstlisting}[style=lyilVerb, label=lst:(chap7):list_compr_array_iter_yil, caption=YIL representation of Listing~\ref{lst:(chap7):list_compr_array_iter}]
    a(#2) = [1, 2, 3];
    #_value(#4) = (len-> 3, ptr-> &a(#2));
    #_iter(#6) = 0;
#GOTO test(#3);
#LABEL beg(#2);
    YI_8(#8) = 4 * #_iter(#6);
    YI_9(#9) = #_value(#4).ptr + YI_8(#8);
    YI_10(#a) = cast!{*(i32)} (YI_9(#9));
    i(#b) = *YI_10(#a);
    #_out(#5)[#_iter(#6)] = i(#b);
    #_iter(#6) = #_iter(#6) + 1;
#LABEL test(#3);
    YI_7(#7) = #_iter(#6) < 3;
#IF YI_7(#7)
#THEN_GOTO beg(#2)
#ELSE_GOTO end(#1);
#LABEL end(#1);
    b(#e) = #_out(#5);
\end{lstlisting}

One can note from Listings~\ref{lst:(chap7):list_compr_tuple_iter_yil}
and~\ref{lst:(chap7):list_compr_array_iter_yil} that the iteration over an array value
actually creates a slice over the array value that is iterated. This allows to
use the exact same system for slice and array iterations (the same thing is
performed for \token{for} loops) as slices are pointer to an array value with a
specific length.

\subsection{Specifics to slice value iteration}

As discussed in Section~\ref{sec:slice_expansion}, slices can be expanded when
their size is forcibly defined using an index operated with a range operand.
This system can also be used to iterate over a slice value within a list
comprehension to create an array or a tuple, where the size must be known at
compile time. In practice, because the size of the slice cannot be effectively
checked at compile time, a runtime check is added to ensure that the slice
contains enough values to respect the index operation.

\begin{lstlisting}[style=coloredverbatim, label=lst:(chap7):list_compr_slice_to_array, caption=List comprehension over a slice with cte size]
fn foo ()-> [i32];

let a = foo ();
let b = [i for i in a [0 .. 3]]; // ok, array of size 3
let c = (i for i in a [0 .. 2],); // ok, tuple of arity 2
let d = copy [i for i in a]; // ok, creates a new slice
\end{lstlisting}

In the above example, the \token{copy} operator is used to create a slice value
that is stored in the variable \token{d}. This copy operator does not actually
make a copy of the value returned by the list comprehension. Instead, it informs
the compiler that the list comprehension must create a heap allocation for the
value it will generate. This ensures that only one allocation is made, resulting
in a value that is exactly the same as \token{copy a}.

In addition, if the function \token{foo} returns a slice value with fewer than 3
elements, the program will panic at runtime. This occurs because the list
comprehension at line 4 requires at least 3 values. Since this check cannot be
performed at compile time, it is done at runtime, resulting in a panic if the
requirement is not met.

\vfill%
\pagebreak
