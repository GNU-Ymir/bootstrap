\section{Conditional branching}%
\label{sec:if_else}

A conditional control flow can be defined using the keywords \token{if} and
\token{else}. The syntax \token{if C V} defines that the value \token{V} is
evaluated if and only if the condition \token {C} of type \token {bool} is true.
Using the keyword \token{else} this construction can be extended to provide
another value to evaluate if the condition is not met. The if condition at line
2 in the next example generates a runtime conditional representation that can be
represented by the flow graph presented in Figure~\ref{fig:(chap7):if_cond_simple}, or
by the YIL code in Listing~\ref{lst:(chap7):if_cond_simple}.

\begin{lstlisting} [style=coloredverbatim, escapechar=@]
fn foo (cond : bool)-> i32 {
  if cond {
    89
  } else {
    11
  }
}

let x = foo (true); // /x/ evaluated to 89
let y = foo (false); // /y/ evaluated to 11
\end{lstlisting}

\begin{lstlisting}[style=lyilVerb, caption=Simple condition, label=lst:(chap7):if_cond_simple]
frame :  _Y4main3fooFbZi32 (let cond(#1) : u8)-> i32 {
    let YI_2(#2) : i32;
#IF cond(#1)
#THEN_GOTO then(#1)
#ELSE_GOTO else(#3);
#LABEL then(#1);
    YI_2(#2) = 89;
#GOTO end(#2);
#LABEL else(#3);
    YI_2(#2) = 11;
#GOTO end(#2);
#LABEL end(#2);
    return YI_2(#2);
}
\end{lstlisting}

\input{chapters/chapter7/figures/if_cond_simple}

Conditional branching can be applied to any test that produces a \token{bool}
value that is unknown at compile time. However, they are not allowed if the
condition can be determined at compile time, as they would only complicate the
source code with useless control flows that can be determined statically. For
example, in the following code on line 2, the condition is always \token{true},
so the condition is useless and the code on line 3 is always evaluated, in
addition, on line 5 the condition is always \token{false}, creating dead code
that is never evaluated.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
let a = [1, 2, 3];
if (@\hb{a.len <= 3}@) { // error, len of /a/ is /cte/
  println (a [2]);
}

if (a.len >= 4) {
  @\hb{println (a [3]);}@ // error, dead code
}
\end{lstlisting}

\subsection {Conditional value}
\label{sec:cond_value_type}

A \token{if} construct has a result value if all branches have a result value.
The type of the expression is the type of the first branch, i.e. the type of the
value of the first \token{if}. The value of the \token{else} branch is
implicitly cast to the type of the first branch value, if this is not possible
the compiler returns an error.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
let a = if cond {
  12
@\hb{\};}@ // error, no else value

let b = if cond {
  12
} else {
  "str"
@\hb{\};}@ // error, incompatible i32 and [c8]

let d = if cond {
  12
} else {
  11u32
}; // ok, implicit cast of 11u32 to i32
\end{lstlisting}

\subsection{Mutable conditional value}

If the type of the \token{else} branch is compatible with the type of the first
branch, but does not match its mutability, the mutability of the result value of
the \token{if} construct is reduced to match the most restricted value. In the
next example, because the value of the \token{else} branch has a more
restricted mutability than the value of the \token{if} branch, the result type
of the expression takes the mutability of the \token{else} branch, and thus the
result value is of type \token{mut [i32]}.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
let a = copy [1, 2, 3];
let @\hb{dmut b = if cond \{}@// error, mutability does not fit in /b/
  copy [2, 3, 4] // mut [mut i32]
} else {
  a
\hb{\};}@ // mut [i32]
\end{lstlisting}

As for scope values when returning a mutable borrowed value, because
the \token{alias} contract is already accepted within the value of the
branches, it is not necessary to accept it again for the result value of the
\token{if} construct. Therefore, in the next example, the keyword
\token{alias} is not used before the keyword \token{if}, even though the
affectation to \token{b} moves borrowed mutable data.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
fn foo (cond : bool) {
  let dmut a = copy [1, 2, 3];
  let dmut b = if cond {
    alias a // alias is mandatory here
  } else {
    copy [2, 3, 4]
  };
}
\end{lstlisting}


\subsection{Chaining conditions}

Conditions can be chained by following the \token{else} with another
\token{if} condition. In fact, this does not really chain the condition, since
in this case the \token{if} condition following the \token{else} keyword is
the value that is evaluated in case the condition of the first \token{if} is
not true. To illustrate, the following source code presents two chained
\token{if} conditions that are exactly similar in semantics.


\begin{minipage}[t][][t]{0.47\linewidth}
\begin{lstlisting}[style=coloredverbatim, escapechar=@, caption=Using a \token{if} as the value of the \token{else} branch]
if cond {
  println ("First condition is true");
} else if cond2 {
  println ("Second condition is true");
} else {
  println ("None of the conditions were true");
}
\end{lstlisting}
\end{minipage}\hspace{10pt}%
\begin{minipage}[t][][t]{0.47\linewidth}
  \begin{lstlisting}[style=coloredverbatim, escapechar=@, caption=Using a block as the value of the \token{else} branch]
if cond {
  println ("First condition is true");
} else {
  if cond2 {
    println ("Second condition is true");
  } else {
    println ("None of the conditions were true");
  }
}
  \end{lstlisting}
\end{minipage}
\vspace{-10pt}%

\subsection{Early return branch}

We have seen in Section~\ref{sec:function_early_return} that a function can exit
early in three different ways (i.e., \token{return}, \token{throw}, or
\token{panic}). Such an early exit can happen inside a branch of a conditional
value. In this case, that particular branch is considered a return branch and
therefore has no value. In Section~\ref{sec:inf_loop} we will see a construction
that can also exit a branch of the flow graph without constructing a value (i.e.
\token{break}). As a result, the \token{if} construction can sometimes have a
result value even though not all branches construct a value.

%\smallskip

\input{chapters/chapter7/figures/if_cond_early_return}

\begin{lstlisting}[style=coloredverbatim, caption=Early return in \token{if} condition, label=lst:(chap7):if_cond_early_return]
fn foo (cond : bool)-> i32 {
  let a = if cond {
    return 89; // exits the function
  } else {
    10
  }; // ok, all non-returning branches have a value

  a + 9
}
\end{lstlisting}

In the example presented in Listing~\ref{lst:(chap7):if_cond_early_return}, the value of
the variable \token{a} can be constructed. In fact, if the condition is not
true, the value of \token{a} will be 10, and if the condition is true, then the
function exits, so the value of \token{a} does not need to be evaluated in this
case. Figure~\ref{fig:(chap7):if_cond_early_exit} shows the flow graph resulting from
this source code. You can clearly see from this graph that in the flow that the
first branch follows (when the condition is met), the variable \token{a} is
never needed, and therefore does not need to be constructed for the code to be
correct.


\subsection {Conditional pattern}
\label{sec:cond_pattern}

We have seen in Section~\ref{sec:pattern_vdecl} that variables can be declared
using a pattern, and that the pattern might be refutable and needing runtime
validation. In that case, the pattern has to be coupled with a conditional
branch representation using the syntax \token{if let Pattern = Value V}, as
presented in the next example.

\input{chapters/chapter7/figures/if_cond_let_OK}

\begin{lstlisting}[style=coloredverbatim, label=lst:(chap7):if_cond_let_Ok, caption=Example of conditional pattern]
fn foo ()-> i32?;

if let Ok (x : i32) = foo () {
  println ("Foo returned the value : ", x);
}
\end{lstlisting}

In the previous example, the function \token{foo} could return a \token{none}
value, but the code would still be safe because the conditional ensures that the
variable \token{x} is created if and only if the function actually returns a
value. This example produces the YIL representation shown in
Figure~\ref{fig:(chap7):if_cond_let_Ok}, as you can see the variable \token{x} is
actually created only if the value returned by \token{foo} is set. All kinds of
patterns can be used for conditional pattern declarations, those are described
in Section~\ref{sec:pattern_matching}.


Pattern conditional branching can be used for any pattern that requires run-time
validation, but is not allowed for patterns that are irrefutable (or always
wrong), as it would just make the code unnecessarily complex.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
let a = (1, 2, 3);

if @\hb{let (x, y, z) = a \{}@ // error, pattern is irrefutable
  println (x, ' ', y, ' ', z);
}
\end{lstlisting}

\subsubsection{Conditional pattern guard}

As we will see in the presentation of patterns in
Section~\ref{sec:pattern_matching}, using an identifier within a pattern
declares a new variable that must not be shadowed by another variable with the
same name. For example, in the next listing at line 4, the compiler returns an
error because the pattern declares a new variable \token{x} rather than
evaluating for equality, as it does in the second pattern condition at line 10.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
fn foo ()-> i32?;

let x = 2;
if let Ok (@\hb{x}@) = foo () { // error, shadowing declaration of /x/
  println ("foo () == ", x);
} else {
  println ("Either foo () returned none, or != x");
}

if let Ok (2) = foo () { // ok, value equality test
  println ("foo () returned the value 2")
}
\end{lstlisting}

To solve this problem, and to allow comparison with variables within pattern
matching, the pattern guard was introduced. The pattern guard allows two test
conditions in one line, using the token \token{\&\&} at the end of the syntax
\token{if let Pattern = Value \&\& Test V} to add an extra condition in which the
variables declared within the pattern are accessible. In the next example, the
declaration of the variable \token{y} does not overshadow any other variable and
can therefore be used to compare the value returned by \token{foo} with the
value stored in the variable \token{x} inside the pattern guard. Unlike a second
conditional branch, as presented in
Listing~\ref{lst:(chap7):using_second_cond_no_guard}, the pattern guard allows the
\token{else} value to be evaluated in case the pattern guard test fails, and
therefore makes writing code easier and less redundant.

\notebox{ Because the pattern guard is introduced by the token \token{\&\&},
  operators of equal and lower precedence (e.g. \token{=}, \token{+=},
  \token{||}, ...) cannot be used directly inside the value accepted by the
  pattern and must be enclosed in parentheses (e.g. \token{if let Ok (x) = (foo ()
    || bar () \&\& baz ())? \&\& guard}).}


\begin{lstlisting}[style=coloredverbatim, caption=Using a pattern guard]
let x = 2;

if let Ok (y) = foo () && y == x {
  println ("foo () returned the value ", y, " which is equal to ", x);
} else {
  println ("Either none, or y != x");
}
\end{lstlisting}

\begin{lstlisting}[style=coloredverbatim, caption=Using a second condition instead of pattern guard, label=lst:(chap7):using_second_cond_no_guard]
if let Ok (y) = foo () {
  if (y == x) {
    println ("foo () returned the value ", y, " which is equal to ", x);
  } else {
    println ("y != x");
  }
} else {
  println ("foo () returned none");
}
\end{lstlisting}

\vfill%
\pagebreak
