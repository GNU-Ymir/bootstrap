\section{Infinite loop}%
\label{sec:inf_loop}

A loop can be defined with the keyword \token{loop}. A loop defined with this
keyword is an infinite loop that never stops unless it is broken with the
\token{break} keyword or terminated by an early function exit (i.e., returning
with the \token{return} keyword, throwing an exception, or panicking). This type
of loop can be useful for managing operations that have no real defined end
(e.g. a worker thread waiting for new tasks, a TCP server waiting for new
connections).

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
loop {
  println ("I will print this message indefinitely");
}
\end{lstlisting}

\subsubsection{Breaking a loop}
\label{sec:breaking_loops}

A break statement with the keyword \token{break} stops loop iterations and exits
its scope. The break statement only breaks one level of the loop, so if multiple
levels of loops are wrapped, then only the lowest level of the loop is broken,
and the iterations of the higher level loops continue. In the following example,
the output result of execution will be a sequence of pairs of \textit{Inner
  Loop} and \textit{Outer Loop}, as the inner loop will only iterate once before
breaking and returning to the upper loop.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
loop {
  loop {
    println ("Inner Loop");
    break;
  }
  println ("Outer Loop");
}
\end{lstlisting}

Any statement after an irrefutable break branch is inaccessible, so the compiler
will raise an error if dead code is found after a break statement.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
loop {
  break;
  println ("Post break"); // error, unreachable statement
}

println ("After loop"); // ok, break only breaks the loop, it does not exit the function
\end{lstlisting}

\subsection {Infinite loop value}

As mentioned earlier, an infinite loop can be broken using the \token{break}
keyword. The break construction can be associated with a value, this value will
be the value taken by the loop after exiting. If multiple breaks are defined in
the loop, they must all produce a value of compatible type. The type of the
loop's value is determined in the same way as the type of the value of an if
condition, by checking all possible branches and calculating the most common
type (cf. Section~\ref{sec:cond_value_type}). The control flow of the next
Listing~\ref{lst:(chap7):simple_loop_break} is illustrated in
Figure~\ref{fig:(chap7):simple_loop_break}.

\begin{lstlisting}[style=coloredverbatim, label=lst:(chap7):simple_loop_break, caption=Breaking a loop with a value]
let mut count = 0;

let x = loop {
  if (count == 10) {
    break count + 1;
  }

  count += 1;
};

assert (x == 11);
\end{lstlisting}

\input{chapters/chapter7/figures/simple_loop_break}


In the next example, since the two values declared by the break
constructions are compatible but not equivalent, the type of the breaks is
implicitly cast to \token{\&A}, with the compiler defining the most common type
between the two breaks as the ancestor of the class objects. The same operations
would be done for other compatible types, such as int, char literals with
compatible but not equivalent types.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
class A {
  pub self () {}
}

class B over A {
  pub self () {}
}

class C over A {
  pub self () {}
}

let mut count = 0;
let x = loop {
  if count == 1 {
    break B::new ();
  } else if count = 10 {
    break C::new ();
  }

  count += 1;
};
\end{lstlisting}


\subsubsection {Mutable loop value}

As with the conditional value, the value of a loop construction can be made
mutable. If multiple breaks are defined within the loop, the mutability of the
type of the loop value is reduced to the most restricted mutability among the
break values. In the following example, the mutability of the value on line 8 is
more restricted than the value on line 6, so the mutability of the type of the
loop is the same as that of the break value on line 8.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
let mut count = 1;
let a = copy [2, 3, 4];

let x = loop {
  if count == 1 {
    break copy [1, 2, 3];
  } else if count == 10 {
    break a;
  }

  count += 1;
};
\end{lstlisting}

Since the mutability of the loop value is the same as the mutability of the most
restricted value among the break values, it can borrow mutable data and must
therefore respect the contract of mutable memory movement as defined for scope
values. No \token{alias} is needed above the loop itself, as this has
necessarily already been done on the break values.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
let mut count = 0;
let dmut a = copy [1, 2, 3];

let dmut x = loop { // no need for explicit /alias/
  if count == 10 {
    break alias a; // /alias/ is mandatory here
  }

  count += 1;
};
\end{lstlisting}

\vfill%
\pagebreak
