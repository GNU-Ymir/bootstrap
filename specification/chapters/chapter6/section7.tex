\section {Memory movement without variables}
\subsection{Borrowed memory implicit aliases}

Memory aliasing can sometimes be determined implicitly, as it may have already
been established (e.g., by returning from a function call, block, etc.). In such
cases, the contract is already accepted, and there is no need to use the keyword
\token{alias} again. A comprehensive list and examples of implicitly allowed
memory aliasing is presented in this section.

\subsubsection*{Mutable return value}

When a function is called, its return value is retrievable from the caller
function. If the return value borrows mutable data, it does not need to be
explicitly aliased, in fact it is already supposed to be done in the body of the
callee in order to return the value by alias, so it would only be redondant to
force the alias inside the caller as well.

\begin{lstlisting}[style=coloredverbatim]
// Function that return a dmut slice
fn foo (a : i32)-> dmut [i32] {
  let dmut x = copy [0 ; a]; // allocating a slice of size /a/

  // explicitely return a mutable alias of the value, to respect the return value contract
  alias x
}

let dmut x = foo (12); // no need for explicit alias the call of /foo/
\end{lstlisting}

\subsubsection*{Reference return value}

A function cannot return a reference. There is a guarantee in Ymir that all
aliasable and mutable borrowed values are on the heap, which is not the case for
reference values, which can be on the stack and therefore cease to exist when
the function is returned. To avoid this, it was decided not to allow reference
returns.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
fn foo ()-> @\hb{ref}@ i32 { // error, cannot return a reference
  let a = 12;
  a
}
\end{lstlisting}

\subsubsection*{Lazy return value}
\label{sec:lazy_return}

A function cannot return a lazy value. A lazy value is not intended to be passed
from function to function or from variable to variable. It is constructed once
and assigned to a variable, which will be the sole reference to that lazy value.

\begin{lstlisting}[style=coloredverbatim, escapechar=@
]fn bar ()-> i32;

fn foo (lazy a : i32)-> @\hb{lazy}@ i32 { // error, cannot return a lazy value
  println ("In foo");
  a // even, when constructed with lazy
}

let lazy x = lazy bar ();
foo (@\hb{x}@); // cannot pass a lazy variable, to a lazy parameter
let lazy z = foo (lazy bar ()); // would be ok, but is bar called in the end ?

z; // is bar called twice, once ?
\end{lstlisting}

While laziness can be useful for efficiency enhancement, it has a significant
drawback: it obscures many details, making it difficult to explain a program's
behavior. To address this, it was decided to forbid the copying of a lazy value
without dereferencing it. This simplification ensures that a lazy value can
serve only once.
