\section{Pattern variable declaration}
\label{sec:pattern_vdecl}

A local variable declaration can be done using a pattern instead of a single
variable declaration. Available patterns are fully described in
Section~\ref{sec:pattern_matching} about pattern matching. If the pattern is
irrefutable (the condition to match the pattern is known at compile time and is
always true), then the variables defined within the pattern can be declared.
Patterns can be used for many things, such as deconstructing tuples, arrays,
accessing class fields, etc.

\begin{lstlisting}[style=coloredverbatim, escapechar=@, caption=Tuple deconstruction]
let t = (1, 't', 12.0f);
let (x, y, z) = t;
let (w, _...) = t; // taking only the first value, ignoring the rest
\end{lstlisting}

\begin{lstlisting}[style=coloredverbatim, escapechar=@, caption=Array deconstruction]
let a = [1, 2, 3];
let [i, j, k] = a;
let [l, m, _...] = a; // taking only the first two values ignoring the rest
\end{lstlisting}

\begin{lstlisting}[style=coloredverbatim, caption=Class field access]
class A {
  pub let i : i32;
  pub self (i : i32) with i = i {}

  @field
  pub fn len (self)-> i32 {
    2
  }
}

let a = A::new (1);
let A (i-> x, len-> y) = a;

assert (x == a.i && y == a.len);
\end{lstlisting}

The lifetime of variables declared using pattern variable declaration is the
same as that of variables declared using standard declaration. In fact, there is
no standard declaration, a variable declared with the syntax \token{let a : i32
  = 12} uses the pattern \token{a : i32} with the matching value \token{12}
and is therefore irrefutable.

Refutable patterns (that are unknown at compile time) must be coupled with
conditional branching (cf. Section~\ref{sec:if_else}) as they may or may not
create new variables depending on the result of the pattern evaluation.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
fn foo ()-> i32?;

let @\hb{Ok (x : i32) = foo ();}@ // error, refutable since it may fail if /foo/ returns /none/
\end{lstlisting}

\subsection{Pattern variable mutability and references}

The value that is passed to pattern must respect mutability of borrowed values,
and therefore as any data movement must use the keyword \token{alias} to
perform mutable borrowed data movement. Because the keyword is recursive, an
inside pattern deconstruction may impact mutable access to inner values. In the
next example, the variable \token{a} has mutable access to borrowed data from
\token{t}, when the variable \token{b} has only const access to its second
field, however the keyword \token{alias} has to be used over the value
\token{t} to allow mutable access from \token{a}.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
let dmut t = (copy [1, 2], copy [2, 3]);
let (dmut a : [i32], b : [i32]) = alias t;
//     /alias/ is mandatory here  ^^^^^

a [0] = 9;
t.1 [0] = 9;
println (t); // ([9, 2], [9, 3])
println (b); // [9, 3]
\end{lstlisting}

As for any variable declaration the keyword \token{ref} can be used to create a
reference to a lvalue. In that case, instead of the keyword \token{alias}, the
keyword \token{ref} has to be used to decorate the value that is being
referenced. In the next example, the variable \token{a} is a reference to the
first field of the tuple value stored in \token{t}.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
let dmut t = (copy [1, 2], copy [2, 3]);
let (dmut ref a : [i32], _) = ref t;

a = copy [9, 8, 7];
println (t); // ([9, 8, 7], [2, 3]);
\end{lstlisting}

When values to variable associations are a mix of aliases and references, the
keyword \token{ref} must be used, in this unique case it allows for mutable
\token{alias}. The \token{alias} keyword can never be used to create a mutable
reference. In the next example, the variable \token{a} is a mutable reference
to the first field of the value stored in \token{t}, and the variable
\token{b} mutably borrows the same value as the second field of \token{t}. In
this case, a mutable reference and a mutable alias are created at the same time,
so the keyword \token{ref} is used to decorate the associated value to allow
this. However, in line \token{4}, the use of the keyword \token{ref} is not
allowed, since neither \token{c} nor \token{d} create a reference, the keyword
\token{alias} must be used.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
let dmut t = (copy [1, 2], copy [2, 3]);
let (dmut ref a, dmut b) = ref t; // ok, /ref/ replaces /alias/ in that case

let (dmut c, dmut d) = @\hb{ref}@ t; // error, no mutable references needed, thus /alias/ has to be used
\end{lstlisting}

If there is no mutable alias and no mutable reference, then the keyword is not
allowed to decorate the associated value, to avoid using the keywords by default
resulting in the opposite of their purpose (helping developers to easily spot
the locations of mutable memory movements, and possible side effects).

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
let dmut t = (copy [1, 2], copy [2, 3]);
let (a, b) = @\hb{alias}@ t; // error, /alias/ is useless
let (c, d) = @\hb{ref}@ t; // error, /ref/ is useless
\end{lstlisting}

\vfill%
\pagebreak
