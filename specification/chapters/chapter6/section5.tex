\section{Laziness}
\label{sec:variable_laziness}

A variable can be declared using the keyword \token{lazy}. Marking a variable as
lazy indicates that its value might not be utilized, and hence, if its creation
requires extensive computation, it can be beneficial to delay its construction
until it's actually needed.

\mynotebox{ Laziness can be applied to various kinds of constructs. In all these
  cases, laziness refers to the same behavior: the value is constructed only
  when it is needed. Laziness is a powerful construct that can significantly
  enhance a program's efficiency with minimal modifications. However, these
  enhancements come with certain costs, which will be thoroughly discussed in
  Section~\ref{sec:impl_lazy_closure}. }

\begin{lstlisting}[style=coloredverbatim]
/*
 * The value of 'b' might be unnecessary for the function to return a result
 */
fn foo (x : bool, a : i32, lazy b : i32) -> i32 {
  if (x) {
    a
  } else {
    a + b
  }
}

// Define a lazy variable
let lazy x = lazy bar ();

// Calling the function 'foo' with a lazy value
foo (true, 12, lazy baz ());
\end{lstlisting}

When associated to a local variable declaration, the keyword \token{lazy} can
only decorate a variable that is not part of a pattern declaration. This means
that an iterator, a variable within a pattern in pattern matching, and similar
constructs cannot be decorated with the keyword \token{lazy}.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
class A {
  pub let x = 12;
  /// ...
}

let A (x-> @\hb{lazy}@ x) = lazy A::new (); // error, lazy cannot decorate a variable in a pattern matching

for @\hb{lazy}@ i in [1, 2, 3] { // error, lazy cannot decorate a iterator
}

match foo () {
  @\hb{lazy}@ x => { // error, cannot decorate a variable with lazy in a pattern matching
  }
}
\end{lstlisting}

\subsection {Initial value of a lazy variable}
\label{sec:lazy_param}

The keyword \token{lazy} signals that the variable's value might not be used,
and thus, it might be unnecessary to construct it. Variables are not defined as
lazy by default because they require more memory space, an allocation, and the
compilation of a new function, which also increases the size of the generated
executable. The decision to make a parameter variable lazy is left to the
discretion of the developer and is generally reserved for values that require
heavy computation or significant time and resources (e.g., I/O operations,
network communications, etc.).

\begin{lstlisting}[style=coloredverbatim]
fn foo (useA : bool, lazy a : i32)-> i32 {
  if (useA) {
    a
  } else {
    0
  }
}
\end{lstlisting}

Laziness is a contract that must be acknowledged when working with a lazy
variable. In the next example, the function \token{foo} takes a lazy variable as
a parameter, so the contract must be accepted when setting up the function
call's arguments. This contract is essential to prevent unwanted behavior. Since
the value passed to the parameter \token{a} is only constructed within the
function \token{foo}, the function \token{bar} might never be called, depending
on the logic within \token{foo}. By explicitly using the \token{lazy} keyword
when constructing the value, the expected behavior is clearly evident at first
glance. The output of the program depicted in Listing~\ref{lst:(chap6):accept_laziness}
is presented in Listing~\ref{lst:(chap6):result_accept_laziness}, from that result one
can observe that the call to the function \token{bar} was made within the
function \token{foo}, and might have not be made at all as it is the case during
the second call of the function \token{foo}.

\begin{lstlisting}[style=coloredverbatim, label=lst:(chap6):accept_laziness, caption=Example of laziness contract acceptance]
fn foo (useA : bool, lazy a : i32)-> i32 {
  println ("In foo");
  let x = if (useA) {
    a
  } else {
    0
  };

  println ("Exit foo");
  x
}

fn bar ()-> i32 {
  println ("In bar");
  12
}

let a = foo (true, lazy bar ());
println ("a = ", a);
let b = foo (false, lazy bar ());
println ("b = ", b);
\end{lstlisting}

\begin{lstlisting}[style=bashVerb, caption=Result of execution of Listing~\ref{lst:(chap6):accept_laziness}, label=lst:(chap6):result_accept_laziness]
In foo
In Bar
Exit foo
a = 12
In foo
Exit foo
b = 0
\end{lstlisting}

Implementation of lazy variable is not presented in this section. To understand
the details of its implementation, closure and function pointers have to be
introduced, therefore we'll come back to lazy variables and their technical
implementation in Section~\ref{sec:impl_lazy_closure}.

\subsubsection*{Global variable}

All global variables are lazy, and in fact the keyword \token{lazy} is mandatory
to define a global variable. The

\subsection {Lazy mutable variable}
\label{sec:variable_lazy_mut}

A lazy variable can be mutable if it creates a value that borrows data. However,
since the variable itself is used to generate a value, we cannot change the
value it is associated with, but we can change the value it is borrowing. In a
sense, the behavior of a lazy variable (local, global or parameter) is similar
to the behavior of a parameter variable that borrows mutable data.

There are two reasons for this restriction. First, specifically for parameter
variables, since the variable is not a reference, changing its value would not
affect the value that was used when calling the function â€” a value that might
not have a memory location anyway. Second, this restriction applies not only to
lazy parameters but to all lazy variables that can be constructed in Ymir (e.g.,
local lazy variables, global lazy variables, etc.). If the value of a lazy
variable could be changed, two different outcomes could occur: 1. the lazy value
is constructed, and then the result value is changed, 2. the lazy value is not
constructed, and the value is set by the assignment. Both behaviors could be
acceptable but seem unnecessary and can be resolved more straightforwardly by
introducing another variable that is not lazy. For these two reasons, a lazy
variable can borrow mutable data but is never mutable itself.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
fn foo (lazy dmut a : [i32]) {
  @\hb{a = copy [1, 2, 3];}@ // error, a is not a lvalue
  a [0] = 3; // ok, a borrows mutable data
}

fn main () {}
  let lazy dmut a = lazy {
    println ("Allocate");
    copy [1, 2, 3]
  };

  a @\hb{=}@ copy [2, 3]; // prints "Allocate" ?
  // so, it is not allowed

  a [0] = 9; // ok, a borrows mutable data
}
\end{lstlisting}

In the following example, the variable \token{a} is a lazy mutable parameter
that borrows a slice of \token{i32}. As with any lazy value, it is constructed
when the variable \token{a} is referenced for the first time, which happens at
line \token{2}. Because the parameter \token{a} is lazy and borrows data, two
different contracts must be accepted when calling the function \token{foo}. This
is why the call at line \token{6} that passes the variable \token{i} uses both
keywords \token{lazy} and \token{alias}.

\begin{lstlisting}[style=coloredverbatim, caption=Example of lazy mutable parameter]
fn foo (lazy dmut a : [i32]) { a [0] = 9; }

let dmut i = copy [1, 2, 3];
foo (lazy alias i);

assert (i [0] == 9);
\end{lstlisting}

\notebox { When the two keywords \token{lazy} and \token{alias} are used
  together, they are always written in the same order: first \token{lazy},
  followed by \token{alias} (i.e., \token{lazy alias i}). The reason for this
  order is explained in Section~\ref{sec:impl_lazy_closure}, which discusses the
  technical implementation of lazy values. A value enclosed within the lazy
  value can be an implicit alias, such as when it makes a copy, calls a
  function, or is a block. Further details on memory management are provided in
  Chapter~\ref{chap:memory_management}. }

\vfill%
\pagebreak
