\section {Reference variable}
\label{sec:ref_variable}

The \token{ref} keyword can be used to decorate a variable when constructing it
with the \token{let} construct, or when declaring a parameter variable. Only
lvalues can be referenced. A reference value is equivalent to a pointer value,
except that it can never be null and is always associated with a memory segment,
making it safe to use. This keyword can only be used to describe a variable, a
type cannot be described as a reference, and it is impossible to store a
reference inside another value.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
  let dmut a = [1, 2, 3];
  let ref b = a; // no copy of /a/

  println (b [0]); // 1

  a [0] = 89;
  println (b [0]); // 89

  @\hb{b [0] = 9;}@// error, /b/ is immutable
\end{lstlisting}

In the above example, \token{b} is a pointer to the value of \token{a},
meaning that when the value of \token{a} changes, so does the value of
\token{b}. The following listing shows the YIL representation of the above
code, and Figure~\ref{fig:(chap6):ref_variable} illustrates the state of the stack when the
program is executed on a 64-bits system.

\begin{lstlisting}[style=lyilVerb]
  let a(#1) : [i32;3];
  let b(#2) : *([i32;3]);
  a(#1) = [1, 2, 3];
  b(#2) = &a(#2);
  _Y3std2io7printlnNi32Fi32Zv(*b(#2)[0]);
  a(#1)[0] = 89;
  _Y3std2io7printlnNi32Fi32Zv(*b(#2)[0]);
\end{lstlisting}

\input{chapters/chapter6/figures/ref_variable}

\subsection{Reference parameter variable}
\label{sec:ref_param}

The \token{ref} keyword can be used to decorate a parameter variable. This
decorator is used to pass a value by reference to a function. To pass a value by
reference to a function, nothing has to be done on the calling side if the
variable is not mutable and the referencing is made implicitely.

\begin{lstlisting}[style=coloredverbatim]
use std::io;
fn foo (ref x : i32) {
  println (x);
}

let a = 12;
foo (a); // ok, x is immutable in foo
\end{lstlisting}

\begin{lstlisting}[style=lyilVerb]
frame :  _Y4main3fooFRi32Zv (let x(#1) : *(i32))-> void {
    _Y3std2io7printlnNi32Fi32Zv(*x(#1));
}

frame :  _Y4main4mainFZv ()-> void {
    let a(#1) : i32;
    a(#1) = 12;
    _Y4main3fooFRi32Zv(&a(#1));
}
\end{lstlisting}

In the above example, the variable \token{a} is passed by reference to the
function \token{foo} however this reference is constant, and the function
\token{foo} cannot modified its value. It can be useful to pass a variable by
reference to avoid copying big datas, for example an array containing a lot of
elements and avoid copying all of them.

\input{chapters/chapter6/figures/ref_param_array}

In the Listing~\ref{lst:(chap6):result_copy_v_ref_array}, the value is not copied when passed to the \token{foo}
function, but is copied when passed to the \token{bar} function. The abstract
result of both functions is the same, but calling \token{foo} should be faster.
Figure~\ref{fig:(chap6):example_call_ref_array} and
Figure~\ref{fig:(chap6):example_call_copy_array} show the state of the stack when
calling the \token{foo} function on line 10 and the \token{bar} function on
line 11, respectively. These images are the abstract representation of the Ymir
Intermediate Language presented in the following listing.

\begin{lstlisting}[style=coloredverbatim, label=lst:(chap6):result_copy_v_ref_array, caption=Example of passing an array by reference vs. by value]
fn foo (ref x : [i32 ; 10]) {
  println (x [5]);
}

fn bar (x : [i32 ; 10]) {
  println (x [5]);
}

let a = [0 ; 10];
foo (a);
bar (a);
\end{lstlisting}

\begin{lstlisting}[style=lyilVerb, caption=YIL result of Listing~\ref{lst:result_copy_v_ref_array}]
frame :  _Y4main3barFA10_3i32Zv (let x(#1) : [i32;10])-> void {
    _Y3std2io7printlnNi32Fi32Zv(x(#1)[5]);
}
frame :  _Y4main3fooFRA10_3i32Zv (let x(#1) : *([i32;10]))-> void {
    _Y3std2io7printlnNi32Fi32Zv(*x(#1)[5]);
}
frame :  _Y4main4mainFZv ()-> void {
    let YI_1(#1) : [i32;10];
    let a(#2) : [i32;10];
    YI_1(#1) = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    a(#2) = YI_1(#1);
    _Y4main3fooFRA10_3i32Zv(&a(#2));
    _Y4main3barFA10_3i32Zv(a(#2));
}
\end{lstlisting}

Only a \textit{lvalue} can be passed to a function as a reference, otherwise it
does not really have a memory location, and therefore an address cannot be
assigned to it.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
fn foo (ref x : i32);

foo (@\hb{12}@); // error, 12 is not a lvalue
\end{lstlisting}

\subsection {Mutable reference variable}
\label{sec:mut_ref_param}

By default, a local reference variable and a parameter reference variable are
not mutable, but they can be made mutable using the \token{mut} and \token{dmut}
decorators.Unlike mutable value parameters, a mutable reference parameter can be
mutable even if it does not borrow any mutable data. In fact, as we saw in the
previous section, a reference parameter is a pointer that can never be null, so
it actually borrows data from another frame.

The contract of a function that presents a mutable reference parameter must be
accepted as it was mandatory for mutable parameters, but this time instead of
the keyword \token{alias} the keyword \token{ref} is used.

\begin{lstlisting}[style=coloredverbatim]
fn foo (ref mut x : i32) {
  x = 12;
}

let mut a = 1;
foo (ref a);
\end{lstlisting}

\begin {lstlisting}[style=lyilVerb]
frame :  _Y4main3fooFRi32Zv (let x(#1) : *(i32))-> void {
    *x(#1) = 12;
}
frame :  _Y4main4mainFZv ()-> void {
    let a(#1) : i32;
    a(#1) = 1;
    _Y4main3fooFRi32Zv(&a(#1));
}
\end{lstlisting}

As for the keyword \token{alias}, this keyword \token{ref} cannot be used in
vain and must be associated with a mutable reference parameter.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
fn foo (ref x : i32);

let mut a = 12;
foo (@\hb{ref}@ a); // forbidden, unecessary mutable reference

let b = 12;
foo (@\hb{ref}@ b); // forbidden, cannot create a mutable reference from a data that is not mutable
\end{lstlisting}

A local reference variable can be mutable as long as the value it references is
also mutable, and the contract has been accepted with the \token{ref} keyword.
It follows the same rules as those just presented for mutable reference
parameters.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
  let mut a = 12;
  let mut ref b = ref a; // ok

  b = 90;
  println (a); // 90
\end{lstlisting}

As for mutable reference parameters, the keyword \token{ref} is mandatory to
accept the mutable reference contract. This keyword can only be used on an
lvalue. In the next example, the contract is not respected at line 2. At line 5,
even if the variable is an lvalue and the keyword \token{ref} is used, because
the mutability of \token{c} is not deep enough to fit into the mutability of the
variable \token{d}, the compiler sends an error.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
  let mut a = 12;
  let @\hb{mut ref b = a;}@ // error, mutable reference requires ref keyword

  let mut c : [i32] = copy [1, 2, 3];
  let @\hb{dmut ref d = ref c;}@ // error, cannot fit mut [i32] into mut [mut i32]
\end{lstlisting}

\vfill%
\pagebreak
