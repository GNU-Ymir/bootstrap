\section{Variable mutability}
\label{sec:variable_mutability}

A variable is immutable by default, but can be made mutable using the
\token{mut} and \token{dmut} keywords. We saw in
Section~\ref{sec:preamble_compound_types} that values can borrow data depending
on their type. Since all the mutability information about specific types has
already been discussed in Chapter~\ref{chap:compound} for native compound types
and in Chapter~\ref{chap:custom_types} for user-defined types, we will not
discuss it further. Because type mutability is recursive, an inner type can only
be mutable if the type containing it is also mutable. Consequently, for a value
inside a local variable to be mutable, the variable itself must also be mutable.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
let a = 12;
@\hb{a = 9;}@ // error, /a/ is immutable

let mut b = 12;
b = 9; // ok, /b/ is mutable


let @\hb{c : [mut i32]}@ // error, /c/ is immutable, its inner value cannot be mutable
           = copy [1, 2, 3];

let mut d : [mut i32]  // ok, /d/ is of type mut [mut i32]
          = copy [1, 2, 3];


let dmut e = copy [1, 2, 3]; // same as /d/

d [0] = 9; // ok
e [0] = 10; // ok

let mut f = copy [1, 2, 3]; // /f/ is of type mut [i32]
@\hb{f [0] = 0;}@ // error, inner value of /f/ is immutable
f = copy [4, 5]; // ok, /f/ is mutable
\end{lstlisting}

\warningbox{
  The mutability of a variable exhibits specific behaviors when the variable is a
  reference or is lazy. These topics will be discussed in
  Sections~\ref{sec:ref_variable} and~\ref{sec:variable_laziness}.
}

\subsection{Mutability of a parameter variable}

A parameter whose type is borrowing data can be described as mutable. In this
case, because the parameter is borrowing mutable data, it must be explicitly
accepted when the function is called using the \token{alias} keyword. The
behavior is similar to assigning mutable borrowed data to a mutable variable,
and must follow the same rules regarding mutability levels.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
fn foo (dmut x : [i32]) {
  x [0] = 12; // ok, a is mutable
}

let dmut a = copy [1, 2, 3];
foo (alias a); // Ok, contract has been accepted

assert (a == [12, 2, 3]);

let dmut b = copy [1, 2, 3];
foo (@\hb{b}@); // forbidden, /b/ should be passed by alias

let c = copy [1, 2, 3];
foo (@\hb{alias c}@);// error, the mutability level of c is not high enough
\end{lstlisting}

Figure~\ref{fig:(chap6):example_mut_params} shows the stack and heap memory state when
the \token{foo} function is called at line 6 in the previous code. Note that
the value of \token{x} borrows the same value as \token{a} from the
\token{main} function, but they don't share the same memory address.

\input{chapters/chapter6/figures/mut_parameter}

The parameter itself is not mutable, and we cannot change the value to which it
is associated. This is because mutable data is passed by value, not by
reference. Therefore, in the following example, modifying the value borrowed by
the variable \token{x} on line 3 would have no effect on the value borrowed by
the value \token{a}. However, on line 3, the value borrowed by \token{x} is the
same as the value borrowed by \token{a}, so modifying it will modify the value
of both variables. It was decided that the parameters should not be lvalues in
order to completely separate the concept of reference parameters and value
parameters.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
fn foo (dmut x : [i32]) {
  @\hb{x = [4, 5, 6];}@ // forbidden, x is not a lvalue
  x [0] = 3; // ok, x borrows mutable data
}

let dmut a = copy [1, 2, 3];
foo (alias a);
\end{lstlisting}

To be allowed to be mutable, the mutability of the parameter must be deep enough
to actually touch borrowed data - and therefore imply an explicit alias of the
value associated with it during the call. For example, in the next example, even
if the parameter actually borrows data, the mutable modifier is not deep enough
and does not affect it. In this case, the compiler will reject the code and
return an error to avoid useless mutable decorators for parameter variables that
cannot change data. This rule is specific to function value parameters and does
not apply to default variables or reference parameters.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
// forbidden, a [0] is not mutable, and neither is a
fn foo (@\hb{mut a : [i32]}@);

// forbidden as well, a [0] is not borrowed, and a[0][0] is const
fn bar (@\hb{mut a : [mut [i32] ; 2]}@);

// obviously forbidden, no data are borrowed
fn baz (@\hb{mut a : i32}@);
\end{lstlisting}

If a parameter is constant, it is forbidden to associate a mutable variable with
it using the keyword \token{alias}. This keyword is used to indicate that the
contract for a data movement of borrowed mutable data has been accepted.
Approving code that uses this keyword when no mutable data is being moved would
have the undesirable effect of encouraging the keyword to be used even when
unnecessary, and thus as a kind of mandatory decorator, which would ultimately
defeat its main purpose of preventing unwanted mutable movement.

In the example below, the keyword \token{alias} is used in two different
contexts, both of which are incorrect. The first instance is on line 5, where
the variable \token{x} does not have mutable access to the data it borrows.
Therefore, it does not have the right to give this permission to another
variable, and the keyword \token{alias} is not allowed. In the second case, on
line 6, variable \token{y} has mutable access to the borrowed data, but it is
being passed to a variable that does not need mutable access. Therefore, the
keyword is unnecessary and not allowed. It is important to avoid using it for
every data movement without considering its usefulness, as this is a bad
practice, for that reason it is enforced by the compiler.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
fn foo (mut a : [mut i32]);
fn bar (a : [i32]);

let x = copy [1, 2, 3];
let dmut y = copy [1, 2, 3];

foo (@\hb{alias x}@); // forbidden, x is const
bar (@\hb{alias y}@); // forbidden, passing to a const does not require /alias/
\end{lstlisting}

\vfill%
\pagebreak
