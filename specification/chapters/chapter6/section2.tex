\section{Variable declaration}
\label{sec:local_variable_declaration}

This section presents how variables are declared within a source file,
describing their syntax and the purpose of each part.

\subsection{Grammar of a variable declaration}

There are three different kinds of variables that can be declared in Ymir:
local, parameter, and global variables. Global and parameter variables can be
declared using only one syntax. On the other hand, local variables can be
declared using four different syntaxes, each with a distinct purpose and
behavior, often used to deconstruct values in specific ways. The syntax
declarations for these types of variables are summarized in this subsection.

\subsubsection*{Global variable}

A global variable is declared at the global scope using the keyword
\token{lazy}. The keywords \token{mut} or \token{dmut} are optional and describe
the mutability property of the variable. Global variables, being lazy, have
specific mutability behaviors that are detailed in
Section~\ref{sec:variable_lazy_mut}. The identifier of a variable follows the
same syntax as any identifier in Ymir. The type part of the variable declaration
is optional (cf. Section~\ref{sec:variable_type}), and its syntax is any
expression that can describe a type. The value part of the declaration is
mandatory for a global variable (cf. Section~\ref{sec:variable_init_value}), and
its syntax is any expression that can describe a value.

\begin{lstlisting}[style=bashVerb]
global_variable := 'lazy' ('mut' | 'dmut')? Identifier (':' type)? '=' value ';'
\end{lstlisting}

\subsubsection*{Parameter variable}

A parameter variable is declared within the list of parameters of a function
declaration. The follow the syntax presented in the listing below. The
identifier of a variable follows the same syntax as any identifier in Ymir. The
type part of the variable declaration is mandatory (cf.
Section~\ref{sec:variable_type}), and its syntax is any expression that can
describe a type. The value part of the declaration is optional for a parameter
variable (cf. Section~\ref{sec:variable_init_value}), and its syntax is any
expression that can describe a value.

\begin{lstlisting}[style=bashVerb]
parameter_variable := decorator Identifier ':' type ('=' value)?
\end{lstlisting}

\subsubsection*{Local variable}
\subsubsection*{Iterator variable}
\subsubsection*{Pattern variable}
\subsubsection*{Disposable variable}

\subsection{Variable lifetime and shadowing}

The lifetime of a local and parameter variable begins when it is declared and
ends when the scope containing the variable declaration is exited. Two variables
with the same name cannot be alive at the same time. Defined by opening and
closing curly braces, a scope determines the lifetime of the variables declared
within it.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
fn main () { // start of a scope
  let a = 12;
  { // start of a second scope

    println (@\hb{b}@ + a); // error, /b/ is not defined yet
    let b = 24;

    println (b + a); // Ok, /b/ and a are defined

    let @\hb{a}@ = 89; // error, /a/ is already defined
  } // exiting the second scope

  println (@\hb{b}@ + a); // Error, /b/ does not exist anymore
  let b = 9; // ok, /b/ from second scope is not alive anymore
}
\end{lstlisting}

Global variables have no specific lifetime; they exist from the start of the
program until its end. Therefore, they are accessible at any point of time, and
from anywhere that has public access to them, as discussed in
Section~\ref{sec:symbol_protection}.

Because global variables are accessible from their parent symbol (the module in
which they are described), there is a way to avoid variable shadowing problems.
If two global variables with the same name cannot be declared within the same
module, a global variable never shadows the declaration of a local or a
parameter variable. In the following example, the local variable \token{pi}
declared at line 6 is allowed because it is not shadowed by the global variable
declared at line 3. However, the declaration of the local variable \token{tau}
at line 7 is not allowed because it is shadowed by the parameter variable
described at line 5.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
mod foo;

lazy pi = 3.1415926535; // global variable

fn calculate (tau : f64) {
  let pi = 3.14; // local variable (allowed, global pi is still accessible through the module foo)
  let @\hb{tau}@ = 6.28; // error, shadows parameter
}

\end{lstlisting}

\subsection{Scope value}

As presented in Section~\ref{sec:function_body}, a scope has a value if the last
expression contained in the scope is a value and does not end with the \token{;}
token. The value can be used as any other expression value (e.g. as the value of
a variable declaration).

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
let a = {
  let b = 12;
  b + 12
};

let c = {
  let b = 12;
  b + @\hb{c}@ // error, /c/ does not exist yet
};
\end{lstlisting}

\subsection{Variable initial value}
\label{sec:variable_init_value}

A local variable is always declared with an initial value. The goal is to ensure
that any data in the program came from somewhere, and is not initialized from a
random memory state of the machine running the program (as we can have in the C
language). One can argue that static verification can be used to ensure that a
variable is set before it is used, and argue that forcing an initial value on a
variable is not the best way to achieve data validity. While this is more a
matter of opinion than sound scientific reasoning at this point, we believe that
scattering the initialization of a variable makes programs harder to read. In
addition, immutable variables would initially be mutable, making the behavior of
a program even more difficult to understand. In the following listings, two
examples of source code with the same behavior are presented. On the left, a
valid source code that is accepted by the Ymir language, and on the right, a
source code that is not accepted based on the arguments we presented.

\hspace{-15pt}%
\begin{minipage}[t][][t]{0.47\linewidth}
  \begin{lstlisting}[style=coloredverbatim, escapechar=@, caption=Valid]
fn foo (cond : bool) {
  let i = if cond {
    42
  } else {
    7
  };
}
  \end{lstlisting}
\end{minipage}\hspace{10pt}%
\begin{minipage}[t][][t]{0.47\linewidth}
  \begin{lstlisting}[style=coloredverbatim, escapechar=@, caption=Invalid]
fn foo (cond : bool) {
  let i : i32;
  if cond {
    i = 42;
  } else {
    i = 7;
  };
}
  \end{lstlisting}
\end{minipage}

In the context of function call, a parameter variable is invariably associated
with a value. This stems from the fundamental requirement that when invoking a
function, each parameter must be initialized with a value; no parameter can
remain uninitialized. Thus, at the point of function call, all parameters
inherently possess a defined value. On the contrary, as for a local variable, a
global variable must be associated with a value. This value is constructed
lazily when the variable is first referenced in the program.

\begin{lstlisting}[style=coloredverbatim]
lazy X; // error, x has no initial value
lazy Z = foo (); // ok, will take the return value of foo when first referenced in the program
\end{lstlisting}

In the above listing, the global variable \token{Z} will takes on the return
value of the function \token{foo} when \token{Z} is first referenced in the
program. This lazy initialization ensures that Z is constructed only when its
value is needed, optimizing performance by delaying computation until necessary.
More information about lazy variables is presented in
Section~\ref{sec:variable_laziness}.

\subsection{Unused variable}
\label{sec:unused_variables}

A declared local or parameter variable has to be used during its lifetime,
otherwise the compiler will send an error, as the variable is useless and only
complexify the source code with dead code.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
{
  let a = 12;
@\hb{\}}@ // error, /a/ is defined but not used
\end{lstlisting}

There are two ways to force the compiler to ignore an unused variable, the first
is to use a special identifier for the variable, either by putting an underscore
at the beginning and end of the variable (e.g. \token{\_a\_}), or by naming the
variable directly \token{\_}. A variable named \token{\_} is anonymous and
cannot be used at all. The second way is to use the variable in a statement.
This statement can be empty (i.e. \token{a;}). Function parameters follow the
exact same semantic, and therefore must be used within the body of the function.
They can be used or ignored with the same system as local variables.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
{
  let _a_ = 12;
} // ok, /_a_/ is an ignorable variable

{
  let _ = 12;
} // ok, /_/ is anonymus

{
  let a = 12;
  a; // using the variable
} // ok, all variables were used
\end{lstlisting}

Global variables can remain unused. As explored further in this chapter, global
variables are inherently lazy in Ymir, meaning they are constructed only upon
first reference. Additionally, because global variables can be accessed from any
symbol with public access (cf. Section~\ref{sec:symbol_protection}), including
from external packages, it is impossible to guarantee that a global variable
will never be accessed. Consequently, there is no enforcement mechanism to
ensure that global variables are used, and they can be declared without being
referenced in the program.

\subsection{Variable type}
\label{sec:variable_type}

The type of the variable is automatically infered from the value that is
associated to it. Sometimes the compiler may fail the inference, or multiple
types can be associated to a specific value by implicit casting. To solve that
problem a type can be attached to a variable declaration using the token
\token{:}. The type specified must of course be compatible with the type of the
value.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
let a = 12; // automatically infering i32
let b : i32 = 12; // declaring i32

let c : i64 = 12; // ok, implicit cast to i64
let d : [c8 ; 5] = "Hello"; // ok implicit cast from [c8] to [c8 ; 5]
\end{lstlisting}

Some values needs an explicit type to be used as variable initialization values.
For example the value \token{none} that creates an empty option values has no
inner type on its own. In fact its inner type is deduced from the type of the
lvalue that will receive it during affectation. Other types such as \token{void}
can simply not be used for variable declaration as they do not contain a value.
To create a variable with no value, an empty tuple \token{()} can be used.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
let @\hb{a = none;}@ // error, cannot create a variable with type (none)?
let b : (i32)? = none; // ok, type is explicitely defined

let @\hb{c = {};}@ // error, cannot create a var of type void
let @\hb{d : void = {};}@ // error, even by explicitely writing it

let e = (); // ok empty tuple
let f : () = (); // ok, same as /e/
\end{lstlisting}


\vfill%
\pagebreak
