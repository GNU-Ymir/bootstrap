\section {Ranges}%
\label{sec:range_type}

Range is a compound type consisting of four elements that describe a range of
values. The four elements are \token{fst} the first value of the range (e.g.
\token{0}), \token{scd} the last value of the range (e.g. \token{10}),
\token{step} the step of the range (e.g. \token{2}), and \token{contains} of
type bool, which indicates whether the last value \token{scd} is contained in
the range or not. There are only three types that can describe the inner
components of a range: integer, floating point and character. The type of the
range is defined by the inner type preceded by the token \token{..} (e.g.
\token{..i32} describes a range of \token{i32} values). Ranges are useful for
iteration or for accessing a subset of values (for example, a subset of a
slice).

\subsection {Literals}

Range literals are described using the \token{..} token or the \token{...}
token. The \token{..} token is used to define a range whose final value is not
included in the range, and the \token{...} token defines a range whose final
value is included. If different tokens are used to describe the literal, the
type is the same, and the \token{..} token is always the only token used to
describe a range type.

\begin{lstlisting}[style=coloredverbatim]
let a : ..i32 = 0 .. 2;
let b : ..i32 = 0 ... 2;

assert (a.fst == b.fst);
assert (a.scd == b.scd);
assert (a.step == b.step);
assert (!a.contain && b.contain);
\end{lstlisting}

Range values can be decreasing, in which case the step is negative. Note that
for ranges of unsigned integers and character values, it is theoretically
impossible to have a negative value for the step. However, there is a bit of
cheating going on here, using the overflow limitation of types to create a value
that, when added to \token{fst}, equals \token{fst - abs (step)} (in practice,
this is exactly the same as adding a negative value at the binary level, but it
is not really the valid high level representation). For this reason it can be
considered that step is always a signed version of the type, even if the field
type is considered to be the same as the type of the inner values (\token{fst}
and \token{scd}), and thus one bit of its encoding is always used for the sign.
\smallskip

The \token{fst} value of the range literal is constructed before the
\token{scd} value. In the following example, the function \token{foo} is
called before the function \token{bar}.

\begin{lstlisting}[style=coloredverbatim]
fn foo ()-> i32 {
  println ("In foo.");
  12
}

fn bar ()-> i32 {
  println ("In bar.");
  1
}

let a = (foo ()) .. (bar ());
\end{lstlisting}

\subsection {Mutability and memory alignement}

As one might expect, range values do not share any data, and every field
included in the value is replicated during data movement. Therefore, there is no
concern for mutability, rendering the type not aliasable. A mutable range has
the ability to modify its internal fields, but even if the range type is a
compound type, it operates precisely like a scalar type since it can never
contain any borrowed data. In memory a range value has the same memory
alignement as the structure (cf. Chapter~\ref{chap:structures}) presented in the
following source code where \token{T} is the inner type of the range.

\begin{lstlisting}[style=coloredverbatim]
struct Range {T} {
  let fst : T;
  let scd : T;
  let step : T;
  let contain : bool;
}
\end{lstlisting}

\subsection {Properties}

Range type properties can be accessed through the operator \token{::} applied
to a type expression. The following properties include:

\begin{center}\begin{adjustbox}{max width=\linewidth}
  \begin{tabular}{|l|ll|}
    \hline
    Name & Meaning & Type\\
    \hline
    \hline
    \texttt{init} & The initial value ranging from \texttt{T::init} & \texttt{typeof (x)}\\
    & to \texttt{T::init} with a step of \texttt{T::init} and & \\
    & with \texttt{contain} set to \texttt{false} where \texttt{T} is & \\
    & the inner type (e.g. \texttt{i32} for \texttt{..i32}). &\\
    \hline
    \texttt{typeid} & A string encoding the name of the type & \texttt{[c8]} \\
    \hline
  \end{tabular}
\end{adjustbox}\end{center}


\subsection {Binary operators}

Binary operators are divided into 4 groups:

\begin{itemize}
  \setlength\itemsep{-4pt}
\item Access: The operator \token{.} is utilized to access the field of the
  range type. The right operand is the name of the field to access. The fields
  are listed in the table below.

  \begin{center}\begin{adjustbox}{max width=\linewidth}
    \begin{threeparttable}
      \begin{tabular}{|l|ll|}
        \hline
        Name & Value & Type\\
        \hline
        \hline
        \texttt {fst} & The first value of the range & \textit{T}$^{1^{\phantom{j}}}$ \\
        \texttt {scd} & The second value of the range & \textit{T}$^{1^{\phantom{j}}}$ \\
        \texttt {step} & The step of the range & \textit{S}$^{2^{\phantom{j}}}$ \\
        \texttt {contain} & The field describing wether or  & \texttt{bool} \\
        & not the scd value is contained in the range &\\
        \hline
      \end{tabular}
      \begin{tablenotes}
      \item[1.] \texttt{\_\_pragma!inner (typeof (x), 0)}
      \item[2.]\small \textit{Signed version of inner type for integer type
        ranges, an integer type for character type ranges, and
        \texttt{\_\_pragma!inner (typeof(x), 0)} for float type ranges.}
      \end{tablenotes}
    \end{threeparttable}
\end{adjustbox}\end{center}

Accessed fields are only mutable if the range is also mutable.

\item Contains: The \token{in} and \token{!in} operators verify the presence
  of a value in a range. The left operand must match the inner type of the right
  operand, and the right operand must be a range type.

\item Comparison: Ranges can be compared using the operators \token{==} and
  \token{!=}. This checks the equality or inequality of each field within the
  range. It is important that the left and right operands are of the same type.

\item Affectation: A range value can be an lvalue if and only if it is mutable.
  \begin{lstlisting}[style=coloredverbatim]
let mut a = 0 .. 7;

a = 7 .. 1;
  \end{lstlisting}

\end{itemize}

\subsection {Range iteration}

 Ranges are iterable types, so they can be used as the iterable value of a
 \token{for} loop. Only one immutable variable can be declared when iterating
 over a range value. This iterator variable takes the value of the \token{fst}
 field of the range and increments by the \token{step} field until it reaches
 the \token{scd} field. If the range is a containing range (i.e. the
 \token{contain} field is true), then the \token{scd} field is included in
 the iteration. Optimisations are performed if the inner values of the range are
 known at compile time.

\begin{lstlisting}[style=coloredverbatim]
for i in 0 .. 7 {
    print (i, ' '); // 0 1 2 3 4 5 6
}

for i in 0 ... 7 {
    print (i, ' '); // 0 1 2 3 4 5 6 7
}

for i in 7 .. 0 {
    print (i, ' '); // 7 6 5 4 3 2 1
}
\end{lstlisting}

For more information on \token{for} loops, see the Section~\ref{sec:for_loop}.

\vfill%
\pagebreak
