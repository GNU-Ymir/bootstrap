\section{Arrays}

 An array is a compound type containing a list of values of the same type stored
 in a contiguous memory segment and whose size is known at compile time. An
 array type is described using the following syntax \token{[T ; N]} where
 \token{T} is the inner type of the array and \token{N} is an integer value
 describing the number of elements contained in the array.

\subsection {Literals}

Array literals are a list of values enclosed in brackets \token{[} and
  \token{]}. An array literal of size \token{0} contains no data and consists
only of the brackets, its type is always \token{[void ; 0]}, and it can be
assigned to any lvalue with an array type whose size is \token{0}.

\begin{lstlisting}[style=coloredverbatim]
fn foo (x : [i32 ; 4]) {}

let a = [1, 2, 3]; // array [i32 ; 3]
let b : [i32 ; 3] = [1, 2, 3]; // array [i32 ; 3]

foo ([1, 2, 3, 4]); // calling with an array [i32 ; 4]

let c : [i32 ; 0] = []; // ok [void ; 0] can be implicitely casted to [i32 ; 0]
\end{lstlisting}

Array inner values are constructed in the order they are written. In the
following example, the function \token{foo} is called before the function
\token{bar}.

\begin{lstlisting}[style=coloredverbatim]
fn foo ()-> i32 {
  println ("In foo.");
  1
}

fn bar ()-> i32 {
  println ("In bar.");
  2
}

let a : [i32 ; 2] = [foo (), bar ()];
\end{lstlisting}

There are two other ways to define an array literal value. The first is the
array construction syntax. This syntax is similar to the type description of the
type array, but uses a value instead of a type \token{[V ; N]}. Each element of
the array takes the value \token{V}. When this syntax is used, the inner value
is constructed only once and replicated at each index of the array. In the
following example, the function \token{foo} is called once and each index of
the array contains the value \token{12}.

\begin{lstlisting}[style=coloredverbatim]
fn foo ()-> i32 {
  println ("In foo.");
  12
}

let a = [foo () ; 4];
assert (a [0] == a [1]);
\end{lstlisting}

\smallskip
The last array literal syntax uses a \token{for} loop. This syntax, called list
comprehension, is explained in more detail in the Section~\ref{sec:list_compr}.
Unlike the array construction syntax, the values are calculated at each index of
the array, so the function is called four times in the following code, when it
would have been called only once using the array construction syntax.

\begin{lstlisting}[style=coloredverbatim]
fn foo ()-> i32 {
  println ("In foo.");
  12
}

let a = [foo () for i in 0 .. 4];
assert (a [0] == a [1]);
\end{lstlisting}


\subsection {Mutability and memory alignement}
Arrays do not borrow data because they store data as the actual list of values
contained in the array. Therefore, when data is moved, all the data in the array
is copied. The mutability level of an array is only important if the inner type
of the array borrows data, similar to tuples. Figure~\ref{fig:data_repr_array}
shows the memory representation of the following example.

\begin{lstlisting}[style=coloredverbatim]
let dmut a : [i32 ; 3] = [1, 2, 3];

let dmut b = a; // no need for alias
                // a and b don't refer to the same memory segment

let i = 89;
let c : [*i32 ; 1] = [&i];

let dmut d = c; // not allowed, discard const property of the inner type
\end{lstlisting}

\input{chapters/chapter4/figures/array_mutability}

\subsection {Properties}

Array type properties can be accessed using the \token{::} operator on a type
expression. The properties are as follows:

\begin{center}\begin{adjustbox}{max width=\linewidth}
  \begin{tabular}{|l|ll|}
    \hline
    Name & Meaning & Type\\
    \hline
    \hline
    \texttt{init} & The initial value, where all & \texttt{typeof(x)} \\
    & inner values are set to  & \\
    \Xhline{0.001pt}
    \texttt{size} & The static size of the array (is equal to \texttt{.len}) & \texttt{usize} \\
    \hline
    \texttt{typeid} & A string encoding the name of the type & \texttt{[c8]} \\
    \hline
  \end{tabular}
\end{adjustbox}\end{center}

\subsection {Binary operators}

Binary operators are divided into four groups:

\begin{itemize}
  \setlength\itemsep{-4pt}
\item Access: The \token{.} operator is used to access fields that describe the
  array value. The right operand is the name of the field to be accessed. These
  fields are described in the table below.

  \begin{center}\begin{adjustbox}{max width=\linewidth}
      \begin{threeparttable}
        \begin{tabular}{|l|ll|}
          \hline
          Name & Value & Type\\
          \hline
          \hline
          \texttt{len} & The size of the array & \texttt{usize} \\
          \texttt{ptr} & The pointer to the first element  & \textit{T}$^{1^{\phantom{J}}}$\\
          & of the array & \\
          \hline
        \end{tabular}
        \begin{tablenotes}
        \item [1.] inner type of the array, i.e. \texttt{*(\_\_pragma!inner (typeof (x), 0))} \\
        \end{tablenotes}
      \end{threeparttable}
\end{adjustbox}\end{center}

The \token{len} field is known at compile time and can therefore be used in
a \token{cte} expression. The type of the \token{ptr} field has the same
level of mutability as the array type. Note that array does not really have
fields. The values are constructed from the array information, \token{ptr}
takes the address of the array as a value, and \token{len} is an integer
literal containing the length of the array in number of elements contained.

\item Concatenation: The concatenation operator \token{\~} is used to create an
  array or slice containing the values of two arrays or slices. The operator can
  be used if the left and right operands have the same internal type, regardless
  of their relative sizes. The mutability of the generated value is the
  strictest mutability between the two operands. For example, the type and
  mutability of \token{([*i32 ; 4]) \~\ (dmut [*i32 ; 2])} is \token{[*i32 ;
      6]} to avoid discarding the constant property of the values contained in
  the left operand. Notice that the type of the generated value is an array
  whose size is the sum of the left and right operand sizes.

  The operator can also be used when one of the operands is a slice. In this
  case, the return value of the operation will be a slice instead of an array,
  since its size cannot be known at compile time. This operation is actually
  performed more by the slice operand than by the array operands, and is
  discussed further in the section~\ref{sec:slices}.

  The operator \token{\~} was chosen to avoid confusion with \token{+}, which
  would behave differently depending on the operands.Concatenation is not really
  an arithmetic operation, as \token{+} would refer to an addition of all the
  inner values of two arrays, rather than their concatenation. Concatenation
  operator is obviously not commutative.

  \begin{lstlisting}[style=coloredverbatim]
let a : [i32 ; 3] = [1, 2, 3];
let b : [i32 ; 2] = [4, 5];

let c : [i32 ; 5] = a ~ b;

assert (c == [1, 2, 3, 4, 5]);
  \end{lstlisting}

\item Comparison: Binary comparison operators can be used with two arrays of the
  same inner type, or an array and a slice of the same inner type. The result of
  the operation is always of type \token{bool}. For the operators to work, the
  inner type of the array must also define the comparison operators. Lexical
  order is used, so the size of the arrays are only used if one of the two operands
  is a prefix of the other (e.g. \token{[1, 2]} is a prefix of \token{[1, 2,
      3]}, so \token{[1, 2, 3]} is considered greater than \token{[1, 2]}, but
  \token{[1, 3]} is greater than \token{[1, 2, 3]}).

  \begin{center}\begin{adjustbox}{max width=1.0\linewidth}
    \begin{tabular}{|c|lll|}
      \hline
      Operator & Operation & Comm. & Example\\
      \hline
      \hline
      \texttt{>}      & Greater than     & No          & \texttt{([1, 2] > [2, 3]) == false}    \\
      \texttt{<}      & Lower than       & No          & \texttt{([1, 2] < [2, 3]) == true}     \\
      \texttt{>=}     & Greater or equal & No          & \texttt{([1, 2, 3] >= [1, 2]) == true} \\
      \texttt{<=}     & Lower or equal   & No          & \texttt{([1, 2, 3] <= [2]) == true}    \\
      \texttt{==}     & Equal            & Yes         & \texttt{([1, 2] == [1, 2]) == true}    \\
      \texttt{!=}     & Not equal        & Yes         & \texttt{([1, 2] != [1, 2]) == false}   \\
      \hline
    \end{tabular}
  \end{adjustbox}\end{center}

\item Affectation: An array value can be an lvalue if and only if it is mutable.
  Information about inner type mutability has already been discussed in the
  section on mutability, and will therefore not be discussed further here. The
  size of the left and right operands must of course be strictly equal.

  \begin{lstlisting}[style=coloredverbatim]
let mut a : [i32 ; 2] = [1, 2];

a = [2, 3];
  \end{lstlisting}

\end{itemize}

\subsection {Index operator}

The index operator can be used on an array as the left operand, with an int
value or a range value as the right operand.

\begin{itemize}
  \setlength\itemsep{-4pt}
\item With an int value; The element at the index described by the int value is
  returned. The mutability of the result value depends on the mutability of the
  inner type of the array. If the mutability level of the array type is at least
  \token{2}, the result value can be used as lvalue.

  \begin{lstlisting}[style=coloredverbatim]
let mut a : [mut i32 ; 3] = [1, 2, 3];
let mut b : [i32 ; 2] = [4, 5];

a [0] = 9; // ok, mutability level of 'a' is high enough

b [0] = 11; // not allowed, b inner values are not mutable
b = [9, 10]; // ok, b is mutable
  \end{lstlisting}

  If the value of the int operand is known at compile time, a size check is
  performed to ensure that the access does not overflow the array size, and that
  the value used is greater than or equal to zero. If the value is unknown at
  compile time, a condition is added and an array size check is performed at
  runtime. Panic is triggered if an overflow occurs.

  In the first version of Ymir, the exception
  \token{core::exception::OutOfArray} was thrown, which forced developers to
  deal with the exception. This made the program extremely strict, forcing the
  developer to double check every array access by hand. Programming became
  relatively impractical. Developers generally responded to this problem with
  control flow \token{try \{ \} catch \{ panic; \}}. Thus, a faster
  compiler-generated approach was chosen (i.e., \token{if (out) panic;}). This
  test is turned off if the compiler can ensure the inboud test without knowing
  the exact value of the index.

\item With a range value; using a range value containing int values as the right
  operand, the program creates a slice containing only a subset of the array
  values. The mutability level of the created slice type is the same as the
  mutability of the array type. The \token{copy} operator must be used to create
  the slice value, as it allocates memory on the heap (see Slice
  limitation~\ref{sec:slice_lim}) and to prevent implicit memory allocations.

  \begin{lstlisting}[style=coloredverbatim]
let a : [i32 ; 4] = [1, 2, 3, 4];

let b : [i32] = copy a [0 .. 2];
  \end{lstlisting}

  If the inner values of the range are known at compile time, it is checked that
  there will be no array overflow. The range must be ascending, i.e. the first
  value of the range must be less than the second value. This is also checked at
  compile time if possible. If the values of the range are not known at compile
  time, then these checks are done at runtime. The contain field of the range
  has no effect on the array access, and the \token{scd} value is always
  considered not contained.

  If the range used to index the array is known at compile time, a new array
  value can be created. In that case the \token{copy} operator is no more
  mandatory, and the result of the operand is an array value.

  \begin{lstlisting}[style=coloredverbatim]
fn foo (a : [i32 ; 3]) {
  println (a);
}

let a = [1, 2, 3, 4];
foo (a [1 .. 4]);
  \end{lstlisting}

\end{itemize}

\subsection {Dollar operator}

The dollar operator can be used within an index operation in the right operand
expression. The dollar value takes the value of the size of the array and its
type is \token{usize}. Its value is known at compile time.

\begin{lstlisting}[style=coloredverbatim]
let a : [i32 ; 4] = [1, 2, 3, 4];

let b = a [0us .. $ - 1us]; // all the values except the last one

let c = a [$ - 2us]; // The second value to the last
\end{lstlisting}

\subsection {Array iteration}

Arrays are iterable types, so they can be used as iterable values of a
\token{for} loop. The \token{for} loop can use either one or two variables as
iterators. If a single variable is used, it automatically captures the value of
the array element at the current iteration index. Conversely, if two variables
are used, the first variable represents the iteration index, while the second
variable stores the value of the array element at that specific index.

\begin{lstlisting}[style=coloredverbatim]
let a : [i32 ; 4] = [1, 2, 3, 4];
for i, elem in a {
    assert (a [i] == elem);
}

// Only 1 iterator, captures the value
for elem in a {
  println (elem); // 1 2 3 4
}
\end{lstlisting}

In practice, a slice is created over the array value (without copying) to ensure
that the array is created only once. Thus, the above code is rewritten as
follows by the compiler. This code is not valid ymir source code, but a
representation of what the compiler generates before performing optimizations.

\begin{lstlisting}[style=myilVerb]
let mut a : mut [mut i32 ; 4us] = [1, 2, 3, 4];
{
  let #_value : [mut i32] = {.len = 4us, .ptr = &a[0]};
  let elem : i32;
  let i : usize = 0us;
  while (i < #_value.len) {
    elem = #_value [i];
    {
      core::exception::abort (a [i] == elem, (""s8)[]);
      <unit-value>
    };
    i = (i + 1us)
  }
}
\end{lstlisting}


\subsection {Array expansion}

The special operator \token{expand} can be used on arrays, to turn them into a
list of parameters. This operator can be used to pass the values of an array as
function parameters, or to construct another array, or even a tuple.

\begin{lstlisting}[style=coloredverbatim]
fn foo (a : i32, b : i32) {}


let a : [i32 ; 2] = [1, 2];
let b : [i32 ; 3] = [expand a, 3];

foo (expand a);

let c : (i32, i32, i32) = (expand b,); // finishing coma is mandatory because it's a tuple literal
\end{lstlisting}

This operation is done at compile time and is simply a less verbose rewrite. In
fact, in the previous example, the line \token{foo (expand a)} is rewritten as
\token{foo (a [0], a [1])}. The mutability level of the expanded values is
always \token{1}, i.e. array expansion can never borrow mutable data. This
operation can be done because the size of an array is known at compile time. The
above example produces the following Ymir Intermediate Language code.

\begin{lstlisting}[style=myilVerb]
frame : main::main ()-> void {
    let a : [i32 ; 2us] = [1, 2];
    let b : [i32 ; 3us] = [a [0us], a [1us], 3];
    main::foo (a [0us], a [1us]);
    let c : (i32, i32, i32) = (b [0us], b [1us], b [2us]);
    c;
    <unit-value>
}
frame : main::foo (a : i32, b : i32)-> void {
    a;
    b;
    <unit-value>
}
\end{lstlisting}


\subsection{Implicit casting}

Array literal values may contain literal values that can be implicitely
converted during compilation (e.g. integer literals, tuple construction values,
class objects, etc.). In this case, the conversion is performed at \token{cte}
implicitely.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
// ok, '1' literal can be implicitely converted to '1us'
let mut a : [usize ; 2] = [1, 2];

let mut i = 12;
// error, 'i' is not cte, it cannot be converted
a = @\hb{[i, i]}@;
\end{lstlisting}

This implicit casting is recursive and allowed for any inner values that might
be affected, but it only applies to array literal values, not to any array
values, even immutable ones.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
// No problem, '0' is converted implictely to '0us', and so on
let a : [(usize, isize) ; 2] = [(0, 8), (1, 2)];

// error, implicit cast is not allowed 'a' is not a array literal
let b : [(i32, i32) ; 2] = @\hb{a}@;
\end{lstlisting}

\subsubsection{Implicit conversion of string literal}

String literals (see section~\ref{sec:string_lit}) can be converted to array
values at compile time. String literals are in the text, and thus are pointers to
text segments, hence their proximity to the slice type. However, since their
values are actually known at \token{cte}, they can be converted to array
literal values. This conversion is done implicitly using an array type value as
lvalue and a \token{cte} string literal value as rvalue.

\begin{lstlisting}[style=coloredverbatim]
let a : [c32 ; 5] = "Hello";
let b : [c8 ; 5] = "Hello"; // no need for suffix, implicit char conversion is allowed on cte values
\end{lstlisting}

The program's behavior differs when using array values stored on the stack
compared to using slices. In this case, the program uses 25 bytes of memory on
the stack, whereas slices would have used 32 bytes on a 64-bit system. This is
because the array values use 5 times 4 bytes (for the \token{c32} array) plus 5
bytes (for the \token{c8} array), while slices would have used 2 pointers and 2
\token{usize}. For big string literals, it has to be taken into account.

\vfill%
\pagebreak
