\section{Options}%
\label{sec:options}

An option is a compound type that represents the encapsulation of an optional
value. An option type is described using the syntax \token{T?}, where
\token{T} is the type of the optional value encapsulated in the option. An
option value can be in two different states, \token{Ok} where the encapsulated
optional value is set, \token{Err} where the optional value is not set. In the
\token{Err} state, the value can contain an exception value of type
\token{\&Exception} (see Chapter~\ref{chap:Error_handling}) describing the
reason for the error. Option type and error handling are very close in Ymir and
are described in more detail in Chapter~\ref{chap:Error_handling}.

\subsection{Literals}

There are two kinds of option type literals to describe the two states an option
value can be in. The first literal, which constructs an option value from the
value that it encapsulates, uses the syntax \token{V?}, where \token{V} is the
value that is encapsulated. The type of such a literal is \token{typeof(V)?}.
The second sort of literal that can be used is the keyword \token{none}, which
describes an option value with no encapsulated value and no error description;
this is the simplest way to create an error option value. The type of the value
created by the keyword \token{none} is inferred from the lvalue to which the
value is moved (e.g. the return type of a function, a variable type, etc.), but
has no type per se. An error option value can also be created from a value that
throws an error, this is discussed further in Chapter~\ref{chap:Error_handling}.

\begin{lstlisting}[style=coloredverbatim]
fn foo ()-> i32? { // optionnaly return an i32 value
  none // create an error option value
}

let a = 12?; // i32? option value
let b : void? = (
  match foo () { // pattern matching on the value return by 'foo'
    Ok (i : i32) => { // foo returned an i32 value
      println ("Foo value is set : ", i);
    }
    Err () => { // foo returned nothing
      throw AssertError::new ("Foo value is unset");
    }
  }
)? // '?' token to encapsulate the error throwing in an option

\end{lstlisting}

\subsection{Mutability and memory alignement}

Option values reside on the stack. They don't borrow or allocate the value they
encapsulate. Of course, they can be borrowing values if the value they
encapsulate is a borrowing value. Option values can be described using a
\token{union struct} and a \token{struct}, as described in the following code.
There are several ways to access the values encapsulated within an option value.
The most common way is to use pattern matching and other language elements
designed specifically for option types. The data alignment and size of an option
encapsulating a value of type \token{T} is exactly the same as it would be for
a value whose type is the structure \token{OptionType!{T}}.

\begin{lstlisting}[style=coloredverbatim]
@union
struct InnerType {T} {
  let error : &Exception;
  let value : T;
}

struct OptionType {T} {
  let set : bool;
  let content : InnerType!{T};
}
\end{lstlisting}

The \token{hasValue} field in the \token{OptionType} definition describes the
behavior of the option value with respect to the content value. If it is
\token{true}, then \token{content.value} is set and used, and if it is
\token{false}, then \token{content.error} may be set, but not necessarily.
Option values have a free pass to define the class reference value
\token{content.error} as \token{null}. Normally class references are always
set in Ymir, but in the specific case of option values, if an option value is in
the \token{error} state, then the \token{content.error} value can be equal to
the \token{null} value, behaving more like a pointer than a reference. This is
taken into account during pattern matching and field access. From the developer
point of view, the error field cannot be accessed if empty, an error would be
thrown otherwise (cf. Access binary operator).

Option can contain mutable inner values, in which case the option value must
also be mutable. The syntax to specify that the inner value should be mutable is
the following \token{mut (mut T)?}. The mutability level of an option type
behaves exactly like the mutability level of an array type.

\begin{lstlisting}[style=coloredverbatim]
let dmut a : (i32)? = 12?;
let dmut b : ([i32])? = (copy [1, 2, 3])?;

let dmut c = a; // ok, no memory borrowing, just implicit stack copy
let dmut d = b; // error inner slice would be borrowed implicitely
let dmut e = alias b; // ok no implicit alias, 'copy' would also work
\end{lstlisting}

\subsection{Properties}

The properties of an option type can be accessed by using the \token{::} operator on a type expression. The properties are:

\begin{center}\begin{adjustbox}{max width=\linewidth}
  \begin{tabular}{|l|ll|}
    \hline
    Name & Meaning & Type\\
    \hline
    \hline
    \texttt{init} & The initial value \texttt{none} & \texttt{typeof(x)}\\
    \hline
    \texttt{typeid} & A string encoding the name of the type & \texttt{[c8]} \\
    \hline
  \end{tabular}
\end{adjustbox}\end{center}

\subsection{Binary operators}

Binary operators are divided into four groups :
\begin{itemize}
  \setlength\itemsep{-4pt}
\item Access: The \token{.} operator is used to access the fields of the option
  type. There are four fields that can be accessed within an option value, which
  are described in the following table. These fields cannot be true at the same
  time, so $hasError \implies \lnot hasValue$ and $hasValue \implies \lnot
  hasError$, but $\lnot hasError \land \lnot hasValue$ can be true.

  \begin{center}\begin{adjustbox}{max width=1.0\linewidth}
      \begin{threeparttable}
        \begin{tabular}{|c|ll|}
          \hline
          Field & Value & Type \\
          \hline
          \hline
          \texttt{hasValue} & true iif the option has a value & \texttt{bool} \\
          \texttt{hasError} & true iif the option has no value but has an error & \texttt{bool} \\
          \Xhline{0.001pt}
          \texttt{value} & the value contained in the option & \textit{T}$^{1^{\phantom{j}}}$ \\
          \texttt{error} & the value contained in the option & \textit{\&Exception}$^{2^{\phantom{j}}}$ \\
          \hline
        \end{tabular}
        \begin{tablenotes}
        \item[1.] inner type of the option, i.e. \texttt{\_\_pragma!inner (typeof (x), 0)}
        \item[2.] instance of an object inheriting from \texttt{core::exception::Exception}
        \end{tablenotes}
      \end{threeparttable}
  \end{adjustbox}\end{center}

  The \token{hasError} field is not included in the option value (as explained
  in the previous subsection on memory alignment of option types). It is
  calculated from the \token{hasValue} and \token{error} fields. In addition, the
  \token{error} and \token{value} fields share the same memory address, but
  are never used at the same time, depending on the \token{hasValue} field.

  \begin{lstlisting}[style=coloredverbatim]
fn foo (x : bool)-> i32? {
  if (x) {
    (12)?
  } else {
    none
  }
}

let a = foo (true);
assert (!a.hasError && a.hasValue);
  \end{lstlisting}

  The \token{value} and \token{error} fields are special fields that cannot be
  set at the same time (they share the same memory address). When accessing
  these fields, a runtime check is performed. If the option has no value and the
  field \token{value} is accessed an exception of type
  \token{core::exception::EmptyValOption} is thrown. This exception is of
  course catchable and rethrowable like any other exception. It was chosen not
  to make the program panic, to force developers to deal with empty option
  values, and to prevent the ``nullpointer exception'' effect.

  On the other hand, a runtime check is performed when the \token{error} field
  is accessed. If the option has no error the exception
  \token{core::exception::EmptyErrOption} is thrown.

  \begin{lstlisting}[style=coloredverbatim]
fn main ()
    throws EmptyValOption, // accessing value
           &EmptyErrOption  // accessing error
{

    let a = foo (true);
    let x = a.value + 12; // throw if no value
    println (a.error); // throw if no error
}
  \end{lstlisting}

\item Comparison: Binary comparison operator can be used on option values, whose
  inner types are comparable. The result of the operation is always a type bool.
  A none value is always lower than an ok value.

  \begin{center}\begin{adjustbox}{max width=1\linewidth}
      \begin{threeparttable}
        \begin{tabular}{|c|lll|}
          \hline
          Operator & Operation & Commutative & Example \\
          \hline
          \hline
          \texttt{==} & Equality test & Yes & \texttt{((12)? == (12)?) == true}\\
          \texttt{!=} & Inequality test & Yes & \texttt{((12)? != (12)?) == false}\\
          \texttt{<} & Lower than & No & \texttt{(none < (12)?) == true}\\
          \texttt{>} & Greater than & No & \texttt{(none > (12)?) == false}\\
          \texttt{>=} & Greater or equal$^{1^{\phantom{j}}}$ & No & \texttt{((12)? >= (11)?) == true}\\
          \texttt{<=} & Lower or equal$^{1^{\phantom{j}}}$ & No & \texttt{((12)? <= (11)?) == false}\\
          \hline
        \end{tabular}
      \end{threeparttable}
  \end{adjustbox}\end{center}

\item Affectation: An option value can be a lvalue if and only if it is mutable.
  The inner value of an option value can be also used as a lvalue if the option
  is mutable, and inner value is mutable. If the inner value is borrowing
  memory, it behave exactly as an inner value from a tuple type. The error field
  of an option value cannot be modified, even if the option is mutable.

\begin{lstlisting}[style=coloredverbatim]
let dmut a = (12)?;
a.value = 98;

let mut b = ([12])?;
b = ([89])?; // ok
b.value[0] = 98; // no, inner value is not mutable

let dmut c = ([1,2,3])?;
c.value [0] = 12; // Ok
\end{lstlisting}

\end{itemize}

\subsection{Pattern matching}

There are two ways to access the inner value of an option value. The first
described in this section is pattern matching. Two pattern matching keywords
(only accessible within pattern matching deconstruction rules) are provided. The
first, \token{Ok}, is used to deconstruct an option value containing an inner
value, it can contain another pattern matching deconstruction rule to match over
the inner value of the option type. The second pattern matching keyword is
\token{Err}, used for option values without inner values. It can take an inner
deconstruction rule to match on the error exception (see
Chapter~\ref{chap:Error_handling}) if there is one.

\begin{lstlisting}[style=coloredverbatim]
let v : i32? = foo ()
match v {
  Ok (89) => {} // option containing the value '89'
  Ok () => {} // option value containing anything
  Err (msg : &AssertError) => {} // option value that failed due to an assert error
  Err () => {} // any option value that failed
}
\end{lstlisting}

In the example above, the \token{Ok()} pattern matching rule would match any
option value, such as \token{12?} or \token{42?}. On the other hand, the
\token{Err()} pattern matching rule would match any option value that does not
contain an inner value, such as \token{none} or \token{(throw AssertError
  ("failure"))?}.


\subsection{Inheritence and casting}

Option value can contain object values from polymorphic classes. In this case,
an option value can be implicitly casted from \token{B?} to \token{A?} if and
only if \token{A} is an ancestor of the class \token{B}. As for array, or
slice casting, the opposite is not possible for the same reasons. This
polymorphic casting is also available in pattern matching, where the inner
deconstruction rule of the \token{Ok} rule can do polymorphic class memory
aliasing. For more information on class types, see
Chapter~\ref{chap:custom_type}.

\begin{lstlisting}[style=coloredverbatim]
class A {
  pub self () {}
}

class B over A {
  pub self () {}
}

let a : (&A)? = (B::new ())?; // implicit casting is allowed
match a {
  Ok (b : &B) => {} // Polymorphic test
  Ok (a : &A) => {} // Direct test
}

// only works if a contains an instance of '&B'
if let Ok (j : &B) = a {

}
\end{lstlisting}
