\section{Pointers}%
\label{sec:pointer_type}

Pointers are values storing an address of memory. Pointer types are described
using the \token{*} token followed by a type (e.g. \token{*i32} describing a
pointer to a \token{i32} value). In the beta version of Ymir (compiler written
in c++) the operator \token{\&} was used, it was changed as it was also used to
refer to object instances that are in a way pointers but have very different
behavior.

\subsection {Literals}

The keyword \token{null} is used to describe a pointer pointing to nowhere.
This is the only literal that can be used as a pointer value.

\subsection {Construction}

To construct a pointer, the unary operator \token{\&} can be used on a lvalue
(for example, a variable). This operator returns the address of the value
referenced by the operand, i.e. \token{\&a} returns the address of the segment
of memory referenced by the variable \token{a}. For the sake of simplicity, we
can say that we are retrieving the address of the variable \token{a}.

\begin{lstlisting}[style=coloredverbatim]
let a = 12;
let b : *i32 = &a;
\end{lstlisting}

\subsection {Mutability}

Because pointers borrow data from another value (value pointed by the pointer),
their mutability is important. A pointer has two level of mutability:
\begin{enumerate}
  \setlength\itemsep{-4pt}
\item \token{mut *T}, In this case, the pointer can be changed, but the value
  inside the pointer cannot be changed.
\item \token{mut *(mut T)}, In this case, both the value to which the pointer
  is pointing and the pointer itself can be changed.
\end{enumerate}

A mutable pointer (\textit{level 1}) means that if the pointer is contained
inside another compound type or variable, then the value it points to can be
changed. Checking for mutability is done at compile time when borrowing a value
to construct a pointer value.
\smallskip

\begin{lstlisting}[style=coloredverbatim]
let dmut a : *i32 = null;

let b = 12;
a = &b; // not allowed 'b' is not mutable
*a = 24; // but it would be modified by this operation


let mut c = 11;
a = &c; // allowed c is mutable
*a = 24; // modify the value of c is allowed
\end{lstlisting}

\smallskip
The keyword \token{alias} must be used on the right operand when data borrowing
is transferred to the left operand. In practice, this means that if the
mutability of the left operand is second level (i.e. \token{mut *(mut T)}), the
keyword \token{alias} must be used, and the right operand must also be second
level mutable. The keyword can be omitted if the aliasing is obvious (i.e. by
function return, or construction such as the unary operator \token{\&}).

\subsection {Properties}

Pointer type properties can be accessed using the \token{::} operator on a type
expression. The properties are as follows: following:

\begin{center}\begin{adjustbox}{max width=\linewidth}
  \begin{tabular}{|l|ll|}
    \hline
    Name & Meaning & Type\\
    \hline
    \hline
    \texttt{init} & The initial value \texttt{null} & \texttt{typeof(x)}\\
    \hline
    \texttt{typeid} & A string encoding the name of the type & \texttt{[c8]} \\
    \hline
  \end{tabular}
\end{adjustbox}\end{center}

\subsection {Casting}

A pointer type can be cast to any pointer type using the cast operator
\token{cast!T(V)}. A pointer is a really low-level type with few guarantees,
but some operations rely on this possibility to perform generic operations
(common trait \token{Packable} for example). The mutability of the result is
the same as the mutability of the operand, if the value is explicitely aliased,
it is immutable otherwise. This is the only allowed cast on pointer types.
\smallskip

\begin{lstlisting}[style=coloredverbatim]
  let dmut a : [i32]  = copy [12];
  let dmut b : *[i32] = &a;

  // c : dmut *[f32];
  let dmut c = cast!{*[f32]} (alias b);

  // not allowed, from *[f32] to dmut *[f32];
  let dmut d = cast!{*[f32]} (b);
\end{lstlisting}

\subsection {Unary operators}

The unary operator \token{*} is used on a pointer value to dereference it and
access the value pointed to by the pointer. This operation is unsafe and may
cause the program to crash. If the operation does not crash, it does not
necessarily mean that the pointer was created correctly. This operation is
unsafe and can only be used in a \token{unsafe} context.
\smallskip

\begin{lstlisting}[style=coloredverbatim]
let i = 10;
let x = &i;

unsafe {
  let j = *x;
}
\end{lstlisting}

\subsection {Binary operators}

Binary operators are divided into 3 groups:
\begin{itemize}
  \setlength\itemsep{-4pt}
\item Arithmetic: Pointer arithmetic is allowed with a \token{usize} as the
  right operand. Unlike the C language, the arithmetic does not depend on the
  size of the data pointed to by the pointer. The operation adds a number of
  bytes to the address, which means that the addition operation with a left
  operand whose value is \token{0xabc0} and a right operand \token{8us} will
  always have the value \token{0xabc8}, regardless of the type of content
  pointed to by the pointer. The behaviour is not the same with the index
  operator. The type of the result of the operation is always the same as the
  type of the left operand.

  \begin{center}\begin{adjustbox}{max width=1\linewidth}
    \begin{tabular}{|c|lll|}
      \hline
      Operator & Operation & Commutative & Example \\
      \hline
      \hline
      \texttt{+} & Addition & Yes & \texttt{\&a + 2us} \\
      \texttt{-} & Substraction & No & \texttt{\&a - 2us} \\
      \hline
    \end{tabular}
  \end{adjustbox}\end{center}

\item Logical: Comparison operators always return a value of type \token{bool}
  and can only be used if the two operands are of the same pointer type (e.g.
  \token{*i32} with \token{*i32}).

  \begin{center}\begin{adjustbox}{max width=1\linewidth}
      \begin{threeparttable}
        \begin{tabular}{|c|lll|}
          \hline
          Operator & Operation & Commutative & Example \\
          \hline
          \hline
          \texttt{==} & Equality test & Yes & \texttt{(\&a == \&a) == true}\\
          \texttt{!=} & Inequality test & Yes & \texttt{(\&a != \&a) == false}\\
          \texttt{<} & Lower than & No & \texttt{(\&a < \&a + 1us) == false}\\
          \texttt{>} & Greater than & No & \texttt{(\&a > \&a - 1us) == true}\\
          \texttt{>=} & Greater or equal$^{1^{\phantom{j}}}$ & No & \texttt{(\&a >= \&a - 1us) == true}\\
          \texttt{<=} & Lower or equal$^{1^{\phantom{j}}}$ & No & \texttt{(\&a <= \&a - 1us) == false}\\
          \hline
        \end{tabular}
    \end{threeparttable}
    \end{adjustbox}\end{center}

\item Affectation: The affectation operators are usable when the two operands
  are of exactly the same pointer type. The mutability level of the left operand
  must be less than or equal to the mutability level of the right operand.
  Affection operators can be mixed with arithmetic operators (e.g. \token{+=},
  \token{-=}). In this case the operation is rewritten as \token{x = x + y}
  and \token{y} must be a value of type \token{usize}.

  \begin{lstlisting}[style=coloredverbatim]
let mut a = 11;
let dmut b = &a;

let mut c = &a;
b = c; // not allowed it will discard the const property
c = b; // No problem the mutability level of c is lower than the one of b

c += 1us;

let dmut d = &a;
b = alias d; // alias is needed, data is borrowed
  \end{lstlisting}

\end{itemize}

\subsection {Index operator}

The index operator can be used on a pointer left operand with an int value as
the index right operand. The result of the operation is the dereferencing of the
pointer value by the offset of the value used as index. Unlike pointer
arithmetic using the \token{+} and \token{-} operators, the index operator
takes into account the size of the data pointed to by the pointer, i.e. the
index operation \token{(\&a)[7]} is strictly transformed into \token{*(\&a +
  (7us * sizeof (\_\_pragma!inner (typeof(\&a), 0)))}. This operation is unsafe
because it dereferences a raw pointer.

\smallskip

\begin{lstlisting}[style=coloredverbatim]
let mut a = 12;
let dmut b = &a;

unsafe {
  b [0] = 89;
}
assert (a == 89);
\end{lstlisting}

\smallskip

The mutability of the result value depends on the mutability level of the
pointer operand. If the mutability level of the pointer operand is 2, then the
result can be used as lvalue. The above example produces the following Ymir Intermediate Language code.

\begin{lstlisting}[style=myilVerb]
frame : main::main ()-> void {
    let mut a : mut i32 = 12;
    let mut b : mut *(mut i32) = &(a);
    {
        *((b + (cast!{usize}(0) * 4us))) = 89;
        <unit-value>
    };
    core::exception::abort ((a == 89), (""s8)[]);
    <unit-value>
}
\end{lstlisting}

\vfill%
\pagebreak
