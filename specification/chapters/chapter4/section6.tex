\section{Slices}%
\label{sec:slices}

A slice is a compound type that contains a list of values of the same type that
are stored in a contiguous segment of memory, but the size of which is unknown
at compile time. A slice is described using the syntax \token{[T]}, where
\token{T} is the inner type of the slice. Unlike array types, slices are
pointers to borrowed memory, and are allocated on the heap, or written in the
text segment (e.g. string literals).

In practice, a slice is a pointer \token{*T} to the borrowed data and a
\token{usize} storing the size of the slice. A slice may contain no data, in
which case both the pointer and the size are equal to \token{0}. If the size of
the slice is strictly positive, then the pointer is non-null.


\input{chapters/chapter4/figures/slice_mutability}

\subsection{Limitation}%
\label{sec:slice_lim}

Because a slice can be created from an array value, it can point to nowhere.
This is a big problem; and it does not seem to be solvable by static analysis.

\begin{lstlisting}[style=coloredverbatim]
fn foo (a : [i32])-> [i32] {
    a
}

fn bar ()-> [i32] {
    let a : [i32 ; 2] = [1, 2]; // 'a' does not exist at the end of bar

    foo (a) // but is returned from this function call
}

let x = bar ();
println (x); // undefined behavior
\end{lstlisting}

Forcing the copy of the array when creating a slice from it seems to be the only
reasonable way to solve this problem. This means that slices never point to
memory on the stack, but always to the heap. One can argue that we have the same
limitation with pointers, but pointers are not intended to be used outside of
trusted and unsafe parts of code, where slices are one of the most common types,
and restricting their operations to unsafe contexts only would be extremely
limiting.

\begin{lstlisting}[style=coloredverbatim]
let a : [i32 ; 2] = [1, 2];
let b : [i32] = a; // not allowed
let c : [i32] = copy a; // ok
\end{lstlisting}



\subsection{Mutability and memory alignement}

Slices borrow data (that resides on the heap or in immutable memory segments -
ex: data), so when moving data it is important to consider the mutability of the
borrowed data. Slices have three levels of mutability, 0, 1 and 2, where 0 means
that neither the slice nor the inner data is mutable, 1 means that the slice is
mutable but not the inner data, and finally 2 means that both the slice and the
inner data are mutable. The mutability level can of course be recursive if the
slices contain borrowed data.


As an example to illustrate the memory representation of slices, the
figure~\ref{fig:(chap4):data_repr_slice} shows the memory representation of the slice
value \token{x = copy [1, 2, 3]}. Slices with a mutability of 2 or higher
cannot be moved or copied without explicit specification. The keywords
\token{alias}, \token{copy} and \token{dcopy} must be used.

\begin{lstlisting}[style=coloredverbatim]
let dmut a : [[i32]] = [[1], [2], [3]];

let dmut b = a; // forbidden
let dmut c = alias a; // ok, make a reference to the same data as 'a'
let dmut d = copy a; // forbidden copy of 'a' is 'mut [mut [i32]]', not 'mut [mut [mut i32]]'

let dmut e = dcopy a; // ok, deeply copy of 'a'
\end{lstlisting}



\subsection{Properties}

The properties of a slice type can be accessed by using the \token{::} operator on a type expression. The properties are:

\begin{center}\begin{adjustbox}{max width=\linewidth}
  \begin{tabular}{|l|ll|}
    \hline
    Name & Meaning & Type\\
    \hline
    \hline
    \texttt{init} & The initial value & \texttt{typeof(x)}\\
    & an empty slice of size \texttt{0} & \\
    \hline
    \texttt{typeid} & A string encoding the name of the type & \texttt{[c8]} \\
    \hline
  \end{tabular}
\end{adjustbox}\end{center}

\subsection{Binary operators}

Binary operators are divided into four groups :
\begin{itemize}
  \setlength\itemsep{-4pt}
\item Access: The operator \token{.} is used to access fields that describe the slice value. The right operand is the name of the field to be accessed. These fields are described in the table below.

  \begin{center}\begin{adjustbox}{max width=\linewidth}
      \begin{threeparttable}
        \begin{tabular}{|l|ll|}
          \hline
          Name & Value & Type\\
          \hline
          \hline
          \texttt{len} & The size of the slice & \texttt{usize} \\
          \texttt{ptr} & The pointer to the first element  & \textit{T}$^{1^{\phantom{j}}}$ \\
          & of the array & \\
          \hline
        \end{tabular}
        \begin{tablenotes}
        \item [1.] inner type of the slice, i.e. \texttt{*(\_\_pragma!inner (typeof (x), 0))} \\
        \end{tablenotes}
      \end{threeparttable}
  \end{adjustbox}\end{center}

  The type of the \token{ptr} field has the same level of mutability as the
  slice type. The \token{len} fields contains the number of elements contained
  in the data borrowed by the slice.

\item Concatenation: The concatenation operator ~\token{\~} is used to create a
  slice containing the values of two slices, or an array and a slice. The
  operator can be used if the left and right operands have the same internal
  type, regardless of their relative sizes. The mutability of the generated
  value is the strictest mutability between the two operands. For example, the
  type and mutability of \token{([*i32]) \~\ (dmut [*i32])} is \token{[*i32]}
  to avoid discarding the constant property of the values contained in the left
  operand. Unlike array concatenation, this operator allocates memory on the
  heap whenever a slice is involved as at least one of the two operands.
  Concatenation operator is obviously not commutative.

\item Comparison: Binary comparison operator can be used with two slices of the
  same inner type, or a slice and an array whose inner types are comparable. The
  result of the operation is always of type \token{bool}. For the operators to
  work, the inner type of the array must also define the comparison operators.
  Lexical order is used, so the size of the slices are only used if one of the
  two operands is a prefix of the other (e.g. \token{[1, 2]} is a prefix of
  \token{[1, 2, 3]}, so \token{[1, 2, 3]} is considered greater than
  \token{[1, 2]}, but \token{[1, 3]} is greater than \token{[1, 2, 3]}).

  \begin{center}\begin{adjustbox}{max width=1.0\linewidth}
    \begin{tabular}{|c|lll|}
      \hline
      Operator & Operation & Comm. & Example\\
      \hline
      \hline
      \texttt{>}      & Greater than     & No          & \texttt{([1, 2] > [2, 3]) == false}    \\
      \texttt{<}      & Lower than       & No          & \texttt{([1, 2] < [2, 3]) == true}     \\
      \texttt{>=}     & Greater or equal & No          & \texttt{([1, 2, 3] >= [1, 2]) == true} \\
      \texttt{<=}     & Lower or equal   & No          & \texttt{([1, 2, 3] <= [2]) == true}    \\
      \texttt{==}     & Equal            & Yes         & \texttt{([1, 2] == [1, 2]) == true}    \\
      \texttt{!=}     & Not equal        & Yes         & \texttt{([1, 2] != [1, 2]) == false}   \\
      \hline
    \end{tabular}
  \end{adjustbox}\end{center}

\item Affectation: A slice value can be an lvalue if and only if it is mutable.
  The size of the left and right operands is irrelevant during slice
  affectation. Slice affectation represents a memory movement, so the mutability
  of the inner values is important. Indeed, if the mutability level of the left
  operand is higher than the mutability level of the right operand, then the
  constant property would be discarded, removing its guarantee, so it is not
  allowed.

  \begin{lstlisting}[style=coloredverbatim]
let      a = copy [1, 2, 3]; // const [i32]
let dmut b = copy [2, 3, 4]; // mut [mut i32]
let dmut c = copy [5, 9]; // mut [mut i32]

a = copy [2, 3]; // not allowed, 'a' is const
b = a; // not allowed, discard const property of inner values of 'a'
b = c; // not allowed, implicit alias
b = alias c; // ok
  \end{lstlisting}

\end{itemize}


\subsection{Index operator}

The index operator can be used on a slice value as the left operand, with an int
value or a range value as the right operand.

\begin{itemize}
  \setlength\itemsep{-4pt}
\item With an int value; the element at the index described by the int value is
  returned. The mutability of the result value depends on the mutability level
  of the inner type of the slice. If the mutability level of the slice type is
  at least \token{2}, the result value can be used as lvalue.

  \begin{lstlisting}[style=coloredverbatim]
let dmut a = copy [1, 2, 3];
let mut  b = copy [4, 5];

a [0] = 9; // ok, mutability level of 'a' is high enough
b [0] = 11; // not allowed, b inner values are not mutable
b = copy [9, 10]; // ok, b is mutable
  \end{lstlisting}

  Since the size of the slice value is not known at compile time (most of the
  time), a condition is added at runtime and a size check is performed to ensure
  that the index is valid. A panic is triggered if an overflow occurs. Sometimes
  the size of the slice can be inferred, or the order inequality between the
  index and the size of the slice can be guaranteed, in these cases the size
  check is done at compile time and no condition is added at runtime.

\item With a range value; using a range value containing int values as the right
  operand, the program creates a slice containing only a subset of the slice
  value. The mutability level of the created slice if the same as the mutability
  level of the left operand of the operation. Unlike the array index operator
  with a range, no \token{copy} operator is mandatory. In fact, the memory
  borrowed by a slice value is always on the heap, so the risk presented in
  Section~\ref{sec:slice_lim} is not present when dealing only with slices. Such
  an index operator does not copy any memory, it only creates a new reference,
  no implicit memory allocation takes place.

  \begin{lstlisting}[style=coloredverbatim]
let a = copy [1, 2, 3, 4];

let b = a [0 .. 2];
  \end{lstlisting}

  If the inner values of the range and the size of the slice are known at
  compile time, it is checked that there will be no slice overflow. The range
  must be ascending, i.e. the first value of the range must be less than the
  second value. This is also checked at compile time if possible. If the values
  of the range are not known at compile time, then these checks are done at
  runtime. The contain field of the range has no effect on the slice access, and
  the \token{scd} value is always considered not contained.

\end{itemize}


\subsection{Dollar operator}

The dollar operator can be used within an index operation in the right operand
expression. The dolalr value takes the value of the size of the slice and its
type is \token{usize}. Its value can be known at compile time if the size of
the left operand slice can be inferred.

\begin{lstlisting}[style=coloredverbatim]
let a = copy [1, 2, 3, 4];

let b = a [0 .. $ - 1]; // all values except the last one
let c = a [$ - 1]; // the second value to the last
\end{lstlisting}


\subsection{Slice iteration}

Slices, being iterable types, can be utilized as iterable values in a for loop.
This loop can employ either one or two variables as iterators. When a single
variable is employed, it automatically captures the value of the slice element
at the current iteration index. Conversely, if two variables are utilized, the
first variable denotes the iteration index, while the second variable holds the
value of the slice element at that particular index.

\begin{lstlisting}[style=coloredverbatim]
let a = copy [1, 2, 3, 4];
for i, elem in a {
  assert (a [i] == elem);
}

// only one iterator, captures the value
for elem in a {
  println (elem); // 1 2 3 4
}
\end{lstlisting}

The iteration of a slice is translated into a basic while loop. It's important
to note that a reference to the value is obtained through the variable
\token{\#\_value}. The concept behind this approach is to enable iteration
through a constructed value, such as a function call (e.g., \token{for i in
  foo()}), while ensuring that the value is only constructed once. To achieve
this, the value is cached in a variable, preventing the function from being
called repeatedly at each iteration.

\begin{lstlisting}[style=myilVerb]
let #_value(#4b) : mut [mut i32] = a(#3o);
let elem(#3w) : i32;
let i(#43) : usize = 0us;
while (i(#43) < #_value(#4b).len) {
  elem(#3w) = #_value(#4b) [i(#43)];
  {
    a(#3o) [i(#43)] = (elem(#3w) + 1);
    <unit-value>
  };
  i(#43) = (i(#43) + 1us)
}
\end{lstlisting}

\subsection{Slice expansion}
\label{sec:slice_expansion}

If the size of the slice value is known at compile time, the \token{expand}
operator can be used to convert the inner values of the slice to a list of
parameters, to construct an array value, or to construct a tuple value. To know
the size of a slice value at compile time, use the index operator with a range
int value whose \token{fst} and \token{scd} values are also known. This forces
the size of the slice value to be known so that it can be used in a
\token{expand} operation.

\begin{lstlisting}[style=coloredverbatim]
fn foo ()-> [i32] {
  // ...
}

fn bar (a : i32, b : i32) {
  // ...
}

let a = foo (); // 'a' slice size is unknown

bar (expand a [0 .. 2]); // ok, slice size is known and is 2
let c : [i32 ; 4] = [expand a [1 .. 4], 9]; // expansion, might panic at runtime if 'a' is not big enough

let d : (i32, i32, c32) = (expand a [1 .. 3], 't');

bar (expand a); // error size of 'a' is unknown
  \end{lstlisting}

This operation is done at compile time and is simply a less verbose rewrite. In
fact, in the previous example, the line \token{bar (expand a [0 .. 2])} is
rewritten to become \token{bar (a [0], a [1])}. As with any slice index, a
conditional check is performed at runtime, which would only be valid if the
slice \token{a} contains at least two elements. The mutability level of a slice
expansion is always \token{1}, i.e. a slice expansion can never borrow mutable
data.


\subsection{Inheritence and casting}

Slice value can contain object values from polymorphic classes. In this case, an
option value can be implicitly casted from \token{[B]} to \token{[A]} if and
only if \token{A} is an ancestor of the class \token{B}. As for array casting,
the opposite is not possible for the same reasons. Like any memory movement, the
implicit casting must be aliased if the inner values are mutable and the alias
is not obvious.

\begin{lstlisting}[style=coloredverbatim]
class A {
  pub self () {}
}

class B over A {
  pub self () {}
}

let b : [&B] = copy [B::new (), B::new ()];
let a : [&A] = b; // implict casting from [&B] to [&A]
\end{lstlisting}

\vfill%
\pagebreak
