\section{Boolean}
\label{sec:org9f3a743}

The Bool type is a simple type, whose name is \token{bool}, and that can only
describe two values \token{true} and \token{false}. It is stored in a single
byte of memory, although only the first bit is used and has meaning.

\subsection{Properties}
\label{sec:org503bc9e}

Properties of the type \token{bool} are accessible by using the operator
\token{::} on a type expression. The properties are as follows:

\begin{center}
  \begin{adjustbox}{max width=\linewidth}
    \begin{tabular}{|l|ll|}
      \hline
      Name & Meaning & Type\\[0pt]
      \hline
      \hline
      \texttt{init} & The initial value \texttt{false} & \texttt{bool}\\[0pt]
      \hline
      \texttt{typeid} & A string encoding the name of the type & \texttt{[c8]}\\[0pt]
      \hline
    \end{tabular}
  \end{adjustbox}
\end{center}

\subsection{Literals}
\label{sec:org7620b9c}

Boolean literals are the keywords \token{true} and \token{false}.

\subsection{Casting}
\label{sec:org7cd1f94}

A value of type \token{bool} can be cast to a value of type \token{u8} using
the cast operator, in which case the value \token{false} is converted to the
value \token{0u8} and the value \token{true} is converted to the value
\token{1u8}. The reverse conversion is impossible using the cast operator, but
can be carried out using the equality operators of type int (e.g. \token{1u8 ==
  1u8}). This is the only cast allowed for the boolean type. It is impossible to
convert a boolean value to a value of another type without explicitly using the
cast operator.

\subsection{Unary operators}
\label{sec:orgb412ce4}

The unary operator \token{!} can be used on a boolean value to get its opposite
value (i.e. \token{!true} becomes \token{false} and \token{!false} becomes
\token{true}).

\subsection{Binary operators}
\label{sec:org030ae50}

Binary operators involving a bool operand can only be used if both operands are
of type bool. There is an exception to this rule when the operation involves an
object operand that has overridden the said operator (as a left or right
operand).

Binary operators are divided into 3 groups:

\begin{itemize}
  \setlength\itemsep{-4pt}
\item Affectation: Affectation operators can be used to change the value of a
  mutable lvalue of type bool using a right operand of type bool. Because there
  are no arithmetic operators that can be used on a bool value, no arithmetic
  operator can be attached to the affectation operation. \token{\&\&=} and
  \token{||=} are not valid operators, and their use results in a syntax error.

\item Comparisons: The comparison operators \token{==} and \token{!=} can be
  used with two bool values to evaluate equality and inequality respectively.
  The result of the operations is always of type \token{bool}. By convention,
  it is not recommended to use equality and inequality operators to test the
  \token{bool} values. In fact, \token{a == false} can be rewritten as
  \token{!a}, and \token{a == true} is simply \token{a}.

\item Logical: Logical operators can be used with two bool operands.

  \begin{center}
    \begin{adjustbox}{max width=1.0\linewidth}
      \begin{tabular}{|c|l l l|}
        \hline
        Operator & Operation & Commutative & Example\\[0pt]
        \hline
        \hline
        \texttt{\(\vert\vert\)} & Or & No & \texttt{false} \(\vert{} \vert{}\) \texttt{true == true}\\[0pt]
        \texttt{\&\&} & And & No & \texttt{true \&\& false == false}\\[0pt]
        \hline
      \end{tabular}
    \end{adjustbox}
  \end{center}

  The operators \token{\&\&} and \token{||} are marked as non-commutative. This
  is not because they can return a different value if the left and right operands
  are inverted, but because for \token{\&\&} the right operand is not evaluated
  if the left operand is false, and for \token{||} the right operand is not
  evaluated if the left operand is true. This can be useful when chaining tests.

  \begin{lstlisting}[style=coloredverbatim]
let i = 12;
let p = &i;

// if 'p == null', '*p == 12' is not evaluated
let a = p != null && *p == 12;

// if 'p == null', '*p != 12' is not evaluated
let b = p == null || *p != 12;

// foo function is not called
let c = true || foo ();

// foo function is called
let d = false || foo ();
  \end{lstlisting}
\end{itemize}
