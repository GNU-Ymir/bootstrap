\section{Characters}
\label{sec:char_type}

Character types are used to encode characters (ASCII or Unicode). There are
three character types \token{c8}, \token{c16} and \token{c32} with a size of
\token{8}, \token{16} and \token{32} bits respectively. These char types are
encoding values in utf-8, utf-16 and utf-32.

\begin{center}
  \begin{tabular}{ll}
    Value & Content\\[0pt]
    \hline
    \texttt{\textbackslash{}a} & Alert beep, (Bell)\\[0pt]
    \texttt{\textbackslash{}b} & Backspace\\[0pt]
    \texttt{\textbackslash{}f} & Page break\\[0pt]
    \texttt{\textbackslash{}n} & New line\\[0pt]
    \texttt{\textbackslash{}r} & Carriage return\\[0pt]
    \texttt{\textbackslash{}t} & Horizontal tab\\[0pt]
    \texttt{\textbackslash{}v} & Vertical tab\\[0pt]
    \texttt{\textbackslash{}\textbackslash{}} & Backslash\\[0pt]
    \texttt{\textbackslash{}'} & Apostrophe\\[0pt]
    \texttt{\textbackslash{}"} & Double quotation mark\\[0pt]
    \texttt{\textbackslash{}u\{\}} & Unicode\\[0pt]
  \end{tabular}
  \captionof{table}{\label{tab:escape_chars} Escape characters}
\end{center}

\subsection{Properties}
\label{sec:orgf9fbc31}

The properties of char types can be accessed by using the \token{::} operator
on a type expression. The properties are as follows:

\begin{center}
  \begin{adjustbox}{max width=\linewidth}
    \begin{tabular}{|l|ll|}
      \hline
      Name & Meaning & Type\\[0pt]
      \hline
      \hline
      \texttt{init} & The initial value \texttt{\textbackslash{}u\{0\}} & \texttt{typeof(x)}\\[0pt]
      \hline
      \texttt{typeid} & A string encoding the name of the type & \texttt{[c8]}\\[0pt]
      \hline
    \end{tabular}
  \end{adjustbox}
\end{center}


\subsection{Literals}
\label{sec:org73c4919}

Char literals are enclosed by the token \token{'} and can be described using three forms:

\begin{enumerate}
  \setlength\itemsep{-4pt}
\item Using the direct representation of the character (e.g. \tokennolst{π}),
\item Using an escape character. The escape chars are described in the
  table~\ref{tab:escape_chars}.

\item Using an int literal representation of Unicode. To avoid confusing the int
  literal representation with the literal of the int itself, the int literal
  must be encoded using the escape character \tokennolst{\textbackslash{}u} and the
  tokens \token{\{} and \token{\}}. For example
  \tokennolst{\textbackslash{}u\{0x263A\}}, \tokennolst{\textbackslash{}u\{0b1101\}} or
  \tokennolst{\textbackslash{}u\{10\}}.

\end{enumerate}

As with float or int literals, a suffix must be added at the end of the literal
to define the value with the correct type. For example, to define a \token{c32}
value containing the character \token{a}, write \token{'a'c32}. Literal values
without a suffix are considered to be of type \token{c8}.

\begin{lstlisting}[style=coloredverbatim]
let a : c32 = 'r'c32;
let b : c8 = '\u{10}';
let d = 'π'c32;
let e = '\n'c8;

assert (e == b);
\end{lstlisting}

\subsection{Casting}
\label{sec:org16d703f}

Char types can be cast using the cast operator. It is not possible to implicitly convert a char value to a value of another type.

\begin{itemize}
  \setlength\itemsep{-4pt}
\item To other char types: The cast operator can be used to convert a char of
  one size to a char of another size. This does not guarantee encoding validity.
  The standard library defines more complex transformations that respect
  encoding in the \token{std::conv} module.

\item To integer types: The cast operator can be used to transform a char value
  of type \token{c8} into a \token{u8}, a \token{c16} into a \token{u16} and
  a \token{c32} into a \token{u32}. The transformation does not change the
  value in any way (exactly the same bits before and after the cast).

\end{itemize}


\subsubsection{Implicit casting}

The implicit casting of char values known at \token{cte} follows the same
rules as described for integer \token{cte} values.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
fn foo (f : c32) {}
fn foo (f : c8) {}

let a : c8 = 'a'c32; // ok, c32 is converted implicitely to c8

foo ('a'); // ok, using c8 definition
@\hb{foo ('a'c16)}@; // error, both definitions work
\end{lstlisting}

\subsection{Unary operators}
\label{sec:org78546fb}

No unary operators can be used on char types.

\subsection{Binary operators}
\label{sec:orge863f7d}

Binary operators on character types are divided into four groups.

\begin{itemize}
  \setlength\itemsep{-4pt}
\item Arithmetic: Binary arithmetic operators can be used with a char value and
  an unsigned int value (of the same size, e.g. for \token{c8} and
  \token{u8}). The result always takes the type of the char operand. It is
  impossible to add or subtract two char values, even if they are of exactly the
  same type.

  \begin{center}
    \begin{adjustbox}{max width=1.0\linewidth}
      \begin{tabular}{|c|lll|}
        \hline
        Operator & Operation & Commutative & Example\\[0pt]
        \hline
        \hline
        \texttt{+} & Addition & Yes & \texttt{'a' + 16u8 == 'q'}\\[0pt]
        \texttt{-} & Subtraction & No & \texttt{'q' - 16u8 == 'a'}\\[0pt]
        \hline
      \end{tabular}
  \end{adjustbox}\end{center}


  Char values can be used as right operands in arithmetic operations. The type of
  the result operation would still be the type of the char operand, and the int
  operand would still have to be of the same size as the char operand, so
  \token{('q' + 12u8) == (12u8 + 'q')}.

\item Logical: Binary logical operators can be used with two char values of
  exactly the same type. The result of the operation is always of type
  \token{bool}.

  \begin{center}
    \begin{adjustbox}{max width=1.0\linewidth}
      \begin{tabular}{|c|lll|}
        \hline
        Operator & Operation & Commutative & Example\\[0pt]
        \hline
        \hline
        \texttt{>} & Greater than & No & \texttt{('q' > 'a') == true}\\[0pt]
        \texttt{<} & Lower than & No & \texttt{('q' < 'a') == false}\\[0pt]
        \texttt{>=} & Greater or equal & No & \texttt{('q' >= 'q') == true}\\[0pt]
        \texttt{<=} & Lower or equal & No & \texttt{('b' <= 'r') == true}\\[0pt]
        \texttt{==} & Equal & Yes & \texttt{('a' == 'a') == true}\\[0pt]
        \texttt{!=} & Not equal & Yes & \texttt{('a' != 'a') == false}\\[0pt]
        \hline
      \end{tabular}
  \end{adjustbox}\end{center}

\item Affectation: The affectation operator \token{=} is usable when the left
  operand is a mutable lvalue and the right operand is strictly the same char
  type as the left operand.

  The affectation operator can be mixed with an arithmetic operator \token{+=}
  and \token{-=}, in which case the right operand must be a value whose type is
  an unsigned int with a size exactly equal to the size of the char type of the
  left operand. The affectation \token{x += y} is rewritten as \token{x = x +
    (y)}, where the y operand always has a higher priority than the affectation
  operator.

  \begin{lstlisting}[style=coloredverbatim]
let mut a = 'a';

let b = a + 21u8;

a = 'e';
a += 7u8;

assert (b == 'v');
assert (a == 'l')
  \end{lstlisting}

\item Range: The range operator can be used on two char values whose types are
  strictly identical, creating a range value.

  \begin{center}
    \begin{adjustbox}{max width=1.0\linewidth}
      \begin{tabular}{|l|lll|}
        \hline
        Operator & Operation & Example & Interval\\[0pt]
        \hline
        \hline
        \texttt{..} & Range operator not inclusive & \texttt{'a' .. 'z'} & \texttt{[a;z[}\\[0pt]
            \texttt{...} & Range operator inclusive & \texttt{'a' ... 'r'} & \texttt{[a;r]}\\[0pt]
            \hline
      \end{tabular}
  \end{adjustbox}\end{center}


  The result value has a default increment of \token{1} and its inner type is
  the type of the operands. It can be increasing or decreasing depending on the
  values used to construct it.

\end{itemize}

\subsection{Overflowing}
\label{sec:orga9c18c5}

Compile time overflow checking is done on \textit{cte} values. The check ensures
that the chosen type is large enough to encode the value. There is no way to
check for overflow at runtime, and it can happen. It is also possible, due to
the encoding, that a value is not a valid unicode or ascii value if it is
created at runtime (e.g. \token{'π' + 501u32}).

\vfill%
\pagebreak
