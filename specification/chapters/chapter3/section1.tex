\section{Integers}
\label{sec:(chap3):integers}

Integers are numbers without a decimal point. There are two types of integers,
signed and unsigned. The type of signed integers starts with the letter
\token{i}, while the type of unsigned integers starts with the letter
\token{u}.

\begin{table}[h]
  \centering
  \begin{tabular}{|r|ll|}
    \hline
    size & signed & unsigned\\[0pt]
    \hline
    \hline
    8 & \texttt{i8} & \texttt{u8}\\[0pt]
    16 & \texttt{i16} & \texttt{u16}\\[0pt]
    32 & \texttt{i32} & \texttt{u32}\\[0pt]
    64 & \texttt{i64} & \texttt{u64}\\[0pt]
    arch & \texttt{isize} & \texttt{usize}\\[0pt]
    \hline
  \end{tabular}
  \caption{\label{tab:(chap3):integer_types} List of integer types and their respective sizes}
\end{table}

The size of the type in bits is written in the type itself, e.g. \token{i32} is
a signed int of 32 bits. The table above shows the list of integer types
implemented in version 1.0 of ymirc. \token{usize} and \token{isize} are
architecture dependent and have a size in bits that depends on the size of the
pointers on the target system, (i.e. 32 bits on 32 bit systems, 64 bits on 64
bit systems, and so on).



\subsection{Literals}
\label{sec:org2cf045d}

Integer literals can be written in four forms:

\begin{enumerate}
  \setlength\itemsep{-4pt}
\item Octal, starting with \token{0o} and containing only numbers between \token{0} and \token{7}. (e.g. \token{0o71217}).
\item Hexadecimal, starting with \token{0x} and containing numbers from
  \token{0} to \token{9} and letters from \token{a} to \token{f} in upper or
  lower case (e.g. \token{0xAB87fe}).
\item Binary, starting with \token{0b} and containing numbers from \token{0} to
  \token{1} (e.g. \token{0b10010}).
\item Decimal, starting with nothing special and containing numbers from
  \token{0} to \token{9} (e.g. \token{182993}).
\end{enumerate}


All four forms can also contain the token \token{\_} to separate long integer
literals and make them more readable (e.g. \token{1\_000\_000\_000\_000}).
There can be as many \token{\_} as you like, they will just be removed during
compilation.

Literals must end with a suffix to define a literal of an int type other than
\token{i32}. For example, to define a literal with value \token{67} and type
\token{i8}, you would write \token{67i8} or \token{0x43i8} or
\token{0o103i8}. A check is made during compilation to ensure that the selected
int type has enough bytes to encode the expected literal. Suffixes for
\token{isize} and \token{usize} are \token{is} and \token{us} respectively.

\subsection{Properties}
\label{sec:orgc02cb40}

Integer properties are accessed using the \token{::} operator (as for any type)
on a type expression. The properties are

\begin{center}
  \begin{adjustbox}{max width=\linewidth}
    \begin{tabular}{|l|ll|}
      \hline
      name & value & type\\[0pt]
      \hline
      \hline
      \texttt{init} & The initial value \texttt{0} & \texttt{typeof(x)}\\[0pt]
      \texttt{max} & The maximum value the type can encode & \texttt{typeof(x)}\\[0pt]
      \texttt{min} & The minimum value the type can encode & \texttt{typeof(x)}\\[0pt]
      \hline
      \texttt{typeid} & A string encoding the name of the type & \texttt{[c8]}\\[0pt]
      \hline
    \end{tabular}
  \end{adjustbox}
\end{center}



The following code shows an example of how type properties can be used.

\begin{lstlisting}[style=coloredverbatim]
println (i32::max); // 2_147_483_647
println (i16::min); // -32_768
\end{lstlisting}

\subsection{Casting}
\label{sec:orgfdc3d25}

Integer values can be cast to other types.

\begin{itemize}
  \setlength\itemsep{-4pt}
\item To other integers: It is impossible to change the type of an int value
implicitly, i.e. it is impossible to transform a value of type \token{i32} into
a value of type \token{i64} without explicitly mentioning it. The cast operator
\token{cast!T (V)} can convert any int type to another int type.


\item To char types: The cast operator can be used to convert an int type of
  type \token{u8} to a \token{c8}, a \token{u32} to a \token{c32} and a
  \token{u16} to a \token{c16} and vice versa (e.g. \token{c8} to
  \token{u8}). This is the only allowed casting from int to chars. Implicit
  casting is not allowed. The transformation does not change the value in any
  way (exactly the same bits before and after the cast).

  \begin{lstlisting}[style=coloredverbatim]
let a : c32 = cast!c32 (97u32);
let b : u8 = cast!u8 ('a'c8);
  \end{lstlisting}

\item To floating-point types: Casting to floating-point types is allowed from
  any int type whose type has a size of at least \token{4} bytes (\token{i32},
  \token{u32} and higher) to any floating-point type, and vice versa using the
  cast operator. This is the only allowed casting from int to float types.
  Implicit casting is not allowed. The value encoding is changed to be
  represented correctly. In fact, int and float have completely different ways
  of representing values in memory. The value is truncated when converted from a
  float to an int. And there may be some stepping when converting an int value
  to a float value, due to the holes in the set of values representable by the
  float encoding system.

  \begin{lstlisting}[style=coloredverbatim]
let a : f32 = cast!f32 (97u32);
let b : f64 = cast!f64 (12);

let c : i64 = cast!i64 (67.87);
  \end{lstlisting}

\end{itemize}

\subsubsection{Implicit casting}

Implicit casting of integer values is sometimes allowed under certain
conditions. The value must be \token{cte}, and an overflow check is performed
to ensure that it does not overflow the capabilities of the type to which it is
cast.

  \begin{lstlisting}[style=coloredverbatim]
fn foo (a : u64) {
  // ...
}

let a : i64 = 1;
foo (7 + a); // 7 + a can be known at compilation time, 'a' is immutable and cte

let b : usize = 0; // no problem '0' is implicitely converted to 'usize'
  \end{lstlisting}

The purpose of this is to reduce the verbosity of the code when it is not
necessary, and the type is explicitly defined without ambiguity. It is not
possible to implicitly convert values of types other than integers to integer
values (e.g. character literals cannot be implicitly converted to integer
values). Implicit conversion is not allowed in cases of ambiguity. For instance,
in the following source code, there is no definition of the function
\token{foo} that accepts a value of type \token{u8}, so both functions might
work.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
fn foo (a : i32) {
    println ("foo i32 ", a);
}

fn foo (a : usize) {
    println ("foo usize ", a);
}

fn main () {
    foo (1); // ok, foo i32 1
    foo (1us); // ok, foo usize 1
    @\hb{foo (1u8)}@; // error, works with both
}
  \end{lstlisting}

The compiler rejects the code with an error. If there was only one definition of
the function \token{foo}, the implicit cast would have been allowed (after an
overflow check).

\subsection{Unary operators}
\label{sec:orge691bb5}

The following unary operators can be used on int types.



%% \begin{adjustbox}{max width=\linewidth}
\begin{center}
  \begin{threeparttable}
    \begin{tabular}{|l|ll|}
      \hline
      Operator & Operation & Example\\[0pt]
      \hline
      \hline
      \texttt{-} & Opposite value & \texttt{-19}\\[0pt]
      \hline
      \texttt{!} & Byte Not\(^{1}\) & \texttt{!19 == -20}\\[0pt]
      \hline
    \end{tabular}
    \begin{tablenotes}

    \item[1.] \footnotesize \textit{inverts each bit of the binary
      representation of the int value. This is semantically the same as
      computing \token{-x-1} (if the integer is signed).}

    \end{tablenotes}
  \end{threeparttable}
\end{center}
%% \end{adjustbox}

The result of unary operations always has the same type as the operand used in
the operation. The inverse operator \token{-} cannot be used on unsigned types
because they cannot be negative.

\subsection{Binary operators}
\label{sec:orgb91194f}

Binary operators with an int operand can only be used if both operands are of
type int. There are two exceptions to this rule: 1. When the operation involves
an object operand that has overridden the said binary operator (as a left or
right operand), 2. When one of the operands is of char or pointer type. Binary
operators involving char types are presented in the section on char types (cf.
Section~\ref{sec:char_type}), and those involving pointer types are presented in
the chapter on compound types (cf. Section~\ref{sec:pointer_type}). The binary
operators are divided into 5 groups:

\begin{itemize}
  \setlength\itemsep{-4pt}
\item Arithmetics: Binary arithmetic operators can be used with two int values
  whose types have the same signed property (two signed operands or two unsigned
  operands, but not a mix). The result of the operation takes the type of the
  largest of the two operands, e.g. for an addition between a \token{i64} and a
  \token{i32} (e.g. \token{12 + 78i64}), the result takes the type
  \token{i64}. There is one exception, the exponent operator, where the right
  operand is always \token{i32} and the result is always of the type of the
  left operand.

  \begin{center}
    \begin{adjustbox}{max width=1.0\linewidth}
      \begin{tabular}{|c|lll|}
        \hline
        Operator & Operation & Commutative & Example\\[0pt]
        \hline
        \hline
        \texttt{+} & Addition & Yes & \texttt{1 + 2 == 3}\\[0pt]
        \texttt{-} & Subtraction & No & \texttt{2 - 1 == 1}\\[0pt]
        \texttt{*} & Multiplication & Yes & \texttt{3 * 4 == 12}\\[0pt]
        \texttt{/} & Division (truncate) & No & \texttt{13 / 3 == 4}\\[0pt]
        \texttt{\%} & Rest of the division & No & \texttt{13 \% 3 == 1}\\[0pt]
        \verb~^^~ & Exponant & No & \texttt{3} \verb~^^~ \texttt{4 == 81}\\[0pt]
        \hline
      \end{tabular}
    \end{adjustbox}
  \end{center}

\item Bytes: Bytes binary operators can be used with two int values of exactly
  the same type (e.g. \token{i64} with and only with \token{i64}).

  \begin{center}
    \begin{adjustbox}{max width=1.0\linewidth}
      \begin{tabular}{|c|l l l|}
        \hline
        Operator & Operation & Commutative & Example \\[0pt]
        \hline
        \hline
        \texttt{\(\vert\)} & Byte Or & Yes & \texttt{0b001} \(\vert{}\) \texttt{0b010 == 0b011}\\[0pt]
        \texttt{\&} & Byte And & Yes & \texttt{0b001 \& 0b010 == 0b000}\\[0pt]
        \texttt{\textasciicircum{}} & Byte Xor & Yes & \texttt{0b001 \textasciicircum{} 0b011 == 0b010}\\[0pt]
        \Verb~>>~ & Byte left shift & No & \texttt{0b100000} \verb~>>~ \texttt{0b010 == 0b001000}\\[0pt]
        \Verb~<<~ & Byte right shift & No & \texttt{0b001000} \verb~<<~ \texttt{0b010 == 0b100000}\\[0pt]
        \hline
      \end{tabular}
    \end{adjustbox}
  \end{center}

\item Logical: Binary logical operators can be used with two integer values
  whose types have the same signed property (two signed operands or two unsigned
  operands, but not a mix). The largest type of the two integers is used to cast
  the value of the operand with the smallest type, to ensure that there is no
  overflow during the comparison. The result of the operation is always of type
  \token{bool}.

  \begin{center}
    \begin{adjustbox}{max width=1.0\linewidth}
      \begin{tabular}{|c|l l l|}
        \hline
        Operator & Operation & Commutative & Example\\[0pt]
        \hline
        \hline
        \texttt{>} & Greater than & No & \texttt{(12 > 11) == true}\\[0pt]
        \texttt{<} & Lower than & No & \texttt{(12 < 11) == false}\\[0pt]
        \texttt{>=} & Greater or equal & No & \texttt{(14 >= 14) == true}\\[0pt]
        \texttt{<=} & Lower or equal & No & \texttt{(11 <= 19) == true}\\[0pt]
        \texttt{==} & Equal & Yes & \texttt{(10 == 10) == true}\\[0pt]
        \texttt{!=} & Not equal & Yes & \texttt{(10 != 10) == false}\\[0pt]
        \hline
      \end{tabular}
    \end{adjustbox}
  \end{center}

\item Affectation: The affectation operator \token{=} can be used when the two
  operands are of exactly the same int type. The left operand must be a mutable
  lvalue (e.g. a mutable variable, a slice access, etc.). The affectation
  operator can be mixed with a math or byte operator (e.g. \token{+=},
  \token{\&=}, etc.). In this case, the operation \token{x += y} is rewritten
  as \token{x = x + (y)}, where the y operand always has a higher priority than
  the affectation operator. For example, the operation \token{x *= 12 + 3} is
  rewritten as \token{x = x * (12 + 3)}, even though the multiplication
  operator has a higher priority than the addition operator, i.e. the result of
  \token{x *= (12 + 3)} is different from the result of \token{x = (x * 12 +
    3)}.

  \begin{lstlisting}[style=coloredverbatim]
let mut a = 11;
let b = a * 12 + 3;
a *= 12 + 3;

assert (b == 135);
assert (a == 165);
  \end{lstlisting}

\item Range: The range operator can be used on int values of exactly the same
  type, creating a \token{range} value. The range type is a native compound
  type, described in the next chapter (cf. Section~\ref{sec:range_type}).

  \begin{center}
    \begin{adjustbox}{max width=1.0\linewidth}
      \begin{tabular}{|c|lll|}
        \hline
        Operator & Operation & Example & Interval\\[0pt]
        \hline
        \texttt{..} & Range operator not inclusive & \texttt{34 .. 12} & \texttt{[34;12[}\\[0pt]
            \texttt{...} & Range operator inclusive & \texttt{5 ... 89} & \texttt{[5;89]}\\[0pt]
            \hline
      \end{tabular}
    \end{adjustbox}
  \end{center}

The value of the result range has a default increment of \token{1} and its
inner type is the type of the operand. It can be ascending or descending
depending on the values used to construct it.

\end{itemize}

\subsection{Overflowing}
\label{sec:org0881da2}

Compile-time checks for value overflow are performed on \textit{cte} values.
There is no way to check for an overflow at runtime, and it may occur.

\vfill%
\pagebreak




