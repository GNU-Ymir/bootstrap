\section{Global name aliases}
\label{sec:global_alias_names}

A name alias can be used to simplify code by creating a shorthand reference to a
frequently used type or value. This can make the code more readable and easier
to maintain. The keyword \token{def} is used to create a name alias.

\subsection {Using name alias for types}

A name alias can be associated to a type, by using the keyword \token{def}
followed by an identifier, the token \token{:} and finally a type description.

\begin{lstlisting}[style=coloredverbatim]
def String : [c8];

let a : String = "Hello";
\end{lstlisting}

The alias is a global symbol and has access to other symbols as described in
Section~\ref{sec:symbol_protection}. Therefore, they can be used to export
private symbols within a module to external modules under certain conditions. In
the next example, the class \token{A} takes a template parameter that could be
associated with any value, but we only want to export the version that takes the
value \token{"extern"} as a template parameter without defining the class twice.
The alias declaration \token{X} at line 24 comes in handy, allowing this
exportation without making the symbol \token{A} accessible from outside modules.

\begin{lstlisting}[style=coloredverbatim]
use std::io;

mod inner {
    class A {value : [c8]} {
        pub self () {}

        cte if (value == "local") {
            pub fn local (self) {
                println ("Method for local use only");
            }
        } else {
            pub fn external (self) {
                println ("Method for external use");
            }
        }
    }

    pub fn foo () {
        let x = A!{"local"}::new ();
        x.local ();
    }

    // Exporting a specific specialization of A
    pub def X : A!{"extern"};
}


fn main () {
    let x = inner::X::new ();
    x.external ();

    inner::foo ();
}
\end{lstlisting}

This code demonstrates how to use name alias to create flexible and reusable
components while keeping certain implementation details protected within a
module. The above code is just an example, and there might be many other reasons
that justify the use of name aliases, such as code simplification,
maintainability, and abstractions, among others.

\subsubsection*{Type mutability}

The type associated with an alias is always immutable, with its mutability
effectively defined when the alias is used rather than when it is declared. For
example, in the following code, the alias \token{IntArray} is associated with a
\token{[i32]} slice type, and one cannot declare its mutability within the alias
declaration itself. At line 3, when the alias \token{IntArray} is used to
declare a variable, the use of the keyword \token{dmut} makes the type of the
variable deeply mutable. On the other hand, when the keyword \token{dmut} is not
used at line 5, the resulting type is \token{mut [i32]} instead of \token{mut
  [mut i32]}.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
def IntArray : @\hb{dmut}@ [i32]; // error, mutability change is not allowed here

let dmut a : IntArray = copy [1, 2, 3]; // inner values are mutable, due to dmut
let mut b : IntArray = a; // inner values are not mutable, no need to alias a

b [0] @\hb{=}@ 9; // mutability of IntArray is const by default
\end{lstlisting}

The reason for not allowing mutability change directly from the alias
declaration is to avoid hidden mutability changes. If the keywords \token{mut}
and \token{dmut} were not visible at the location of the variable declaration,
it would create a situation where the variable has mutable access to its data
without clear indication. This would necessitate checking the alias declaration
to ensure such hidden behavior does not occur. This approach contradicts the
philosophy of the Ymir language, which aims to place all behavior explanations
at the location where they effectively have an impact, thereby avoiding the
dispersion of information across the code.

\subsection{Using name alias for values}

A value can be associated to an alias name using a syntax close to the one used
to declare a type name alias, but by replacing the token \token{:} by the token
\token{=}.

\begin{lstlisting}[style=coloredverbatim]
def SuccessMessage = "Success !";
def ErrorMessage = "Failure..";

let test : bool = // ...;
if test {
  println (SuccessMessage);
} else {
  println (ErrorMessage);
}
\end{lstlisting}

As a name alias for a type, a name alias to a value is a global symbol, and thus
can be used to export private symbol to external modules under certain
conditions. In the next example, the function \token{foo} is not accessible fro
the the \token{main} function while the global alias \token{F} is. For that
reason at line 18 and 19, the function \token{foo} can be called using the alias
\token{F} that export an alias to the function prototype symbols. In this
example, the name alias actually exports an alias to multiple symbols - the two
functions \token{foo} declared within the module \token{inner}. It is during the
call expressions at line 18 and 19 that the a specialization is performed (at
compile time) to decide which of the two symbols is used.

\begin{lstlisting}[style=coloredverbatim]
use std::io;

mod inner {

  fn foo (i : i32) {
    println ("In first foo : ", i);
  }

  fn foo (i : i32, j : i32) {
    println ("In second foo : ", i + j);
  }

  pub def F = inner::foo; // with inner:: to make sure no other foo functions are aliased
}

fn main () {
  inner::F (12);
  inner::F (12, 23);
}
\end{lstlisting}

\subsubsection*{Value alias construction}

A name alias exists only during compile time, and therefore has no memory
location at runtime. It is not a constant global variable. For that reason, the
value attached to a name alias is constructed each time it is referenced. In the
next example, the name alias \token{F} is attached to a value that calls the
function \token{foo}. This alias is referenced twice at line 9 and 10, therefore
the function \token{foo} is called twice.

\begin{lstlisting}[style=coloredverbatim]
fn foo ()-> i32 {
  println ("Calling foo");
  12
}

def F = foo ();

fn main () {
  let _ = F;
  let _ = F;
}
\end{lstlisting}


This behavior has other implications, firstly because name aliases have no
memory location and are simply shorthands for constructing values, they cannot
be changed, and have no memory address.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
def V = 12;
def A = copy [1, 2, 3];

V @\hb{=}@ 89; // error, V is not a lvalue
A [0] @\hb{=}@ 8; // error, A is not an lvalue either
\end{lstlisting}

Secondly, when it involves value allocations and memory borrowing. In the next
example, the variable \token{a} and \token{b} borrows two different slices, that
are constructed when referencing the name alias \token{A}.

\begin{lstlisting}[style=coloredverbatim]
def A = copy [1, 2, 3];

let dmut a = A;
let dmut b = A;

a [0] = 9;
assert (b [0] == 1);
\end{lstlisting}

One could arguee that in this example, from the perspective of the variables
\token{a} and \token{b} an hidden allocation is performed. It was chosen to
allow this kind of behavior as the same observation can be made when calling a
function that returns an allocated value without needing the use of an
\token{alias} nor a new \token{copy}. From that understanding, a value name
alias can be seen as a function call that takes no parameter and that is inlined
at compile time.

\begin{lstlisting}[style=coloredverbatim]
fn foo ()-> dmut [i32];
def A = copy [1, 2, 3];

let dmut a = foo ();
let dmut b = A;
\end{lstlisting}

\vfill%
\pagebreak
