\section{Character and String types}

A character type is a data type used to store a single textual symbol, such as a
letter, digit, or punctuation mark. It is commonly used in text processing and
input/output operations. Multiple character values can be combined to form
strings, which are used to represent longer sequences of text.

\subsection{Character literal}
\label{sec:chap2_char_lit}

A character literal consists of a character symbol enclosed in single quotes
(\token{'}). There are three character types: \token{c8}, \token{c16}, and
\token{c32}, which are used to store values in UTF8, UTF16, and UTF32
encoding, respectively. The encoding determines the number of bits used to
represent a character symbol. As we will see in a later subsection, when working
with string values, the choice of encoding plays a major role in how text is
stored in memory.

\begin{lstlisting}[style=coloredverbatim, label=lst:(chap2):char_literal, caption=Example of character literals, escapechar=@]
let x = 'A';
let y = '@\ensuremath{\texttt{\Omega{}}}@'c16;
let z = '@\emoji{slightly-smiling-face}@'c32;
\end{lstlisting}


In listing~\ref{lst:(chap2):char_literal}, three character literals are defined
and stored in the variables \token{x}, \token{y}, and \token{z}. The suffixes
\token{c16} and \token{c32} indicate that the literals \token{'Î©'c16} and
\token{'ðŸ™‚'c32} are encoded using the types \token{c16} and \token{c32},
respectively. When no suffix is specified, as in \token{'A'}, the default UTF8
encoding is used.

\bigskip

\noindent{}The value \token{'ðŸ™‚'} requires exactly 32 bits for encoding and
therefore cannot be stored in a \token{c8} or \token{c16} variable. The compiler
will issue an error for the following source code.

\begin{lstlisting}[style=coloredverbatim, label=lst:(chap2):char_encode_error, escapechar=@]
let x = '@\hb{\emoji{slightly-smiling-face}}@'; // Error : malformed literal, number of c8 is 4 
\end{lstlisting}%

ASCII encoding defines a set of special characters, called escape characters,
which represent formatting actions such as line breaks or tabulation. These
escape characters are always introduced by a backslash. The table below lists
the escape characters available in Ymir. All escape characters (except Unicode
values, which depend on the specific code point being encoded) are representable
as UTFâ€‘8 characters.

\begin{center}
  \begin{tabular}{ll}
    Value & Content\\[0pt]
    \hline
    \texttt{\textbackslash{}a} & Alert beep, (Bell)\\[0pt]
    \texttt{\textbackslash{}b} & Backspace\\[0pt]
    \texttt{\textbackslash{}f} & Page break\\[0pt]
    \texttt{\textbackslash{}n} & New line\\[0pt]
    \texttt{\textbackslash{}r} & Carriage return\\[0pt]
    \texttt{\textbackslash{}t} & Horizontal tab\\[0pt]
    \texttt{\textbackslash{}v} & Vertical tab\\[0pt]
    \texttt{\textbackslash{}\textbackslash{}} & Backslash\\[0pt]
    \texttt{\textbackslash{}'} & Apostrophe\\[0pt]
    \texttt{\textbackslash{}"} & Double quotation mark\\[0pt]
    \texttt{\textbackslash{}u\{code\}} & Unicode\\[0pt]
  \end{tabular}
  \captionof{table}{\label{tab:(chap2):escape_chars} Escape characters}
\end{center}

Table~\ref{tab:(chap2):escape_chars} presents the escape sequence
\texttt{\textbackslash{}u\{code\}}. This escape sequence is used to write
Unicode literals by specifying their integer code point rather than the encoded
character itself. For example, the literal \token{'ðŸ™‚'} corresponds to the value
\token{0x1F642}, and can therefore be written as \token{'\u\{0x1F642\}'c32}.

\subsection{String type}

A string is a data type designed to hold text. It represents a sequence of
characters arranged in memory according to a specific encoding system. Unlike
single character values, strings can contain any Unicode symbol, and the memory
required depends on the characters stored.

\subsection{String literal}

A string literal is a sequence of character symbols enclosed in double quotes
(\token{"}). A string type can be understood as an array (or slice) of character
elements, described using bracket tokens. For example, \token{\[c8\]} represents
a string of arbitrary length encoded in UTFâ€‘8, and \token{\[c16 ; 5\]}
represents a string of exactly 5 characters encoded in UTFâ€‘16. This notation
makes explicit both the encoding system and the size constraints of the string.
Array and slice types will be introduced in detail in the next chapter on
Composed Types. For now, it is sufficient to understand that both arrays and
slices store their values sequentially in memory, one after the other.
\bigskip

\noindent{}As with character literals, a suffix may be appended to a string literal to
specify the encoding style. The available suffixes are \token{s8}, \token{s16},
and \token{s32}. When no suffix is provided, the default encoding system is
UTFâ€‘8.

\begin{lstlisting}[style=coloredverbatim, label=lst:(chap2):string_literal, caption=Example of string literals, escapechar=@]
let greetings = "Hello World!";
let utf8_unicode = "@\texttt{\color{black!30!applegreen} ì•ˆë…•í•˜ì„¸ìš” ì„¸ê³„}@";
let utf32_unicode = "@\texttt{\color{black!30!applegreen} ã“ã‚“ã«ã¡ã¯ ä¸–ç•Œ}@"s32;
\end{lstlisting}

\subsection{A Small Word on Encoding}

As discussed in Section~\ref{sec:chap2_char_lit}, character values may require
up to four bytes of memory depending on the symbol they represent. Basic
characters defined in the ASCII table are encoded using only 8 bits, and can
therefore be stored in \token{c8} type values or within strings of type
\token{[c8]} without the need for complex encoding schemes. For example, in
Listing~\ref{lst:(chap2):string_literal}, the value assigned to the variable
\token{greetings} consists solely of ASCII characters. These characters are
placed sequentially in memory, beginning with the letter \token{'H'}, which
corresponds to the value $72$ in the ASCII table.

\input{chapters/chapter2/figures/hello_string_figure}


\noindent{} When characters cannot be represented within the ASCII table, they are encoded
using the Unicode system. The purpose of Unicode is to provide a universal
mapping for every possible character, using a variable number of bytes ranging
from one to four. In UTFâ€‘32, each character is always encoded with four bytes.
For characters that require fewer bytes, the unused portions are left blank.
While UTFâ€‘32 is conceptually the simplest of the three major encoding schemes
(compared to UTFâ€‘8 and UTFâ€‘16), it is not memoryâ€‘efficient, since a significant
portion of the allocated space is often filled with zeros.

\bigskip

\noindent{}The following Japanese text \colorbox{background!90!gray!60}{\texttt{\color{black!30!applegreen} "ã“ã‚“ã«ã¡ã¯"}}
is composed of five characters, each represented as a UTFâ€‘32
Unicode code point: \token{0x3053 0x3093 0x306b 0x3061 0x306f}. The first
character, \colorbox{background!90!gray!60}{\texttt{\color{black!30!applegreen} ã“}}, has the Unicode code point
\token{0x3053}, which requires only 14 bits. This means it could be stored
within a \token{c16} type. However, under UTFâ€‘32 encoding, every character is
allocated a full 4 bytes, leaving two bytes filled with zeros. The same
applies to each of the five characters in the word, resulting in a total of 20
bytes used, even though only 10 bytes contain meaningful information. On the other hand the character \token{ðŸ™‚} unicode codepoint is \token{0x1f642},
taking 17 bits in memory, therefore not fitting inside a \token{c16} anymore,
therefore UTF16 and UTF32 encoding of that character would take the same
amount of bytes to store the character in memory.

\bigskip

\noindent{}UTFâ€‘8 encodes Unicode characters by using a variable number of bytes for each
symbol. The first byte contains information that indicates how many subsequent
bytes belong to the same character. For example, in the mixed English and Korean
text \colorbox{background!90!gray!60}{\texttt{\color{black!30!applegreen}{"Hello is ì•ˆë…•í•˜ì„¸ìš”"}}}, the segment \token{"Hello is "} uses one
byte per character, while the segment \colorbox{background!90!gray!60}{\texttt{\color{black!30!applegreen}{"ì•ˆë…•í•˜ì„¸ìš”"}}} requires three bytes
for each character. The UTFâ€‘8 encoding of the entire string therefore occupies
24 bytes of memory, compared to 56 bytes in UTFâ€‘32 and 28 bytes in UTFâ€‘16.

\bigskip

\noindent{}Because UTFâ€‘8 uses variable-length encoding, the length of the array must be
considered carefully. Although the word \colorbox{background!90!gray!60}{\texttt{\color{black!30!applegreen}{"ì•ˆë…•í•˜ì„¸ìš”"}}} consists of five
characters, its UTFâ€‘8 representation requires 15 bytes, and the length of the
corresponding \token{\[c8\]} array will thus be reported as 15. Similar care must be
taken when using UTFâ€‘16 encoding, as each character may require either 2 or 4
bytes depending on its Unicode code point.

\begin{lstlisting}[style=coloredverbatim, label=lst:(chap2):encoding_example, caption=Encoding consequence on array length, escapechar=@]
let utf8_str = "@\texttt{\color{black!30!applegreen} ì•ˆë…•í•˜ì„¸ìš” ì„¸ê³„}@";
let utf16_str = "@\texttt{\color{black!30!applegreen} ì•ˆë…•í•˜ì„¸ìš” ì„¸ê³„}@"s16;
let utf32_str = "@\texttt{\color{black!30!applegreen} ì•ˆë…•í•˜ì„¸ìš” ì„¸ê³„}@"s32;

println (utf8_str.len); // 22, or 22 bytes
println (utf16_str.len); // 8, or 8 * 2 => 16 bytes
println (utf32_str.len); // 8, or 8 * 4 => 32 bytes
\end{lstlisting}

\notebox{ For all these encoding reasons, it becomes clear why the character
  \emoji{slightly-smiling-face} cannot be represented using a single \token{c8}. In fact, the
  length of \token{"ðŸ™‚"} is reported as 4, since UTFâ€‘8 requires four bytes to
  encode this symbol. Encoding is not a trivial topic. It will be explored in
  greater detail in a later chapter. What is important to understand here is
  that the apparent length of a string does not always correspond to the number
  of characters it contains. When in doubt, converting the string into UTFâ€‘32
  will reveal the true character count, as UTFâ€‘32 consistently encodes each
  character with a fixed length of four bytes. }

\begin{lstlisting}[style=coloredverbatim, label=lst:(chap2):converting_encoding, caption=String encoding conversion, escapechar=@]
use std::conv; // to import \to\

let utf8_str = "@\texttt{\color{black!30!applegreen} ì•ˆë…•í•˜ì„¸ìš” ì„¸ê³„}@";

let utf32_str = to!{[c32]} (utf8_str); // converting UTF8 into UTF32

assert (utf8_str.len == 22);
assert (utf32_str.len == 8);
\end{lstlisting}
