\section{Variable declaration}

Within a function, a variable can be declared using the \token{let} keyword. A
variable is an identifier that points to a specific value. The value stored in a
variable is associated with a type, which defines the behavior of the program
when referring to that variable. We can think of a variable as a bin that
contains the value, with the size of each bin depending on the type of the
variable. In this chapter we will focus on some of the basic types available in
Ymir. These types only have the ability to store scalar values. The basic types
are the following: integer types, floating point types, character types and
boolean type. There are several floating-point, integer and character types that
can store different ranges of values, but for the moment we will focus on
\token{i32}, \token{f32} and \token{c8}, which are an integer, a floating-point
and a character type respectively. In the following program, four variables are
declared \token{x}, \token{y}, \token{z} and \token{w}. These variables are
typed \token{i32}, \token{f32}, \token{c8} and \token{bool}.

\begin{lstlisting}[style=coloredVerbatim, caption=simple variable declaration, label=lst:(chap2):basic_variables]
use std::io;

fn main () {
  let x : i32 = 10;
  let y : f32 = 3.1415;
  let z : c8 = 'c';
  let w : bool = false;

  println ("X : ", x);
  println ("Y : ", y);
  println ("Z : ", z);
  println ("W : ", w);
}
\end{lstlisting}

\input{chapters/chapter2/figures/variable_bins}

When entering the program, four bins are declared each containing a value (as
depicted in Figure~\ref{fig:(chap2):variable_bins}). The value contained in
these bins can be invoked by using the identifier of the variable as presented
in \textit{println} calls from line 9 to 12 in
Listing~\ref{lst:(chap2):basic_variables}. The syntax of a variable declaration
defines the type of the variable being declared (after the \token{:} token and
before the \token{=} token). This type definition is optional, and is only used
to ensure that the type of the variable is correctly defined by the compiler,
which infers the type from the value used to initialize the variable. In the
previous example, the declared variables are actually constants, since the
values they encapsulate are not mutable and therefore cannot be changed. The
keyword \token{mut} can be placed after the keyword \token{let} to define that a
variable is mutable (and therefore actually a variable). For simplicity, named
constants are also called variables, but are distinguished from actual
variables, which are generally called mutable variables.


The value of a mutable variable can be changed using the \token{=} operator.
This operator assigns a new value to a variable, and is valid only if the new
value (placed on the right side of the operation) is of the same type as the
variable being changed (placed on the left side of the operation). Within an
affectation operation, the left operand is called \textit{lvalue} and the right
operand is called \textit{rvalue}. Listing~\ref{lst:(chap2):value_change}
presents an example of a value modification using the variable \token{x} as the
\textit{lvalue}, resulting in the output presented under it.

\begin{lstlisting}[style=coloredVerbatim, caption=Example of mutable variable, label=lst:(chap2):value_change]
use std::io;

fn main () {
  let mut x = 10;

  x = 42;
  println ("X : ", x);

  x = 314;
  println ("X : ", x);
}
\end{lstlisting}
\vspace{-10pt}%
\begin{lstlisting}[style=bashVerb, label=lst:(chap2):value_change_output]
X : 42
X : 314
\end{lstlisting}

To explain the behavior of the previous source code presented in
Listing~\ref{lst:(chap2):value_change}, lets consider the execution of a program
as a cursor movement going down and starting from the \token{main} function
(which is the first function to be executed in a Ymir program). The program
starts by creating a bin for the variable \token{x} and by putting the value
\token{10} into it. The cursor then goes down and performs the assignment
operation, changing the value of the variable \token{x} to the value \token{42}.
It goes down again and calls the function \textit{println}, which displays the
value of the variable \token{x} in the console output. The same kind of
operations are performed in lines 9 and 10. Program execution following a cursor
movement is a programming paradigm called imperative (more precisely, procedural
programming). There are other paradigms in programming logic, including the
declarative paradigm. Ymir provides different approaches to program execution,
all of which are governed by the imperative procedural paradigm and will be
thoroughly explored in the course of this book.

