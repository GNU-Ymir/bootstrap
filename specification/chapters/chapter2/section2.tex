\section{Variable declaration}

Within a function, a variable can be declared using the \token{let} keyword. A
variable is essentially an identifier that refers to a specific value. Each
value has an associated type, and this type determines how the program
interprets and operates on the variable. To visualize this, we can think of a
variable as a \textit{box} that contains the value. The size and shape of the
box depend on the variable’s type, ensuring that only values of the correct form
can be stored inside. In this chapter, we will focus on the basic types
available in Ymir. These types are limited to storing scalar values. The
fundamental categories are:

\vspace{-10pt}%
\begin{itemize}
\setlength\itemsep{0.2mm}
\item integer types,
\item floating-point types,
\item character types,
\item the boolean type.
\end{itemize}\vspace{-10pt}%

Although Ymir provides several variants of integers, floating-point numbers, and
characters, each capable of representing different ranges of values, we will
concentrate here on three representative examples: \token{i32} (an integer),
\token{f32} (a floating-point number), and \token{c8} (a character).

\smallskip{}
\noindent{}In the following program, four variables are declared: \token{x}, \token{y},
\token{z}, and \token{w}. Their respective types are \token{i32}, \token{f32},
\token{c8}, and \token{bool}.

\begin{lstlisting}[style=coloredVerbatim, caption=simple variable declaration, label=lst:(chap2):basic_variables]
use std::io;

fn main () {
  let x : i32 = 10;
  let y : f32 = 3.1415;
  let z : c8 = 'c';
  let w : bool = false;

  println ("X : ", x);
  println ("Y : ", y);
  println ("Z : ", z);
  println ("W : ", w);
}
\end{lstlisting}

\input{chapters/chapter2/figures/variable_bins}

To better understand how variables work, it can be helpful to imagine them as
boxes. This is only a mental image: in practice, the program does not literally
create boxes, but the metaphor captures the global idea of how values are stored
and accessed. When the program presented in
Listing~\ref{lst:(chap2):basic_variables}, is execute, and the \textit{main}
function is entered, four such \textit{boxes} are created, each containing a
value (see Figure~\ref{fig:(chap2):variable_bins}). The contents of these boxes
can be retrieved by referring to their labels (or identifier), as shown in the
\textit{println} statements from lines 9 to 12 in
Listing~\ref{lst:(chap2):basic_variables}.

\smallskip{}
\noindent{}Declaring a variable follows a specific syntax. After the keyword \token{let},
we may indicate the \textit{shape} of the box (that is, the type of value it can
contain) by writing it between the \token{:} and \token{=} symbols. This type
annotation is optional, because the compiler can usually determine the box’s
shape automatically from the first value placed inside. Once the box’s shape is
set, however, only values of that shape can be stored in it. In the example, the
declared boxes are sealed: their contents cannot be changed once assigned. These
are constants. To create a box that can be reopened and filled with new
contents, we use the keyword \token{mut} after \token{let}. Such boxes are
called mutable variables. For convenience, both sealed and unsealed
\textit{boxes} are often referred to as variables but technically only the
mutable ones behave as true variables in the usual sense.

\smallskip{}

The value stored in a mutable variable can be changed using the \token{=}
operator. This operator assigns a new value to a variable, and the assignment is
valid only if the new value (written on the right-hand side) has the same type
as the variable being updated (written on the left-hand side).

\smallskip{}
\noindent{}In the terminology of assignments, the left operand is called the
\textit{lvalue} (short for \textit{left value}), and the right operand is called
the \textit{rvalue} (short for \textit{right value}). In terms of the box
metaphor, the \textit{lvalue} represents the box itself, while the
\textit{rvalue} represents the new content being placed inside.
Listing~\ref{lst:(chap2):value_change} illustrates such a value modification,
where the variable \token{x} serves as the \textit{lvalue}. The resulting
program output is shown directly below the listing.

\begin{lstlisting}[style=coloredVerbatim, caption=Example of mutable variable, label=lst:(chap2):value_change]
use std::io;

fn main () {
  let mut x = 10;

  x = 42;
  println ("X : ", x);

  x = 314;
  println ("X : ", x);
}
\end{lstlisting}
\vspace{-10pt}%
\begin{lstlisting}[style=bashVerb, label=lst:(chap2):value_change_output]
X : 42
X : 314
\end{lstlisting}

To explain the behavior of the source code shown in
Listing~\ref{lst:(chap2):value_change}, we can imagine the execution of a
program as a cursor moving downward through the instructions, beginning with the
\token{main} function (the entry point of any Ymir program).

\smallskip{}
\noindent{}The program first creates a box for the variable \token{x} and places
the value \token{10} inside. As the cursor continues, it reaches the assignment
operation, which replaces the contents of the box with the new value \token{42}.
The cursor then moves to the next instruction, a call to the \textit{println}
function, which retrieves the value stored in \token{x} and displays it on the
console.

\smallskip{}
\noindent{}The instructions on lines 9 and 10 work in the same way: the cursor
moves downward, step by step, carrying out each operation in order. This style
of execution, where the program state is modified step by step as control flows
from one instruction to the next, is known as imperative programming, and more
specifically, procedural programming.


\smallskip{}
\noindent{}Ymir provides different ways to structure and execute programs, but
all of these approaches follow the imperative procedural paradigm. This
paradigm, which describes step-by-step execution of instructions, forms the
foundation of the language. Its principles and variations will be thoroughly
explored throughout this book.
