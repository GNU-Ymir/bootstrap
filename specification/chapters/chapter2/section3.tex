\vspace{-5pt}%
\section{Operators}

\textit{rvalues} can be formed by combining values stored in one or more
variables. Constructing values in this way, using operators, is essential for
creating programs that perform meaningful operations. Operators are organized
into several subgroups, each representing a different type of elementary
operation. These subgroups allow programs to manipulate data in a variety of
ways, from simple arithmetic to logical comparisons.

\vspace{-5pt}%
\begin{itemize}
  \setlength\itemsep{-4pt}
\item Arithmetic operators are typically applied to integer and floating-point
  values to perform mathematical operations, such as addition, subtraction,
  multiplication, etc. When applied, these operators produce a new value whose
  type matches that of the operands. This allows programs to calculate results
  while preserving the type of the original data.
\smallskip{}

\item Logical operators are used to compare values or combine conditions,
  producing a result of type \token{bool} (true or false). These operators are
  essential for making decisions in a program, such as controlling the flow of
  execution based on certain conditions.
\smallskip{}

\item Byte operators perform operations on values at the binary level. These
  operators will be discussed in a later chapter, after the memory
  representation of a program has been introduced, since understanding how data
  is stored in memory is essential for using them correctly.
\smallskip{}

\item Boolean operators apply Boolean logic to values of type \token{bool}. They
  are used to combine or manipulate true/false values, enabling programs to make
  decisions and control the flow of execution based on logical conditions.
  \smallskip{}

\end{itemize}

An example of arithmetic and logical operators is presented in the following
listing. In this example, values of type \token{i32} are combined using these
operators to produce new values, illustrating how computations and comparisons
are performed in Ymir.

\begin{lstlisting}[style=coloredverbatim, label=lst:(chap2):operator_example, caption=Example of basic operators on \token{i32} values]
use std::io;

fn main () {
  let x = 12;
  let y = 24;

  let z = x + y;
  let w = z * 4;

  println ("Z : ", z);
  println ("W : ", w);
  let b = z > x;

  println ("Z > X : ", b);
}
\end{lstlisting}
\vspace{-10pt}%
\begin{lstlisting}[style=bashVerb, label=lst:(chap2):operator_example_output]
Z : 36
W : 144
Z > W : true
\end{lstlisting}

Multiple operators can be combined in a single expression to perform several
operations at once, making programs shorter and easier to read. Each operator
has a precedence, similar to the rules used in mathematics, which determines the
order in which operations are performed.

\smallskip{}
\noindent{}Table~\ref{tab:(chap2):operator_precedence} shows the precedence of
different operators, where a higher priority means the operator is executed
first. Operator precedence can be visualized as a tree of operations, in which
each node represents an operator, and the children of a node are the operands or
sub-expressions it operates on. The leaves of the tree are the original values,
and the tree is evaluated from the bottom up, combining nodes step by step until
a single final value is obtained.

\smallskip{}
\noindent{}Figure~\ref{fig:(chap2):operator_precedence} illustrates the precedence tree for
the expression \token{1 + 3 * (4 - 9)}. In this example, parentheses \token{()}
increase the precedence of the enclosed operation, so \token{4 - 9} is evaluated
before the multiplication, even though the subtraction operator \token{-}
normally has lower precedence than the multiplication operator \token{*}.

\input{chapters/chapter2/figures/operator_precedence_table}

Figure~\ref{fig:(chap2):operator_precedence_no_par} shows the operator
precedence tree for the almost similar expression \token{1 + 3 * 4 - 9}, but
without parentheses. Notice the difference compared to the previous example:
without parentheses, the order of evaluation is determined solely by operator
precedence. This affects the final result of the expression.

\input{chapters/chapter2/figures/operator_precedence_example}

Some special assignment operators, such as \token{+=} and \token{-=}, are listed
in Table~\ref{tab:(chap2):operator_precedence}. These operators combine a
mathematical operation with an assignment. The \textit{lvalue} on the left-hand
side is used as the left operand of the operation, while the \textit{rvalue} on
the right-hand side is used as the right operand. The result of the operation is
then stored back into the \textit{lvalue}. For example, the operator \token{+=}
can be used to add a value to the variable \token{x} and update it in a single
step.

\smallskip{}
\noindent{}Even if the \textit{rvalue} contains
operations with lower precedence than the assignment itself — such as an
addition within the \textit{rvalue} while a multiplication is involved in a
composed assignment (e.g., \token{x *= y + 1;}) — these operations are executed
in the correct order, as if the entire \textit{rvalue} was enclosed in
parentheses (therefore rewritten into \token{x = x * (y + 1);}).

\smallskip{}
\noindent{}When expressions involve many operators and the order of evaluation
might be unclear, it is good practice to use parentheses or split the operations
across multiple lines. This improves readability and helps avoid mistakes, even
though the compiler always follows a well-defined precedence.

\begin{lstlisting}[style=coloredVerbatim]
let mut x = 10;
let y = 3;

x *= 2 + y; // rewritten into x = x * (2 + y);
println ("X : ", x);
\end{lstlisting}
\vspace{-10pt}%
\begin{lstlisting}[style=bashVerb]
X : 50
\end{lstlisting}


In addition to binary operators, which involve two operands, unary operators
operate on a single operand. Unary operators have higher precedence than binary
operators. Ymir provides four unary operators: \token{-}, \token{&}, \token{*},
and \token{!}. The meaning of each operator depends on the type of its operand,
for example:
\begin{itemize}
\item The \token{-} operator applied to an integer returns its opposite value.
\item The \token{!} operator applied to a boolean returns the opposite boolean value (i.e. the \textit{not} operator).
\item The \token{-} operator does not apply to boolean values.
\item The \token{!} operator applied to an integer performs a bitwise operation (which will be explained in a later chapter).
\end{itemize}

