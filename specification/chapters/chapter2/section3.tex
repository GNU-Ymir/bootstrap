\vspace{-5pt}%
\section{Operators}

\textit{rvalues} can be constructed by composing multiple values from multiple
variables. Value composition using operators is essential for creating programs
that actually perform operations. Operators are divided into several subgroups
that form different types of elementary operations.

\vspace{-5pt}%
\begin{itemize}
  \setlength\itemsep{-4pt}
\item Arithmetic operators (generally used on integer and floating-point values) are used to perform mathematical operations such as addition, subtraction, and so on. They produce a new value of the same type as the operands.
\item Logical operators are used to compare values and produce a boolean value.
\item Byte operators perform operations on values at the binary level (these operators will be discussed in a future chapter after the memory representation of a program will have been presented).
\item Boolean operators, which apply Boolean logic to values of type Boolean.
\end{itemize}

Example of arithmetic and logical operators are presented in the next Listing.
In this example, values of type \token{i32} are used to generate a new value.

\begin{lstlisting}[style=coloredverbatim, label=lst:(chap2):operator_example, caption=Example of basic operators on \token{i32} values]
use std::io;

fn main () {
  let x = 12;
  let y = 24;

  let z = x + y;
  let w = z * 4;

  println ("Z : ", z);
  println ("W : ", w);
  let b = z > x;

  println ("Z > X : ", b);
}
\end{lstlisting}
\vspace{-10pt}%
\begin{lstlisting}[style=bashVerb, label=lst:(chap2):operator_example_output]
Z : 36
W : 144
Z > W : true
\end{lstlisting}


\input{chapters/chapter2/figures/operator_precedence_table}

Multiple operators can be concatenated to perform multiple operations in one
line, making programs shorter and more readable. Operators have what is called
precedence (as in mathematics). The precedence of operators is defined in the
table~\ref{tab:(chap2):operator_precedence}, where the higher priority means
that the operator is executed first. The operator precedence generates a tree of
operands, where each node (operand) of a tree pair is executed from left to
right. The figure~\ref{fig:(chap2):operator_precedence} shows the operator
precedence tree of the operation \token{1 + 3 * (4 - 9)}. In this operation, the
use of the token \token{()} makes the bracketed operation more precedent than
the multiplication operation, even if the operator \token{-} has less precedence
than the operator \token{*}. Figure~\ref{fig:(chap2):operator_precedence_no_par}
presents the operator precedence tree of the nearly similar operation \token{1 +
  3 * 4 - 9}. Notice the difference between the two.

\input{chapters/chapter2/figures/operator_precedence_example}

You can note special affectation operators from
Table~\ref{tab:(chap2):operator_precedence} (e.g., \token{+=}, \token{-=}).
These operators are a shortened version of a math operation and an affectation,
taking the \textit{lvalue} as the left operand of the math operation and the
\textit{rvalue} as the right value before affecting the result to the
\textit{lvalue}. In the following example, the \token{+=} operator is used to
assign a new value to the variable \token{x}. Even though the right operand is
formed by an addition operator (which has a lower precedence than the
multiplication operator), it is executed with priority, and the multiplication
is done last, just before the affectation, you may consider the right operand to
be surrounded by parentheses. When operator precedence is not clear or is
subject to interpretation -- even if the compiler always uses the same order
operation -- for example, when many operands are involved, it may be a good
practice to use parentheses or to decompose the operations into multiple lines.

\begin{lstlisting}[style=coloredVerbatim]
let mut x = 10;
let y = 3;

x *= 2 + y; // rewritten into x = x * (2 + y);
println ("X : ", x);
\end{lstlisting}
\vspace{-10pt}%
\begin{lstlisting}[style=bashVerb]
X : 50
\end{lstlisting}

In addition to binary operators (operators involving two operands), unary
operators are used to apply operations to a single operand. These operators have
the highest priority over binary operators. There are four unary operators:
\token{-}, \token{&}, \token{*}, and \token{!}. These operators
have different meanings depending on the type of operand they have. For example,
the \token{-} operator on an integer value returns the opposite value, while
the \token{!} operator on a boolean value also returns the opposite value of
the boolean, while the \token{-} operator has no meaning on boolean values,
and the \token{!} operator performs a bitwise operation on an integer value
(which will be explained in a future chapter).
