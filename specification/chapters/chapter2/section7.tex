\vfill\pagebreak
\section{Boolean type and Boolean algebra}

A Boolean is a fundamental data type that can hold one of two values,
\token{true} or \token{false}. It is designed to represent truth values in
logical operations and Boolean algebra. Boolean values form the foundation of
conditional processing, enabling programs to follow different branches of
execution depending on control flow decisions. In Ymir the Boolean type is
represeted by the keyword \token{bool}, and is encoded in one byte of memory
where the value \token{0b00000000} represents the value \token{false}, and
\token{true} is represented by any other value.

\subsection{Primary operators}

Boolean algebra is concerned with truth values and the operations used to
combine them. It is built on three fundamental operations, AND, OR, and NOT (in
contrast to the four basic operations of numerical algebra — addition,
subtraction, multiplication, and division). Any other logical operation can be
expressed in terms of these three. Mastering Boolean algebra is essential for
computer science, as it forms the foundation of programming and control flow.

The AND operation (also called conjunction), denoted as $\land$ in Boolean
algebra and written as \token{&&} in Ymir, compares two Boolean values and
returns \token{true} only if both operands are \token{true}. The OR operation
(also called disjunction), denoted as $\lnot$ in Boolean algebra and written as
\token{||} in Ymir, also takes two operands and returns \token{true} if at least
one of them is \token{true}, regardless of the other. The final elementary
operator, NOT (also called negation), denoted as $\lnot$ in Boolean algebra and
written as \token{!} in Ymir, takes a single operand and inverts its value,
turning \token{true} into \token{false} and \token{false} into \token{true}. The
Boolean value \token{false} is commonly denoted by \bot, while \token{true} is
represented by \top.

\input{chapters/chapter2/figures/boolean_algebra_base_operators}
\vspace{-10pt}%
\subsection{Secondary operators}

Boolean algreba defines secondary operators, that are formed from the basic
operations. One can list three of them, implication, bidirectional implication,
and exclusive disjunction. All secondary operations can be transformed into a
expression of basic operators.

\begin{itemize}
\vspace{-5pt}%
\item Implication: $x \rightarrow y = \lnot x \lor y$.
\vspace{-5pt}%
\item Bidirectional implication : $x \leftrightarrow y = (\lnot x \lor y) \land (x \lor \lnot y)$ 
\vspace{-5pt}
\item Exclusive disjunction (or XOR) : $x \oplus y = (x \land \lnot y) \lor (\lnot x \land y)$
\end{itemize}
\vspace{-5pt}%

\input{chapters/chapter2/figures/boolean_algebra_secondary}


To understand rewriting, we can examine the following table, which presents the
truth values of the three operators. As an example, consider the implication
operator. The two simplest cases occur when the value of $x$ is true: in this
situation, for the implication to evaluate to true, $y$ must also be true.
Conversely, when the value of $x$ is false, the implication provides no
constraint on $y$. Indeed, since implication is one‑sided, the truth of $y$ does
not determine the truth of $x$, and $y$ may therefore be either true or false.
Although in everyday language the expression $\lnot x \lor y$ may seem to carry
a different meaning, it produces exactly the same truth table.

Ymir does not provide secondary operators for Boolean values, since the primary
operators already perform all the necessary operations on them.

\subsection{Laws on Boolean operators}

Boolean operations obey many of the same laws as ordinary arithmetic operators.
 For instance, the $\lor$ operator can be compared to addition, and the $\land$
 operator to multiplication. As a consequence, the three fundamental laws of
 commutativity, associativity, and distributivity are also applicable in Boolean
 algebra.

\textit{a)} Commutativity: the order of the operands does not affect the result of the
operation. This property applies to both AND and OR, for example $x \lor y =
y \lor x$.
\smallskip

\textit{b)} Associativity: the way operands are grouped does not affect the result of the
operation. This property applies to both AND and OR; for example, $x \land
(y \land z) = (x \land y) \land z$. However, associativity does not hold when
different operators are mixed. For instance, $x \land (y \lor z) \neq (x \land
y) \lor z$. To illustrate, let $x = \bot, y = \bot$ and $z = \top$, then
$x \land (y \lor z) = \bot$ while $(x \land y) \lor z = \top$.
\smallskip

\textit{c)} Distributivity: One operation can be spread across another. For instance
$x \land (y \lor z) = (x \land y) \lor (x \land z)$.

These laws are one of the main sources of errors when working with Boolean logic
operators, so it is important to keep them in mind. In Ymir, the AND operator
has higher precedence than the OR operator (since it is comparable to
multiplication, while OR corresponds to addition). Nevertheless, it is good
practice to use parentheses to group Boolean expressions, both to avoid mistakes
in the intended logic and to account for the algebraic laws that govern Boolean
operations.

A good example of a possible error is to rely on commutativity alone, and forgetting about precedence, leading to differences in associativity. In the next listing the variable \token{r1} and \token{r2} will hold different values, due to the laws we have described.

\begin{lstlisting}[style=coloredverbatim, label=lst:(chap2):boolean_error, caption=Example of logic error when dealing with Boolean values, escapechar=@]
let x = false, y = false, z = true;                                          

let r1 = x && y || z;
let r2 = (z || x) && y;

@\hb{assert (r1 == r2);}@ // Sorry, wrong. 
\end{lstlisting}

\subsection{Specificities of Boolean operators in Ymir}

In Ymir, Boolean operators are implemented using conditional branching to
determine the result. In other words, the second operand of a Boolean operation
is not always evaluated if the first operand already provides a definitive
outcome. This occurs when the first operand of an AND operation is false, or
when the first operand of an OR operation is true. For example, if the first
operand of an AND operation is false, the overall result must necessarily be
false, regardless of the value of the second operand.

The reasons for this behavior are twofold. First, it provides optimization: the
second operand may involve a complex computation rather than a simple variable
lookup (for example, a function call), and skipping its evaluation saves
computation time. Second, it ensures that the second operand is only evaluated
when the first operand does not already determine the result. This behavior has
practical applications, which will be examined in subsequent chapters.

In the following example, the function \token{foo} is not called because the
variable \token{x} holds the value true. By the absorption law, $\top \lor y$ is
always $\top$, regardless of the value of $y$. If the OR operator were replaced
by the AND operator \token{&&} at line 11, the function \token{foo} would be
evaluated, unless the value of $x$ were also set to \token{false}. In that case,
$\bot \land y$ is always $\bot$, regardless of the value of $y$.

\begin{lstlisting}[style=coloredverbatim, caption=Example of boolean operation optimised out]
fn foo ()-> bool {
    println ("In foo");
    true
}

fn main ()
    throws AssertError
{
    let mut x = true;

    assert (x || foo ()); // not calling foo
    println ("Exit");
}
\end{lstlisting}
\begin{lstlisting}[style=bashVerb, escapechar=@+]
@+\textcolor{teal!80}{alice@dev:\mtilde}@+$ gyc main.yr -o main
@+\textcolor{teal!80}{alice@dev:\mtilde}@+$ ./main
Exit
\end{lstlisting}


Consequently even though standard boolean algebra specifies that AND and OR operators are commutative, there are not in Ymir.
