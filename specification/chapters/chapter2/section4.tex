\section{Integer types}

Ymir provides several types to store integer values: \token{i8}, \token{i16},
\token{i32}, \token{i64}, and \token{isize}. These types differ in the range of
values they can represent, which is determined by the number of bits used in
memory. The \token{isize} type represents the largest integer size that the
system can handle (for example, 64 bits on ARM64 or 32 bits on x86).

\smallskip{}
\noindent{}Integer types that start with the letter \textit{i} are signed,
meaning they can store both positive and negative values. In contrast, types
starting with the letter \textit{u}—\token{u8}, \token{u16}, \token{u32},
\token{u64}, and \token{usize}—are unsigned, meaning they can only store
non-negative values. The presence or absence of a sign affects the range of
values that each type can encode.

\subsection{Literal representation}

An integer literal is a sequence of digits in the source code that represents a
constant integer value. Integer literals are written in decimal form, using only
numbers without spaces. For example, \token{12} and \token{36} are integer
literals, as seen in previous listings. To make long numbers easier to read,
thqe underscore (\_) can be used as a separator. For instance,
\token{1\_000\_000\_000\_000} is a valid integer literal equivalent to one
trillion.

\smallskip{}
\noindent{}By default, integer literals create values of type i32. However, it is possible
to explicitly specify another integer type by adding a suffix. For example, 12u8
creates an 8-bit unsigned integer, while 12i64 would create a 64-bit signed
integer.

\mynotebox{
  More advanced integer literals can be written in octal, hexadecimal,
  or binary form. These representations are covered in detail in the advanced
  chapter on integers (see Chapter~\ref{sec:(chap3):integers}).
}

\subsection{Memory representation}

Computers store numbers in binary (base $2$), meaning each digit, called a bit,
can only be $0$ or $1$. Each bit represents a power of $2$, starting from the
rightmost bit as $2^0$, the next as $2^1$, and so on. An 8-bit integer, for
example, uses 8 bits (1 byte) to store a value, forming an 8-digit number in
base $2$.

\input{chapters/chapter2/figures/integer_range}

\smallskip{}
\noindent{}Unsigned 8-bit integers \token{u8} use all 8 bits to represent non-negative
numbers, ranging from $0$ to $2^8-1 = 255$. Each bit contributes to the total
value depending on its position: the rightmost bit represents 1, the next bit 2,
then 4, 8, 16, 32, 64, and finally 128 for the leftmost bit. For instance, the
number 13 in binary is $00001101$, which corresponds to:
\begin{equation}
  (0\times{}128) +
  (0\times{}64) + (0\times{}32) + (0\times{}16) + (1\times{}8) + (1\times{}4) + (0\times{}2) +
  (1\times{}1) = 13
\end{equation}

Signed 8-bit integers \token{i8} can store both negative and positive numbers.
Ymir uses two’s complement to represent negative values, where the most
significant bit (MSB) serves as a sign bit (i.e., the first bit): 0 indicates a
positive number, and 1 indicates a negative number. The positive number 13 is
represented exactly as in the unsigned case: $00001101$. To represent $-13$, one
first writes 13 in binary ($00001101$), then inverts all bits to get $11110010$,
and finally adds 1, resulting in $11110011$, which represents -13. Because the
most significant bit (MSB) is used to indicate whether a number is positive or
negative, one bit is effectively reserved for the sign. As a result, an 8-bit
signed integer can represent values from $-2^7$ to $2^7-1$, which is from $-128$
to $127$. Despite this, there are still 256 distinct values that can be
represented in total, the same as the number of values in an 8-bit unsigned
integer.

\mynotebox{
  The unary operator \token{!}, when applied to an integer, returns its one’s
  complement—that is, it inverts all the bits of the number. For example, the
  operation \token{(!13) + 1} produces the two’s complement of $13$, which is equal
  to \token{-13}.
}

This concept generalizes to integers of larger sizes. Integer types in Ymir
commonly use 8, 16, 32, or 64 bits. The number of bits determines the range of
values that can be stored. Unsigned integers range from 0 to $2^N-1$, while
signed integers using two’s complement range from $-2^{N-1}$ to $2^{N-1}-1$.
While base 2 can theoretically represent any number, computer memory is finite,
so integer types always have a fixed range.


\subsection{Integer overflow}

Because integers are stored using a fixed number of bits, each integer type can
represent only a limited range of values. When a calculation produces a value
larger than the maximum or smaller than the minimum, an event called
\textit{integer overflow} occurs.

\smallskip{}
\noindent{}For example, consider an 8-bit unsigned integer \token{u8}, which can
store values from $0$ to $255$. Adding $1$ to $255$ causes an overflow, which
wraps around and results in 0. Similarly, subtracting $1$ from $0$ wraps around
to $255$. Signed integers can also overflow. For an 8-bit signed integer
\token{i8}, which ranges from $-128$ to $127$, adding $1$ to $127$ or
subtracting $1$ from $-128$ produces a value outside the representable range. In
Ymir, there is no built-in mechanism to detect or prevent integer overflow. If
an overflow occurs, it happens at runtime - and cannot be verified during
compilation, and handling it safely would significantly reduce performance.

\smallskip{}
\noindent{}Integer overflow is important to understand because it can lead to unexpected results or bugs in programs if not carefully managed.
