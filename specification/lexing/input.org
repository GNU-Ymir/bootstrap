

** Input

The input format of an ymir source file is interpreted as a sequence of Unicode code points in Utf-8.
The file extension it ~.yr~

** Keywords

There are two type of keywords, strict keywords and weak ones. Strict keywords cannot be used as identifiers.

*** Strict keywords

#+ATTR_LATEX: :environment longtable :align |l|l|
|-------------+-------------------------------------------------------------------------|
| value       | Short description                                                       |
|-------------+-------------------------------------------------------------------------|
| ~aka~       | As known as, to give a name to a value or a type to be                  |
|             | used multiple times (can also be used in an import)                     |
| ~alias~     | Memory management                                                       |
| ~assert~    | Assertion expression                                                    |
| ~atomic~    | Thread safe code section                                                |
| ~break~     | Loop breaking                                                           |
| ~cast~      | Type casting                                                            |
| ~class~     | Class definition                                                        |
| ~const~     | Constant attribute for a type or a value                                |
| ~copy~      | Single level memory copy                                                |
| ~cte~       | Compile time evaluation                                                 |
| ~dcopy~     | Deep level memory copy                                                  |
| ~def~       | Function definition                                                     |
| ~dg~        | Delegate type (closure type)                                            |
| ~dmut~      | Deeply mutable attribute for type or variable                           |
| ~do~        | Do for do while loop                                                    |
| ~__dtor~    | Destructor of class instance                                            |
| ~else~      | Else part of an if else construction                                    |
| ~enum~      | Definition of an enumeration                                            |
| ~expand~    | Expand a tuple value into multiple parameters                           |
| ~extern~    | Define an external definition (from another language)                   |
| ~false~     | Literal false value of bool type                                        |
| ~for~       | For loop                                                                |
| ~fn~        | Type of function pointer type                                           |
| ~if~        | If part of an if else construction                                      |
| ~impl~      | Trait implementation in class                                           |
| ~import~    | Module importation                                                      |
| ~in~        | In operator (and for loop)                                              |
| ~is~        | Pointer type and class instance equality operator                       |
| ~lazy~      | Global var declaration or lazy value, variable                          |
| ~let~       | Variable definition                                                     |
| ~loop~      | Loop without terminal condition                                         |
| ~macro~     | Macro definition                                                        |
| ~match~     | pattern matching construction                                           |
| ~mod~       | Module definition                                                       |
| ~mut~       | Mutable property for type of variable                                   |
| ~null~      | Null value for pointer type                                             |
| ~of~        | Template specialization operator                                        |
| ~over~      | Template specialization operator, method override and class inheritence |
| ~__pragma~  | Pragma operations (compilable, panic, trusted...)                       |
| ~prv~       | Private definition protection                                           |
| ~prot~      | Protected definition protection                                         |
| ~pub~       | Public definition protection                                            |
| ~pure~      | Pure property for type or variable                                      |
| ~ref~       | Reference property for variable                                         |
| ~return~    | Function return statement                                               |
| ~self~      | class instance object in methods                                        |
| ~sizeof~    | Sizeof type                                                             |
| ~struct~    | Structure definition                                                    |
| ~super~     | Super object instance in methods                                        |
| ~throw~     | Throw exception statement                                               |
| ~throws~    | Throw list of exception in function definition                          |
| ~trait~     | Trait definition                                                        |
| ~true~      | True literal value of bool type                                         |
| ~typeof~    | Get the type from a value                                               |
| ~__test~    | unittest definition                                                     |
| ~__version~ | version test                                                            |
| ~while~     | While loop                                                              |
| ~with~      | With construction (for disposable types)                                |
|-------------+-------------------------------------------------------------------------|

*** Weak

#+ATTR_LATEX: :environment longtable :align |l|l|
|-----------+-----------------------------------------------|
| value     | Short description                             |
|-----------+-----------------------------------------------|
| ~C~       | C language external                           |
| ~CXX~     | C++ language external                         |
| ~D~       | D language external                           |
| ~new~     | allocation of new object, or slice allocation |
| ~typeid~  | the type id of a type                         |
| ~success~ | Success scope guard                           |
| ~failure~ | Failure scope guard                           |
| ~exit~    | Exit scope guard                              |
| ~main~    | Main function name                            |
| ~_~       | Anonymus variable name                        |
| ~YMIR~    | Ymir language external                        |
| ~skips~   | Tokens skiped in macro definition             |
| ~members~ | List of members of a enumeration              |
|-----------+-----------------------------------------------|



** Identifier

Identifiers follow the grammar rule :

#+BEGIN_EXAMPLE :align center
identifier := (_)* [a-zA-Z] ([a-zA-Z0-9] | '_')*
#+END_EXAMPLE


\noindent The token ~_~ is a valid identifier that indicates a variable that is intentionally unused.

*** Convention

- Identifier beginning by the token ~_~ (e.g. ~_myVar~) are private or protected within the current context.
- Global identifier are written in full upper case separated by the token ~_~ and surrounded by two ~_~ tokens (e.g. ~lazy __GLOBAL_VARIABLE__~).
- Types start with an upper case letter and each new word also start with an upper case letter (e.g. ~struct MyStruct~, ~class Foo~).
- All other identifiers are starting by a lower case letter and each new word starts with an upper case letter. (e.g. ~def functionDoingSomething~, ~let localVar~)

\pagebreak

** Comments

Comments follow the grammar rule :
#+BEGIN_EXAMPLE
comments :=   single_line_comment
            | multiline_comments
            | no_doc_comment

single_line_comment := '//' ([^\n])* '\n'
multiline_comments := '/*' (comments | [^*/])* '*/'
no_doc_comment := '/*!'' (comments | [^*/])* '*/'

#+END_EXAMPLE
