* Input

The input format of an ymir source file is interpreted as a sequence of Unicode
code points in Utf-8. The file extension it ~.yr~

* Keywords

There are two type of keywords, strict keywords and weak ones. Strict keywords cannot be used as identifiers.

** Strict keywords

#+ATTR_LATEX: :environment longtable :align |l|l|
|-------------+-------------------------------------------------------------------------|
| value       | Short description                                                       |
|-------------+-------------------------------------------------------------------------|
| ~aka~       | As known as, to give a name to a value or a type to be                  |
|             | used multiple times (can also be used in an import)                     |
| ~alias~     | Memory management                                                       |
| ~assert~    | Assertion expression                                                    |
| ~atomic~    | Thread safe code section                                                |
| ~break~     | Loop breaking                                                           |
| ~cast~      | Type casting                                                            |
| ~class~     | Class definition                                                        |
| ~const~     | Constant attribute for a type or a value                                |
| ~copy~      | Single level memory copy                                                |
| ~cte~       | Compile time evaluation                                                 |
| ~dcopy~     | Deep level memory copy                                                  |
| ~def~       | Function definition                                                     |
| ~dg~        | Delegate type (closure type)                                            |
| ~dmut~      | Deeply mutable attribute for type or variable                           |
| ~do~        | Do for do while loop                                                    |
| ~__dtor~    | Destructor of class instance                                            |
| ~else~      | Else part of an if else construction                                    |
| ~enum~      | Definition of an enumeration                                            |
| ~expand~    | Expand a tuple value into multiple parameters                           |
| ~extern~    | Define an external definition (from another language)                   |
| ~false~     | Literal false value of bool type                                        |
| ~for~       | For loop                                                                |
| ~fn~        | Type of function pointer type                                           |
| ~if~        | If part of an if else construction                                      |
| ~impl~      | Trait implementation in class                                           |
| ~import~    | Module importation                                                      |
| ~in~        | In operator (and for loop)                                              |
| ~is~        | Pointer type and class instance equality operator                       |
| ~lazy~      | Global var declaration or lazy value, variable                          |
| ~let~       | Variable definition                                                     |
| ~loop~      | Loop without terminal condition                                         |
| ~macro~     | Macro definition                                                        |
| ~match~     | pattern matching construction                                           |
| ~mod~       | Module definition                                                       |
| ~mut~       | Mutable property for type of variable                                   |
| ~null~      | Null value for pointer type                                             |
| ~of~        | Template specialization operator, and dynamic type comparison           |
| ~over~      | Template specialization operator, method override and class inheritence |
| ~__pragma~  | Pragma operations (compilable, panic, trusted...)                       |
| ~prv~       | Private definition protection                                           |
| ~prot~      | Protected definition protection                                         |
| ~pub~       | Public definition protection                                            |
| ~pure~      | Pure property for type or variable                                      |
| ~ref~       | Reference property for variable                                         |
| ~return~    | Function return statement                                               |
| ~self~      | class instance object in methods                                        |
| ~sizeof~    | Sizeof type                                                             |
| ~struct~    | Structure definition                                                    |
| ~super~     | Super object instance in methods                                        |
| ~throw~     | Throw exception statement                                               |
| ~throws~    | Throw list of exception in function definition                          |
| ~trait~     | Trait definition                                                        |
| ~true~      | True literal value of bool type                                         |
| ~typeof~    | Get the type from a value                                               |
| ~__test~    | unittest definition                                                     |
| ~__version~ | version test                                                            |
| ~while~     | While loop                                                              |
| ~with~      | With construction (for disposable types)                                |
|-------------+-------------------------------------------------------------------------|

** Weak

#+ATTR_LATEX: :environment longtable :align |l|l|
|-----------+-----------------------------------------------|
| value     | Short description                             |
|-----------+-----------------------------------------------|
| ~C~       | C language external                           |
| ~new~     | allocation of new object, or slice allocation |
| ~typeid~  | the type id of a type                         |
| ~success~ | Success scope guard                           |
| ~failure~ | Failure scope guard                           |
| ~exit~    | Exit scope guard                              |
| ~main~    | Main function name                            |
| ~_~       | Anonymus variable name                        |
| ~skips~   | Tokens skiped in macro definition             |
| ~members~ | List of members of a enumeration              |
|-----------+-----------------------------------------------|



* Identifier

Identifiers follow the grammar rule :

\begin{code}
Identifier := (_)* [a-zA-Z] ([a-zA-Z0-9] | '_')*
\end{code}

\noindent The token ~_~ is a valid identifier that indicates a variable that is intentionally unused.

** Convention

- Identifier beginning by the token ~_~ (e.g. ~_myVar~) are private or protected within the current context.
- Global identifier are written in full upper case separated by the token ~_~ and surrounded by two ~_~ tokens (e.g. ~lazy __GLOBAL_VARIABLE__~).
- Types start with an upper case letter and each new word also start with an upper case letter (e.g. ~struct MyStruct~, ~class Foo~).
- All other identifiers are starting by a lower case letter and each new word starts with an upper case letter. (e.g. ~def functionDoingSomething~, ~let localVar~)

* Comments

Comments follow the grammar rule :

\begin{code}
comments :=   single_line_comment
            | multiline_comments
            | no_doc_comment

single_line_comment := '//' ([^\n])* '\n'
multiline_comments := '/*' (comments | [^*/])* '*/'
no_doc_comment := '/++'' (comments | [^+/])* '+/'
\end{code}

* Global declarations :

List of global declarations and there respective syntax.

\begin{code}
source := ('mod' Path ';')? block_declaration

block_declaration :=   protection_block
                     | version_block
                     | extern_block
                     | '{' declaration* '}'

protection_block := ('pub' | 'prv') block_declaration
extern_block := 'extern' ('(' 'C' ')')? block_declaration
version_block := '__version' Identifier block_declaration ('else' block_declaration)

declaration :=   aka
               | class
               | enum
               | function
               | global_decl
               | import
               | extern
               | macro
               | module
               | struct
               | trait
               | unittest
\end{code}


** Attributes

Attributes are used to give properties to declaration (e.g. classes, structs, functions, etc.)

\begin{code}
attributes :=   '@' '{' Identifier (',' Identifier)* '}'
              | '@' Identifier
\end{code}

** Template parameter list

Template parameter list can be used in almost any global declaration (not all, e.g. imports), to define template specialization definition.

\begin{code}
template_param_list := '{' template_param (',' template_param)* '}'

template_param :=   'struct' Identifier
                  | 'class' Identifier
                  | 'tuple' Identifier
                  | 'alias' Identifier
                  | template_var_param
                  | operand:(3)

template_var_param :=   Identifier ':' expression:(10) ('=' expression:(0))?
                      | Identifier '=' expression:(0)
                      | Identifier '...'
                      | Identifier 'over' expression:(0)
                      | Identifier 'of' expression:(0)
                      | Identifier 'impl' expression:(0)
\end{code}

** Aka

\begin{code}
aka := 'aka' Identifier '=' expression:(0) ';'
\end{code}

An aka is a global declaration giving a name to a type, or a value.

** Class

\begin{code}
class :=   template_class
         | simple_class

template_class := 'class' ('if' expression:(0))? (attributes)?
                          Identifier template_param_list  ('over' expression:(0))
                   '{'
                          class_content
                   '}'

simple_class := 'class' (attributes)?
                        Identifier ('over' expression:(0))
                '{'
                        class_content
                '}'

class_content := (  class_protection_block
                  | class_version_block
                  | class_cte_block
                  | class_inner_declaration)*

class_inner_declaration :=   class_simple_inner_declaration
                           | class_impl   (; cannot be used inside protection)
                           | import (; cannot be used inside protection)
                           | class_dtor   (; cannot be used inside protection)

class_simple_inner_declaration :=   class_constructor
                                  | class_function
                                  | 'let' single_var_decl ';'
\end{code}


*** /Class version, protection, cte/

\begin{code}
class_protection_block := ('pub' | 'prot' | 'prv') class_simple_content
class_version_block :=  '__version' Identifier class_content ('else' class_content)?
class_cte_block := 'cte' 'if' expression:(0) class_content ('else' class_content)?

class_simple_content := class_simple_inner_declaration*
\end{code}

*** /Class constructor/

\begin{code}
class_constructor :=   class_constructor_template
                     | class_constructor_simple


class_constructor_template := 'self' ('if' expression:(0)) (attributes)? template_param_list
                                     function_param_list
                                     (class_constructor_with)? (throws_decl)?
                               expression:(0)


class_constructor_simple := 'self' function_param_list
                                   (class_constructor_with)? (throws_decl)?
                            expression:(0)


class_constructor_with := 'with' (Identifier '=' expression:(0))+
\end{code}

*** /class function/

\begin{code}
class_function :=   class_function_template
                  | class_function_simple

class_function_template := 'def' ('if' expression:(0))? Identifier template_param_list
                                 class_function_param_list ('->' expression:(0))? (throws_decl)?
                                 expression:(0)

class_function_simple := ('def' | 'over') Identifier
                                 class_function_param_list ('->' expression:(0))? (throws_decl)?
                                 expression:(0)



class_function_param_list := '(' ('mut')? 'self' (',' single_var_decl)* ')'
\end{code}

*** /class destructor/

\begin{code}
class_dtor := '__dtor' '(' 'mut' 'self' ')' expression:(0)
\end{code}


*** /class implements/

\begin{code}
class_impl :=   'impl' expression:(0) '{' class_function_simple* '}'
              | 'impl' expression:(0) (',' expression:(0))* ';'
\end{code}


** Enumeration

\begin{code}
enum :=   enum_template
        | enum_simple

enum_template := 'enum' ('if' expression:(0))?
                        enum_content '->' Identifier template_param_list ';'

enum_simple := 'enum' enum_content
                      '->' Identifier ';'

enum_content := ('|' Identifier '=' expression:(0))*
\end{code}


** Function

\begin{code}
function :=   function_template
            | function_simple

function_template := 'def' ('if' expression:(0))? (attributes)? Identifier
                           template_param_list param_list
                           '->' expression:(0)
                           (throws_decl)?
                           expression:(0)

function_simple := 'def' (attributes)? Identifier param_list '->' expression:(0)
                         (throws_decl)?
                         expression:(0)

param_list := '(' (single_var_decl (',' single_var_decl)*)? ')'

throws_decl := 'throws' expression:(0) (',' expression:(0))*
\end{code}


** Global

\begin{code}
global_var := 'let' single_var_decl ';'
\end{code}


** Import

\begin{code}
import :=   'import' single_import (',' single_import)* ';'

single_import := path ('aka' Identifier)
\end{code}

** Macro

\begin{code}
macro := 'macro' Identifier '{' macro_content* '}'

macro_content :=   'pub' macro_content
                 | '__version' Identifier macro_content ('else' macro_content)
                 | import
                 | '{' macro_content* '}''
                 | macro_rule
                 | macro_ctor

macro_ctor := 'self' macro_head_rule macro_body_rule
macro_rule := 'def' Identifier macro_head_rule (macro_body_rule | ';')

macro_head_rule := macro_inner_mult ('skips' ('"' [.]* '"' '|' ('"' [.]* '"')*)?
macro_inner_mult := '(' (macro_expression*) ')'
                    '(' (macro_expression '|' macro_expression)* ')'

macro_expression :=   macro_inner_mult (Multiplicator)?
                    | Identifier '=' macro_expression
                    | '"' [.]* '"'
                    | expression:(10)

macro_body_rule := '{' [.]* '}'
Multiplicator := ('*' | '+' | '?')
\end{code}

** Module

\begin{code}
module :=   module_template
          | module_simple

module_template := 'mod' ('if' expression:(0)) Identifier template_param_list block_declaration
module_simple := 'mod' Identifier block_declaration
\end{code}

** Struct

\begin{code}
struct :=   struct_template
          | struct_simple

struct_template := 'struct' ('if' expression:(0))
                            struct_field*
                            '->' Identifier template_param_list ';'

struct_simple := 'struct' struct_field* '->' Identifier ';'
struct_field := '|' single_var_decl
\end{code}

** Trait

\begin{code}
trait :=   trait_template
         | trait_simple

trait_template := 'trait' ('if' expression:(0)) Identifier
                          template_param_list
                          '{'
                              class_content
                          '}'

trait_simple := 'trait' Identifier
                        '{'
                             class_content
                        '}'
\end{code}

If traits can read constructors, dtors and implementations during syntaxic time, they will be invalid during semantic time.

** Unittest

\begin{code}
unittest := '__test' expression:(0)
\end{code}

* Expressions

List of expressions and their respective syntax

** expression

Expression are read in a way that ensure operator precedence at syntaxic time. Thus generated syntaxic tree can be validated in the order is was generated at semantic time. The higher level of the operator the higher the priority of the operator.

\begin{code}
expression:(level) := expression:(level + 1) operator:(level) expression:(level)
expression:(10) := operand:(0)

operator:(0) := '=' | '/=' | '-=' | '+=' | '*=' | '%=' | '~=' | '>>=' | '<<='
operator:(1) := '||'
operator:(2) := '&&'
operator:(3) := '<' | '>' | '<=' | '>=' | '!=' | '==' | '!=' | 'of' | 'is' | 'in'
operator:(4) := '...' | '..'
operator:(5) := '<<' | '>>'
operator:(6) := '|' | '^' | '&'
operator:(7) := '+' | '-' | '~'
operator:(8) := '*' | '/' | '%'
operator:(9) := '^^'
\end{code}

** operand

There are four level of operands, plus a recursive following operator syntax (operand_follow).

\begin{code}
operand:(0) := (unary_op)? operand:(1) ('?')?
unary_op := '-' | '&' | '*' | '!'


operand:(1) :=   block
               | if_expr
               | while_expr
               | assert_expr
               | break_expr
               | dowhile_expr
               | for_expr
               | match_expr
               | var_decl
               | return_expr
               | function_type_expr
               | delegate_type_expr
               | loop_expr
               | throw_expr
               | version_expr
               | pragma_expr
               | with_expr
               | atomic_expr
               | operand:(2) (operand_follow)?


operand:(2) := operand:(3) ('::' operand:(2) (template_call)?)?

operand:(3) :=   cast_expr
                | template_checker
                | array_literal
                | tuple_literal
                | lambda_literal
                | intrinsic
                | literal
                | decorated_expression
                | Identifier
\end{code}

Operand follow is recursive and refer to the operators written after the operand but not being binary operators (e.g. call operator '()', index operator '[]', etc.).

\begin{code}
operand_follow :=   '(' call_list ')' (operand_follow)?
                  | ('[' | ':[') call_list ']' (operand_follow)?
                  | ('.' | ':.') operand:(3) (template_call)? (operand_follow)?
                  | macro_call (operand_follow)?

call_list := ((expression:(0) (',' expression:(0))*)?
macro_call :=    '#{' [.]* '}'
               | '#[' [.]* ']'
               | '#(' [.]* ')'
\end{code}

** block

The if needClosingExpr mean that the ';' token is mandatory iif the read expression needs a closing. For example if expression, while loop and such elements do not need a closing token, when var declaration needs one.

\begin{code}
block := '{' (n=expression:(0) (if needClosingExpr (n) ';') | ';')* (expression:(0))? '}' scope_guard
scope_guard :=   ('success' | 'failure' | 'exit') block
               | catch_guard
\end{code}


** if expression

\begin{code}
if_expr := 'if' expression:(0) if_body ('else' expression:(0))?
if_body :=    block
           |  expression:(0) (';')?
\end{code}


** while expression

\begin{code}
while_expr := 'while' expression:(0) while_body
while_body :=    block
              |  expression:(0) (';')?
\end{code}

** assert expression

\begin{code}
assert_expr := 'assert' '(' expression:(0) (',' expression:(0))? ')'
\end{code}

** break expression

\begin{code}
break_expr := 'break' ( expression:(0) | ';' )
\end{code}

** dowhile expression

\begin{code}
do_while := 'do' expression:(0) 'while' expression:(0)
\end{code}

** for expression

\begin{code}
for_expression := 'for' ('(' for_loop_decl ')' | for_loop_decl) for_loop_body
for_loop_decl := single_var_decl_no_value (',' single_var_decl_no_value)* 'in' expression:(0)

for_loop_body :=   block
                 | expression:(0) (';')?
\end{code}


** match expression

\begin{code}
match_expr := 'match' expression:(0) '{' (inner_matcher_expr '=>' expression:(10))+ '}'

inner_matcher_expr :=   single_var_decl_match
                      | calling_match
                      | par_match
                      | cro_match
                      | '_'
                      | expression:(0)

single_var_decl_match :=  (Decorator)* (Identifier | '_') ':' ('_' | expression:(10)) ('=' inner_matcher_expr)?

calling_match := (Identifier | '_') ('::' Identifier)* (template_call)?
                                    (('(' inner_matcher_expr ')') | ('->' inner_matcher_expr))

par_match := '(' inner_matcher_expr (',' inner_matcher_expr)*)? ')'
cro_match := '[' inner_matcher_expr (',' inner_matcher_expr)*)? ']'
\end{code}

** variable declaration

\begin{code}
var_decl :=    'let' single_var_decl (',' single_var_decl)*
            |  'let' destruct_decl

single_var_decl_no_value := (Decorator*) (Identifier | '_') (':' expression:(10))?
single_var_decl := single_var_decl_no_value ('=' expression:(0))?

destruct_decl := '(' single_var_decl_no_value (',' single_var_decl_no_value)* ')' '=' expression:(0)

Decorator := 'dmut' | 'ref' | 'mut' | 'lazy' | 'cte' | 'pure' | 'const'
\end{code}

** return expression

\begin{code}
return_expr := 'return' (expression:(0) | ';')
\end{code}

** function and delegate types expression

\begin{code}
function_type_expr := 'fn' function_type_prototype ('->' expression:(10))?
delegate_type_expr := 'dg' function_type_prototype ('->' expression:(10))?

function_type_prototype := '(' (expression:(10) (',' expression:(10))*)? ')'
\end{code}

** loop expression

\begin{code}
loop_expr := 'loop' loop_body
loop_body :=   block
             | expression:(0) (';')?
\end{code}

** throw expression

\begin{code}
throw_expr := 'throw' expression:(0)
\end{code}

** version expression

\begin{code}
version_expr := '__version' Identifier expression:(0) ('else' operand:(1))?
\end{code}

** pragma expression

\begin{code}
pragma_expression := '__pragma' '!' Identifier '(' expression:(0) ')'
\end{code}

** with expression

\begin{code}
with_expression := 'with' single_var_decl (',' single_var_decl)* with_body
with_body :=   block
             | expression:(0) (';')?
\end{code}

** atomic expression

\begin{code}
atomic_expr := 'atomic' (expression:(0))? atomic_body
atomic_body :=   block
               | expression:(0) (';')?
\end{code}

** cast expression

\begin{code}
cast_expression := 'cast' '!' (('{' expression:(0) '}') | operand:(3)) '(' expression:(0) ')'
\end{code}

** template checker

\begin{code}
template_checker := 'is' template_call template_param_list
template_call := '!' (('{'' call_list  '}') | operand:(3))
\end{code}

** array and tuple literal

\begin{code}
array_literal := '[' call_list ']'
tuple_literal :=   '(' call_list ')'
                 | '(' expression:(0) ',' ')'
\end{code}

** Lambda literal

\begin{code}
lambda_literal := '|' param_list '|' ('->' expression:(10)? ('=>')? lambda_body
lambda_body :=   block
               | expression:(0) ';'
\end{code}

** intrinsic and decorated expression

\begin{code}
intrinsic := Intrinsic (expression:(10) | '(' expression:(0) ')')
decorated_expression := Decorator (expression:(10) | '(' expression:(0) ')')

Intrinsic := 'copy' | 'expand' | 'typeof' | 'sizeof' | 'alias' | 'dcopy'
\end{code}

** literal

\begin{code}
literal :=   Numeric
           | Float
           | Char
           | String
           | 'true' | 'false' | 'null' | '$'

NumericNoSuffix := [0-9] ([0-9] | '_')*
Numeric := NumericNoSuffix IntSuffix?
           | '0x' ([0-9a-eA-E] | '_')* IntSuffix?
           | "0o" ([0-7] | '_')* IntSuffix?

IntSuffix := 'u8' | 'u16' | 'u32' | 'u64' | 'us' | 'i8' | 'i16' | 'i32' | 'i64' | "is"

Float := NumericNoSuffix '.' (NumericNoSuffix)? FloatSuffix?
         | '.' NumericNoSuffix FloatSuffix?

FloatSuffix := 'f32' | 'f64'

Char := ''' [.]* ''' ('c8' | 'c32')?
String := '"' [.]* '"' ('s8' | 's32')?
\end{code}
