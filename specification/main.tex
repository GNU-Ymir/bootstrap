% Created 2023-08-26 sam. 11:05
% Intended LaTeX compiler: pdflatex
\documentclass[twoside,a4paper,11pt]{book}

\input{special_header}

\author{Emile Cadorel}
\date{\today}
\title{Ymir language specification 1.0}

\hypersetup{
  pdfauthor={Emile Cadorel},
  pdftitle={Ymir language specification 1.0},
  pdflang={English}}


\begin{document}
\setlength{\aweboxleftmargin}{0.05\linewidth}
\setlength{\aweboxcontentwidth}{0.93\linewidth}

%% \usepackage{utf8}
%% \setcode{utf8}

\maketitle
\dominitoc
\dominilof
\dominilot

\chapter*{Ymir releases}

Language specification of the Ymir language. This documentation is about the language specification, but is not a tutorial for the language.


The first stable release of Ymir is version 1.0, designed to be built using the
cxx\_version (version 0.1 of the Ymir compiler written in C++). Supporting tools
(such as GYC, Gyllir), the standard library and the documentation are released
with the same version number as the language release. GYC includes two versions:
the backend GCC version (e.g. 11.3.0) and the Ymir language version (e.g. 1.0).
The backend version should not affect the behaviour, only the frontend version
(ymirc version) has an effect.

\begin{multicols*}{2}
  \tableofcontents
\end{multicols*}

\chapter{Native scalar types}

This chapter dives into the semantic rules governing native types and their
behaviors. It outlines various operations like casting, binary and unary
operations, indexing, and more that can be performed on these types. The focus
here is on scalar types, while compound types will be discussed in the following
chapter. A scalar type inherently holds just one value and doesn't rely on or
borrow from other values. Consequently, it cannot be mutable on its own.
However, it can be part of a compound mutable type or a mutable variable,
allowing for mutability in broader context.

\begin{multicols*}{2}
  \minitoc%
  \input{semantic/native_scalar_types}
\end{multicols*}



\chapter{Native compound types}
\label{chap:compound}

This chapter presents the semantic specification of native compound types and
their associated behaviour. It lists the casting, binary, unary, index\ldots
operators and other permitted operations on the types presented. This chapter
also discusses the mutability of compound types, as they often contain borrowed
values. Some \texttt{pragma} operations are applicable to compound types, but
they are not covered in this chapter; a specific chapter on \texttt{pragma}
operators is presented in the Chapter~\ref{chap:conditional_compilation}.

\begin{multicols*}{2}
  \minitoc%
  \input{semantic/native_compound_types}
\end{multicols*}



\chapter{Global constructions}%
\label{chap:global_construction}

This chapter introduces the different global declarations that can be made
within a source file. A source code file is organized as a list of global
declarations that are described directly without enclosing symbols. This chapter
presents the module structures, the import semantics and some other global
symbols that can be found at the first level of a source file's symbol
hierarchy. This chapter does not cover some global elements that have specific
behavior, such as custom types presented in Chapter~\ref{chap:custom_type},
macros presented in Chapter~\ref{chap:macros}, or pragmas and other conditional
compilation constructions presented in
Chapter~\ref{chap:conditional_compilation}.

\begin{multicols*}{2}
  \minitoc%
  \input{semantic/global_constructions}
\end{multicols*}




\chapter{Variables and memory management}
\label{chap:variables}

A variable in Ymir, like in other programming languages, is a symbolic name that
represents a memory location where a value is stored. When the variable name is
used, the program accesses this memory location to retrieve or modify the value.
Depending on the type of variable that is written out, the memory access can be
made differently (e.g., reference variables) or with varying permissions (e.g.,
writing permissions). This chapter presents the different types of variables
that can be defined in Ymir, their memory representation, and their permissions.
All the concepts presented in this chapter are crucial for understanding how
memory is managed in Ymir.

\begin{multicols*}{2}
  \minitoc%
  \input{semantic/variables}
\end{multicols*}

\chapter{Control flows}%
\label{chap:control_flows}

Control flows are local constructs that use values to define the behavior of the
body of a function. There are several different types of control flows, ranging
from simple condition branching to collection iteration through pattern-matching
deconstruction. This chapter introduces the semantic specification of these
constructs. All constructs presented in this chapter are always placed within a
function body.

\begin{multicols*}{2}
  \minitoc%
  \input{semantic/control_flow}
\end{multicols*}

\chapter{Custom types}%
\label{chap:custom_types}

\begin{multicols*}{2}
  \minitoc%
  \input{semantic/custom_type}
\end{multicols*}

\chapter{Functional}
\label{chap:functional}

\begin{multicols*}{2}
  \minitoc%
  \input{semantic/functional}
\end{multicols*}

\chapter{Macros}
\label{chap:macros}

\begin{multicols*}{2}
  \minitoc%
  %\input{semantic/macros}
\end{multicols*}


\chapter{Conditional compilation}
\label{chap:conditional_compilation}

\begin{multicols*}{2}
  \minitoc%
  %\input{semantic/conditional_compilation}
\end{multicols*}

\end{document}
