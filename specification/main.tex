% Created 2023-08-26 sam. 11:05
% Intended LaTeX compiler: pdflatex
\documentclass[a4paper,11pt]{book}

\input{special_header}

\author{Emile Cadorel}
\date{\today}
\title{Ymir language specification 1.0}

\hypersetup{
  pdfauthor={Emile Cadorel},
  pdftitle={Ymir language specification 1.0},
  pdflang={English}}


\begin{document}

%% \usepackage{utf8}
%% \setcode{utf8}

\maketitle
\dominitoc
\dominilof
\dominilot

\chapter*{Ymir releases}

Language specification of the Ymir language. This documentation is about the language specification, but is not a tutorial for the language.


The first stable release of Ymir is version 1.0, designed to be built using the cxx\_version (version 0.1 of the Ymir compiler written in C++). Supporting tools (such as GYC, Gyllir), the standard library and the documentation are released with the same version number as the language release. GYC includes two versions: the backend GCC version (e.g. 11.3.0) and the Ymir language version (e.g. 1.0). The backend version should not affect the behaviour, only the frontend version (ymirc version) has an effect.

\begin{multicols*}{2}
  \tableofcontents
\end{multicols*}


\chapter{Native scalar types}

This chapter presents the semantic specification of native types and their
associated behaviour. It lists the casting, binary, unary, index\ldots operators
and other permitted operations on the types presented. This chapter covers the
specification of scalar types. Compound types are covered in the next chapter.
By its nature, a scalar type contains only one value. This value is never
borrowed from another value. Therefore, a scalar type cannot be mutable by
itself, but it can be used within a compound mutable type or a mutable variable.

\begin{multicols*}{2}
  \minitoc%
  \input{semantic/native_scalar_types}
\end{multicols*}

\chapter{Native compound types}

This chapter presents the semantic specification of native compound types and
their associated behaviour. It lists the casting, binary, unary, index\ldots
operators and other permitted operations on the types presented. This chapter
also discusses the mutability of compound types, as they often contain borrowed
values. Some \texttt{pragma} operations are applicable to compound types, but
they are not covered in this chapter; a specific chapter on \texttt{pragma}
operators is presented in the Chapter~\ref{chap:conditional_compilation}.

\begin{multicols*}{2}
  \minitoc%
%% \end{multicols*}%
%% \begin{multicols*}{2}
  \input{semantic/native_compound_types}
\end{multicols*}

\chapter{Global constructions}%
\label{chap:global_construction}

This chapter presents the different global declarations that can be made inside
a source code file. A source code files is organized as a list of global
declaration, that are described directly without enclosing symbol. In this
chapter are presented the module structures, the importation semantic, and some
other global symbols that can be found at the first level of a source code file
organization. This chapter does not cover some global elements, that have
specific behavior such as custom types presented in
Chapter~\ref{chap:custom_type}, macros presented in Chapter~\ref{chap:macros},
or pragmas and other conditional compilation constructions presented in
Chapter~\ref{chap:conditional_compilation}.

\begin{multicols*}{2}
  \minitoc%
  \input{semantic/global_constructions}
\end{multicols*}

\chapter{Control flows}%
\label{chap:control_flows}

\begin{multicols*}{2}
  \minitoc%
\end{multicols*}%
\begin{multicols*}{2}
  \input{semantic/control_flow}
\end{multicols*}

\chapter{Custom types}%
\label{chap:custom_types}


\begin{multicols*}{2}
  \minitoc%
\end{multicols*}%
\begin{multicols*}{2}
  \input{semantic/custom_type}
\end{multicols*}

\end{document}
