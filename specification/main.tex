% Created 2023-08-26 sam. 11:05
% Intended LaTeX compiler: pdflatex
\documentclass[a4paper,11pt]{book}

\input{special_header}

\author{Emile Cadorel}
\date{\today}
\title{Ymir language specification 1.0}

\hypersetup{
  pdfauthor={Emile Cadorel},
  pdftitle={Ymir language specification 1.0},
  pdflang={English}}


\begin{document}
\setlength{\aweboxleftmargin}{0.05\linewidth}
\setlength{\aweboxcontentwidth}{0.93\linewidth}

%% \usepackage{utf8}
%% \setcode{utf8}

\maketitle
\dominitoc
\dominilof
\dominilot

\chapter*{Ymir releases}

Language specification of the Ymir language. This documentation is about the language specification, but is not a tutorial for the language.


The first stable release of Ymir is version 1.0, designed to be built using the cxx\_version (version 0.1 of the Ymir compiler written in C++). Supporting tools (such as GYC, Gyllir), the standard library and the documentation are released with the same version number as the language release. GYC includes two versions: the backend GCC version (e.g. 11.3.0) and the Ymir language version (e.g. 1.0). The backend version should not affect the behaviour, only the frontend version (ymirc version) has an effect.

\begin{multicols*}{2}
  \tableofcontents
\end{multicols*}


\chapter{Native scalar types}

This chapter presents the semantic specification of native types and their
associated behaviour. It lists the casting, binary, unary, index\ldots operators
and other permitted operations on the types presented. This chapter covers the
specification of scalar types. Compound types are covered in the next chapter.
By its nature, a scalar type contains only one value. This value is never
borrowed from another value. Therefore, a scalar type cannot be mutable by
itself, but it can be used within a compound mutable type or a mutable variable.

\begin{multicols*}{2}
  \minitoc%
  \input{semantic/native_scalar_types}
\end{multicols*}

\chapter{Native compound types}

This chapter presents the semantic specification of native compound types and
their associated behaviour. It lists the casting, binary, unary, index\ldots
operators and other permitted operations on the types presented. This chapter
also discusses the mutability of compound types, as they often contain borrowed
values. Some \texttt{pragma} operations are applicable to compound types, but
they are not covered in this chapter; a specific chapter on \texttt{pragma}
operators is presented in the Chapter~\ref{chap:conditional_compilation}.

\begin{multicols*}{2}
  \minitoc%
%% \end{multicols*}%
%% \begin{multicols*}{2}
  \input{semantic/native_compound_types}
\end{multicols*}

\chapter{Global constructions}%
\label{chap:global_construction}

This chapter introduces the different global declarations that can be made
within a source file. A source code file is organized as a list of global
declarations that are described directly without enclosing symbols. This chapter
presents the module structures, the import semantics and some other global
symbols that can be found at the first level of a source file's symbol
hierarchy. This chapter does not cover some global elements that have specific
behavior, such as custom types presented in Chapter~\ref{chap:custom_type},
macros presented in Chapter~\ref{chap:macros}, or pragmas and other conditional
compilation constructions presented in
Chapter~\ref{chap:conditional_compilation}.

\begin{multicols*}{2}
  \minitoc%
  \input{semantic/global_constructions}
\end{multicols*}

\chapter{Control flows}%
\label{chap:control_flows}

\begin{multicols*}{2}
  \minitoc%
  \input{semantic/control_flow}
\end{multicols*}

\chapter{Custom types}%
\label{chap:custom_type}

\begin{multicols*}{2}
  \minitoc%
  \input{semantic/custom_type}
\end{multicols*}

\chapter{Macros}
\label{chap:macros}

\begin{multicols*}{2}
  \minitoc%
  %\input{semantic/macros}
\end{multicols*}


\chapter{Conditional compilation}
\label{chap:conditional_compilation}

\begin{multicols*}{2}
  \minitoc%
  %\input{semantic/conditional_compilation}
\end{multicols*}

\end{document}
