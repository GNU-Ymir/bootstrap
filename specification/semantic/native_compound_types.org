* Preamble

Before presenting the specification of the different compound types, let's
define some useful element of language.

+ /Data borrowing/ -- A data borrowing value, is a value that points to data that is not automatically copied when the value is copied. The simplest example of a data borrowing is using a pointer type, where the value of the pointer gives information about a memory address containing data, such data pointed by the pointer is not copied when the pointer is. An illustration of this is presented in figure [[fig:data_borrowing]]

    #+HEADER: :file images/data_borrowing.pdf :imagemagick yes
    #+HEADER: :results output silent :headers '("\\usepackage{tikz}")
    #+HEADER: :fit yes :imoutoptions -geometry 400 :iminoptions -density 600
    #+BEGIN_src latex
\tikzstyle{every picture}+=[remember picture]
\tikzstyle{mProjectPP}=[circle,fill=yellow!70, minimum size=20pt,inner sep=0pt]
\tikzstyle{label}=[rectangle, fill=white, minimum size=40pt, inner sep=0pt]
\tikzstyle{Box}=[rectangle, fill=white, minimum size=40pt, inner sep=0pt]
\tikzstyle{Box2}=[rectangle, fill=white, minimum size=20pt, inner sep=0pt]
\definecolor{applegreen}{rgb}{0.55, 0.71, 0.0}
\definecolor{antiquebrass}{rgb}{0.8, 0.58, 0.46}

\begin{tikzpicture}
  % ================ Axis ========================
  \draw (0, 0) -- coordinate (LEFT) (0, 0);
  \draw[->](0, 10) -- coordinate (YAx) (0, 0);
  \draw[->](7.2, 10) -- coordinate (YAx) (7.2, 0);
  \draw[Box] (3.5, 10.7) -- (3.5, 10.7) node[anchor=center]{\textbf{STACK}};

  \filldraw (0, 6.5) circle (1pt) node[align=center, left] {+0};
  \filldraw (0, 5.5) circle (1pt) node[align=center, left] {+8};
  \filldraw (0, 4.5) circle (1pt) node[align=center, left] {+16};
  \filldraw (0, 3.5) circle (1pt) node[align=center, left] {+24};
  \filldraw (0, 2.5) circle (1pt) node[align=center, left] {+32};

  %% % ================ Foo ========================
  \fill[black!10] (0.2, 10) rectangle (7, 8);
  \draw[Box] (3.5, 7.6) -- (3.5, 7.6) node[anchor=center]{\textbf{.}};
  \draw[Box] (3.5, 7.4) -- (3.5, 7.4) node[anchor=center]{\textbf{.}};
  \draw[Box] (3.5, 7.2) -- (3.5, 7.2) node[anchor=center]{\textbf{.}};

  \draw[line width=1pt] (0.18, 6.9) rectangle (7.02, 2.48);
  \fill[blue!10] (0.2, 6.5) rectangle (7, 2.5);
  \draw[Box] (3.5, 6.7) -- (3.5, 6.7) node[anchor=center]{\emph{foo}};

  \draw[Box] (0.5, 5.5) -- (0.5, 5.5) node[anchor=center]{\textbf{\textit{x}}};
  \draw[line width=1pt] (0.3, 6.4) rectangle (6.8, 4.6);
  \draw[line width=1pt] (0.7, 5.5) rectangle (6.8, 5.5);

  \draw[Box] (3.5, 6) -- (3.5, 6) node[anchor=center]{\emph{len~=}~$3$};
  \draw[Box] (3.5, 5) -- (3.5, 5) node[anchor=center]{\emph{ptr~=}~0xfa45b987};

  \draw[Box] (0.5, 3.5) -- (0.5, 3.5) node[anchor=center]{\textbf{\textit{y}}};
  \draw[line width=1pt] (0.3, 4.4) rectangle (6.8, 2.6);
  \draw[line width=1pt] (0.7, 3.5) rectangle (6.8, 3.5);

  \draw[Box] (3.5, 4) -- (3.5, 4) node[anchor=center]{\emph{len~=}~$3$};
  \draw[Box] (3.5, 3) -- (3.5, 3) node[anchor=center]{\emph{ptr~=}~0xfa45b987};


  %% % ================ Heap ========================

  \draw[->](10, 10) -- coordinate (YAx) (10, 0);
  \draw[->](17.2, 10) -- coordinate (YAx) (17.2, 0);
  \filldraw (17.2, 7.5) circle (1pt) node[align=center, right] {0xfa45b987};

  % ================ Data ========================
  \draw[Box] (13.5, 10.7) -- (13.5, 10.7) node[anchor=center]{\textbf{HEAP}};
  \fill[black!10] (10.2, 10) rectangle (17, 8);
  \fill[applegreen!20] (10.2, 7.9) rectangle (17, 5);
  \draw[line width=1pt] (10.4, 7) rectangle (16.8, 7);
  \draw[line width=1pt] (10.4, 6) rectangle (16.8, 6);

  \draw[Box] (13.5, 7.5)  (13.8, 7.5) node[anchor=center]{$1$};
  \draw[Box] (13.5, 6.5)  (13.8, 6.5) node[anchor=center]{$2$};
  \draw[Box] (13.5, 5.5)  (13.8, 5.5) node[anchor=center]{$3$};

  \draw[thick,->,shorten >=1pt] (7.3, 5) to [out=0,in=180] node[below left, yshift=3mm] {} (9.9, 7.5);

  \draw[thick,->,shorten >=1pt] (7.3, 3) to [out=0,in=180] node[below left, yshift=3mm] {} (9.9, 7.5);

\end{tikzpicture}

#+END_src

    #+CAPTION: Example of data borrowing
    #+NAME: fig:data_borrowing
    #+attr_latex: :width 200px
    [[file:../images/data_borrowing.pdf]]

    In the above example, both variable ~x~ and ~y~ borrow the data located in
    the heap at the address ~0xfa45b987~. By copying the value of the variable ~y~
    into another variable, no copy of the borrowed value is made (located on the heap) but only the value directly inside ~y~ would be copied, in that case located on the stack. The borrowed data can be
    located on the stack or an the heap, and the same applies for borrowing data.
    Such memory is called borrowed as it can live longer that the value pointing to it, and only borrows its value for reading or writing.

    In the case of borrowing data, mutability is very important as multiple variable
    refers to the same segment of memory, and thus side effect could occurs
    inpredictively. Memory mutability is here to help managing such behavior, and
    ensure that only few variables have a mutable access to values, and most
    importantly that no mutable memory borrowing is created unintentionally.

- /Data movement/ -- A data movement is a copy of a value from a segment of memory
  to another segment. This can be performed by affectation, memory copy (or deep
  copy), function call, etc. Data movements are made to be always explicit, such
  that no unwanted copy (slowing the program) are made.

- /lvalue/ -- A lvalue is the left operand in a /data movement/ operation. In
  other word it is an expression refering to a segment of memory that will be
  modified due to a data movement. A lvalue can from many type of expression
  (e.g. simple variable, function parameter, index operation, etc.)

- /rvalue/ -- A rvalue is the right operand involved in a /data movement/
  operation. A rvalue can be aliased (using the keyword ~alias~), referenced
  (keyword ~ref~), copied with (~copy~, ~dcopy~) or implicit. Implicit meaning
  that data movement does not borrow mutable data, and therefore is allowed
  implicitly. In case of implicit data movement, no borrowed data is copied.

With the help of keywords (~alias~, ~ref~, ~copy~ and ~dcopy~) data movement and
mutability should be always easy to follow, and should help the compiler to
ensure that no unwanted side effects are occuring.

* Pointers

Pointers are values storing an address of memory. Pointer types are described
using the ~*~ token followed by a type (e.g. ~*i32~ describing a pointer to a
~i32~ value). In the beta version of Ymir (compiler written in c++) the operator
~&~ was used, it was changed as it was also used to refer to object instances
that are in a way pointers but have very different behavior.

** Literals

The ~null~ keywords is used to describe a pointer that points to nowhere. This
is the only literal that can be used as pointer value.

** Construction

To construct a pointer the unary operator ~&~ can be used on a lvalue
(a variable for example). This operator retreive the address of the value
referenced by the operand, (i.e. ~&a~ retreives the address of the segment of
memory referenced by the variable ~a~). By abuse of speech and simplification,
we can say that we retreive the address of the variable ~a~.

\begin{code}
let a = 12;
let b : *i32 = &a;
\end{code}

** Mutability

Because pointers borrow data from another value (value pointed by the pointer),
their mutability is important. A pointer has two level of mutability :
- ~mut *T~, in that case the pointer can be changed but not the value inside it.
- ~mut *(mut T)~, in that case both the value pointed by the pointer and the pointer itself are mutable.

A mutable pointer (level 1) means that if the pointer is contained inside
another compound type or in a variable its value can be changed. When the value inside the pointer is created mutability checking is made at compilation time.

\begin{code}
let dmut a : *i32 = null;

let b = 12;
a = &b; // not allowed  b is not mutable
*a = 24; // but it would be modified by this operation


let mut c = 11;
a = &c; // allowed c is mutable
*a = 24; // modify the value of c is allowed
\end{code}

The keyword ~alias~ has to be used on the right operand if data borrowing is
transfered to the left operand. In practice, this means that if the left operand
mutability is of second level (i.e. ~mut *(mut T)~), the keyword ~alias~ has to
be used, and right operand must also be of second level mutability. The keyword
can be omitted if the aliasing is obvious (i.e. by function return, or
construction such as the unary operator ~&~).

** Properties

Properties on pointer type can be accessed using the operator ~::~ on a type expression. The properties are the following :

|----------+------------------------------------------------------+-------------|
| name     | value                                                | type        |
|----------+------------------------------------------------------+-------------|
|----------+------------------------------------------------------+-------------|
| ~init~   | The initial value ~null~                             | ~typeof(x)~ |
|----------+------------------------------------------------------+-------------|
| ~inner~  | The inner type contained in the pointer type         | None        |
|          | This property returns a type expression, not a value |             |
|----------+------------------------------------------------------+-------------|
| ~typeid~ | A string encoding the name of the type               | ~[c8]~      |
| ~sizeof~ | The size in bytes of the type                        | ~usize~     |
|----------+------------------------------------------------------+-------------|



** Casting

A pointer type can be casted using the cast operator ~cast!T(V)~ into a
~*(void)~. A ~*void~ pointer type can be casted into any pointer type. Pointer
is a really low level type with just few guarantees, but some operations relies
on that possibility to perform generic operations (common traits, ~Packable~ for
example).

This is the only allowed casts on pointer types.

** Unary operators

The unary operator ~*~ is used on a pointer value to dereference it and access
the value pointed by the pointer. This operation is unsafe, and might throw a
~SegFault~ exception. If the operation does not throw anything it does not
necessarily mean that the pointer was correctly created.

** Binary operators

Binary operators are divided into 3 groups :

- Math :

  Pointer arithmetic is allowed using a ~usize~ as right operand. Unlike in C language, the arithmetic does not depend on the size of the data pointed by the pointer. The operation adds a number of bytes to the address, meaning that the addition operation using a left operand whose value is ~0xabc0~ and a right operand ~8us~ will always have the value ~0xabc8~ no matter the type of content pointed by the pointer. The behavior is not the same with index operator. The type of the result of the operation always takes the same type as the left operand.

    #+ATTR_LATEX: :align |c|ll|
  |----------+-------------+------------|
  | Operator | Operation   | Example    |
  |----------+-------------+------------|
  | ~+~      | Addition    | ~&a + 2us~ |
  | ~-~      | Subtraction | ~&a - 1us~ |
  |----------+-------------+------------|

- Logical :

  Comparison operators always return a value of type ~bool~ and are only usable when the two operands are of the same pointer type (e.g. *i32 with *i32).

    #+ATTR_LATEX: :align |c|lll|
  |----------+---------------+-------------+--------------------------|
  | Operator | Operation     | Commutative | Example                  |
  |----------+---------------+-------------+--------------------------|
  |----------+---------------+-------------+--------------------------|
  | ~is~     | Equality test | Yes         | ~&a is &a == true~       |
  | ~!is~    | Equality test | Yes         | ~&a !is &a == false~     |
  | ~<~      | Lower than    | No          | ~&a < &a + 1us == false~ |
  | ~>~      | Greated than  | No          | ~&a > &a - 1us == false~ |
  |----------+---------------+-------------+--------------------------|

  One can note that the equality operator for pointers are not ~==~ and ~!=~, and that those operators are undefined for pointer operands. The reason behind that is to keep consistency with the equality operators of class instances, where the ~is~ and ~!is~ operators check the address equality and ~==~ and ~!=~ are used for the value equality.


- Affectation :

  The affectation operator are usable when the two operands have strictly the same pointer type.The mutability level of the left operand must be lower or equal to the mutability level of the right operand.
  Affectation operators can be mixed with math operators (e.g. ~+=~, ~-=~). In that case the operation is rewritten into ~x = x + y~ and ~y~ must be a value of type ~usize~.

  \begin{code}
  let mut a = 11;
  let dmut b = &a;

  let mut c = &a;
  b = c; // not allowed it will discard the const property
  c = b; // No problem the mutability level of c is lower than the one of b

  c += 1us;

  let dmut d = &a;
  b = alias d; // alias is needed, data is borrowed
  \end{code}

** Index operator

The index operator can be used on a pointer left operand using a int value as an index right operand. The result of the operation is the dereferencement of the pointer value with the offset of the value used as index. Unlike pointer arithmetic using the ~+~ and ~-~ operator, the index operator takes into account the size of the data pointed by the pointer, meaning that the index operation ~(&a)[7]~ is strictly transformed into ~*(&a + (7us * sizeof (typeof(&a)::inner)))~.

The result value mutability depends on the level of mutability of the pointer operand. If the pointer operand mutability level is 2, then the result can be used as a lvalue.

\begin{code}
let mut a = 12;
let dmut b = &a;

b [0] = 89;
assert (a == 89);
\end{code}

* Tuples

Tuple are anonymus structure storing a set of data of different types. They are described as a list of types enclosed within parentheses (e.g. ~(i32, f32, c8)~). A tuple can have only one inner type, in that case the token ~,~ is added after the definition of the inner type (e.g. ~(i32,)~).


** Literals

Tuple literals are described as a list of values enclosed by parentheses tokens, for example ~(1, 'r', false)~ is a tuple literal whose types is ~(i32, c32, bool)~. Tuple containing only one value must contain the token ~,~ after the declaration of the value, in order to distinguish them from priority operation enclosed within parentheses.

\begin{code}
let a = (1, 'r', false);
let b : (i32,) = (23,); // tuple value
let c : i32 = (23); // int value
\end{code}

** Mutability <<sec:tuple_mutability>>

The mutability of tuple values cannot be described as a mutability level as it could be for other compound types. In the case of tuple, the mutability is defined as a tree, where each node of the tree depend on the mutability of its parent. For example, the mutability of the following tuple type ~mut (mut i32, f32, dmut *c8)~ is presented in the figure [[fig:tuple_mutability]].


#+HEADER: :file images/tuple_mutability.pdf :imagemagick yes
#+HEADER: :results output silent :headers '("\\usepackage{tikz}")
#+HEADER: :fit yes :imoutoptions -geometry 400 :iminoptions -density 600
#+BEGIN_src latex
\begin{tikzpicture}

  \draw[-, black!30!green] (0,0) -- (-1,-1);
  \draw[-, red!50] (0,0) -- (0,-1);
  \draw[-, black!30!green] (0,0) -- (1,-1);
  \draw[-, black!30!green] (1,-1) -- (1,-2);

  \filldraw (0, 0.2) node[align=center, above] {\tiny{mut}};
  \filldraw (0, 0) circle (1pt) node[align=center, above] {\tiny{(i32, f32, *c8)}};
  \filldraw (-1,-1) circle (1pt) node[align=center, below]{\tiny{mut}};
  \filldraw (-1,-1.2) node[align=center, below]{\tiny{i32}};
  \filldraw (0,-1) circle (1pt) node[align=center, below]{\tiny{const}};
  \filldraw (0,-1.2) node[align=center, below]{\tiny{f32}};
  \filldraw (1,-1) circle (1pt) node[align=center, right]{\tiny{mut *c8}};
  \filldraw (1,-2) circle (1pt) node[align=center, right]{\tiny{mut c8}};


\end{tikzpicture}
#+END_src

#+CAPTION: Example of the process
#+NAME: fig:tuple_mutability
#+attr_latex: :width 200px
[[file:../images/tuple_mutability.pdf]]

Mutability level of inner types is important only when they borrow data. In the
previous example presented in figure [[fig:tuple_mutability]], only the mutability
of the inner type ~*c8~ is important during data movement. In other word a value
of type ~mut (i32, f32, dmut *c8)~ can be passed to it without any problem. As
for any borrowing type, the keyword ~alias~ has to be used when data is
borrowed.

\begin{code}
let mut x = 't'c8;
let mut a : mut (mut i32, f32, dmut *c8) = (1, 12.0f, &x);
let mut b : mut (i32, f32, dmut *c8) = (1, 7.0f, null);

a = alias b; // no problem
b = alias a; // no problem either

let c : (i32, f32, *c8) = (1, 7.0f, &x);
a = alias c; // not allowed, it would dicard constant property of the third field
\end{code}

Tuple types having mutable values that are not borrowing data are considered non
borrowing types, and therefore don't need ~alias~ during data movement. In
practice all the data of this kind of tuples are copied during data movement.

** Properties

Properties on pointer type can be accessed using the operator ~::~ on a type expression. The properties are the following :

|----------+---------------------------------------------------------+-------------|
| name     | value                                                   | type        |
|----------+---------------------------------------------------------+-------------|
|----------+---------------------------------------------------------+-------------|
| ~arity~  | The number of inner elements of the tuple type          | ~usize~     |
|----------+---------------------------------------------------------+-------------|
| ~init~   | The initial value of the tuple, where every inner field | ~typeof(x)~ |
|          | are set to ~T::init~                                    |             |
|          | -- example: ~(i32, f32)::init == (i32::init, f32::init)~ |             |
|----------+---------------------------------------------------------+-------------|
| ~typeid~ | A string encoding the name of the type                  | ~[c8]~      |
| ~sizeof~ | The size in bytes of the type                           | ~usize~     |
|----------+---------------------------------------------------------+-------------|

\noindent Inner types are not accessible through the operator ~::~, but are accessible
using ~__pragma~.
# (cf. Chapter [[chap:pragmas]]).

** Binary operators

Binary operators are divided into 3 groups :

- Access:

  The operator ~.~ is used to access to a given field of the tuple. The right
  operand must be of an int type and be within the range of ~0~ and the arity of
  the tuple being accessed. The result of the operation takes the type of the
  field at the index described by the right operand, and so is the value. The
  first field index is ~0~.

  \begin{code}
  let mut a : (mut i32, f32) = (8, 8.f);

  a._0 = 7; // allowed first field is mutable
  a._1 = 1.f; // not allowed, second field is not mutable

  let c = a.(12 - 11); // accessing the field at index 1
  \end{code}

- Comparison:

  The comparison operators ~==~ and ~!=~ are defined on tuples when every inner
  types are comparable. It compares all the fields of two tuples, and checks
  wether all the inner values are equals for ~==~, or at least one inner value
  is different between the two operands for the operator ~!=~.

  There is no order relation between tuples, even if they have the same type as
  in general such comparison would be senseless.

- Affectation:

  Affectation operator creates a data movement from the right operand to the
  left operand. Mutability has to be respected when data is borrowed. Data
  mutability on tuples was already presented in Section [[sec:tuple_mutability]].

** Dollar operator

The dollar operator is usable within an Access binary operation in the right operand expression. The dollar value takes the value of the arity of the tuple, and its type is ~usize~. Its value is known at compilation time.

\begin{code}
let a = (1, 9.0f, 'r');

let b = a.($ - 1us); // access the last value, i.e. 'r'
\end{code}

** Tuple expansion

Tuples have a specific operator named ~expand~ that transform them into a list
of parameters. The expansion of tuple is useful to create other tuples, or
passing the data of the tuple as function parameters.

\begin{code}
def foo (a : i32, b : f32) {}

let a = (1, 5.f);
let b : (i32, f32, c32) = (expand a, 't'); // transform a into a list of values

foo (expand a); // transform a into a list of parameters
\end{code}

Such operation is made at compilation time, and is simply a rewritte that is
less verbose. Indeed in the previous example, the line ~foo (expand a)~, is
rewritten into ~foo (a.0, a.1)~. The mutability level of the expanded values is
always ~1~ meaning tuple expansion can never borrow mutable data.

** Tuple deconstruction

Tuple can be used to declare multiple variable at once, using the same ~let~
declaration. We call this declarations a tuple deconstruction, as it splits the
values of the tuple into a list of variables.

\begin{code}
let (mut a, b, c) = (1, 't', 12.f); // a is mutable, but not b nor c

assert (a == 1 && b == 't' && c == 12.f);
\end{code}

A variadic variable can be used as the last variable declaration in such
deconstruction with the token ~...~. In that case it's type is always a tuple
that takes all the values in the tuple that are left, and are not associated
with other variables.

\begin{code}
let (a, b...) = (1, 2, 3);

assert (a == 1);
assert (b == (2, 3));
\end{code}

The mutability level of variables declared using tuple deconstruction can never
be higher than ~1~. Maybe this limitation can be removed. The problem being that
explicit aliasing would be done to every field of the tuple (i.e. ~let (dmut
a, b) = alias t;~), but maybe in this case it is acceptable.


** Tuple iteration

Tuples are iterable types, thus they can be used as the iterable value of a ~for~
loop. In practice because such iteration would create iterator variables with
different types, the iteration is unrolled at compilation time.

\begin{code}
let a = (1, 't', 89.0f);
for i in a {
    println (i);
}

// would be rewritten into
println (a._0);
println (a._1);
println (a._2);
\end{code}

Two variables are usable as iterators, the first one being the index of the
iteration, and the second one being the value inside the tuple. If only one
variable is defined, only the value of the tuple fields is contained in the
iterator. Iterators are always immutable and never used as references, however
this limitation can be easily couterfeited, using the index iterator to access
the tuple.

\begin{code}
let dmut a = (1, 2, 3);
for i, _ in a {
    a.(i) = 9;
}

assert (a == (9, 9, 9));
\end{code}

More information about ~for~ loops is presented in Chapter  [[chap:control_flow]].

* Ranges

Range is a compound type composed of four elements describing a range of values.
The four elements are the following: ~fst~ the first value of the range (e.g.
~0~), ~scd~ the final value of the range (e.g. ~10~), ~step~ the step of the
range (e.g. ~2~), and ~contains~ of type bool specifiying wether the final value
~scd~ is included in the range or not. There are only three kind of types that
can be describing the inner components of a range: integer, floating point and
character types. Range type is defined using the inner type followed by the
token ~..~ (e.g. ~i32..~ describes a range of ~i32~ values).

Range are useful for iteration, or accessing a subset of values (for example a
subset of a slice).

** Literals

Range literals are described using the token ~..~ or the token ~...~. The token
~..~ is used to define a range whose final value is not included in the range,
when the ~...~ token defined a range whose final value is included. If different
tokens are used to describe the literal, the type is the same, and the token
~..~ is always the only token used to describe a range type.

\begin{code}
let a : i32.. = 0 .. 2;
let b : i32.. = 0 ... 2;

assert (a.fst == b.fst && a.scd == b.scd && a.step == b.step);
assert (!a.contains && b.contains);
\end{code}

Range values can be decreasing, in that case the step is negative. One can note
that for ranges of unsigned integers and character values, a negative value for
the step is in theory impossible to have. However there is some cheating
happening here using the limitation of overflowing of the types to create a
value that when added to ~fst~ equals to ~fst - abs (step)~ (in practice this is
exactly the same as adding a negative value at the binary level, but it is not
really the valid high level representation). For that reason one can consider
that step is always a signed version of the type even if the field type is
considered to be the same as the type of the inner values (~fst~ and ~scd~) and
thus that one bit of its encoding is always used for the sign.

** Mutability

As one might expect range values don't borrow any data, and every field
contained in the value is copied during data movement, thus there is no need to
worry about mutability making the type not aliasable. A mutable range can modify
its inner fields. Even if the range type is a compound type, it behave exactly
has a scalar type as it can never contain any borrowed data.


** Properties

Properties on range type can be accessed using the operator ~::~ on a type expression. The properties are the following :

|----------+-----------------------------------------------------------+-------------|
| name     | value                                                     | type        |
|----------+-----------------------------------------------------------+-------------|
|----------+-----------------------------------------------------------+-------------|
| ~init~   | The initial value ranging from ~T::init~ to ~T::init~     | ~typeof(x)~ |
|          | with a step of ~T::init~ and with contains set to ~false~ |             |
|          | where ~T~ is the inner type (e.g. ~i32~ for ~i32..~)      |             |
|----------+-----------------------------------------------------------+-------------|
| ~inner~  | The inner type contained in the range type                | None        |
|          | This property returns a type expression, not a value      |             |
|----------+-----------------------------------------------------------+-------------|
| ~typeid~ | A string encoding the name of the type                    | ~[c8]~      |
| ~sizeof~ | The size in bytes of the type                             | ~usize~     |
|----------+-----------------------------------------------------------+-------------|

** Binary operators

Binary operators are divided into 4 groups :

- Access:

  The operator ~.~ is used to access to the field of the range type. The right
  operand being the name of the field to access. These fields are described in
  the following table.

  |------------+---------------------------------------------+---------------------|
  | name       | value                                       | type                |
  |------------+---------------------------------------------+---------------------|
  |------------+---------------------------------------------+---------------------|
  | ~fst~      | The first value of the range                | ~typeof (x)::inner~ |
  | ~scd~      | The second value of the range               | ~typeof (x)::inner~ |
  | ~step~     | The step of the range                       | ~typeof (x)::inner~ |
  | ~contains~ | The field describing wether or              | ~bool~              |
  |            | not the scd value is contained in the range |                     |
  |------------+---------------------------------------------+---------------------|

  Accessed fields are mutable if and only if the range is mutable.

- Contains :

  The operator ~in~ and ~!in~ are used to check wether a value is contained
  inside a range value. In that case the type of the left operand must be the
  same as the inner type of the right operand, and the type of the right operand
  must be a range type.

  \begin{code}
  let a = 0 .. 7, b = 0 ... 7;

  assert (6 in a);
  assert (7 !in a && 7 in b);
  \end{code}

- Comparison :

  Range are comparable using the operators ~==~ and ~!=~, checking the equality
  (or inequality) of every field of the range. The left and right operand must
  have exactly the same type.

- Affectation :

  A range value can be a lvalue if and only if it is mutable.

  \begin{code}
  let mut a = 0 .. 7;

  a = 7 .. 1;
  \end{code}

** Range iteration

Ranges are iterable types, therefore they can be used as the iterable value of a
~for~ loop. Only one imutable variable can be declared when iterating over a
range value. This iterator variable takes the value of the ~fst~ field of the
range, and increment by the ~step~ field until it reaches the ~scd~ field. If
the range is a containing range (i.e. ~contains~ field is true), then the ~scd~
field is included in the iteration.

\begin{code}
for i in 0 .. 7 {
    print (i, ' '); // 0 1 2 3 4 5 6
}

for i in 0 ... 7 {
    print (i, ' '); // 0 1 2 3 4 5 6 7
}

for i in 7 .. 0 {
    print (i, ' '); // 7 6 5 4 3 2 1
}
\end{code}

More information about ~for~ loops is presented in Chapter  [[chap:control_flow]].

* Arrays

An array is a compound type containing a list of values of the same type stored
in continuous memory segment and whose size is known at compilation time. An
array type is described using the following syntax ~[T ; N]~ where ~T~ is the
inner type of the array, and ~N~ is an integer value describing the number of
elements contained in the array.

** Literals

Array literals are a list of values enclosed within brackets ~[~ and ~]~. An
array literal of size ~0~ contains no data, and is just the brackets. Array
literal are indistinguishable from slice literals (cf. Section [[sec:slices]]), it
is the type of lvalue operand that define wether to create a slice or an array
value. By default if the type of the lvalue is not defined the operand type is
always a slice type.

\begin{code}
def foo (x : [i32 ; 4]) {// ...}

let a = [1, 2, 3]; // slice [i32]
let b : [i32 ; 3] = [1, 2, 3]; // array [i32 ; 3]


foo ([1, 2, 3, 4]); // calling with an array [i32 ; 4]
\end{code}

Array literals can also be defined using the array construction syntax. The
syntax is close to the type description of the array type, but using a value
instead of a type ~[V ; N]~. Each element of the array will take the value ~V~.

\begin{code}
let a = [12 ; 2]; // an array of i32 of size 2, where every element is equal to 12

assert (a [0] == 12 && a [1] == 12);
\end{code}

** Mutability

Arrays don't borrow data on their own, as they are in fact the data of the
arrays themselves. Meaning that during data movement all the datas contained in
an array are copied. As for tuples, mutability level of array is therefore only
important if the inner type of the array is a type that borrows data.

\begin{code}
let dmut a : [i32 ; 3] = [1, 2, 3];

let dmut b = a; // no need for alias
                // a and b don't refer to the same memory segment

let i = 89;
let c : [*i32 ; 1] = [&i];

let dmut d = c; // not allowed, discard const property of the inner type
\end{code}


** Properties

Properties on array type can be access using the operator ~::~ on a type expression. The properties are the following :

|----------+------------------------------------------------------------------+-------------|
| name     | value                                                            | type        |
|----------+------------------------------------------------------------------+-------------|
|----------+------------------------------------------------------------------+-------------|
| ~init~   | The initial value, where every inner values are set to ~T::init~ | ~typeof(x)~ |
|          | and where ~T~ is the inner type of the array                     |             |
| ~size~   | The static size of the array (is equal to ~.len~)                | ~usize~     |
|----------+------------------------------------------------------------------+-------------|
| ~inner~  | The inner type contained in the array type                       | None        |
|          | This property returns a type expression, not a value             |             |
|----------+------------------------------------------------------------------+-------------|
| ~typeid~ | A string encoding the name of the type                           | ~[c8]~      |
| ~sizeof~ | The size in bytes of the type                                    | ~usize~     |
|----------+------------------------------------------------------------------+-------------|

** Binary operators

Binary operators are divided into four groups :

- Access:

  The operator ~.~ is used to access to fields describing the array type. The
  right operand is the field of the information to access. These fields are
  described in the following table.

  |------------+-----------------------------------------------+------------------------|
  | name       | value                                         | type                   |
  |------------+-----------------------------------------------+------------------------|
  |------------+-----------------------------------------------+------------------------|
  | ~len~      | The size of the array                         | ~usize~                |
  | ~ptr~      | The pointer to the first element of the array | ~*(typeof (x)::inner)~ |
  |------------+-----------------------------------------------+------------------------|

  The ~len~ field is knwon at compilation time, and therefore usable in a ~cte~
  expression. The type of the ~ptr~ field has the same mutability level as the
  array type.

- Concatenation :

  Concatenation operator ~~~ is used to create an array or a slice containing the values of two arrays or slices. The operator is usable when the left and right operand have the same inner type, no matter their relative sizes. The mutability of the generated value is the most strict mutability between the two operands. For example, the type and mutability of ~([*i32 ; 4]) ~ (dmut [*i32 ; 2])~ is ~[*i32 ; 6]~ to avoid discarding constant property of the values containined in the left operand. As one can note the type of the generated value is an array type whose size is the sum of the size of the left and right operands.

  The operator is also usable when one of the two operands is a slice. In that
  case the return value of the operation will therefore be a slice instead of an
  array as its size cannot be knwon at compilation time. This operation is in
  fact carried out by the slice operand more than by the array operands, and
  will be further discuss in the subsection [[sec:slices]].

  The operator ~~~ was selected to avoid confusion with the ~+~ that would have
  different behavior depending on the operands. Concatenation is not really a
  math operation, as ~+~ would preferably refer to an addition of all the inner
  values of two arrays, more than to their concatenation.

  Concatenation operator is obviously not commutative.

  \begin{code}
  let a : [i32 ; 3] = [1, 2, 3];
  let b : [i32 ; 2] = [4, 5];

  let c : [i32 ; 5] = a ~ b;

  assert (c == [1, 2, 3, 4, 5]);
  \end{code}

- Comparison :

  Binary comparison operators are usable using two arrays with the same inner
  type, or one array and one slice with the same inner type. The result of the
  operation always takes the type ~bool~. For the operators to work, the inner
  type of the array must also define the comparison operators. Lexical order is
  used therefore the size of an array is only used when one of the two operands
  is a prefix to the other (e.g. ~[1, 2]~ is a prefix of ~[1, 2, 3]~, therefore
  ~[1, 2, 3]~ is considered greater than ~[1, 2]~, however ~[1, 3]~ is greater
  than ~[1, 2, 3]~).


  #+ATTR_LATEX: :align |c|lll|
  |----------+------------------+-------------+---------------------------------|
  | Operator | Operation        | Commutative | Example                         |
  |----------+------------------+-------------+---------------------------------|
  |----------+------------------+-------------+---------------------------------|
  | ~>~      | Greater than     | No          | ~([1, 2] > [2, 3]) == false~    |
  | ~<~      | Lower than       | No          | ~([1, 2] < [2, 3]) == true~     |
  | ~>=~     | Greater or equal | No          | ~([1, 2, 3] >= [1, 2]) == true~ |
  | ~<=~     | Lower or equal   | No          | ~([1, 2, 3] <= [2]) == true~    |
  | ~==~     | Equal            | Yes         | ~([1, 2] == [1, 2]) == true~    |
  | ~!=~     | Not equal        | Yes         | ~([1, 2] != [1, 2]) == false~   |
  |----------+------------------+-------------+---------------------------------|


- Affectation :

  An array value can be a lvalue if and only if it is mutable. Information about
  inner type mutability was already discussed in the mutability paragraph, and
  therefore will not be further discussed here. The size of the left and right
  operands must of course be strictly equal.

  \begin{code}
  let mut a : [i32 ; 2] = [1, 2];

  a = [2, 3];
  \end{code}

** Index operator

The index operator can be used on an array left operand using a int value or a
range value as right operand.

- With an int value; The element at the index described by the int value is returned. The mutability of the result value depends on the mutability of the inner type of the array. If the mutability level of the array type is at least ~2~, the result value can be used as a lvalue.

  \begin{code}
  let mut a : [mut i32 ; 3] = [1, 2, 3];
  let mut b : [i32 ; 2] = [4, 5];

  a [0] = 9; // ok, mutability level of a is high enough

  b [0] = 11; // not allowed, b inner values are not mutable
  b = [9, 10]; // ok, b is mutable
  \end{code}

  If the value of the int operand is knwonable at compilation time, a size check
  is performed to ensure that the access does not overflow the array size, and
  that used value is positive or null. If the value is unknown at compilation time, a
  condition is added when compiling the code in version ~DEBUG~, and an array
  size checking is performed during runtime, panicking when an overflow occurs.
  If the code is compiled in release mode, no checking is performed and index
  overflow can happen.

- with a range value; Using a range value containing int values as right
  operand, a slice is created containing only a subset of the array values. The
  mutability level of the created slice type is the same as the mutability of the
  array type.

  \begin{code}
  let a = [i32 ; 4] = [1, 2, 3, 4];

  let b : [i32] = a [0 .. 2];
  \end{code}

  If inner values of the range are knowable at compilation time, checking is
  made to verify that no array overflow will occur. Range must be increasing,
  meaning that the first value of the range must be lower than the second value,
  and must not be an including range. This is also checked at compilation time
  if possible. If the values of the range values are not knwonable at
  compilation time, then these checks are made at runtime if version ~DEBUG~ is
  enabled.

** Dollar operator

The dollar operator is usable within an index operation in the right operand
expression. The dollar value takes the value of the size of the array and its
type is ~usize~. Its value is known at compilation time.

\begin{code}
let a = [i32 ; 4] = [1, 2, 3, 4];

let b = a[0us .. $ - 1us]; // all the values except the last one

let c = a [$ - 2us]; // The second value to the last
\end{code}

** Array iteration


Arrays are iterable types, therefore they can be used as the iterable values of
a ~for~ loop. The ~for~ loop can be equipped with either one or two variables as
iterators. When a single variable is employed, it automatically captures the
value of the array element at the current iteration index. Conversely, if two
variables are utilized, the first variable represents the iteration index, while
the second variable stores the value of the array element at that specific
index.

\begin{code}
\end{code}


** Array expansion

* Slices <<sec:slices>>

slices

* Options

options
