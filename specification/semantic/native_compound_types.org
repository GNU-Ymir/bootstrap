
* Pointers

Pointers are values storing an address of memory. Pointer types are described
using the ~*~ token followed by a type (e.g. ~*i32~ describing a pointer to a
~i32~ value). In the beta version of Ymir (compiler written in c++) the operator
~&~ was used, it was changed as it was also used to refer to object instances
that are in a way pointers but have very different behavior.

** Literals

The ~null~ keywords is used to describe a pointer that points to nowhere. This
is the only literal that can be used as pointer value.

** Construction

To construct a pointer the unary operator ~&~ can be used on a lvalue
(a variable for example). This operator retreive the address of the value
referenced by the operand, (i.e. ~&a~ retreives the address of the segment of
memory referenced by the variable ~a~). By abuse of speech and simplification,
we can say that we retreive the address of the variable ~a~.

\begin{code}
let a = 12;
let b : *i32 = &a;
\end{code}

** Mutability

Because pointers borrow data from another value (value pointed by the pointer),
their mutability is important. A pointer has two level of mutability :
- ~mut *i32~, in that case the pointer can be changed but not the value inside it.
- ~mut *(mut i32)~, in that case both the value pointed by the pointer and the pointer itself are mutable.

A mutable pointer (level 1) means that if the pointer is contained inside
another compound type or in a variable its value can be changed. When the value inside the pointer is created mutability checking is made at compilation time.

\begin{code}
let dmut a : *i32 = null;

let b = 12;
a = alias (&b); // not allowed  b is not mutable
*a = 24; // but it would be modified by this operation


let mut c = 11;
a = alias (&c); // allowed c is mutable
*a = 24; // modify the value of c is allowed
\end{code}

** Properties

Properties on pointer type can be accessed using the operator ~::~ on a type expression. The properties are the following :

|----------+------------------------------------------------------+-------------|
| name     | value                                                | type        |
|----------+------------------------------------------------------+-------------|
|----------+------------------------------------------------------+-------------|
| ~init~   | The initial value ~null~                             | ~typeof(x)~ |
|----------+------------------------------------------------------+-------------|
| ~inner~  | The inner type contained in the pointer type         | None        |
|          | This property returns a type expression, not a value |             |
|----------+------------------------------------------------------+-------------|
| ~typeid~ | A string encoding the name of the type               | ~[c8]~      |
| ~sizeof~ | The size in bytes of the type                        | ~usize~     |
|----------+------------------------------------------------------+-------------|



** Casting

A pointer type can be casted using the cast operator ~cast!T(V)~ into a
~*(void)~. A ~*void~ pointer type can be casted into any pointer type. Pointer
is a really low level type with just few guarantees, but some operations relies
on that possibility to perform generic operations (common traits, ~Packable~ for
example).

This is the only allowed casts on pointer types.

** Unary operators

The unary operator ~*~ is used on a pointer value to dereference it and access
the value pointed by the pointer. This operation is unsafe, and might throw a
~SegFault~ exception. If the operation does not throw anything it does not
necessarily mean that the pointer was correctly created.

** Binary operators

Binary operators are divided into 3 groups :

- Math :

  Pointer arithmetic is allowed using a ~usize~ as right operand. Unlike in C language, the arithmetic does not depend on the size of the data pointed by the pointer. The operation adds a number of bytes to the address, meaning that the addition operation using a left operand whose value is ~0xabc0~ and a right operand ~8u8~ will always have the value ~0xabc8~ no matter the type of content pointed by the pointer. The behavior is not the same with index operator. The type of the result of the operation always takes the same type as the left operand.

    #+ATTR_LATEX: :align |c|ll|
  |----------+-------------+------------|
  | Operator | Operation   | Example    |
  |----------+-------------+------------|
  | ~+~      | Addition    | ~&a + 2us~ |
  | ~-~      | Subtraction | ~&a - 1us~ |
  |----------+-------------+------------|

- Logical :

  Comparison operators always return a value of type ~bool~ and are only usable when the two operands are of the same pointer type (e.g. *i32 with *i32).

    #+ATTR_LATEX: :align |c|lll|
  |----------+---------------+-------------+--------------------------|
  | Operator | Operation     | Commutative | Example                  |
  |----------+---------------+-------------+--------------------------|
  |----------+---------------+-------------+--------------------------|
  | ~is~     | Equality test | Yes         | ~&a is &a == true~       |
  | ~!is~    | Equality test | Yes         | ~&a !is &a == false~     |
  | ~<~      | Lower than    | No          | ~&a < &a + 1us == false~ |
  | ~>~      | Greated than  | No          | ~&a > &a - 1us == false~ |
  |----------+---------------+-------------+--------------------------|

  One can note that the equality operator for pointers are not ~==~ and ~!=~, and that those operators are undefined for pointer operands. The reason behind that is to keep consistency with the equality operators of class instances, where the ~is~ and ~!is~ operators check the address equality and ~==~ and ~!=~ are used for the value equality.


- Affectation :

  The affectation operator are usable when the two operands have strictly the same pointer type.The mutability level of the left operand must be lower or equal to the mutability level of the right operand.
  Affectation operators can be mixed with math operators (e.g. ~+=~, ~-=~). In that case the operation is rewritten into ~x = x + y~ and ~y~ must a value of type ~usize~.

  \begin{code}
  let dmut a = 11;
  let dmut b = &a;

  let mut c = &a;
  b = c; // not allowed it will discard the const property
  c = b; // No problem the mutability level of c is lower than the one of b

  c += 1us;
  \end{code}

** Index operator


* Tuples

tuple

* Ranges

range

* Arrays

arrays

* Slices

slices

* Options

options
