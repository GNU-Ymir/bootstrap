
* Pointers

Pointers are values storing an address of memory. Pointer types are described
using the ~*~ token followed by a type (e.g. ~*i32~ describing a pointer to a
~i32~ value). In the beta version of Ymir (compiler written in c++) the operator
~&~ was used, it was changed as it was also used to refer to object instances
that are in a way pointers but have very different behavior.

** Literals

The ~null~ keywords is used to describe a pointer that points to nowhere. This
is the only literal that can be used as pointer value.

** Construction

To construct a pointer the unary operator ~&~ can be used on a lvalue
(a variable for example). This operator retreive the address of the value
referenced by the operand, (i.e. ~&a~ retreives the address of the segment of
memory referenced by the variable ~a~). By abuse of speech and simplification,
we can say that we retreive the address of the variable ~a~.

\begin{code}
let a = 12;
let b : *i32 = &a;
\end{code}

** Mutability

Because pointers borrow data from another value (value pointed by the pointer),
their mutability is important. A pointer has two level of mutability :
- ~mut *T~, in that case the pointer can be changed but not the value inside it.
- ~mut *(mut T)~, in that case both the value pointed by the pointer and the pointer itself are mutable.

A mutable pointer (level 1) means that if the pointer is contained inside
another compound type or in a variable its value can be changed. When the value inside the pointer is created mutability checking is made at compilation time.

\begin{code}
let dmut a : *i32 = null;

let b = 12;
a = &b; // not allowed  b is not mutable
*a = 24; // but it would be modified by this operation


let mut c = 11;
a = &c; // allowed c is mutable
*a = 24; // modify the value of c is allowed
\end{code}

The keyword ~alias~ has to be used on the right operand if data borrowing is
transfered to the left operand. In practice, this means that if the left operand
mutability is of second level (i.e. ~mut *(mut T)~), the keyword ~alias~ has to
be used, and right operand must also be of second level mutability. The keyword
can be omitted if the aliasing is obvious (i.e. by function return, or
construction such as the unary operator ~&~).

** Properties

Properties on pointer type can be accessed using the operator ~::~ on a type expression. The properties are the following :

|----------+------------------------------------------------------+-------------|
| name     | value                                                | type        |
|----------+------------------------------------------------------+-------------|
|----------+------------------------------------------------------+-------------|
| ~init~   | The initial value ~null~                             | ~typeof(x)~ |
|----------+------------------------------------------------------+-------------|
| ~inner~  | The inner type contained in the pointer type         | None        |
|          | This property returns a type expression, not a value |             |
|----------+------------------------------------------------------+-------------|
| ~typeid~ | A string encoding the name of the type               | ~[c8]~      |
| ~sizeof~ | The size in bytes of the type                        | ~usize~     |
|----------+------------------------------------------------------+-------------|



** Casting

A pointer type can be casted using the cast operator ~cast!T(V)~ into a
~*(void)~. A ~*void~ pointer type can be casted into any pointer type. Pointer
is a really low level type with just few guarantees, but some operations relies
on that possibility to perform generic operations (common traits, ~Packable~ for
example).

This is the only allowed casts on pointer types.

** Unary operators

The unary operator ~*~ is used on a pointer value to dereference it and access
the value pointed by the pointer. This operation is unsafe, and might throw a
~SegFault~ exception. If the operation does not throw anything it does not
necessarily mean that the pointer was correctly created.

** Binary operators

Binary operators are divided into 3 groups :

- Math :

  Pointer arithmetic is allowed using a ~usize~ as right operand. Unlike in C language, the arithmetic does not depend on the size of the data pointed by the pointer. The operation adds a number of bytes to the address, meaning that the addition operation using a left operand whose value is ~0xabc0~ and a right operand ~8us~ will always have the value ~0xabc8~ no matter the type of content pointed by the pointer. The behavior is not the same with index operator. The type of the result of the operation always takes the same type as the left operand.

    #+ATTR_LATEX: :align |c|ll|
  |----------+-------------+------------|
  | Operator | Operation   | Example    |
  |----------+-------------+------------|
  | ~+~      | Addition    | ~&a + 2us~ |
  | ~-~      | Subtraction | ~&a - 1us~ |
  |----------+-------------+------------|

- Logical :

  Comparison operators always return a value of type ~bool~ and are only usable when the two operands are of the same pointer type (e.g. *i32 with *i32).

    #+ATTR_LATEX: :align |c|lll|
  |----------+---------------+-------------+--------------------------|
  | Operator | Operation     | Commutative | Example                  |
  |----------+---------------+-------------+--------------------------|
  |----------+---------------+-------------+--------------------------|
  | ~is~     | Equality test | Yes         | ~&a is &a == true~       |
  | ~!is~    | Equality test | Yes         | ~&a !is &a == false~     |
  | ~<~      | Lower than    | No          | ~&a < &a + 1us == false~ |
  | ~>~      | Greated than  | No          | ~&a > &a - 1us == false~ |
  |----------+---------------+-------------+--------------------------|

  One can note that the equality operator for pointers are not ~==~ and ~!=~, and that those operators are undefined for pointer operands. The reason behind that is to keep consistency with the equality operators of class instances, where the ~is~ and ~!is~ operators check the address equality and ~==~ and ~!=~ are used for the value equality.


- Affectation :

  The affectation operator are usable when the two operands have strictly the same pointer type.The mutability level of the left operand must be lower or equal to the mutability level of the right operand.
  Affectation operators can be mixed with math operators (e.g. ~+=~, ~-=~). In that case the operation is rewritten into ~x = x + y~ and ~y~ must be a value of type ~usize~.

  \begin{code}
  let mut a = 11;
  let dmut b = &a;

  let mut c = &a;
  b = c; // not allowed it will discard the const property
  c = b; // No problem the mutability level of c is lower than the one of b

  c += 1us;

  let dmut d = &a;
  b = alias d; // alias is needed, data is borrowed
  \end{code}

** Index operator

The index operator can be used on a pointer left operand using a int value as an index right operand. The result of the operation is the dereferencement of the pointer value with the offset of the value used as index. Unlike pointer arithmetic using the ~+~ and ~-~ operator, the index operator takes into account the size of the data pointed by the pointer, meaning that the index operation ~(&a)[7]~ is strictly transformed into ~*(&a + (7us * sizeof (typeof(&a)::inner)))~.

The result value mutability depends on the level of mutability of the pointer operand. If the pointer operand mutability level is 2, then the result can be used as a lvalue.

\begin{code}
let mut a = 12;
let dmut b = &a;

b [0] = 89;
assert (a == 89);
\end{code}

* Tuples

Tuple are anonymus structure storing a set of data of different types. They are described as a list of types enclosed within parentheses (e.g. ~(i32, f32, c8)~). A tuple can have only one inner type, in that case the token ~,~ is added after the definition of the inner type (e.g. ~(i32,)~).


** Literals

Tuple literals are described as a list of values enclosed by parentheses tokens, for example ~(1, 'r', false)~ is a tuple literal whose types is ~(i32, c32, bool)~. Tuple containing only one value must contain the token ~,~ after the declaration of the value, in order to distinguish them from priority operation enclosed within parentheses.

\begin{code}
let a = (1, 'r', false);
let b : (i32,) = (23,); // tuple value
let c : i32 = (23); // int value
\end{code}

** Mutability <<sec:tuple_mutability>>

The mutability of tuple values cannot be described as a mutability level as it could be for other compound types. In the case of tuple, the mutability is defined as a tree, where each node of the tree depend on the mutability of its parent. For example, the mutability of the following tuple type ~mut (mut i32, f32, dmut *c8)~ is presented in the figure [[fig:tuple_mutability]].


#+HEADER: :file images/tuple_mutability.pdf :imagemagick yes
#+HEADER: :results output silent :headers '("\\usepackage{tikz}")
#+HEADER: :fit yes :imoutoptions -geometry 400 :iminoptions -density 600
#+BEGIN_src latex
\begin{tikzpicture}

  \draw[-, black!30!green] (0,0) -- (-1,-1);
  \draw[-, red!50] (0,0) -- (0,-1);
  \draw[-, black!30!green] (0,0) -- (1,-1);
  \draw[-, black!30!green] (1,-1) -- (1,-2);

  \filldraw (0, 0.2) node[align=center, above] {\tiny{mut}};
  \filldraw (0, 0) circle (1pt) node[align=center, above] {\tiny{(i32, f32, *c8)}};
  \filldraw (-1,-1) circle (1pt) node[align=center, below]{\tiny{mut}};
  \filldraw (-1,-1.2) node[align=center, below]{\tiny{i32}};
  \filldraw (0,-1) circle (1pt) node[align=center, below]{\tiny{const}};
  \filldraw (0,-1.2) node[align=center, below]{\tiny{f32}};
  \filldraw (1,-1) circle (1pt) node[align=center, right]{\tiny{mut *c8}};
  \filldraw (1,-2) circle (1pt) node[align=center, right]{\tiny{mut c8}};


\end{tikzpicture}
#+END_src

#+CAPTION: Example of the process
#+NAME: fig:tuple_mutability
#+attr_latex: :width 200px
[[file:../images/tuple_mutability.pdf]]

Mutability level of inner types is important only when they borrow data. In the
previous example presented in figure [[fig:tuple_mutability]], only the mutability
of the inner type ~*c8~ is important during data movement. In other word a value
of type ~mut (i32, f32, dmut *c8)~ can be passed to it without any problem. As
for any borrowing type, the keyword ~alias~ has to be used when data is
borrowed.

\begin{code}
let mut x = 't'c8;
let mut a : mut (mut i32, f32, dmut *c8) = (1, 12.0f, &x);
let mut b : mut (i32, f32, dmut *c8) = (1, 7.0f, null);

a = alias b; // no problem
b = alias a; // no problem either

let c : (i32, f32, *c8) = (1, 7.0f, &x);
a = alias c; // not allowed, it would dicard constant property of the third field
\end{code}

Tuple types having mutable values that are not borrowing data are considered non
borrowing types, and therefore don't need ~alias~ during data movement. In
practice all the data of this kind of tuples are copied during data movement.

** Properties

Properties on pointer type can be accessed using the operator ~::~ on a type expression. The properties are the following :

|----------+---------------------------------------------------------+-------------|
| name     | value                                                   | type        |
|----------+---------------------------------------------------------+-------------|
|----------+---------------------------------------------------------+-------------|
| ~arity~  | The number of inner elements of the tuple type          | ~usize~     |
|----------+---------------------------------------------------------+-------------|
| ~init~   | The initial value of the tuple, where every inner field | ~typeof(x)~ |
|          | are set to ~T::init~                                    |             |
|          | -- example: ~(i32, f32)::init == (i32::init, f32::init)~ |             |
|----------+---------------------------------------------------------+-------------|
| ~typeid~ | A string encoding the name of the type                  | ~[c8]~      |
| ~sizeof~ | The size in bytes of the type                           | ~usize~     |
|----------+---------------------------------------------------------+-------------|

\noindent Inner types are not accessible through the operator ~::~, but are accessible
using ~__pragma~.
# (cf. Chapter [[chap:pragmas]]).

** Binary operators

Binary operators are divided into 3 groups :

- Access:

  The operator ~.~ is used to access to a given field of the tuple. The right
  operand must be of an int type and be within the range of ~0~ and the arity of
  the tuple being accessed. The result of the operation takes the type of the
  field at the index described by the right operand, and so is the value. The
  first field index is ~0~.

  \begin{code}
  let mut a : (mut i32, f32) = (8, 8.f);

  a._0 = 7; // allowed first field is mutable
  a._1 = 1.f; // not allowed, second field is not mutable

  let c = a.(12 - 11); // accessing the field at index 1
  \end{code}

- Comparison:

  The comparison operators ~==~ and ~!=~ are defined on tuples when every inner
  types are comparable. It compares all the fields of two tuples, and checks
  wether all the inner values are equals for ~==~, or at least one inner value
  is different between the two operands for the operator ~!=~.

- Affectation:

  Affectation operator creates a data movement from the right operand to the left operand. Mutability has to be respected when data is borrowed. Data mutability on tuples was already presented in Section [[sec:tuple_mutability]].

* Ranges

range

* Arrays

arrays

* Slices

slices

* Options

options
