* Preamble

Before presenting the specification of the different compound types, let's
define some useful element of language.

+ /Data borrowing/ -- A data borrowing value, is a value that points to data that is not automatically copied when the value is copied. The simplest example of a data borrowing is using a pointer type, where the value of the pointer gives information about a memory address containing data, such data pointed by the pointer is not copied when the pointer is. An illustration of this is presented in figure [[fig:data_borrowing]]

    #+HEADER: :file images/data_borrowing.pdf :imagemagick yes
    #+HEADER: :results output silent :headers '("\\usepackage{tikz}")
    #+HEADER: :fit yes :imoutoptions -geometry 400 :iminoptions -density 600
    #+BEGIN_src latex
\tikzstyle{every picture}+=[remember picture]
\tikzstyle{mProjectPP}=[circle,fill=yellow!70, minimum size=20pt,inner sep=0pt]
\tikzstyle{label}=[rectangle, fill=white, minimum size=40pt, inner sep=0pt]
\tikzstyle{Box}=[rectangle, fill=white, minimum size=40pt, inner sep=0pt]
\tikzstyle{Box2}=[rectangle, fill=white, minimum size=20pt, inner sep=0pt]
\definecolor{applegreen}{rgb}{0.55, 0.71, 0.0}
\definecolor{antiquebrass}{rgb}{0.8, 0.58, 0.46}

\begin{tikzpicture}
  % ================ Axis ========================
  \draw (0, 0) -- coordinate (LEFT) (0, 0);
  \draw[->](0, 10) -- coordinate (YAx) (0, 0);
  \draw[->](7.2, 10) -- coordinate (YAx) (7.2, 0);
  \draw[Box] (3.5, 10.7) -- (3.5, 10.7) node[anchor=center]{\textbf{STACK}};

  \filldraw (0, 6.5) circle (1pt) node[align=center, left] {+0};
  \filldraw (0, 5.5) circle (1pt) node[align=center, left] {+8};
  \filldraw (0, 4.5) circle (1pt) node[align=center, left] {+16};
  \filldraw (0, 3.5) circle (1pt) node[align=center, left] {+24};
  \filldraw (0, 2.5) circle (1pt) node[align=center, left] {+32};

  %% % ================ Foo ========================
  \fill[black!10] (0.2, 10) rectangle (7, 8);
  \draw[Box] (3.5, 7.6) -- (3.5, 7.6) node[anchor=center]{\textbf{.}};
  \draw[Box] (3.5, 7.4) -- (3.5, 7.4) node[anchor=center]{\textbf{.}};
  \draw[Box] (3.5, 7.2) -- (3.5, 7.2) node[anchor=center]{\textbf{.}};

  \draw[line width=1pt] (0.18, 6.9) rectangle (7.02, 2.48);
  \fill[blue!10] (0.2, 6.5) rectangle (7, 2.5);
  \draw[Box] (3.5, 6.7) -- (3.5, 6.7) node[anchor=center]{\emph{foo}};

  \draw[Box] (0.5, 5.5) -- (0.5, 5.5) node[anchor=center]{\textbf{\textit{x}}};
  \draw[line width=1pt] (0.3, 6.4) rectangle (6.8, 4.6);
  \draw[line width=1pt] (0.7, 5.5) rectangle (6.8, 5.5);

  \draw[Box] (3.5, 6) -- (3.5, 6) node[anchor=center]{\emph{len~=}~$3$};
  \draw[Box] (3.5, 5) -- (3.5, 5) node[anchor=center]{\emph{ptr~=}~0xfa45b987};

  \draw[Box] (0.5, 3.5) -- (0.5, 3.5) node[anchor=center]{\textbf{\textit{y}}};
  \draw[line width=1pt] (0.3, 4.4) rectangle (6.8, 2.6);
  \draw[line width=1pt] (0.7, 3.5) rectangle (6.8, 3.5);

  \draw[Box] (3.5, 4) -- (3.5, 4) node[anchor=center]{\emph{len~=}~$3$};
  \draw[Box] (3.5, 3) -- (3.5, 3) node[anchor=center]{\emph{ptr~=}~0xfa45b987};


  %% % ================ Heap ========================

  \draw[->](10, 10) -- coordinate (YAx) (10, 0);
  \draw[->](17.2, 10) -- coordinate (YAx) (17.2, 0);
  \filldraw (17.2, 7.5) circle (1pt) node[align=center, right] {0xfa45b987};

  % ================ Data ========================
  \draw[Box] (13.5, 10.7) -- (13.5, 10.7) node[anchor=center]{\textbf{HEAP}};
  \fill[black!10] (10.2, 10) rectangle (17, 8);
  \fill[applegreen!20] (10.2, 7.9) rectangle (17, 5);
  \draw[line width=1pt] (10.4, 7) rectangle (16.8, 7);
  \draw[line width=1pt] (10.4, 6) rectangle (16.8, 6);

  \draw[Box] (13.5, 7.5)  (13.8, 7.5) node[anchor=center]{$1$};
  \draw[Box] (13.5, 6.5)  (13.8, 6.5) node[anchor=center]{$2$};
  \draw[Box] (13.5, 5.5)  (13.8, 5.5) node[anchor=center]{$3$};

  \draw[thick,->,shorten >=1pt] (7.3, 5) to [out=0,in=180] node[below left, yshift=3mm] {} (9.9, 7.5);

  \draw[thick,->,shorten >=1pt] (7.3, 3) to [out=0,in=180] node[below left, yshift=3mm] {} (9.9, 7.5);

\end{tikzpicture}

#+END_src

    #+CAPTION: Example of data borrowing
    #+NAME: fig:data_borrowing
    #+attr_latex: :width 200px
    [[file:../images/data_borrowing.pdf]]

    In the above example, both variable ~x~ and ~y~ borrow the data located in
    the heap at the address ~0xfa45b987~. By copying the value of the variable ~y~
    into another variable, no copy of the borrowed value is made (located on the heap) but only the value directly inside ~y~ would be copied, in that case located on the stack. The borrowed data can be
    located on the stack or an the heap, and the same applies for borrowing data.
    Such memory is called borrowed as it can live longer that the value pointing to it, and only borrows its value for reading or writing.

    In the case of borrowing data, mutability is very important as multiple variable
    refers to the same segment of memory, and thus side effect could occurs
    inpredictively. Memory mutability is here to help managing such behavior, and
    ensure that only few variables have a mutable access to values, and most
    importantly that no mutable memory borrowing is created unintentionally.

- /Data movement/ -- A data movement is a copy of a value from a segment of memory
  to another segment. This can be performed by affectation, memory copy (or deep
  copy), function call, etc. Data movements are made to be always explicit, such
  that no unwanted copy (slowing the program) are made.

- /lvalue/ -- A lvalue is the left operand in a /data movement/ operation. In
  other word it is an expression refering to a segment of memory that will be
  modified due to a data movement. A lvalue can from many type of expression
  (e.g. simple variable, function parameter, index operation, etc.)

- /rvalue/ -- A rvalue is the right operand involved in a /data movement/
  operation. A rvalue can be aliased (using the keyword ~alias~), referenced
  (keyword ~ref~), copied with (~copy~, ~dcopy~) or implicit. Implicit meaning
  that data movement does not borrow mutable data, and therefore is allowed
  implicitly. In case of implicit data movement, no borrowed data is copied.

With the help of keywords (~alias~, ~ref~, ~copy~ and ~dcopy~) data movement and
mutability should be always easy to follow, and should help the compiler to
ensure that no unwanted side effects are occuring.

* Pointers

Pointers are values storing an address of memory. Pointer types are described
using the ~*~ token followed by a type (e.g. ~*i32~ describing a pointer to a
~i32~ value). In the beta version of Ymir (compiler written in c++) the operator
~&~ was used, it was changed as it was also used to refer to object instances
that are in a way pointers but have very different behavior.

** Literals

The ~null~ keywords is used to describe a pointer that points to nowhere. This
is the only literal that can be used as pointer value.

** Construction

To construct a pointer the unary operator ~&~ can be used on a lvalue
(a variable for example). This operator retreive the address of the value
referenced by the operand, (i.e. ~&a~ retreives the address of the segment of
memory referenced by the variable ~a~). By abuse of speech and simplification,
we can say that we retreive the address of the variable ~a~.

\begin{code}
let a = 12;
let b : *i32 = &a;
\end{code}

** Mutability

Because pointers borrow data from another value (value pointed by the pointer),
their mutability is important. A pointer has two level of mutability :
- ~mut *T~, in that case the pointer can be changed but not the value inside it.
- ~mut *(mut T)~, in that case both the value pointed by the pointer and the pointer itself are mutable.

A mutable pointer (level 1) means that if the pointer is contained inside
another compound type or in a variable its value can be changed. When the value inside the pointer is created mutability checking is made at compilation time.

\begin{code}
let dmut a : *i32 = null;

let b = 12;
a = &b; // not allowed  b is not mutable
*a = 24; // but it would be modified by this operation


let mut c = 11;
a = &c; // allowed c is mutable
*a = 24; // modify the value of c is allowed
\end{code}

The keyword ~alias~ has to be used on the right operand if data borrowing is
transfered to the left operand. In practice, this means that if the left operand
mutability is of second level (i.e. ~mut *(mut T)~), the keyword ~alias~ has to
be used, and right operand must also be of second level mutability. The keyword
can be omitted if the aliasing is obvious (i.e. by function return, or
construction such as the unary operator ~&~).

** Properties

Properties on pointer type can be accessed using the operator ~::~ on a type expression. The properties are the following :

|----------+------------------------------------------------------+-------------|
| name     | value                                                | type        |
|----------+------------------------------------------------------+-------------|
|----------+------------------------------------------------------+-------------|
| ~init~   | The initial value ~null~                             | ~typeof(x)~ |
|----------+------------------------------------------------------+-------------|
| ~inner~  | The inner type contained in the pointer type         | None        |
|          | This property returns a type expression, not a value |             |
|----------+------------------------------------------------------+-------------|
| ~typeid~ | A string encoding the name of the type               | ~[c8]~      |
| ~sizeof~ | The size in bytes of the type                        | ~usize~     |
|----------+------------------------------------------------------+-------------|



** Casting

A pointer type can be casted using the cast operator ~cast!T(V)~ into a
~*(void)~. A ~*void~ pointer type can be casted into any pointer type. Pointer
is a really low level type with just few guarantees, but some operations relies
on that possibility to perform generic operations (common traits, ~Packable~ for
example).

This is the only allowed casts on pointer types.

** Unary operators

The unary operator ~*~ is used on a pointer value to dereference it and access
the value pointed by the pointer. This operation is unsafe, and might throw a
~SegFault~ exception. If the operation does not throw anything it does not
necessarily mean that the pointer was correctly created.

** Binary operators

Binary operators are divided into 3 groups :

- Math :

  Pointer arithmetic is allowed using a ~usize~ as right operand. Unlike in C language, the arithmetic does not depend on the size of the data pointed by the pointer. The operation adds a number of bytes to the address, meaning that the addition operation using a left operand whose value is ~0xabc0~ and a right operand ~8us~ will always have the value ~0xabc8~ no matter the type of content pointed by the pointer. The behavior is not the same with index operator. The type of the result of the operation always takes the same type as the left operand.

    #+ATTR_LATEX: :align |c|ll|
  |----------+-------------+------------|
  | Operator | Operation   | Example    |
  |----------+-------------+------------|
  | ~+~      | Addition    | ~&a + 2us~ |
  | ~-~      | Subtraction | ~&a - 1us~ |
  |----------+-------------+------------|

- Logical :

  Comparison operators always return a value of type ~bool~ and are only usable when the two operands are of the same pointer type (e.g. *i32 with *i32).

    #+ATTR_LATEX: :align |c|lll|
  |----------+---------------+-------------+--------------------------|
  | Operator | Operation     | Commutative | Example                  |
  |----------+---------------+-------------+--------------------------|
  |----------+---------------+-------------+--------------------------|
  | ~is~     | Equality test | Yes         | ~&a is &a == true~       |
  | ~!is~    | Equality test | Yes         | ~&a !is &a == false~     |
  | ~<~      | Lower than    | No          | ~&a < &a + 1us == false~ |
  | ~>~      | Greated than  | No          | ~&a > &a - 1us == false~ |
  |----------+---------------+-------------+--------------------------|

  One can note that the equality operator for pointers are not ~==~ and ~!=~, and that those operators are undefined for pointer operands. The reason behind that is to keep consistency with the equality operators of class instances, where the ~is~ and ~!is~ operators check the address equality and ~==~ and ~!=~ are used for the value equality.


- Affectation :

  The affectation operator are usable when the two operands have strictly the same pointer type.The mutability level of the left operand must be lower or equal to the mutability level of the right operand.
  Affectation operators can be mixed with math operators (e.g. ~+=~, ~-=~). In that case the operation is rewritten into ~x = x + y~ and ~y~ must be a value of type ~usize~.

  \begin{code}
  let mut a = 11;
  let dmut b = &a;

  let mut c = &a;
  b = c; // not allowed it will discard the const property
  c = b; // No problem the mutability level of c is lower than the one of b

  c += 1us;

  let dmut d = &a;
  b = alias d; // alias is needed, data is borrowed
  \end{code}

** Index operator

The index operator can be used on a pointer left operand using a int value as an index right operand. The result of the operation is the dereferencement of the pointer value with the offset of the value used as index. Unlike pointer arithmetic using the ~+~ and ~-~ operator, the index operator takes into account the size of the data pointed by the pointer, meaning that the index operation ~(&a)[7]~ is strictly transformed into ~*(&a + (7us * sizeof (typeof(&a)::inner)))~.

The result value mutability depends on the level of mutability of the pointer operand. If the pointer operand mutability level is 2, then the result can be used as a lvalue.

\begin{code}
let mut a = 12;
let dmut b = &a;

b [0] = 89;
assert (a == 89);
\end{code}

* Tuples

Tuple are anonymus structure storing a set of data of different types. They are described as a list of types enclosed within parentheses (e.g. ~(i32, f32, c8)~). A tuple can have only one inner type, in that case the token ~,~ is added after the definition of the inner type (e.g. ~(i32,)~).


** Literals

Tuple literals are described as a list of values enclosed by parentheses tokens, for example ~(1, 'r', false)~ is a tuple literal whose types is ~(i32, c32, bool)~. Tuple containing only one value must contain the token ~,~ after the declaration of the value, in order to distinguish them from priority operation enclosed within parentheses.

\begin{code}
let a = (1, 'r', false);
let b : (i32,) = (23,); // tuple value
let c : i32 = (23); // int value
\end{code}

** Mutability <<sec:tuple_mutability>>

The mutability of tuple values cannot be described as a mutability level as it could be for other compound types. In the case of tuple, the mutability is defined as a tree, where each node of the tree depend on the mutability of its parent. For example, the mutability of the following tuple type ~mut (mut i32, f32, dmut *c8)~ is presented in the figure [[fig:tuple_mutability]].


#+HEADER: :file images/tuple_mutability.pdf :imagemagick yes
#+HEADER: :results output silent :headers '("\\usepackage{tikz}")
#+HEADER: :fit yes :imoutoptions -geometry 400 :iminoptions -density 600
#+BEGIN_src latex
\begin{tikzpicture}

  \draw[-, black!30!green] (0,0) -- (-1,-1);
  \draw[-, red!50] (0,0) -- (0,-1);
  \draw[-, black!30!green] (0,0) -- (1,-1);
  \draw[-, black!30!green] (1,-1) -- (1,-2);

  \filldraw (0, 0.2) node[align=center, above] {\tiny{mut}};
  \filldraw (0, 0) circle (1pt) node[align=center, above] {\tiny{(i32, f32, *c8)}};
  \filldraw (-1,-1) circle (1pt) node[align=center, below]{\tiny{mut}};
  \filldraw (-1,-1.2) node[align=center, below]{\tiny{i32}};
  \filldraw (0,-1) circle (1pt) node[align=center, below]{\tiny{const}};
  \filldraw (0,-1.2) node[align=center, below]{\tiny{f32}};
  \filldraw (1,-1) circle (1pt) node[align=center, right]{\tiny{mut *c8}};
  \filldraw (1,-2) circle (1pt) node[align=center, right]{\tiny{mut c8}};


\end{tikzpicture}
#+END_src

#+CAPTION: Example of the process
#+NAME: fig:tuple_mutability
#+attr_latex: :width 200px
[[file:../images/tuple_mutability.pdf]]

Mutability level of inner types is important only when they borrow data. In the
previous example presented in figure [[fig:tuple_mutability]], only the mutability
of the inner type ~*c8~ is important during data movement. In other word a value
of type ~mut (i32, f32, dmut *c8)~ can be passed to it without any problem. As
for any borrowing type, the keyword ~alias~ has to be used when data is
borrowed.

\begin{code}
let mut x = 't'c8;
let mut a : mut (mut i32, f32, dmut *c8) = (1, 12.0f, &x);
let mut b : mut (i32, f32, dmut *c8) = (1, 7.0f, null);

a = alias b; // no problem
b = alias a; // no problem either

let c : (i32, f32, *c8) = (1, 7.0f, &x);
a = alias c; // not allowed, it would dicard constant property of the third field
\end{code}

Tuple types having mutable values that are not borrowing data are considered non
borrowing types, and therefore don't need ~alias~ during data movement. In
practice all the data of this kind of tuples are copied during data movement.

** Properties

Properties on pointer type can be accessed using the operator ~::~ on a type expression. The properties are the following :

|----------+---------------------------------------------------------+-------------|
| name     | value                                                   | type        |
|----------+---------------------------------------------------------+-------------|
|----------+---------------------------------------------------------+-------------|
| ~arity~  | The number of inner elements of the tuple type          | ~usize~     |
|----------+---------------------------------------------------------+-------------|
| ~init~   | The initial value of the tuple, where every inner field | ~typeof(x)~ |
|          | are set to ~T::init~                                    |             |
|          | -- example: ~(i32, f32)::init == (i32::init, f32::init)~ |             |
|----------+---------------------------------------------------------+-------------|
| ~typeid~ | A string encoding the name of the type                  | ~[c8]~      |
| ~sizeof~ | The size in bytes of the type                           | ~usize~     |
|----------+---------------------------------------------------------+-------------|

\noindent Inner types are not accessible through the operator ~::~, but are accessible
using ~__pragma~.
# (cf. Chapter [[chap:pragmas]]).

** Binary operators

Binary operators are divided into 3 groups :

- Access:

  The operator ~.~ is used to access to a given field of the tuple. The right
  operand must be of an int type and be within the range of ~0~ and the arity of
  the tuple being accessed. The result of the operation takes the type of the
  field at the index described by the right operand, and so is the value. The
  first field index is ~0~.

  \begin{code}
  let mut a : (mut i32, f32) = (8, 8.f);

  a._0 = 7; // allowed first field is mutable
  a._1 = 1.f; // not allowed, second field is not mutable

  let c = a.(12 - 11); // accessing the field at index 1
  \end{code}

- Comparison:

  The comparison operators ~==~ and ~!=~ are defined on tuples when every inner
  types are comparable. It compares all the fields of two tuples, and checks
  wether all the inner values are equals for ~==~, or at least one inner value
  is different between the two operands for the operator ~!=~.

  There is no order relation between tuples, even if they have the same type as
  in general such comparison would be senseless.

- Affectation:

  Affectation operator creates a data movement from the right operand to the
  left operand. Mutability has to be respected when data is borrowed. Data
  mutability on tuples was already presented in Section [[sec:tuple_mutability]].

** Tuple expansion

Tuples have a specific operator named ~expand~ that transform them into a list
of parameters. The expansion of tuple is useful to create other tuples, or
passing the data of the tuple as function parameters.

\begin{code}
def foo (a : i32, b : f32) {}

let a = (1, 5.f);
let b : (i32, f32, c32) = (expand a, 't'); // transform a into a list of values

foo (expand a); // transform a into a list of parameters
\end{code}

Such operation is made at compilation time, and is simply a rewritte that is
less verbose. Indeed in the previous example, the line ~foo (expand a)~, is
rewritten into ~foo (a.0, a.1)~. The mutability level of the expanded values is
always ~1~ meaning tuple expansion can never borrow mutable data.

** Tuple deconstruction

Tuple can be used to declare multiple variable at once, using the same ~let~
declaration. We call this declarations a tuple deconstruction, as it splits the
values of the tuple into a list of variables.

\begin{code}
let (mut a, b, c) = (1, 't', 12.f); // a is mutable, but not b nor c

assert (a == 1 && b == 't' && c == 12.f);
\end{code}

A variadic variable can be used as the last variable declaration in such
deconstruction with the token ~...~. In that case it's type is always a tuple
that takes all the values in the tuple that are left, and are not associated
with other variables.

\begin{code}
let (a, b...) = (1, 2, 3);

assert (a == 1);
assert (b == (2, 3));
\end{code}

The mutability level of variables declared using tuple deconstruction can never
be higher than ~1~. Maybe this limitation can be removed. The problem being that
explicit aliasing would be done to every field of the tuple (i.e. ~let (dmut
a, b) = alias t;~), but maybe in this case it is acceptable.


** Tuple iteration

Tuple are iterable types, thus they can be used as the iterable value of a ~for~
loop. In practice because such iteration would create iterator variables with
different types, the iteration is unrolled at compilation time.

\begin{code}
let a = (1, 't', 89.0f);
for i in a {
    println (i);
}

// would be rewritten into
println (a._0);
println (a._1);
println (a._2);
\end{code}

Two variables are usable as iterators, the first one being the index of the
iteration being the value inside the tuple. If only one variable is defined, the
value of the tuple fields is contained in the iterator. Iterators are always
immutable and never used as references, however this limitation can be easily
couterfeited, using the index iterator to access the tuple.

\begin{code}
let dmut a = (1, 2, 3);
for i, _ in a {
    a.(i) = 9;
}

assert (a == (9, 9, 9));
\end{code}

More information about ~for~ loops is presented in Chapter  [[chap:control_flow]].

* Ranges

Range is a compound type composed of four elements describing the a range of
values. The four element are the following: ~fst~ the first value of the range
(e.g. ~0~), ~scd~ the final value of the range (e.g. ~10~), ~step~ the step of
the range (e.g. ~2~), and ~contains~ of type bool specifiying wether the final
value ~scd~ is include in the range or not. There are only three kind of types
that can be describing the inner components of a range: integer, floating point
and character types. Range type is defined using the inner type followed by the
token ~..~ (e.g. ~i32..~ describes a range on ~i32~ values).

Range are useful for iteration, or accessing a subset of values (for example a
subset of a slice).

** Literals

Range literals are described using the token ~..~ or the token ~...~. The token
~..~ is used to define a range whose final value is not included in the range,
when the ~...~ token defined a range whose final value is included. If different
tokens are used to describe the literal, the type is the same, and the token
~..~ is always the only token used to describe a range type.

\begin{code}
let a : i32.. = 0 .. 2;
let b : i32.. = 0 ... 2;

assert (a.fst == b.fst && a.scd == b.scd && a.step == b.step);
assert (!a.contains && b.contains);
\end{code}

Range values can be decreasing, in that case the step is negative. One can note
that for range on unsigned integers and character values, a negative value for
the step is in theory impossible to have. However there is some cheating
happening here using the limitation of overflowing of the types to create a
value that when added to ~fst~ equals to ~fst - abs (step)~ (in practice this is
exactly the same as adding a negative value at the binary level, but it is not
really the valid high level representation). For that reason one can consider
that step is always a signed version of the type even if the field type is
considered to be the same as the type of the inner values (~fst~ and ~scd~) and
thus that one bit of its encoding is always used for the sign.

** Mutability

As one might expect range values don't borrow any data, and every field
contained in the value is copied during data movement, thus there is no need to
worry about mutability making the type not aliasable. A mutable range can modify
its inner fields. Even if the range type is a compound type, it behave exactly
has a scalar type as it can never contain any borrowed data.


** Properties

Properties on range type can be accessed using the operator ~::~ on a type expression. The properties are the following :

|----------+-----------------------------------------------------------+-------------|
| name     | value                                                     | type        |
|----------+-----------------------------------------------------------+-------------|
|----------+-----------------------------------------------------------+-------------|
| ~init~   | The initial value ranging from ~T::init~ to ~T::init~     | ~typeof(x)~ |
|          | with a step of ~T::init~ and with contains set to ~false~ |             |
|          | where ~T~ is the inner type (e.g. ~i32~ for ~i32..~)      |             |
|----------+-----------------------------------------------------------+-------------|
| ~inner~  | The inner type contained in the range type                | None        |
|          | This property returns a type expression, not a value      |             |
|----------+-----------------------------------------------------------+-------------|
| ~typeid~ | A string encoding the name of the type                    | ~[c8]~      |
| ~sizeof~ | The size in bytes of the type                             | ~usize~     |
|----------+-----------------------------------------------------------+-------------|

** Binary operators

Binary operators are divided into 4 groups :

- Access:

  The operator ~.~ is used to access to the field of the range type. The right
  operand being the name of the field to access. These fields are described in
  the following table.

  |------------+---------------------------------------------+---------------------|
  | name       | value                                       | type                |
  |------------+---------------------------------------------+---------------------|
  |------------+---------------------------------------------+---------------------|
  | ~fst~      | The first value of the range                | ~typeof (x)::inner~ |
  | ~scd~      | The second value of the range               | ~typeof (x)::inner~ |
  | ~step~     | The step of the range                       | ~typeof (x)::inner~ |
  | ~contains~ | The field describing wether or              | ~bool~              |
  |            | not the scd value is contained in the range |                     |
  |------------+---------------------------------------------+---------------------|

  Accessed fields are mutable if and only if the range is mutable.

- Contains :

  The operator ~in~ and ~!in~ are used to check wether a value is contained
  inside a range value. In that case the type of the left operand must be the
  same as the inner type of the right operand, and the type of the right operand
  must be a range type.

  \begin{code}
  let a = 0 .. 7, b = 0 ... 7;

  assert (6 in a);
  assert (7 !in a && 7 in b);
  \end{code}

- Comparison :

  Range are comparable using the operators ~==~ and ~!=~, checking the equality
  (or inequality) of every field of the range. The left and right operand must
  have exactly the same type.

- Affectation :

  A range value can be a lvalue if and only if it is mutable.

  \begin{code}
  let mut a = 0 .. 7;

  a = 7 .. 1;
  \end{code}




* Arrays

arrays

* Slices

slices

* Options

options
