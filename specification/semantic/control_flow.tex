\section{Preamble}

Control flows are generally decided at run time, i.e. the generated machine code
contains a machine-level representation of the control flow, and it is decided
at run time which branches are traversed. These decisions could also be made at
compile time, using the keyword \texttt{cte} for \textit{Compile Time
  Execution}, with some requirements. Since these requirements depend on the
type of control flow construct used, they will be detailed in each specific
section, but they always involve the compiler needing to know some values at
compile time. The \texttt{cte} control flow is consistent with the concept of
conditional compilation introduced in
Chapter~\ref{chap:conditional_compilation}.

\section{Variables, scope and lifetime}
\label{sec:variable_lifetime}

The first construct is a simple scope. Defined by opening and closing curly
braces, a scope determines the lifetime of the variables declared within it.
Variables are declared using the keyword \texttt{let} followed by an identifier
and an optional type (using the token \texttt{:}). The lifetime of a variable
begins when it is declared and ends when the scope containing the variable
declaration is exited. Two variables with the same name cannot be alive at the
same time.

\begin{lstlisting}[style=coloredverbatim]
fn main () { // start of a scope
  let a = 12;
  { // start of a second scope

    println (b + a); // error, /b/ is not defined yet
    let b = 24;

    println (b + a); // Ok, /b/ and a are defined

    let a = 89; // error, /a/ is already defined
  } // exiting the second scope

  println (b + a); // Error, /b/ does not exist anymore
  let b = 9; // ok, /b/ from second scope is not alive anymore
}
\end{lstlisting}

\subsection{Scope value}

As presented in section~\ref{sec:function_body}, a scope has a value if the last
expression contained in the scope is a value and does not end with the
\texttt{;} token. The value can be used as any other expression value (e.g. as
the value of a variable declaration).

\begin{lstlisting}[style=coloredverbatim]
let a = {
  let b = 12;
  b + 12
};

let c = {
  let b = 12;
  b + c // error, /c/ does not exist yet
};
\end{lstlisting}

\subsection{Variable initial value}

A variable is always declared with an initial value. The goal is to ensure that
any data in the program came from somewhere, and is not initialized from a
random memory state of the machine running the program (as we can have in the C
language). One can argue that static verification can be used to ensure that a
variable is set before it is used, and argue that forcing an initial value on a
variable is not the best way to achieve data validity. While this is more a
matter of opinion than sound scientific reasoning at this point, we believe that
scattering the initialization of a variable makes programs harder to read. In
addition, immutable variables would initially be mutable, making the behavior of
a program even more difficult to understand. In the following listings, two
examples of source code with the same behavior are presented. On the left, a
valid source code that is accepted by the Ymir language, and on the right, a
source code that is not accepted based on the arguments we presented.

\hspace{-10pt}%
\begin{minipage}[t][][t]{0.47\linewidth}
  \begin{lstlisting}[style=coloredverbatim, caption=Valid]
fn foo (cond : bool) {
  let i = if cond {
    42
  } else {
    7
  };
}
  \end{lstlisting}
\end{minipage}\hspace{10pt}%
\begin{minipage}[t][][t]{0.47\linewidth}
  \begin{lstlisting}[style=coloredverbatim, caption=Invalid]
fn foo (cond : bool) {
  let i : i32;
  if cond {
    i = 42;
  } else {
    i = 7;
  };
}
  \end{lstlisting}
\end{minipage}


\subsection{Unused variable}

A declared variable has to be used during its lifetime, otherwise the compiler
will send an error, as the variable is useless and only complexify the source
code with dead code.

\begin{lstlisting}[style=coloredverbatim]
{
  let a = 12;
} // error, /a/ is defined but not used
\end{lstlisting}

There are two ways to force the compiler to ignore an unused variable, the first
is to use a special identifier for the variable, either by putting an underscore
at the beginning and end of the variable (e.g. \texttt{\_a\_}), or by naming the
variable directly \texttt{\_}. A variable named \texttt{\_} is anonymous and
cannot be used at all. The second way is to use the variable in a statement.
This statement can be empty (i.e. \texttt{a;}). Function parameters follow the
exact same semantic, and therefore must be used within the body of the function.
They can be used or ignored with the same system as local variables.

\begin{lstlisting}[style=coloredverbatim]
{
  let _a_ = 12;
} // ok, /_a_/ is an ignorable variable

{
  let _ = 12;
} // ok, /_/ is anonymus

{
  let a = 12;
  a; // using the variable
} // ok, all variables were used
\end{lstlisting}

\subsection{Variable type}

The type of the variable is automatically infered from the value that is
associated to it. Sometimes the compiler may fail the inference, or multiple
types can be associated to a specific value by implicit casting. To solve that
problem a type can be attached to a variable declaration using the token
\texttt{:}. The type specified must of course be compatible with the type of the
value.

\begin{lstlisting}[style=coloredverbatim]
let a = 12; // automatically infering i32
let b : i32 = 12; // declaring i32

let c : i64 = 12; // ok, implicit cast to i64
let d : [c8 ; 5] = "Hello"; // ok implicit cast from [c8] to [c8 ; 5]
\end{lstlisting}

Some values needs an explicit type to be used as variable initialization values. For example the value \texttt{none} that creates an empty option values has no inner type on its own. In fact its inner type is deduced from the type of the lvalue that will receive it during affectation. Other types such as \texttt{void} can simply not be used for variable declaration as they do not contain a value. To create a variable with no value, an empty tuple \texttt{()} can be used.

\begin{lstlisting}[style=coloredverbatim]
let a = none; // error, cannot create a variable with type (none)?
let b : (i32)? = none; // ok, type is explicitely defined

let c = {}; // error, cannot create a var of type void
let d : void = {}; // error, even by explicitely writing it

let e = (); // ok empty tuple
let f : () = (); // ok, same as /e/
\end{lstlisting}

\subsection {Variable mutability}

A variable is immutable by default, but can be made mutable using the
\texttt{mut} and \texttt{dmut} keywords. We saw in
Section~\ref{sec:preamble_compound_types} that values can borrow data depending
on their type. Since all the mutability information about specific types has
already been discussed in Chapter~\ref{chap:compound} for native compound types
and in Chapter~\ref{chap:custom_types} for user-defined types, we will not
discuss it further.

Because type mutability is recursive, an inner type can only be mutable if the
type containing it is also mutable, which also means that for a value inside a
variable to be mutable, the variable must also be mutable. This behavior for
local variables is different from that of function parameters, as presented in
Section~\ref{sec:mutable_parameter}.

\begin{lstlisting}[style=coloredverbatim]
let a = 12;
a = 9; // error, /a/ is immutable

let mut b = 12;
b = 9; // ok, /b/ is mutable


let c : [mut i32] // error, /c/ is immutable, its inner value cannot be mutable
      = copy [1, 2, 3];

let mut d : [mut i32]  // ok, /d/ is of type mut [mut i32]
          = copy [1, 2, 3];


let dmut e = copy [1, 2, 3]; // same as /d/

d [0] = 9; // ok
e [0] = 10; // ok

let mut f = copy [1, 2, 3]; // /f/ is of type mut [i32]
f [0] = 0; // error, inner value of /f/ is immutable
f = copy [4, 5]; // ok, /f/ is mutable
\end{lstlisting}

\subsection{Reference variable}

The \texttt{ref} keyword can be used to decorate a variable when constructing it
with the \texttt{let} construct. This decorator is used to specify that a
variable is a reference to another lvalue, it follows exactly the same rules as
presented for reference parameters in Section~\ref{sec:ref_param}. Only lvalues
can be referenced.

\begin{lstlisting}[style=coloredverbatim]
let dmut a = [1, 2, 3];
let ref b = a; // no copy of /a/

println (b [0]); // 1

a [0] = 89;
println (b [0]); // 89

b [0] = 9; // error, b is immutable
\end{lstlisting}

In the above example, \texttt{b} is a pointer to the value of \texttt{a},
meaning that when the value of \texttt{a} changes, so does the value of
\texttt{b}. The following listing shows the YIL representation of the above
code, and Figure~\ref{fig:ref_variable} illustrates the state of the stack when the
program is executed.

\begin{lstlisting}[style=intermediateVerb]
let a(#2) : [i32;3];
let b(#3) : *([i32;3]);
a(#2) = [1, 2, 3];
b(#3) = &a(#2);
_Y3std2io7printlnNi32Fi32Zv(*b(#3)[0]);
a(#2)[0] = 89;
_Y3std2io7printlnNi32Fi32Zv(*b(#3)[0]);
\end{lstlisting}

\input{images/ref_variable}

A reference variable can be mutable as long as the value it references is also
mutable, and the contract has been accepted with the \texttt{ref} keyword. It
follows the same rules presented in Section~\ref{sec:mut_ref_param} for mutable
reference parameters.

\begin{lstlisting}[style=coloredverbatim]
let mut a = 12;
let mut ref b = ref a; // ok

b = 90;
println (a); // 90
\end{lstlisting}

As for mutable reference parameters, the keyword \texttt{ref} is mandatory to
accept the mutable reference contract. This keyword can only be used on an
lvalue. In the next example, the contract is not respected at line 2. At line 5,
even if the variable is an lvalue and the keyword \texttt{ref} is used, because
the mutability of \texttt{c} is not deep enough to fit into the mutability of
the variable \texttt{d}, the compiler sends an error.

\begin{lstlisting}[style=coloredverbatim]
let mut a = 12;
let mut ref b = a; // error, mutable reference requires ref keyword

let mut c : [i32] = copy [1, 2, 3];
let dmut ref d = ref c; // error, cannot fit mut [i32] into mut [mut i32]
\end{lstlisting}

\section{Conditional branching}%
\label{sec:if_else}

A conditional control flow can be defined using the keywords \texttt{if} and
\texttt{else}. The syntax \texttt{if C V} defines that the value \texttt{V} is
evaluated if and only if the condition \texttt {C} of type \texttt {bool} is
true. Using the keyword this construction can be extended to provide another
value to evaluate if the condition is not met.

\begin{lstlisting} [style=coloredverbatim]
fn foo (cond : bool)-> i32 {
  if cond {
    89
  } else {
    11
  }
}

let x = foo (true); // /x/ evaluated to 89
let y = foo (false); // /y/ evaluated to 11
\end{lstlisting}

A \texttt{if} construct has a value if all branches have a value. All branches
must also construct a value of compatible type. The common type is inferred by
the compiler using the infer type branching algorithm defined in
Listing~\ref{lst:infer_type_branching}.

\begin{lstlisting}[style=coloredverbatim]
fn foo (cond : bool, cond2 : bool) {
  let a = if cond { 12 }; // error, no else value

  let b = if cond { 12 } else { "str" }; // error, incompatible i32 and [c8]

  let c = if cond { 12 } else if cond2 { 8 }; // error, no else value
  let d = if cond { 12 } else { 11 }; // ok
}
\end{lstlisting}

\section{Infinite loop}%
\label{sec:inf_loop}

\section{Conditional loop}%
\label{sec:while_loop}

\section{Iteration loop}%
\label{sec:for_loop}

\section{List comprehension}%
\label{sec:list_compr}

\section{Disposing block}%
\label{sec:with_block}

\section{Scope guards}%
\label{sec:scope_guards}
