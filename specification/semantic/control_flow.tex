\section{Preamble}

Control flows are generally determined dynamically at runtime, where the machine
code generated contains instructions for the control flow, and the specific
branches to traverse are decided during program execution. However, it is
possible to make these decisions statically at compile time using the keyword
\token{cte} for \textit{Compile Time Execution}, subject to certain
requirements. These requirements vary depending on the type of control flow
construct used, and they entail the compiler needing to possess specific values
at compile time. The utilization of cte control flow aligns with the concept of
conditional compilation introduced in
Chapter~\ref{chap:conditional_compilation}.


\section{Variables, scope and lifetime}
\label{sec:variable_lifetime}

The first construct is a simple scope. Defined by opening and closing curly
braces, a scope determines the lifetime of the variables declared within it.
Variables are declared using the keyword \token{let} followed by an identifier
and an optional type (using the token \token{:}). The lifetime of a variable
begins when it is declared and ends when the scope containing the variable
declaration is exited. Two variables with the same name cannot be alive at the
same time.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
fn main () { // start of a scope
  let a = 12;
  { // start of a second scope

    println (@\hb{b}@ + a); // error, /b/ is not defined yet
    let b = 24;

    println (b + a); // Ok, /b/ and a are defined

    let @\hb{a}@ = 89; // error, /a/ is already defined
  } // exiting the second scope

  println (@\hb{b}@ + a); // Error, /b/ does not exist anymore
  let b = 9; // ok, /b/ from second scope is not alive anymore
}
\end{lstlisting}

\subsection{Scope value}

As presented in section~\ref{sec:function_body}, a scope has a value if the last
expression contained in the scope is a value and does not end with the
\token{;} token. The value can be used as any other expression value (e.g. as
the value of a variable declaration).

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
let a = {
  let b = 12;
  b + 12
};

let c = {
  let b = 12;
  b + @\hb{c}@ // error, /c/ does not exist yet
};
\end{lstlisting}

\subsection{Variable initial value}

A variable is always declared with an initial value. The goal is to ensure that
any data in the program came from somewhere, and is not initialized from a
random memory state of the machine running the program (as we can have in the C
language). One can argue that static verification can be used to ensure that a
variable is set before it is used, and argue that forcing an initial value on a
variable is not the best way to achieve data validity. While this is more a
matter of opinion than sound scientific reasoning at this point, we believe that
scattering the initialization of a variable makes programs harder to read. In
addition, immutable variables would initially be mutable, making the behavior of
a program even more difficult to understand. In the following listings, two
examples of source code with the same behavior are presented. On the left, a
valid source code that is accepted by the Ymir language, and on the right, a
source code that is not accepted based on the arguments we presented.

\hspace{-15pt}%
\begin{minipage}[t][][t]{0.47\linewidth}
  \begin{lstlisting}[style=coloredverbatim, escapechar=@, caption=Valid]
fn foo (cond : bool) {
  let i = if cond {
    42
  } else {
    7
  };
}
  \end{lstlisting}
\end{minipage}\hspace{10pt}%
\begin{minipage}[t][][t]{0.47\linewidth}
  \begin{lstlisting}[style=coloredverbatim, escapechar=@, caption=Invalid]
fn foo (cond : bool) {
  let i : i32;
  if cond {
    i = 42;
  } else {
    i = 7;
  };
}
  \end{lstlisting}
\end{minipage}


\subsection{Unused variable}
\label{sec:unused_variables}

A declared variable has to be used during its lifetime, otherwise the compiler
will send an error, as the variable is useless and only complexify the source
code with dead code.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
{
  let a = 12;
@\hb{\}}@ // error, /a/ is defined but not used
\end{lstlisting}

There are two ways to force the compiler to ignore an unused variable, the first
is to use a special identifier for the variable, either by putting an underscore
at the beginning and end of the variable (e.g. \token{\_a\_}), or by naming the
variable directly \token{\_}. A variable named \token{\_} is anonymous and
cannot be used at all. The second way is to use the variable in a statement.
This statement can be empty (i.e. \token{a;}). Function parameters follow the
exact same semantic, and therefore must be used within the body of the function.
They can be used or ignored with the same system as local variables.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
{
  let _a_ = 12;
} // ok, /_a_/ is an ignorable variable

{
  let _ = 12;
} // ok, /_/ is anonymus

{
  let a = 12;
  a; // using the variable
} // ok, all variables were used
\end{lstlisting}

\subsection{Variable type}

The type of the variable is automatically infered from the value that is
associated to it. Sometimes the compiler may fail the inference, or multiple
types can be associated to a specific value by implicit casting. To solve that
problem a type can be attached to a variable declaration using the token
\token{:}. The type specified must of course be compatible with the type of the
value.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
let a = 12; // automatically infering i32
let b : i32 = 12; // declaring i32

let c : i64 = 12; // ok, implicit cast to i64
let d : [c8 ; 5] = "Hello"; // ok implicit cast from [c8] to [c8 ; 5]
\end{lstlisting}

Some values needs an explicit type to be used as variable initialization values. For example the value \token{none} that creates an empty option values has no inner type on its own. In fact its inner type is deduced from the type of the lvalue that will receive it during affectation. Other types such as \token{void} can simply not be used for variable declaration as they do not contain a value. To create a variable with no value, an empty tuple \token{()} can be used.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
let @\hb{a = none;}@ // error, cannot create a variable with type (none)?
let b : (i32)? = none; // ok, type is explicitely defined

let @\hb{c = {};}@ // error, cannot create a var of type void
let @\hb{d : void = {};}@ // error, even by explicitely writing it

let e = (); // ok empty tuple
let f : () = (); // ok, same as /e/
\end{lstlisting}

\subsection {Variable mutability}

A variable is immutable by default, but can be made mutable using the
\token{mut} and \token{dmut} keywords. We saw in
Section~\ref{sec:preamble_compound_types} that values can borrow data depending
on their type. Since all the mutability information about specific types has
already been discussed in Chapter~\ref{chap:compound} for native compound types
and in Chapter~\ref{chap:custom_types} for user-defined types, we will not
discuss it further.

Because type mutability is recursive, an inner type can only be mutable if the
type containing it is also mutable, which also means that for a value inside a
variable to be mutable, the variable must also be mutable. This behavior for
local variables is different from that of function parameters, as presented in
Section~\ref{sec:mutable_parameter}.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
let a = 12;
@\hb{a = 9;}@ // error, /a/ is immutable

let mut b = 12;
b = 9; // ok, /b/ is mutable


let @\hb{c : [mut i32]}@ // error, /c/ is immutable, its inner value cannot be mutable
           = copy [1, 2, 3];

let mut d : [mut i32]  // ok, /d/ is of type mut [mut i32]
          = copy [1, 2, 3];


let dmut e = copy [1, 2, 3]; // same as /d/

d [0] = 9; // ok
e [0] = 10; // ok

let mut f = copy [1, 2, 3]; // /f/ is of type mut [i32]
@\hb{f [0] = 0;}@ // error, inner value of /f/ is immutable
f = copy [4, 5]; // ok, /f/ is mutable
\end{lstlisting}

\subsection{Reference variable}

The \token{ref} keyword can be used to decorate a variable when constructing it
with the \token{let} construct. This decorator is used to specify that a
variable is a reference to another lvalue, it follows exactly the same rules as
presented for reference parameters in Section~\ref{sec:ref_param}. Only lvalues
can be referenced.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
let dmut a = [1, 2, 3];
let ref b = a; // no copy of /a/

println (b [0]); // 1

a [0] = 89;
println (b [0]); // 89

@\hb{b [0] = 9;}@// error, /b/ is immutable
\end{lstlisting}

In the above example, \token{b} is a pointer to the value of \token{a},
meaning that when the value of \token{a} changes, so does the value of
\token{b}. The following listing shows the YIL representation of the above
code, and Figure~\ref{fig:ref_variable} illustrates the state of the stack when the
program is executed on a 64-bits system.

\begin{lstlisting}[style=intermediateVerb]
let a(#1) : [i32;3];
let b(#2) : *([i32;3]);
a(#1) = [1, 2, 3];
b(#2) = &a(#2);
_Y3std2io7printlnNi32Fi32Zv(*b(#2)[0]);
a(#1)[0] = 89;
_Y3std2io7printlnNi32Fi32Zv(*b(#2)[0]);
\end{lstlisting}

\input{images/ref_variable}

A reference variable can be mutable as long as the value it references is also
mutable, and the contract has been accepted with the \token{ref} keyword. It
follows the same rules presented in Section~\ref{sec:mut_ref_param} for mutable
reference parameters.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
let mut a = 12;
let mut ref b = ref a; // ok

b = 90;
println (a); // 90
\end{lstlisting}

As for mutable reference parameters, the keyword \token{ref} is mandatory to
accept the mutable reference contract. This keyword can only be used on an
lvalue. In the next example, the contract is not respected at line 2. At line 5,
even if the variable is an lvalue and the keyword \token{ref} is used, because
the mutability of \token{c} is not deep enough to fit into the mutability of
the variable \token{d}, the compiler sends an error.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
let mut a = 12;
let @\hb{mut ref b = a;}@ // error, mutable reference requires ref keyword

let mut c : [i32] = copy [1, 2, 3];
let @\hb{dmut ref d = ref c;}@ // error, cannot fit mut [i32] into mut [mut i32]
\end{lstlisting}


\subsection{Pattern variable declaration}
\label{sec:pattern_vdecl}

Variable declaration can be done using a pattern instead of a single variable
declaration. Available patterns are fully described in
Section~\ref{sec:pattern_matching} about pattern matching. If the pattern is
irrefutable (the condition to match the pattern is known at compile time and is
always true), then the variables defined within the pattern can be declared.
Patterns can be used for many things, such as deconstructing tuples, arrays,
accessing class fields, etc.
\begin{lstlisting}[style=coloredverbatim, escapechar=@, caption=Tuple deconstruction]
let t = (1, 't', 12.0f);
let (x, y, z) = t;
let (w, _...) = t; // taking only the first value, ignoring the rest
\end{lstlisting}

\begin{lstlisting}[style=coloredverbatim, escapechar=@, caption=Array deconstruction]
let a = [1, 2, 3];
let [i, j, k] = a;
let [l, m, _...] = a; // taking only the first two values ignoring the rest
\end{lstlisting}

\begin{lstlisting}[style=coloredverbatim, caption=Class field access]
class A {
  pub let i : i32;
  pub self (i : i32) with i = i {}

  @field
  pub fn len (self)-> i32 {
    2
  }
}

let a = A::new (1);
let A (i-> x, len-> y) = a;

assert (x == a.i && y == a.len);
\end{lstlisting}

The lifetime of variables declared using pattern variable declaration is the
same as that of variables declared using standard declaration. In fact, there is
no standard declaration, a variable declared with the syntax \token{let a : i32
  = 12} uses the pattern \token{a : i32} with the matching value \token{12}
and is therefore irrefutable.

Refutable patterns (that are unknown at compile time) must be coupled with
conditional branching (cf. Section~\ref{sec:if_else}) as they may or may not
create new variables depending on the result of the pattern evaluation.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
fn foo ()-> i32?;

let @\hb{Ok (x : i32) = foo ();}@ // error, refutable since it may fail if /foo/ returns /none/
\end{lstlisting}

\subsection{Pattern variable mutability and references}

The value that is passed to pattern must respect mutability of borrowed values,
and therefore as any data movement must use the keyword \token{alias} to
perform mutable borrowed data movement. Because the keyword is recursive, an
inside pattern deconstruction may impact mutable access to inner values. In the
next example, the variable \token{a} has mutable access to borrowed data from
\token{t}, when the variable \token{b} has only const access to its second
field, however the keyword \token{alias} has to be used over the value
\token{t} to allow mutable access from \token{a}.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
let dmut t = (copy [1, 2], copy [2, 3]);
let (dmut a : [i32], b : [i32]) = alias t;
//     /alias/ is mandatory here  ^^^^^

a [0] = 9;
t.1 [0] = 9;
println (t); // ([9, 2], [9, 3])
println (b); // [9, 3]
\end{lstlisting}

As for any variable declaration the keyword \token{ref} can be used to create a
reference to a lvalue. In that case, instead of the keyword \token{alias}, the
keyword \token{ref} has to be used to decorate the value that is being
referenced. In the next example, the variable \token{a} is a reference to the
first field of the tuple value stored in \token{t}.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
let dmut t = (copy [1, 2], copy [2, 3]);
let (dmut ref a : [i32], _) = ref t;

a = copy [9, 8, 7];
println (t); // ([9, 8, 7], [2, 3]);
\end{lstlisting}

When values to variable associations are a mix of aliases and references, the
keyword \token{ref} must be used, in this unique case it allows for mutable
\token{alias}. The \token{alias} keyword can never be used to create a mutable
reference. In the next example, the variable \token{a} is a mutable reference
to the first field of the value stored in \token{t}, and the variable
\token{b} mutably borrows the same value as the second field of \token{t}. In
this case, a mutable reference and a mutable alias are created at the same time,
so the keyword \token{ref} is used to decorate the associated value to allow
this. However, in line \token{4}, the use of the keyword \token{ref} is not
allowed, since neither \token{c} nor \token{d} create a reference, the keyword
\token{alias} must be used.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
let dmut t = (copy [1, 2], copy [2, 3]);
let (dmut ref a, dmut b) = ref t; // ok, /ref/ replaces /alias/ in that case

let (dmut c, dmut d) = @\hb{ref}@ t; // error, no mutable references needed, thus /alias/ has to be used
\end{lstlisting}

If there is no mutable alias and no mutable reference, then the keyword is not
allowed to decorate the associated value, to avoid using the keywords by default
resulting in the opposite of their purpose (helping developers to easily spot
the locations of mutable memory movements, and possible side effects).

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
let dmut t = (copy [1, 2], copy [2, 3]);
let (a, b) = @\hb{alias}@ t; // error, /alias/ is useless
let (c, d) = @\hb{ref}@ t; // error, /ref/ is useless
\end{lstlisting}

\section{Conditional branching}%
\label{sec:if_else}

A conditional control flow can be defined using the keywords \token{if} and
\token{else}. The syntax \token{if C V} defines that the value \token{V} is
evaluated if and only if the condition \token {C} of type \token {bool} is
true. Using the keyword \token{else} this construction can be extended to
provide another value to evaluate if the condition is not met. The if condition
at line 2 in the next example generates a runtime conditional representation
that can be represented by the flow graph presented in
Figure~\ref{fig:if_cond_simple}, or by the YIL code in
Listing~\ref{lst:if_cond_simple}.

\begin{lstlisting} [style=coloredverbatim, escapechar=@]
fn foo (cond : bool)-> i32 {
  if cond {
    89
  } else {
    11
  }
}

let x = foo (true); // /x/ evaluated to 89
let y = foo (false); // /y/ evaluated to 11
\end{lstlisting}


\begin{lstlisting}[style=intermediateVerb, caption=Simple condition, label=lst:if_cond_simple]
frame :  _Y4main3fooFbZi32 (let cond(#1) : u8)-> i32 {
    let YI_2(#2) : i32;
#IF cond(#1)
#THEN_GOTO then(#1)
#ELSE_GOTO else(#3);
#LABEL then(#1);
    YI_2(#2) = 89;
#GOTO end(#2);
#LABEL else(#3);
    YI_2(#2) = 11;
#GOTO end(#2);
#LABEL end(#2);
    return YI_2(#2);
}
\end{lstlisting}

\input{images/if_cond_simple}

Conditional branching can be applied to any test that produces a \token{bool}
value that is unknown at compile time. However, they are not allowed if the
condition can be determined at compile time, as they would only complicate the
source code with useless control flows that can be determined statically. For
example, in the following code on line 2, the condition is always \token{true},
so the condition is useless and the code on line 3 is always evaluated, in
addition, on line 5 the condition is always \token{false}, creating dead code
that is never evaluated.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
let a = [1, 2, 3];
if (@\hb{a.len <= 3}@) { // error, len of /a/ is /cte/
  println (a [2]);
}

if (a.len >= 4) {
  @\hb{println (a [3]);}@ // error, dead code
}
\end{lstlisting}

\subsection {Conditional value}
\label{sec:cond_value_type}

A \token{if} construct has a result value if all branches have a result value.
The type of the expression is the type of the first branch, i.e. the type of the
value of the first \token{if}. The value of the \token{else} branch is
implicitly cast to the type of the first branch value, if this is not possible
the compiler returns an error.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
let a = if cond {
  12
@\hb{\};}@ // error, no else value

let b = if cond {
  12
} else {
  "str"
@\hb{\};}@ // error, incompatible i32 and [c8]

let d = if cond {
  12
} else {
  11u32
}; // ok, implicit cast of 11u32 to i32
\end{lstlisting}

\subsection{Mutable conditional value}

If the type of the \token{else} branch is compatible with the type of the first
branch, but does not match its mutability, the mutability of the result value of
the \token{if} construct is reduced to match the most restricted value. In the
next example, because the value of the \token{else} branch has a more
restricted mutability than the value of the \token{if} branch, the result type
of the expression takes the mutability of the \token{else} branch, and thus the
result value is of type \token{mut [i32]}.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
let a = copy [1, 2, 3];
let @\hb{dmut b = if cond \{}@// error, mutability does not fit in /b/
  copy [2, 3, 4] // mut [mut i32]
} else {
  a
\hb{\};}@ // mut [i32]
\end{lstlisting}

As for scope values when returning a mutable borrowed value, because
the \token{alias} contract is already accepted within the value of the
branches, it is not necessary to accept it again for the result value of the
\token{if} construct. Therefore, in the next example, the keyword
\token{alias} is not used before the keyword \token{if}, even though the
affectation to \token{b} moves borrowed mutable data.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
fn foo (cond : bool) {
  let dmut a = copy [1, 2, 3];
  let dmut b = if cond {
    alias a // alias is mandatory here
  } else {
    copy [2, 3, 4]
  };
}
\end{lstlisting}


\subsection{Chaining conditions}

Conditions can be chained by following the \token{else} with another
\token{if} condition. In fact, this does not really chain the condition, since
in this case the \token{if} condition following the \token{else} keyword is
the value that is evaluated in case the condition of the first \token{if} is
not true. To illustrate, the following source code presents two chained
\token{if} conditions that are exactly similar in semantics.


\begin{minipage}[t][][t]{0.47\linewidth}
\begin{lstlisting}[style=coloredverbatim, escapechar=@, caption=Using a \token{if} as the value of the \token{else} branch]
if cond {
  println ("First condition is true");
} else if cond2 {
  println ("Second condition is true");
} else {
  println ("None of the conditions were true");
}
\end{lstlisting}
\end{minipage}\hspace{10pt}%
\begin{minipage}[t][][t]{0.47\linewidth}
  \begin{lstlisting}[style=coloredverbatim, escapechar=@, caption=Using a block as the value of the \token{else} branch]
if cond {
  println ("First condition is true");
} else {
  if cond2 {
    println ("Second condition is true");
  } else {
    println ("None of the conditions were true");
  }
}
  \end{lstlisting}
\end{minipage}
\vspace{-10pt}%

\subsection{Early return branch}

We have seen in Section~\ref{sec:function_early_return} that a function can exit
early in three different ways (i.e., \token{return}, \token{throw}, or
\token{panic}). Such an early exit can happen inside a branch of a conditional
value. In this case, that particular branch is considered a return branch and
therefore has no value. In Section~\ref{sec:inf_loop} we will see a construction
that can also exit a branch of the flow graph without constructing a value (i.e.
\token{break}). As a result, the \token{if} construction can sometimes have a
result value even though not all branches construct a value.

%\smallskip

\input{images/if_cond_early_return}

\begin{lstlisting}[style=coloredverbatim, caption=Early return in \token{if} condition, label=lst:if_cond_early_return]
fn foo (cond : bool)-> i32 {
  let a = if cond {
    return 89; // exits the function
  } else {
    10
  }; // ok, all non-returning branches have a value

  a + 9
}
\end{lstlisting}

In the example presented in Listing~\ref{lst:if_cond_early_return}, the value of
the variable \token{a} can be constructed. In fact, if the condition is not
true, the value of \token{a} will be 10, and if the condition is true, then the
function exits, so the value of \token{a} does not need to be evaluated in this
case. Figure~\ref{fig:if_cond_early_exit} shows the flow graph resulting from
this source code. You can clearly see from this graph that in the flow that the
first branch follows (when the condition is met), the variable \token{a} is
never needed, and therefore does not need to be constructed for the code to be
correct.


\subsection {Conditional pattern}
\label{sec:cond_pattern}

We have seen in Section~\ref{sec:pattern_vdecl} that variables can be declared
using a pattern, and that the pattern might be refutable and needing runtime
validation. In that case, the pattern has to be coupled with a conditional
branch representation using the syntax \token{if let Pattern = Value V}, as
presented in the next example.

\input{images/if_cond_let_Ok}

\begin{lstlisting}[style=coloredverbatim, label=lst:if_cond_let_Ok, caption=Example of conditional pattern]
fn foo ()-> i32?;

if let Ok (x : i32) = foo () {
  println ("Foo returned the value : ", x);
}
\end{lstlisting}

In the previous example, the function \token{foo} could return a \token{none}
value, but the code would still be safe because the conditional ensures that the
variable \token{x} is created if and only if the function actually returns a
value. This example produces the YIL representation shown in
Figure~\ref{fig:if_cond_let_Ok}, as you can see the variable \token{x} is
actually created only if the value returned by \token{foo} is set. All kinds of
patterns can be used for conditional pattern declarations, those are described
in Section~\ref{sec:pattern_matching}.


Pattern conditional branching can be used for any pattern that requires run-time
validation, but is not allowed for patterns that are irrefutable (or always
wrong), as it would just make the code unnecessarily complex.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
let a = (1, 2, 3);

if @\hb{let (x, y, z) = a \{}@ // error, pattern is irrefutable
  println (x, ' ', y, ' ', z);
}
\end{lstlisting}

\subsubsection{Conditional pattern guard}

As we will see in the presentation of patterns in
Section~\ref{sec:pattern_matching}, using an identifier within a pattern
declares a new variable that must not be shadowed by another variable with the
same name. For example, in the next listing at line 4, the compiler returns an
error because the pattern declares a new variable \token{x} rather than
evaluating for equality, as it does in the second pattern condition at line 10.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
fn foo ()-> i32?;

let x = 2;
if let Ok (@\hb{x}@) = foo () { // error, shadowing declaration of /x/
  println ("foo () == ", x);
} else {
  println ("Either foo () returned none, or != x");
}

if let Ok (2) = foo () { // ok, value equality test
  println ("foo () returned the value 2")
}
\end{lstlisting}

To solve this problem, and to allow comparison with variables within pattern
matching, the pattern guard was introduced. The pattern guard allows two test
conditions in one line, using the token \token{\&\&} at the end of the syntax
\token{if let Pattern = Value \&\& Test V} to add an extra condition in which the
variables declared within the pattern are accessible. In the next example, the
declaration of the variable \token{y} does not overshadow any other variable and
can therefore be used to compare the value returned by \token{foo} with the
value stored in the variable \token{x} inside the pattern guard. Unlike a second
conditional branch, as presented in
Listing~\ref{lst:using_second_cond_no_guard}, the pattern guard allows the
\token{else} value to be evaluated in case the pattern guard test fails, and
therefore makes writing code easier and less redundant.

\notebox{ Because the pattern guard is introduced by the token \token{\&\&},
  operators of equal and lower precedence (e.g. \token{=}, \token{+=},
  \token{||}, ...) cannot be used directly inside the value accepted by the
  pattern and must be enclosed in parentheses (e.g. \token{if let Ok (x) = (foo ()
    || bar () \&\& baz ())? \&\& guard}).}


\begin{lstlisting}[style=coloredverbatim, caption=Using a pattern guard]
let x = 2;

if let Ok (y) = foo () && y == x {
  println ("foo () returned the value ", y, " which is equal to ", x);
} else {
  println ("Either none, or y != x");
}
\end{lstlisting}

\begin{lstlisting}[style=coloredverbatim, caption=Using a second condition instead of pattern guard, label=lst:using_second_cond_no_guard]
if let Ok (y) = foo () {
  if (y == x) {
    println ("foo () returned the value ", y, " which is equal to ", x);
  } else {
    println ("y != x");
  }
} else {
  println ("foo () returned none");
}
\end{lstlisting}

\section{Infinite loop}%
\label{sec:inf_loop}

A loop can be defined with the keyword \token{loop}. A loop defined with this
keyword is an infinite loop that never stops unless it is broken with the
\token{break} keyword or terminated by an early function exit (i.e., returning
with the \token{return} keyword, throwing an exception, or panicking). This type
of loop can be useful for managing operations that have no real defined end
(e.g. a worker thread waiting for new tasks, a TCP server waiting for new
connections).

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
loop {
  println ("I will print this message indefinitely");
}
\end{lstlisting}

\subsubsection{Breaking a loop}
\label{sec:breaking_loops}

A break statement with the keyword \token{break} stops loop iterations and exits
its scope. The break statement only breaks one level of the loop, so if multiple
levels of loops are wrapped, then only the lowest level of the loop is broken,
and the iterations of the higher level loops continue. In the following example,
the output result of execution will be a sequence of pairs of \textit{Inner
  Loop} and \textit{Outer Loop}, as the inner loop will only iterate once before
breaking and returning to the upper loop.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
loop {
  loop {
    println ("Inner Loop");
    break;
  }
  println ("Outer Loop");
}
\end{lstlisting}

Any statement after an irrefutable break branch is inaccessible, so the compiler
will raise an error if dead code is found after a break statement.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
loop {
  break;
  println ("Post break"); // error, unreachable statement
}

println ("After loop"); // ok, break only breaks the loop, it does not exit the function
\end{lstlisting}

\subsection {Infinite loop value}

As mentioned earlier, an infinite loop can be broken using the \token{break}
keyword. The break construction can be associated with a value, this value will
be the value taken by the loop after exiting. If multiple breaks are defined in
the loop, they must all produce a value of compatible type. The type of the
loop's value is determined in the same way as the type of the value of an if
condition, by checking all possible branches and calculating the most common
type (cf. Section~\ref{sec:cond_value_type}). The control flow of the next
Listing~\ref{lst:simple_loop_break} is illustrated in
Figure~\ref{fig:simple_loop_break}.

\begin{lstlisting}[style=coloredverbatim, label=lst:simple_loop_break, caption=Breaking a loop with a value]
let mut count = 0;

let x = loop {
  if (count == 10) {
    break count + 1;
  }

  count += 1;
};

assert (x == 11);
\end{lstlisting}

\input{images/simple_loop_break}


In the next example, since the two values declared by the break
constructions are compatible but not equivalent, the type of the breaks is
implicitly cast to \token{\&A}, with the compiler defining the most common type
between the two breaks as the ancestor of the class objects. The same operations
would be done for other compatible types, such as int, char literals with
compatible but not equivalent types.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
class A {
  pub self () {}
}

class B over A {
  pub self () {}
}

class C over A {
  pub self () {}
}

let mut count = 0;
let x = loop {
  if count == 1 {
    break B::new ();
  } else if count = 10 {
    break C::new ();
  }

  count += 1;
};
\end{lstlisting}


\subsubsection {Mutable loop value}

As with the conditional value, the value of a loop construction can be made
mutable. If multiple breaks are defined within the loop, the mutability of the
type of the loop value is reduced to the most restricted mutability among the
break values. In the following example, the mutability of the value on line 8 is
more restricted than the value on line 6, so the mutability of the type of the
loop is the same as that of the break value on line 8.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
let mut count = 1;
let a = copy [2, 3, 4];

let x = loop {
  if count == 1 {
    break copy [1, 2, 3];
  } else if count == 10 {
    break a;
  }

  count += 1;
};
\end{lstlisting}

Since the mutability of the loop value is the same as the mutability of the most
restricted value among the break values, it can borrow mutable data and must
therefore respect the contract of mutable memory movement as defined for scope
values. No \token{alias} is needed above the loop itself, as this has
necessarily already been done on the break values.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
let mut count = 0;
let dmut a = copy [1, 2, 3];

let dmut x = loop { // no need for explicit /alias/
  if count == 10 {
    break alias a; // /alias/ is mandatory here
  }

  count += 1;
};
\end{lstlisting}

\section{Conditional loop}%
\label{sec:while_loop}

Conditional loops continue iterating as long as a specified condition remains
true. They are initialized with the keyword \token{while} and follow the syntax
\token{while C V}, where \token{C} represents the condition that must be
satisfied, and \token{V} is the value evaluated while the condition remains
true. Similar to conditional branching, the condition \token{C} must be of type
\token{bool}. The following example showcases a while loop that iterates five
times before exiting. Its control flow is illustrated in
Figure~\ref{fig:simple_while_loop}

\begin{lstlisting}[style=coloredverbatim, caption=Simple while loop, label=lst:simple_while_loop]
let mut count = 0;

while count < 5 {
  count += 1;
}

assert (count == 5);
\end{lstlisting}

\input{images/simple_while_loop}

\subsection{Do-while loop}
\label{sec:do_while_loop}

While loops are activated if the associated condition is true from the outset.
In contrast, do-while loops, first execute the loop body before evaluating the
loop condition. This guarantees that the loop body runs at least once,
irrespective of whether the condition is initially false. Do-while loops are
defined with the syntax \token{do V while C;}, where \token{V} represents the
value evaluated upon entering the loop, and \token{C} is the condition that
halts the loop when it evaluates to \token{false}.

\begin{lstlisting}[style=coloredverbatim, caption=Simple do while loop, label=lst:simple_do_while_loop]
let mut count = 0;

do {
  count += 1;
} while count < 5;

assert (count == 5);
\end{lstlisting}

\input{images/simple_do_while_loop}

\subsection{While-let loop}
\label{sec:while_let_loop}

In conditional branching, as discussed in Section~\ref{sec:cond_pattern}, a
pattern can serve as the condition. This capability, similar to its usage in if
conditionals, is available for while loops. However, it is not applicable for
do-while loops. In the following given example, the loop continues as long as
the option contained within the variable \token{x} holds a value and halts
either when it doesn't hold a value or when its value exceeds \token{5}. The
code presented in Listing~\ref{lst:while_let_rewritten} exhibits identical
behavior, albeit implemented using a loop construct and an if let conditional,
as the compiler rewrites the code from Listing~\ref{lst:while_let_example}.

\begin{lstlisting}[style=coloredverbatim, caption=While-let example, label=lst:while_let_example]
fn foo (i : i32)-> i32?;

let mut x = foo (0);
let mut count = 0;

while let Ok (z) = x && z < 5 {
  count += 1;
  x = foo (count);
}
\end{lstlisting}

\begin{lstlisting}[style=coloredverbatim, caption=While-let rewritten using loop and if-let, label=lst:while_let_rewritten]
fn foo (i : i32)-> i32?;

let mut x = foo (0);
let mut count = 0;

loop {
  if let Ok (z) = x && z < 5 {
    count += 1;
    x = foo (count);
  } else break;
}
\end{lstlisting}

As one might expect, since while-let is merely a syntactic transformation into a
loop over an if pattern condition, all the pattern and guard systems discussed
in Section~\ref{sec:cond_pattern} are applicable to the while-let construction.

\subsection{While loop value}

While loops don't inherently produce any values, as there's no assurance that
the loop will be entered and a value constructed. Conversely, do-while loops are
guaranteed to be entered at least once, potentially allowing for a value to be
constructed. However, to maintain consistency with basic while loops, it was
decided not to allow value construction from do-while loops. In essence, only
infinite loops defined with the \token{loop} keyword have the capability to
construct a value. As a consequence, a \textit{break} statement within a
\textit{while} or \textit{do-while} loop cannot be linked with a value and must
always yield a \token{void} result.

\section{Iteration loop}%
\label{sec:for_loop}

The keyword \token{for} initiates an iteration loop that traverses over a value.
As discussed in Chapter~\ref{chap:compound}, certain values such as arrays,
tuples, and slices can be iterated over using variables. The syntax of a
\textit{for} loop is as follows: \token{for i, j,... in V}, where \token{i, j,
  ...} represents a list of variable declarations, and \token{V} denotes the
value being iterated over. For loops are applicable to some native compound
types and to custom class types that implement the \textit{for loop} operator,
as detailed in Chapter~\ref{sec:class_override_for_loop}.

For clarity, throughout the rest of this section, the variable representing the
value at the current iteration will be denoted as a \textit{value iterator},
typically depicted by the variable \textit{v}. Similarly, the variable holding
the index will be termed an \textit{index iterator}, usually depicted by the
variable \textit{i}.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
let a = copy [1, 2, 3];

for i, v in a {
  println ("Value at index : ", i , " equals to : ", v);
}
\end{lstlisting}

The type of the iterator is automatically inferred, but it can be explicitly
specified by appending the token \token{:} followed by the desired type.
However, the specified type must match the type that would have been inferred.
The primary purpose of explicitly specifying the type is to allow for mutability
modifications.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
let a = copy [1, 2, 3];

for i : usize, v : i32 in a {
  println ("Value at index : ", i , " equals to : ", v);
}
\end{lstlisting}

The index iterator is inherently immutable, meaning decorators cannot be
attached to its declaration. Index iterators are accessible for all iterable
native compound types, such as range, tuple, array, and slices. For tuples,
slices, and arrays, a single iterator serves as the value iterator by default.
However, if two iterators are defined, the first one is the index iterator,
while the second one becomes the value iterator. Conversely, for ranges, only
one iterator can be declared, and it acts as the index iterator.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
for i in 0 .. 10 {
  println ("Index iteration : ", i);
}

for v in [1, 2, 3] {
  println ("Value iteration : ", v);
}

for i, v in [1, 2, 3] {
  println ("Value and index iteration : ", i, ' ', v);
}
\end{lstlisting}

\subsection {Mutable value iterator}

In line with any variable declaration, the value iterator is initially immutable
by default. However, it can be rendered mutable by using the keywords
\token{mut} or \token{dmut}. Because iterators index the values being iterated,
they don't behave like typical variables but rather resemble function
parameters. As discussed in Section~\ref{sec:mutable_parameter}, even though
function parameters can be mutable, they aren't \textit{lvalues} unless they're
reference parameters. This is because completely altering their value would
change the memory address of the value they're borrowing, thereby having no
impact on the initially assigned value.

For the same reason, value iterators can only be mutable if they are associated
with mutable borrowed data, explicitly aliased to them. In the following
example, the variable \token{v} is mutable and borrows the same memory segments
as the elements contained in \token{a[i]}. Because it is mutable, it can modify
the values that are borrowed but cannot be completely changed.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
let dmut a = dcopy [[1, 2], [3, 4]];
for dmut v in alias a {
  v [0] = 10; // ok, aliasing /a/
  @\hb{v = copy [8, 9];}@ // error, /v/ is not a lvalue
}

assert (a [0][0] == 10);
\end{lstlisting}

Because value iterators are not lvalues, they cannot be mutable if they do not
borrow mutable data. Without access to mutable elements to modify, the
mutability of the variable would be pointless, as it would have no effect on the
iterated value.

\begin{lstlisting}[style=coloredverbatim, escapechar=@, caption=Useless mutable iterator, label=lst:useless_mut_iterator]
let dmut a = copy [1, 2, 3];
for @\hb{mut}@ v in alias a { // error, x cannot be mutable, it does not borrow mutable data
  @\hb{v = 1;}@ // would have no effect on /a/
}
\end{lstlisting}

\subsection{Reference iterators}

The \token{ref} keyword can be applied as a decorator to the value iterator.
This decorator alters the behavior of the iterator, providing reference access
to the values being iterated rather than copying the value at each index. This
can be beneficial when iterating over large datasets contained within the
iterated value, such as a slice of arrays (e.g., \token{[[c8; 1024]]}). In the
following example, both loops exhibit the same behavior, but the second one is
expected to be faster. To be utilized as a reference value, the value being
iterated must be an lvalue and does not necessarily need to be mutable (as long
as the reference value iterator itself is not mutable; for details on mutable
reference value iterators, refer to the next subsection).

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
let a : [[i32 ; 1024]] = copy [[0 ; 1024], [1 ; 1024]];
for v in a { // copy 1024 i32, at each iteration
  println (v);
}

for ref v in a { // reference, copying only 1 pointer (8 bytes)
  println (v);
}
\end{lstlisting}

This type of reference value iterator can be utilized with tuples, arrays, or
slices. In the following example, the first for loop at line 2 creates a copy of
the values contained in the tuple, while the second loop at line 5 iterates
using references, thereby avoiding the need to copy 110 \textit{i32} values.
Similarly, the loops for an array value make copies at line 10 and iterate by
reference at line 13. The Ymir Semantic Language reveals these differences,
transforming the loop at line 2 into the one depicted in
Listing~\ref{lst:copy_value_iter_tu} and the loop at line 5 into the one shown
in Listing~\ref{lst:ref_value_iter_tu}.

\begin{lstlisting}[style=coloredverbatim, caption=iteration using reference value iterator, label=lst:ref_value_iter_ex]
let a = ([0 ; 100], [1 ; 10]);
for v in a {
  println (v);
}

for ref v in a {
  println (v);
}

let b : [[i32 ; 1024] ; 2] = [[0 ; 1024], [1 ; 1024]];
for v in b {
  println (v);
}

for ref v in b {
  println (v);
}
\end{lstlisting}

\begin{lstlisting}[style=intermediateVerb, caption=By copy iteration on a tuple, label=lst:copy_value_iter_tu]
cte for {
  {
    let v(#48) : [i32 ; 100us] = [0 ; 100us];
    {
      std::io::println!{[i32 ; 100us]}::println (v(#48));
      <unit-value>
    }
  };
  {
    let v(#s7) : [i32 ; 10us] = [1 ; 10us];
    {
      std::io::println!{[i32 ; 10us]}::println (v(#s7));
      <unit-value>
    }
  }
};
\end{lstlisting}

\begin{lstlisting}[style=intermediateVerb, caption=By reference iteration on a tuple, label=lst:ref_value_iter_tu]
cte for {
  {
    let ref v(#1gd) : [i32 ; 100us] = ref (a(#3t).0);
    {
      std::io::println!{[i32 ; 100us]}::println (v(#1gd));
      <unit-value>
    }
  };
  {
    let ref v(#1hd) : [i32 ; 10us] = ref (a(#3t).1);
    {
      std::io::println!{[i32 ; 10us]}::println (v(#1hd));
      <unit-value>
    }
  }
};
\end{lstlisting}

\subsection{Mutable reference iterator}

A reference iterator can be rendered mutable by decorating it with the keywords
\token{mut} or \token{dmut}. It adheres to the same guidelines as any mutable
reference variable or parameter (see Section~\ref{sec:mut_ret_param}),
indicating that the iterator variable itself is mutable, and any modifications
to it directly impact the referenced value. The value being iterated must
conform to the mutability level of the iterator, and the contract must be
acknowledged by decorating the iterated value with the keyword \token{ref}.

In the following example, the value iterator is a mutable reference to the
values contained in the slice value stored in the variable \token{a}. Because
the iterator is a mutable reference iterator, it is an lvalue (as opposed to a
simple mutable iterator, which would not be applicable here - see
Listing~\ref{lst:useless_mut_iterator}), and therefore can be modified. After
the end of the \textit{for} loop, the values contained in the slice stored in
\token{a} are modified.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
let dmut a = copy [1, 2, 3];

for i, ref mut v in ref a {
  //                ^^^ mandatory
  v = cast!i32 (i) + 9;
}

assert (a == [9, 10, 11]);
\end{lstlisting}

The iterator must be compatible with the mutability level of the iterated value.
In the following example, at line 4, the iterator is deeply mutable. However,
the variable \token{a} only has partial mutable access to the value it borrows,
meaning it can modify only the first level, but not the values stored in the
inner slices. On the other hand, at line 9, the iterator is only one level
mutable, matching the mutability level of \token{a}. As a result, it will modify
the values stored in \token{a} without altering the values stored within the
inner borrowed slices.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
let y = copy [3, 4];
let mut a : [mut [i32]] = dcopy [[1, 2], y];

for @\hb{ref dmut}@ v in ref a {
  //    ^^^, error, incompatible mut [i32] -> mut [mut i32]
  @\hb{v [0] = 9;}@ // would modify values that /a/ does not own
}

for ref mut v in ref a {
  //    ^^^ Ok, slice in /a/ is mutable
  v = copy [10, 11];
}

assert (a [0] == [10, 11]);
assert (a [1] == [10, 11]);
assert (y == [3, 4]); // /y/ is untouch as guaranteed

\end{lstlisting}

\section{List comprehension}%
\label{sec:list_compr}

List comprehension is a concise method for creating arrays, slices, or tuples
using a single line of code. It applies an expression to each item in a list by
iterating over an iterable, similar to a standard for loop. The syntax \token{[V
    for i, j ... in Iter]} and \token{(V for i, j ... in Iter,)}. In the next
example at line 1, an array of size \textit{10} is created by iterating over a
range value. In this example, an array value can be created because the number
of iteration of the for loop can be computed at compile time. Because the size
is known, a tuple value can be created using the same principle as presented at
line 3.

\begin{lstlisting}[style=coloredverbatim]
let a = [i^^2 for i in 0 .. 10];

let b = (i^^2 for i in 0 .. 10,);
//      Note the coma         ^, which is mandatory to create a tuple
\end{lstlisting}

When the size cannot be known at compile time, for example when the iteration is
made on a slice value, then one cannot create a tuple or an array value, but can
still create a slice value, that is allocated during runtime. In the next
example, the keyword \token{copy} performs a dynamic allocation of the correct
size, that is computed during runtime. At line 6, the compiler being unable to
compute the size of the array at compile time, rejects the code by sending an
error, for the same reason the tuple list comprehension at line 7 is also
rejected.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
fn foo ()-> [i32];

let x = foo ();
let a = copy [i^^2 for i in x]; // compute the square of each element of the slice /x/

let b = @\hb{[i for i in x];}@ // error, size of array is not cte
let c = @\hb{(i for i in x,);}@ // error, arity of tuple not cte
\end{lstlisting}

To be used as an iterable value in a list comprehension, the value must be
iterable using a standard \token{for} loop and must have a computable length
before entering the loop. This size can be known at compile time (to create an
array or a tuple) or only at runtime (to create a slice). The four native
iterable values for list comprehension are slices, arrays, tuples, and ranges.
Custom class types can override the list comprehension operator, as discussed in
Chapter~\ref{sec:class_override_lst_compr}.

\subsection{Mutable and reference value iterators}

In the previous section on \token{for} loops, we discussed that iterators can be
references and mutable, depending on the type of the value being iterated. In
list comprehension, the value iterator can be a reference but cannot be mutable.
The primary purpose of list comprehension is to create new values, not to modify
existing ones. Allowing the modification of the iterated value during the
creation of another value would result in two operations happening
simultaneously, leading to potentially confusing programming patterns that we
believe should be avoided. However, the iterator can still be a reference to
avoid copying values during iterations, such as when iterating over a slice of
array values. In the following listing, the list comprehension is forbidden
because it attempts to modify the values contained in \token{a}.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
let dmut a = dcopy [[1, 2], [3, 4]];

let dmut b = copy [{
    @\hb{v[0] = 1;}@ // error, v cannot be mutable
    v[1]
} for @\hb{dmut}@ v in @\hb{alias}@ a]; // error, cannot make a mutable value iterator
\end{lstlisting}

One can still modify the value \token{a} by using a direct reference. This
approach does not hinder optimization. In the following example, a single loop
performs two operations at each iteration, rather than requiring two separate
loops as shown in the next Listing~\ref{lst:compr_two_loops}.

\begin{lstlisting}[style=coloredverbatim, caption=Modify existing value during list comprehension]
let dmut a = dcopy [[1, 2], [3, 4]];

let dmut b = copy [{
    a [i][0] = 9; // ok, /a/ is directly referenced
    v [1]
} for i, ref v in a]; // ok, iterating by const reference

assert (a [0] == [9, 2]);
assert (b == [2, 4]);
\end{lstlisting}

\begin{lstlisting}[style=coloredverbatim, caption=Using two loops]
let dmut a = dcopy [[1, 2], [3, 4]];

let dmut b = copy [v [1] for ref v in a]; // ok, iterating by const reference
for ref dmut v in ref a { // second loop to modify /a/
  v [0] = 9;
}

assert (a [0] == [9, 2]);
assert (b == [2, 4]);
\end{lstlisting}

\subsection {YIL representation}

List comprehensions that iterate over a tuple value or create a tuple value are
unfolded at compile time to generate a literal value. The following
Listings~\ref{lst:list_compr_tuple_iter} and~\ref{lst:list_compr_tuple_create}
produce the YIL (Ymir Intermediate Language) representation shown respectively
in Listings~\ref{lst:list_compr_tuple_iter_yil}
and~\ref{lst:list_compr_tuple_create_yil}.

\begin{lstlisting}[style=coloredverbatim, label=lst:list_compr_tuple_iter, caption=List comprehension iterating over a tuple]
let a = (1, 2, 3);
let b = [i for i in a];
\end{lstlisting}

\begin{lstlisting}[style=intermediateVerb, label=lst:list_compr_tuple_iter_yil, caption=YIL representation of Listing~\ref{lst:list_compr_tuple_iter}]
a(#2) = (1, 2, 3);
i(#3) = a(#2)._0;
i(#5) = a(#2)._1;
i(#7) = a(#2)._2;
YI_9(#9) = [i(#3), i(#5), i(#6)];
\end{lstlisting}

\begin{lstlisting}[style=coloredverbatim, label=lst:list_compr_tuple_create, caption=List comprehension iterating over a tuple]
let a = [1, 2, 3];
let b = (i for i in a,);
\end{lstlisting}

\begin{lstlisting}[style=intermediateVerb, label=lst:list_compr_tuple_create_yil, caption=YIL representation of Listing~\ref{lst:list_compr_tuple_iter}]
a(#1) = [1, 2, 3];
YI(#3) = (len-> 3, ptr-> &a(#2));
#_value(#4) = YI(#3);
#_iter(#5) = 0;
YI(#6) = 4 * #_iter(#5);
YI(#7) = #_value(#4).ptr + YI(#6);
YI(#8) = cast!{*(i32)} (YI(#7));
i(#9) = *YI(#8);
#_iter(#5) = 1;
YI(#b) = 4 * #_iter(#5);
YI(#c) = #_value(#4).ptr + YI(#b);
YI(#d) = cast!{*(i32)} (YI(#c));
i(#e) = *YI(#d);
#_iter(#5) = 2;
YI(#g) = 4 * #_iter(#5);
YI(#h) = #_value(#4).ptr + YI(#g);
YI(#i) = cast!{*(i32)} (YI(#h));
i(#j) = *YI(#i);
b(#l) = (i(#9), i(#e), i(#j))
\end{lstlisting}

On the other hand, list comprehensions that create a slice or an array from a
range, a slice, or an array value generate a loop that is executed at runtime.
The following Listings~\ref{lst:list_compr_range_iter}
and~\ref{lst:list_compr_array_iter} produce the YIL (Ymir Intermediate Language)
representation shown respectively in
Listings~\ref{lst:list_compr_range_iter_yil}
and~\ref{lst:list_compr_array_iter_yil}.

\begin{lstlisting}[style=coloredverbatim, label=lst:list_compr_range_iter, caption=List comprehension iterating over a range]
let a = [i for i in 0 .. 10];
\end{lstlisting}

\begin{lstlisting}[style=intermediateVerb, label=lst:list_compr_range_iter_yil, caption=YIL representation of Listing~\ref{lst:list_compr_range_iter}]
    #_iter(#1) = 0;
#GOTO test(#3);
#LABEL beg(#2);
    i(#4) = cast!{i32} (#_iter(#1));
    #_value(#2)[#_iter(#1)] = i(#4);
    #_iter(#1) = #_iter(#1) + 1;
#LABEL test(#3);
    YI_3(#3) = #_iter(#1) < 10;
#IF YI_3(#3)
#THEN_GOTO beg(#2)
#ELSE_GOTO end(#1);
#LABEL end(#1);
    a(#8) = #_value(#2);
\end{lstlisting}

\begin{lstlisting}[style=coloredverbatim, label=lst:list_compr_array_iter, caption=List comprehension iterating over an array]
let mut a = [1, 2, 3];
let b = [i for i in a];
\end{lstlisting}

\begin{lstlisting}[style=intermediateVerb, label=lst:list_compr_array_iter_yil, caption=YIL representation of Listing~\ref{lst:list_compr_array_iter}]
    a(#2) = [1, 2, 3];
    #_value(#4) = (len-> 3, ptr-> &a(#2));
    #_iter(#6) = 0;
#GOTO test(#3);
#LABEL beg(#2);
    YI_8(#8) = 4 * #_iter(#6);
    YI_9(#9) = #_value(#4).ptr + YI_8(#8);
    YI_10(#a) = cast!{*(i32)} (YI_9(#9));
    i(#b) = *YI_10(#a);
    #_out(#5)[#_iter(#6)] = i(#b);
    #_iter(#6) = #_iter(#6) + 1;
#LABEL test(#3);
    YI_7(#7) = #_iter(#6) < 3;
#IF YI_7(#7)
#THEN_GOTO beg(#2)
#ELSE_GOTO end(#1);
#LABEL end(#1);
    b(#e) = #_out(#5);
\end{lstlisting}

One can note from Listings~\ref{lst:list_compr_tuple_iter_yil}
and~\ref{lst:list_compr_array_iter_yil} that the iteration over an array value
actually creates a slice over the array value that is iterated. This allows to
use the exact same system for slice and array iterations (the same thing is
performed for \token{for} loops) as slices are pointer to an array value with a
specific length.

\subsection{Specifics to slice value iteration}

As discussed in Section~\ref{sec:slice_expansion}, slices can be expanded when
their size is forcibly defined using an index operated with a range operand.
This system can also be used to iterate over a slice value within a list
comprehension to create an array or a tuple, where the size must be known at
compile time. In practice, because the size of the slice cannot be effectively
checked at compile time, a runtime check is added to ensure that the slice
contains enough values to respect the index operation.

\begin{lstlisting}[style=coloredverbatim, label=lst:list_compr_slice_to_array, caption=List comprehension over a slice with cte size]
fn foo ()-> [i32];

let a = foo ();
let b = [i for i in a [0 .. 3]]; // ok, array of size 3
let c = (i for i in a [0 .. 2],); // ok, tuple of arity 2
let d = copy [i for i in a]; // ok, creates a new slice
\end{lstlisting}

In the above example, the \token{copy} operator is used to create a slice value
that is stored in the variable \token{d}. This copy operator does not actually
make a copy of the value returned by the list comprehension. Instead, it informs
the compiler that the list comprehension must create a heap allocation for the
value it will generate. This ensures that only one allocation is made, resulting
in a value that is exactly the same as \token{copy a}.

In addition, if the function \token{foo} returns a slice value with fewer than 3
elements, the program will panic at runtime. This occurs because the list
comprehension at line 4 requires at least 3 values. Since this check cannot be
performed at compile time, it is done at runtime, resulting in a panic if the
requirement is not met.

\section{Scope guards}%
\label{sec:scope_guards}

Scope guards are a programming construct utilized to ensure that specific
operations are executed automatically upon exiting a scope. These guards are
commonly employed for tasks such as cleanup actions, error recovery, or managing
resources. There are two main types of scope guards: scope exiting and error
handling. The former, discussed in Section~\ref{sec:exit_guards}, is declared
following a scope declaration using one of three keywords: \token{exit},
\token{success}, or \token{failure} (e.g., \token{\{ ... \} exit \{ ... \}}). The
latter, discussed in Section~\ref{sec:catching_errors}, is declared with the
keyword catch and is utilized to handle exceptions thrown within a specific
scope, employing the syntax \token{\{...\} catch { Pattern => V }}


\begin{lstlisting}[style=coloredverbatim]
fn foo ()-> i32
  throws AssertError;

{
  foo ();
} exit {
  println ("Called foo");
} catch {
  AssertError () => {
    println ("Foo has failed!");
  }
}
\end{lstlisting}

\subsection{Exit guards}
\label{sec:exit_guards}

The \token{exit} guard serves as a scope guard designed to execute an action
when a scope is exited, regardless of the success or failure of the guarded
scope. In contrast, the scope guards \token{failure} and \token{success} are
activated under specific conditions upon exiting the scope. The guard
\token{failure} is triggered when the scope throws an exception, while the guard
\token{success} is triggered when the scope exits normally. These scope guards
can be highly beneficial for managing resources that require disposal or for
calling functions that must execute at the end of a scope.

\smallskip

In the provided example, the code at line 10 is executed irrespective of whether
the \token{foo} function succeeds or fails. Conversely, the code at line 14 is
executed solely if the \token{foo} function exits normally, whereas the code at
line 12 is exclusively executed in the event of \token{foo} failing.

\begin{lstlisting}[style=coloredverbatim]
fn foo ()-> i32
  throws AssertError
{
  // ...
}

{
  foo ();
} exit {
  println ("Foo was exited");
} failure {
  println ("Foo failed");
} success {
  println ("Foo succeeded");
}
\end{lstlisting}

Exit scope guards lack access to variables declared within the scope they guard.
Specifically, \token{exit} and \token{failure} cannot ensure that variables
declared within the guarded scope are constructed. While \token{success} could
potentially guarantee this access, it adheres to the same behavior as other
scope guards and also lacks access to variables declared within the guarded
scope. In the following example, line 4 is prohibited as the variable \token{a}
no longer exists (and might have never been constructed).

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
{
  let a = foo ();
} exit {
  println ("Foo returned : ", @\hb{a}@); // error, a does not exists here
}
\end{lstlisting}

Exit scope guards cannot throw exceptions, return early from functions, break
loops, or generate values. They may execute in contexts where the program is
already throwing an exception (e.g., the \token{failure} scope is only triggered
in such contexts) or in contexts that have already triggered a break or an early
function return. Allowing exit scope guards to throw exceptions, return early,
or break loops would result in two exceptions being thrown simultaneously or two
values being returned, which is nonsensical. Additionally, scope guards do not
generate values; the value of a guarded scope is the value generated by the
scope itself. Scope guards are solely used to execute actions once this value is
generated (or failed to be generated), not to handle errors or provide a
different value. For error handling, a \token{catch} scope guard can be
utilized, as will be presented in the subsequent subsection.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
let a = {
    1
} exit {
  @\hb{2}@ // error, scope guard value must be of type /void/
};
// If it was allowed, what would be the value of /a/ here?

{
  throw AssertError ("First exceptions");
} failure {
  @\hb{throw AssertError ("Second exception");}@ // error, scope guard can't throw exceptions
};
// If it was allowed, which would be the thrown error?

{
  return 1;
} success {
  @\hb{return 8}@; // error, exit scope guard cannot return a value
}
// And what would the function actually return ?
\end{lstlisting}

Exit scope guards can indeed be utilized to dispose of a class object, as
demonstrated in the following example. It's important to note that defining the
variable \token{f} within the scope guarded by the exit at line 6 wouldn't be
feasible, as it wouldn't be accessible within the scope guard and thus wouldn't
be disposable. However, it is not the preferred method. Instead, a disposing
scope declaration (refer to Section~\ref{sec:dispose_block}) is recommended for
such purposes.

\begin{lstlisting}[style=coloredverbatim]
use std::fs; // for File

let dmut f = File::create ("file.txt", write-> true);
{
  f.write ("content");
} exit {
  f.dispose ();
}

f.write ("other content"); // ok, but file was disposed so it will throw
\end{lstlisting}

For code clarity, the guards \token{failure} and \token{success} should only be
used if the guarded scope can throw exceptions. Otherwise, they would either
never be executed or be strictly equivalent to an \token{exit} guard.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
{
  println ("In scope");
} @\hb{failure}@ { // error, never used
  println ("Failed to print ??");
} @\hb{success}@ { // error, always executed, thus exit must be used instead
  println ("Succeed to print");
}
\end{lstlisting}

\section{Handling exceptions}
\label{sec:catching_errors}

Exceptions are handled using a specific scope guard name \token{catch}. This scope guard unlike the other scope guards have a specific syntax and enclose a list a patterns similar to the pattern that can be found inside a pattern matching expression. The patterns that can be found in \token{catch} scope guards are used to match over the exception that is caught, and therefore only a variable declaration and field deconstructor can be used (these are the only two pattern that are relevant for matching over an object).


\begin{lstlisting}[style=coloredverbatim]
fn foo ()
  throws AssertError;

fn main () {
  {
    foo ();
  } catch {
    a : &AssertError => {
      println ("Caught an assert error with message : ", a.msg);
    }
  }

  println ("Continuing normally");
}
\end{lstlisting}

The type of exceptions that can be caught by the \token{catch} scope guard are
all the exceptions that are thrown within the scope that is guarded. It is
mandatory that the scope guard catch all the exceptions, there is no automatic
rethrowing of uncaught exception as it could be done in other programming
language.

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
fn foo (x : i32?)
  throws AssertError, EmptyValOption;

fn main () {
  {
    foo (none);
  } catch {
    @\hb{EmptyErrOption ()}@ => { // error, foo cannot throw EmptyErrOption

    }
    EmptyValOption () => {
      println ("Option was empty");
    }
    @\hb{\}}@ // error, AssertError exception is not caught
  }
}
\end{lstlisting}

\subsection{Exception rethrowing}

Because exception are not rethrown automatically if not caught, a \token{catch} scope guard that does not throw any exception is considered safe (in the sense they are not throwing, but they might still panic or trigger unsafe operations). A \token{catch} scope guard can throw an exception as any other classical scope using the keyword \token{throw} or by calling a function that throws exception. Indeed, unlike other scope guards (exit, success and failure) a \token{catch} scope guard is only triggered if the scope that is guarded failed to produce a value, and the exception that was thrown being caught only one path is leading out of the flow graph from the scope guard.

For that reason, scopes decalared within a \token{catch} scope guard have the
same properties as standard scopes (can break, generate or return a value, throw
exceptions, etc.).

\begin{lstlisting}[style=coloredverbatim]
{
  foo ();
} catch {
  EmptyValOption () => {
    println ("Recovering");
  }
  e => { // catch every other exceptions
    throw e; // and rethrow them
  }
}

println ("Foo succeeded, or we successfully recovered from the error");
\end{lstlisting}

\subsection{Guarded scope value}

When a scope that is supposed to generate a value fails (by throwing an exception), a \token{catch} scope guard can be used to define the value that will be generated instead. All the scopes (triggered by the different patterns) of a \token{catch} scope guard must define a value of the same type as the value that would be generated by the guarded scope in case of success (with the exception of scopes that early breaks, returns or throw an exception of course). The same principal that was introduced in Section~\ref{sec:cond_value_type} is used to infer the type of the value that is generated by the different branchs. Indeed, catch scope guards can be seen as \token{else} conditional branches that are entered when an exception is thrown instead of a condition being unmet.

\begin{lstlisting}[style=coloredverbatim]
fn foo ()-> i32
  throws AssertError;

fn main () {
  let a = {
    foo () // value of foo, if foo succeeds
  } catch {
    _ => { 0 } // 0 if foo fails
  };

  println (a); // a is always correctly set
}
\end{lstlisting}


\subsection{Guarded scope mutable value}

As for that mutability infered when dealing with conditional branches, the value
of a scope guarded by a \token{catch} scope guard takes the mutability of the
branch giving the fewest permissions. In the next example, because the value
generated by the \token{catch} pattern scope at line ? is less mutable than the
type returned by the function \token{foo}, its mutability is chosen. Basically
everything related to value inference in branch values applies to \token{catch}
scope guard.

\begin{lstlisting}[style=coloredverbatim]
fn foo ()-> dmut [i32]
  throws AssertError;

fn main () {
  let x = copy [1, 2, 3];
  let a = {
    foo ()
  } catch {
    AssertError (msg-> m) => {
      println ("Message of the assert error : ", m);
      x
    }
  };

  let dmut b = {
    foo ()
  } catch {
    _ => {
      copy x // ok, creates a dmut [i32]
    }
  };
}
\end{lstlisting}

\subsection{Breaking and early returns}

We have seen that since catch scope guards are triggered only when the guarded scope has failed to continue they can generated values and throw exceptions. For the same reason, such scope guards can be used to break loops or return function early using respectively the keywords \token{break} and \token{return}. In these contexts, the rules presented in Section~\ref{sec:function_early_return} and in section~\ref{sec:inf_loop} apply.

\begin{lstlisting}[style=coloredverbatim]
let mut i = 0;
let nbIters = loop {
  {
    foo ();
    i += 1;
  } catch {
    _ => break i;
  }
};

println ("Foo function ran ", nbIters, " times before failing");
\end{lstlisting}

\begin{lstlisting}[style=coloredverbatim]
fn bar ()-> i32 {
  let x = {
    foo ()
  } catch {
    _ => {
      println ("Foo failed, simply returning 1");
      return 1;
    }
  };

  println ("Value of foo : ", x);
  x + 1
}
\end{lstlisting}

\subsection{Scope guard priority}

Mutliple scope guards can be attached to the same scope, by declaring them one
after the other. If they can be defined in any order, they are always executed
in the order, i.e. \token{catch}, \token{success} or \token{failure} and finally
\token{exit}. The scope guards \token{catch} and \token{success} are never
executed together, as the success scope guards are executed only when the scope
they are guarding successfully finished. For the same reason \token{failure} and
\token{success} cannot be executed together.

\begin{lstlisting}[style=coloredverbatim]
{
  foo ();
} catch {
  e => println ("Caught an execption : ", e);
} failure {
  println ("Scope failed");
}
\end{lstlisting}


\section{Threads synchronization}

\section{Disposing scope declaration}%
\label{sec:dispose_block}

\begin{lstlisting}[style=coloredverbatim, escapechar=@]
use std::fs; // for File

with dmut f = File::create ("file.txt", write-> true) {
  f.write ("content");
} // call f.dispose ();

@\hb{f}@.write ("other content"); // error, /f/ variable does not exists
\end{lstlisting}
