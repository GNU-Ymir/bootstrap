\section{Preamble}

Control flows are generally decided at run time, i.e. the generated machine code
contains a machine-level representation of the control flow, and it is decided
at run time which branches are traversed. These decisions could also be made at
compile time, using the keyword \token{cte} for \textit{Compile Time
  Execution}, with some requirements. Since these requirements depend on the
type of control flow construct used, they will be detailed in each specific
section, but they always involve the compiler needing to know some values at
compile time. The \token{cte} control flow is consistent with the concept of
conditional compilation introduced in
Chapter~\ref{chap:conditional_compilation}.

\section{Variables, scope and lifetime}
\label{sec:variable_lifetime}

The first construct is a simple scope. Defined by opening and closing curly
braces, a scope determines the lifetime of the variables declared within it.
Variables are declared using the keyword \token{let} followed by an identifier
and an optional type (using the token \token{:}). The lifetime of a variable
begins when it is declared and ends when the scope containing the variable
declaration is exited. Two variables with the same name cannot be alive at the
same time.

\begin{lstlisting}[style=coloredverbatim]
fn main () { // start of a scope
  let a = 12;
  { // start of a second scope

    println (b + a); // error, /b/ is not defined yet
    let b = 24;

    println (b + a); // Ok, /b/ and a are defined

    let a = 89; // error, /a/ is already defined
  } // exiting the second scope

  println (b + a); // Error, /b/ does not exist anymore
  let b = 9; // ok, /b/ from second scope is not alive anymore
}
\end{lstlisting}

\subsection{Scope value}

As presented in section~\ref{sec:function_body}, a scope has a value if the last
expression contained in the scope is a value and does not end with the
\token{;} token. The value can be used as any other expression value (e.g. as
the value of a variable declaration).

\begin{lstlisting}[style=coloredverbatim]
let a = {
  let b = 12;
  b + 12
};

let c = {
  let b = 12;
  b + c // error, /c/ does not exist yet
};
\end{lstlisting}

\subsection{Variable initial value}

A variable is always declared with an initial value. The goal is to ensure that
any data in the program came from somewhere, and is not initialized from a
random memory state of the machine running the program (as we can have in the C
language). One can argue that static verification can be used to ensure that a
variable is set before it is used, and argue that forcing an initial value on a
variable is not the best way to achieve data validity. While this is more a
matter of opinion than sound scientific reasoning at this point, we believe that
scattering the initialization of a variable makes programs harder to read. In
addition, immutable variables would initially be mutable, making the behavior of
a program even more difficult to understand. In the following listings, two
examples of source code with the same behavior are presented. On the left, a
valid source code that is accepted by the Ymir language, and on the right, a
source code that is not accepted based on the arguments we presented.

\hspace{-15pt}%
\begin{minipage}[t][][t]{0.47\linewidth}
  \begin{lstlisting}[style=coloredverbatim, caption=Valid]
fn foo (cond : bool) {
  let i = if cond {
    42
  } else {
    7
  };
}
  \end{lstlisting}
\end{minipage}\hspace{10pt}%
\begin{minipage}[t][][t]{0.47\linewidth}
  \begin{lstlisting}[style=coloredverbatim, caption=Invalid]
fn foo (cond : bool) {
  let i : i32;
  if cond {
    i = 42;
  } else {
    i = 7;
  };
}
  \end{lstlisting}
\end{minipage}


\subsection{Unused variable}

A declared variable has to be used during its lifetime, otherwise the compiler
will send an error, as the variable is useless and only complexify the source
code with dead code.

\begin{lstlisting}[style=coloredverbatim]
{
  let a = 12;
} // error, /a/ is defined but not used
\end{lstlisting}

There are two ways to force the compiler to ignore an unused variable, the first
is to use a special identifier for the variable, either by putting an underscore
at the beginning and end of the variable (e.g. \token{\_a\_}), or by naming the
variable directly \token{\_}. A variable named \token{\_} is anonymous and
cannot be used at all. The second way is to use the variable in a statement.
This statement can be empty (i.e. \token{a;}). Function parameters follow the
exact same semantic, and therefore must be used within the body of the function.
They can be used or ignored with the same system as local variables.

\begin{lstlisting}[style=coloredverbatim]
{
  let _a_ = 12;
} // ok, /_a_/ is an ignorable variable

{
  let _ = 12;
} // ok, /_/ is anonymus

{
  let a = 12;
  a; // using the variable
} // ok, all variables were used
\end{lstlisting}

\subsection{Variable type}

The type of the variable is automatically infered from the value that is
associated to it. Sometimes the compiler may fail the inference, or multiple
types can be associated to a specific value by implicit casting. To solve that
problem a type can be attached to a variable declaration using the token
\token{:}. The type specified must of course be compatible with the type of the
value.

\begin{lstlisting}[style=coloredverbatim]
let a = 12; // automatically infering i32
let b : i32 = 12; // declaring i32

let c : i64 = 12; // ok, implicit cast to i64
let d : [c8 ; 5] = "Hello"; // ok implicit cast from [c8] to [c8 ; 5]
\end{lstlisting}

Some values needs an explicit type to be used as variable initialization values. For example the value \token{none} that creates an empty option values has no inner type on its own. In fact its inner type is deduced from the type of the lvalue that will receive it during affectation. Other types such as \token{void} can simply not be used for variable declaration as they do not contain a value. To create a variable with no value, an empty tuple \token{()} can be used.

\begin{lstlisting}[style=coloredverbatim]
let a = none; // error, cannot create a variable with type (none)?
let b : (i32)? = none; // ok, type is explicitely defined

let c = {}; // error, cannot create a var of type void
let d : void = {}; // error, even by explicitely writing it

let e = (); // ok empty tuple
let f : () = (); // ok, same as /e/
\end{lstlisting}

\subsection {Variable mutability}

A variable is immutable by default, but can be made mutable using the
\token{mut} and \token{dmut} keywords. We saw in
Section~\ref{sec:preamble_compound_types} that values can borrow data depending
on their type. Since all the mutability information about specific types has
already been discussed in Chapter~\ref{chap:compound} for native compound types
and in Chapter~\ref{chap:custom_types} for user-defined types, we will not
discuss it further.

Because type mutability is recursive, an inner type can only be mutable if the
type containing it is also mutable, which also means that for a value inside a
variable to be mutable, the variable must also be mutable. This behavior for
local variables is different from that of function parameters, as presented in
Section~\ref{sec:mutable_parameter}.

\begin{lstlisting}[style=coloredverbatim]
let a = 12;
a = 9; // error, /a/ is immutable

let mut b = 12;
b = 9; // ok, /b/ is mutable


let c : [mut i32] // error, /c/ is immutable, its inner value cannot be mutable
      = copy [1, 2, 3];

let mut d : [mut i32]  // ok, /d/ is of type mut [mut i32]
          = copy [1, 2, 3];


let dmut e = copy [1, 2, 3]; // same as /d/

d [0] = 9; // ok
e [0] = 10; // ok

let mut f = copy [1, 2, 3]; // /f/ is of type mut [i32]
f [0] = 0; // error, inner value of /f/ is immutable
f = copy [4, 5]; // ok, /f/ is mutable
\end{lstlisting}

\subsection{Reference variable}

The \token{ref} keyword can be used to decorate a variable when constructing it
with the \token{let} construct. This decorator is used to specify that a
variable is a reference to another lvalue, it follows exactly the same rules as
presented for reference parameters in Section~\ref{sec:ref_param}. Only lvalues
can be referenced.

\begin{lstlisting}[style=coloredverbatim]
let dmut a = [1, 2, 3];
let ref b = a; // no copy of /a/

println (b [0]); // 1

a [0] = 89;
println (b [0]); // 89

b [0] = 9; // error, b is immutable
\end{lstlisting}

In the above example, \token{b} is a pointer to the value of \token{a},
meaning that when the value of \token{a} changes, so does the value of
\token{b}. The following listing shows the YIL representation of the above
code, and Figure~\ref{fig:ref_variable} illustrates the state of the stack when the
program is executed on a 64-bits system.

\begin{lstlisting}[style=intermediateVerb]
let a(#1) : [i32;3];
let b(#2) : *([i32;3]);
a(#1) = [1, 2, 3];
b(#2) = &a(#2);
_Y3std2io7printlnNi32Fi32Zv(*b(#2)[0]);
a(#1)[0] = 89;
_Y3std2io7printlnNi32Fi32Zv(*b(#2)[0]);
\end{lstlisting}

\input{images/ref_variable}

A reference variable can be mutable as long as the value it references is also
mutable, and the contract has been accepted with the \token{ref} keyword. It
follows the same rules presented in Section~\ref{sec:mut_ref_param} for mutable
reference parameters.

\begin{lstlisting}[style=coloredverbatim]
let mut a = 12;
let mut ref b = ref a; // ok

b = 90;
println (a); // 90
\end{lstlisting}

As for mutable reference parameters, the keyword \token{ref} is mandatory to
accept the mutable reference contract. This keyword can only be used on an
lvalue. In the next example, the contract is not respected at line 2. At line 5,
even if the variable is an lvalue and the keyword \token{ref} is used, because
the mutability of \token{c} is not deep enough to fit into the mutability of
the variable \token{d}, the compiler sends an error.

\begin{lstlisting}[style=coloredverbatim]
let mut a = 12;
let mut ref b = a; // error, mutable reference requires ref keyword

let mut c : [i32] = copy [1, 2, 3];
let dmut ref d = ref c; // error, cannot fit mut [i32] into mut [mut i32]
\end{lstlisting}


\subsection{Pattern variable declaration}
\label{sec:pattern_vdecl}

Variable declaration can be done using a pattern instead of a single variable
declaration. Available patterns are fully described in
Section~\ref{sec:pattern_matching} about pattern matching. If the pattern is
irrefutable (the condition to match the pattern is known at compile time and is
always true), then the variables defined within the pattern can be declared.
Patterns can be used for many things, such as deconstructing tuples, arrays,
accessing class fields, etc.
\begin{lstlisting}[style=coloredverbatim, caption=Tuple deconstruction]
let t = (1, 't', 12.0f);
let (x, y, z) = t;
let (w, _...) = t; // taking only the first value, ignoring the rest
\end{lstlisting}

\begin{lstlisting}[style=coloredverbatim, caption=Array deconstruction]
let a = [1, 2, 3];
let [i, j, k] = a;
let [l, m, _...] = a; // taking only the first two values ignoring the rest
\end{lstlisting}

\begin{lstlisting}[style=coloredverbatim, caption=Class field access]
class A {
  pub let i : i32;
  pub self (i : i32) with i = i {}

  @field
  pub fn len (self)-> i32 {
    2
  }
}

let a = A::new (1);
let A (i-> x, len-> y) = a;

assert (x == a.i && y == a.len);
\end{lstlisting}

The lifetime of variables declared using pattern variable declaration is the
same as that of variables declared using standard declaration. In fact, there is
no standard declaration, a variable declared with the syntax \token{let a : i32
  = 12} uses the pattern \token{a : i32} with the matching value \token{12}
and is therefore irrefutable.

Refutable patterns (that are unknown at compile time) must be coupled with
conditional branching (cf. Section~\ref{sec:if_else}) as they may or may not
create new variables depending on the result of the pattern evaluation.

\begin{lstlisting}[style=coloredverbatim]
fn foo ()-> i32?;

let Ok (x : i32) = foo (); // error, refutable since it may fail if /foo/ returns /none/
\end{lstlisting}

\subsection{Pattern variable mutability and references}

The value that is passed to pattern must respect mutability of borrowed values,
and therefore as any data movement must use the keyword \token{alias} to
perform mutable borrowed data movement. Because the keyword is recursive, an
inside pattern deconstruction may impact mutable access to inner values. In the
next example, the variable \token{a} has mutable access to borrowed data from
\token{t}, when the variable \token{b} has only const access to its second
field, however the keyword \token{alias} has to be used over the value
\token{t} to allow mutable access from \token{a}.

\begin{lstlisting}[style=coloredverbatim]
let dmut t = (copy [1, 2], copy [2, 3]);
let (dmut a : [i32], b : [i32]) = alias t;
//     /alias/ is mandatory here  ^^^^^

a [0] = 9;
t.1 [0] = 9;
println (t); // ([9, 2], [9, 3])
println (b); // [9, 3]
\end{lstlisting}

As for any variable declaration the keyword \token{ref} can be used to create a
reference to a lvalue. In that case, instead of the keyword \token{alias}, the
keyword \token{ref} has to be used to decorate the value that is being
referenced. In the next example, the variable \token{a} is a reference to the
first field of the tuple value stored in \token{t}.

\begin{lstlisting}[style=coloredverbatim]
let dmut t = (copy [1, 2], copy [2, 3]);
let (dmut ref a : [i32], _) = ref t;

a = copy [9, 8, 7];
println (t); // ([9, 8, 7], [2, 3]);
\end{lstlisting}

When values to variable associations are a mix of aliases and references, the
keyword \token{ref} must be used, in this unique case it allows for mutable
\token{alias}. The \token{alias} keyword can never be used to create a mutable
reference. In the next example, the variable \token{a} is a mutable reference
to the first field of the value stored in \token{t}, and the variable
\token{b} mutably borrows the same value as the second field of \token{t}. In
this case, a mutable reference and a mutable alias are created at the same time,
so the keyword \token{ref} is used to decorate the associated value to allow
this. However, in line \token{4}, the use of the keyword \token{ref} is not
allowed, since neither \token{c} nor \token{d} create a reference, the keyword
\token{alias} must be used.

\begin{lstlisting}[style=coloredverbatim]
let dmut t = (copy [1, 2], copy [2, 3]);
let (dmut ref a, dmut b) = ref t; // ok, /ref/ replaces /alias/ in that case

let (dmut c, dmut d) = ref t; // error, no mutable references needed, thus /alias/ has to be used
\end{lstlisting}

If there is no mutable alias and no mutable reference, then the keyword is not
allowed to decorate the associated value, to avoid using the keywords by default
resulting in the opposite of their purpose (helping developers to easily spot
the locations of mutable memory movements, and possible side effects).

\begin{lstlisting}[style=coloredverbatim]
let dmut t = (copy [1, 2], copy [2, 3]);
let (a, b) = alias t; // error, /alias/ is useless
let (c, d) = ref t; // error, /ref/ is useless
\end{lstlisting}

\section{Conditional branching}%
\label{sec:if_else}

A conditional control flow can be defined using the keywords \token{if} and
\token{else}. The syntax \token{if C V} defines that the value \token{V} is
evaluated if and only if the condition \token {C} of type \token {bool} is
true. Using the keyword \token{else} this construction can be extended to
provide another value to evaluate if the condition is not met. The if condition
at line 2 in the next example generates a runtime conditional representation
that can be represented by the flow graph presented in
Figure~\ref{fig:if_cond_simple}, or by the YIL code in
Listing~\ref{lst:if_cond_simple}.

\begin{lstlisting} [style=coloredverbatim]
fn foo (cond : bool)-> i32 {
  if cond {
    89
  } else {
    11
  }
}

let x = foo (true); // /x/ evaluated to 89
let y = foo (false); // /y/ evaluated to 11
\end{lstlisting}


\begin{lstlisting}[style=intermediateVerb, caption=Simple condition, label=lst:if_cond_simple]
frame :  _Y4main3fooFbZi32 (let cond(#1) : u8)-> i32 {
    let YI_2(#2) : i32;
#IF cond(#1)
#THEN_GOTO then(#1)
#ELSE_GOTO else(#3);
#LABEL then(#1);
    YI_2(#2) = 89;
#GOTO end(#2);
#LABEL else(#3);
    YI_2(#2) = 11;
#GOTO end(#2);
#LABEL end(#2);
    return YI_2(#2);
}
\end{lstlisting}

\input{images/if_cond_simple}

Conditional branching can be applied to any test that produces a \token{bool}
value that is unknown at compile time. However, they are not allowed if the
condition can be determined at compile time, as they would only complicate the
source code with useless control flows that can be determined statically. For
example, in the following code on line 2, the condition is always \token{true},
so the condition is useless and the code on line 3 is always evaluated, in
addition, on line 5 the condition is always \token{false}, creating dead code
that is never evaluated.

\begin{lstlisting}[style=coloredverbatim]
let a = [1, 2, 3];
if (a.len <= 3) { // error, len of /a/ is /cte/
  println (a [2]);
}

if (a.len >= 4) {
  println (a [3]); // error, dead code
}
\end{lstlisting}

\subsection {Conditional value}
\label{sec:cond_value_type}

A \token{if} construct has a result value if all branches have a result value.
The type of the expression is the type of the first branch, i.e. the type of the
value of the first \token{if}. The value of the \token{else} branch is
implicitly cast to the type of the first branch value, if this is not possible
the compiler returns an error.

\begin{lstlisting}[style=coloredverbatim]
let a = if cond {
  12
}; // error, no else value

let b = if cond {
  12
} else {
  "str"
}; // error, incompatible i32 and [c8]

let d = if cond {
  12
} else {
  11u32
}; // ok, implicit cast of 11u32 to i32
\end{lstlisting}

\subsection{Mutable conditional value}

If the type of the \token{else} branch is compatible with the type of the first
branch, but does not match its mutability, the mutability of the result value of
the \token{if} construct is reduced to match the most restricted value. In the
next example, because the value of the \token{else} branch has a more
restricted mutability than the value of the \token{if} branch, the result type
of the expression takes the mutability of the \token{else} branch, and thus the
result value is of type \token{mut [i32]}.

\begin{lstlisting}[style=coloredverbatim]
let a = copy [1, 2, 3];
let dmut b = if cond { // error, mutability does not fit in /b/
  copy [2, 3, 4] // mut [mut i32]
} else {
  a
}; // mut [i32]
\end{lstlisting}

As for scope values when returning a mutable borrowed value, because
the \token{alias} contract is already accepted within the value of the
branches, it is not necessary to accept it again for the result value of the
\token{if} construct. Therefore, in the next example, the keyword
\token{alias} is not used before the keyword \token{if}, even though the
affectation to \token{b} moves borrowed mutable data.

\begin{lstlisting}[style=coloredverbatim]
fn foo (cond : bool) {
  let dmut a = copy [1, 2, 3];
  let dmut b = if cond {
    alias a // alias is mandatory here
  } else {
    copy [2, 3, 4]
  };
}
\end{lstlisting}


\subsection{Chaining conditions}

Conditions can be chained by following the \token{else} with another
\token{if} condition. In fact, this does not really chain the condition, since
in this case the \token{if} condition following the \token{else} keyword is
the value that is evaluated in case the condition of the first \token{if} is
not true. To illustrate, the following source code presents two chained
\token{if} conditions that are exactly similar in semantics.


\begin{minipage}[t][][t]{0.47\linewidth}
\begin{lstlisting}[style=coloredverbatim, caption=Using a \token{if} as the value of the \token{else} branch]
if cond {
  println ("First condition is true");
} else if cond2 {
  println ("Second condition is true");
} else {
  println ("None of the conditions were true");
}
\end{lstlisting}
\end{minipage}\hspace{10pt}%
\begin{minipage}[t][][t]{0.47\linewidth}
  \begin{lstlisting}[style=coloredverbatim, caption=Using a block as the value of the \token{else} branch]
if cond {
  println ("First condition is true");
} else {
  if cond2 {
    println ("Second condition is true");
  } else {
    println ("None of the conditions were true");
  }
}
  \end{lstlisting}
\end{minipage}
\vspace{-10pt}%

\subsection{Early return branch}


We have seen in Section~\ref{sec:function_early_return} that a function can exit
early in three different ways (i.e., \token{return}, \token{throw}, or
\token{panic}). Such an early exit can happen inside a branch of a conditional
value. In this case, that particular branch is considered a return branch and
therefore has no value. In Section~\ref{sec:inf_loop} we will see a construction
that can also exit a branch of the flow graph without constructing a value (i.e.
\token{break}). As a result, the \token{if} construction can sometimes have a
result value even though not all branches construct a value.

%\smallskip

\input{images/if_cond_early_return}

\begin{lstlisting}[style=coloredverbatim, caption=Early return in \token{if} condition, label=lst:if_cond_early_return]
fn foo (cond : bool)-> i32 {
  let a = if cond {
    return 89; // exits the function
  } else {
    10
  }; // ok, all non-returning branches have a value

  a + 9
}
\end{lstlisting}

In the example presented in Listing~\ref{lst:if_cond_early_return}, the value of
the variable \token{a} can be constructed. In fact, if the condition is not
true, the value of \token{a} will be 10, and if the condition is true, then the
function exits, so the value of \token{a} does not need to be evaluated in this
case. Figure~\ref{fig:if_cond_early_exit} shows the flow graph resulting from
this source code. You can clearly see from this graph that in the flow that the
first branch follows (when the condition is met), the variable \token{a} is
never needed, and therefore does not need to be constructed for the code to be
correct.


\subsection {Conditional pattern}
\label{sec:cond_pattern}

We have seen in Section~\ref{sec:pattern_vdecl} that variables can be declared
using a pattern, and that the pattern might be refutable and needing runtime
validation. In that case, the pattern has to be coupled with a conditional
branch representation using the syntax \token{if let Pattern = Value V}, as
presented in the next example.

\input{images/if_cond_let_Ok}

\begin{lstlisting}[style=coloredverbatim, label=lst:if_cond_let_Ok, caption=Example of conditional pattern]
fn foo ()-> i32?;

if let Ok (x : i32) = foo () {
  println ("Foo returned the value : ", x);
}
\end{lstlisting}

In the previous example, the function \token{foo} could return a \token{none}
value, but the code would still be safe because the conditional ensures that the
variable \token{x} is created if and only if the function actually returns a
value. This example produces the YIL representation shown in
Figure~\ref{fig:if_cond_let_Ok}, as you can see the variable \token{x} is
actually created only if the value returned by \token{foo} is set. All kinds of
patterns can be used for conditional pattern declarations, those are described
in Section~\ref{sec:pattern_matching}.


Pattern conditional branching can be used for any pattern that requires run-time
validation, but is not allowed for patterns that are irrefutable (or always
wrong), as it would just make the code unnecessarily complex.

\begin{lstlisting}[style=coloredverbatim]
let a = (1, 2, 3);

if let (x, y, z) = a { // error, pattern is irrefutable
  println (x, ' ', y, ' ', z);
}
\end{lstlisting}

\subsubsection{Conditional pattern guard}

As we will see in the presentation of patterns in
Section~\ref{sec:pattern_matching}, using an identifier within a pattern
declares a new variable that must not be shadowed by another variable with the
same name. For example, in the next listing at line 4, the compiler returns an
error because the pattern declares a new variable \token{x} rather than
evaluating for equality, as it does in the second pattern condition at line 10.

\begin{lstlisting}[style=coloredverbatim]
fn foo ()-> i32?;

let x = 2;
if let Ok (x) = foo () { // error, shadowing declaration of /x/
  println ("foo () == ", x);
} else {
  println ("Either foo () returned none, or != x");
}

if let Ok (2) = foo () { // ok, value equality test
  println ("foo () returned the value 2")
}
\end{lstlisting}

To solve this problem, and to allow comparison with variables within pattern
matching, the pattern guard was introduced. The pattern guard allows two test
conditions in one line, using the token \token{\&\&} at the end of the syntax
\token{if let Pattern = Value \&\& Test V} to add an extra condition in which the
variables declared within the pattern are accessible. In the next example, the
declaration of the variable \token{y} does not overshadow any other variable and
can therefore be used to compare the value returned by \token{foo} with the
value stored in the variable \token{x} inside the pattern guard. Unlike a second
conditional branch, as presented in
Listing~\ref{lst:using_second_cond_no_guard}, the pattern guard allows the
\token{else} value to be evaluated in case the pattern guard test fails, and
therefore makes writing code easier and less redundant.

\notebox{ Because the pattern guard is introduced by the token \token{\&\&},
  operators of equal and lower precedence (e.g. \token{=}, \token{+=},
  \token{||}, ...) cannot be used directly inside the value accepted by the
  pattern and must be enclosed in parentheses (e.g. \token{if let Ok (x) = (foo ()
    || bar () \&\& baz ())? \&\& guard}).}


\begin{lstlisting}[style=coloredverbatim, caption=Using a pattern guard]
let x = 2;

if let Ok (y) = foo () && y == x { //
  println ("foo () returned the value ", y, " which is equal to ", x);
} else {
  println ("Either none, or y != x");
}
\end{lstlisting}

\begin{lstlisting}[style=coloredverbatim, caption=Using a second condition instead of pattern guard, label=lst:using_second_cond_no_guard]
if let Ok (y) = foo () {
  if (y == x) {
    println ("foo () returned the value ", y, " which is equal to ", x);
  } else {
    println ("y != x");
  }
} else {
  println ("foo () returned none");
}
\end{lstlisting}

\section{Infinite loop}%
\label{sec:inf_loop}

A loop can be defined with the keyword \token{loop}. A loop defined with this
keyword is an infinite loop that never stops unless it is broken with the
\token{break} keyword or terminated by an early function exit (i.e., returning
with the \token{return} keyword, throwing an exception, or panicking). This type
of loop can be useful for managing operations that have no real defined end
(e.g. a worker thread waiting for new tasks, a TCP server waiting for new
connections).

\begin{lstlisting}[style=coloredverbatim]
loop {
  println ("I will print this message indefinitely");
}
\end{lstlisting}

\subsubsection{Breaking a loop}
\label{sec:breaking_loops}

A break statement with the keyword \token{break} stops loop iterations and exits
its scope. The break statement only breaks one level of the loop, so if multiple
levels of loops are wrapped, then only the lowest level of the loop is broken,
and the iterations of the higher level loops continue. In the following example,
the output result of execution will be a sequence of pairs of \textit{Inner
  Loop} and \textit{Outer Loop}, as the inner loop will only iterate once before
breaking and returning to the upper loop.

\begin{lstlisting}[style=coloredverbatim]
loop {
  loop {
    println ("Inner Loop");
    break;
  }
  println ("Outer Loop");
}
\end{lstlisting}

Any statement after an irrefutable break branch is inaccessible, so the compiler
will raise an error if dead code is found after a break statement.

\begin{lstlisting}[style=coloredverbatim]
loop {
  break;
  println ("Post break"); // error, unreachable statement
}

println ("After loop"); // ok, break only breaks the loop, it does not exit the function
\end{lstlisting}

\subsection {Infinite loop value}

As mentioned earlier, an infinite loop can be broken using the \token{break}
keyword. The break construction can be associated with a value, this value will
be the value taken by the loop after exiting. If multiple breaks are defined in
the loop, they must all produce a value of compatible type. The type of the
loop's value is determined in the same way as the type of the value of an if
condition, by checking all possible branches and calculating the most common
type (cf. Section~\ref{sec:cond_value_type}). The control flow of the next
Listing~\ref{lst:simple_loop_break} is illustrated in
Figure~\ref{fig:simple_loop_break}.

\begin{lstlisting}[style=coloredverbatim, label=lst:simple_loop_break, caption=Breaking a loop with a value]
let mut count = 0;

let x = loop {
  if (count == 10) {
    break count + 1;
  }

  count += 1;
};

assert (x == 11);
\end{lstlisting}

\input{images/simple_loop_break}


In the next example, since the two values declared by the break
constructions are compatible but not equivalent, the type of the breaks is
implicitly cast to \token{\&A}, with the compiler defining the most common type
between the two breaks as the ancestor of the class objects. The same operations
would be done for other compatible types, such as int, char literals with
compatible but not equivalent types.

\begin{lstlisting}[style=coloredverbatim]
class A {
  pub self () {}
}

class B over A {
  pub self () {}
}

class C over A {
  pub self () {}
}

let mut count = 0;
let x = loop {
  if count == 1 {
    break B::new ();
  } else if count = 10 {
    break C::new ();
  }

  count += 1;
};
\end{lstlisting}


\subsubsection {Mutable loop value}

As with the conditional value, the value of a loop construction can be made
mutable. If multiple breaks are defined within the loop, the mutability of the
type of the loop value is reduced to the most restricted mutability among the
break values. In the following example, the mutability of the value on line 8 is
more restricted than the value on line 6, so the mutability of the type of the
loop is the same as that of the break value on line 8.

\begin{lstlisting}[style=coloredverbatim]
let mut count = 1;
let a = copy [2, 3, 4];

let x = loop {
  if count == 1 {
    break copy [1, 2, 3];
  } else if count == 10 {
    break a;
  }

  count += 1;
};
\end{lstlisting}

Since the mutability of the loop value is the same as the mutability of the most
restricted value among the break values, it can borrow mutable data and must
therefore respect the contract of mutable memory movement as defined for scope
values. No \token{alias} is needed above the loop itself, as this has
necessarily already been done on the break values.

\begin{lstlisting}[style=coloredverbatim]
let mut count = 0;
let dmut a = copy [1, 2, 3];

let dmut x = loop { // no need for explicit /alias/
  if count == 10 {
    break alias a; // /alias/ is mandatory here
  }

  count += 1;
};
\end{lstlisting}

\section{Conditional loop}%
\label{sec:while_loop}

Conditional loops continue iterating as long as a specified condition remains
true. They are initialized with the keyword \token{while} and follow the syntax
\token{while C V}, where \token{C} represents the condition that must be
satisfied, and \token{V} is the value evaluated while the condition remains
true. Similar to conditional branching, the condition \token{C} must be of type
\token{bool}. The following example showcases a while loop that iterates five
times before exiting. Its control flow is illustrated in
Figure~\ref{fig:simple_while_loop}

\begin{lstlisting}[style=coloredverbatim, caption=Simple while loop, label=lst:simple_while_loop]
let mut count = 0;

while count < 5 {
  count += 1;
}

assert (count == 5);
\end{lstlisting}

\input{images/simple_while_loop}

\subsection{Do-while loop}
\label{sec:do_while_loop}

While loops are activated if the associated condition is true from the outset.
In contrast, do-while loops, first execute the loop body before evaluating the
loop condition. This guarantees that the loop body runs at least once,
irrespective of whether the condition is initially false. Do-while loops are
defined with the syntax \token{do V while C}, where \token{V} represents the
value evaluated upon entering the loop, and \token{C} is the condition that
halts the loop when it evaluates to \token{false}.

\begin{lstlisting}[style=coloredverbatim, caption=Simple do while loop, label=lst:simple_do_while_loop]
let mut count = 0;

do {
  count += 1;
} while (count < 5)

assert (count == 5);
\end{lstlisting}

\input{images/simple_do_while_loop}

\subsection{While-let loop}
\label{sec:while_let_loop}

In conditional branching, as discussed in Section~\ref{sec:cond_pattern}, a
pattern can serve as the condition. This capability, similar to its usage in if
conditionals, is available for while loops. However, it is not applicable for
do-while loops. In the following given example, the loop continues as long as
the option contained within the variable \token{x} holds a value and halts
either when it doesn't hold a value or when its value exceeds \token{5}. The
code presented in Listing~\ref{lst:while_let_rewritten} exhibits identical
behavior, albeit implemented using a loop construct and an if let conditional,
as the compiler rewrites the code from Listing~\ref{lst:while_let_example}.

\begin{lstlisting}[style=coloredverbatim, caption=While-let example, label=lst:while_let_example]
fn foo (i : i32)-> i32?;

let mut x = foo (0);
let mut count = 0;

while let Ok (z) = x && z < 5 {
  count += 1;
  x = foo (count);
}
\end{lstlisting}

\begin{lstlisting}[style=coloredverbatim, caption=While-let rewritten using loop and if-let, label=lst:while_let_rewritten]
fn foo (i : i32)-> i32?;

let mut x = foo (0);
let mut count = 0;

loop {
  if let Ok (z) = x && z < 5 {
    count += 1;
    x = foo (count);
  } else break;
}
\end{lstlisting}

\subsection{While loop value}

While loops don't inherently produce any values, as there's no assurance that
the loop will be entered and a value constructed. Conversely, do-while loops are
guaranteed to be entered at least once, potentially allowing for a value to be
constructed. However, to maintain consistency with basic while loops, it was
decided not to allow value construction from do-while loops. In essence, only
infinite loops defined with the \token{loop} keyword have the capability to
construct a value. As a consequence, a \textit{break} statement within a
\textit{while} or \textit{do-while} loop cannot be linked with a value and must
always yield a \token{void} result.

\section{Iteration loop}%
\label{sec:for_loop}

\section{List comprehension}%
\label{sec:list_compr}

\section{Disposing block}%
\label{sec:with_block}

\section{Scope guards}%
\label{sec:scope_guards}

\section{Threads synchronization}
