\section{Preamble}

Control flows are generally decided at run time, i.e. the generated machine code
contains a machine-level representation of the control flow, and it is decided
at run time which branches are traversed. These decisions could also be made at
compile time, using the keyword \texttt{cte} for \textit{Compile Time
  Execution}, with some requirements. Since these requirements depend on the
type of control flow construct used, they will be detailed in each specific
section, but they always involve the compiler needing to know some values at
compile time. The \texttt{cte} control flow is consistent with the concept of
conditional compilation introduced in
Chapter~\ref{chap:conditional_compilation}.

\section{Variables, scope and lifetime}
\label{sec:variable_lifetime}

The first construct is a simple scope. Defined by opening and closing curly
braces, a scope determines the lifetime of the variables declared within it.
Variables are declared using the keyword \texttt{let} followed by an identifier
and an optional type (using the token \texttt{:}). The lifetime of a variable
begins when it is declared and ends when the scope containing the variable
declaration is exited. Two variables with the same name cannot be alive at the
same time.

\begin{lstlisting}[style=coloredverbatim]
fn main () { // start of a scope
  let a = 12;
  { // start of a second scope

    println (b + a); // error, /b/ is not defined yet
    let b = 24;

    println (b + a); // Ok, /b/ and a are defined

    let a = 89; // error, /a/ is already defined
  } // exiting the second scope

  println (b + a); // Error, /b/ does not exist anymore
  let b = 9; // ok, /b/ from second scope is not alive anymore
}
\end{lstlisting}

\subsection{Scope value}

As presented in section~\ref{sec:function_body}, a scope has a value if the last
expression contained in the scope is a value and does not end with the
\texttt{;} token. The value can be used as any other expression value (e.g. as
the value of a variable declaration).

\begin{lstlisting}[style=coloredverbatim]
let a = {
  let b = 12;
  b + 12
};

let c = {
  let b = 12;
  b + c // error, /c/ does not exist yet
};
\end{lstlisting}

\subsection{Variable initial value}

A variable is always declared with an initial value. The goal is to ensure that
any data in the program came from somewhere, and is not initialized from a
random memory state of the machine running the program (as we can have in the C
language). One can argue that static verification can be used to ensure that a
variable is set before it is used, and argue that forcing an initial value on a
variable is not the best way to achieve data validity. While this is more a
matter of opinion than sound scientific reasoning at this point, we believe that
scattering the initialization of a variable makes programs harder to read. In
addition, immutable variables would initially be mutable, making the behavior of
a program even more difficult to understand. In the following listings, two
examples of source code with the same behavior are presented. On the left, a
valid source code that is accepted by the Ymir language, and on the right, a
source code that is not accepted based on the arguments we presented.



\hspace{-15pt}%
\begin{minipage}[t][][t]{0.47\linewidth}
  \begin{lstlisting}[style=coloredverbatim, caption=Valid]
fn foo (cond : bool) {
  let i = if cond {
    42
  } else {
    7
  };
}
  \end{lstlisting}
\end{minipage}\hspace{10pt}%
\begin{minipage}[t][][t]{0.47\linewidth}
  \begin{lstlisting}[style=coloredverbatim, caption=Invalid]
fn foo (cond : bool) {
  let i : i32;
  if cond {
    i = 42;
  } else {
    i = 7;
  };
}
  \end{lstlisting}
\end{minipage}


\subsection{Unused variable}

A declared variable has to be used during its lifetime, otherwise the compiler
will send an error, as the variable is useless and only complexify the source
code with dead code.

\begin{lstlisting}[style=coloredverbatim]
{
  let a = 12;
} // error, /a/ is defined but not used
\end{lstlisting}

There are two ways to force the compiler to ignore an unused variable, the first
is to use a special identifier for the variable, either by putting an underscore
at the beginning and end of the variable (e.g. \texttt{\_a\_}), or by naming the
variable directly \texttt{\_}. A variable named \texttt{\_} is anonymous and
cannot be used at all. The second way is to use the variable in a statement.
This statement can be empty (i.e. \texttt{a;}). Function parameters follow the
exact same semantic, and therefore must be used within the body of the function.
They can be used or ignored with the same system as local variables.

\begin{lstlisting}[style=coloredverbatim]
{
  let _a_ = 12;
} // ok, /_a_/ is an ignorable variable

{
  let _ = 12;
} // ok, /_/ is anonymus

{
  let a = 12;
  a; // using the variable
} // ok, all variables were used
\end{lstlisting}

\subsection{Variable type}

The type of the variable is automatically infered from the value that is
associated to it. Sometimes the compiler may fail the inference, or multiple
types can be associated to a specific value by implicit casting. To solve that
problem a type can be attached to a variable declaration using the token
\texttt{:}. The type specified must of course be compatible with the type of the
value.

\begin{lstlisting}[style=coloredverbatim]
let a = 12; // automatically infering i32
let b : i32 = 12; // declaring i32

let c : i64 = 12; // ok, implicit cast to i64
let d : [c8 ; 5] = "Hello"; // ok implicit cast from [c8] to [c8 ; 5]
\end{lstlisting}

Some values needs an explicit type to be used as variable initialization values. For example the value \texttt{none} that creates an empty option values has no inner type on its own. In fact its inner type is deduced from the type of the lvalue that will receive it during affectation. Other types such as \texttt{void} can simply not be used for variable declaration as they do not contain a value. To create a variable with no value, an empty tuple \texttt{()} can be used.

\begin{lstlisting}[style=coloredverbatim]
let a = none; // error, cannot create a variable with type (none)?
let b : (i32)? = none; // ok, type is explicitely defined

let c = {}; // error, cannot create a var of type void
let d : void = {}; // error, even by explicitely writing it

let e = (); // ok empty tuple
let f : () = (); // ok, same as /e/
\end{lstlisting}

\subsection {Variable mutability}

A variable is immutable by default, but can be made mutable using the
\texttt{mut} and \texttt{dmut} keywords. We saw in
Section~\ref{sec:preamble_compound_types} that values can borrow data depending
on their type. Since all the mutability information about specific types has
already been discussed in Chapter~\ref{chap:compound} for native compound types
and in Chapter~\ref{chap:custom_types} for user-defined types, we will not
discuss it further.

Because type mutability is recursive, an inner type can only be mutable if the
type containing it is also mutable, which also means that for a value inside a
variable to be mutable, the variable must also be mutable. This behavior for
local variables is different from that of function parameters, as presented in
Section~\ref{sec:mutable_parameter}.

\begin{lstlisting}[style=coloredverbatim]
let a = 12;
a = 9; // error, /a/ is immutable

let mut b = 12;
b = 9; // ok, /b/ is mutable


let c : [mut i32] // error, /c/ is immutable, its inner value cannot be mutable
      = copy [1, 2, 3];

let mut d : [mut i32]  // ok, /d/ is of type mut [mut i32]
          = copy [1, 2, 3];


let dmut e = copy [1, 2, 3]; // same as /d/

d [0] = 9; // ok
e [0] = 10; // ok

let mut f = copy [1, 2, 3]; // /f/ is of type mut [i32]
f [0] = 0; // error, inner value of /f/ is immutable
f = copy [4, 5]; // ok, /f/ is mutable
\end{lstlisting}

\subsection{Reference variable}

The \texttt{ref} keyword can be used to decorate a variable when constructing it
with the \texttt{let} construct. This decorator is used to specify that a
variable is a reference to another lvalue, it follows exactly the same rules as
presented for reference parameters in Section~\ref{sec:ref_param}. Only lvalues
can be referenced.

\begin{lstlisting}[style=coloredverbatim]
let dmut a = [1, 2, 3];
let ref b = a; // no copy of /a/

println (b [0]); // 1

a [0] = 89;
println (b [0]); // 89

b [0] = 9; // error, b is immutable
\end{lstlisting}

In the above example, \texttt{b} is a pointer to the value of \texttt{a},
meaning that when the value of \texttt{a} changes, so does the value of
\texttt{b}. The following listing shows the YIL representation of the above
code, and Figure~\ref{fig:ref_variable} illustrates the state of the stack when the
program is executed on a 64-bits system.

\begin{lstlisting}[style=intermediateVerb]
let a(#1) : [i32;3];
let b(#2) : *([i32;3]);
a(#1) = [1, 2, 3];
b(#2) = &a(#2);
_Y3std2io7printlnNi32Fi32Zv(*b(#2)[0]);
a(#1)[0] = 89;
_Y3std2io7printlnNi32Fi32Zv(*b(#2)[0]);
\end{lstlisting}

\input{images/ref_variable}

A reference variable can be mutable as long as the value it references is also
mutable, and the contract has been accepted with the \texttt{ref} keyword. It
follows the same rules presented in Section~\ref{sec:mut_ref_param} for mutable
reference parameters.

\begin{lstlisting}[style=coloredverbatim]
let mut a = 12;
let mut ref b = ref a; // ok

b = 90;
println (a); // 90
\end{lstlisting}

As for mutable reference parameters, the keyword \texttt{ref} is mandatory to
accept the mutable reference contract. This keyword can only be used on an
lvalue. In the next example, the contract is not respected at line 2. At line 5,
even if the variable is an lvalue and the keyword \texttt{ref} is used, because
the mutability of \texttt{c} is not deep enough to fit into the mutability of
the variable \texttt{d}, the compiler sends an error.

\begin{lstlisting}[style=coloredverbatim]
let mut a = 12;
let mut ref b = a; // error, mutable reference requires ref keyword

let mut c : [i32] = copy [1, 2, 3];
let dmut ref d = ref c; // error, cannot fit mut [i32] into mut [mut i32]
\end{lstlisting}


\subsection{Pattern variable declaration}

Variable declaration can be done using a pattern instead of a single variable
declaration. Available patterns are fully described in
Section~\ref{sec:pattern_matching} about pattern matching. If the pattern is
irrefutable (the condition to match the pattern is known at compile time and is
always true), then the variable defined within the pattern can be declared.
Patterns can be used for many things, such as deconstructing tuples, arrays,
accessing class fields, etc.
\begin{lstlisting}[style=coloredverbatim]
// Decomposing a tuple
let t = (1, 't', 12.0f);
let (x, y, z) = t;
let (w, _...) = t; // taking only the first value, ignoring the rest
\end{lstlisting}

\begin{lstlisting}[style=coloredverbatim]
// Decomposing an array
let a = [1, 2, 3];
let [i, j, k] = a;
let [l, m, _...] = a; // taking only the first two values ignoring the rest
\end{lstlisting}

\begin{lstlisting}[style=coloredverbatim]
class A {
  pub let i : i32;
  pub self (i : i32) with i = i {}

  @field
  pub fn len (self)-> i32 {
    2
  }
}

let a = A::new (1);

// accessing fields of a, and declaring two variables x and y
let A (i-> x, len-> y) = a;
\end{lstlisting}

The lifetime of variables declared using pattern variable declaration is the
same as that of variables declared using standard declaration. In fact, there is
no standard declaration, a variable declared with the syntax \texttt{let a : i32
  = 12} uses the pattern \texttt{a : i32} with the matching value \texttt{12}
and is therefore irrefutable.

Refutable patterns (that are unknown at compile time) must be coupled with
conditional branching (cf. Section~\ref{sec:if_else}) as they may or may not
create new variables depending on the result of the pattern evaluation.

\begin{lstlisting}[style=coloredverbatim]
fn foo ()-> i32?;

let Ok (x : i32) = foo (); // error, refutable since it may fail if /foo/ returns /none/
\end{lstlisting}

\subsection{Pattern variable mutability and references}

The value that is passed to pattern must respect mutability of borrowed values,
and therefore as any data movement must use the keyword \texttt{alias} to
perform mutable borrowed data movement. Because the keyword is recursive, an
inside pattern deconstruction may impact mutable access to inner values. In the
next example, the variable \texttt{a} has mutable access to borrowed data from
\texttt{t}, when the variable \texttt{b} has only const access to its second
field, however the keyword \texttt{alias} has to be used over the value
\texttt{t} to allow mutable access from \texttt{a}.

\begin{lstlisting}[style=coloredverbatim]
let dmut t = (copy [1, 2], copy [2, 3]);
let (dmut a : [i32], b : [i32]) = alias t;
//     /alias/ is mandatory here  ^^^^^

a [0] = 9;
t.1 [0] = 9;
println (t); // ([9, 2], [9, 3])
println (b); // [9, 3]
\end{lstlisting}

As for any variable declaration the keyword \texttt{ref} can be used to create a
reference to a lvalue. In that case, instead of the keyword \texttt{alias}, the
keyword \texttt{ref} has to be used to decorate the value that is being
referenced. In the next example, the variable \texttt{a} is a reference to the
first field of the tuple value stored in \texttt{t}.

\begin{lstlisting}[style=coloredverbatim]
let dmut t = (copy [1, 2], copy [2, 3]);
let (dmut ref a : [i32], _) = ref t;

a = copy [9, 8, 7];
println (t); // ([9, 8, 7], [2, 3]);
\end{lstlisting}

When values to variable associations are a mix of aliases and references, the
keyword \texttt{ref} must be used, in this unique case it allows for mutable
\texttt{alias}. The \texttt{alias} keyword can never be used to create a mutable
reference. In the next example, the variable \texttt{a} is a mutable reference
to the first field of the value stored in \texttt{t}, and the variable
\texttt{b} mutably borrows the same value as the second field of \texttt{t}. In
this case, a mutable reference and a mutable alias are created at the same time,
so the keyword \texttt{ref} is used to decorate the associated value to allow
this. However, in line \texttt{4}, the use of the keyword \texttt{ref} is not
allowed, since neither \texttt{c} nor \texttt{d} create a reference, the keyword
\texttt{alias} must be used.

\begin{lstlisting}[style=coloredverbatim]
let dmut t = (copy [1, 2], copy [2, 3]);
let (dmut ref a, dmut b) = ref t; // ok, /ref/ replaces /alias/ in that case

let (dmut c, dmut d) = ref t; // error, no mutable references needed, thus /alias/ has to be used
\end{lstlisting}

If there is no mutable alias and no mutable reference, then the keyword is not
allowed to decorate the associated value, to avoid using the keywords by default
resulting in the opposite of their purpose (helping developers to easily spot
the locations of mutable memory movements, and possible side effects).

\begin{lstlisting}[style=coloredverbatim]
let dmut t = (copy [1, 2], copy [2, 3]);
let (a, b) = alias t; // error, /alias/ is useless
let (c, d) = ref t; // error, /ref/ is useless
\end{lstlisting}

\section{Conditional branching}%
\label{sec:if_else}

A conditional control flow can be defined using the keywords \texttt{if} and
\texttt{else}. The syntax \texttt{if C V} defines that the value \texttt{V} is
evaluated if and only if the condition \texttt {C} of type \texttt {bool} is
true. Using the keyword \texttt{else} this construction can be extended to
provide another value to evaluate if the condition is not met. The if condition
at line 2 in the next example generates a runtime conditional representation
that can be represented by the flow graph presented in
Figure~\ref{fig:if_cond_simple}, or by the YIL code in
Listing~\ref{lst:if_cond_simple}.

\begin{lstlisting} [style=coloredverbatim]
fn foo (cond : bool)-> i32 {
  if cond {
    89
  } else {
    11
  }
}

let x = foo (true); // /x/ evaluated to 89
let y = foo (false); // /y/ evaluated to 11
\end{lstlisting}

\input{images/if_cond_simple}

\begin{lstlisting}[style=intermediateVerb, caption=Simple condition, label=lst:if_cond_simple]
frame :  _Y4main3fooFbZi32 (let cond(#1) : u8)-> i32 {
    let YI_2(#2) : i32;
#IF cond(#1)
#THEN_GOTO then(#1)
#ELSE_GOTO else(#3);
#LABEL then(#1);
    YI_2(#2) = 89;
#GOTO end(#2);
#LABEL else(#3);
    YI_2(#2) = 11;
#GOTO end(#2);
#LABEL end(#2);
    return YI_2(#2);
}
\end{lstlisting}



\subsection {Conditional value}

A \texttt{if} construct has a result value if all branches have a result value.
The type of the expression is the type of the first branch, i.e. the type of the
value of the first \texttt{if}. The value of the \texttt{else} branch is
implicitly cast to the type of the first branch value, if this is not possible
the compiler returns an error.

\begin{lstlisting}[style=coloredverbatim]
let a = if cond {
  12
}; // error, no else value

let b = if cond {
  12
} else {
  "str"
}; // error, incompatible i32 and [c8]

let d = if cond {
  12
} else {
  11u32
}; // ok, implicit cast of 11u32 to i32
\end{lstlisting}

\subsection{Mutable conditional value}

If the type of the \texttt{else} branch is compatible with the type of the first
branch, but does not match its mutability, the mutability of the result value of
the \texttt{if} construct is reduced to match the most restricted value. In the
next example, because the value of the \texttt{else} branch has a more
restricted mutability than the value of the \texttt{if} branch, the result type
of the expression takes the mutability of the \texttt{else} branch, and thus the
result value is of type \texttt{mut [i32]}.

\begin{lstlisting}[style=coloredverbatim]
let a = copy [1, 2, 3];
let dmut b = if cond { // error, mutability does not fit in /b/
  copy [2, 3, 4] // mut [mut i32]
} else {
  a
}; // mut [i32]
\end{lstlisting}

As for scope values when returning a mutable borrowed value, because
the \texttt{alias} contract is already accepted within the value of the
branches, it is not necessary to accept it again for the result value of the
\texttt{if} construct. Therefore, in the next example, the keyword
\texttt{alias} is not used before the keyword \texttt{if}, even though the
affectation to \texttt{b} moves borrowed mutable data.

\begin{lstlisting}[style=coloredverbatim]
fn foo (cond : bool) {
  let dmut a = copy [1, 2, 3];
  let dmut b = if cond {
    alias a // alias is mandatory here
  } else {
    copy [2, 3, 4]
  };
}
\end{lstlisting}


\subsection{Chaining conditions}

Conditions can be chained by following the \texttt{else} with another
\texttt{if} condition. In fact, this does not really chain the condition, since
in this case the \texttt{if} condition following the \texttt{else} keyword is
the value that is evaluated in case the condition of the first \texttt{if} is
not true. To illustrate, the following source code presents two chained
\texttt{if} conditions that are exactly similar in semantics.


\begin{minipage}[t][][t]{0.47\linewidth}
\begin{lstlisting}[style=coloredverbatim, caption=Using a \texttt{if} as the value of the \texttt{else} branch]
if cond {
  println ("First condition is true");
} else if cond2 {
  println ("Second condition is true");
} else {
  println ("None of the conditions were true");
}
\end{lstlisting}
\end{minipage}\hspace{10pt}%
\begin{minipage}[t][][t]{0.47\linewidth}
  \begin{lstlisting}[style=coloredverbatim, caption=Using a block as the value of the \texttt{else} branch]
if cond {
  println ("First condition is true");
} else {
  if cond2 {
    println ("Second condition is true");
  } else {
    println ("None of the conditions were true");
  }
}
  \end{lstlisting}
\end{minipage}
\vspace{-10pt}%

\subsection{Early return branch}


We have seen in Section~\ref{sec:function_early_return} that a function can exit
early in three different ways (i.e., \texttt{return}, \texttt{throw}, or
\texttt{panic}). Such an early exit can happen inside a branch of a conditional
value. In this case, that particular branch is considered a return branch and
therefore has no value. In Section~\ref{sec:inf_loop} we will see a construction
that can also exit a branch of the flow graph without constructing a value (i.e.
\texttt{break}). As a result, the \texttt{if} construction can sometimes have a
result value even though not all branches construct a value.

\smallskip

\begin{lstlisting}[style=coloredverbatim, caption=Early return in \texttt{if} condition, label=lst:if_cond_early_return]
fn foo (cond : bool)-> i32 {
  let a = if cond {
    return 89; // exits the function
  } else {
    10
  }; // ok, all non-returning branches have a value

  a + 9
}
\end{lstlisting}

In the example presented in Listing~\ref{lst:if_cond_early_return}, the value of
the variable \texttt{a} can be constructed. In fact, if the condition is not
true, the value of \texttt{a} will be 10, and if the condition is true, then the
function exits, so the value of \texttt{a} does not need to be evaluated in this
case. Figure~\ref{fig:if_cond_early_exit} shows the flow graph resulting from
this source code. You can clearly see from this graph that in the flow that the
first branch follows (when the condition is met), the variable \texttt{a} is
never needed, and therefore does not need to be constructed for the code to be
correct.

\input{images/if_cond_early_return}

\section{Infinite loop}%
\label{sec:inf_loop}

\section{Conditional loop}%
\label{sec:while_loop}

\section{Iteration loop}%
\label{sec:for_loop}

\section{List comprehension}%
\label{sec:list_compr}

\section{Disposing block}%
\label{sec:with_block}

\section{Scope guards}%
\label{sec:scope_guards}
