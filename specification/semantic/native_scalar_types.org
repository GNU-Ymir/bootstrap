

* Integers

Integer types refer to numbers without decimal point. There a two kind of
integers, signed and unsigned ones. The type of signed integers starts with the
letter ~i~ where unsigned ones start with the letter ~u~. The size of the type
in bits is written in the type itself, for example ~i32~ is a signed int of 32
bits. The following table presents the list of integer types implemented in the
version 1.0 of ymirc. ~usize~ and ~isize~ are architecture dependant and have a
size in bits that depends on the size of the pointers on the targeted system,
(i.e. 32 bits on 32 bits systems, 64 bits on 64 bits system, and so on)

|------+---------+----------|
| size | signed  | unsigned |
|------+---------+----------|
|------+---------+----------|
|    8 | ~i8~    | ~u8~     |
|   16 | ~i16~   | ~u16~    |
|   32 | ~i32~   | ~u32~    |
|   64 | ~i64~   | ~u64~    |
| arch | ~isize~ | ~usize~  |
|------+---------+----------|

** Literals

Integer literals can be written using four forms:
1. octal, starting with ~0o~ and containing only numbers ranging from ~0~ to ~7~.
   ~0o71217~
2. hexadecimal, starting with ~0x~ and containing numbers ranging from ~0~ to ~9~ and letters ranging from ~a~ to ~f~ in lower or upper case.
   ~0xAB87fe~
3. Binary, starting with ~0b~ and containing numbers ranging from ~0~ to ~1~. ~0b10010~.
4. Decimal , starting with nothing special and containing numbers ranging from ~0~ to ~9~.
   ~182993~


All four forms can also contain the token ~_~ to separate long integer literal
and make them more readable (i.e. ~1_000_000_000~). There can be as many ~_~ as
wanted, there are just removed during the compilation.

Literal have to end with a suffix to define a literal from another int type than
~i32~. For example to define a literal of value ~67~ and of type ~i8~, the
following has to be written ~67i8~ or ~0x43i8~ or ~0o103i8~. A verification is
made during the compilation to ensure that the selected int type has enough
bytes to encode the expected literal. Suffixes for ~isize~ and ~usize~ are
respectively ~is~ and ~us~.

** Properties

Integer properties are accessed using the operator ~::~ (as for any type) on a type expression. The properties are the following :

|----------+----------------------------------------+-------------|
| name     | value                                  | type        |
|----------+----------------------------------------+-------------|
|----------+----------------------------------------+-------------|
| ~init~   | The initial value ~0~                  | ~typeof(x)~ |
| ~max~    | The maximum value the type can encode  | ~typeof(x)~ |
| ~min~    | The minimum value the type can encode  | ~typeof(x)~ |
|----------+----------------------------------------+-------------|
| ~typeid~ | A string encoding the name of the type | ~[c8]~      |
|----------+----------------------------------------+-------------|

Example :
\begin{code}
println (i32::max); // 2_147_483_647
println (i16::min); // -32_768
\end{code}


** Casting

- To other integers :

  It is impossible to change the type of an int value implicitely meaning it is
  impossible to transform a value of type ~i32~ to value of type ~i64~ without
  specifically mentionning it. The cast operator ~cast!T (V)~ can transform any int
  type to another int type.

  There is one exception to the previous rule. If a literal value is written
  without suffix, it can be transformed into a value of any int type as long as
  it is known at compilation time. Overflow checking is performed to ensure the
  casting is possible.

  For example, the following is allowed :
  \begin{code}
  def foo (a : u64) { // ... }

  let a : i64 = 1;
  foo (7 + a); // 7 + a can be known at compilation time, 'a' is immutable and cte
  \end{code}

- To char types :

  The cast operator can be used to transform a int type of type ~u8~ into a
  ~c8~, a ~u32~ to a ~c32~ and a ~u16~ into a ~c16~ and converserly (e.g. ~c8~
  to ~u8~). That is the only allowed casting from int to chars. No implicit
  casting is allowed. The transformation does not modify the value in any way
  (exactly the same bits before and after the cast).

- To float types :

  The casting to floating point types is allowed from any int type whose type
  has a size of at least ~4~ bytes (~i32~, ~u32~ and higher) to any floating
  point type, and converserly using the cast operator. This is the only allowed
  casting from int to float types. No implicit casting is allowed. The value
  encoding is modified to be correctly represented. Indeed, int and float have
  completely different ways of representing types in memory. The value is
  truncated when transformed from a float to an int. And there may be some
  stepping when transforming an int value into a float values due to the holes
  present in the set of values representable by float encoding system.

** Unary operators

The following unary operators can be used on int types :
 | Operator | Operation                                                                       | Example      |
 |----------+---------------------------------------------------------------------------------+--------------|
 |----------+---------------------------------------------------------------------------------+--------------|
 | ~-~      | Opposite value                                                                  | ~-19~        |
 |----------+---------------------------------------------------------------------------------+--------------|
 | ~!~      | Byte Not, inverts each bit from the binary representation of the int value.     | ~!19 == -20~ |
 |          | This is semantically the same as calculating ~-x-1~ (if the integer is signed)  |              |
 |----------+---------------------------------------------------------------------------------+--------------|

The result of unary operations always has the same type as the operand used in the operation. Opposite operator ~-~ is not usable on unsigned type, as they cannot be negative.


** Binary operators

Binary operators involving an int operand can only be used when the two operands
are of type int. There are two exception to that rule 1. When the operation
involves an object operand that has overriden the said binary operator (as left
or right operand), 2. When on of the operand is a char type or a pointer type.
Binary operators involving char types are presented in the section about char
types, and involving pointer types are presented in the chapter about compound
types.

Binary operators are divided into 5 groups:
- Math :

  Binary math operators are usable using two int values whose types have the
  same signed property (two signed operands or two unsigned operands, but not a
  mix). The result of the operation takes the type of the biggest of the two
  operands for example for an addition between a ~i64~ and a ~i32~ (e.g. ~12 +
  78i64~), the result takes the type ~i64~. There is an exception, being the
  exponant operator, where the right operand is always a ~i32~, and the results
  always takes the type of the left operand.

  #+ATTR_LATEX: :align |c|lll|
  |----------+----------------------+-------------+---------------|
  | Operator | Operation            | Commutative | Example       |
  |----------+----------------------+-------------+---------------|
  |----------+----------------------+-------------+---------------|
  | ~+~      | Addition             | Yes         | ~1 + 2 == 3~  |
  | ~-~      | Subtraction          | No          | ~2 - 1 == 1~  |
  | ~*~      | Multiplication       | Yes         | ~3 * 4 == 12~ |
  | ~/~      | Division (truncate)  | No          | ~13 / 3 == 4~ |
  | ~%~      | Rest of the division | No          | ~13 % 3 == 1~ |
  | ~^^~     | Exponant             | No          | ~3^^4 == 81~  |
  |----------+----------------------+-------------+---------------|

- Bytes :

  Bytes binary operators are usable using two int values having exactly the same type (e.g. ~i64~ with and only with ~i64~).

   #+ATTR_LATEX: :align |c|l l l l|
   |--------------------+------------------+-------------+--------------------+-----------------------------|
   | Operator           | Operation        | Commutative | Example            | Binary explanation          |
   |--------------------+------------------+-------------+--------------------+-----------------------------|
   |--------------------+------------------+-------------+--------------------+-----------------------------|
   | \texttt{\(\vert\)} | Byte Or          | Yes         | ~1~ \vert ~2 == 3~ | ~(001~ \vert ~010 == 011)~  |
   | ~&~                | Byte And         | Yes         | ~1 & 2 == 0~       | ~(001 & 010 == 000)~        |
   | ~^~                | Byte Xor         | Yes         | ~1 ^ 3 == 2~       | ~(001 ^ 011 == 010)~        |
   | ~>>~               | Byte left shift  | No          | ~32 >> 2 == 8~     | ~(100000 >> 010 == 001000)~ |
   | ~<<~               | Byte right shift | No          | ~8 << 2 == 32~     | ~(001000 << 010 == 100000)~ |
   |--------------------+------------------+-------------+--------------------+-----------------------------|


- Logical :

  Binary logical operators are usable using two int values whose types have the
  same signed property (two signed operands or two unsigned operands, but not a
  mix). The biggest type of the two integers is used to cast the value of the
  operand with the smallest type. The result of the operation always takes the
  type ~bool~.

  #+ATTR_LATEX: :align |c|lll|
  |----------+------------------+-------------+----------------------|
  | Operator | Operation        | Commutative | Example              |
  |----------+------------------+-------------+----------------------|
  |----------+------------------+-------------+----------------------|
  | ~>~      | Greater than     | No          | ~(12 > 11) == true~  |
  | ~<~      | Lower than       | No          | ~(12 < 11) == false~ |
  | ~>=~     | Greater or equal | No          | ~(14 >= 14) == true~ |
  | ~<=~     | Lower or equal   | No          | ~(11 <= 19) == true~ |
  | ~==~     | Equal            | Yes         | ~(10 == 10) == true~ |
  | ~!=~     | Not equal        | Yes         | ~(10 != 10) == false~ |
  |----------+------------------+-------------+----------------------|

- Affectation :

  The affectation operator ~=~ is usable when the two operands have strictly the
  same int type. The left operand must be a mutable lvalue (e.g. a mutable
  variable, a slice access, etc.). Affectation operator can be mixed with a math
  or byte operator (e.g. ~+=~, ~&=~, etc.). In that case the operation ~x += y~
  is rewritten into ~x = x + (y)~, where the y operand has always higher
  priority than the affectation operator. For example the operation ~x *= 12 +
  3~ will be rewritten into ~x = x * (12 + 3)~ even though the multiplication
  operator has a higher priority than the addition operator, meaning that the
  result of ~x *= (12 + 3)~ is different to the result of ~x = (x * 12 + 3)~.

  \begin{code}
  let mut a = 11;
  let b = a * 12 + 3;
  a *= 12 + 3;

  assert (b == 135);
  assert (a == 165);
  \end{code}

- Range :

  The range operator can be used on int values of strictly the same type,
  creating a ~range~ value. The range type is a native compound type that is
  described in the next chapter.

    |----------+------------------------------+------------+-----------|
    | Operator | Operation                    | Example    | Interval  |
    |----------+------------------------------+------------+-----------|
    | ~..~     | Range operator not inclusive | ~34 .. 12~ | ~[34;12[~ |
    | ~...~    | Range operator inclusive     | ~5 ... 89~ | ~[5;89]~  |
    |----------+------------------------------+------------+-----------|

 The result range value has a default step of ~1~ and its inner type is the type
  of the operand. It can be increasing or decreasing depending on the values
  used to construct it.

** Overflowing

Compile time verification of value overflowing is made on cte values. There is
no way to check an overflow at runtime, and it may occur.

* Floating point types

Floating point types refer to numbers with a decimal point. There are 4
floating, presented in the table below. Builtin floating point types conform to
the IEEE 754 arithmetic, meaning for example that ~f32~ have 1 bit of sign, ~8~
bits of exponent, and ~24~ (23 explicit) bits of mantissa. ~fsize~ type represent
the biggest floating point type that can be represented on the target
architecture.

| type   | size |  exp | mantissa          |
|--------+------+------+-------------------|
|--------+------+------+-------------------|
| ~f32~  |   32 |    8 | 24 (23 explicit)) |
| ~f64~  |   64 |   11 | 53 (52 explicit)  |
| ~f80~  |   80 |   16 | 64 (63 explicit)  |
| ~fsize~ | arch | arch | arch              |
|--------+------+------+-------------------|

** Literals

Floating point types can be written using three different forms, decimal, scientific notation.
1. Decimal, two decimal int literals seperated with the token ~.~ (with no
   white space in between). ~1837.0289~. The decimal part can be omitted
   meaning it is equal to ~0~ (e.g. ~10.~ is valid, but not ~.10~).

2. Scientific notation, same as decimal notation but ending with an exponent
   preceded by the letter ~e~ or ~E~. ~3.14e78 == (3.14 * 10.0 ^^ 78)~, meaning
   $3.14 \times 10^{78}$. A signed can be set for exponential part following the
   letter ~e~ or ~E~ with the token ~-~ or ~+~, e.g. ~3.e-10~. There cannot be
   any space in the literal.

3. Hexadecimal notation, starting with ~0x~, then two hexadecimal int literal
   separated with the token ~.~ followed by the letter ~p~ or ~P~, and finishing
   with a decimal int literal representing the exponential part. The fraction
   part can be empty, in that case the letter ~p~ follows the ~.~ token.
   However, the ~.~ token and the exponential part ~p~ are mandatory. A sign can
   be set for exponential part following the letter ~p~ or ~P~ with the token
   ~-~ or ~+~. There cannot be any space in the literal. Unlike scientific
   notation, the exponential part is a power of ~2~ instead of ~10~, e.g.
   ~0xA.p4 == (10.0 * 2.0^^4)~.

The three forms can also include the token ~_~ to separate long literals and
make them easier to read (e.g. ~124_732.789_281~, ~0x1.FFFF_FFFFp1023~,
~3.14_15_92e3f~). There can be as many ~_~ as wanted, there are just removed
during the compilation. Literals can end with a suffix to specify the type of the
literal; ~f~ to define ~f32~ literals, ~d~ to define ~f64~ (for ~double~), ~l~
for ~f80~ (for ~long~) and ~r~ for ~fsize~ (for ~real~). Literals with no suffix
are considered of type ~f64~. The literal ~4.5e10f~ and ~0.8f~, ~0x1.FFp10f~ are
of type ~f32~ when ~4.5e10~ and ~0.8~, ~0x1.FFp10~ are of type ~f64~.

\pagebreak

** Properties

Floating point properties are accessible using the operator ~::~ on a type expression. The properties are the following :

| Name         | Meaning                                                                                | Type        |
|--------------+----------------------------------------------------------------------------------------+-------------|
|--------------+----------------------------------------------------------------------------------------+-------------|
| ~init~       | The initial value - nan (Not a Number)                                                 | ~typeof(x)~ |
| ~max~        | The maximal finite value that this type can encode                                     | ~typeof(x)~ |
| ~min~        | The minimal finite value that this type can encode                                     | ~typeof(x)~ |
| ~nan~        | The value Not a Number                                                                 | ~typeof(x)~ |
| ~inf~        | The value positive infinity                                                            | ~typeof(x)~ |
| ~epsilon~    | The smallest increment to the value 1                                                  | ~typeof(x)~ |
| ~dig~        | The number of decimal digit of precision                                               | ~u32~       |
| ~mant_dig~   | Number of bits in the mantissa                                                         | ~u32~       |
| ~max_10_exp~ | The maximum value such that $10^{max\_10\_exp}$ is representable                       | ~i32~       |
| ~max_exp~    | The maximum value such that $2^{max\_exp-1}$ is representable                          | ~i32~       |
| ~min_10_exp~ | The minimum value such that $10^{min\_10\_exp}$ is representable as a normalized value | ~i32~       |
| ~min_exp~    | The minimum value such that $2^{min\_exp-1}$ is representable as a normalized value    | ~i32~       |
|--------------+----------------------------------------------------------------------------------------+-------------|
| ~typeid~     | A string encoding the name of the type                                                 | ~[c8]~      |
|--------------+----------------------------------------------------------------------------------------+-------------|

The ~min~ value is not the opposite value of the ~max~ value. The following
block describes the order relation between values of floating point types.

\begin{code}
     +     +-----------+------------+    ..   +    ..    +----------+----------+     +       #
-infinity -max        -1          -min        0          min        1         max  infinity  NaN
\end{code}


** Casting

- To other floating point types :

  It is impossible to change the type of a float value implicitely. The cast
  operator ~cast!T (V)~ can transform any float type into another float type.

- To integer types :

  The cast operator can be used to transform a float value of any float type
  into a int value whose type has a size of at least 4 bytes (~i32~, ~u32~ and
  bigger). When using the cast operator, the value is truncated to the floor
  value (e.g. ~1.3~ ~1.5~ and ~1.8~ are all truncated to ~1~), and everything
  that were part of the decimal part of the float value is lost. The opposite
  cast is also allowed (from any int type whose size is at least ~4~ bytes to
  any float type); in that case some stepping can occur due to floating point
  encoding.

Floating point types cannot be transformed into other types.

** Unary operators

The ~-~ unary operators can be used on floating point types. The result of the
operation is the opposite value, and has the same type as the operand of the
operation. For example ~-89.0f~ is of type ~f32~.

** Binary operators

Binary operators involving a float operand can be used only when the two
operands are floats. There is an exception to that rule when the operation
involves an object operand that has overriden the said binary operator (for left
or right operand). Binary operators are divided into 4 groups :
- Math :

  Binary math operators are usable using two float values. The result of the
  operation takes the type of the biggest operand (e.g. operation with ~f32~ and
  ~f64~ takes the type ~f64~).  Usable operators are described in the
  following table.

    #+ATTR_LATEX: :align |c|lll|
  |----------+------------------+-------------+-----------------------|
  | Operator | Operation        | Commutative | Example               |
  |----------+------------------+-------------+-----------------------|
  |----------+------------------+-------------+-----------------------|
  | ~+~      | Addition         | Yes         | ~1.0 + 2.3 == 3.3~    |
  | ~-~      | Subtraction      | No          | ~1. - 8. == -7.~      |
  | ~*~      | Multiplication   | Yes         | ~3. * 4. == 12.~      |
  | ~/~      | Division         | No          | ~7. / 3. == 2.333~    |
  | ~%~      | Rest of division | No          | ~7.23 % 3.09 == 1.05~ |
  | ~^^~     | Exponant         | No          | ~7. ^^ 3 == 343.~     |
  |----------+------------------+-------------+-----------------------|

  Power operator ~^^~ is a special operator that can take a float or an integer
  value as right operand. If both operands are float values, then they must
  share the exact same type, and result value takes the type of the operands. If
  the right operand is an int value, then the result of the operation takes the
  type of the left operand.

- Logical :

  Binary logical operators are usable using two float values. The biggest type
  of the two operands is used to cast the value of the operand with the smallest
  type. The result of the operation always takes the type ~bool~.

  #+ATTR_LATEX: :align |c|lll|
  |----------+------------------+-------------+----------------------|
  | Operator | Operation        | Commutative | Example              |
  |----------+------------------+-------------+----------------------|
  |----------+------------------+-------------+----------------------|
  | ~>~      | Greater than     | No          | ~(12 > 11) == true~  |
  | ~<~      | Lower than       | No          | ~(12 < 11) == false~ |
  | ~>=~     | Greater or equal | No          | ~(14 >= 14) == true~ |
  | ~<=~     | Lower or equal   | No          | ~(11 <= 19) == true~ |
  | ~==~     | Equal            | Yes         | ~(10 == 10) == true~ |
  | ~!=~     | Not equal        | Yes         | ~10 != 10) == false~ |
  |----------+------------------+-------------+----------------------|

- Affectation :

  The affectation operator ~=~ is usable when the two operands have strictly the
  same float type. The left operand must be a mutable lvalue (e.g. a mutable
  variable, a slice access, etc.). Affectation operator can be mixed with a math
  operator (e.g. ~+=~, ~/=~, etc.). In that case the operation ~x += y~
  is rewritten into ~x = x + (y)~, where the y operand has always higher
  priority than the affectation operator. For example the operation ~x *= 12. +
  3.~ will be rewritten into ~x = x * (12. + 3.)~ even though the multiplication
  operator has a higher priority than the addition operator, meaning that the
  result of ~x *= (12. + 3.)~ is different to the result of ~x = (x * 12. + 3.)~.

  \begin{code}
  let mut a = 11.0;
  let b = a * 12.0 + 3.0;
  a *= 12.0 + 3.0;

  assert (b == 135.0);
  assert (a == 165.0);
  \end{code}

- Range :

    The range operator can be used on two float values of strictly the same
  type, creating a ~range~ value. The range type is a native compound type that
  is described in this chapter.

    |----------+------------------------------+----------------+---------------|
    | Operator | Operation                    | Example        | Interval      |
    |----------+------------------------------+----------------+---------------|
    | ~..~     | Range operator not inclusive | ~34.f .. 12.f~ | ~[34.f;12.f[~ |
    | ~...~    | Range operator inclusive     | ~5.f ... 89.f~ | ~[5.f;89.f]~  |
    |----------+------------------------------+----------------+---------------|

 The result range value has a default step of ~1.0~ and its inner type is the
 type of the operand. It can be increasing or decreasing depending on the
 values used to construct it.

** Overflowing and stepping

  Because of the encoding of the float values, holes are presents in the set of
values they can represent. Thus, some operation that should be mathematically
equivalent do not always produce the same float value. To compare two float
values the property ~::epsilon~ can be used.

There is no check neither at compile time nor at runtime for value overflowing.


* Bool

Bool type is a simple type that can describe only two values ~true~ and ~false~.

** Literals

Boolean literals are the keywords ~true~ and ~false~.

** Properties

Properties of ~bool~ type are accessible using the operator ~::~ on a type
expression. The properties are the following :

| Name     | Meaning                                | Type   |
|----------+----------------------------------------+--------|
|----------+----------------------------------------+--------|
| ~init~   | The initial value ~false~              | ~bool~ |
|----------+----------------------------------------+--------|
| ~typeid~ | A string encoding the name of the type | ~[c8]~ |
|----------+----------------------------------------+--------|

** Casting

The ~bool~ type can be cast using the cast operator to the type ~u8~. This is
the only cast allowed for boolean type. It is impossible to transform a bool
value into a value of another type without explicitely using the cast operator.

** Unary operators

The unary operator ~!~ can be used on a boolean value to get its opposite value,
(i.e. ~!true~ becoming ~false~ and ~!false~ becoming ~true~).

** Binary operators

Binary operators involving bool operand can only be used if the two operands are
bool of type bool. There is an exception to that rule when the operation
involves an object operand that has overriden the said operator (as left or
right operand).

Binary operators are divided into 3 groups :
- Affectation

Affectation operators can be used to change the value of a mutable lvalue of
type bool using a right operand of type bool. Because there are no math
operators usable on a bool values, no math operator can be attached to the
affectation operation. ~&&=~ and ~||=~ are not valid operators, and their usage
will result in a syntax error.

- Comparison

The comparison ~==~ and ~!=~ are usable using two bool values, to respectively evaluate equality and inequality.

- Logical

logical operators are usable with two bool operands.
   #+ATTR_LATEX: :align |c|l l l|
   |-------------------------+-----------+-------------+-----------------------------------|
   | Operator                | Operation | Commutative | Example                           |
   |-------------------------+-----------+-------------+-----------------------------------|
   |-------------------------+-----------+-------------+-----------------------------------|
   | \texttt{\(\vert\vert\)} | Or        | No          | ~false~ \vert\vert ~true == true~ |
   | ~&&~                    | And       | No          | ~true && false == false~          |
   |-------------------------+-----------+-------------+-----------------------------------|

   Operator ~&&~ and ~||~ are marked not commutative. It is not because they can
   return a different value if left and right operands are reverted, but because
   for ~&&~, right operand is not evaluated if the left operand is false, and for
   ~||~, right operand is not evaluated if left operand is true. It can be useful
   when chaining tests.

   \begin{code}
   let i = 12;
   let p = &i;

   let a = p !is null && *p == 12;  // if 'p is null', '*p == 12' is not evaluated
   let b = p is null || *p != 12; // if 'p is null', '*p != 12' is not evaluated
   let c = true || foo (); // foo function is not called
   let d = false || foo (); // foo function is called
   \end{code}

* Characters

Character types are used to encode characters (ascii, or unicode). There are
three char types ~c8~, ~c16~ and ~c32~ with a respective size of ~8~, ~16~ and
~32~ bits. Those char types are encoding values in utf-8, utf-16 and utf-32.

** Literals
Char literals are enclosed by the token ~'~ , and can be described using three forms:
1. the binary representation of the character (e.g. ~π~),
2. Using an escape char. The escape char are described in the following table :

   | Value  | Content               |
   | ~\a~   | Alert beep, (Bell)    |
   | ~\b~   | Backspace             |
   | ~\f~   | Page break            |
   | ~\n~   | New line              |
   | ~\r~   | Carriage return       |
   | ~\t~   | Horizontal tab        |
   | ~\v~   | Vertical tab          |
   | ~\\~   | Backslash             |
   | ~\'~   | Apostrophe            |
   | ~\"~   | Double quotation mark |
   | ~\u{}~ | Unicode               |

3. int literal representation of the unicode. To not confuse the int literal
   reprentation with the literal of the int themselves, the int literal has to
   be encoded using the escape character ~\u~ and the tokens ~{~ and ~}~. For
   example ~\u{0x263A}~ or ~\u{10}~.

As for float or int literals, a suffix has to be added at the end of the literal
to define the value with the correct type. For example to define a ~c8~ value
containing the character ~a~, the following has to be written ~'a'c8~. Literal
with no suffix are considered of type ~c32~.

\begin{code}
let a : c32 = 'r';

let d = 'π';
let e = '\n'c8;

assert (e == b);
\end{code}

** Properties

The properties of char types are accessible using the ~::~ operator on a type expression. The properties are the following :

| Name     | Meaning                                | Type        |
|----------+----------------------------------------+-------------|
|----------+----------------------------------------+-------------|
| ~init~   | The initial value ~\u{0}~              | ~typeof(x)~ |
|----------+----------------------------------------+-------------|
| ~typeid~ | A string encoding the name of the type | ~[c8]~      |
|----------+----------------------------------------+-------------|

** Casting

Char types can be casted using the cast operator. It is impossible to transform a char value into a value of another type implicitely.

- To other char types :

  The cast operator can be used to transform a char of any size into a char of another size. This does not ensure encoding validity. Standard library defines more complexe transformation that respect the encoding in the module ~std::conv~.

- To integers types :

  The cast operator can be used to transform a char value of type ~c8~ into a
  ~u8~, a ~c16~ into a ~u16~ and a ~c32~ into a ~u32~. The transformation does
  not modify the value in any way (exactly the same bits before and after the
  cast).

** Unary operators

No unary operators are usable on chars.

** Binary operators

Binary operators on char are divided into four groups :

- Math:

  Binary math operators are usable using a char value and a unsigned int value
  (of the same size, e.g. for ~c8~ a ~u8~). The result always takes the type of
  the char operand.

  #+ATTR_LATEX: :align |c|lll|
  |----------+-------------+-------------+----------------------|
  | Operator | Operation   | Commutative | Example              |
  |----------+-------------+-------------+----------------------|
  |----------+-------------+-------------+----------------------|
  | ~+~      | Addition    | Yes         | ~'a' + 16u32 == 'q'~ |
  | ~-~      | Subtraction | No          | ~'q' - 16u32 == 'a'~ |
  |----------+-------------+-------------+----------------------|


  Char values can be used as right operands on math operation. The type of the
  result operation would still be the type of the char operand, and the int
  operand would still have to be of the same size as the type of the char
  operand, meaning that ~('q' + 12u32) == (12u32 + 'q')~.

- Logical :

Binary logical operators are usable using two char values of whose type are
exactly the same. The result of the operation always takes the type ~bool~.

  #+ATTR_LATEX: :align |c|lll|
  |----------+------------------+-------------+-------------------------|
  | Operator | Operation        | Commutative | Example                 |
  |----------+------------------+-------------+-------------------------|
  |----------+------------------+-------------+-------------------------|
  | ~>~      | Greater than     | No          | ~('q' > 'a') == true~   |
  | ~<~      | Lower than       | No          | ~('q' < 'a') == false~  |
  | ~>=~     | Greater or equal | No          | ~('q' >= 'q') == true~  |
  | ~<=~     | Lower or equal   | No          | ~('b' <= 'r') == true~  |
  | ~==~     | Equal            | Yes         | ~('a' == 'a') == true~  |
  | ~!=~     | Not equal        | Yes         | ~('a' != 'a') == false~ |
  |----------+------------------+-------------+-------------------------|

- Affectation :

  The affectation operator ~=~ is usable when the left operand is a mutable lvalue, and the right operand has strictly the same char type as the left operand.

  The affectation operator can be mixed with a math operator ~+=~ and ~-=~, in
  that case the right operand must be an unsigned int type whose size is exactly
  the size of the char type of the left operand. The affectation ~x += y~ will
  be rewritten into ~x = x + (y)~, where the y operand has always a higher
  priority than the affectation operator.

  \begin{code}
  let mut a = 'a';

  let b = a + 21u32;

  a = 'e';
  a += 7u32;

  assert (b == 'v');
  assert (a == 'l')
  \end{code}

- Range :

  The range operator can be used on two char values whose types are strictly identical, creating a range value.

    |----------+------------------------------+---------------+----------|
    | Operator | Operation                    | Example       | Interval |
    |----------+------------------------------+---------------+----------|
    | ~..~     | Range operator not inclusive | ~'a' .. 'z'~  | ~[a;z[~  |
    | ~...~    | Range operator inclusive     | ~'a' ... 'r'~ | ~[a;r]~  |
    |----------+------------------------------+---------------+----------|

  The result value has a default step of ~1~ and its inner type is the type of the operands. It can be increasing of decreasing depending on the values used to construct it.

** Overflowing

Compile time verification of value overflowing is made on cte values. The
verification ensure that the chosen type is big enough to encode the value.
There is no way to check an overflowing at runtime and it may occur. It is also
possible due the encoding that a value is not a valid unicode or ascii value if
it was created during runtime (e.g. ~'π' + 501u32~).

* Void

The void type is a special type that has no value. Unlike other type it cannot
be used to declare variables.

There is no literal to describe a void type has it cannot take any value. There
is no way to cast a void type into another type, there is no value to transform.
For the same reason there are no operators applicable to void types.

** Properties

The properties of a void type are accessible using the ~::~ operator on a type expression. The properties are the following :

| Name     | Meaning                                | Type        |
|----------+----------------------------------------+-------------|
|----------+----------------------------------------+-------------|
| ~typeid~ | A string encoding the name of the type | ~[c8]~      |
|----------+----------------------------------------+-------------|
