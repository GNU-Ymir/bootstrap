\section{Modules}%
\label{sec:modules}

A module is a first-level symbol that can contain other types of symbols. Any
other type of symbol is necessarily contained within a module.

\subsection{File module}

A source file declares a module symbol. Its name can be specified explicitly
with the keyword \texttt{in} as the first line of code. The purpose of this line
is for documentation purposes only, any comment above this line is considered
part of the documentation of the module symbol. The documentation syntax is
described in Chapter~\ref{chap:documentation}. The name of the module must
be the same as the file it is described in. For example, the file
\textit{foo.yr} should start with the line \texttt{in foo;}. This line is
optional.


\begin{lstlisting}[style=coloredverbatim]
/**
 * Documentation of the /foo/ module.
 * @Authors: John Doe
 * @Licence: GPLv3
 */
in foo;
\end{lstlisting}

A module can enclose other modules with the keyword \texttt{mod}. The name of
the enclosed module follows the keyword, and must be the name of the file being
enclosed. It can be a sibling file, or a child file (in the subdirectory with
the same name as the parent module). If both files exist (child and sibling),
the compiler will generate an error. Depending on whether they are child files
(in a directory whose name is the name of the enclosing module) or sibling
files, enclosed modules are either child or sibling. For example, assuming the
file hierarchy shown in Figure~\ref{fig:file_hierarchy}, the module located in
the file \textit{./foo/bar.yr} and enclosed by the module \textit{./foo.yr} will
be named \texttt{foo::bar} whereas the module located in \textit{./baz.yr}, even
if enclosed by the module \texttt{foo}, will be named \texttt{baz}. A complete
example is given below for the file hierarchy shown in
figure~\ref{fig:file_hierarchy}.

\input{images/file_hierarchy}

\noindent 1) Root directory :

\vspace{-5pt}%
\begin{minipage}[t][][t]{0.47\linewidth}
\begin{lstlisting}[caption=\textit{./foo.yr}, style=coloredverbatim]
in foo;

mod baz;
pub mod bar;
mod qux;

\end{lstlisting}
\end{minipage}\hspace{5pt}%
\begin{minipage}[t][][t]{0.47\linewidth}
\begin{lstlisting}[caption=\textit{./baz.yr}, style=coloredverbatim]
in baz;

pub fn pubFuncInBaz () {}
fn prvFuncInBaz () {}
\end{lstlisting}
\end{minipage}


\noindent 2) Subdirectory \textit{foo/}:

\vspace{-5pt}%
\begin{minipage}[t][][t]{0.47\linewidth}
\begin{lstlisting}[caption=\textit{./foo/bar.yr}, style=coloredverbatim]
in bar;

pub fn pubFuncInBar () {}
fn prvFuncInBar () {}
\end{lstlisting}
\end{minipage}\hspace{5pt}%
\begin{minipage}[t][][t]{0.47\linewidth}
\begin{lstlisting}[caption=\textit{./foo/qux.yr}, style=coloredverbatim]
in qux;

pub fn pubFuncInQux () {}
fn prvFuncInQux () {}
\end{lstlisting}
\end{minipage}


To compile all the sources of the above example, only one file has to be passed
to the compiler, here the file \textit{./foo.yr}. All inner modules declared in
the \texttt{foo} module will be reached and validated by the compiler. A file
hierarchy of source files is called a package, and always starts with a root
file. This is the main reason for sibling modules, as only one file is the entry
point of a package, whereas sometimes multiple root modules would be needed. The
following bash command line is used to compile the package. The
\texttt{-fdump-ymir} option is used to dump files representing what the compiler
generated at each stage, and \texttt{-nostdinc} to not automatically include the
standard library and runtime.

\begin{lstlisting}[style=intermediateVerb]
$ gyc foo.yr -fdump-ymir -nostdinc
\end{lstlisting}

The file \textit{foo.yr.ydump-decls.1} shows the symbol tree declared during the
declaration phase (before validation, so without template symbols -
\textit{foo.yr.ydump-decls.2} contains all declared symbols after validation, so
including the templates).

\begin{lstlisting}[style=intermediateVerb]
baz
    baz::prvFuncInBaz
    pub baz::pubFuncInBaz
pub foo
    pub foo::bar
        foo::bar::prvFuncInBar
        pub foo::bar::pubFuncInBar
    foo::qux
        foo::qux::prvFunctionInQux
        pub foo::qux::pubFunctionInQux
\end{lstlisting}

\subsection{Local module}

A module can be declared directly inside another module without using another
file. In this case, the module is considered a child module, and therefore the
result is identical to a file module located in a subdirectory. For example, the
\texttt{foo} module described above could have been written as follows. The
generated symbol tree is exactly the same.

\begin{minipage}{\linewidth}
\begin{lstlisting}[caption=\textit{./foo.yr}, style=coloredverbatim]
in foo;

mod baz;

pub mod bar {
  pub fn pubFuncInBar () {}
  fn prvFuncInBar () {}
}

mod qux {
  pub fn pubFuncInQux () {}
  fn prvFuncInQux () {}
}
\end{lstlisting}
\end{minipage}

\subsection{Protection}

The keywords \texttt{pub} (for public) and \texttt{prv} (for private) are used
to define the protection of a symbol. By default, a symbol is private. A private
symbol is accessible only by the module that declares it and by the other child
symbols declared in the same module. In other words, a module has access to all
the symbols it has declared and all the symbols declared by its parents. But it
does not have access to the private symbols declared by its child modules, or
those declared by siblings or cousins.

To clarify the situation, let's look at the symbol lookup algorithm. This
algorithm always starts with the symbol requesting access, then looks at its
siblings, then at the parent symbol and its siblings, and then at the
grandparents and their siblings. For example, if the symbol
\texttt{foo::bar::pubFuncInBar} makes a symbol lookup request, then three levels
of symbols are visible as described in the figure~\ref{fig:symbol_privacy}. In
addition to these levels, public symbols declared within visible symbols are
also visible, recursively.

\input{images/symbol_privacy}

As a result, the symbol \texttt{foo::bar::pubFuncInBar} has access to the symbol
\texttt{foo::qux::pubFuncInQux}, even if the symbol \texttt{qux} is declared
private by the parent module \texttt{foo}. On the other hand, the symbol
\texttt{foo::bar::pubFuncInBar} does not have access to
\texttt{foo::qux::prvFuncInQux}, nor does the symbol \texttt{baz} have access to
the module \texttt{foo::qux}.

\subsection{Package importation}

As we have seen, a package is compiled by passing the path to its root file to
the compiler. But a package may depend on other packages, which need to be
imported in order to use the symbols they describe. This is done by using the
compiler's \texttt{-I} option to import an external package and declare its
symbols in the symbol table. All symbols imported by this method are not
validated by the compiler (except for template symbols which are generated on
invocation - see Chapter~\ref{chap:templates}). So they have to be validated
manually and linked during symbol linking.

In the following example, let's consider two packages, the package \texttt{foo},
located in the directory \textit{/home/alice/mypackage/foo.yr}, which declares a
sub-module \texttt{bar}, and a second package \texttt{qux}, located in the path
\textit{/home/alice/external/qux.yr}, and which declares a module \texttt{baz}.

\begin{lstlisting}[caption=\textit{/home/alice/mypackage/foo.yr}, style=coloredverbatim]
in foo;

mod bar {
  pub fn tryAccessToBaz () {
    qux::baz::funcInBaz ();
  }
}
\end{lstlisting}

\begin{lstlisting}[caption=\textit{/home/alice/external/qux.yr}, style=coloredverbatim]
in qux;

pub mod baz {
  pub fn funcInBaz () {
    std::io::println ("Success !");
  }
}
\end{lstlisting}

In order for the module \texttt{foo::bar} to access the module
\texttt{qux::baz}, the following command line must be written. It will declare
the symbol \texttt{qux} as a sibling module of the root module \texttt{foo} and
thus with the same privacy protection as described above. Therefore, the module
\texttt{qux::baz} must be declared public to be accessible by the module
\texttt{foo} and its children.

\begin{lstlisting}[style=intermediateVerb]
$ gyc foo.yr -I ../external/qux.yr
\end{lstlisting}

Because the \texttt{qux} package is not validated, the above command will result
in a linking error stating that the symbol \texttt{qux::baz::funcInBaz} was not
found. This is a linking error, not a validation error. To correct this error,
the \texttt{qux} package must first be validated and then linked when compiling
the \texttt{foo} package.

\begin{minipage}{\linewidth}
\begin{lstlisting}[style=intermediateVerb]
$ cd /home/alice/external
$ gyc qux.yr -c // -c to create an object .o file
$ cd ../mypackage
$ gyc foo.yr -I ../external/qux.yr ../external/qux.o // add qux.o for the symbol linking
\end{lstlisting}
\end{minipage}

Note: The symbol \texttt{qux::baz::funcInBaz} has access to the symbol
\texttt{std::io::println} because the compiler includes the standard library
package by default. This import follows the same rules as any other package
import, and this package could be imported manually using the \texttt{-I}
switch, followed by the path to the standard library installation, and
\texttt{-nostdinc} to disable automatic import. This can be useful for testing
new or custom versions of the standard library. For more information on the
standard library and runtime, see Chapter~\ref{chap:std_and_core_runtime}.

\subsection {Using a module}

As you may have noticed, the full path of symbols has to be written to access
them, for example in \texttt{foo::bar:tryAccessToBaz} the access to the symbol
\texttt {qux::baz::funcInBaz} was in full letter. This can be cumbersome, so the
construction \texttt{use} was introduced. This construction is followed by the
ymir path of a module and describes that symbol names written in the current
symbol can come from this module. For example, let's say you need to use the
\texttt{println} often, then the \texttt{use std::io;} construction can be
useful. The use construction is enclosed in the symbol that makes the statement
and its children.

\begin{minipage}{\linewidth}
\begin{lstlisting}[caption=\textit{./foo.yr}, style=coloredverbatim]
in foo;

mod bar {
  use qux::baz;
  use std::io;

  pub fn tryAccessToBaz () {
    funcInBaz ();
    println ("io without full name");
  }
}


fn funcInFoo () {
  std::io::println ("Need full name, foo did not use std::io");
}
\end{lstlisting}
\end{minipage}
The declaration dump file \textit{foo.yr.ydump-decls.1} contains the list of
modules used within a given symbol. The core modules are the modules that are
automatically imported and used in every module when the \texttt{-nostdinc}
option is not used. They contain symbols used by the runtime and referenced by
the compiler to perform high-level operations (such as deep copies of slices,
exception throwing, etc.). More information about the runtime and the standard
library is presented in Chapter~\ref{chap:std_and_core_runtime}.

\begin{minipage}{\linewidth}
\begin{lstlisting}[caption=\textit{foo.yr.ydump-decls.1}, style=intermediateVerb]
pub foo - use {core, core::array, core::range, core::exception, core::typeinfo, core::duplication, core::math}
  foo::bar - use {core, core::array, core::range, std::io, qux::baz, core::exception, core::typeinfo, core::duplication, core::math}
      pub foo::bar::tryAccessToBaz
  foo::funcInFoo
\end{lstlisting}
\end{minipage}

The path described in a \texttt{use} statement can be more complex, describing a
tree of modules to use. For example, you may want to use the modules
\texttt{std::io}, \texttt{std::fs::path}, and \texttt{std::fs::file}. This can
be done in a single line.

\begin{lstlisting}[style=coloredverbatim]
in foo;

use std::{io, fs::{path, file}};
\end{lstlisting}

\subsubsection{Use statement locality}

As explained above, \texttt{use} statements are enclosed by the symbol that
makes them and by its children. However, in addition to this, use statements are
local to a file, meaning that child modules declared in files other than their
parent module don't have access to the use statements of their parent modules.
This is enforced to avoid cluttering up child modules with use statements they
may not need or even want, and to make use statements clearer since they're
always in the same file as the file they affect. As a result, there is a slight
difference between a child module declared locally in the same file, and a child
module declared in a subdirectory file.
\smallskip

1) When using a single file:

\begin{lstlisting}[caption=\textit{./foo.yr}, style=coloredverbatim]
in foo;
use std::io;

mod bar {
  fn inBar () {
    println("In bar."); // ok, with the use statement from /foo/.
  }
}
\end{lstlisting}

2) When using two separate files:

\begin{minipage}[t][][t]{0.3\linewidth}
\begin{lstlisting}[caption=\textit{./foo.yr}, style=coloredverbatim]
in foo;
use std::io;

mod bar;
\end{lstlisting}
\end{minipage}%
\hfill%
\begin{minipage}[t][][t]{0.65\linewidth}
\begin{lstlisting}[caption=\textit{./foo/bar.yr}, style=coloredverbatim]
in bar;

fn inBar () {
  println("In bar."); // error, parent use statement is hidden
}
\end{lstlisting}
\end{minipage}%
\smallskip


\section{Functions}%
\label{sec:functions}

A function is a piece of code that can be called to perform a defined behavior.
A function is declared using the keyword \texttt{fn} followed by the name of the
function to be described. A function is enclosed in a module like any other
global symbol.

\subsection{Parameters}

The parameters of a function are declared in parentheses after the function
identifier. Parameters serve as the input of the function, allowing to pass data
to the function when calling it. A parameter declaration follows the syntax
\texttt{ident : T}, where \texttt{ident} is the parameter's identifier and
\texttt{T} is its type. Parameters are separated by a comma. The lifetime of the
parameters are limited to the scope of the function body.

\begin{lstlisting}[style=coloredverbatim]
fn foo (a : i32, b : i32) {
  std::io::println (a, " ", b);
}
\end{lstlisting}

The type of the parameter is mandatory, but its identifier can be the token
\texttt{\_} to define the the parameter is not used by the function. If it can
seem useless, it has its purpose for function overriding (for example in class
method override, cf. Chapter~\ref{chap:custom_types}).

\subsubsection {Calling a function}

A function is called using the syntax \texttt{ident (arg1, arg2, ...)}, where
\texttt{ident} is the identifier of the function to call (path to the function
symbol), followed by a list of arguments enclosed in parentheses and separated
by commas. A function argument is a value passed either positionnally or by
keyword as the value to be taken by the parameter of the function when called.
To construct a keyword argument, the parameter identifier is used and associated
with a value using the \texttt{->} token. The following example shows the call
of the function \texttt{foo} using both possibilities.

\begin{lstlisting}[style=coloredverbatim]
foo (1, 2); // positional /a/, then /b/

foo (b-> 2, 1); // keyword for /b/, then position for /a/
foo (b-> 2, a-> 1); // keyword for both parameters
\end{lstlisting}

A keyword argument can be placed anywhere in the argument list. The argument
parameter assignment algorithm starts by removing the keyword arguments from the
equation and locking their assignment, and then iterates over the parameters
that do not yet have an assignment to assign them to the positional arguments.
The result of all the above calls is the same, and produce the following Ymir
Intermediate Language code (for the function \texttt{foo} in the module
\texttt{main}).

\begin{lstlisting}[style=intermediateVerb]
_Y4main3fooFi32i32Zv(1, 2);
_Y4main3fooFi32i32Zv(1, 2);
_Y4main3fooFi32i32Zv(1, 2);
\end{lstlisting}

\textbf{Important note:} the arguments of the function are constructed in the order of
the parameters, and not in the order they appear in the function call. For
example, if the function \texttt{foo} is called as described in the following
source code, the function \texttt{bar} will always be called before the function
\texttt{baz}. If the order of construction of the arguments is defined and
predictible, it is not a good habit to count on it, and the use of intermediate
variables is strongly recommanded to avoid any errors.

\begin{lstlisting}[style=coloredverbatim]
fn bar ()-> i32 {
  println ("In bar");
  12
}

fn baz ()-> i32 {
  println ("In baz");
  15
}

foo (a-> bar (), b-> baz ());
foo (b-> baz (), bar ());
// if the above code perform the same order of operations, it is recommanded to make it clear

let x = bar ();
let y = baz (); // it is more clear that bar is called before baz
foo (a-> x, b-> y);
\end{lstlisting}

The above source code produces the following Ymir Intermediate Language. At this
level, there is no difference between the three calls, but the third one is
preferred for code clarity.

\begin{lstlisting}[style=intermediateVerb]
let YI_1(#1) : i32;
let YI_2(#2) : i32;
let YI_3(#3) : i32;
let YI_4(#4) : i32;
let YI_5(#5) : i32;
let x(#6) : i32;
let YI_7(#7) : i32;
let y(#8) : i32;
YI_1(#1) = _Y4main3barFZi32();
YI_2(#2) = _Y4main3bazFZi32();
_Y4main3fooFi32i32Zv(YI_1(#1), YI_2(#2)); // first call
YI_3(#3) = _Y4main3barFZi32();
YI_4(#4) = _Y4main3bazFZi32();
_Y4main3fooFi32i32Zv(YI_3(#3), YI_4(#4)); // second call
x(#5) = _Y4main3barFZi32();
y(#6) = _Y4main3bazFZi32();
_Y4main3fooFi32i32Zv(x(#5), y(#6)); // third call
\end{lstlisting}

\subsubsection {Uniform call syntax}

The Uniform Call Syntax (\textit{UCS}) allows to call any function with the same
syntax as method calls (see Chapter~\ref{chap:custom_types}). The primary use of
this syntax is to chain calls and provide pipe handling to a value by placing
the first argument (associated with the first parameter) before the function
name and concatenating it with the \texttt{.} token. There is no need to change
the function definition to allow for \textit{UCS}.

\begin{lstlisting}[style=coloredverbatim]
fn add (a : i32, b : i32)-> i32 {
  a + b
}

let a = 12;
let b = a.add (13).add (125); // rewritten into add (add (a, 13), 125)
\end{lstlisting}

\textit{UCS} calls are simply rewritten by placing the left operand of the
binary operation \texttt{.} as the first positional argument of the call. It is
impossible to use a keyword argument as this left operand. The above source code
produces the following Ymir Intermediate Language result.

\begin{lstlisting}[style=intermediateVerb]
let a(#1) : i32;
let YI_2(#2) : i32;
let b(#3) : i32;
a(#1) = 12;
YI_2(#2) = _Y4main3addFi32i32Zi32(a(#1), 13);
b(#3) = _Y4main3addFi32i32Zi32(YI_2(#2), 125);
\end{lstlisting}

\subsubsection {Optional parameters}

A parameter within a function can have a default value, making it optional to
provide an argument when calling the function. This default value is specified
by appending the \texttt{=} token after the parameter type, followed by the
desired value. The optional parameter can be placed anywhere in the parameter
list.

\begin{lstlisting}[style=coloredverbatim]
fn foo (a : i32 = 12, b : i32) {
  std::io::println (a, " ", b);
}
\end{lstlisting}

To call the \texttt{foo} function described in the above code, only one argument
is needed to associate it with the \texttt{b} parameter. The value of the
parameter can be changed using a keyword argument.

\begin{lstlisting}[style=coloredverbatim]
foo (3); // defining parameter /b/

foo (3, a-> 18); // defining parameter /a/ and /b/
foo (a-> 18, 3); // defining parameter /a/ and /b/
\end{lstlisting}

If no other value is associated with an optional parameter, its default value is
constructed at the place of the call. This means that for a complex default
value (for example, a function call), the value is constructed before entering
the function. For example, let's look at the following code where the parameter
\texttt{a} has a default value constructed by calling the function \texttt{bar},
then the function \texttt{bar} is called before the function \texttt{foo} when
calling the function \texttt{foo}. The result is described in the YIL code
below.

\begin{lstlisting}[style=coloredverbatim]
fn bar ()-> i32 {
  println ("In bar.");
  12
}

fn foo (a : i32 = bar ()) {
  println ("In foo : ", a);
}

foo ();
\end{lstlisting}

\begin{lstlisting}[style=intermediateVerb]
let YI_1(#1) : i32;
YI_1(#1) = _Y4main3barFZi32();
_Y4main3fooFi32Zv(YI_1(#1));
\end{lstlisting}

The default value of an optional parameter can refer to a symbol that is
accessible within the context of the function for which it is a parameter, but
because the function has not yet been entered and because it would create
complex parameter order dependencies, this value cannot refer to the other
parameters of the function.

\begin{lstlisting}[style=coloredverbatim]
mod bar {
  pub fn foo (a : i32 = prvInBar ()) {
    println (a);
  }

  fn prvInBar ()-> i32 {
    12
  }
}

bar::foo (); // ok, no need to have access to prvInBar from here because foo has the access

bar::prvInBar (); // error, prvInBar is private within this context
\end{lstlisting}

\subsubsection{Recursive optional parameter}

An optional parameter can be constructed by a function, it can even be
constructed by calling the function in which it is a parameter. However, since
simply calling the function without changing the value of this default parameter
would result in an infinite recursion, in such contexts default values might be
disabled and made mandatory. For example, the following code will cause the
function \texttt{foo} to fail because the parameter \texttt{a} is
self-dependent. For the same reason, the functions \texttt{bar} and \texttt{baz}
are not allowed.

\begin{lstlisting}[style=coloredverbatim]
fn foo (a : i32 = foo ())-> i32 {
  a + 1
}

fn bar (a : i32 = baz ())-> i32 {
  a + 1
}

fn baz (a : i32 = bar ())-> i32 {
  a - 1
}
\end{lstlisting}

To solve this problem, the value of the parameter \texttt{a} can be set inside
the recursive calls. For example, the following code shows a solution for the
functions \texttt{bar} and \texttt{baz}. This fix may seem abrupt, and one could
argue that only one of the two functions needs to stop the infinite recursion.
However, it was decided to force this, as it seems to be a fairly niche problem
that needs to be avoided anyway.

\begin{lstlisting}[style=coloredverbatim]
// setting the option parameter a in baz, to stop the infinite recursion
fn bar (a : i32 = baz (a-> 1))-> i32 {
  a + 1
}

// setting the option parameter a in bar, to stop the infinite recursion
fn baz (a : i32 = bar (a-> 1))-> i32 {
  a - 1
}

bar ();
\end{lstlisting}

The above source code produce the following YIL result.

\begin{lstlisting}[style=intermediateVerb]
let YI_1(#1) : i32;
let YI_2(#2) : i32;
YI_1(#1) = _Y4main3bazFi32Zi32(1);
YI_2(#2) = _Y4main3barFi32Zi32(YI_1(#1));
\end{lstlisting}


\subsubsection {Mutable parameters}

\subsection {Body, expressions and statements}

\subsection {Return value}

\subsection {Exceptions}

\subsection {Effects}

\subsection{The main function}
A program always starts with the function named \texttt{main}



\section{Global variable}%
\label{sec:global_variables}

Global var

\section{Global alias names}
\label{sec:global_alias_names}

\section{Unit tests}%
\label{sec:unit_test}

unit test

\section{External declaration}%
\label{sec:extern_var}

External variable
