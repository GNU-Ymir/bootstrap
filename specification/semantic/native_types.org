

* Integers

Integer types refer to numbers without decimal point. There a two kind of
integers, signed and unsigned ones. The type of signed integers start with the
letter ~i~ where unsigned ones start with the letter ~u~. The size of the type
in bits is written in the type itself, for example ~i32~ is a signed int of 32
bits. The following table presents the list of integer types implemented in the
version 1.0 of ymirc. ~usize~ and ~isize~ are architecture dependant and have a
size in bits that depends on the size of the pointers on the targeted system,
(i.e. 32 bits on 32 bits systems, 64 bits on 64 bits system, and so on)

|------+---------+----------|
| size | signed  | unsigned |
|------+---------+----------|
|    8 | ~i8~    | ~u8~     |
|   16 | ~i16~   | ~u16~    |
|   32 | ~i32~   | ~u32~    |
|   64 | ~i64~   | ~u64~    |
| arch | ~isize~ | ~usize~  |
|------+---------+----------|

** Literals

Integer literals can be written using three forms octal, hexadecimal and decimal.
1. octal, starting with ~0o~ and containing only numbers ranging from ~0~ to ~7~.
   ~0o71217~
2. hexadecimal, starting with ~0x~ and containing numbers ranging from ~0~ to ~9~ and letters ranging from ~a~ to ~f~ in lower or upper case.
   ~0xAB87fe~
3. Decimal , starting with nothing special and containing numbers ranging from ~0~ to ~9~.
   ~182993~

All three forms can also contain the token ~_~ to separate long integer literal
and make them more readable (i.e. ~1_000_000_000~). There can be as many ~_~ as
wanted, there are just removed during the compilation.

Literal have to end with a suffix to define a literal from another int type than
~i32~. For example to define a literal of value ~67~ and of type ~i8~, the
following has to be written ~67i8~ or ~0x43i8~ or ~0o103i8~. A verification is
made during the compilation to ensure that the selected int type has enough
bytes to encode the expected literal.

** Properties

Integer properties are accessed using the operator ~::~ (as for any type) on a type expression. The properties are the following :

|-------+---------------------------------------|
| name  | value                                 |
|-------+---------------------------------------|
| ~max~ | The maximum value the type can encode |
| ~min~ | The minimum value the type can encode |
|-------+---------------------------------------|

Example :
\begin{code}
println (i32::max); // 2_147_483_647
println (i16::min); // -32_768
\end{code}


** Casting

- To other integers :

  It is impossible to change the type of a int value implicitely meaning it is
  impossible to transform a value of type ~i32~ to value of type ~i64~ without
  specifically mention it. The cast operator ~cast!T (V)~ can transform any int
  type to another int type.

  There is one exception to the previous rule. If a literal value is written
  without suffix, it can be transformed into a value of any int type if used
  during a variable affectation or as a function parameter. However it loses this
  privilege as soon as it is involved in an operation.

  For example, the following is allowed :
  \begin{code}
  def foo (a : u64) { // ... }

  let a : i64 = 1;
  foo (7);
  \end{code}

  But not the following :
  \begin{code}
  def foo (a : u64) { // ... }

  let a : i64 = 8 + 1;
  foo (a);
  \end{code}

- To char types :

  The cast operator can be used to transform a int type of type ~u8~ into a
  ~c8~, a ~u32~ to a ~c32~ and a ~u16~ into a ~c16~ and converserly (e.g. ~c8~
  to ~u8~). That is the only allowed casting from int to chars. No implicit
  casting is allowed.

- To float types :

  The casting to floating point types is allowed from ~i64~ to ~f64~ and from
  ~i32~ to ~f32~ and converserly using the cast operator. This is the only
  allowed casting from int to float types. No implicit casting is allowed.

- To boolean types

  The type ~u8~ can be casted using the cast operator to the type ~bool~ and
  converserly, this is the only allowed casting from int to bool. No implicit
  casting is allowed.

** Unary operators
