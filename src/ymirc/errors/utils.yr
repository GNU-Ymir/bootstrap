/**
 * Some utils on error management
 * 
 * */
in utils;


use std::algorithm::sorting;
use ymirc::errors::message;

/**
 * Map the error part of an option value by applying a transformation on it
 * @params:
 *    - x: the value on which to change the error
 *    - map: the map function on the error part
 * @returns: the option but with the error changed
 * */
pub fn errorMap {T} (x : T?, map : dg (&ErrorMsg)-> &ErrorMsg)-> T? {    
    return errorMapT!{T} (x, map)?;
} 

/**
 * Map the error part of an option value by applying a transformation on it
 * And throw the error if it exists, or the unwrapped value if it doesn't
 * @params:
 *    - x: the value on which to change the error
 *    - map: the map function on the error part
 *    - default: the error message to pass to the map, if the error in the option is not of the correct type (or there's no error)
 * @returns: the unwrapped value
 * @throws: the error returned by the map function if the value has no error value
 * 
 * */
pub fn errorMapT {T} (x : T?, map : dg (&ErrorMsg)-> &ErrorMsg, default : &ErrorMsg = DEFAULT_ERROR_MSG)-> T
    throws ErrorMsg
{
    if let Ok (val) = x {        
        return val;
    }

    if let Err (msg : &ErrorMsg) = x {
        throw map (msg);
    }
    
    throw map (default)    
}

/**
 * Flatten a list of errors
 * All ErrorMsg::list in notes will be flattened out, other errors will be left as is
 * @params:
 *    - notes: the list of errors to flatten
 *    - sort: iif true sort the errors by location, else left in the same order
 * @returns: the flattened list of errors
 * */
pub fn flatten (notes : [&ErrorMsg], sort : bool)-> [&ErrorMsg] {
    let mut res : [mut &ErrorMsg] = [];
    let mut already : [usize => mut ()] = copy [];
    for i in notes {
        if (i.isList ()) {
            let d = flatten (i.getNotes (), sort-> true);
            for j in d if j.getId () !in already {
                res ~= [j];
                already [j.getId ()] = ();            
            }
        } else if !i.isEmpty () && i.getId () !in already {            
            res ~= [i];
            already [i.getId ()] = ();              
        }            
    }

    if sort {
        return sorting::sort (alias res, |x, y| => {
            if (x.getLocation ().line < y.getLocation ().line) return true;
            if (x.getLocation ().line == y.getLocation ().line) {
                if x.getEndLocation ().isEof { return false; }
                if y.getEndLocation ().isEof { return true; }
                return x.getEndLocation ().line < y.getEndLocation ().line;
            }
            
            return false;
        });
    } else { return res; }
}
