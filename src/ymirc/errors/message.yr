mod ymirc::errors::message;

import std::io;
import ymirc::lexing::word;
import ymirc::errors::format;
import ymirc::utils::_;

pub enum 
| USED_AS_IDENTIFIER   = "%(y) cannot be used as an identifier"s8
| IN_DECL_BLOCK        = "in block declaration"s8
| UNEXPECTED_BUT_LST   = "read %(y), when expecting %(y)"s8
| UNTERMINATED_BLOCK   = "block is never closed"s8
| IF_NON_TEMPLATE      = "test on a non-template declaration"s8
| UNDEFINED_ATTRIBUTE  = "undefined attribute %(y)"s8
| IMPORT_IN_PROTECTION = "protection has no effect on import statement inside a class declaration"s8
| DESTRUCTOR_IN_PROTECTION = "protection has no effect on destructor declaration"s8
| IMPL_IN_PROTECTION   = "protection has no effect on impl declaration"s8
| MULTIPLE_AUX_CSTRS   = "multiple constructor redirects are not allowed"s8
| IN_TEMPLATE_PARAMS   = "in template parameters"s8
| BLOCK_NEVER_CLOSED   = "missing block closing braces"s8
 -> SyntaxErrorMessage;

    
/**
 * This class store a list of error message
 * This list is used to display readable message for the user
 * @example: 
 * ================
 * let loc = Word::new ("("s8, filename, "(test )!\n"s8, 1u64, 1u64, 0u64, 0u64);
 * let loc3 = Word::new (")!"s8, filename, "(test )!\n"s8, 400000u64, 7u64, 0u64, 0u64);
 * let sub_note = ErrorMsg::note (loc, "Message3"s8, oneLine-> false);
 * let note = ErrorMsg::warn (loc, end-> loc3, "Message"s8, oneLine-> false, notes-> [sub_note]);
 * let dmut notes = Vec!(&ErrorMsg)::new ();
 * notes:.push (note);
 * notes:.push (sub_note);
 * throw ErrorMsg::fatal (loc, end-> loc3, "Message2"s8, notes-> notes[]);    
 * ================
 */
pub class @final ErrorMsg over Exception {

    /// The sub note of the error
    let _notes : [&ErrorMsg];

    /// The location of the error
    let _begin : &Word = Word::eof ();

    /// The end location of the error
    let _end : &Word = Word::eof ();

    /// The message 
    let _msg : [c8] = ""s8;

    /// If true, only prints an error on one line
    let _oneLine = false;

    /// True iif its a note
    let _isNote = false;

    /// True iif its a warning
    let _isWarning = false;

    /**
     * A fatal error, is an error that print the message "Error : " ~ msg
     */
    pub self fatal (loc : &Word, end : &Word = Word::eof (), notes : [&ErrorMsg] = [], oneLine : bool = false, msg : [c8])
        with _msg = msg,
        _notes = notes,
        _begin = loc, _end = end,
        _oneLine = oneLine
    {}

    /**
     * A note error, is an error that print the message "Note : " ~ msg
     */
    pub self note (loc : &Word, end : &Word = Word::eof (), notes : [&ErrorMsg] = [], oneLine : bool = false, msg : [c8])
        with _msg = msg,
        _begin = loc, _end = end,
        _notes = notes,
        _oneLine = oneLine,
        _isNote = true
    {}

    /**
     * A warn error, is an error that print the message "Warning : " ~ msg
     */
    pub self warn (loc : &Word, end : &Word = Word::eof (), notes : [&ErrorMsg] = [], oneLine : bool = false, msg : [c8])
        with _msg = msg,
        _begin = loc, _end = end,
        _notes = notes,
        _oneLine = oneLine,
        _isWarning = true
    {}

    /**
     * Internal constructor to specifiy all fields
     */
    prv self all (loc : &Word, end : &Word, notes : [&ErrorMsg], oneLine : bool, msg : [c8], isNote : bool, isWarning : bool)
        with _msg = msg, _begin = loc, _end = end, _notes = notes, _oneLine = oneLine, _isNote = isNote, _isWarning = isWarning
    {}

    /**
     * An error without message, that is just a list of sub errors
     */
    pub self list (lst : [&ErrorMsg])
        with _notes = lst
    {}


    /**
     * ================================================================================
     * ================================================================================
     * =========================           GETTERS            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * @returns: the list of sub errors 
     */
    pub def getNotes (mut self) -> [&ErrorMsg] {
        self._notes
    }

    /**
     * @returns: the message of the error
     */
    pub def getMessage (self)-> [c8] {
        self._msg 
    }

    /**
     * @returns: the begin location of the error
     */
    pub def getLocation (self) -> &Word {
        self._begin
    }

    /**
     * @returns: the end location of the error
     */
    pub def getEndLocation (self)-> &Word {
        self._end
    }


    /**
     * ================================================================================
     * ================================================================================
     * =========================          SUB NOTES           =========================
     * ================================================================================
     * ================================================================================
     */
    
    /**
     * @returns: a new error message with more notes
     */
    pub def withNote (self, notes : [&ErrorMsg], alone : bool = false)-> &ErrorMsg {
        if !alone {
            ErrorMsg::all (self._begin, self._end, self._notes ~ notes, self._oneLine, self._msg, self._isNote, self._isWarning)
        } else {
            ErrorMsg::all (self._begin, self._end, notes, self._oneLine, self._msg, self._isNote, self._isWarning)
        }
    }

    /**
     * Add a sub note, that will contain the note of self
     * @example: 
     * =========
     * let loc = ...
     * let errB = ErrorMsg::fatal (loc, "B");
     * let errX = ErrorMsg::fatal (loc, "C");
     * let errA = ErrorMsg::fatal (loc, "A", notes-> [errB]);
     * // We have an error A-> [B, C]
     * // We add an intermidiate error D, as a note of A, containing the notes [B, C]
     * let errD = errA.subbingNote (ErrorMsg::fatal (loc, "D"));
     *
     * // Errors are now D = A-> [D-> [B, C]]
     * assert (errD.getMessage () == "A"s8);  
     * assert (errD.getNotes ()[0].getMessage () == "D"s8);
     * assert (errD.getNotes ()[0].getNotes ()[0].getMessage () == "B"s8);
     * assert (errD.getNotes ()[0].getNotes ()[1].getMessage () == "C"s8);
     * =========
     */
    pub def subbingNote (self, note : &ErrorMsg)-> &ErrorMsg {
        ErrorMsg::all (self._begin, self._end, [note.withNote (self._notes, alone-> true)], self._oneLine, self._msg, self._isNote, self._isWarning)
    }

    /**
     * Append a note at the end of the list of notes (always at first index)
     * @example: 
     * ============
     * let loc = ...
     * let errB = ErrorMsg::fatal (loc, "B");
     * let errX = ErrorMsg::fatal (loc, "C");
     * let errA = ErrorMsg::fatal (loc, "A", notes-> [errB]);
     * // We have an error A-> [B, C]
     * // We add an intermidiate error D, as a note of A, containing the notes [B, C]
     * let errD = errA.appendNotes ([ErrorMsg::fatal (loc, "D")]);
     *
     * // Errors are now D = A-> [B-> [D], C]
     * assert (errD.getMessage () == "A"s8);  
     * assert (errD.getNotes ()[0].getMessage () == "B"s8);
     * assert (errD.getNotes ()[1].getMessage () == "C"s8);
     * assert (errD.getNotes ()[0].getNotes ()[0].getMessage () == "D"s8);
     * =========
     */
    pub def appendNotes (self, notes : [&ErrorMsg])-> &ErrorMsg {
        if (self._notes.len == 0u64) {
            ErrorMsg::all (self._begin, self._end, notes, self._oneLine, self._msg, self._isNote, self._isWarning)
        } else {
            {
                let aux = self._notes [0].appendNotes (notes);
                const ErrorMsg::all (self._begin, self._end, [aux] ~ self._notes [1us .. $], self._oneLine, self._msg, self._isNote, self._isWarning)
            } catch {
                _ => { // impossible
                    self
                }
            }
        }           
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================        MISCELLANEOUS         =========================
     * ================================================================================
     * ================================================================================
     */
    
    impl Streamable;    
    impl Formattable {

        /**
         * Pretty print of the error, that can directly written into stderr for averting the user of an error
         */
        pub over format (self, dmut stream : &Formatter) {
            if (self._isNote) stream:.writef ("%(b) : %"s8, "Note"s8, self._msg);
            else if (self._isWarning) stream:.writef ("%(y) : %"s8, "Warning"s8, self._msg);
            else if (self._msg != ""s8) stream:.writef ("%(r) : %"s8, "Error"s8, self._msg);

            if (!self._oneLine) {
                if (self._end.isEof ()) {
                    stream:.formatLocation (self._begin);
                } else {
                    stream:.formatLocation (self._begin, self._end);
                }
            } 

            let max_line =
                if (self._end.isEof ()) { self._begin.line () } else { self._end.line () };

            {
                let leftLine = center (format ("%"s8, max_line), 3u64);
                let padd = center (""s8, leftLine.len);
                let l = format ("%% ┃ %"s8, Colors::BOLD, padd, Colors::RESET);

                stream:.entabing (txt-> l);
            }
                        
            let mut notOneLine = true;
            let mut max_padd = 0u64;
            for i in self._notes {
                stream:.write ('\n'c8);
                i.format (alias stream);                
                notOneLine = !i._oneLine || i._notes.len != 0u64;
                
                max_padd = i._begin.line ();                
                if (i._end.line () > max_padd) {
                    max_padd = i._end.line ();
                }
            }
            
            stream:.detabing ();
            
            if (self._notes.len != 0u64) {                
                let leftLine = center (format ("%"s8, max_line), 3u64);
                let padd = center (""s8, leftLine.len);
                let leftLine2 = center (format ("%"s8, max_padd), 3u64);
                let padd2 = center (""s8, leftLine2.len, "━"s8);
                
                if (notOneLine) {
                    stream:.writef ("\n%% ┗━%━┻━ %", Colors::BOLD, padd, padd2, Colors::RESET);
                } else {
                    stream:.writef ("\n%% ┗━%━━ %", Colors::BOLD, padd, padd2, Colors::RESET);
                }
            } else if (!self._oneLine) {
                let leftLine = center (format ("%"s8, max_line), 3u64);
                let padd = center (""s8, leftLine.len);
                stream:.writef ("\n%% ┗━━━━━━━ %", Colors::BOLD, padd, padd, Colors::RESET);
            }
        }
        
    }
        
}
