in message;

use std::{io, stream, fs::path, conv, env};
use ymirc::lexing::word;
use ymirc::errors::format;
use ymirc::global::state;
use ymirc::utils::_;

extern (C) fn _yrt_exc_resolve_stack_trace (trc : [*void])-> [c8];

pub lazy dmut __GLOB_ERR_ID__ : [usize] = copy [0us];

fn generateUniqErrorId ()-> usize {
    __GLOB_ERR_ID__ [0] += 1us;
    __GLOB_ERR_ID__ [0]
}

/**
 * This class store a list of error message
 * This list is used to display readable message for the user
 * @example: 
 * ================
 * let loc = copy Word ("(", filename, "(test )!\\n", 1u64, 1u64, 0u64, 0u64);
 * let loc3 = copy Word (")!", filename, "(test )!\\n", 400000u64, 7u64, 0u64, 0u64);
 * let sub_note = copy ErrorMsg::note (loc, "Message3", oneLine-> false);
 * let note = copy ErrorMsg::warn (loc, end-> loc3, "Message", oneLine-> false, notes-> copy [sub_note]);
 *
 * throw copy ErrorMsg::fatal (loc, end-> loc3, "Message2", notes-> copy [note, sub_note]);
 * ================
 */
@final
pub class ErrorMsg over Exception {

    // The stack trace of the error
    let mut _movingTrace : [*void] = [];
    
    // The sub note of the error
    let _notes : [&ErrorMsg];

    // The location of the error
    let _begin : &Word = EOF_WORD;

    // The end location of the error
    let _end : &Word = EOF_WORD;

    // The message
    let _msg : [c8] = "";

    // If true, only prints an error on one line
    let _oneLine = false;

    // If true prints the location of the error in the one line format
    let _oneLineWithLoc = false;

    // True iif its a note
    let _isNote = false;

    // True iif its a warning
    let _isWarning = false;

    // True iif this is just a list of errors
    let _isList = false;

    // The id of the error
    let _id : usize;

    // True if print notes even if not verbose
    let _forceVerbose : bool = false;

    // The inverse depth of the error
    let mut _inverseDepth : u32 = 0;

    /**
     * A fatal error, is an error that print the message "Error : " ~ msg
     */
    pub self fatal (loc : &Word, end : &Word = EOF_WORD, notes : [&ErrorMsg] = [], oneLine : bool = false, msg : [c8], forceVerbose : bool = false)
        with _msg = msg
        , _notes = flattening (notes)
        , _begin = { if (loc.isBefore (end)) loc else end }
        , _end = { if (loc.isBefore (end)) end else loc }
        , _oneLine = oneLine
        , _id = generateUniqErrorId ()
        , _forceVerbose = forceVerbose
    {
        self._movingTrace = self.super.trace;
        self:.computeInverseDepth ();
    }

    /**
     * A note error, is an error that print the message "Note : " ~ msg
     */
    pub self note (loc : &Word, end : &Word = EOF_WORD, notes : [&ErrorMsg] = [], oneLine : bool = false, withLoc : bool = false, msg : [c8])
        with _msg = msg
        , _begin = { if (loc.isBefore (end)) loc else end }
        , _end = { if (loc.isBefore (end)) end else loc }
        , _notes = flattening (notes)
        , _oneLine = oneLine
        , _oneLineWithLoc = withLoc
        , _isNote = true
        , _id = generateUniqErrorId ()
    {
        self._movingTrace = self.super.trace;
        self:.computeInverseDepth ();
    }

    /**
     * A warn error, is an error that print the message "Warning : " ~ msg
     */
    pub self warn (loc : &Word, end : &Word = EOF_WORD, notes : [&ErrorMsg] = [], oneLine : bool = false, msg : [c8])
        with _msg = msg
        , _begin = { if (loc.isBefore (end)) loc else end }
        , _end = { if (loc.isBefore (end)) end else loc }
        , _notes = flattening (notes)
        , _oneLine = oneLine
        , _isWarning = true
        , _id = generateUniqErrorId ()
    {
        self._movingTrace = self.super.trace;
        self:.computeInverseDepth ();
    }

    /**
     * Internal constructor to specifiy all fields
     */
    prv self all (loc : &Word, end : &Word, notes : [&ErrorMsg], oneLine : bool, msg : [c8], isNote : bool, isWarning : bool, isList : bool)
        with _msg = msg
        , _begin = { if (loc.isBefore (end)) loc else end }
        , _end = { if (loc.isBefore (end)) end else loc }
        , _notes = flattening (notes)
        , _oneLine = oneLine
        , _isNote = isNote
        , _isWarning = isWarning
        , _isList = isList
        , _id = generateUniqErrorId ()
    {
        self._movingTrace = self.super.trace;
        self:.computeInverseDepth ();
    }

    /**
     * An error without message, that is just a list of sub errors
     */
    pub self list (lst : [&ErrorMsg])
        with _notes = flattening (lst)
        , _isList = true
        , _id = generateUniqErrorId ()
    {
        self._movingTrace = self.super.trace;
        self:.computeInverseDepth ();
    }


    /*!
     * ================================================================================
     * ================================================================================
     * =========================           GETTERS            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * @returns: the list of sub errors 
     */
    pub fn getNotes (self) -> [&ErrorMsg] {
        self._notes
    }

    /**
     * @returns: the message of the error
     */
    pub fn getMessage (self)-> [c8] {
        self._msg 
    }

    /**
     * @returns: the id of the error
     * */
    pub fn getId (self)-> usize {
        self._id
    }

    /**
     * @returns: the begin location of the error
     */
    pub fn getLocation (self) -> &Word {
        self._begin
    }

    /**
     * @returns: the end location of the error
     */
    pub fn getEndLocation (self)-> &Word {
        self._end
    }

    /**
     * @returns: true iif this is just a list of errors
     */
    pub fn isList (self)-> bool {
        self._isList
    }

    pub fn isOneLine (self)-> bool {
        self._oneLine
    }

    pub fn isEmpty (self)-> bool {
        self._oneLine && !self._oneLineWithLoc && self._msg == ""
    }

    /**
     * @returns: all the stack traces of the errors
     */
    pub fn getRecursiveTrace (self)-> [[c8]] {
        let mut traces : mut [[c8]] = [];
        for i in self._notes {
            traces ~= i.getRecursiveTrace ();
            break;
        }

        if (traces.len == 0us) {
            traces ~= [_yrt_exc_resolve_stack_trace (self._movingTrace)];
        }
        
        traces
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================          SUB NOTES           =========================
     * ================================================================================
     * ================================================================================
     */
    
    /**
     * @returns: a new error message with more notes
     */
    pub fn withNote (self, notes : [&ErrorMsg], alone : bool = false)-> &ErrorMsg {
        if !alone {
            let dmut ret = copy ErrorMsg::all (self._begin, self._end, self._notes ~ notes, self._oneLine, self._msg, self._isNote, self._isWarning, self._isList);
            ret._movingTrace = self._movingTrace;
            ret
        } else {
            let dmut ret = copy ErrorMsg::all (self._begin, self._end, notes, self._oneLine, self._msg, self._isNote, self._isWarning, self._isList);
            ret._movingTrace = self._movingTrace;
            ret
        }
    }

    /**
     * Add a sub note, that will contain the note of self
     * @example: 
     * =========
     * let loc = ...
     * let errB = copy ErrorMsg::fatal (loc, "B");
     * let errX = copy ErrorMsg::fatal (loc, "C");
     * let errA = copy ErrorMsg::fatal (loc, "A", notes-> copy [errB]);
     * // We have an error A-> [B, C]
     * // We add an intermidiate error D, as a note of A, containing the notes [B, C]
     * let errD = errA.subbingNote (ErrorMsg::fatal (loc, "D"));
     *
     * // Errors are now D = A-> [D-> [B, C]]
     * assert (errD.getMessage () == "A");
     * assert (errD.getNotes ()[0].getMessage () == "D");
     * assert (errD.getNotes ()[0].getNotes ()[0].getMessage () == "B");
     * assert (errD.getNotes ()[0].getNotes ()[1].getMessage () == "C");
     * =========
     */
    pub fn subbingNote (self, note : &ErrorMsg)-> &ErrorMsg {
        let dmut ret = copy ErrorMsg::all (self._begin, self._end, copy [note.withNote (self._notes, alone-> true)], self._oneLine, self._msg, self._isNote, self._isWarning, self._isList);
        ret._movingTrace = self._movingTrace;
        ret
    }

    /**
     * Append a note at the end of the list of notes (always at first index)
     * @example: 
     * ============
     * let loc = ...
     * let errB = copy ErrorMsg::fatal (loc, "B");
     * let errX = copy ErrorMsg::fatal (loc, "C");
     * let errA = copy ErrorMsg::fatal (loc, "A", notes-> copy [errB]);
     * // We have an error A-> [B, C]
     * // We add an intermidiate error D, as a note of A, containing the notes [B, C]
     * let errD = errA.appendNotes (copy [copy ErrorMsg::fatal (loc, "D")]);
     *
     * // Errors are now D = A-> [B-> [D], C]
     * assert (errD.getMessage () == "A");
     * assert (errD.getNotes ()[0].getMessage () == "B");
     * assert (errD.getNotes ()[1].getMessage () == "C");
     * assert (errD.getNotes ()[0].getNotes ()[0].getMessage () == "D");
     * =========
     */
    pub fn appendNotes (self, notes : [&ErrorMsg])-> &ErrorMsg {
        if (self._notes.len == 0u64) {
            let dmut ret = copy ErrorMsg::all (self._begin, self._end, notes, self._oneLine, self._msg, self._isNote, self._isWarning, self._isList);
            ret._movingTrace = self._movingTrace;
            ret
        } else {            
            let aux = self._notes [0].appendNotes (notes);
            let dmut ret =  copy ErrorMsg::all (self._begin, self._end, copy [aux] ~ self._notes [1us .. $], self._oneLine, self._msg, self._isNote, self._isWarning, self._isList);
            ret._movingTrace = self._movingTrace;
            ret            
        }           
    }


    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =====================================          DEPTH          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */

    fn computeInverseDepth (mut self) {
        self._inverseDepth = 0;
        let add = if self._isList { 0u32 } else { 1u32 };
        for i in self._notes {
            if i._inverseDepth + add > self._inverseDepth {
                self._inverseDepth = i._inverseDepth + add;
            }
        }
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================        MISCELLANEOUS         =========================
     * ================================================================================
     * ================================================================================
     */

    fn formatNotes (self, dmut stream : &Formatter, root : bool = false)-> (bool, u64) {
        let mut notOneLine = true;
        let mut max_padd = 0u64;
        let innerRoot = if (self._isList) { root } else { false };

        let mut j = 0us;
        let verbose = if (self._notes.len > 4us) { root || global::state::instance ().isVerboseActive () || stream.tags.verbose || self._forceVerbose } else { true };
        for  i in self._notes {
            if (!verbose && j == 3us) {
                stream:.write ('\n'c8);
                stream:.writef ("%(b) : other errors in list, user -v or --verbose to show them", "Note");
                stream:.write ('\n'c8, ' 'c8);
                break {}
            }

            let dmut innerStream = copy Formatter::from (alias stream);
            i.format (alias innerStream, root-> innerRoot);
            notOneLine = !i._oneLine || i._notes.len != 0u64;

            max_padd = i._begin.line;
            if (i._end.line > max_padd) {
                max_padd = i._end.line;
            }

            if (innerStream.hasWrittenSomeErrors () && innerStream [].len != 0) {
                if (j != 0us) stream:.write ('\n'c8);
                stream:.write (innerStream[]);
                stream:.wroteErrors (true);
            }

            if (innerStream[].len != 0us) j += 1us;
        }

        (notOneLine, max_padd)
    }


    fn formatText (self, dmut stream : &Formatter, root : bool) {
        root;

        if (stream.tags.withErrorIds) {
            if (self._isNote) stream:.writef ("%(b) (#%(B))", "Note", self._id.to!{[c8], 36us} ());
            else if (self._isWarning) stream:.writef ("%(y) (#%(B))", "Warning", self._id.to!{[c8], 36us} ());
            else if (self._msg != "") stream:.writef ("%(r) (#%(B))", "Error", self._id.to!{[c8], 36us} ());
        } else {
            if (self._isNote) stream:.writef ("%(b)", "Note");
            else if (self._isWarning) stream:.writef ("%(y)", "Warning");
            else if (self._msg != "") stream:.writef ("%(r)", "Error");
        }

        if (!self._oneLine) {
            stream:.writef (" : %", self._msg);
            if (self._end.isEof ()) {
                formatLocation (alias stream, self._begin);
            } else {
                formatLocation (alias stream, self._begin, self._end);
            }
        } else {
            stream:.writef (" : %", self._msg);
            if (self._oneLineWithLoc) {
                formatLocationNoLineReturn (alias stream, self._begin);
            }
        }
    }

    impl Streamable;    
    impl ErrorFormattable {

        /**
         * Pretty print of the error, that can directly written into stderr for averting the user of an error
         */
        pub over format (self, dmut stream : &Formatter, root : bool) {
            if (stream.hasWrittenError (self._id)) {
                if (!root) {
                    if (stream.tags.withErrorIds) {
                        stream:.writef ("%(b) : previous error (#%(B))", "Note", self._id.to!{[c8], 36us} ());
                    } else {
                        stream:.writef ("%(b) : previous error", "Note");
                    }
                }
                return {}
            }

            let verbose = (global::state::instance ().isVerboseActive () || stream.tags.verbose || self._forceVerbose);

            if (self._isList) {
                self.formatNotes (alias stream, root-> root);
                return {}
            }

            else if (!verbose && self._inverseDepth >= 4 && !root) {
                let dmut innerStream = copy Formatter::from (alias stream);
                self.formatNotes (alias innerStream, root-> false);

                if innerStream.hasWrittenSomeErrors () {
                    if self._inverseDepth == 4 {
                        stream:.writef ("%(b) : deep errors, user -v or --verbose to show them", "Note");
                        stream:.write ('\n'c8, ' 'c8);
                    }

                    stream:.write (innerStream[]);
                    stream:.wroteErrors (true);
                }

                return {}
            }

            stream:.registerError (self._id);
            stream:.wroteErrors (true);

            self.formatText (alias stream, root);

            let max_line = if (self._end.isEof ()) { self._begin.line } else { self._end.line };
            let leftLine = center (format ("%", max_line), 3u64);
            let padd = center ("", leftLine.len);
            let l = format ("%% ┃ %", Colors::BOLD, padd, Colors::RESET);

            stream:.entabing (txt-> l);
            let (notOneLine, max_padd) = if (self._notes.len != 0us) {
                let dmut innerStream = copy Formatter::from (alias stream);
                let res = self.formatNotes (alias innerStream, root-> false);

                if (root || innerStream.hasWrittenSomeErrors ()) && innerStream [].len != 0 {
                    stream:.write ("\n");
                    stream:.write (innerStream[]);
                } else if root {
                    stream:.writef ("\n%(b) : previous errors", "Note");
                }

                res
            } else {
                (false, 0u64)
            };
            stream:.detabing ();
            
            if (self._notes.len != 0u64) {
                let leftLine2 = center (format ("%", max_padd), 3u64);
                let padd2 = center ("", leftLine2.len, "━");
                
                if (notOneLine) {
                    stream:.writef ("\n%% ┗━%━┻━ %", Colors::BOLD, padd, padd2, Colors::RESET);
                } else {
                    stream:.writef ("\n%% ┗━%━━ %", Colors::BOLD, padd, padd2, Colors::RESET);
                }
            } else if (!self._oneLine && (!self._begin.isEof () || !self._end.isEof ())) {
                stream:.writef ("\n%% ┗━━━━━━━ %", Colors::BOLD, padd, padd, Colors::RESET);
            }
        }
        
    }


    
}

fn flattening (notes : [&ErrorMsg])-> [&ErrorMsg] {
    let mut res : [&ErrorMsg] = [];
    let mut already : [usize => mut ()] = copy [];
    for i in notes {
        if (i.isList ()) {
            let d = flattening (i.getNotes ());
            for j in d {
                if j.getId () !in already {
                    res ~= [j];
                    already [j.getId ()] = ();
                }
            }
        } else {
            if !i.isEmpty () {
                if i.getId () !in already {
                    res ~= [i];
                    already [i.getId ()] = ();
                }
            }
        }            
    }
    
    res
}
