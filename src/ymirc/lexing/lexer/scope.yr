/*
 * Management of block scoped to manages tokens version ignoring
 *
 * <hr>
 * 
 * @Package: ymirc        
 * @Module: ymirc::lexing::lexer::scope
 * @File: ymirc/lexing/lexer/scope.yr
 * @Author(s):
 *   - Emile Cadorel <ecadorel@gmail.com>
 *
 * @Created (YYYY-MM-DD): 2026-02-10
 * @Copyright (C) 2021â€“2026 GNU-Ymir
 * @License
 *   ```text
 *   This file is part of the Ymir language project.
 *
 *   Ymir is free software: you can redistribute it and/or modify it
 *   under the terms of the GNU General Public License as published by
 *   the Free Software Foundation, either version 3 of the License, or
 *   (at your option) any later version.
 *
 *   Ymir is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with Ymir.  If not, see <https://www.gnu.org/licenses/>.
 *   ```
 */


in scope;

use ymirc::global::state;
use ymirc::utils::list;
use ymirc::lexing::word;

use std::io;

/**
 * A class that manages a version scope
 * */
class SrcScope {

    // the location of the version directive that opened the scope
    pub let open : &Word;

    // The version to open (else can need close, but have EOF version)
    pub let version : &Word;

    // True iif the scope is always ignore (for else conditions)
    pub let isIgnore : bool;
    
    // The list of words in the scope
    pub let mut words : [&Word] = []; 

    // The list of comments in the scope
    pub let mut comms : [[c8]] = [];

    /**
     * @params:
     *    - open: the word that opened the scope and therefore need close (or EOF if root scope)
     *    - version: the version that was openend by the scope or EOF
     * */
    pub self (open : &Word, version : &Word, ignore : bool)
        with open = open
        , version = version
        , isIgnore = ignore
    {}
    
}

/**
 * A record to manage the differents scoped by version filters
 * 
 * */
pub class SrcScopeList {

    // The list of opened scopes
    let dmut _scopes : &List!{dmut &SrcScope} = copy List!{dmut &SrcScope} ();

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =====================================          CTORS          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */
    
    /***/    
    pub self () {
        self:.enter (EOF_WORD, EOF_WORD, false);
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ==================================          ENTER/CLOSE          ===================================
     * ====================================================================================================
     * ====================================================================================================
     */    

    /**
     * Enter a new version scope
     *
     * @params:
     *    - open:    the token that opened the scope (EOF for first scope)
     *    - version: the version that is opened (EOF for first, or fallback elses)
     *    - ignore:  true iif a previous if was accepted therefore the 'else' block has to be ignored
     * */
    pub fn enter (mut self, open: &Word, version: &Word, ignore: bool) {
        self._scopes:.push (copy SrcScope (open, version, ignore));        
    }

    /**
     * Exit the last opened scope (on END directive)
     * Will fold the words to previous scope if the version is active, or the version is EOF
     *
     * @returns: true if the version was folded into parent's scope, or ignored because a previous if was
     * */
    pub fn exit (mut self)-> bool {
        if self._scopes.len <= 1 {
            eprintln ("internal lexer error: exiting top level scope");
            panic;
        }        

        let top = self._scopes.back ();        
        self._scopes:.pop ();
        
        if !top.isIgnore && (top.version.isEof || state::instance ().isVersionActive (top.version.str)) {            
            self._scopes:.back ().words ~= top.words;
            self._scopes:.back ().comms ~= top.comms;
            return true;
        } 

        top.isIgnore
    }
    
    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =====================================          WORDS          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Push a word in the top opened scope
     *
     * @params:
     *    - w:    the word to push
     *    - comm: the comment attached to that word
     *
     * @assume
     *   At least one scope is opened
     *   
     * */
    pub fn push (mut self, w : &Word, comm : [c8]) {
        self._scopes:.back ().words ~= [w];
        self._scopes:.back ().comms ~= [comm];
    }
    
    /**
     * @returns: the last word that was pushed in the list
     * */
    pub fn back (self)-> &Word {        
        if self._scopes.back ().words.len != 0 {
            return self._scopes.back ().words [$ - 1];            
        }

        EOF_WORD
    }

    /**
     * @returns: the list of opened scope in the list
     * */
    pub fn opIndex (self)-> [&SrcScope] {
        self._scopes[]
    }
    
}
