/*
 * Module containing a cursor utils to keep track of tokenizing cursor.
 *
 * <hr>
 * 
 * @Package: ymirc        
 * @Module: ymirc::lexing::cursor
 * @File: ymirc/lexing/cursor.yr
 * @Author(s):
 *   - Emile Cadorel <ecadorel@gmail.com>
 *
 * @Created (YYYY-MM-DD): 2026-02-09
 * @Copyright (C) 2021â€“2026 GNU-Ymir
 * @License
 *   ```text
 *   This file is part of the Ymir language project.
 *
 *   Ymir is free software: you can redistribute it and/or modify it
 *   under the terms of the GNU General Public License as published by
 *   the Free Software Foundation, either version 3 of the License, or
 *   (at your option) any later version.
 *
 *   Ymir is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with Ymir.  If not, see <https://www.gnu.org/licenses/>.
 *   ```
 */

in cursor;

use ymirc::lexing::word;

/**
 * Util cursor to help keep track of line, col and seek positions
 * */
pub record SrcCursor {

    /*! Public fields **/
    pub {
        // The name of the file being travesed
        let filename : [c8];

        // The content of the file being travesed
        let content : [c8];
    }

    /*! Private fields **/
    prv {
        // The current line in the file
        let mut _line : u64;

        // The current column in the file
        let mut _col : u64;

        // The cursor to the char of the line being read
        let mut _lineSeek : usize;

        // The cursor in the file
        let mut _seek : usize = 0us;
    }
    
    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =====================================          CTORS          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */
    
    /**
     * @params:
     *    - filename: the name of the file being travesed
     *    - content:  the content of the file being travesed
     *    - line:     starting the counter at a specific line
     *    - col:      starting the counter at a specific column
     *    - lineSeek: the cursor position of the line being read (if line != 0)
     * */
    pub self (filename : [c8], content : [c8])
        with filename = filename
        , content = content
        , _line = 1
        , _col = 1
        , _lineSeek = 0
    {}

    /**
     * Move the cursor to a new line, increasing seek by 1
     * */
    pub fn newLine (mut self) {
        self._seek += 1;
        self._lineSeek += cast!usize (self._col);
        self._line += 1;
        self._col = 1;                 
    }

    /**
     * Move the cursor foward, increasing seek by `len`
     * */
    pub fn forward (mut self, len : usize) {        
        self._col += cast!u64 (len);
        self._seek += len;
    }        

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          GETTERS          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * @returns: the cursor position
     * */
    @field
    pub fn seek (self)-> usize {
        self._seek
    }

    /**
     * @returns: the current line
     * */
    @field
    pub fn line (self)-> u64 {
        self._line
    }

    /**
     * @returns: the current column
     * */
    @field
    pub fn col (self)-> u64 {
        self._col
    }

    /**
     * @returns: the current line seek
     * */
    @field
    pub fn lineSeek (self)-> usize {
        self._lineSeek
    }    
    
    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =================================          INSTANTIATION          ==================================
     * ====================================================================================================
     * ====================================================================================================
     */
    
    /**
     * Instantiate a new location word at the cursor position
     * @params:
     *    - tok: the content of the word
     * */
    pub fn instantiateLoc (self, tok : [c8])-> &LocWord {
        copy LocWord (str-> tok,
                      filename-> self.filename,
                      fileContent-> self.content,
                      line-> self._line,
                      col-> self._col,
                      seek-> self._seek,
                      lineSeek-> self._lineSeek)
    }

    
    /**
     * Instantiate a new keyword at the cursor position
     * @params:
     *    - tok: the content of the word
     * */
    pub fn instantiateKey (self, tok : [c8])-> &KeyWord {
        copy KeyWord (tok,
                      filename-> self.filename,
                      fileContent-> self.content,
                      line-> self._line,
                      col-> self._col,
                      seek-> self._seek,
                      lineSeek-> self._lineSeek)
    }

    /**
     * Instantiate a new keyword at the cursor position
     * @params:
     *    - tok: the content of the word
     * */
    pub fn instantiateName (self, tok : [c8])-> &NameWord {
        copy NameWord (tok,
                       filename-> self.filename,
                       fileContent-> self.content,
                       line-> self._line,
                       col-> self._col,
                       seek-> self._seek,
                       lineSeek-> self._lineSeek)
    }
    
    /**
     * Instantiate a new token word at the cursor position
     * @params:
     *    - tok: the content of the word
     * */
    pub fn instantiateTok (self, tok : [c8])-> &TokenWord {
        copy TokenWord (tok,
                        filename-> self.filename,
                        fileContent-> self.content,
                        line-> self._line,
                        col-> self._col,
                        seek-> self._seek,
                        lineSeek-> self._lineSeek)
    }

    /**
     * Instantiate a new eof word at the cursor position
     * */
    pub fn instantiateEof (self)-> &EofWord {
        copy EofWord (filename-> self.filename,                      
                      line-> self._line,
                      col-> self._col)
    }

    /**
     * Instantiate a new numeric word at the cursor position
     * @params:
     *    - tok:      the content of the numeric value
     *    - notation: the notation used
     *    - suffix:   the suffix at the end of the numeric value
     * @returns: the numeric word
     * */
    pub fn instantiateNum (self, tok : [c8], notation : NumericNotation, suffix : &Word)-> &NumericWord {
        copy NumericWord (tok,
                          notation-> notation,
                          suffix-> suffix,
                          filename-> self.filename,
                          fileContent-> self.content,
                          line-> self._line,
                          col-> self._col,
                          seek-> self._seek,
                          lineSeek-> self._lineSeek)
    }

    /**
     * Instantiate a new float word at the cursor position
     * @params:
     *    - tok:      the content of the integral part of the word
     *    - dec:      the decimal part
     *    - exp:      the exponant part (for sci and hex floats, EOF for decimal)
     *    - suffix:   the suffix at the end of the float word
     *    - sign:     the sign (of the dec part for sci or hex, EOF for decimal)
     *    - notation: the notation being used
     * @returns: a float word
     * */
    pub fn instantiateFloat (self,
                             tok:       [c8],
                             dot:       &Word,
                             dec:       &Word,
                             exp:       &Word,
                             sign:      &Word,
                             suffix:    &Word,                             
                             notation:  FloatNotation)-> &FloatWord {
                             
        copy FloatWord (str-> tok,
                        dot-> dot,
                        dec-> dec,
                        suffix-> suffix,                        
                        exp-> exp,
                        sign-> sign,
                        notation-> notation,
                        
                        filename-> self.filename,
                        fileContent-> self.content,
                        line-> self._line,
                        col-> self._col,
                        seek-> self._seek,
                        lineSeek-> self._lineSeek)
    }

    
    
    /**
     * Instantiate a string word at the cursor position
     * @params:
     *    - tok:     the content of the word
     *    - open:    the token opening the string
     *    - close:   the token closing the string
     *    - trimmed: the number of left indentation trimmed from the string
     *    - suffix:  the suffix of the string token
     * */
    pub fn instantiateStr (self, tok : [c8], open : &Word, close : &Word, trimmed : usize, suffix : &Word)-> &Word {
        copy StringWord (tok,
                         open,
                         close,
                         trimmed,
                         suffix,
                         filename-> self.filename,
                         fileContent-> self.content,
                         line-> self._line,
                         col-> self._col,
                         seek-> self._seek,
                         lineSeek-> self._lineSeek)
    }
}
