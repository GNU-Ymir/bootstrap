/*
 * @Package: ymirc        
 * @Module: ymirc::lexing::word
 * @File: ymirc/lexing/word.yr
 *
 * @Purpose:
 *   Defines the Word class, representing a lexical unit extracted from a file.
 *   Stores content, file location, and contextual metadata used by the lexer
 *   and downstream compiler stages.
 *
 * @Author(s):
 *   - Emile Cadorel ecadorel@gmail.com
 *
 * @Created (YYYY-MM-DD): 2021-11-12
 *
 * @Copyright (C) 2021–2026 GNU-Ymir
 *
 * ```text
 * This file is part of the Ymir language project.
 *
 * Ymir is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Ymir is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Ymir.  If not, see <https://www.gnu.org/licenses/>.
 * ```
 */

in word;

use std::{stream, io};
use ymirc::utils::colors;

mod ::eof;
mod ::float;
mod ::int;
mod ::key;
mod ::loc;
mod ::name;
mod ::string;
mod ::tok;

/*!
 * ====================================================================================================
 * ====================================================================================================
 * ======================================          LAZY          ======================================
 * ====================================================================================================
 * ====================================================================================================
 */


/**
 * An eof word, as it is used a lot of time in the project, no need to allocate it each time.
 * 
 * @example:
 * ```
 * let a = copy EofWord ();
 * let b = EOF_WORD;
 *
 * assert (a == b);
 *
 * // equality doesn't test location
 * let c = copy EofWord (filename-> "file.yr");
 *
 * assert (c == a);
 * assert (b.isSameLoc (a));
 * assert (!b.isSameLoc (c));
 * ```
 */
pub lazy EOF_WORD : &Word = copy EofWord ();

/*!
 * ====================================================================================================
 * ====================================================================================================
 * ===================================          SUBCLASSES          ===================================
 * ====================================================================================================
 * ====================================================================================================
 */

/*! Classes */
pub def StringWord     : string::StringWord;
pub def EofWord        : eof::EofWord;
pub def TokenWord      : tok::TokenWord;
pub def KeyWord        : key::KeyWord;
pub def NameWord       : name::NameWord;
pub def NumericWord    : int::NumericWord;
pub def FloatWord      : float::FloatWord;
pub def LocWord        : loc::LocWord;

/*! Enums */
pub def NumericNotation : int::NumericNotation;
pub def FloatNotation   : float::FloatNotation;

/*!
 * ====================================================================================================
 * ====================================================================================================
 * =====================================          CLASS          ======================================
 * ====================================================================================================
 * ====================================================================================================
 */

/**
 * A Word models a lexical unit extracted from a source file.
 *
 * It stores both the textual content of the token and its full source location:
 * filename, line, column, absolute seek position, and the seek of the beginning
 * of the line. This information is used throughout the lexing and parsing stages
 * to provide accurate diagnostics, error reporting, and source mapping.
 *
 * Words may represent identifiers, keywords, symbols, or any other atomic
 * fragment of the input stream. Special instances such as EOF_WORD are used to
 * signal end‑of‑file conditions.
 */
@abstract
pub class Word {

    /*! Public fields */
    pub {
        // The content of the word
        let str: [c8] = "";

        // The name of the file in which the string was read
        let filename: [c8];

        // The line location in the file
        let line: u64 = 0;

        // The colon location in the file
        let col: u64 = 0;

        // The seek location (cursor location in the file)
        let seek: usize = 0;

        // The content of the in which the word was found (only a borrow reference)
        let fileContent: [c8] = "";

        // The seek of the line in wich the word can be found (lineSeek = seek - col)
        let lineSeek: usize = 0;
    }
    
    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =====================================          CTORS          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */
    
    /**
     * Create a word from a file 
     * @params: 
     *   - str:      the content of the word
     *   - filename: the name of the file that contains the word
     *   - line:     the location line of the word
     *   - col:      the location column of the word
     *   - seek:     the location cursor of the word (number of c8 preceding it)
     *   - lineSeek: the location cursor of the beginning of the line containing the word
     */
    pub self (str:         [c8],
              filename:    [c8],
              fileContent: [c8],
              line:        u64,
              col:         u64,
              seek:        usize,
              lineSeek:    usize)
        
        with str = str
        , filename = filename
        , fileContent = fileContent
        , line = line
        , col = col
        , seek = seek
        , lineSeek = lineSeek
    {}

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          CLONING          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Clone the word to create a location word with a different content and
     * different location (keeping filename and filecontent)
     * 
     * @params:
     *    - str: the content to put in the word
     *    - line: the line to set
     *    - col: the column of the new word
     *    - lineSeek: the seek of the line of the new word
     * */
    pub fn locate (self, str: [c8], line: u64, col: u64, lineSeek: usize)-> &LocWord {
        copy LocWord (str-> str,
                      self.filename,
                      fileContent-> self.fileContent,
                      line,
                      col,
                      seek-> lineSeek + cast!usize (col),
                      lineSeek-> lineSeek)
    }

    /**
     * Clone the word to create a location word with a different content and
     * increasing location line columns (keeping filename and filecontent)
     * 
     * @params:
     *    - str: the content to put in the word
     *    - line: the line to set
     *    - col: the column of the new word
     *    - lineSeek: the seek of the line of the new word
     *
     * @warning
     *    the line seek becomes invalid if addLine != 0
     * */
    pub fn locate (self, str: [c8], addLine: u64, addCol: u64)-> &LocWord {
        copy LocWord (str-> str,
                      self.filename,
                      fileContent-> self.fileContent,
                      self.line + addLine,
                      self.col + addCol,
                      seek-> self.seek + cast!usize (addCol),
                      lineSeek-> if addLine == 0 { self.lineSeek } else { 0 })
    }

    /**
     * Clone the word to create a location word with the same content but another filename
     * 
     * @params:
     *    - str: the content to put in the word
     *    - line: the line to set
     *    - col: the column of the new word
     *    - lineSeek: the seek of the line of the new word
     *
     * @warning
     *    The file content is not fetched, therefore set to the same as
     *    self lineSeek and seek are also left as is for the same reason.
     *
     * @info
     *    The purpose of this function is more to change the filename to a
     *    relative name, but pointing to the same one
     *    
     * */
    pub fn locate (self, filename : [c8])-> &LocWord {
        copy LocWord (str-> self.str,
                      filename,
                      fileContent-> self.fileContent,
                      self.line,
                      self.col,
                      seek-> self.seek,
                      lineSeek-> self.lineSeek)
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          GETTERS          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */
    
    /**
     * @returns: the length of the content of the word
     */
    @field
    pub fn len (self) -> usize {
        self.str.len 
    }

    /**
     * @returns: true iif self is an EofWord
     * */
    @{final, field}    
    pub fn isEof (self)-> bool {
        self of EofWord
    }
    
    /**
     * @returns: true iif self is an FloatWord
     * */    
    @{final, field}
    pub fn isFloat (self)-> bool {
        self of FloatWord
    }

    /**
     * @returns: true iif self is an NumericWord
     * */    
    @{final, field}
    pub fn isNumeric (self)-> bool {
        self of NumericWord
    }

    /**
     * @returns: true iif self is an KeyWord
     * */    
    @{final, field}
    pub fn isKey (self)-> bool {
        self of KeyWord
    }

    /**
     * @returns: true iif self is an LocWord
     * */    
    @{final, field}
    pub fn isLoc (self)-> bool {
        self of LocWord
    }

    /**
     * @returns: true iif self is an NameWord
     * */    
    @{final, field}
    pub fn isName (self)-> bool {
        self of NameWord
    }

    /**
     * @returns: true iif self is an StringWord
     * */    
    @{final, field}
    pub fn isString (self)-> bool {
        self of StringWord
    }

    /**
     * @returns: true iif self is an TokenWord
     * */
    @{final, field}
    pub fn isToken (self)-> bool {
        self of TokenWord
    }    
    
    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          COMPARISON          ===================================
     * ====================================================================================================
     * ====================================================================================================
     */
    
    /**
     * @returns: true iif self.str == `str`
     */
    pub fn opEquals (self, str : [c8])-> bool {
        self.str == str
    }    

    /**
     * @returns: true iif the content of self is the same as the content of o
     *           and word are of the same type
     *   
     * @warning
     *   Does not test location. cf. isSameLoc
     */
    pub fn opEquals (self, o: &Word)-> bool;
    
    /**
     * @returns: true iif the two words are at the same location
     * 
     * @warning
     *   Does not check content, cf. opEquals.
     *   Same location and same content must use both tests.
     */
    @final
    pub fn isSameLoc (self, o: &Word)-> bool {                
        self.filename == o.filename &&
            self.line == o.line &&
            self.col == o.col &&
            self.seek == o.seek &&
            self.lineSeek == o.lineSeek            
    }

    /**
     * @returns: true iif the location of self is before o
     * 
     * @info
     *   - if o is eof, always return true
     *   - if they are from different file always return false
     *   - if they are equal, returns true
     *   
     * */
    @final
    pub fn isBefore (self, o: &Word)-> bool {
        if (o of EofWord)
            return true;
        
        if (self.filename != o.filename) return false;

        if (self.line == o.line) {
            self.col <= o.col
        } else {
            self.line <= o.line
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =================================          MISCELLANEOUS          ==================================
     * ====================================================================================================
     * ====================================================================================================
     */
    
    impl Hashable;        
    impl Streamable;
    
}
