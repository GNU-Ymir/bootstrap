/*
 * @Package: ymirc        
 * @Module: ymirc::lexing::word::string
 * @File: ymirc/lexing/word/string.yr
 *
 * @Purpose:
 *   Defines the StringWord class, representing a lexical string extracted from a file.
 *   
 *
 * @Author(s):
 *   - Emile Cadorel ecadorel@gmail.com
 *
 * @Created (YYYY-MM-DD): 2026-02-08
 *
 * @Copyright (C) 2021â€“2026 GNU-Ymir
 *
 * ```text
 * This file is part of the Ymir language project.
 *
 * Ymir is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Ymir is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Ymir.  If not, see <https://www.gnu.org/licenses/>.
 * ```
 */

in string;

use std::{stream, io};
use ymirc::utils::colors;


/**
 * A StringWord models a lexical string extracted form a source file
 *
 * It stores in addition to parent Word class fields, the location of the
 * opening token and closing token. As well as the suffix that was written at
 * the end of the string literal if any (not applicable to all kind of string
 * words).
 * 
 * */
@final
pub class StringWord over Word {

    /*! Public fields */
    pub {

        // The word that opened the string
        let open : &Word;

        // The word that closed the string
        let close : &Word;

        // The left padding that was removed from the string
        let trim : usize;

        // The suffix at the end of the string
        let suffix : &Word;        
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =====================================          CTORS          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Create a word containing a string word. a word than may contain sub
     * tokens, but was cutted by the lexer as a string.
     *    
     * @params:
     *  - str:       the content of the word
     *  - open:      the token opening the string
     *  - close:     the token closing the string
     *  - trim:      the number of trimmed column (for line, col reconstruction)
     *  - suffix:    the suffix of the string
     *  - filename:  the name of the file that contains the word
     *  - line:      the location line of the word
     *  - col:       the location column of the word (not trimmed)
     *  - seek:      the location cursor of the word (number of c8 preceding it)
     *  - lineSeek:  the location cursor of the beginning of the line containing the word     
     * */
    pub self (str:         [c8],
              open:        &Word,
              close:       &Word,
              trim:        usize,
              suffix:      &Word,
              filename:    [c8],
              fileContent: [c8],
              line:        u64,
              col:         u64,
              seek:        usize,
              lineSeek:    usize)
        
        with super (str, filename, fileContent, line, col, seek, lineSeek) 
        , open = open
        , close = close
        , trim = trim
        , suffix = suffix
    {}
    
    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          COMPARISON          ===================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * @returns: false
     *
     * @info
     *    String token are not comparable to string values, use .str to compare content
     * */
    pub over opEquals (self, _ : [c8])-> bool {
        false
    }

    /**
     * Compare two words
     *
     * @info
     *   To be equal a string word must contain the same content, and open
     *   and close must be equal. `.trim` is not important
     *
     * */
    pub over opEquals (self, o: &Word)-> bool {        
        if let s : &StringWord = o {
            if self.str != s.str return false;
            if self.open != s.open return false;
            if self.close != s.close return false;
            if self.suffix != s.suffix return false;

            return true;
        }

        return false;
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =================================          MISCELLANEOUS          ==================================
     * ====================================================================================================
     * ====================================================================================================
     */
    
    impl Hashable;        
    impl Streamable {
        pub over toStream (self, dmut stream: &StringStream)-> void {                        
            stream:.write (Colors::WHITE_BACK, Colors::GREEN)                                
                :.write (self.str)
                :.write (Colors::RESET, Colors::BOLD)
                :.write (" --> ")
                :.write (self.filename)
                :.write (":(")
                :.write (self.line)
                :.write (",")
                :.write (self.col)                
                :.write (")")
                :.write (Colors::RESET);                                            
        }
    }
    
}
