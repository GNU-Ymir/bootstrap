/*
 * Defines the NumericWord class, representing a word containing a numeric
 * value.
 *
 * <hr>
 * 
 * @Package: ymirc        
 * @Module: ymirc::lexing::word::int
 * @File: ymirc/lexing/word/int.yr
 * @Author(s):
 *   - Emile Cadorel <ecadorel@gmail.com>
 *
 * @Created (YYYY-MM-DD): 2026-02-09
 * @Copyright (C) 2021â€“2026 GNU-Ymir
 * @License
 *   ```text
 *   This file is part of the Ymir language project.
 *
 *   Ymir is free software: you can redistribute it and/or modify it
 *   under the terms of the GNU General Public License as published by
 *   the Free Software Foundation, either version 3 of the License, or
 *   (at your option) any later version.
 *
 *   Ymir is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with Ymir.  If not, see <https://www.gnu.org/licenses/>.
 *   ```
 */

in int;

use std::{stream, io};
use ymirc::utils::colors;

pub enum
| DEC = 1
| BIN = 2
| OCT = 3
| HEX = 4
 -> NumericNotation; 


/**
 * A NumericWord models a lexical numeric value extracted from a file.
 *
 * It contains information about the used notation, and suffix at the end of the
 * token.
 * 
 * */
@final
pub class NumericWord over Word {

    /*! Public fields */
    pub {
        // The encoding used
        let notation : NumericNotation;

        // The suffix at the end of the numeric word
        let suffix : &Word;
    }
    
    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =====================================          CTORS          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Create a word from a file containing a token
     * @params: 
     *   - str:      the content of the word
     *   - filename: the name of the file that contains the word
     *   - notation: the kind of notation used to encode the numeric constant
     *   - suffix:   the suffix placed at the end of the constant
     *   - line:     the location line of the word
     *   - col:      the location column of the word
     *   - seek:     the location cursor of the word (number of c8 preceding it)
     *   - lineSeek: the location cursor of the beginning of the line containing the word     
     * */
    pub self (str:         [c8],
              suffix:      &Word,
              notation:    NumericNotation,
              filename:    [c8],
              fileContent: [c8],
              line:        u64,
              col:         u64,
              seek:        usize,
              lineSeek:    usize)
        with super (str, filename, fileContent, line, col, seek, lineSeek)
        , suffix = suffix
        , notation = notation
    {}
    
    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          COMPARISON          ===================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * @returns: false
     *
     * @info
     *    Int token are not comparable to string values, since they are composed of multiple words
     * */
    pub over opEquals (self, _ : [c8])-> bool {
        false
    }
    
    /**         
     * @returns: true iif `o` is a numeric word and contain the same content,
     *           notation and suffix
     * */
    pub over opEquals (self, o : &Word)-> bool {        
        if let n: &NumericWord = o {    
            if self.str != n.str return false;
            if self.notation != n.notation return false;
            if self.suffix != n.suffix return false;
        }

        return false;
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =================================          MISCELLANEOUS          ==================================
     * ====================================================================================================
     * ====================================================================================================
     */
    
    impl Hashable;        
    impl Streamable {
        pub over toStream (self, dmut stream: &StringStream)-> void {
            stream:.write (Colors::PURPLE)                
                :.write (self.str)
                :.write (Colors::RESET, Colors::BOLD)
                :.write (" --> ")
                :.write (self.filename)
                :.write (":(")
                :.write (self.line)
                :.write (",")
                :.write (self.col)
                :.write (",");

            
            match self.notation {                
                NumericNotation::DEC => {
                    stream:.write ("DEC");
                }
                NumericNotation::BIN => {
                    stream:.write ("BIN");
                }
                NumericNotation::OCT => {
                    stream:.write ("OCT");
                }
                _ => {
                    stream:.write ("HEX");
                } 
            }                

            if !self.suffix.isEof {
                stream:.write (", suf="):.write (self.suffix.str);
            }

            stream:.write (")"):.write (Colors::RESET);                                            
        }
    }
    
}
