/*
 * Internal utils for the Tokenizer record.
 *
 * <hr>
 * 
 * @Package: ymirc        
 * @Module: ymirc::lexing::tokenizer::node
 * @File: ymirc/lexing/tokenizer/node.yr
 * @Author(s):
 *   - Emile Cadorel <ecadorel@gmail.com>
 *
 * @Created (YYYY-MM-DD): 2026-02-09
 * @Copyright (C) 2021â€“2026 GNU-Ymir
 * @License
 *   ```text
 *   This file is part of the Ymir language project.
 *
 *   Ymir is free software: you can redistribute it and/or modify it
 *   under the terms of the GNU General Public License as published by
 *   the Free Software Foundation, either version 3 of the License, or
 *   (at your option) any later version.
 *
 *   Ymir is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with Ymir.  If not, see <https://www.gnu.org/licenses/>.
 *   ```
 */

in node;

use std::traits;

/**
 * A node of a tokenizer, that stores information about tokens
 */
@final
pub class Node {

    // The current value of the node
    pub let key : c8;

    // True iif this node is the end of a token
    let mut _isToken : bool;

    // True iif this is a skip token
    let mut _isSkip : bool;

    // The closing of the comment if this is a comment
    let mut _isComment : bool;

    // The closing of the string if this is a string
    let mut _isString : bool;

    // The list of continuation of the token
    let dmut _next : [&Node] = [];

    /**
     * @params:
     *    - key: the value of the node
     *    - isToken: true iif this node is located at the end of a token
     *    - isSkip: true iif this node is located at the end of a skip token
     *    - isComment: the closing string iif this is is a closing token
     * */
    pub self (key : c8)
        with key = key
        , _isToken = false
        , _isSkip = false
        , _isComment = false
        , _isString = false
    {}

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          INSERTION          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Insert sub tokens accepted tokens
     * @params:
     *     - str: the rest to read to create a valid token     
     * */
    pub fn insert (mut self, str : [c8], isSkip : bool, isComment : bool, isString : bool) {
        if str.len == 0 {
            self._isToken = true;
            self._isSkip = isSkip;
            self._isComment = isComment;
            self._isString = isString;
            return;
        }

        for i in 0 .. self._next.len {
            if (self._next [i].key == str [0]) {
                self._next [i]:.insert (str [1 .. $], isSkip, isComment, isString);
                return;
            }
        }

        let dmut n = copy Node (str [0]);
        n:.insert (str [1 .. $], isSkip, isComment, isString);

        self._next ~= [alias n];
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ======================================          FIND          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Read the start of the string for an eventual token
     * 
     * @returns:
     *    - .0: the length of the token at the beginning of the string content
     *    - .1: true iif this is a skip token
     *    - .2: true iif this is a comment opening token
     *    - .3: true iif this is a string opening token
     */
    pub fn len (self, content : [c8])-> (usize, bool, bool, bool) {
        if content.len == 0 {
            if self._isToken {
                return (1us, self._isSkip, self._isComment, self._isString);
            } else return (0us, false, false, false);
        }

        for i in 0 .. self._next.len {
            if self._next [i].key == content [0] {
                let (subLen, isSkip, isComment, isString) = self._next [i].len (content [1 .. $]);
                if subLen != 0 {
                    return (subLen + 1, isSkip, isComment, isString);
                }
            }
        }

        if self._isToken {
            return (1, self._isSkip, self._isComment, self._isString);
        }

        return (0, false, false, false);
    } 

}
