in expression;

pub mod ::assert_;
pub mod ::atomic_;
pub mod ::block;
pub mod ::break_;
pub mod ::cast_;
pub mod ::conditional;
pub mod ::decoexpr;
pub mod ::empty;
pub mod ::for_;
pub mod ::funcptr;
pub mod ::future_;
pub mod ::intrinsic;
pub mod ::lambda;
pub mod ::list;
pub mod ::listmap;
pub mod ::listmtch;
pub mod ::matcher;
pub mod ::namedexpr;
pub mod ::optionmtch;
pub mod ::panic_;
pub mod ::patterndecl;
pub mod ::pragma;
pub mod ::return_;
pub mod ::scopeguard;
pub mod ::set;
pub mod ::slice;
pub mod ::slicefor;
pub mod ::throw_;
pub mod ::try;
pub mod ::unsafe_;
pub mod ::vardecl;
pub mod ::while_;
pub mod ::literal;
pub mod ::macro_;
pub mod ::operator;
pub mod ::template;

use ymirc::lexing::word;
use ymirc::syntax::node;
use ymirc::utils::format;
use std::{io, stream};

/**
 * Ancestor class of all expressions
 */
@abstract
pub class Expression over SyntaxNode {

    /**
     * @params:
     *   - loc: the location of the expression
     */
    pub self (loc : &Word) with super (loc)
    {}

    /**
     * @returns: true iif self and other are strictly identical
     */
    pub fn opEquals (self, o : &Expression)-> bool;

    impl Streamable;
}
