mod ymirc::syntax::expression::list;

import ymirc::syntax::declaration::_;
import ymirc::syntax::expression::_;

import ymirc::syntax::_;
import ymirc::lexing::word;
import ymirc::lexing::tokens;
import ymirc::utils::format;

import std::io;


/**
 * A list is a list of expression, surrounded by tokens, such as () or []
 * They are used for array and tuple literals, and are not equals to Sets
 * @verbatim:
 * ===============
 * list_lit :=   Tokens::LPAR argument*(Tokens::COMA) Tokens::RPAR
 *             | Tokens::LCRO argument*(Tokens::COMA) Tokens::RCRO
 * ===============
 */
pub class @final List over Expression {

    /// The location of the end of the expression
    let _end : &Word;

    /// The list of parameters
    let _params : [&Expression];

    /**
     * @params: 
     *    - loc: the location (and type, depending on the token contained in the word), of the expression
     *    - end: the location of the closing token of the expression
     *    - params: the list of parameters inside the literal
     */
    pub self (loc : &Word, end : &Word, params : [&Expression])
        with super (loc), _end = end, _params = params
    {}

    /**
     * ================================================================================
     * ================================================================================
     * =========================           GETTERS            =========================
     * ================================================================================
     * ================================================================================
     */
    
    /**
     * @returns: the closing location of the expression
     */
    pub def getEndLocation (self)-> &Word {
        self._end
    }

    /**
     * @returns: the list of parameters inside the expression
     */
    pub def getParameters (self)-> [&Expression] {
        self._params
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================        MISCELLANEOUS         =========================
     * ================================================================================
     * ================================================================================
     */
    
    impl Streamable;
    impl Formattable {

        /**
         * Pretty formatting of the expression inside the stream
         */
        pub over format (self, dmut stream : &Formatter) {
            stream:.write (self._loc.str ());
            stream:.entabing ();
            let mut j = 0u64;
            for i in self._params {
                if (j != 0u64) stream:.write (", "s8);
                i.format (alias stream);
                j += 1u64;
            }
            stream:.detabing ();
            stream:.write (self._end.str ());
        }
    }
    
}
