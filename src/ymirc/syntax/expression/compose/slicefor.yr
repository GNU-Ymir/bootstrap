/*
 * Declares the SliceForAllocatorExpr class.
 *
 * <hr>
 * 
 * @Package: ymirc        
 * @Module: ymirc::syntax::expression::compose::slicefor
 * @File: ymirc/syntax/expression/compose/slicefor.yr
 * @Author(s):
 *   - Emile Cadorel <ecadorel@gmail.com>
 *
 * @Created (YYYY-MM-DD): 2026-02-12
 * @Copyright (C) 2021â€“2026 GNU-Ymir
 * @License
 *   ```text
 *   This file is part of the Ymir language project.
 *
 *   Ymir is free software: you can redistribute it and/or modify it
 *   under the terms of the GNU General Public License as published by
 *   the Free Software Foundation, either version 3 of the License, or
 *   (at your option) any later version.
 *
 *   Ymir is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with Ymir.  If not, see <https://www.gnu.org/licenses/>.
 *   ```
 */
    
in slicefor;

use std::stream;

use ymirc::lexing::{word, tokens, keys};
use ymirc::utils::format;

/**
 * Syntaxic representation of a slice or tuple allocation using a list comprehension
 *
 */
@final
pub class SliceForAllocatorExpr over ComposeExpr {

    pub {
        // The location of the 'for' keyword
        let forLoc: &Word;

        // The left value
        let value: &Expression;

        // The iteration variables
        let decls: [&Expression];

        // The iterated value
        let iter: &Expression;

        // True if the slice for creates an array (or slice)
        // false means we try to create a tuple
        let isArray: bool;
    }
    
    /**
     * @params:
     *    - loc: the location of the allocator
     *    - value: the value to construct at each index
     *    - decls: the variables used to iterate
     *    - iter: the value being iterated
     *    - isArray: true if we try to create an array, false means a tuple
     */
    pub self (loc: &Word, forLoc: &Word, value: &Expression, decls: [&Expression], iter: &Expression, isArray: bool)
        with super (loc)
        , forLoc = forLoc
        , value = value
        , decls = decls
        , iter = iter
        , isArray = isArray
    {}

    /**
     * @returns: true if a tuple is created
     * */
    @field
    pub fn isTuple (self)-> bool {
        !self.isArray
    }
    

    impl Streamable;
    impl Formattable {
        pub over format (self, dmut stream: &Formatter) {
            if self.isArray 
                stream:.write (Tokens::LCRO, ' ');
            else
                stream:.write (Tokens::LPAR, ' ');
        
            stream:.entabing ();
            self.value.format (alias stream);

            stream:.write (' ', Keys::FOR, ' ');
            for i, elem in self.decls {
                if (i != 0us) stream:.write (", ");
                elem.format (alias stream);
            }
            stream:.write (' ', Keys::IN, ' ');
            self.iter.format (alias stream);
            stream:.detabing ();
            
            if self.isArray
                stream:.write (Tokens::RCRO);
            else
                stream:.write (Tokens::RPAR);            
        }
    }

}
