mod ymirc::syntax::expression::block;

import ymirc::syntax::declaration::_;
import ymirc::syntax::expression::_;

import ymirc::syntax::_;
import ymirc::lexing::word;
import ymirc::lexing::tokens;
import ymirc::utils::format;

import std::io;

/**
 * Syntaxic representation of a block expression
 * @verbatim: 
 * ===============
 * block_expr := '{' (expression ';')* (expression)? '}' (catcher_block)? (scope_guards)*
 * ===============
 */
pub class @final Block over Expression {

    /// The location of the end of the block
    let _end : &Word;

    /// The list of declaration inside the block
    let _declModule : &Declaration;

    /// THe content of the block
    let _content : [&Expression];

    /// The catcher of the block
    let _catcher : &Expression;
    
    /// The list of scope guards
    let _scopes : [&ScopeGuard];

    /**
     * @params: 
     *    - loc: the location of the block
     *    - end: the location of the end of the block ('}')
     *    - module: the list of declaration made inside the block (imports, function, ...)
     *    - content: the list of expression contained in the block
     *    - guards: the list of scope guards of the block
     */
    pub self (loc : &Word, end : &Word, module : &Declaration = DeclBlock::empty (), content : [&Expression], catcher : &Expression = EmptyExpression::new (), guards : [&ScopeGuard] = [])
        with super (loc), _end = end, _declModule = module, _content = content, _scopes = guards, _catcher = catcher
    {}

    /**
     * ================================================================================
     * ================================================================================
     * =========================           GETTERS            =========================
     * ================================================================================
     * ================================================================================
     */
    
    /**
     * @returns: the location of the end of the block
     */
    pub def getEndLocation (self)-> &Word {
        self._end
    }

    /**
     * @returns: the internal module of the block containing declarations
     */
    pub def getModule (self)-> &Declaration {
        self._declModule
    }

    /**
     * @returns: the list of expression contained in the block
     */
    pub def getExpressions (self)-> [&Expression] {
        self._content
    }

    /**
     * @returns: the list of scope guards of the block
     */
    pub def getGuards (self)-> [&ScopeGuard] {
        self._scopes
    }

    /**
     * @returns: the catcher of the block
     */
    pub def getCatcher (self)-> &Expression {
        self._catcher
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================        MISCELLANEOUS         =========================
     * ================================================================================
     * ================================================================================
     */

    impl Streamable;
    impl Formattable {

        /**
         * Pretty formatting of the block inside the stream
         */
        pub over format (self, dmut stream : &Formatter) {
            stream:.write ("{\n"s8);
            stream:.entabing ();

            match  self._declModule {
                x : &DeclBlock => {
                    if (x.getDeclarations ().len != 0u64) {
                        x.format (alias stream);
                    }
                }
                _ => {
                    self._declModule.format (alias stream);
                }
            }

            let mut j = 0us;
            for i in self._content {
                if (j != 0us)
                    stream:.write (Tokens::SEMI_COLON, "\n");
                i.format (alias stream);
                j += 1us;
            }
            if (self._content.len != 0us) {
                stream:.write ('\n'c8);
            }
            stream:.detabing ();
            stream:.write ("}\n"s8);
            
            match self._catcher {
                EmptyExpression () => {}
                _ => {
                    stream:.write (" ", Keys::CATCH, " ");
                    self._catcher.format (alias stream);
                }
            }
            
            for i in self._scopes {
                i.format (alias stream);
            }
        }        
    }
    
}
