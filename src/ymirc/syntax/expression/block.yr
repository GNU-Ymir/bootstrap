/*
 * Declares the BlockExpr class, containing a list of inner expressions and
 * declarations.
 *
 * <hr>
 * 
 * @Package: ymirc        
 * @Module: ymirc::syntax::expression::block
 * @File: ymirc/syntax/expression/block.yr
 * @Author(s):
 *   - Emile Cadorel <ecadorel@gmail.com>
 *
 * @Created (YYYY-MM-DD): 2021-11-20
 * @Copyright (C) 2021â€“2026 GNU-Ymir
 * @License
 *   ```text
 *   This file is part of the Ymir language project.
 *
 *   Ymir is free software: you can redistribute it and/or modify it
 *   under the terms of the GNU General Public License as published by
 *   the Free Software Foundation, either version 3 of the License, or
 *   (at your option) any later version.
 *
 *   Ymir is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with Ymir.  If not, see <https://www.gnu.org/licenses/>.
 *   ```
 */

in block;

use ymirc::syntax::declaration::block;
use ymirc::syntax::expression::{empty, block::scopeguard};

use ymirc::lexing::keys;
use ymirc::lexing::{word, tokens};
use ymirc::utils::format;

use std::stream;

/*!
 * ====================================================================================================
 * ====================================================================================================
 * ====================================          SUBMODS          =====================================
 * ====================================================================================================
 * ====================================================================================================
 */

mod ::scopeguard;
mod ::set;


/*!
 * ====================================================================================================
 * ====================================================================================================
 * =====================================          TYPES          ======================================
 * ====================================================================================================
 * ====================================================================================================
 */

pub def ScopeGuardExpr: scopeguard::ScopeGuardExpr;
pub def SetExpr: set::SetExpr;

/**
 * Syntaxic representation of a block expression.
 * 
 */
@final
pub class BlockExpr over Expression {

    /*! Public fields */
    pub {
        // The location of the end of the block
        let end: &Word;

        // The list of declaration inside the block
        let declModule: &Declaration;

        // THe content of the block
        let content: [&Expression];

        // The catcher of the block
        let catcher: &Expression;
        
        // The list of scope guards
        let scopes: [&ScopeGuardExpr];
    }
    
    /**
     * @params: 
     *    - loc:     the location of the block
     *    - end:     the location of the end of the block ('}')
     *    - module:  the list of declaration made inside the block (imports, function, ...)
     *    - content: the list of expression contained in the block
     *    - guards:  the list of scope guards of the block
     */
    pub self (loc: &Word,
              end: &Word,
              module: &Declaration = EMPTY_BLOCK_DECL,
              content: [&Expression],
              catcher: &Expression = EMPTY_EXPR,
              guards: [&ScopeGuardExpr] = [])
        
        with super (loc)
        , end = end
        , declModule = module
        , content = content
        , scopes = guards
        , catcher = catcher
    {}

             
    impl Streamable;
    impl Formattable {

        /**
         * Pretty formatting of the block inside the stream
         */
        pub over format (self, dmut stream: &Formatter) {
            stream:.write (Tokens::LACC, Tokens::RETURN);
            stream:.entabing ();

            if let x: &BlockDecl = self.declModule {                
                x.format (alias stream);                
            }            
            
            for i, elem in self.content {
                if (i != 0) stream:.write (Tokens::SEMI_COLON, Tokens::RETURN);
                elem.format (alias stream);                
            }
            
            if (self.content.len != 0) stream:.write ('\n');            
            stream:.detabing ();
            stream:.write (Tokens::RACC);

            if self.catcher !of EmptyExpr {          
                self.catcher.format (alias stream);                
            }
            
            for i in self.scopes {
                i.format (alias stream);
            }
        }        
    }
    
}
