mod ymirc::syntax::expression::_;

import ymirc::lexing::word;
import ymirc::syntax::node;

import ymirc::utils::format;

import ymirc::utils::serialize;
import std::io;

/**
 * Ancestor class of all expressions
 */
pub class @abstract Expression over SyntaxNode {

    /**
     * @params: 
     *   - loc: the location of the expression
     */
    pub self (loc : &Word) with super (loc)
    {}

    /**
     * @returns: true iif self and other are strictly identical
     */
    pub fn opEquals (self, o : &Expression)-> bool;

    impl Serializable;
    impl Streamable;
}

pub import ymirc::syntax::expression::assert_;
pub import ymirc::syntax::expression::atomic_;
pub import ymirc::syntax::expression::block;
pub import ymirc::syntax::expression::break_;
pub import ymirc::syntax::expression::cast_;
pub import ymirc::syntax::expression::conditional;
pub import ymirc::syntax::expression::decoexpr;
pub import ymirc::syntax::expression::destrdecl;
pub import ymirc::syntax::expression::empty;
pub import ymirc::syntax::expression::for_;
pub import ymirc::syntax::expression::funcptr;
pub import ymirc::syntax::expression::intrinsic;
pub import ymirc::syntax::expression::lambda;
pub import ymirc::syntax::expression::list;
pub import ymirc::syntax::expression::literal::_;
pub import ymirc::syntax::expression::macro_::_;
pub import ymirc::syntax::expression::matcher;
pub import ymirc::syntax::expression::namedexpr;
pub import ymirc::syntax::expression::operator::_;
pub import ymirc::syntax::expression::pragma;
pub import ymirc::syntax::expression::return_;
pub import ymirc::syntax::expression::scopeguard;
pub import ymirc::syntax::expression::set;
pub import ymirc::syntax::expression::slice;
pub import ymirc::syntax::expression::template::_;
pub import ymirc::syntax::expression::throw_;
pub import ymirc::syntax::expression::try;
pub import ymirc::syntax::expression::unsafe_;
pub import ymirc::syntax::expression::vardecl;
pub import ymirc::syntax::expression::while_;
pub import ymirc::syntax::expression::with_;
