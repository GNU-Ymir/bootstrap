mod ymirc::syntax::declaration::class_;


import ymirc::syntax::declaration::_;
import ymirc::syntax::expression::_;

import ymirc::syntax::_;
import ymirc::lexing::word;
import ymirc::lexing::tokens;
import ymirc::utils::format;

import std::io;


/**
 * A syntax class declaration 
 * @verbatim: 
 * ================
 * class_decl := Keys::CLASS (attributes) Identifier (Keys::OVER Path) '{' class_content '}'
 * ================
 */
pub class @final ClassDecl over Declaration {

    /// The ancestor of the class (might be empty)
    let _ancestor : &Expression;

    /// The list of declaration inside the class
    let _content : [&Declaration];

    /// The list of attributes
    let _attributes : [AttributeWord];

    
    /**
     * @params: 
     *    - loc: the identifier of the class 
     *    - comm: the comments about the class
     *    - inner: the inner declarations about the class
     *    - attrs: the attributes of the class (final, abstract...)
     *    - ancestor: the expression that declare the ancestor of the class
     */
    pub self (loc : &Word, comm : [c8], inner : [&Declaration], attrs : [AttributeWord] = [], ancestor : &Expression = UnitExpr::new ())
        with super (loc, comm), _content = inner, _attributes = attrs, _ancestor = ancestor
    {}


    /**
     * ================================================================================
     * ================================================================================
     * =========================           GETTERS            =========================
     * ================================================================================
     * ================================================================================
     */
    
    /**
     * @returns: the expression declaring the ancestor of the class
     * @info: if the class has no ancestor, returns a UnitExpr expression
     */
    pub def getAncestor (self)-> &Expression {
        self._ancestor
    }

    /**
     * @returns: the list of declaration inside the class
     */
    pub def getDeclarations (self)-> [&Declaration] {
        self._content
    }

    /**
     * @returns: the list of attributes
     */
    pub def getAttributes (self)-> [AttributeWord] {
        self._attributes
    }


    /**
     * ================================================================================
     * ================================================================================
     * =========================        MISCELLANEOUS         =========================
     * ================================================================================
     * ================================================================================
     */

    impl Streamable;
    impl Formattable {

        /**
         * Pretty formatting of the class inside the stream
         */
        pub over format (self, dmut stream : &Formatter) {
            stream:.write (Keys::CLASS, ' 'c8);
            if (self._attributes.len != 0u64) {
                stream:.write (Tokens::AT, '{'c8);
                let mut j = 0u64;
                for i in self._attributes {
                    if (j != 0u64) stream:.write (','c8);
                    stream:.write (i.attr);
                    j += 1u64;
                }
                stream:.write ("} "s8);
            }
            stream:.write (self._loc.str ());
            
            match self._ancestor {
                UnitExpr () => {}
                _ => {
                    stream:.entabing ();
                    stream:.write (' 'c8, Keys::OVER, ' 'c8);
                    self._ancestor.format (alias stream);
                    stream:.detabing ();
                }
            }

            stream:.write (" {\n"s8);
            stream:.entabing ();
            for i in self._content {
                i.format (alias stream);
            }
            stream:.detabing ();
            stream:.write ("}\n"s8);            
        }
        
    }

}
