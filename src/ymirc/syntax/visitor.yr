in visitor;

mod ::global;
mod ::special;
mod ::type;
mod ::expr;
mod ::enum_;
mod ::def_;
mod ::macro_;
mod ::union_;
mod ::function;
mod ::trait_;


use ymirc::syntax::errors;
use ymirc::errors::_;
use ymirc::syntax::{_,
                    visitor::_,
                    declaration::_,
                    expression::_};

use ymirc::lexing::_;
use ymirc::utils::_;
use ymirc::global::state;

use std::{fs::_, io};

/**
 * Open a file and read it's content
 * 
 * @params:
 *    - path: the path to the file
 * */
fn readFile (path: Path)-> [c8]
    throws FsError
{    
    let dmut f = File::open (path);
    f:.readAll ()
}

/**
 * The syntax visitor class is the class used to transform a text content into an analyzable syntax tree
 * The syntax visitor will validated the content of the source code, but only at a syntaxic level
 */
@final
pub class SyntaxVisitor {

    /*! Context fields */
    prv {
        // The path of the file being read
        let _path: Path;

        // The lexer that is used to cut the content string in tokens
        let dmut _lex: &SrcLexer;

        // The location of the template call being read if any
        let mut _inTemplateCall: &Word = EOF_WORD;
    }
    
    /*! Visitor fields */
    prv {
        // The visitor for class and struct declarations
        let _typeVisitor: TypeVisitor = TypeVisitor (); 

        // The visitor for `def` declarations
        let _defVisitor: DefVisitor = DefVisitor ();
        
        // The visitor for enumerations
        let _enumVisitor: EnumVisitor = EnumVisitor ();

        // The visitor for expressions and instructions
        let _exprVisitor: ExpressionVisitor = ExpressionVisitor ();
        
        // The visitor for global declarations
        let _globalVisitor: GlobalVisitor = GlobalVisitor ();

        // The visitor for reading `macro` declarations
        let _macroVisitor: MacroVisitor = MacroVisitor ();

        // The visitor for reading `union` declarations
        let _unionVisitor: UnionVisitor = UnionVisitor ();

        // The visitor reading functions
        let _functionVisitor: FunctionVisitor = FunctionVisitor ();

        // The visitor reading traits
        let _traitVisitor: TraitVisitor = TraitVisitor ();
    }
    
    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =====================================          CTORS          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */
    
    /**
     * Create a new visitor for a given file
     * 
     * @params:
     *    - path: the path of the file to read
     */
    pub self open (path: Path)
        with _lex = copy SrcLexer (path.toStr (), readFile (path))        
        , _path = path
        throws FsError, ErrorMsg
    {}                    

    /**
     * Create a new visitor from string content
     * 
     * @params:
     *    - path:    the path of the file containing the string
     *    - content: the content of the string
     *    
     * */
    pub self fromStr (path: [c8], content: [c8])
        with _lex = copy SrcLexer (path, content)                                        
        , _path = Path (path)

        throws ErrorMsg
    {}            

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          GETTERS          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * @returns: the lexer
     * */
    pub fn getLexer (mut self)-> dmut &SrcLexer {
        alias self._lex
    }

    /**
     * @returns: the visitor reading global blocks
     * */
    pub fn getGlobalVisitor (self)-> GlobalVisitor {
        self._globalVisitor
    }

    /**
     * @returns: the visitor reading class and struct blocks
     * */
    pub fn getTypeVisitor (self)-> TypeVisitor {
        self._typeVisitor
    }

    /**
     * @returns: the visitor reading expressions and instructions
     * */
    pub fn getExpressionVisitor (self)-> ExpressionVisitor {
        self._exprVisitor
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          READING          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */
    
    /**
     * Once the visitor is initialized, (with open for instance) the content can
     * be read an transformed into a syntax tree
     * 
     * @example:
     * ```
     * let dmut visitor = copy Visitor::open (Path ("foo.yr"));
     * {
     *    // verify the grammar of the content of the file
     *    // And return it into a syntax tre
     *    let module = visitor:.read ();
     *    println (format ("%", module)); // pretty print the module that has been read
     * } catch {
     *    err: &ErrorMsg => {
     *          println (format ("%", err)); // print the error that occured inside the file
     *    }
     * }
     * ```
     */
    pub fn read (mut self)-> &ModuleDecl
        throws ErrorMsg
    {                 
        let (loc, path, comm) = self:.readGlobalModuleName ();
        let block = self._globalVisitor.readBlock (alias self, loc, comm);
        let ret = copy ModuleDecl (loc-> loc,
                                   name-> path,
                                   comm-> comm,
                                   block-> block,
                                   isGlobal-> true);
        
        ret
    }

    /**
     * Read the first declaration line of the module (if any), and return the
     * declared path
     * 
     * @returns:
     *    - .0: the location of the `in` keyword was read, EOF if not
     *    - .1: the identifier of the current module if `in` was read, EOF if not
     *    - .2: the comments describing the current global module
     *
     *
     * @grammar
     * ```
     * GlobalModuleName :=
     *      'in' Identifier ';'
     *    | <empty>
     *    
     * ```
     */
    fn readGlobalModuleName (mut self) -> (&Word, &Word, [c8])
        throws ErrorMsg
    {
        let (next, _) = self:.readIf (Keys::IN);
        if (next != Keys::IN) {
            return (EOF_WORD, EOF_WORD, "");
        }
        
        let (path, comm) = self:.readIdentifier ();
        self:.readTokens (Tokens::SEMI_COLON);
        (next, path, comm)
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          ATTRIBUTES          ===================================
     * ====================================================================================================
     * ====================================================================================================
     */


    /**
     * Throw a syntax error if there are attributes in a wrong position (i.e. !attrLoc.isEof)
     * 
     * @params:
     *    - loc:     the location of the declaration that cannot have attributes
     *    - attrLoc: the attributes location (or EOF if not read)
     *    - attrs:   the list of read attributes
     * */
    pub fn checkNoAttributes (self, loc: &Word, attrLoc: &Word, attrs: [AttributeWord])
        throws ErrorMsg
    {        
        if (attrLoc.isEof) return;
        
        let mut notes: [&ErrorMsg] = [];
        if !loc.isEof {
            notes = copy [copy ErrorMsg::note (loc, "")];
        }                
        
        throw copy ErrorMsg::fatal (attrLoc,
                                    format (SyntaxErrorMessage::UNEXPECTED_ATTRIBUTES, copy [x.attr for x in attrs]),
                                    notes-> notes);                
    }

    /**
     * Read a list of custom attributes, if the token Tokens::AT is not read,
     * then an empty list is returned
     * 
     * @info: Not rewindable, if start with Tokens::AT, it is an attribute
     * 
     * @grammar
     * ```
     * attributes_lst :=
     *     '@' '{' Attribute (Tokens::COMA Attribute)* '}')
     *   | '@' Attribute ('@' Attribute)*
     *   
     * ```
     * @returns:
     *   - .0: the location of the attribute reading (or EOF if nothing read)
     *   - .1: the list of attributes read
     *   - .2: the comments on top of the attribute list
     *   
     */
    pub fn readAttributes (mut self)-> (&Word, [AttributeWord], [c8])
        throws ErrorMsg
    {
        // All attributes start with Tokens::AT '@'
        let (next, comm) = self:.readIf (Tokens::AT);
        if (next.isEof) return (EOF_WORD, [], []);

        // List starts with '@' '{
        let (open, _) = self:.readIf (Tokens::LACC);
        let mut vec: [mut AttributeWord] = [];
        loop {
            let (identifier, _) = self:.readTokens (expand Attributes::__members__);

            // Check if already read
            for j in vec if j.attr == identifier {
                throw copy ErrorMsg::fatal (j.loc, end-> identifier, format (SyntaxErrorMessage::MULTIPLE_ATTRS, j.attr));            
            }

            // No need to check wether it exists, it necessarily does, we read it in self:.readTokens
            for id in Attributes::__members__ if id == identifier {
                vec ~= [AttributeWord (identifier, id)];                    
                break;            
            }
            

            // Only one, not a list (not read '{')
            if (open.isEof) {
                // But they can be chained with another '@'
                let (at,_) = self:.readIf (Tokens::AT);
                if (at.isEof) break;
            } else {
                // multiple, either ',' or '}'
                let (close, _) = self:.readTokens (Tokens::COMA, Tokens::RACC);
                if (close.str == Tokens::RACC) break;
            }
        }        

        (next, vec, comm)
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ==================================          DECLARATIONS          ==================================
     * ====================================================================================================
     * ====================================================================================================
     */
    
    /**
     * Read a declaration introduced by the keyword `def`
     * @params:
     *    - loc:  the location of the `def` keyword
     *    - comm: the comment above the `def`
     *    
     * @grammar: cf. `DefVisitor`     
     */
    pub fn readDef (mut self, loc: &Word, comm: [c8])-> &Declaration
        throws ErrorMsg
    {
        return self._defVisitor.read (alias self, loc, comm);
    }    

    /**
     * Read a class declaration cf. ClassVisitor
     *
     * @params:
     *   - loc:   the token introducing the class
     *   - comm:  the comment on top of the class
     *   - attrs: the list of attributes on top of the class
     *
     * @grammar: cf. `ClassVisitor`
     */
    pub fn readClass (mut self,  loc: &Word, comm: [c8], attrs: [AttributeWord])-> &Declaration
        throws ErrorMsg
    {
        return self._typeVisitor.read (alias self, loc, comm, attrs);
    }

    /**
     * Read an union type, introduced by the `union` keyword
     *
     * @params:
     *    - loc:  the location of the `union` keyword
     *    - comm: the comment above the union
     *
     * @grammar: cf. `UnionVisitor`
     * 
     * */
    pub fn readUnion (mut self, loc: &Word, comm: [c8])-> &Declaration
        throws ErrorMsg
    {
        return self._unionVisitor.read (alias self, loc, comm);
    }
    
    /**
     * Read an enumeration definition
     *
     * @params:
     *    - loc:  the location of the `enum` keyword
     *    - comm: the comment above the enum
     *
     * @grammar: cf. `EnumVisitor`
     */
    pub fn readEnum (mut self,  loc: &Word, comm: [c8])-> &Declaration
        throws ErrorMsg
    {
        return self._enumVisitor.read (alias self, loc, comm);
    }

    /**
     * Read a function definition
     *
     * @params:
     *    - loc:   the location of the `fn` keyword
     *    - comm:  the comment above the function
     *    - attrs: the list of attributes above the function
     *
     * @grammar: cf. `FunctionVisitor`
     *     
     */
    pub fn readFunction (mut self, loc: &Word, comm: [c8], attrs: [AttributeWord])-> &Declaration
        throws ErrorMsg
    {
        return self._functionVisitor.read (alias self, loc, comm, attrs);
    }
    
    /**
     * Read a macro declaration
     * 
     * @params:
     *    - loc:  the location of the `macro` keyword
     *    - comm: the comment above the macro
     *
     * @grammar: cf. `MacroVisitor`
     */
    pub fn readMacro (mut self,  loc: &Word, comm: [c8])-> &MacroDecl
        throws ErrorMsg
    {
        return self._macroVisitor.read (alias self, loc, comm);
    }

    /**
     * Read a trait declaration
     *
     * @params:
     *    - loc:  the location of the `trait` keyword
     *    - comm: the comment above the trait
     *
     * @grammar: cf. `TraitVisitor`
     */
    pub fn readTrait (mut self,  loc: &Word, comm: [c8])-> &Declaration
        throws ErrorMsg
    {
        return self._traitVisitor.read (alias self, loc, comm);
    }

    /**
     * Read a unittest declaration
     *
     * @params
     *    - loc:  the location of the `__test` keyword
     *    - comm: the comment above the unittest
     *
     * @grammar: cf. `FunctionVisitor`
     */
    pub fn readUnitTest (mut self, loc: &Word, comm: [c8])-> &Declaration
        throws ErrorMsg
    {
        return self._functionVisitor.readUnittest (alias self, loc, comm);        
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          TEMPLATES          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Read a list of template parameters
     *
     * @params:
     *    - ifLoc: the location of the template test if there is one (can be EOF)
     *
     * @info:
     *    A specific error is thrown if the ifLoc is set, but there are not template to read
     * 
     * @grammar
     * ```
     * TemplateParameters :=
     *    '{' TemplateParameter (',' TemplateParameter)* '}'
     *
     * TemplateParameter :=
     *     TemplateVarDeco Identifier
     *   | TemplateVarParam
     *   | ExpressionSimple(0)
     *
     * TemplateVarDeco :=
     *      'alias'
     *    | 'class'
     *    | 'entity'
     *    | 'tuple'
     *    | 'record'
     *    | 'union'
     *    | 'enum'
     *
     *
     * TemplateVarParam :=
     *      Identifier (':' OperandSimple(0))? ('=' ExpressionSimple(BOOL_LOGIC))?
     *    | Identifier ':' '...'
     *    | Identifier '...'
     *    | Identifier TemplateFilter OperandSimple(0) ('&&' TemplateFilter OperandSimple(0))*
     *    | OperandSimple(0)
     *    
     * ```
     */
    pub fn readTemplateParameters (mut self, ifLoc: &Word)-> [&Expression]
        throws ErrorMsg
    {        
        let (begin, _) = self:.readIf (Tokens::LACC);            
        if (begin.isEof) { // We don't use readTokens, because we want to check wether the ifLoc is set
            let mut notes: [&ErrorMsg] = [];
            if !ifLoc.isEof { // There's a template test, but no template
                notes = copy [copy ErrorMsg::note (ifLoc, SyntaxErrorMessage::IF_NON_TEMPLATE)];
            } 

            // Expecting a list of template parameters
            throw copy ErrorMsg::fatal (begin, format (SyntaxErrorMessage::UNEXPECTED_BUT_LST, begin.str, Tokens::LACC),
                                        notes-> notes);
        }
        
        // read the template expressions
        let mut vec: [mut &Expression] = [];
        loop {
            let seek = self.getSeek ();
            let (curr, _) = self:.readToken ();
            match curr.str {
                Keys::ALIAS | Keys::CLASS | Keys::ENTITY | TemplateVarType::TUPLE | Keys::RECORD | Keys::UNION | Keys::ENUM => {
                    let (ident, _) = self:.readIdentifier ();
                    vec ~= [copy TemplateVarExpr (ident, keys::toEnum!{TemplateVarType} (curr.str))];
                }
                _ => {
                    self:.rewindToSeek (seek);
                    if curr.isName && curr != Keys::SELF {
                        vec ~= [self:.readTemplateVarParam ()];
                    } else {
                        vec ~= [self._exprVisitor.readOperandSimple0 (alias self)];
                    }
                }
            }

            let (token, _) = self:.readTokens (Tokens::RACC, Tokens::COMA);
            if (token.str == Tokens::RACC) break;
        }

        vec
    }

    /**
     * Read an expression that checks template specialization
     * 
     * @grammar: cf. `self.readTemplateParameters`
     */
    fn readTemplateVarParam (mut self)-> &Expression
        throws ErrorMsg
    {

        let (id, _) = self:.readIfIdentifier ();
        if id.isEof { // All filters, start with an Identifier, but OperandSimple(0)
            return self._exprVisitor.readOperandSimple0 (alias self);
        }

        let (next, _) = self:.readToken ();
        match next.str {
            Tokens::COLON => {                
                return self:.readTemplateVarValue (id);
            }

            Tokens::TDOT => {
                return copy TemplateVariadicVarExpr (id, isValue-> false);   
            }
            Keys::OVER | Keys::OF | Keys::IMPL => {
                return self:.readTemplateVarOf (id, next);
            }
            
            Tokens::EQUAL => {
                let value = self._exprVisitor.readOperandSimple0 (alias self);
                
                return copy VarDeclExpr (id,
                                         name-> id,
                                         type-> EMPTY_EXPR,
                                         value-> value,
                                         isMutOrDmut-> EOF_WORD,
                                         isLazyOrRef-> EOF_WORD);
            }
            
        }

        self:.rewind ();
        return copy VarExpr (name-> id);
    }

    /**
     * Read a template var value, introduced by the token ':'
     *
     * @params:
     *    - id:    the identifier of the variable
     *    - colon: the location of the ':' token
     *
     * @grammar: cf. `self:.readTemplateParameters`
     * */
    fn readTemplateVarValue (mut self, id: &Word)-> &Expression
        throws ErrorMsg
    {
        let type = self._exprVisitor.readOperandSimple0 (alias self);
        
        let mut value: &Expression = EMPTY_EXPR;
        let (hasValue, _) = self:.readIf (Tokens::EQUAL);
        if !hasValue.isEof {
            value = self._exprVisitor.readExpressionSimple (alias self, BinaryOperatorsLevelNames::BOOL_LOGIC);
        }

        return copy VarDeclExpr (id,
                                 name-> id,
                                 type-> type,
                                 value-> value,
                                 isMutOrDmut-> EOF_WORD,
                                 isLazyOrRef-> EOF_WORD);        
    }

    /**
     * Read a template of var filter
     * 
     * @params:
     *    - id:     the identifier of the variable being specialized
     *    - filter: the first filter that was read (of, over, impl)
     *
     * @grammar: cf. `self:.readTemplateParameters`
     * */
    fn readTemplateVarOf (mut self, id: &Word, filter: &Word)-> &Expression
        throws ErrorMsg
    {
        let mut lst: [&TemplateOfVarExpr] = [];
        let mut currFilter: &Word = filter;
        loop {
            let spec = self._exprVisitor.readOperandSimple0 (alias self);
            let kind = keys::toEnum!{TemplateOfVarType} (currFilter.str);
            lst ~= [copy TemplateOfVarExpr (id, spec, kind-> kind)];

            let (hasAnd, _) = self:.readIf (Tokens::DAND);
            if hasAnd.isEof
                break;

            let (nextFilter, _) = self:.readTokens (Keys::OVER, Keys::OF, Keys::IMPL);
            currFilter = nextFilter;
        }

        if lst.len == 1
            return lst [0];

        return copy TemplateAndExpr (id, lst);
    }
    

    /**
     * Read a template test (if any)
     * 
     * @returns:
     *   - .0: the location of the if token, (or eof)
     *   - .1: the test expression, or EmptyExpr
     *
     * @grammar
     * ```
     * TemplateTest :=
     *    'if' ExpressionSimple(BOOL_LOGIC)
     * ```
     */
    pub fn readTemplateTest (mut self)-> (&Word, &Expression)
        throws ErrorMsg
    {
        let (hasTest, _) = self:.readIf (Keys::IF);
        if hasTest.isEof {
            return (hasTest, EMPTY_EXPR);
        }
        
        (hasTest, self._exprVisitor.readExpressionSimple (alias self, BinaryOperatorsLevelNames::BOOL_LOGIC))        
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ================================          VAR DECLARATION          =================================
     * ====================================================================================================
     * ====================================================================================================
     */
    
    /**
     * Read a variable modifier. 
     *
     * @grammar
     * ```
     * VariableModifier :=
     *   | <empty>
     *   | MutOrDmutKw
     *   | LazyOrRefKw
     *   | MutOrDmutKw LazyOrRefKw
     *   | LazyOrRefKw MutOrDmutKw
     *
     * MutOrDmutKw := 'mut' | 'dmut'
     * LazyOrRefKw := 'lazy' | 'ref'             
     * ```
     *
     * @returns:
     *    - .0: the location of the `lazy` | `ref` keyword or EOF
     *    - .1: the location of the `mut` | `dmut` keyword or EOF
     * */
    pub fn readVariableModifiers (mut self)-> (&Word, &Word) {
        let (isLazyOrRef, _) = self:.readIf (Keys::LAZY, Keys::REF);        
        let (isMutOrDmut, _) = self:.readIf (Keys::MUTABLE, Keys::DMUTABLE);
        
        if (isLazyOrRef.isEof && !isMutOrDmut.isEof) {
            let (retry, _) = self:.readIf (Keys::LAZY, Keys::REF);

            return (retry, isMutOrDmut);
        }

        (isLazyOrRef, isMutOrDmut)
    }        


    /**
     * Read a variable modifier omitting lazy. 
     *
     * @grammar
     * ```
     * VariableModifierNoLazy :=
     *   | <empty>
     *   | MutOrDmutKw
     *   | RefKw
     *   | MutOrDmutKw RefKw
     *   | RefKw MutOrDmutKw
     *
     * MutOrDmutKw := 'mut' | 'dmut'
     * RefKw := 'ref'             
     * ```
     *
     * @returns:
     *    - .0: the location of the `ref` keyword or EOF
     *    - .1: the location of the `mut` | `dmut` keyword or EOF
     * */
    pub fn readVariableModifiersNoLazy (mut self)-> (&Word, &Word) {
        let (isLazyOrRef, _) = self:.readIf (Keys::REF);        
        let (isMutOrDmut, _) = self:.readIf (Keys::MUTABLE, Keys::DMUTABLE);
        
        if (isLazyOrRef.isEof && !isMutOrDmut.isEof) {
            let (retry, _) = self:.readIf (Keys::REF);

            return (retry, isMutOrDmut);
        }

        (isLazyOrRef, isMutOrDmut)
    }        
    
    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ==================================          IDENTIFIERS          ===================================
     * ====================================================================================================
     * ====================================================================================================
     */
    
    /**
     * Read an identifier from the lexer
     *
     * @returns:
     *    - .0: the identifier
     *    - .1: the comment above the identifier
     */
    pub fn readIdentifier (mut self)-> (&Word, [c8])
        throws ErrorMsg
    {        
        let (ident, comm) = self:.readToken ();
        if !ident.isName {
            throw copy ErrorMsg::fatal (ident, format (SyntaxErrorMessage::UNEXPECTED, ident.str));
        }

        (ident, comm)
    }

    /**
     * Read the next token, and return it if it's a valid identifier, or return
     * EOF and left the cursor unmoved if it isn't.
     *
     * @returns:
     *    - .0: the identifier
     *    - .1: the comment above the identifier
     */
    pub fn readIfIdentifier (mut self)-> (&Word, [c8]) {
        let ident = self.peekToken ();
        if !ident.isName {
            return (EOF_WORD, "");
        }
        
        return self:.readToken ();
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =================================          CONTEXT SWITCH          =================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Set the location of the current '!' calling templates values (EOF otherwise)
     *
     * @params:
     *    - loc: the location of the '!' operator
     *  
     * */
    pub fn setInTemplate (mut self, loc: &Word) {
        self._inTemplateCall = loc;
    }

    /**
     * @returns: the location of the current '!' calling template values, if any (EOF otherwise)
     * */
    pub fn isInNoAccTemplate (self)-> &Word {
        self._inTemplateCall
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ================================          READING HELPERS          =================================
     * ====================================================================================================
     * ====================================================================================================
     */
    
    /**
     * Read a token, compare it to the list, and if the token is among them
     * return it. If it isn't left the cursor unmoved and return EOF.           
     * 
     * @params:
     *    - lst: a list of tokens
     *
     * @returns:
     *    - .0: the read token (or EOF)
     *    - .1: the comment above the token
     *
     * @example
     * ```
     * let seek = context.getSeek ();
     * 
     * // Read and increment cursor only if next token is a ',', a ')', or a ']'
     * let (tok, comm) = context:.readIf (Tokens::COMA, Tokens::RPAR, Tokens::RCRO);
     * if tok.isEof {
     *    println ("It is none of them");
     *    assert (context.getSeek () == seek);
     * } 
     * 
     * ```
     */
    pub fn readIf {R...} (mut self, f: [c8], l: R)-> (&Word, [c8]) {                
        let x = self._lex.peek ();        
        if (x.isEof) return (EOF_WORD, "");

        if x == f {
            return self._lex:.next ();
        }
        
        
        cte if (R,)::arity > 1 {
            cte for i in l if x.str == i {
                return self._lex:.next ();    
            } 
        } else {
            if x == l {
                return self._lex:.next ();
            }
        }
        
        return (EOF_WORD, "");
    }
    
    /**
     * Read a token, compare it to the list, and if the token is among them
     * return it. If it isn't left the cursor unmoved and return EOF.           
     *  
     * @params:
     *    - lst: a list of tokens 
     *
     * @returns:
     *    - .0: the read token (or EOF)
     *    - .1: the comment above the token
     *
     * @example
     * ```
     * let seek = context.getSeek ();
     * 
     * // Read and increment cursor only if next token is either a ',' or a ')'
     * let (tok, comm) = context:.readIf (copy [Tokens::COMA, Tokens::RPAR]);
     * if tok.isEof {
     *    println ("It is neither");
     *    assert (context.getSeek () == seek);
     * } 
     * 
     * ```    
     */
    pub fn readIf (mut self, lst: [[c8]])-> (&Word, [c8]) {
        let x = self._lex.peek ();
        if (x.isEof) return (EOF_WORD, "");

        for i in lst {
            if i == x.str {
                return self._lex:.next ();
            }
        }

        return (EOF_WORD, "");
    }

    /**
     * Read a token, compare it to the parameter, and if the two are equal
     * return it. If it isn't left the cursor unmoved and return EOF.
     * 
     * @params:
     *    - tok: a token to compare
     *
     * @returns:
     *    - .0: the read token (or EOF)
     *    - .1: the comment above the token
     *
     * @example
     * ```
     * let seek = context.getSeek ();
     * 
     * // Read and increment cursor only if next token is a ','
     * let (tok, comm) = context:.readIf (Tokens::COMA);
     * if tok.isEof {
     *    println ("It is not");
     *    assert (context.getSeek () == seek);
     * } 
     * 
     * ```
     */
    pub fn readIf (mut self, tok: [c8])-> (&Word, [c8]) {
        let x = self._lex.peek ();
        if (x.str == tok) return self._lex:.next ();

        return (EOF_WORD, "");
    }

    /**
     * Read the next token and return it without comparing it to anything.
     *
     * @returns:
     *    - .0: the read token (or EOF if there are no next token)
     *    - .1: the comment above the token 
     * */
    pub fn readToken (mut self)-> (&Word, [c8]) {
        self._lex:.next ()
    }
    
    /**
     * Returns the next token inside the lexer without moving the cursor
     * 
     * @returns: the next token or EOF if there is no next token.
     * 
     * @example
     * ```
     * let seek = context.getSeek ();
     * let next = context.peekToken ();
     *
     * assert (context.getSeek () == seek);
     * 
     * ```
     * */
    pub fn peekToken (self)-> &Word {
        self._lex.peek ()
    }

    /**
     * @returns: true iif there is no next token to read
     * */
    pub fn isEof (self)-> bool {
        self._lex.isEof
    }

    /**
     * Read a token, compare it to a list of token, and return it if the token
     * is found among the list. Throw an exception if the token is not found.
     * Increment the cursor upon reading.
     * 
     * @params:
     *    - f: the first element of the variadic list
     *    - l: the rest of the variadic list
     *
     * @returns:
     *    - .0: the token read
     *    - .1: the comment above the token
     *
     * @example
     * ```
     * // Force the next token to be a ',', or a ')' or a ']'
     * let (next, _) = context:.readTokens (Tokens::COMA, Tokens::RPAR, Tokens::RCRO);
     *
     * 
     * ```
     */
    pub fn readTokens {R...} (mut self, f: [c8], l: R)-> (&Word, [c8])
        throws ErrorMsg
    {                        
        let (x, y) = self._lex:.next ();
        if x == f {
            return (x, y);
        }

        cte if (R,)::arity > 1 {
            cte for i in l if x.str == i {
                return (x, y);            
            }
            
            throw copy ErrorMsg::fatal (x, format (SyntaxErrorMessage::UNEXPECTED_BUT_LST, x.str, copy [f, expand l]));
        } else {
            if x.str == l {
                return (x, y);
            }
            
            throw copy ErrorMsg::fatal (x, format (SyntaxErrorMessage::UNEXPECTED_BUT_LST, x.str, copy [f, l]));
        }                                 
    }
    
    /**
     * Read a token, compare it to a list of token, and return it if the token
     * is found among the list. Throw an exception if the token is not found.
     * Increment the cursor upon reading.
     * 
     * @params:
     *    - f: the first element of the variadic list
     *    - l: the rest of the variadic list
     *
     * @returns:
     *    - .0: the token read
     *    - .1: the comment above the token
     *
     * @example
     * ```
     * // Force the next token to be a ',', or a ')' or a ']'
     * let (next, _) = context:.readTokens (copy [Tokens::COMA, Tokens::RPAR, Tokens::RCRO]);
     *
     * 
     * ```
     */
    pub fn readTokens (mut self, lst: [[c8]])-> (&Word, [c8])
        throws ErrorMsg
    {
        let (x, y) = self._lex:.next ();
        for i in lst {
            if i == x.str {
                return (x, y);
            }
        }

        throw copy ErrorMsg::fatal (x, format (SyntaxErrorMessage::UNEXPECTED_BUT_LST, x.str, lst));
    }

    /**
     * Read a token, compare it to a token, and return it the two are equal.
     * Throw an exception if they aren't. Increment the cursor upon reading.
     * 
     * @params:
     *    - tok: the token to compare
     *
     * @returns:
     *    - .0: the token read
     *    - .1: the comment above the token
     *
     * @example
     * ```
     * // Force the next token to be a ',', or a ')' or a ']'
     * let (next, _) = context:.readTokens (Tokens::COMA, Tokens::RPAR, Tokens::RCRO);
     *
     * 
     * ```
     */
    pub fn readTokens (mut self, tok: [c8])-> (&Word, [c8])
        throws ErrorMsg
    {
        let (x, y) = self._lex:.next ();
        if (x.str == tok) return (x, y);

        throw copy ErrorMsg::fatal (x, format (SyntaxErrorMessage::UNEXPECTED_BUT_LST, x.str, tok));
    }

    /**
     * @returns: the cursor of the lexer (i.e. seek of the next word)
     * */
    pub fn getSeek (self)-> usize {
        self._lex.getSeek ()
    }
    
    /**
     * @returns: move the cursor backward by one word (i.e. moving the seek to the previous word in the list)
     * */
    pub fn rewind (mut self) {
        self._lex:.rewind ()
    }

    /**
     * Rewind the cursor to seek. The seek can be found using the `getSeek` method.
     *
     * @params:
     *    - seek: the seek to rewind to
     *
     * @example
     * ```
     * let seek = context.getSeek ();
     * let (fst, _) = context:.readToken ();
     * for i in 0 .. NB { // read an arbitrary number of words
     *    context:.readToken ();
     * }
     *
     * context:.rewindToSeek (seek); // go back just before `fst`
     * let (test, _) = context:.readToken ();
     * assert (fst == test);
     * 
     * ```
     * */
    pub fn rewindToSeek (mut self, seek: usize) {
        self._lex:.rewindToSeek (seek)
    }
    
    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =====================================          TESTS          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */
    
    /**
     * @returns:
     *    true, if this expression needs at the end, a semi colon to be
     *    separated from other expressions
     * 
     */
    pub fn needClosingExpr (self, expr: &Expression)-> bool {
        match expr {
            AtomicExpr      () => { false }
            BlockExpr       () => { false }            
            ConditionalExpr () => { false }
            EmptyExpr       () => { false }
            ForLoopExpr     () => { false }
            MatcherExpr     () => { false }            
            ScopeGuardExpr  () => { false }            
            WhileLoopExpr   () => { false }
            UnsafeExpr      () => { false }                        
            _ => { true }
        }
    }
    
}
