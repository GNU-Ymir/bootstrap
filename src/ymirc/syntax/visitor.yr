in visitor;

mod ::global;
mod ::special;
mod ::class_;
mod ::expr;


use ymirc::syntax::errors;
use ymirc::errors::_;
use ymirc::syntax::{_,
                    visitor::_,
                    declaration::_,
                    expression::{_, literal::_, macro_::_, operator::_, template::_}};

use ymirc::lexing::_;
use ymirc::utils::_;
use ymirc::global::state;

use std::{fs::_, io};

/**
 * Open a file and read it's content
 * 
 * @params:
 *    - path: the path to the file
 * */
fn readFile (path : Path)-> [c8]
    throws FsError
{    
    let dmut f = File::open (path);
    f:.readAll ()
}

/**
 * The syntax visitor class is the class used to transform a text content into an analyzable syntax tree
 * The syntax visitor will validated the content of the source code, but only at a syntaxic level
 */
@final
pub class SyntaxVisitor {

    // The path of the file being read
    let _path : Path;

    // The lexer that is used to cut the content string in tokens
    let dmut _lex : &SrcLexer;

    // True iif currently reading template call expr without parentheses
    let mut _inTemplateCall : bool = false;

    // The collection of special tokens and keys
    let _specials : SpecialKeysAndTokens = special::__SPECIAL_TOKENS__;    
    
    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          VISITORS          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    // The visitor for global declarations
    let _globalVisitor : GlobalVisitor = GlobalVisitor ();

    // The visitor for class and struct declarations
    let _classVisitor : ClassVisitor = ClassVisitor ();

    // The visitor for expressions and instructions
    let _exprVisitor : ExpressionVisitor = ExpressionVisitor (); 
    
    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =====================================          CTORS          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */
    
    /**
     * Create a new visitor for a given file
     * @params:
     *  - path: the path of the file to read
     */
    pub self open (path : Path)
        with _lex = copy SrcLexer (path.toStr (), readFile (path))        
        , _path = path
        throws FsError, ErrorMsg
    {}                    

    /**
     * Create a new visitor from string content
     * @params:
     *    - path: the path of the file containing the string
     *    - content: the content of the string
     * */
    pub self fromStr (path : [c8], content : [c8])
        with _lex = copy SrcLexer (path, content)                                        
        , _path = Path (path)

        throws ErrorMsg
    {}            


    /*!
     * ================================================================================
     * ================================================================================
     * ========================            GETTERS            =========================
     * ================================================================================
     * ================================================================================
     */


    /**
     * @returns: the lexer
     * */
    pub fn getLexer (mut self)-> dmut &SrcLexer {
        alias self._lex
    }

    /**
     * @returns: the visitor reading global blocks
     * */
    pub fn getGlobalVisitor (self)-> GlobalVisitor {
        self._globalVisitor
    }

    /**
     * @returns: the visitor reading class and struct blocks
     * */
    pub fn getClassVisitor (self)-> ClassVisitor {
        self._classVisitor
    }

    /**
     * @returns: the visitor reading expressions and instructions
     * */
    pub fn getExpressionVisitor (self)-> ExpressionVisitor {
        self._exprVisitor
    }
    
    /*!
     * ================================================================================
     * ================================================================================
     * =========================            MODULE            =========================
     * ================================================================================
     * ================================================================================
     */


    /**
     * Once the visitor is initialized, (with open for instance)
     * the content can be read an transformed into a syntax tree
     * @example:
     * ```
     * let dmut visitor = copy Visitor::open (Path ("foo.yr"));
     * {
     *    // verify the grammar of the content of the file
     *    // And return it into a syntax tre
     *    let module = visitor:.read ();
     *    println (format ("%", module)); // pretty print the module that has been read
     * } catch {
     *    err : &ErrorMsg => {
     *          println (format ("%", err)); // print the error that occured inside the file
     *    }
     * }
     * ```
     */
    pub fn read (mut self)-> &ModuleDecl
        throws ErrorMsg
    {                 
        let (loc, path, comm) = self:.readGlobalPath ();
        let block = self._globalVisitor.readBlock (alias self, loc, comm);
        let ret = copy ModuleDecl (loc, path, comm, block, isGlobal-> true);
        ret
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================      DECLARATION BLOCKS      =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Read the first declaration line of the module (if any), and return the declared path
     * @returns:
     *    - .0: the location of the `in` keyword was read, EOF if not
     *    - .1: the identifier of the current module if `in` was read, EOF if not
     *    - .2: the comments describing the current global module
     *    
     */
    fn readGlobalPath (mut self) -> (&Word, &Word, [c8])
        throws ErrorMsg
    {
        let next = self:.readIf (Keys::INT);
        if (next != Keys::IN) {
            return (EOF_WORD, EOF_WORD, "");
        }
        
        let (path, comm) = self:.readIdentifier ();
        self:.readTokens (Tokens::SEMI_COLON);
        (next, path, comm)
    }


    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          ATTRIBUTES          ===================================
     * ====================================================================================================
     * ====================================================================================================
     */


    /**
     * Throw a syntax error if there are attributes in a wrong position (i.e. !attrLoc.isEof)
     * @params:
     *    - loc: the location of the declaration that cannot have attributes
     *    - attrLoc: the attributes location (or EOF if not read)
     *    - attrs: the list of read attributes
     * */
    pub fn checkNoAttributes (self, loc: &Word, attrLoc: &Word, attrs: [AttributeWord])
        throws ErrorMsg
    {        
        if (attrLoc.isEof) return;
        
        let mut notes: [&ErrorMsg] = [];
        if !loc.isEof {
            notes = copy [copy ErrorMsg::note (loc, "")];
        }                
        
        throw copy ErrorMsg::fatal (attrLoc,
                                    format (SyntaxErrorMessage::UNEXPECTED_ATTRIBUTES, copy [x.attr for x in attrs]),
                                    notes-> notes);                
    }

    /**
     * Read a list of custom attributes, if the token Tokens::AT is not read, then an empty list is returned
     * @info: Not rewindable, if start with Tokens::AT, it is an attribute
     * @verbatim:
     * ```
     * attributes_lst :=  '@' '{' Attribute (Tokens::COMA Attribute)* '}')
     *                   | '@' Attribute ('@' Attribute)*
     * ```
     * @returns:
     *   - .0: the location of the attribute reading (or EOF if nothing read)
     *   - .1: the list of attributes read
     *   - .2: the comments on top of the attribute list
     */
    pub fn readAttributes (mut self)-> (&Word, [AttributeWord], [c8])
        throws ErrorMsg
    {
        // All attributes start with Tokens::AT '@'
        let (next, comm) = self:.readIf (Tokens::AT);
        if (next.isEof) return (EOF_WORD, [], []);

        // List starts with '@' '{
        let (open, _) = self:.readIf (Tokens::LACC);
        let mut vec: [mut AttributeWord] = [];
        loop {
            let (identifier, _) = self:.readTokens (expand Attributes::__members__);

            // Check if already read
            for j in vec if j.attr == identifier {
                throw copy ErrorMsg::fatal (j.loc, end-> identifier, format (SyntaxErrorMessage::MULTIPLE_ATTRS, j.attr));            
            }

            // No need to check wether it exists, it necessarily does, we read it in self:.readTokens
            for id in Attributes::__members__ if id == identifier {
                vec ~= [AttributeWord (identifier, id)];                    
                break;            
            }
            

            // Only one, not a list (not read '{')
            if (open.isEof) {
                // But they can be chained with another '@'
                let (at,_) = self:.readIf (Tokens::AT);
                if (at.isEof) break;
            } else {
                // multiple, either ',' or '}'
                let (close, _) = self:.readTokens (Tokens::COMA, Tokens::RACC);
                if (close.str == Tokens::RACC) break;
            }
        }        

        (next, vec, comm)
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ======================================          DEF          =======================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Read a declaration introduced by the keyword `def`
     *
     * @params:
     *    - loc: the location of the `def` keyword
     *    - comm: the comment above the `def` declaration
     * 
     * @grammars:
     * ```
     * DefDecl :=
     *     TemplateDefDecl     
     *   | DefDecl     
     *
     * TemplateDefDecl :=
     *   TemplateTest? Identifier TemplateParams ('=' | ':') Expression(0) ';'
     *
     * DefDecl :=
     *   Identifier ('=' | ':') Expression (0) ';'
     *   
     * ```
     * 
     */
    pub fn readDef (mut self, loc: &Word, comm: [c8])-> &Declaration
        throws ErrorMsg
    {
        let tryTemplateLoc = self.getSeek ();
        let mut normErr : (&ErrorMsg)? = none;
        let mut templateErr : (&ErrorMsg)? = none;
                
        { // Try reading a normal `def` decl
            let (ident, _) = self:.readIdentifier ();
            let (kind, _) = self:.readTokens (Tokens::EQUAL, Tokens::COLON);
            let value = self:.readExpression ();
            self:.readTokens (Tokens::SEMI_COLON);

            return copy DefDecl (loc, ident, comm, value, kind);
        } catch {
            err => {
                normErr = (err)?;
            }
        }

        // Go back to try reading a template version of the def
        self:.rewindToSeek (tryTemplateLoc);
        { // Try a template `def`
            let (ifLoc, test) = self:.readTemplateTest ();
            let (ident, _) = self:.readIdentifier ();
            let templates = self:.readTemplateParameters (ifLoc-> ifLoc);
            
            let (kind, _) = self:.readTokens (Tokens::EQUAL, Tokens::COLON);
            let value = self:.readExpression ();
            self:.readTokens (Tokens::SEMI_COLON);

            let aka = copy DefDecl (loc, ident, comm, value, kind);
            return copy TemplateDecl (ident, comm, templates, aka, test-> test)
        } catch {
            err => {
                templateErr = (err)?;
            }
        }

        // Both failed, throwing the errors
        if let (Ok (ne), Ok (te)) = (normErr, templateErr) {
            throw copy ErrorMsg::list (copy [ne, te]);
        }

        eprintln ("internal syntax visitor error: error messages are empty");
        panic;    
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =====================================          CLASS          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */
    
    /**
     * Read a class declaration cf. ClassVisitor
     *
     * @params:
     *   - loc:     the token introducing the class
     *   - comm:    the comment on top of the class
     *   - attrs: the list of attributes on top of the class
     *
     * @grammar: cf. `ClassVisitor`
     */
    pub fn readClass (mut self,  loc: &Word, comm: [c8], attrs: [AttributeWord])-> &Declaration
        throws ErrorMsg
    {
        return self._classVisitor.read (alias self, loc, comm, attrs);
    }

    /**
     * Read a class constructor
     * @verbatim:
     * ================
     * constructor :=   Keys::SELF Keys::IF expression:(0) (attrs)? (Identifier)? template_param_list param_list (with_decl)? (throws_decl)? expression:(0)
     *                | Keys::SELF (attrs)? (Identifier)? (template_param_list)? param_list (with_decl)? (throws_decl)? expression:(0)
     * ================
     */
    fn readClassConstructor (mut self, loc : &Word, comm : [c8], attrs : [AttributeWord], isStruct : bool) -> &Declaration
        throws ErrorMsg
    {
        let (hasTest, test) = self:.readTemplateTest ();
        let (name, _) = self:.readIfIdentifier ();
        let templates = self:.readTemplateParameters (ifLoc-> hasTest);

        let proto = self:.readFunctionPrototype (returnValue-> false);

        let dmut construction : [(&Word, &Expression)] = [];
        let mut supers : [&Expression] = [], mut tmpCall : &Expression = EMPTY_EXPR;
        let mut auxCstrLoc = EOF_WORD, mut auxCstrName = EOF_WORD;
        if (!(self:.readIf (Keys::WITH)._0).isEof) {
            loop {
                let (next, _) = self:.readToken ();
                match next.str {
                    Keys::SUPER | Keys::SELF => {
                        if (isStruct && next.str == Keys::SUPER) throw copy ErrorMsg::fatal (next, format (SyntaxErrorMessage::UNEXPECTED, next.str));
                        if (!auxCstrLoc.isEof)
                        throw copy ErrorMsg::fatal (next, SyntaxErrorMessage::MULTIPLE_AUX_CSTRS, notes-> copy [copy ErrorMsg::note (auxCstrLoc, "")]);

                        auxCstrLoc = next;
                        auxCstrName = if (self:.readIf (Tokens::DCOLON)._0.isEof) {
                            EOF_WORD
                        } else {
                            self:.readIdentifier ()._0
                        };

                        tmpCall = self:.readTemplateCall (tmpCall);
                        self:.readTokens (Tokens::LPAR);
                        supers = self:.readArgumentList (withNamed-> true)._0;
                    }
                    _ => {
                        if next.isName {
                            throw copy ErrorMsg::fatal (next, format (SyntaxErrorMessage::USED_AS_IDENTIFIER, next.str));
                        }

                        self:.readTokens (Tokens::EQUAL);
                        construction ~= [(next, self:.readExpression ())];
                    }
                }

                if ((self:.readIf (Tokens::COMA)._0).isEof) {
                    break;
                }
            }
        }

        let (throwLoc, throwers) = self:.readThrowers ();
        let body = self:.readExpression ();

        let cstr = copy ConstructorDecl (loc, comm, rename-> name, proto,
                                         superParams-> supers, superTemplateParams-> tmpCall,
                                         fields-> construction,
                                         body-> body,
                                         explicitCstrsCall-> auxCstrLoc, explicitSuperName-> auxCstrName, attributes-> attrs,
                                         throwers-> throwers, throwerLoc-> throwLoc);

        if (templates.len != 0u64) {
            copy TemplateDecl (loc, comm, templates, cstr, test-> test)
        } else {
            cstr
        }
    }

    /**
     * Read class destructor
     * @verbatim:
     * ================
     * destructor := Keys::DTOR Tokens::LPAR Keys::MUT Keys::SELF Tokens::RPAR expression:(0)
     * ================
     */
    fn readClassDestructor (mut self, loc : &Word, comm : [c8])-> &Declaration
        throws ErrorMsg
    {
        self:.readTokens (Tokens::LPAR);
        let var = self:.readSingleVarDeclaration (mandType-> false, withValue-> false, isClass-> true);
        self:.readTokens (Tokens::RPAR);

        let content = self:.readExpression ();
        copy DestructorDecl (loc, comm, var, content)
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================          IMPLEMENT           =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Read an implementation of traits inside a class definition
     * @verbatim:
     * ==================
     * impl := Keys::IMPL expression:(0) (((',' expression:(0))* ';') | class_block_decl)
     * ==================
     */
    pub fn readImplement (mut self, loc : &Word, comm : [c8]) -> &Declaration
        throws ErrorMsg
    {
        let trait_ = self:.readExpression ();
        let (next, _) = self:.readIf (Tokens::SEMI_COLON, Tokens::COMA, Tokens::LACC);
        if (next == Tokens::LACC) {
            let content = self:.readClassBlockDecl (inImpl-> true, inProtection-> false, closing-> true, isStruct-> false);
            copy ImplDecl (loc, comm, trait_, content-> content)
        } else if (next == Tokens::COMA) {
            let mut impls : [mut &Declaration] = [];
            impls ~= [copy ImplDecl (loc, comm, trait_)];
            loop {
                let tr = self:.readExpression ();
                let (n, _) = self:.readTokens (Tokens::SEMI_COLON, Tokens::COMA);
                impls ~= [copy ImplDecl (loc, comm, tr)];
                if (n == Tokens::SEMI_COLON) break;
            }

            copy BlockDecl (loc, comm, impls)
        } else {
            copy ImplDecl (loc, comm, trait_)
        }
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================             ENUM             =========================
     * ================================================================================
     * ================================================================================
     */


    /**
     * Read an enumeration definition
     * @verbatim:
     * =======================
     * enum_decl :=   Keys::ENUM Keys::IF expression:(0) enum_content Keys::ARROW Identifier template_param_list (Tokens::SEMI_COLON)?
     *              | Keys::ENUM enum_content Keys::ARROW Identifier (Tokens::SEMI_COLON)?
     *
     * enum_content := (Tokens::PIPE Identifier ('=' expression:(0))?)*
     * =======================
     */
    pub fn readEnum (mut self,  loc : &Word, comm : [c8])-> &Declaration
        throws ErrorMsg
    {
        let (hasTest, test) = self:.readTemplateTest ();

        let type = if (!((self:.readIf (Tokens::COLON))._0).isEof) {
            self:.readOperand3 ()
        } else { EMPTY_EXPR }

        let mut values : [mut &VarDeclExpr] = [];
        let mut coms : [[c8]] = [];
        let mut fst = true;
        loop {
            let (n, com) = self:.readTokens (Tokens::PIPE, Tokens::ARROW);
            if (!fst) coms ~= [com];

            if (n != Tokens::ARROW) {
                let (name, _) = self:.readIdentifier ();
                if (!(self:.readIf (Tokens::EQUAL)._0).isEof) {
                    values ~= [copy VarDeclExpr (name, name, value-> self:.readExpression (level-> self._specials.binaryOperators.len), type-> EMPTY_EXPR)]
                } else {
                    values ~= [copy VarDeclExpr (name, name, value-> EMPTY_EXPR, type-> EMPTY_EXPR)]
                }
            } else break;

            fst = false;
        }

        let (name, _) = self:.readIdentifier ();
        let templates = self:.readTemplateParameters (ifLoc-> hasTest);
        self:.readTokens (Tokens::SEMI_COLON);
                
        let en = copy EnumDecl (name, comm, type-> type, values-> values, fieldComms-> coms);
        if (templates.len == 0us) {
            en
        } else {
            copy TemplateDecl (loc, comm, templates, test-> test, content-> en)
        }
    }

    // /*!
    //  * ================================================================================
    //  * ================================================================================
    //  * =========================           FUNCTION           =========================
    //  * ================================================================================
    //  * ================================================================================
    //  */

    // /**
    //  * Read a function definition
    //  * @verbatim:
    //  * ====================
    //  * function :=   Keys::IF expression:(0) Identifier template_param_list function_proto throwers body
    //  *             | Identifier function_proto throwers body
    //  * ====================
    //  */
    // pub fn readFunction (mut self,  _ : &Word, comm : [c8], attrs : [AttributeWord], isMethod : bool = false, isOver : bool = false)-> &Declaration
    //     throws ErrorMsg
    // {
    //     let (hasTest, test) = self:.readTemplateTest ();
    //     let (name, _) = self:.readIdentifier ();
    //     if (name == Keys::SELF) throw copy ErrorMsg::fatal (name, format (SyntaxErrorMessage::USED_AS_IDENTIFIER, name.str));
    //     let templates = self:.readTemplateParameters (ifLoc-> hasTest);

    //     let proto = self:.readFunctionPrototype (isClosure-> false, isClass-> isMethod);
    //     let (throwLoc, throwers) = self:.readThrowers ();
    //     let body = self:.readFunctionBody ();

    //     let func = copy FunctionDecl (name, comm, proto, body, attrs-> attrs, throwers-> throwers, isOver-> isOver, throwerLoc-> throwLoc);
    //     if (templates.len == 0us) {
    //         func
    //     } else {
    //         copy TemplateDecl (name, comm, templates, test-> test, content-> func)
    //     }
    // }

    // /**
    //  * Read a function body
    //  * @verbatim:
    //  * ===================
    //  * body := ';' | expression:(0)
    //  * ===================
    //  */
    // fn readFunctionBody (mut self)-> &Expression
    //     throws ErrorMsg
    // {
    //     if ((self:.readIf (Tokens::SEMI_COLON)._0).isEof) {
    //         self:.readExpression ()
    //     } else {
    //         EMPTY_EXPR
    //     }
    // }

    // /**
    //  * Read a function prototype
    //  * @verbatim:
    //  * ====================
    //  * closure_proto := Tokens::PIPE (var_decl (',' var_decl)*)? Tokens::PIPE (Tokens::ARROW expression:(0))?
    //  * function_proto := Tokens::LPAR (var_decl (',' var_decl)*)? Tokens::RPAR (Tokens::ARROW expression:(0))?
    //  * ====================
    //  */
    // fn readFunctionPrototype (mut self, isClosure : bool = false, isClass : bool = false, returnValue : bool = true)-> &FunctionProtoDecl
    //     throws ErrorMsg
    // {
    //     let (loc, hasParams) = {
    //         if isClosure {
    //             let (n, _) = self:.readTokens (Tokens::PIPE, Tokens::DPIPE);
    //             (n, n == Tokens::PIPE)
    //         } else { (self:.readTokens (Tokens::LPAR)._0, true) }
    //     }; 

    //     let mut isVariadic = false;
    //     let mut params : [mut &VarDeclExpr] = [];
    //     if hasParams {
    //         loop {
    //             if (isClosure) {
    //                 if ((self:.readIf (Tokens::PIPE)._0).isEof) {
    //                     params ~= [self:.readSingleVarDeclaration (mandType-> false, withValue-> false, isClass-> false)];
    //                     if ((self:.readTokens (Tokens::PIPE, Tokens::COMA)._0) == Tokens::PIPE) break;
    //                 } else break;
    //             } else {
    //                 let tok = if (!isClass || params.len > 0us) {
    //                     self:.readIf (Tokens::RPAR, Tokens::TDOT)._0
    //                 } else { EOF_WORD }

    //                 if (tok == Tokens::TDOT) {
    //                     isVariadic = true;
    //                     self:.readTokens (Tokens::RPAR);
    //                     break;
    //                 } else if (tok != Tokens::RPAR) {
    //                     params ~= [self:.readSingleVarDeclaration (mandType-> true, withValue-> true, isClass-> (isClass && params.len == 0us))];
    //                     if ((self:.readTokens (Tokens::RPAR, Tokens::COMA)._0) == Tokens::RPAR) break;
    //                 } else break;
    //             }
    //         }
    //     }

    //     if !returnValue {
    //         return copy FunctionProtoDecl (loc, params-> params, retType-> EMPTY_EXPR, isVariadic-> isVariadic, forLambda-> isClosure);
    //     }

    //     if (!(self:.readIf (Tokens::ARROW)._0).isEof) {
    //         copy FunctionProtoDecl (loc, params-> params, retType-> self:.readExpression (), isVariadic-> isVariadic, forLambda-> isClosure)
    //     } else {
    //         copy FunctionProtoDecl (loc, params-> params, retType-> EMPTY_EXPR, isVariadic-> isVariadic, forLambda-> isClosure)
    //     }
    // }

    // /**
    //  * Read the list of throwers of a function
    //  * @verbatim:
    //  * ====================
    //  * throwers: (Keys::THROWS expression:(0) (',' expression:(0))*)?
    //  * ====================
    //  */
    // fn readThrowers (mut self)-> (&Word, [&Expression])
    //     throws ErrorMsg
    // {
    //     let (th, _) = self:.readIf (Keys::THROWS);
    //     let mut res : [mut &Expression] = [];
    //     if (!th.isEof) {
    //         loop {
    //             res ~= [self:.readExpression ()];
    //             let (n, _) = self:.readIf (Tokens::COMA);
    //             if (n.isEof) break;
    //         }
    //     }

    //     (th, res)
    // }

    // /*!
    //  * ================================================================================
    //  * ================================================================================
    //  * =========================            GLOBAL            =========================
    //  * ================================================================================
    //  * ================================================================================
    //  */

    // /**
    //  * Read a global var declaration
    //  * @verbatim:
    //  * ====================
    //  * global := var_decl
    //  * ====================
    //  */
    // pub fn readGlobal (mut self,  loc : &Word, comm : [c8], isField : bool = false, isStatic : bool = false, forceType : bool = false, attrs : [AttributeWord])-> &GlobalDecl
    //     throws ErrorMsg
    // {
    //     let (_, isMutOrDmut) = self:.readDecoratorVariable (canBeLazyOrRef-> false);
    //     let name = self:.readIdentifier ()._0;

    //     let type = if (forceType || isField) {
    //         self:.readTokens (Tokens::COLON);
    //         self:.readExpression (level-> self._specials.binaryOperators.len)
    //     } else if (self:.readIf (Tokens::COLON)._0 == Tokens::COLON) {
    //         self:.readExpression (level-> self._specials.binaryOperators.len)
    //     } else {
    //         EMPTY_EXPR
    //     };

    //     let value = if (self:.readIf (Tokens::EQUAL)._0 == Tokens::EQUAL) {
    //         self:.readExpression (level-> 0us)
    //     } else {
    //         EMPTY_EXPR
    //     };

    //     let overLazyOrRef = if (!isStatic && !isField) {
    //         loc.locate (Keys::LAZY)
    //     } else {
    //         EOF_WORD
    //     };

    //     let inner = copy VarDeclExpr (name, name,
    //                                   isMutOrDmut-> isMutOrDmut,
    //                                   isLazyOrRef-> overLazyOrRef,
    //                                   value-> value,
    //                                   type-> type);

    //     let glb = copy GlobalDecl (loc, comm, inner, isField-> isField, isStatic-> isStatic, attrs-> attrs);
    //     self:.readTokens (Tokens::SEMI_COLON);

    //     glb
    // }

    // /*!
    //  * ================================================================================
    //  * ================================================================================
    //  * =========================            MACRO             =========================
    //  * ================================================================================
    //  * ================================================================================
    //  */

    // /**
    //  * Read a macro declaration
    //  * @verbatim:
    //  * ==================
    //  * macro := Keys::MACRO Identifier macro_block
    //  * ==================
    //  */
    // pub fn readMacro (mut self,  _ : &Word, comm : [c8])-> &MacroDecl
    //     throws ErrorMsg
    // {
    //     let (name, _) = self:.readIdentifier ();
    //     self:.readTokens (Tokens::LACC);
    //     copy MacroDecl (name, comm, self:.readMacroBlock ())
    // }



    // /**
    //  * Read the content of a macro
    //  * @verbatim:
    //  * =================
    //  * macro_block := Tokens::LACC (public_macro_block | version_macro_block)* Tokens::RACC
    //  * =================
    //  */
    // fn readMacroBlock (mut self) -> [&Declaration]
    //     throws ErrorMsg
    // {
    //     let mut decls : [mut &Declaration] = [];
    //     loop {
    //         let (n, comm) = self:.readIf (Keys::USE, Tokens::RACC);
    //         match n {
    //             Tokens::RACC => { break; }                
    //             Keys::USE => {                    
    //                 decls ~= self._globalVisitor.readUse (alias self, n, comm);
    //             }
    //             _ => {
    //                 decls ~= [self:.readMacroContent ()];
    //             }
    //         }
    //     }

    //     decls
    // }

    // /**
    //  * Read the content of a macro definition
    //  * @verbatim:
    //  * =================
    //  * marco_content := macro_constructor | macro_rule
    //  * =================
    //  */
    // fn readMacroContent (mut self) -> &Declaration
    //     throws ErrorMsg
    // {
    //     let (type, comm) = self:.readTokens (Keys::FUNCTION, Keys::SELF);
    //     match type {
    //         Keys::FUNCTION => {
    //             self:.readMacroRule (type, comm)
    //         }
    //         _ => self:.readMacroConstructor (type, comm)
    //     }
    // }

    // /**
    //  * Read a macro rule
    //  * @verbatim:
    //  * ===============
    //  * macro_rule := Keys::FUNCTION Identifier macro_head_rule (Tokens::SEMI_COLON | macro_body_rule)
    //  * ===============
    //  */
    // fn readMacroRule (mut self, _ : &Word, comm : [c8]) -> &Declaration
    //     throws ErrorMsg
    // {
    //     let (name, _) = self:.readIdentifier ();
    //     let (head, skips) = self:.readMacroRuleHead ();

    //     let body = if (self:.readIf (Tokens::SEMI_COLON)._0.isEof) {
    //         let (body, _) = self:.readStringTokens (Tokens::MACRO_CRO, Tokens::MACRO_ACC, Tokens::MACRO_PAR);            
    //         body
    //     } else {
    //         EOF_WORD
    //     };

    //     copy MacroRuleDecl (name,
    //                         comm,
    //                         body,
    //                         body.str,
    //                         head,
    //                         skips-> skips,
    //                         isConstructor-> false)
    // }


    // /**
    //  * Read a macro constructor
    //  * @verbatim:
    //  * ==================
    //  * macro_constructor := Keys::SELF macro_head_rule macro_body_rule
    //  * ==================
    //  */
    // fn readMacroConstructor (mut self, loc : &Word, comm : [c8]) -> &Declaration
    //     throws ErrorMsg
    // {
    //     let (head, skips) = self:.readMacroRuleHead ();
    //     let (body, _) = self:.readStringTokens (Tokens::MACRO_CRO, Tokens::MACRO_ACC, Tokens::MACRO_PAR);
        
    //     copy MacroRuleDecl (loc,
    //                         comm,
    //                         body,
    //                         body.str,
    //                         head,
    //                         skips-> skips,
    //                         isConstructor-> true)
    // }


    // /**
    //  * Read the head (prototype) of a macro rule (or constructor)
    //  * @verbatim:
    //  * =================
    //  * macro_rule_head :=  macro_inner_mult (Keys::SKIPS string_lit (Tokens::PIPE string_lit)*)?
    //  * =================
    //  */
    // fn readMacroRuleHead (mut self)-> (&MacroMultExpr, [&Expression])
    //     throws ErrorMsg
    // {
    //     let (start, end, inner) = self:.readInnerMacroMult ();

    //     let mut skips : [mut &Expression] = [];
    //     if (!(self:.readIf (Keys::SKIPS)._0).isEof) {
    //         self:.readTokens (Tokens::LPAR);
    //         loop {
    //             let (str, _) = self:.readStringTokens (Tokens::DQUOTE, suffix-> false);                                                
    //             let strExpr = copy StringExpr (str.open, str.close, str.str);
                
    //             skips ~= [copy MacroTokenExpr (str, strExpr)];                    
    //             if (self:.readTokens (Tokens::RPAR, Tokens::PIPE)._0 == Tokens::RPAR) break;
    //         }
    //     }

    //     (copy MacroMultExpr (start, end, inner), skips)
    // }

    // /**
    //  * Read the inner part of a macro mutliplicator
    //  * @verbatim:
    //  * ==================
    //  * macro_inner_mult := Tokens::LPAR ((macro_expression*) | (macro_expression (Tokens::PIPE macro_expression)*) Tokens::RPAR
    //  * ==================
    //  */
    // fn readInnerMacroMult (mut self)-> (&Word, &Word, [&MacroRuleExpression])
    //     throws ErrorMsg
    // {
    //     let (start, _) = self:.readTokens (Tokens::LPAR);

    //     let mut fst = self:.readMacroExpression ();
    //     let (n, _) = self:.readIf (Tokens::PIPE, Tokens::RPAR);
    //     if (n.str == Tokens::RPAR) return (start, n, copy [fst]);
    //     else if (n.str == Tokens::PIPE) { // a list of pipes i.e. /(a | b | c)/
    //         let mut end = EOF_WORD;
    //         loop {
    //             let next = self:.readMacroExpression ();
    //             fst = copy MacroOrExpr (n, fst, next);
    //             end = self:.readTokens (Tokens::PIPE, Tokens::RPAR)._0;
    //             if (end == Tokens::RPAR) break;
    //         }

    //         return (start, end, copy [fst]);
    //     }

    //     // a simple list, i.e. (a b c)
    //     let mut inner : [mut &MacroRuleExpression] = copy [fst];
    //     let mut end = EOF_WORD;
    //     loop {
    //         inner ~= [self:.readMacroExpression ()];
    //         end = self:.readIf (Tokens::RPAR)._0;
    //         if (!end.isEof) break;
    //     }

    //     (start, end, inner)
    // }


    // /**
    //  * Read a macro rule expression
    //  * @verbatim:
    //  * =================
    //  * macro_expression :=   macro_inner_mult (Multiplicator)?
    //  *                     | Identifier (Tokens::EQUAL macro_expression)?
    //  *                     | String
    //  * =================
    //  */
    // fn readMacroExpression (mut self)-> &MacroRuleExpression
    //     throws ErrorMsg
    // {
    //     let (n, _) = self:.readIf (Tokens::LPAR);
    //     if (n == Tokens::LPAR) {
    //         self:.rewind ();
    //         let (start, end, inner) = self:.readInnerMacroMult ();
    //         let (mult, _) = self:.readIf (self._specials.macroMult);
    //         copy MacroMultExpr (start, end, inner, mult-> mult)
    //     } else {
    //         let (ident, _) = self:.readIfIdentifier ();
    //         if (ident.isEof) {                            
    //             let (str, _) = self:.readStringTokens (Tokens::DQUOTE, suffix-> false);
    //             let strExpr = copy StringExpr (str.open, str.close, str.str);                
    //             copy MacroTokenExpr (str, strExpr)             
    //         } else {
    //             if (self:.readIf (Tokens::EQUAL)._0.isEof) {
    //                 copy MacroIdentExpr (ident)
    //             } else {
    //                 let (rule, _) = self:.readIfIdentifier ();
    //                 let inner = if (!rule.isEof) {
    //                     copy MacroIdentExpr (rule)
    //                 } else {
    //                     self:.readMacroExpression ()
    //                 };

    //                 copy MacroVarExpr (ident, inner)
    //             }
    //         }
    //     }
    // }

    // /*!
    //  * ================================================================================
    //  * ================================================================================
    //  * =========================            TRAIT             =========================
    //  * ================================================================================
    //  * ================================================================================
    //  */


    // /**
    //  * Visit a trait declaration
    //  * @verbatim:
    //  * =================
    //  * trait_decl :=   Keys::TRAIT Keys::IF expression:(0) Identifier template_param_list class_block_decl
    //  *               | Keys::TRAIT Identifier class_block_decl
    //  * =================
    //  */
    // pub fn readTrait (mut self,  _ : &Word, comm : [c8])-> &Declaration
    //     throws ErrorMsg
    // {

    //     let (hasTest, test) = self:.readTemplateTest ();
    //     let (name, _) = self:.readIdentifier ();
    //     let templates = self:.readTemplateParameters (ifLoc-> hasTest);
        
    //     self:.readTokens (Tokens::LACC);
    //     let decls = self:.readClassBlockDecl (inImpl-> true, isStruct-> false, closing-> true, inProtection-> false);

    //     let tra = copy TraitDecl (name, comm, decls);

    //     if (templates.len == 0us) {
    //         tra
    //     } else {
    //         copy TemplateDecl (name, comm, templates, test-> test, tra)
    //     }
    
    // }

    // /*!
    //  * ================================================================================
    //  * ================================================================================
    //  * =========================           UNITTEST           =========================
    //  * ================================================================================
    //  * ================================================================================
    //  */


    // /**
    //  * Visit a unittest declaration
    //  * @verbatim:
    //  * ==================
    //  * unittest := Keys::UNITTEST expression:(0)
    //  * ==================
    //  */
    // pub fn readUnitTest (mut self, loc : &Word, comm : [c8])-> &Declaration
    //     throws ErrorMsg
    // {
    //     copy UnitTestDecl (loc, comm, self:.readExpression ())
    // }

    // /*!
    //  * ================================================================================
    //  * ================================================================================
    //  * =========================           TEMPLATE           =========================
    //  * ================================================================================
    //  * ================================================================================
    //  */

    /**
     * Read a list of template parameters     
     */
    pub fn readTemplateParameters (mut self, ifLoc : &Word)-> [&Expression]
        throws ErrorMsg
    {        
        let (begin, _) = self:.readIf (Tokens::LACC);            
        if (begin.isEof) { // We don't use readTokens, because we want to check wether the ifLoc is set
            let mut notes: [&ErrorMsg] = [];
            if !ifLoc.isEof { // There's a template test, but no template
                notes = copy [copy ErrorMsg::note (ifLoc, SyntaxErrorMessage::IF_NON_TEMPLATE)];
            } 

            // Expecting a list of template parameters
            throw copy ErrorMsg::fatal (begin, format (SyntaxErrorMessage::UNEXPECTED_BUT_LST, begin.str, Tokens::LACC),
                                        notes-> notes);
        }
        
        // read the template expressions
        let mut vec: [mut &Expression] = [];
        loop {
            let (curr, _) = self:.readToken ();
            match curr.str {
                Keys::ALIAS | Keys::CLASS | Keys::ENTITY | TemplateVarType::TUPLE | Keys::RECORD | Keys::UNION | Keys::ENUM => {
                    let (ident, _) = self:.readIdentifier ();
                    vec ~= [copy TemplateVarExpr (ident, self.toTemplateVarType (curr.str))];
                }
                _ => {
                    self:.rewindToSeek (curr);
                    if curr.isName && curr != Keys::SELF {
                        vec ~= [self:.readTemplateVarParamWithNext ()];
                    } else {
                        vec ~= [self:.readOperand3 ()];
                    }
                }
            }

            let (token, _) = self:.readTokens (Tokens::RACC, Tokens::COMA);
            if (token.str == Tokens::RACC) break;
        }

        vec
    }

    /**
     * Read an expression that checks template specialization
     * @verbatim:
     * ===============
     * template_var_decl_with_next :=    Identifier (Tokens::COLON expression:0)? (Tokens::EQUAL expression:0)?
     *                               |  Identifier (Keys::OF | Keys::OVER | Keys::IMPL) expression:0 (Tokens::DAND Identifier (Keys::OF | Keys::OVER | Keys::IMPL) expression:0)?
     *                               |  Identifier (Tokens::COLON)?  Tokens::TDOT
     *                               |  expression:0
     * ===============
     */
    fn readTemplateVarParamWithNext (mut self)-> &Expression
        throws ErrorMsg
    {
        let mut inners : [mut &TemplateOfVarExpr] = [];
        let mut name = EOF_WORD;

        loop {
            let z = if (inners.len == 0us) {
                let (x, y) = self:.readTemplateVarParam ();
                if (!y) return x; // cannot &&
                match x {
                    z : &TemplateOfVarExpr => {
                        name = z.getLoc ();
                        z
                    }
                    _ => return x; // ??, but cannot && anyway
                }
            } else {
                let (innerNext, _) = self:.readTokens (Keys::OVER, Keys::OF, Keys::IMPL);
                let k = self.toTemplateOfVarType (innerNext.str);
                copy TemplateOfVarExpr (innerNext.locate (format ("%.%", name.str, inners.len)),
                                        self:.readExpression (level-> self._specials.binaryOperators.len),
                                        kind-> k)
            };

            inners ~= [z];

            let (n, _) = self:.readIf (Tokens::DAND);
            if (n.isEof) break;
        }

        if inners.len == 1us { return inners [0]; }
        let z : &TemplateOfVarExpr = inners [0];
        inners [0] = copy TemplateOfVarExpr (z.getLoc ().locate (format ("%.0", z.getLoc ().str)),
                                             z.getSpecialization (),
                                             z.getKind ());

        copy TemplateAndExpr (name, inners)
    }

    // /**
    //  * Read an expression that might be a variable inside a list of template parameters
    //  * @verbatim:
    //  * ===============
    //  * template_var_decl :=    Identifier (Tokens::COLON expression:0)? (Tokens::EQUAL expression:0)?
    //  *                      |  Identifier (Keys::OF | Keys::OVER | Keys::IMPL) expression:0
    //  *                      |  Identifier (Tokens::COLON)?  Tokens::TDOT
    //  *                      |  expression:0
    //  * ===============
    //  */
    // fn readTemplateVarParam (mut self) -> (&Expression, bool)
    //     throws ErrorMsg
    // {
    //     let (name, _) = self:.readIdentifier ();
    //     let (next, _) = self:.readIf (cast![c8] (Tokens::COLON), Tokens::TDOT,
    //                                   Tokens::EQUAL, Keys::OVER, Keys::OF,
    //                                   Keys::IMPL);

    //     match next.str {
    //         Tokens::COLON => {
    //             let (tok, _) = self:.readIf (Tokens::TDOT);
    //             if (tok.isEof) { // V : type ('=' value)?
    //                 let type = self:.readExpression (level-> self._specials.binaryOperators.len);
    //                 if (!(self:.readIf (Tokens::EQUAL)._0).isEof) { // '=' value
    //                     return (copy VarDeclExpr (name, name, value-> self:.readExpression (), type-> type), false);
    //                 } else return (copy VarDeclExpr (name, name, value-> EMPTY_EXPR, type-> type), false);
    //             } else return (copy TemplateVariadicVarExpr (name, isValue-> true), false); // V:...
    //         }
    //         Tokens::EQUAL => {
    //             return (copy VarDeclExpr (name, name, value-> self:.readExpression (), type-> EMPTY_EXPR), false);
    //         }
    //         Tokens::TDOT  => {
    //             return (copy TemplateVariadicVarExpr (name, isValue-> false), false);
    //         }
    //         Keys::OVER | Keys::OF | Keys::IMPL => {
    //             let k = self.toTemplateOfVarType (next.str);
    //             return (copy TemplateOfVarExpr (name, self:.readExpression (level-> self._specials.binaryOperators.len), kind-> k), true);
    //         }
    //     }

    //     self:.rewindToSeek (name);
    //     return (self:.readExpression (), false);
    // }

    // /**
    //  * Read a template test (if anyl
    //  * @returns:
    //  *   - the location of the if token, (or eof)
    //  *   - the test expression, or Unit
    //  */
    pub fn readTemplateTest (mut self)-> (&Word, &Expression)
        throws ErrorMsg
    {
        let (hasTest, _) = self:.readIf (Keys::IF);
        if hasTest.isEof {
            (hasTest, EMPTY_EXPR)
        } else {
            (hasTest, self:.readExpression (level-> self._specials.binaryOperators.len))
        }
    }

    // /*!
    //  * ================================================================================
    //  * ================================================================================
    //  * =========================         EXPRESSIONS          =========================
    //  * ================================================================================
    //  * ================================================================================
    //  */

    // /**
    //  * Read an expression
    //  * @verbatim:
    //  * ==================
    //  * expression:(level) := expression:(level+1) (binary_operator:(level) expression:(level))?
    //  * expression:(10) := operand:(0)
    //  * ==================
    //  */
    // pub fn readExpression (mut self, level : usize = 0us)-> &Expression
    //     throws ErrorMsg
    // {
    //     if (cast!usize (level) == self._specials.binaryOperators.len) {
    //         self:.readOperand0 ()
    //     } else {
    //         let left = self:.readExpression (level-> level + 1);
    //         self:.readExpressionFollow (left, level-> level)
    //     }
    // }

    // /**
    //  * Read the following of an expression (for operators)
    //  */
    // fn readExpressionFollow (mut self, left : &Expression, level : usize = 0us)-> &Expression
    //     throws ErrorMsg
    // {
    //     let (tok, _) = self:.readIf (self._specials.binaryOperators [level]);
    //     if tok.isEof
    //         return left;
        
    //     let right = self:.readExpression (level-> level + 1us);
    //     return self:.readExpressionFollow (copy BinaryExpr (tok, left, right), level-> level);                
    // }

    // /**
    //  * Read a highest level operand
    //  * @verbatim:
    //  * ===================
    //  * operand:(0) := (unary_operator)? operand:(1) (Tokens::INTEG)?
    //  * ===================
    //  */
    // pub fn readOperand0 (mut self) -> &Expression
    //     throws ErrorMsg
    // {
    //     let (tok, _) = self:.readIf (self._specials.unaryOperators);
    //     let ret = if (!tok.isEof) {
    //         copy UnaryExpr (tok, self:.readOperand1 ())
    //     } else { self:.readOperand1 () }

    //     let (post, _) = self:.readIf (Tokens::INTEG);
    //     if (!post.isEof) {
    //         copy TryExpr (post, ret)
    //     } else { ret }
    // }

    // /**
    //  * Read an operand of level 1
    //  * @verbatim:
    //  * =================
    //  * operand:(1) :=   block
    //  *                | if_expr
    //  *                | while_expr
    //  *                | assert_expr
    //  *                | break_expr
    //  *                | dowhile_expr
    //  *                | for_expr
    //  *                | match_expr
    //  *                | vardecl
    //  *                | return_expr
    //  *                | function_expr
    //  *                | delegate_expr
    //  *                | loop_expr
    //  *                | throw_expr
    //  *                | version
    //  *                | pragma_expr
    //  *                | with_expr
    //  *                | atomic_expr
    //  *                | operand:(operand_follow)?
    //  * =================
    //  */
    // fn readOperand1 (mut self)-> &Expression
    //     throws ErrorMsg
    // {
    //     let (tok, _) = self:.readIf (Tokens::LACC, Keys::IF, Keys::WHILE, Keys::ASSERT,
    //                                  Keys::BREAK, Keys::DO, Keys::FOR, Keys::MATCH, Keys::FUTURE,
    //                                  Keys::LET, Keys::RETURN, Keys::FUNCTION, Keys::DELEGATE,
    //                                  Keys::LOOP, Keys::THROW, Keys::PANIC, Keys::PRAGMA,
    //                                  Keys::ATOMIC, Keys::UNSAFE, Keys::VERSION);

    //     match tok {
    //         Keys::LOOP     => { self:.readLoop (tok) }
    //         Keys::WHILE    => { self:.readWhile (tok) }
    //         Tokens::LACC   => { self:.readBlock (tok) }
    //         Keys::IF       => { self:.readIfExpression (tok) }
    //         Keys::ASSERT   => { self:.readAssert (tok) }
    //         Keys::BREAK    => { self:.readBreak (tok) }
    //         Keys::DO       => { self:.readDoWhile (tok) }
    //         Keys::FOR      => { self:.readFor (tok) }
    //         Keys::MATCH    => { self:.readMatch (tok) }
    //         Keys::LET      => { self:.readVarDeclaration (tok) }
    //         Keys::RETURN   => { self:.readReturn (tok) }
    //         Keys::FUNCTION => { self:.readFunctionType (tok) }
    //         Keys::DELEGATE => { self:.readFunctionType (tok) }
    //         Keys::FUTURE   => { self:.readFutureType (tok) }
    //         Keys::THROW    => { self:.readThrow (tok) }            
    //         Keys::PRAGMA   => { self:.readPragma (tok) }
    //         Keys::ATOMIC   => { self:.readAtomic (tok) }
    //         Keys::UNSAFE   => { self:.readUnsafe (tok) }
    //         Keys::PANIC    => { self:.readPanic (tok) }
    //         Keys::VERSION  => { self:.readVersion (tok) }
    //         _ => { self:.readOperandFollow (self:.readOperand2 (self:.readOperand3 ())) }
    //     }
    // }


    // /**
    //  * Read the follow-up of an operand
    //  * @verbatim:
    //  * =================
    //  * operand_follow :=   Tokens::LPAR param_list Tokens::RPAR (operand_follow)?
    //  *                   | Tokens::LCRO param_list Tokens::RCRO (operand_follow)?
    //  *                   | (Tokens::DOT | Tokens::DOT_AND) operand:(3) (template_call)? (operand_follow)?
    //  *                   | macro_call (operand_follow)?
    //  * =================
    //  */
    // fn readOperandFollow (mut self, left : &Expression)-> &Expression
    //     throws ErrorMsg
    // {
    //     let (n, _) = self:.readIf (Tokens::LPAR, Tokens::LCRO, Tokens::LCRO_AND, Tokens::DOT, Tokens::DOT_AND);
    //     match n {
    //         Tokens::LPAR | Tokens::LCRO | Tokens::LCRO_AND => {
    //             let (params, end) = self:.readArgumentList (withNamed-> true, closing-> if (n == Tokens::LPAR) { Tokens::RPAR } else { Tokens::RCRO });
    //             return self:.readOperandFollow (copy MultOperatorExpr (n, end, left, params));
    //         }        
    //         Tokens::DOT | Tokens::DOT_AND => {
    //             let right = self:.readOperand3 (canBeTemplateCall-> false);
    //             return self:.readOperandFollow (self:.readTemplateCall (copy BinaryExpr (n, left, right)));
    //         }            
    //     }
        
    //     let s = self.peekToken ();
    //     if let str: &StringWord = s match str.open {
    //         Tokens::MACRO_ACC | Tokens::MACRO_PAR | Tokens::MACRO_CRO => {
    //             self:.readToken ();
    //             return copy MacroCallExpr (str.open, str.close, left, str.str);
    //         }
    //     }

    //     left
    // }


    // /**
    //  * Read a level 2 operand
    //  * @verbatim:
    //  * ===============
    //  * operand:(2) := (Tokens::DCOLON template_call)?
    //  * ===============
    //  */
    // fn readOperand2 (mut self, left : &Expression) -> &Expression
    //     throws ErrorMsg
    // {
    //     let (n, _) = self:.readIf (Tokens::DCOLON);
    //     if (!n.isEof) {
    //         let right = self:.readOperand3 (canBeTemplateCall-> false);
    //         self:.readOperand2 (self:.readTemplateCall (copy BinaryExpr (n, left, right)))
    //     } else {
    //         left
    //     }
    // }

    // /**
    //  * Read a level 3 operand
    //  * @verbatim:
    //  * =================
    //  * operand:(3) :=   cast_expr
    //  *                | template_checker
    //  *                | array_lit
    //  *                | tuple_lit
    //  *                | lambda_lit
    //  *                | intrinsic
    //  *                | literal
    //  *                | decorated_expr
    //  *                | var
    //  * =================
    //  */
    // fn readOperand3 (mut self, canBeTemplateCall : bool = true) -> &Expression
    //     throws ErrorMsg
    // {
    //     let (n, _) = self:.readIf (Keys::IS, Tokens::LCRO, Tokens::LPAR, Tokens::NOT);

    //     if (n == Tokens::NOT) {
    //         let (e, _) = self:.readIf(Keys::IS);
    //         if (!e.isEof) {
    //             return copy UnaryExpr (n, self:.readTemplateChecker (e));
    //         }

    //         self:.rewind ();
    //     }

    //     match n {
    //         Keys::CAST                    => { return self:.readCast (n); }
    //         Keys::IS                      => { return self:.readTemplateChecker (n); }
    //         Tokens::LCRO                  => { return self:.readArray (n); }
    //         Tokens::LPAR                  => { return self:.readTuple (n); }
    //         Tokens::PIPE | Tokens::DPIPE  => { return self:.readLambda (n); }
    //     }

    //     let (i, _) = self:.readIf (self._specials.intrinsicKeys);
    //     if (!i.isEof) {
    //         let (p, _) = self:.readIf (Tokens::LPAR);
    //         let inner = if (p.isEof) {
    //             self:.readExpression (level-> self._specials.binaryOperators.len)
    //         } else { self:.readExpression () }

    //         let ret = copy IntrinsicExpr (i, self.toIntrinsic (i.str), inner);
    //         if (!p.isEof) self:.readTokens (Tokens::RPAR);
    //         return ret;
    //     }

    //     let (j, _) = self:.readIf (self._specials.decorators);
    //     if (!j.isEof) {
    //         let inner = self:.readExpression (level-> self._specials.binaryOperators.len);
    //         return copy DecoratedExpr (j, inner, j);
    //     }

    //     let (token, _) = self:.readToken ();        
    //     if token.isName || (token.isKey && token == Keys::SELF) {            
    //         return self:.readVar (token, canBeTemplateCall-> (canBeTemplateCall && !token.isKey))
    //     }

    //     return self:.readLiteral (token);
    // }

    
    // pub fn readTypeExpression (mut self)-> &Expression
    //     throws ErrorMsg
    // {

    //     let (tok, _) = self:.readIf (self._specials.unaryOperators);
    //     let ret = if (!tok.isEof) {
    //         copy UnaryExpr (tok, self:.readOperand1 ())
    //     } else { self:.readOperand1 () }
        
    //     let (tok, _) = self:.readIf (Keys::PRAGMA, Keys::FUNCTION, Keys::DELEGATE, Keys::FUTURE, Keys::TYPEOF);
        
    //     match tok {
    //         Keys::FUNCTION => { self:.readFunctionType (tok) }
    //         Keys::DELEGATE => { self:.readFunctionType (tok) }
    //         Keys::FUTURE   => { self:.readFutureType (tok) }
    //         Keys::TYPEOF   => {
    //             self:.readTokens (Tokens::LPAR);
    //             let inner = self:.readExpression ();
    //             self:.readTokens (Tokens::RPAR);
    //             copy IntrinsicExpr (tok, self.toIntrinsic (tok.str), inner)
    //         }
    //         _ => { self:.readOperand2 (self:.readOperand3 ()) }
    //     }   
    // }
    
    
    // /**
    //  * Read a list of arguments
    //  * @params:
    //  *    - withNamed: if true, named expression are allowed in the argument list
    //  *    - closing: the token that closes the list
    //  * @verbatim:
    //  * ===================
    //  *
    //  * ===================
    //  */
    // fn readArgumentList (mut self, withNamed : bool = false, closing : [c8] = Tokens::RPAR)-> ([&Expression], &Word)
    //     throws ErrorMsg
    // {
    //     let mut vec : [mut &Expression] = [];
    //     let mut end = EOF_WORD;
    //     let (x, _) = self:.readIf (closing);
    //     if (!x.isEof) { end = x; }
    //     else {
    //         loop {
    //             if (withNamed) {
    //                 let mut read = false;
    //                 let start = self.getSeek ();
    //                 let (name, _) = self:.readIfIdentifier ();
    //                 if !name.isEof {
    //                     let (arr, _) = self:.readIf (Tokens::ARROW);
    //                     if (!arr.isEof) {
    //                         vec ~= [copy NamedExpr (name, self:.readExpression ())];
    //                         read = true;
    //                     }
    //                 }

    //                 if !read {
    //                     self:.rewindToSeek (start);
    //                     vec ~= [self:.readExpression ()];
    //                 }
    //             } else {
    //                 vec ~= [self:.readExpression ()];
    //             }

    //             let (n, _) = self:.readTokens (closing, Tokens::COMA);
    //             if (n != Tokens::COMA) {
    //                 end = n;
    //                 break;
    //             }
    //         }
    //     }

    //     (vec, end)
    // }


    // /*!
    //  * ================================================================================
    //  * ================================================================================
    //  * =========================       VAR DECLARATION        =========================
    //  * ================================================================================
    //  * ================================================================================
    //  */
    
    /**
     * Read a variable modifier. The function normalizes the order of modifiers
     * so that the return tuple always places the evaluation modifier (lazy/ref)
     * first and the mutability modifier (mut/dmut) second, regardless of the
     * order in the source code.
     *
     * @grammar:
     * ```
     * VariableModifier :=
     *   | <empty>
     *   | MutOrDmutKw
     *   | LazyOrRefKw
     *   | MutOrDmutKw LazyOrRefKw
     *   | LazyOrRefKw MutOrDmutKw
     *
     * MutOrDmutKw := 'mut' | 'dmut'
     * LazyOrRefKw := 'lazy' | 'ref'             
     * ```
     *
     * @returns:
     *    - .0: the location of the `lazy` | `ref` keyword or EOF
     *    - .1: the location of the `mut` | `dmut` keyword or EOF
     * */
    pub fn readVariableModifiers (mut self)-> (&Word, &Word) {
        let (isLazyOrRef, _) = self:.readIf (Keys::LAZY, Keys::REF);        
        let (isMutOrDmut, _) = self:.readIf (Keys::MUTABLE, Keys::DMUTABLE);
        
        if (isLazyOrRef.isEof && !isMutOrDmut.isEof) {
            let (retry, _) = self:.readIf (Keys::LAZY, Keys::REF);

            return (retry, isMutOrDmut);
        }

        (isLazyOrRef, isMutOrDmut)
    }        
    
    // /**
    //  * Read a single var declaration
    //  * @params:
    //  *    - mandType: the type is mandatory
    //  *    - withValue: there can be a value
    //  *    - isClass: self is a valid Identifier
    //  *    - level: the level of the expression (only applicable if withValue)
    //  * @verbatim:
    //  * ==================
    //  * single_var_decl :=   (Decorator)* (Identifier | Keys::UNDER) (Tokens::COLON expression:(10))? (Tokens::EQUAL expression:(level))
    //  *                    | (Decorator)* Keys::SELF
    //  * ==================
    //  */
    // fn readSingleVarDeclaration (mut self, mandType : bool = false, withValue : bool = true, mandValue : bool = false, isClass : bool = false, level : usize = 0us)-> &VarDeclExpr
    //     throws ErrorMsg
    // {
    //     let (isLazyOrRef, isMutOrDmut) = self:.readDecoratorVariable (canBeLazyOrRef-> !isClass);
    //     let (ig, _) = self:.readIf (Keys::UNDER);
    //     let name = if (!ig.isEof) {
    //         ig
    //     } else { self:.readIdentifier ()._0 }

    //     match name {
    //         Keys::SELF => {
    //             if (!isClass) throw copy ErrorMsg::fatal (name, format (SyntaxErrorMessage::USED_AS_IDENTIFIER, name.str));
    //             return copy VarDeclExpr (name, name, isMutOrDmut-> isMutOrDmut, value-> EMPTY_EXPR, type-> EMPTY_EXPR);
    //         }
    //     }


    //     if (isClass) throw copy ErrorMsg::fatal (name, format (SyntaxErrorMessage::UNEXPECTED_BUT_LST, name.str, Keys::SELF));
    //     let type = if (mandType) {
    //         self:.readTokens (Tokens::COLON);
    //         self:.readExpression (level-> self._specials.binaryOperators.len)
    //     } else if (!(self:.readIf (Tokens::COLON)._0).isEof) {
    //         self:.readExpression (level-> self._specials.binaryOperators.len)
    //     } else { EMPTY_EXPR }

    //     let value = if (withValue || mandValue) {
    //         if (mandValue) {
    //             self:.readTokens (Tokens::EQUAL);
    //             self:.readExpression (level-> level)
    //         } else if (!(self:.readIf (Tokens::EQUAL)._0).isEof) {
    //             self:.readExpression (level-> level)
    //         } else { EMPTY_EXPR }
    //     } else { EMPTY_EXPR };

    //     copy VarDeclExpr (name, name, isMutOrDmut-> isMutOrDmut, isLazyOrRef-> isLazyOrRef, value-> value, type-> type)
    // }

    // /*!
    //  * ================================================================================
    //  * ================================================================================
    //  * =========================            BLOCKS            =========================
    //  * ================================================================================
    //  * ================================================================================
    //  */

    // /**
    //  * Read a block of code
    //  * @verbatim:
    //  * ====================
    //  * block := Tokens::LACC ((n=expression:(0) (Tokens::SEMI_COLON)!if(self:.needClosingExpr (n))* (expression:(0))?) Tokens::RACC (scope_guards)?
    //  * ====================
    //  */
    // fn readBlock (mut self, loc : &Word, canBeCatcher : bool = true)-> &Expression
    //     throws ErrorMsg
    // {
    //     let mut decls : [mut &Declaration] = [];
    //     let mut content : [mut &Expression] = [];
    //     {
    //         let mut end = EOF_WORD;
    //         let mut last = false;
    //         loop {
    //             end = self:.readIf (Tokens::SEMI_COLON, Tokens::RACC)._0;
    //             if (end.isEof) {
    //                 if (!last && content.len != 0us) {
    //                     if (self.needClosingExpr (content [$ - 1us])) {
    //                         let (n, _) = self:.readToken ();
    //                         throw copy ErrorMsg::fatal (n, format (SyntaxErrorMessage::UNEXPECTED_BUT_LST, n.str, Tokens::SEMI_COLON));
    //                     }
    //                 }
                    
    //                 if self._globalVisitor.isLocalDeclaration (self) {
    //                     let d = self._globalVisitor.readLocalDeclaration (alias self);
    //                     decls ~= [d];
    //                     last = true;
    //                 } else {
    //                     let e = self:.readExpression ();
    //                     content ~= [e];
    //                     last = false;
    //                 }                                                                                                
    //             } else if (end == Tokens::SEMI_COLON) {
    //                 last = true;
    //             } else break;
    //         }

    //         let (catcher, scopes) = if (canBeCatcher) {
    //             self:.readScopeGuards ()
    //         } else { (EMPTY_EXPR, []) }

    //         if (last) content ~= [copy EmptyExpression (loc-> end)];
    //         if (decls.len != 0us) {
    //             copy BlockExpr (loc, end, module-> copy BlockDecl (loc.locate (Keys::UNDER), "", decls), content, catcher-> catcher, guards-> scopes)
    //         } else {
    //             copy BlockExpr (loc, end, content, catcher-> catcher, guards-> scopes)
    //         }
    //     } catch {
    //         err : &ErrorMsg => {
    //             if (!loc.isEof) {
    //                 throw copy ErrorMsg::note (loc, SyntaxErrorMessage::IN_DECL_BLOCK, notes-> copy [err]);
    //             } else throw err;
    //         }
    //     }
    // }


    // /**
    //  * Read scope guards
    //  * @verbatim:
    //  * ==================
    //  * scope_guards :=   Keys::EXIT block
    //  *                 | Keys::SUCCESS block
    //  *                 | Keys::FAILURE block
    //  *                 | catcher
    //  * ==================
    //  */
    // fn readScopeGuards (mut self)-> (&Expression, [&ScopeGuardExpr])
    //     throws ErrorMsg
    // {
    //     let mut catcher : &Expression = EMPTY_EXPR;
    //     let mut scopes : [mut &ScopeGuardExpr] = [];
    //     let mut seen : [[c8] => mut &Word] = copy [];
    //     loop {
    //         let (n, _) = self:.readIf (Keys::EXIT, Keys::SUCCESS, Keys::FAILURE, Keys::CATCH);
    //         if (!n.isEof) {
    //             if let Ok (val) = seen [n.str] {
    //                 throw copy ErrorMsg::fatal (n, end-> val, format (SyntaxErrorMessage::MULTIPLE_SAME_GUARD, n.str));
    //             }

    //             seen [n.str] = n;
    //         }

    //         if (n == Keys::CATCH) {
    //             catcher = self:.readCatcher (n);
    //         } else if (!n.isEof) {
    //             let (a, _) = self:.readTokens (Tokens::LACC);
    //             scopes ~= [copy ScopeGuardExpr (n, self:.readBlock (a, canBeCatcher-> false), kind-> self.toScopeGuard (n.str))];
    //         } else break;
    //     }

    //     (catcher, scopes)
    // }

    // /*!
    //  * ================================================================================
    //  * ================================================================================
    //  * =========================          CONDITIONS          =========================
    //  * ================================================================================
    //  * ================================================================================
    //  */

    // /**
    //  * Read an If expression
    //  * @verbatim:
    //  * ======================
    //  * if_expr := Keys::IF expression:(0) ((expression:(0) (Tokens::SEMI_COLON)?) | (block)) (Keys::ELSE expression:(0))?
    //  * ======================
    //  */
    // fn readIfExpression (mut self, loc : &Word)-> &Expression
    //     throws ErrorMsg
    // {
    //     let (isLet, _) = self:.readIf (Keys::LET);
    //     let (test : &Expression, guard : &Expression) = if (isLet.isEof) {
    //         (self:.readExpression (), EMPTY_EXPR)
    //     } else {
    //         let vdecl = self:.readVarDeclaration (isLet, onlyOne-> true, level-> 3us);
    //         let guard = if (!self:.readIf (Tokens::DAND)._0.isEof) {
    //             self:.readExpression ()
    //         } else { EMPTY_EXPR };

    //         (vdecl, guard)
    //     };

    //     let mut content = self:.readExpression ();
    //     match content {
    //         BlockExpr () => {}
    //         _ => {
    //             let (tok, _) = self:.readIf (Tokens::SEMI_COLON);
    //             if (!tok.isEof) {
    //                 let mut inner = copy [content, EMPTY_EXPR];
    //                 content = copy BlockExpr (content.getLoc (), tok, content-> inner);
    //             }
    //         }
    //     }

    //     let (next, _) = self:.readIf (Keys::ELSE);
    //     if (!next.isEof) {
    //         let (n, _) = self:.readIf (Keys::IF);
    //         if (!n.isEof) return copy ConditionalExpr (loc, test, content, else_-> self:.readIfExpression (n), guard-> guard, isLet-> !isLet.isEof);
    //         else {
    //             let mut el_content = self:.readExpression ();
    //             match el_content {
    //                 BlockExpr () => {}
    //                 _ => {
    //                     let (tok, _) = self:.readIf (Tokens::SEMI_COLON);
    //                     if (!tok.isEof) {
    //                         let mut inner : [mut &Expression] = copy [el_content, EMPTY_EXPR];
    //                         el_content = copy BlockExpr (content.getLoc (), tok, content-> inner);
    //                     }
    //                 }
    //             }

    //             return copy ConditionalExpr (loc, test, content, else_-> el_content, isLet-> !isLet.isEof, guard-> guard);
    //         }
    //     }

    //     copy ConditionalExpr (loc, test, content, isLet-> !isLet.isEof, guard-> guard)
    // }


    // /**
    //  * Read an atomic
    //  * @verbatim:
    //  * ==============
    //  * atomic_expr := Keys::ATOMIC (expression:(0))? Tokens::LACC expression:(0) Tokens::RACC
    //  * ==============
    //  */
    // fn readAtomic (mut self, loc : &Word) -> &Expression
    //     throws ErrorMsg
    // {
    //     let (n, _) = self:.readIf (Tokens::LACC);
    //     if (!n.isEof) {
    //         let content = self:.readBlock (n);
    //         return copy AtomicExpr (loc, content, monitor-> EMPTY_EXPR);
    //     } else {
    //         let monitor = self:.readExpression ();
    //         let (tok, _) = self:.readTokens (Tokens::LACC);
    //         let content = self:.readBlock (tok, canBeCatcher-> false);
    //         return copy AtomicExpr (loc, content, monitor-> monitor);
    //     }
    // }

    // /**
    //  * Read an unsafe block
    //  * @verbatim:
    //  * ==========
    //  * unsafe_expr := Keys::UNSAFE Tokens::LACC expression:(0) Tokens::RACC
    //  * ==========
    //  * */
    // fn readUnsafe (mut self, loc : &Word)-> &Expression
    //     throws ErrorMsg
    // {
    //     let content = self:.readExpression ();
    //     return copy UnsafeExpr (loc, content);
    // }

    // /**
    //  * Read a pragma expr
    //  * @verbatim:
    //  * ===================
    //  * pragma_expr := Keys::PRAGMA Tokens::NOT Identifier (Tokens::LPAR param_list Tokens::RPAR)
    //  * ===================
    //  */
    // fn readPragma (mut self, _ : &Word)-> &Expression
    //     throws ErrorMsg
    // {
    //     self:.readIf (Tokens::NOT);
    //     let (ident, _) = self:.readIdentifier ();

    //     self:.readTokens (Tokens::LPAR);
    //     let (params, _) = self:.readArgumentList ();

    //     copy PragmaExpr (ident, params)
    // }

    // /**
    //  * Read a throw expression
    //  * @verbatim:
    //  * =======================
    //  * throw_expr := Keys::THROW expression:(0)
    //  * =======================
    //  */
    // fn readThrow (mut self, loc : &Word)-> &Expression
    //     throws ErrorMsg
    // {
    //     let expr = self:.readExpression ();
    //     copy ThrowExpr (loc, expr)
    // }

    // /**
    //  * Read a panic instruction
    //  * @verbatim:
    //  * =======================
    //  * panic := Keys::PANIC
    //  * =======================
    //  * */
    // fn readPanic (mut self, loc : &Word)-> &Expression {
    //     copy PanicExpr (loc)
    // }

    // /**
    //  * Read a version evaluation expression
    //  * @verbatim:
    //  * ```
    //  * version_lit := Keys::VERSION '(' Identifier ')'
    //  * ```
    //  * */
    // fn readVersion (mut self, loc : &Word)-> &Expression
    //     throws ErrorMsg
    // {
    //     self:.readTokens (Tokens::LPAR);
    //     let (version, _) = self:.readIdentifier ();
    //     self:.readTokens (Tokens::RPAR);
        
    //     copy VersionExpr (loc, version)
    // }

    // /**
    //  * Read a function type
    //  * @verbatim:
    //  * ====================
    //  * function_type := (Keys::FUNCTION | Keys::DG) function_type_prototype function_type_return_type
    //  * function_type_prototype := Tokens::LPAR (expression:(10) (Tokens::COMA expression:(10))*) Tokens::RPAR
    //  * function_type_return_type := (Tokens::ARROW expression:(10))?
    //  * ====================
    //  */
    // fn readFunctionType (mut self, loc : &Word)-> &Expression
    //     throws ErrorMsg
    // {
    //     self:.readTokens (Tokens::LPAR);
    //     let args = self:.readFptrParameters ();
    //     let (t, _) = self:.readIf (Tokens::ARROW);
    //     if (!t.isEof) {
    //         copy FunctionPtrTypeExpr (loc, args, self:.readExpression (level-> self._specials.binaryOperators.len))
    //     } else {
    //         copy FunctionPtrTypeExpr (loc, args, EMPTY_EXPR)
    //     }
    // }

    // /**
    //  * Read a future type
    //  * @verbatim
    //  * ============
    //  * future_type := Keys::FUTURE Tokens::ARROW operand:(3)
    //  * ============
    //  * */
    // fn readFutureType (mut self, loc : &Word)-> &Expression
    //     throws ErrorMsg
    // {
    //     self:.readTokens (Tokens::ARROW);
    //     let param = self:.readOperand3 ();

    //     copy FutureTypeExpr (loc, param)
    // }

    // /**
    //  * Read the parameters of a function pointer type
    //  * */
    // fn readFptrParameters (mut self)-> [&VarDeclExpr]
    //     throws ErrorMsg
    // {
    //     let x = self:.readIf (Tokens::RPAR)._0;
    //     if (!x.isEof) return [];

    //     let mut params : [mut &VarDeclExpr] = [];
    //     loop {
    //         let (isLazyOrRef, isMutOrDmut) = self:.readDecoratorVariable (canBeLazyOrRef-> true);

    //         let type = self:.readExpression (level-> self._specials.binaryOperators.len);
    //         let name = type.getLoc ().locate (Keys::UNDER);
    //         params ~= [copy VarDeclExpr (name, name,
    //                                      isLazyOrRef-> isLazyOrRef,
    //                                      isMutOrDmut-> isMutOrDmut,
    //                                      type-> type,
    //                                      value-> EMPTY_EXPR)];

    //         let (next, _) = self:.readTokens (Tokens::RPAR, Tokens::COMA);
    //         if (next == Tokens::RPAR) break;
    //     }

    //     params
    // }

    // /**
    //  * Read a return expression
    //  * @verbatim:
    //  * ========================
    //  * return_expr := Keys::RETURN ( expression:(0) | ';' )
    //  * ========================
    //  */
    // fn readReturn (mut self, loc : &Word)-> &Expression
    //     throws ErrorMsg
    // {
    //     let (semiCol, _) = self:.readIf (Tokens::SEMI_COLON);
    //     if (!semiCol.isEof) {
    //         copy ReturnExpr (loc, EMPTY_EXPR)
    //     } else {
    //         let expr = self:.readExpression ();
    //         copy ReturnExpr (loc, expr)
    //     }
    // }

    // /**
    //  * Read a var declaration
    //  * @verbatim:
    //  * ========================
    //  * var_decl :=   Keys::LET (single_var_decl Tokens::EQUAL value) (Tokens::COMA (single_var_decl Tokens::EQUAL value))*
    //  *             | Keys::LET pattern Tokens::EQUAL value
    //  * ========================
    //  */
    // fn readVarDeclaration (mut self, loc : &Word, onlyOne : bool = false, level : usize = 0us)-> &Expression
    //     throws ErrorMsg
    // {
    //     let begCursor = self.getSeek ();
    //     let mut succeed = false;
    //     let (tok, _) = self:.readIf (Tokens::LPAR, Tokens::LCRO);
    //     if (tok == Tokens::LPAR || tok == Tokens::LCRO) {
    //         let pattern = self:.readParMatch (tok, endTok-> if (tok == Tokens::LPAR) { Tokens::RPAR } else { Tokens::RCRO });
    //         self:.readTokens (Tokens::EQUAL);
    //         let value = self:.readExpression (level-> level);

    //         return copy PatternVarDeclExpr (loc, pattern, value);
    //     } else {
    //         {
    //             let mut decls : [mut &Expression] = [];
    //             loop {
    //                 decls ~= [self:.readSingleVarDeclaration (mandType-> false, isClass-> false, mandValue-> true, level-> level)];
    //                 succeed = true; // read at least one
    //                 if (!onlyOne) {
    //                     if ((self:.readIf (Tokens::COMA)._0).isEof) break;
    //                 } else break;
    //             }

    //             if (decls.len == 1) return decls [0];
    //             return copy SetExpr (loc, decls);
    //         } catch {
    //             err : &ErrorMsg => {
    //                 if (succeed) throw err; // pattern var decl cannot be grouped with other kind of declarations
    //                 {
    //                     self:.rewindToSeek (begCursor);
    //                     let pattern = self:.readMatchExpression ();

    //                     self:.readTokens (Tokens::EQUAL);
    //                     let value = self:.readExpression (level-> level);

    //                     return copy PatternVarDeclExpr (loc, pattern, value);
    //                 } catch {
    //                     subErr : &ErrorMsg => {
    //                         throw err.withNote (copy [copy ErrorMsg::note (loc, oneLine-> true, SyntaxErrorMessage::READING_PATTERN_DECLARATION, notes-> copy [subErr])]);
    //                     }
    //                 }
    //             }
    //         }
    //     }
    // }

    // /**
    //  * Read a for loop
    //  * @verbatim:
    //  * ===========================
    //  * for_loop := Keys::FOR ((Tokens::LPAR for_loop_decl Tokens::RPAR) | for_loop_decl) expression:(0)
    //  * for_loop_decl := (single_var_decl:(no_value) (Tokens::COMA single_var_decl:(no_value))* Keys::IN expression:(10)
    //  * ===========================
    //  */
    // fn readFor (mut self, loc : &Word)-> &Expression
    //     throws ErrorMsg
    // {
    //     let mut decls : [mut &Expression] = [];
    //     let (par, _) = self:.readIf (Tokens::LPAR);
    //     loop {
    //         decls ~= [self:.readSingleVarDeclaration (mandType-> false, withValue-> false)];
    //         let (n, _) = self:.readTokens (Tokens::COMA, Keys::IN);
    //         if (n == Keys::IN) break;
    //     }

    //     let iter = self:.readExpression ();
    //     if (!par.isEof) self:.readTokens (Tokens::RPAR);

    //     let mut content = self:.readExpression ();
    //     match content {
    //         BlockExpr () => {}
    //         _ => {
    //             let (n, _) = self:.readIf (Tokens::SEMI_COLON);
    //             if (!n.isEof) {
    //                 let inner = copy [content, EMPTY_EXPR];
    //                 content = copy BlockExpr (content.getLoc (), n, inner);
    //             }
    //         }
    //     }

    //     copy ForLoopExpr (loc, decls, iter, content)
    // }


    // /**
    //  * Read a do while loop
    //  * @verbatim:
    //  * =====================
    //  * =====================
    //  */
    // fn readDoWhile (mut self, loc : &Word) -> &Expression
    //     throws ErrorMsg
    // {
    //     let content = self:.readExpression ();
    //     self:.readTokens (Keys::WHILE);
    //     let test = self:.readExpression ();

    //     copy WhileLoopExpr (loc, test-> test, content, isDo-> true)
    // }

    // /**
    //  * Read a break expression
    //  * @verbatim:
    //  * =======================
    //  * break_expr := Keys::BREAK ( expression:(0) | ';' )
    //  * =======================
    //  */
    // fn readBreak (mut self, loc : &Word)-> &Expression
    //     throws ErrorMsg
    // {
    //     let (semiCol, _) = self:.readIf (Tokens::SEMI_COLON);
    //     if (!semiCol.isEof) {
    //         copy BreakExpr (loc, EMPTY_EXPR)
    //     } else {
    //         let expr = self:.readExpression ();
    //         copy BreakExpr (loc, expr)
    //     }
    // }


    // /**
    //  * Read an assert expression
    //  * @verbatim:
    //  * ==========================
    //  * assert_expr := Keys::ASSERT Tokens::LPAR expression:(0) (Tokens::COMA expression:(0))? Tokens::RPAR
    //  * ==========================
    //  */
    // fn readAssert (mut self, tok : &Word)-> &Expression
    //     throws ErrorMsg
    // {
    //     let _ = self:.readTokens (Tokens::LPAR);
    //     let test = self:.readExpression ();
    //     let (n, _) = self:.readTokens (Tokens::RPAR, Tokens::COMA);
    //     let msg = if (n == Tokens::COMA) {
    //         let exp = self:.readExpression ();
    //         self:.readTokens (Tokens::RPAR);
    //         exp
    //     } else {
    //         EMPTY_EXPR
    //     }
    //     self:.readTokens (Tokens::SEMI_COLON);
    //     self:.rewind ();

    //     copy AssertExpr (tok, test, msg)
    // }

    // /**
    //  * Read a loop expression
    //  * @verbatim:
    //  * =========================
    //  * loop_expr := Keys::LOOP expression:(0)
    //  * =========================
    //  */
    // fn readLoop (mut self, loc : &Word)-> &Expression
    //     throws ErrorMsg
    // {
    //     let mut content = self:.readExpression ();
    //     match content {
    //         BlockExpr () => {}
    //         _ => {
    //             let (n, _) = self:.readIf (Tokens::SEMI_COLON);
    //             if (!n.isEof) {
    //                 let inner = copy [content, EMPTY_EXPR];
    //                 content = copy BlockExpr (content.getLoc (), n, inner);
    //             }
    //         }
    //     }

    //     copy WhileLoopExpr (loc, content, isDo-> false)
    // }


    // /**
    //  * Read a while loop
    //  * @verbatim:
    //  * ===========================
    //  * while_expr := Keys::WHILE expression:(0) expression:(0)
    //  * ===========================
    //  */
    // fn readWhile (mut self, loc : &Word)-> &Expression
    //     throws ErrorMsg
    // {

    //     let (isLet, _) = self:.readIf (Keys::LET);
    //     let (test : &Expression, guard : &Expression) = if (isLet.isEof) {
    //         (self:.readExpression (), EMPTY_EXPR)
    //     } else {
    //         let vdecl = self:.readVarDeclaration (isLet, onlyOne-> true, level-> 3us);
    //         let guard = if (!self:.readIf (Tokens::DAND)._0.isEof) {
    //             self:.readExpression ()
    //         } else { EMPTY_EXPR };

    //         (vdecl, guard)
    //     };

    //     let mut content = self:.readExpression ();
    //     match content {
    //         BlockExpr () => {}
    //         _ => {
    //             let (n, _) = self:.readIf (Tokens::SEMI_COLON);
    //             if (!n.isEof) {
    //                 let inner = copy [content, EMPTY_EXPR];
    //                 content = copy BlockExpr (content.getLoc (), n, inner);
    //             }
    //         }
    //     }

    //     if (isLet.isEof) {
    //         copy WhileLoopExpr (loc, test-> test, content, isDo-> false)
    //     } else {
    //         let elseBr = copy BreakExpr (loc, EMPTY_EXPR);
    //         let innerCond = copy ConditionalExpr (loc, test, content, else_-> elseBr, isLet-> true, guard-> guard);
    //         copy WhileLoopExpr (loc, innerCond, isDo-> false)
    //     }
    // }

    // /**
    //  * Read a template call expr
    //  * @verbatim:
    //  * ===========================
    //  * template_call_expr := expression:(0) Tokens::NOT ((Tokens::LACC param_list Tokens::RACC) | operand:(3))
    //  * ===========================
    //  */
    // fn readTemplateCall (mut self, var : &Expression)-> &Expression
    //     throws ErrorMsg
    // {
    //     let (n, _) = self:.readIf (Tokens::NOT);
    //     if (!self._inTemplateCall && n == Tokens::NOT) {          
    //         let (n2, _) = self:.readIf (Tokens::LACC);
    //         let res = self._inTemplateCall;
    //         {
    //             if (!n2.isEof) {
    //                 self._inTemplateCall = false;
    //                 let (lst, _) = self:.readArgumentList (withNamed-> false, closing-> Tokens::RACC);
    //                 self._inTemplateCall = res;

    //                 return copy TemplateCallExpr (n, var, lst);
    //             } else {
    //                 self._inTemplateCall = true;
    //                 let lst = copy [self:.readOperand3 ()];
    //                 self._inTemplateCall = res;

    //                 return copy TemplateCallExpr (n, var, lst);
    //             }
    //         } catch {
    //             err : &ErrorMsg => {
    //                 self._inTemplateCall = res;
    //                 throw err;
    //             }
    //         }
    //     } else if (n == Tokens::NOT) {
    //         throw copy ErrorMsg::fatal (n, SyntaxErrorMessage::MISSING_TEMPLATE_ACC);
    //     }

    //     var
    // }

    // /**
    //  * Read a variable
    //  * @verbatim:
    //  * ===================
    //  * var := Identifier (template_call)?
    //  * ===================
    //  */
    // fn readVar (mut self, name : &Word, canBeTemplateCall : bool = true)-> &Expression
    //     throws ErrorMsg
    // {        
    //     if (canBeTemplateCall) {
    //         self:.readTemplateCall (copy VarExpr (name))
    //     } else {
    //         copy VarExpr (name)
    //     }
    // }

    // /**
    //  * Read a lambda expression
    //  * @verbatim:
    //  * ========================
    //  * lambda_expr := function_proto:(lambda) (Tokens::DARROW)? expression:(0)
    //  * ========================
    //  */
    // fn readLambda (mut self, loc : &Word)-> &Expression
    //     throws ErrorMsg
    // {
    //     self:.rewind ();
    //     let proto = self:.readFunctionPrototype (isClosure-> true, isClass-> false);
    //     self:.readIf (Tokens::DARROW);
    //     copy LambdaValueExpr (loc, proto, self:.readExpression ())
    // }


    // /**
    //  * Read a tuple expression
    //  * @verbatim:
    //  * ========================
    //  * param_expr := Tokens::LPAR (expression:(0) (Tokens::COMA | (Tokens::COMA expression:(0))*))? Tokens::RPAR
    //  * ========================
    //  */
    // fn readTuple (mut self, loc : &Word)-> &Expression
    //     throws ErrorMsg
    // {
    //     let mut end = self:.readIf (Tokens::RPAR)._0;
    //     if (end == Tokens::RPAR) { return copy ListExpr (loc, end, []); }

    //     let mut params : [mut &Expression] = copy [self:.readExpression ()];
    //     let (n, _) = self:.readTokens (Tokens::COMA, Tokens::RPAR, Keys::FOR);
    //     if (n == Keys::FOR) {
    //         let forLoc = n;
    //         let mut decls : [mut &Expression] = [];
    //         let (par, _) = self:.readIf (Tokens::LPAR);
    //         loop {
    //             decls ~= [self:.readSingleVarDeclaration (mandType-> false, withValue-> false)];
    //             let (n2, _) = self:.readTokens (Tokens::COMA, Keys::IN);
    //             if (n2 == Keys::IN) break;
    //         }

    //         let iter = self:.readExpression ();
    //         if (!par.isEof) self:.readTokens (Tokens::RPAR);
    //         self:.readTokens (Tokens::COMA);
    //         self:.readTokens (Tokens::RPAR);

    //         return copy SliceForAllocatorExpr (loc, forLoc, params [0], decls, iter, isTuple-> true);
    //     } else if (n == Tokens::COMA) {
    //         end = self:.readIf (Tokens::RPAR)._0;
    //         if (end.isEof) {
    //             loop {
    //                 params ~= [self:.readExpression ()];
    //                 end = self:.readTokens (Tokens::COMA, Tokens::RPAR)._0;
    //                 if (end == Tokens::RPAR) break;
    //             }

    //             return copy ListExpr (loc, end, params);
    //         } else {
    //             return copy ListExpr (loc, end, params);
    //         }
    //     }

    //     params [0]
    // }


    // /**
    //  * Read a template checker expr
    //  * @verbatim:
    //  * ============================
    //  * template_check := Keys::IS template_call template_param_list
    //  * ============================
    //  */
    // fn readTemplateChecker (mut self, loc : &Word)-> &Expression
    //     throws ErrorMsg
    // {
    //     let call = self:.readTemplateCall (copy VarExpr (loc));
    //     match call {
    //         t : &TemplateCallExpr => {
    //             let params = self:.readTemplateParameters (ifLoc-> EOF_WORD);
    //             copy TemplateCheckerExpr (loc, t.getRights (), params)
    //         }
    //         _ => {
    //             self:.readTokens (Tokens::NOT);
    //             EMPTY_EXPR
    //         }
    //     }
    // }

    // /**
    //  * Read a cast expression
    //  * @verbatim:
    //  * =======================
    //  * cast_expr := Keys::CAST Tokens::NOT ((Tokens::LACC expression:(0) Tokens::RACC) | (operand:(3)) (Tokens::LPAR expression:(0) Tokens::RPAR)
    //  * =======================
    //  */
    // fn readCast (mut self, loc : &Word)-> &Expression
    //     throws ErrorMsg
    // {
    //     self:.readTokens (Tokens::NOT);
    //     let type = if (!(self:.readIf (Tokens::LACC)._0).isEof) {
    //         let e = self:.readExpression ();
    //         self:.readTokens (Tokens::RACC);
    //         e
    //     } else {
    //         self:.readOperand3 ()
    //     }

    //     self:.readTokens (Tokens::LPAR);
    //     let inner = self:.readExpression ();
    //     self:.readTokens (Tokens::RPAR);

    //     copy CastExpr (loc, type, inner)
    // }


    // /*!
    //  * ================================================================================
    //  * ================================================================================
    //  * =========================           MATCHERS           =========================
    //  * ================================================================================
    //  * ================================================================================
    //  */

    // /**
    //  * Read a catcher expression
    //  * @verbatim:
    //  * =========================
    //  * =========================
    //  */
    // fn readCatcher (mut self, loc : &Word)-> &Expression
    //     throws ErrorMsg
    // {
    //     let mut matchers : [mut (&Expression, &Expression, &Expression)] = [];
    //     self:.readTokens (Tokens::LACC);
    //     loop {
    //         let e = self:.readMatchExpression ();
    //         let (cd, _) = self:.readTokens (Keys::IF, Tokens::DARROW);
    //         let condition = if (cd == Keys::IF) {
    //             let x = self:.readExpression (level-> 1us);
    //             self:.readTokens (Tokens::DARROW);
    //             x
    //         } else {
    //             EMPTY_EXPR
    //         };

    //         let mut a = self:.readExpression(level-> self._specials.binaryOperators.len);
    //         let (tok, _) = self:.readIf (Tokens::SEMI_COLON);
    //         if (!tok.isEof) {
    //             let inner = copy [a, EMPTY_EXPR];
    //             a = copy BlockExpr (a.getLoc (), tok, content-> inner);
    //         }

    //         matchers ~= [(e, condition, a)];
    //         if (!(self:.readIf (Tokens::RACC)._0).isEof) break;
    //     }

    //     copy MatcherExpr (loc, EMPTY_EXPR, matchers, isCatcher-> true)
    // }

    // /**
    //  * Read a match expression
    //  * @verbatim:
    //  * ========================
    //  * match_expr := Keys::MATCH expression:(0) Tokens::LACC (inner_matcher_expr Tokens::DARROW expression:(10))+ Tokens::RACC
    //  * ========================
    //  */
    // fn readMatch (mut self, loc : &Word)-> &Expression
    //     throws ErrorMsg
    // {
    //     let mut matchers : [mut (&Expression, &Expression, &Expression)] = [];
    //     let content = self:.readExpression ();
    //     self:.readTokens (Tokens::LACC);
    //     loop {
    //         let e = self:.readMatchExpression ();
    //         let (cd, _) = self:.readTokens (Keys::IF, Tokens::DARROW);
    //         let condition = if (cd == Keys::IF) {
    //             let x = self:.readExpression (level-> 1us);
    //             self:.readTokens (Tokens::DARROW);
    //             x
    //         } else {
    //             EMPTY_EXPR
    //         };

    //         let mut a = self:.readExpression(level-> self._specials.binaryOperators.len);
    //         let (tok, _) = self:.readIf (Tokens::SEMI_COLON);
    //         if (!tok.isEof) {
    //             let inner = copy [a, EMPTY_EXPR];
    //             a = copy BlockExpr (a.getLoc (), tok, content-> inner);
    //         }

    //         matchers ~= [(e, condition, a)];
    //         if (!(self:.readIf (Tokens::RACC)._0).isEof) break;
    //     }

    //     copy MatcherExpr (loc, content, matchers, isCatcher-> false)
    // }

    // /**
    //  * Read an matching expression
    //  * @verbatim:
    //  * ============================
    //  * inner_matcher_expr :=   single_var_decl_match
    //  *                       | calling_match
    //  *                       | par_match
    //  *                       | cro_match
    //  *                       | expression:(0)
    //  * ============================
    //  */
    // fn readMatchExpression (mut self)-> &Expression
    //     throws ErrorMsg
    // {
    //     let (n, _) = self:.readIf (Tokens::LPAR, Tokens::LCRO);
    //     if (n == Tokens::LPAR) {
    //         return self:.readParMatch (n, endTok-> Tokens::RPAR);
    //     } else if (n == Tokens::LCRO) {
    //         return self:.readParMatch (n, endTok-> Tokens::RCRO);
    //     } else {
    //         return self:.readSingleVarDeclarationForMatch ();
    //     }
    // }

    // /**
    //  * Read a single var declaration for a pattern matcher
    //  * @params:
    //  *   - empty: allows for var to have no type nor value
    //  * @verbatim:
    //  * ========================
    //  * single_var_decl_match := (Decorator)* (Identifier | Keys::UNDER) Tokens::COLON (Keys::UNDER | expression:(10))  (Tokens::EQUAL inner_matcher_expr)?
    //  * ========================
    //  */
    // fn readSingleVarDeclarationForMatch (mut self)-> &Expression
    //     throws ErrorMsg
    // {
    //     let (isLazyOrRef, isMutOrDmut) = self:.readDecoratorVariable (canBeLazyOrRef-> true);
    //     if (isLazyOrRef == Keys::LAZY) {
    //         throw copy ErrorMsg::fatal (isLazyOrRef, format (SyntaxErrorMessage::UNDEF_DECORATOR_IN_MATCH, isLazyOrRef.str));
    //     }

    //     let (ig, _) = self:.readIf (Keys::UNDER);
    //     let name = if (!ig.isEof) {
    //         ig
    //     } else if (!isLazyOrRef.isEof || !isMutOrDmut.isEof) {
    //         self:.readIdentifier ()._0
    //     } else {
    //         self:.readIfIdentifier ()._0
    //     };

    //     // No identifier means no mut/lazy ident, thus it is an expression
    //     if (name.isEof) return self:.readExpression (level-> 4us);

    //     // cannot use /self/
    //     else if (name == Keys::SELF) throw copy ErrorMsg::fatal (name, format (SyntaxErrorMessage::USED_AS_IDENTIFIER, name.str));

    //     // Option pattern-> /Ok (...), Err (...)/
    //     else if (name == OptionKeys::MATCH_SOME || name == OptionKeys::MATCH_NONE) {
    //         // dmut Ok (...) means nothing
    //         if (isLazyOrRef != EOF_WORD) throw copy ErrorMsg::fatal (isLazyOrRef, format (SyntaxErrorMessage::UNEXPECTED, isLazyOrRef));
    //         if (isMutOrDmut != EOF_WORD) throw copy ErrorMsg::fatal (isMutOrDmut, format (SyntaxErrorMessage::UNEXPECTED, isMutOrDmut));

    //         return self:.readOptionMatch (name);
    //     }

    //     let (tok, _) = self:.readIf (Tokens::COLON, Tokens::EQUAL, Tokens::LPAR, Tokens::NOT, Tokens::DCOLON);

    //     // Type pattern-> /(ident | _ | ident::ident... | ident!templates...) (...)/
    //     if (tok == Tokens::LPAR || tok == Tokens::NOT || tok == Tokens::DCOLON) {
    //         // dmut Type (fields...) means nothing, cannot dmut the type test

    //         if (isLazyOrRef != EOF_WORD) throw copy ErrorMsg::fatal (isLazyOrRef, format (SyntaxErrorMessage::UNEXPECTED, isLazyOrRef));
    //         if (isMutOrDmut != EOF_WORD) throw copy ErrorMsg::fatal (isMutOrDmut, format (SyntaxErrorMessage::UNEXPECTED, isMutOrDmut));

    //         self:.rewind ();
    //         return self:.readCallingMatch (name);
    //     }

    //     // var decl with a type -> /decos ident : Type = Value/
    //     else if (tok == Tokens::COLON) {
    //         let type = if ((self:.readIf (Keys::UNDER)._0).isEof) {
    //             self:.readExpression (level-> self._specials.binaryOperators.len)
    //         } else { EMPTY_EXPR }

    //         // With a value
    //         let value = if (!(self:.readIf (Tokens::EQUAL)._0).isEof) {
    //             self:.readMatchExpression ()
    //         } else { EMPTY_EXPR }

    //         return copy VarDeclExpr (name, name, isMutOrDmut-> isMutOrDmut, isLazyOrRef-> isLazyOrRef, value-> value, type-> type);
    //     }

    //     // var decl with a value but not type -> /decos ident = Value/
    //     else if (tok == Tokens::EQUAL) {
    //         return copy VarDeclExpr (name, name, isMutOrDmut-> isMutOrDmut, isLazyOrRef-> isLazyOrRef,
    //                                  value-> self:.readMatchExpression (),
    //                                  type-> EMPTY_EXPR);
    //     }

    //     // var decl with no type and no value, just an identifier (or even just /_/)
    //     else  {
    //         if (name != Keys::UNDER && isMutOrDmut.isEof && isLazyOrRef.isEof) {
    //             self:.rewind ();
    //             let content = self:.readExpression (level-> self._specials.binaryOperators.len);
    //             match content {
    //                 v : &VarExpr => {
    //                     return copy VarDeclExpr (v.getLoc (), v.getLoc (), isMutOrDmut-> isMutOrDmut, isLazyOrRef-> isLazyOrRef,
    //                                              value-> EMPTY_EXPR,
    //                                              type-> EMPTY_EXPR);
    //                 }
    //                 _ => return content;
    //             }
    //         } else {
    //             return copy VarDeclExpr (name, name, isMutOrDmut-> isMutOrDmut, isLazyOrRef-> isLazyOrRef,
    //                                      value-> EMPTY_EXPR,
    //                                      type-> EMPTY_EXPR);
    //         }
    //     }
    // }


    // /**
    //  * Read a calling match expression
    //  * @verbatim:
    //  * ===============================
    //  * calling_match :=   (Identifier | Keys::UNDER) (Tokens::DCOLON Identifier)* (template_call)? (Tokens::LPAR (ident Tokens::ARROW inner_matcher_expr (',' ident Tokens::ARROW inner_matcher_expr)*)? Tokens::RPAR)
    //  *                  | Keys::UNDER
    //  *                  | option_match
    //  *                  | expression:(0)
    //  * ===============================
    //  */
    // fn readCallingMatch (mut self, loc : &Word)-> &Expression
    //     throws ErrorMsg
    // {
    //     // a type can be a bit more complex than just an identifier
    //     // it can be a path to a type, and a template type
    //     // This pattern does not apply to slices, and tuple, their patterns are different
    //     let mut var : &Expression = copy VarExpr (loc);
    //     if (loc != Keys::UNDER) {
    //         loop {
    //             let (n, _) = self:.readIf(Tokens::NOT, Tokens::DCOLON);
    //             if (n == Tokens::NOT) {
    //                 self:.rewind ();
    //                 var = self:.readTemplateCall (var);
    //                 break;
    //             } else if (n == Tokens::DCOLON) {
    //                 var = copy BinaryExpr (n, var, copy VarExpr (self:.readIdentifier ()._0));
    //             } else break;
    //         }
    //     }

    //     let (start, _) = self:.readIf (Tokens::LPAR);

    //     // If read a (, then it is a call pattern
    //     // calling function, and compare the value should be done within a match guard
    //     if (!start.isEof) {
    //         let mut params : [mut &Expression] = [];
    //         let mut e = self:.readIf (Tokens::RPAR, Tokens::COMA)._0;
    //         while e != Tokens::RPAR {
    //             let (ident, _) = self:.readIdentifier ();
    //             self:.readTokens (Tokens::ARROW);

    //             params ~= [copy NamedExpr (ident, self:.readMatchExpression ())];
    //             e = self:.readTokens (Tokens::RPAR, Tokens::COMA)._0;
    //         }

    //         copy MultOperatorExpr (start, e, var, params)
    //     } else {
    //         // a variable that is not a var declaration, supposedly read /::/ or /!/
    //         if (loc == Keys::UNDER) { var }
    //         else {
    //             self:.rewindToSeek (loc);
    //             self:.readExpression ()
    //         }
    //     }
    // }

    // /**
    //  * Read an option match
    //  * @verbatim:
    //  * =========================
    //  * option_match := (OptionKeys::MATCH_SOME | OptionKeys::MATCH_NONE) Tokens::LPAR inner_matcher_expr Tokens::RPAR
    //  * =========================
    //  * */
    // fn readOptionMatch (mut self, loc : &Word)-> &Expression
    //     throws ErrorMsg
    // {
    //     self:.readTokens (Tokens::LPAR);
    //     let inner = if (self:.readIf (Tokens::RPAR)._0.isEof) { // some (inner) =>
    //         let inner = self:.readMatchExpression ();
    //         self:.readTokens (Tokens::RPAR);
    //         inner
    //     } else { // some () =>
    //         EMPTY_EXPR
    //     }

    //     copy OptionMatcherExpr (loc, inner)
    // }

    // /**
    //  * Read a list in match expression
    //  * @verbatim:
    //  * ===============================
    //  * par_match :=   Tokens::LPAR (inner_matcher_expr (Tokens::COMA inner_matcher_expr )* (Tokens::COMA inner_matcher_expr Tokens::TDOT))? Tokens::RPAR
    //  *              | Tokens::LPAR (inner_matcher_expr (Tokens::TDOT)? Tokens::COMA) Tokens::RPAR
    //  *              | Tokens::LCRO (inner_matcher_expr (Tokens::COMA inner_matcher_expr)*)? Tokens::RCRO
    //  * ===============================
    //  */
    // fn readParMatch (mut self, loc : &Word, endTok : [c8] = Tokens::RPAR)-> &Expression
    //     throws ErrorMsg
    // {
    //     let mut params : [mut &Expression] = [];
    //     let mut e = self:.readIf (endTok)._0;
    //     while e != endTok {
    //         params ~= [self:.readMatchExpression ()];

    //         e = self:.readTokens (Tokens::COMA, endTok, Tokens::TDOT)._0;
    //         if (e == Tokens::TDOT) {
    //             if (endTok == Tokens::RPAR && params.len == 1us) {
    //                 self:.readTokens (Tokens::COMA);
    //             }
    //             e = self:.readTokens (endTok)._0;
    //             return copy ListMatcherExpr (loc, e, params, true);
    //         }

    //         if (params.len == 1us) {
    //             if (e == Tokens::COMA && endTok == Tokens::RPAR && !self:.readIf (Tokens::RPAR)._0.isEof) { // (x,) is a tuple
    //                 return copy ListMatcherExpr (loc, e, params, false);
    //             }
    //         }
    //     }

    //     // (x) is not a tuple, just x, but () is a tuple
    //     if (endTok == Tokens::RPAR && params.len == 1us) return params [0];
    //     copy ListMatcherExpr (loc, e, params, false)
    // }


    // /*!
    //  * ================================================================================
    //  * ================================================================================
    //  * =========================           LITERALS           =========================
    //  * ================================================================================
    //  * ================================================================================
    //  */


    // /**
    //  * Read a literal
    //  * @verbatim:
    //  * ================
    //  * literal :=   Numeric
    //  *            | Float
    //  *            | Char
    //  *            | String
    //  *            | (Keys::TRUE | Keys::FALSE)
    //  *            | Keys::NULL
    //  *            | Tokens::DOLLAR
    //  * ================
    //  */
    // pub fn readLiteral (mut self, token : &Word)-> &Expression
    //     throws ErrorMsg
    // {                        
    //     if let str: &StringWord = token { // String literal            
    //         match str.open {
    //             Tokens::SQUOTE => {
    //                 return copy CharExpr (str.open, str.close, str.str, suffix-> str.suffix);                    
    //             }
    //             Tokens::DQUOTE | Tokens::TRIPLE_DQUOTE => {
    //                 return copy StringExpr (str.open, str.close, str.str, suffix-> str.suffix);                    
    //             }
    //         }
            
    //         throw copy ErrorMsg::fatal (str.open, format (SyntaxErrorMessage::UNEXPECTED, str.open.str));
    //     }

    //     if let num: &NumericWord = token {
    //         return copy FixedExpr (num, suffix-> num.suffix);
    //     }

    //     if let fl: &FloatWord = token {
    //         throw copy ErrorMsg::fatal (fl, "");
    //     }
        
    //     match token {
    //         Keys::TRUE | Keys::FALSE => {
    //             return copy BoolExpr (token);    
    //         }
    //         Keys::NULL => {
    //             return copy NullExpr (token);    
    //         }
    //         Keys::NONE => {
    //             return copy NoneExpr (token);    
    //         }
    //         Tokens::DOLLAR => {
    //             return copy DollarExpr (token);    
    //         }
    //         Tokens::DDOT => { // ..i32 is a range type
    //             let type = self:.readOperand3 ();
    //             return copy RangeTypeExpr (token, type);
    //         }
    //     }
        
    //     throw copy ErrorMsg::fatal (token, format (SyntaxErrorMessage::UNEXPECTED, token.str));            
    // }

    // /**
    //  * Read an array literal
    //  * @verbatim:
    //  * =================
    //  * array_lit := Tokens::LCRO (expression:(0) (Tokens::COMA expression:(0))*)? Tokens::RCRO
    //  *              | Tokens::AND_LCRO (expression:(0) (Tokens::COMA expression:(0))*)? Tokens::RCRO
    //  * =================
    //  */
    // fn readArray (mut self, loc : &Word)-> &Expression
    //     throws ErrorMsg
    // {
    //     let (n, _) = self:.readIf (Tokens::RCRO);
    //     if (!n.isEof) return copy ListExpr (loc, n, [], isArray-> true);

    //     let mut params : [mut &Expression] = copy [self:.readExpression ()];
    //     let (e, _) = self:.readIf (Tokens::SEMI_COLON, Tokens::RCRO, Tokens::COMA, Keys::FOR, Tokens::DARROW);

    //     if (e == Tokens::SEMI_COLON) { // allocation
    //         let size = self:.readExpression ();
    //         self:.readTokens (Tokens::RCRO);
    //         return copy SliceAllocatorExpr (loc, params [0], size);
    //     }

    //     if (e == Keys::FOR) {
    //         let forLoc = e;
    //         let mut decls : [mut &Expression] = [];
    //         let (par, _) = self:.readIf (Tokens::LPAR);
    //         loop {
    //             decls ~= [self:.readSingleVarDeclaration (mandType-> false, withValue-> false)];
    //             let (n2, _) = self:.readTokens (Tokens::COMA, Keys::IN);
    //             if (n2 == Keys::IN) break;
    //         }

    //         let iter = self:.readExpression ();
    //         if (!par.isEof) self:.readTokens (Tokens::RPAR);
    //         self:.readTokens (Tokens::RCRO);

    //         return copy SliceForAllocatorExpr (loc, forLoc, params [0], decls, iter, isTuple-> false);
    //     }

    //     if (e == Tokens::DARROW) { // map [a => ...
    //         return self:.readListMap (loc, params [0]);
    //     }

    //     let mut end = e;
    //     if (e != Tokens::RCRO) {
    //         loop {
    //             params ~= [self:.readExpression ()];
    //             end = self:.readTokens (Tokens::RCRO, Tokens::COMA)._0;
    //             if (end == Tokens::RCRO) {
    //                 break;
    //             }
    //         }
    //     }

    //     copy ListExpr (loc, end, params, isArray-> true)
    // }

    // /**
    //  * Read a map literal
    //  * @verbatim:
    //  * ===============
    //  * listmap_lit := Tokens::LCRO  map_element (Tokens::COMA map_element)* Tokens::RCRO
    //  * map_element := expression:(10) Tokens::ARROW expression:(10)
    //  * ===============
    //  * */
    // fn readListMap (mut self, loc : &Word, fstKey : &Expression)-> &Expression
    //     throws ErrorMsg
    // {
    //     let mut keys : [mut &Expression] = copy [fstKey];
    //     let mut values : [mut &Expression] = copy [self:.readExpression ()];
    //     let mut end : &Word = EOF_WORD;
    //     loop {
    //         end = self:.readTokens (Tokens::RCRO, Tokens::COMA)._0;
    //         if (end == Tokens::RCRO) break;

    //         keys ~= [self:.readExpression ()];
    //         self:.readTokens (Tokens::DARROW);
    //         values ~= [self:.readExpression ()];
    //     }

    //     copy ListMapExpr (loc, end-> end, keys, values)
    // }
    
    /**
     * Read an identifier from the lexer
     * @throws:
     *    - ErrorMsg: if the next token is not a valid identifier 
     */
    pub fn readIdentifier (mut self)-> (&Word, [c8])
        throws ErrorMsg
    {        
        let (ident, comm) = self:.readToken ();
        if !ident.isName {
            throw copy ErrorMsg::fatal (ident, format (SyntaxErrorMessage::UNEXPECTED, ident.str));
        }

        (ident, comm)
    }

    /**
     * Read an identifier if there is an identifier to read
     * @returns: the identifier (and associated comment), or (EOF_WORD, "") if no identifier can be read
     */
    pub fn readIfIdentifier (mut self)-> (&Word, [c8]) {
        let ident = self.peekToken ();
        if !ident.isName {
            return (EOF_WORD, "");
        }
                
        return self:.readToken ();
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =================================          CONTEXT SWITCH          =================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Set the location of the current '!' calling templates values (EOF otherwise)
     *
     * @params:
     *    - loc: the location of the '!' operator
     *  
     * */
    pub fn setInTemplate (mut self, loc: &Word) {
        self._inTemplateCall = loc;
    }

    /**
     * @returns: the location of the current '!' calling template values, if any (EOF otherwise)
     * */
    pub fn isInNoAccTemplate (self)-> &Word {
        self._inTemplateCall
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ================================          READING HELPERS          =================================
     * ====================================================================================================
     * ====================================================================================================
     */
    
    /**
     * @returns: the next token inside the lexer, if it is equals to one of the token inside lst
     * @info: if none of lst token is found, the lexer is not incremented
     * @params:
     *    - lst: a list of tokens
     */
    pub fn readIf {R...} (mut self, f : [c8], l : R)-> (&Word, [c8]) {                
        let x = self._lex.peek ();        
        if (x.isEof) return (EOF_WORD, "");

        if x == f {
            return self._lex:.next ();
        }
        
        
        cte if (R,)::arity > 1 {
            cte for i in l if x.str == i {
                return self._lex:.next ();    
            } 
        } else {
            if x == l {
                return self._lex:.next ();
            }
        }
        
        return (EOF_WORD, "");
    }
    
    /**
     * @returns: the next token inside the lexer, if it is equals to one of the token inside lst
     * @info: if none of lst token is found, the lexer is not incremented
     * @params:
     *    - lst: a list of tokens
     */
    pub fn readIf (mut self, lst : [[c8]])-> (&Word, [c8]) {
        let x = self._lex.peek ();
        if (x.isEof) return (EOF_WORD, "");

        for i in lst {
            if i == x.str {
                return self._lex:.next ();
            }
        }

        return (EOF_WORD, "");
    }

    /**
     * @returns: the next token inside the lexer, if it is equals to one of the token inside lst
     * @info: if none of lst token is found, the lexer is not incremented
     * @params:
     *    - lst: a token
     */
    pub fn readIf (mut self, lst : [c8])-> (&Word, [c8]) {
        let x = self._lex.peek ();
        if (x.str == lst) return self._lex:.next ();

        return (EOF_WORD, "");
    }

    /**
     * @returns: the next token inside the lexer
     * */
    pub fn readToken (mut self)-> (&Word, [c8]) {
        self._lex:.next ()
    }

    /**
     * Read a string token, starting with `open` or `lst`
     * */
    pub fn readStringTokens {R...} (mut self, start : [c8], l : R)-> (&StringWord, [c8])
        throws ErrorMsg
    {
        let (x, y) = self._lex:.next ();
        if let str : &StringWord = x {                         
            if str.open == start {                                
                return (str, y);
            }
                    
            cte if (R,)::arity > 1 {
                cte for i in l if str.open == i {
                    return (str, y);            
                }
                
            } else {
                if str.open == l {
                    return (str, y);
                }                        
            }    
        }

        throw copy ErrorMsg::fatal (x, format (SyntaxErrorMessage::UNEXPECTED, x.str));        
    }

    /**
     * Read a string token, starting with `open`
     * */
    pub fn readStringTokens (mut self, start : [c8], suffix : bool = true)-> (&StringWord, [c8])
        throws ErrorMsg
    {
        let (x, y) = self._lex:.next ();
        if let str : &StringWord = x {
            if !suffix && !str.suffix.isEof {
                throw copy ErrorMsg::fatal (str.suffix, format (SyntaxErrorMessage::UNEXPECTED, str.suffix.str));                
            }
            
            if str.open == start {
                return (str, y);
            }                    
        }

        throw copy ErrorMsg::fatal (x, format (SyntaxErrorMessage::UNEXPECTED, x.str));        
    }
    
    /**
     * @returns: the next token inside the lexer without moving the cursor
     * */
    pub fn peekToken (self)-> &Word {
        self._lex.peek ()
    }

    /**
     * @returns: the next token in the lexer without making the cursor progress
     * */
    pub fn isEof (self)-> bool {
        self._lex.isEof
    }

    /**
     * @returns: the next token inside the lexer, if it is equals to one of the token inside lst
     * @throws:
     *   - ErrorMsg: if none of the token in lst is equal to the token that have been read, or the next token is eof
     * @params:
     *    - lst: a list of tokens
     */
    pub fn readTokens {R...} (mut self, f : [c8], l : R)-> (&Word, [c8])
        throws ErrorMsg
    {                        
        let (x, y) = self._lex:.next ();
        if x == f {
            return (x, y);
        }

        cte if (R,)::arity > 1 {
            cte for i in l if x.str == i {
                return (x, y);            
            }
            
            throw copy ErrorMsg::fatal (x, format (SyntaxErrorMessage::UNEXPECTED_BUT_LST, x.str, copy [f, expand l]));
        } else {
            if x.str == l {
                return (x, y);
            }
            
            throw copy ErrorMsg::fatal (x, format (SyntaxErrorMessage::UNEXPECTED_BUT_LST, x.str, copy [f, l]));
        }                                 
    }
    
    /**
     * @returns: the next token inside the lexer, if it is equals to one of the token inside lst
     * @throws:
     *   - ErrorMsg: if none of the token in lst is equal to the token that have been read, or the next token is eof
     * @params:
     *    - lst: a list of tokens
     */
    pub fn readTokens (mut self, lst : [[c8]])-> (&Word, [c8])
        throws ErrorMsg
    {
        let (x, y) = self._lex:.next ();
        for i in lst {
            if i == x.str {
                return (x, y);
            }
        }

        throw copy ErrorMsg::fatal (x, format (SyntaxErrorMessage::UNEXPECTED_BUT_LST, x.str, lst));
    }

    /**
     * @returns: the next token inside the lexer, if it is equals to one of the token inside lst
     * @throws:
     *   - ErrorMsg: if none of the token in lst is equal to the token that have been read, or the next token is eof
     * @params:
     *    - lst: a token
     */
    pub fn readTokens (mut self, lst : [c8])-> (&Word, [c8])
        throws ErrorMsg
    {
        let (x, y) = self._lex:.next ();
        if (x.str == lst) return (x, y);

        throw copy ErrorMsg::fatal (x, format (SyntaxErrorMessage::UNEXPECTED_BUT_LST, x.str, lst));
    }

    /**
     * @returns: the cursor of the lexer
     * */
    pub fn getSeek (self)-> usize {
        self._lex.getSeek ()
    }
    
    /**
     * @returns: the next token inside the lexer
     * */
    pub fn rewind (mut self) {
        self._lex:.rewind ()
    }

    /**
     * Rewind to the cursor of a word, right before the word
     * thus self:.readToken () might return the word after that if this is a token
     * */
    pub fn rewindToSeek (mut self, loc : &Word) {
        self._lex:.rewindToSeek (loc.seek)
    }

    /**
     * Rewind the cursor to seek     
     * */
    pub fn rewindToSeek (mut self, seek : usize) {
        self._lex:.rewindToSeek (seek)
    }
    
    /*!
     * ================================================================================
     * ================================================================================
     * =========================            TESTS             =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * @returns: true, if this expression needs at the end, a semi colon to be separated from other expressions
     */
    fn needClosingExpr (self, expr : &Expression)-> bool {
        match expr {
            a : &AtomicExpr => { self.needClosingExpr (a.getValue ()) }
            BlockExpr () => { false }
            b : &BreakExpr => { self.needClosingExpr (b.getValue ()) }
            ConditionalExpr () => { false }
            EmptyExpression () => { false }
            ForLoopExpr () => { false }
            MatcherExpr () => { false }
            r : &ReturnExpr =>  { self.needClosingExpr (r.getValue ()) }
            ScopeGuardExpr () => { false }
            t : &ThrowExpr => { self.needClosingExpr (t.getValue ()) }
            l : &WhileLoopExpr => { l.isDo () }
            UnsafeExpr () => { false }
            s : &SetExpr => {
                if (s.getContent ().len != 0us) {
                    self.needClosingExpr (s.getContent ()[$ - 1us])
                } else { false }
            }
            v : &VarDeclExpr => {
                match v.getValue () {
                    EmptyExpression () => { true }

                    _ => {
                        self.needClosingExpr (v.getValue ())
                    }
                }
            }
            v : &PatternVarDeclExpr => {
                match v.getValue () {
                    EmptyExpression () => { true }
                    _ => {
                        self.needClosingExpr (v.getValue ())
                    }
                }
            }
            i : &IntrinsicExpr => {
                if (i.getType () == IntrinsicKeys::CTE) {
                    self.needClosingExpr (i.getContent ())
                } else { true }
            }
            _ => { true }
        }
    }

    
    /*!
     * ================================================================================
     * ================================================================================
     * =========================             CONV             =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Transform a word into a protection
     * @info: if the word does not contain a protection, by default Protection::PRIVATE is returned
     */
    pub fn toProtection (self, msg : [c8])-> Protection {
        match msg {
            Keys::PUBLIC => { Protection::PUBLIC }
            Keys::PRIVATE => { Protection::PRIVATE }
            Keys::PROTECTED => { Protection::PROTECTED }
            _ => {
                panic;
            }
        }
    }

    /**
     * Transform a word into a template var type
     * @info: if the word does not contain a template var type, by default TemplateVarType::TUPLE is returned
     */
    fn toTemplateVarType (self, msg : [c8])-> TemplateVarType {
        for i in TemplateVarType::__members__ {
            if i == msg {
                return i;
            }
        }

        panic;
    }

    /**
     * Transform a word into a template of var type
     * @info: if the word does not contain a template var type, by default TemplateOfVarType::IMPL is returned
     */
    fn toTemplateOfVarType (self, msg : [c8])-> TemplateOfVarType {
        for i in TemplateOfVarType::__members__ {
            if i == msg {
                return i;
            }
        }

        panic;
    }

    /**
     * Transform a word into an scope guard key
     * @info: if the word does not contain a scope guard name, by default ScopeGuardType::EXIT is returned
     */
    fn toScopeGuard (self, msg : [c8])-> ScopeGuardType {
        for i in ScopeGuardType::__members__ {
            if i == msg {
                return i;
            }
        }

        panic;
    }

    /**
     * Transform a word into an intrinsic key
     * @info: if the word does not contain a intrinsic name, by default IntrinsicKeys::DCOPY is returned
     */
    fn toMemoryKey (self, msg : [c8])-> MemoryKeys {
        for i in MemoryKeys::__members__ {
            if i == msg {
                return i;
            }
        }

        panic;
    }


}
