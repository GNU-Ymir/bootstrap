mod ymirc::syntax::visitor;


import ymirc::errors::_;
import ymirc::syntax::expression::_;
import ymirc::syntax::declaration::_;
import ymirc::syntax::_;
import ymirc::lexing::_;
import ymirc::utils::_;
import ymirc::global::state;

import std::fs, std::fs::_;
import std::collection::set;
import std::collection::vec;
import std::io;


/**
 * The syntax visitor class is the class used to transform a text content into an analyzable syntax tree
 * The syntax visitor will validated the content of the source code, but only at a syntaxic level
 */
pub class SyntaxVisitor {

    /// The lexer that is used to cut the content string in tokens
    let dmut _lex : &Lexer;

    /// The list of forbidden keys (for identifiers)
    let dmut _forbiddenKeys = HashSet!{[c8]}::new ();

    /**
     * Create a new visitor for a given file
     * @params: 
     *  - path: the path of the file to read
     */
    pub self open (path : &Path)
        with _lex = Lexer::new (path.toStr (), content-> {
            with dmut f = File::open (path) {
                f:.readAll ()
            }
        }, tokens-> Tokens::__members__, comments-> CommentTokens::__members__, skips-> SkipTokens::__members__)
        throws &FsError
    {
        for i in Tokens::members {
            self._forbiddenKeys:.insert (i);
        }

        for i in ForbiddenKeys::members {
            self._forbiddenKeys:.insert (i);            
        }
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================            MODULE            =========================
     * ================================================================================
     * ================================================================================
     */


    /**
     * Once the visitor is initialized, (with open for instance) 
     * the content can be read an transformed into a syntax tree
     * @example: 
     * =================
     * let dmut visitor = Visitor::open (Path::new ("foo.yr"));
     * { 
     *    // verify the grammar of the content of the file
     *    // And return it into a syntax tre
     *    let module = visitor:.read (); 
     *    println (format ("%"s8, module)); // pretty print the module that has been read
     * } catch {
     *    err : &ErrorMsg => {
     *          println (format ("%"s8, err)); // print the error that occured inside the file
     *    }
     * }
     * =================
     */
    pub def read (mut self)-> &Module
        throws &ErrorMsg
    {
        let (loc, path, comm) = self:.readGlobalPath ();
        Module::new (loc, path, comm, self:.readDeclBlock (loc, comm), isGlobal-> true)
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================      DECLARATION BLOCKS      =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Read the first declaration line of the module (if any), and return the declared path
     * @returns: 
     *    - the path, or Unit if nothing was found was found
     *    - the comments above the path
     */
     def readGlobalPath (mut self) -> (&Word, &Expression, [c8])
        throws &ErrorMsg
    {
        let beginPos = self._lex.getCounter ();
        
        let (next, comm) = self:.readIf ([Keys::MOD]);
        if (next.isEof ()) return (next, cast!(&Expression) (const Unit::new ()), ""s8);

        let path = self:.readPath ();
        if (!(self:.readIf ([Tokens::SEMI_COLON])._0).isEof ()) {
            (next, path, comm)
        } else {
            self._lex:.rewind (nb-> self._lex.getCounter () - beginPos);
            (next, cast!(&Expression) (const Unit::new ()), ""s8)
        }
    }

    /**
     * Read a set of declaration in a global module (or in a global sub symbol, such as local module, protection block, etc.)
     * @verbatim: 
     * ===================
     * decl_block := declaration | protection_block | version_block
     * ===================
     * @params: 
     *     - close: if false, then the reading stops when the token eof () is found
     *              , otherwise it stops when the token Tokens::RACC is found
     */
    def readDeclBlock (mut self, loc : &Word, comm : [c8], closing : bool = false, protection : Protection = Protection::PRIVATE) -> &DeclBlock
        throws &ErrorMsg    
    {        
        let dmut decls = Vec!(&Declaration)::new ();
        loop {
            let beginCur = self._lex.getCounter ();
            let (tok, comm_) = self._lex:.next ();
            if (closing && tok.str () == Tokens::RACC) break {}
            if (!tok.isEof ()) self._lex:.rewind (nb-> self._lex.getCounter () - beginCur);
            
            match tok.str () {
                Keys::PUBLIC => 
                    decls:.push (self:.readProtectionBlock ());
                Keys::PRIVATE =>
                    decls:.push (self:.readProtectionBlock ());
                Keys::VERSION =>
                    decls:.push (self:.readVersionBlock (protection-> protection));
                Tokens::LACC => {
                    self._lex:.next ();
                    decls:.push (self:.readDeclBlock (tok, comm_, closing-> true, protection-> protection));
                }
                _ => {
                    if !tok.isEof () {
                        decls:.push (self:.readDeclaration ());
                    } else if (!closing) break {}
                    else throw ErrorMsg::fatal (tok, SyntaxErrorMessage::BLOCK_NEVER_CLOSED);
                }
            }            
        }
        
        DeclBlock::new (loc, comm, decls [], protection-> protection)
    }

    /**
     * Read a protection block
     * @verbatim: 
     * ===============
     * protection_block :=   (Keys::PRIVATE | Keys::PUBLIC) Tokens::LACC decl_block Tokens::RACC
     *                     | (Keys::PRIVATE | Keys::PUBLIC) declaration
     * ===============
     */
    def readProtectionBlock (mut self) -> &DeclBlock
        throws &ErrorMsg
    {
        let (loc, comm) = self._lex:.next ();
        {
            let protection = if (loc.str () == Keys::PRIVATE) { Protection::PRIVATE } else { Protection::PUBLIC };
            let (tok, _) = self:.readIf ([Tokens::LACC]);
            if (tok.isEof ()) {
                DeclBlock::new (loc, comm, [self:.readDeclaration ()], protection-> protection)
            } else {
                self:.readDeclBlock (loc, comm, closing-> true, protection-> protection)
            }
        } catch {
            err : &ErrorMsg => {
                throw err.appendNotes ([ErrorMsg::note (loc, SyntaxErrorMessage::IN_DECL_BLOCK)]);
            }
        }
    }


    /**
     * Visit a version block
     * @verbatim: 
     * ================
     * version_block := Keys::VERSION Tokens::LACC decl_block Tokens::RACC (else Tokens::LACC decl_block Tokens::RACC)?
     * ================
     */
    def readVersionBlock (mut self, protection : Protection = Protection::PRIVATE)-> &DeclBlock
        throws &ErrorMsg
    {
        let (loc, comm) = self._lex:.next ();
        {
            let (v, _) = self:.readIdentifier ();
            return if state::instance ().isVersionActive (v.str ()) {
                self:.readTokens ([Tokens::LACC]);
                let block = self:.readDeclBlock (loc, comm, closing-> true, protection-> protection);
                if (!(self:.readIf ([Keys::ELSE])._0).isEof ())
                    self:.ignoreBlock ();
                block
            } else {
                self:.ignoreBlock ();
                if (!(self:.readIf ([Keys::ELSE])._0).isEof ()) {
                    self:.readTokens ([Tokens::LACC]);
                    self:.readDeclBlock (loc, comm, closing-> true, protection-> protection)
                } else {
                    DeclBlock::new (loc, comm, [])
                }
            } ;       
        } catch {
            err : &ErrorMsg => {
                throw err.appendNotes ([ErrorMsg::note (loc, SyntaxErrorMessage::IN_DECL_BLOCK)]);
            }
        }
    }

    /**
     * Ignore a block of element (no matters what is inside)
     * Basically, it can be used to consider the next block of code as a comment 
     * A block is enclosed by Tokens::LACC and Tokens::RACC
     */
    def ignoreBlock (mut self)
        throws &ErrorMsg
    {
        let _ = self:.readTokens ([Tokens::LACC]);
        let mut nb = 1u64;
        loop {
            let (next, _) = self._lex:.next ();
            if (next == Tokens::RACC) {
                nb -= 1u64;
                if (nb == 0u64) 
                    break {}                
            } else if (next == Tokens::LACC) nb += 1u64;
            else if (next.isEof ())
            throw ErrorMsg::fatal (next, SyntaxErrorMessage::UNTERMINATED_BLOCK);
        }
    }
    /**
     * Read a declaration
     * @verbatim:
     * ==================
     * decl :=   aka_decl
     *         | class_decl
     *         | enum_decl
     *         | func_decl
     *         | static_decl
     *         | import_decl
     *         | extern_decl
     *         | macro_decl
     *         | mod_decl
     *         | struct_decl
     *         | trait_decl
     * ==================
     */
    def readDeclaration (mut self)-> &Declaration
        throws &ErrorMsg
    {
        let (tok, comm) = self._lex:.next ();
        match tok.str () {
            Keys::AKA    => { return self:.readAka (tok, comm); }
            Keys::CLASS  => { return self:.readClass (tok, comm); }
            Keys::ENUM   => { return self:.readEnum (tok, comm); }
            Keys::DEF    => { return self:.readFunction (tok, comm); }
            Keys::STATIC => { return self:.readGlobal (tok, comm); }
            Keys::IMPORT => { return self:.readImport (tok, comm); }
            Keys::EXTERN => { return self:.readExtern (tok, comm); }
            Keys::MACRO  => { return self:.readMacro (tok, comm); }
            Keys::MOD    => { return self:.readLocalModule (tok, comm); }
            Keys::STRUCT => { return self:.readStruct (tok, comm); }
            Keys::TRAIT  => { return self:.readTrait (tok, comm); }
            _ => {
                throw ErrorMsg::fatal (tok, format (SyntaxErrorMessage::UNEXPECTED_BUT_LST, tok.str (),
                                                    [Keys::AKA, Keys::CLASS, Keys::ENUM, Keys::STATIC,
                                                     Keys::IMPORT, Keys::EXTERN, Keys::MACRO, Keys::MOD,
                                                     Keys::STRUCT, Keys::TRAIT])
                                      );
            }
        }
    }


    /**
     * ================================================================================
     * ================================================================================
     * =========================             AKA              =========================
     * ================================================================================
     * ================================================================================
     */
    
    /**
     * Read an aka declaration
     * @verbatim: 
     * ===============
     * aka_decl :=   Keys::AKA Keys::IF expression:(0) Identifier template_param_list Tokens::EQUAL expression:(0)
     *             | Keys::AKA Identifier (template_param_list)? Tokens::EQUAL expression:(0)
     * ===============
     */
    def readAka (mut self, _ : &Word, comm : [c8])-> &Declaration
        throws &ErrorMsg
    {
        let (hasTest, test) = self:.readTemplateTest ();        
        let (ident, _) = self:.readIdentifier ();
        let templates = self:.readTemplateParameters (ifLoc-> hasTest)
        
        self:.readTokens ([Tokens::EQUAL]);
        let value = self:.readExpression ();
        self:.readIf ([Tokens::SEMI_COLON]);

        if (templates.len == 0us) {
            Aka::new (ident, comm, value)            
        } else {
            Template::new (ident, comm, templates, Aka::new (ident, comm, value), test-> test)            
        }
    }


    /**
     * ================================================================================
     * ================================================================================
     * =========================            CLASS             =========================
     * ================================================================================
     * ================================================================================
     */
    
    /**
     * Read a class declaration
     * @verbatim: 
     * ===============
     * class_decl :=   Keys::CLASS Keys::IF expression:(0) (attribute_list)? Identifier template_param_list (Keys::OVER expression:(0))? class_block_decl
     *               | Keys::CLASS (attributes_list)? Identifier (template_param_list)? (Keys::OVER expression:(0))? class_block_decl
     * ===============
     */
    def readClass (mut self,  _ : &Word, comm : [c8])-> &Declaration
        throws &ErrorMsg
    {
        let (hasTest, test) = self:.readTemplateTest ();
        let attribs = self:.readAttributes ();
        let (ident, _) = self:.readIdentifier ();
        let templates = self:.readTemplateParameters (ifLoc-> hasTest)

        let ancestor =
            if (self:.readIf ([Keys::OVER])._0).isEof () {
                Unit::new ()
            } else {
                self:.readExpression ()
            };

        let (open, _) = self:.readTokens ([Tokens::LACC]);
        let decls = {
            self:.readClassDeclBlock (closing-> true)
        } catch {
            err : &ErrorMsg => {
                throw err.appendNotes ([ErrorMsg::note (open, SyntaxErrorMessage::IN_DECL_BLOCK)]);
            }
        }
        
        let cls = Class::new (ident, comm, decls, attrs-> attribs, ancestor-> ancestor);

        if (templates.len == 0u64) {
            cls
        } else {
            Template::new (ident, comm, templates, cls, test-> test)
        }
    }

    /**
     * Read the inner part of a class declaration
     * @verbatim: 
     * ================
     * class_block_decl :=   (Keys::PUBLIC | Keys::PRIVATE | Keys::PROTECTED) class_block_decl
     *                     | Keys::VERSION Identifier class_block_decl (Keys::ELSE class_block_decl)?
     *                     | Keys::CTE Keys::IF expression:(0) class_block_decl (Keys::ELSE class_block_decl)?
     *                     | class_inner_declaration*
     * ================
     * @params: 
     *     - close: if false, then the reading stops after the first declaration, otherwise it stops when the token Tokens::RACC is found
     */
    def readClassDeclBlock (mut self, closing : bool = false, inProtection : bool = false)-> [&Declaration]
        throws &ErrorMsg
    {
        let dmut vec = Vec!(&Declaration)::new ();
        loop {
            let (next, comm) = self._lex:.next ();
            match next.str () {
                Keys::PRIVATE | Keys::PUBLIC | Keys::PROTECTED  => {
                    let inner = {
                        if ((self:.readIf ([Tokens::LACC])._0).isEof ()) {
                            let (d, c) = self._lex:.next ();
                            [self:.readClassInnerDecl (d, c, inProtection-> true)]
                        } else {
                            self:.readClassDeclBlock (closing-> true, inProtection-> true)
                        }
                    }  catch {
                        err : &ErrorMsg => {
                            throw err.appendNotes ([ErrorMsg::note (next, SyntaxErrorMessage::IN_DECL_BLOCK)]);
                        }
                    }                    
                    vec:.push (DeclBlock::new (next, comm, inner, protection-> self.toProtection (next.str ())));
                }                
                Keys::VERSION => {
                    vec:.push (self:.readVersionClass (next, comm, inProtection-> inProtection));
                }
                Keys::CTE => {
                    vec:.push (self:.readIfClass (next, comm, inProtection-> inProtection));
                }
                Tokens::LACC => {
                    if (closing) throw ErrorMsg::fatal (next, format (SyntaxErrorMessage::UNEXPECTED_BUT_LST, next.str (), [Keys::PUBLIC, Keys::PROTECTED, Keys::PRIVATE]));
                    else {
                        let r = self:.readClassDeclBlock (closing-> true, inProtection-> true);
                        for i in r { vec:.push (i); }
                    }
                }
                Tokens::RACC => {
                    if (closing) break {}
                    else throw ErrorMsg::fatal (next, format (SyntaxErrorMessage::UNEXPECTED_BUT_LST, next.str (), [Keys::PUBLIC, Keys::PROTECTED, Keys::PRIVATE]));
                }                
                _ => {
                    vec:.push (self:.readClassInnerDecl (next, comm, inProtection-> inProtection));
                }
            }
        }
        
        vec:.fit ();
        vec []
    }

    /**
     * Read a version inside a class definition
     * @verbatim:
     * ===================
     * version_class := __version Identifier class_block_decl ('else' class_block_decl)?
     * ===================
     * @params: 
     *   - inProtection: impl and import cannot be under protected declarators, and must be declared at root level of the class
     */
    def readVersionClass (mut self, loc : &Word, comm : [c8], inProtection : bool = false)-> &Declaration
        throws &ErrorMsg
    {       
        let (v, _) = self:.readIdentifier ();
        return if state::instance ().isVersionActive (v.str ()) {
            self:.readTokens ([Tokens::LACC]);
            let block = self:.readClassDeclBlock (closing-> true, inProtection-> inProtection);
            if (!(self:.readIf ([Keys::ELSE])._0).isEof ()) {
                self:.ignoreBlock ();
            }
            
            DeclBlock::new (loc, comm, block)
        } else {
            self:.ignoreBlock ();
            if (!(self:.readIf ([Keys::ELSE])._0).isEof ()) {
                self:.readTokens ([Tokens::LACC]);
                let block = self:.readClassDeclBlock (closing-> true, inProtection-> inProtection);
                DeclBlock::new (loc, comm, block)
            } else {
                DeclBlock::new (loc, comm, [])
            }
        }        
    }

    /**
     * Read a if condition or assert inside a class definition
     * @verbatim: 
     * ================
     * if_class := Keys::CTE (Keys::IF expression block (Keys::ELSE block)?) | (Keys::ASSERT Tokens::LPAR expression (Tokens::COMA expression)? Tokens::RPAR ) 
     * ================
     */
    def readIfClass (mut self, loc : &Word, comm : [c8], inProtection : bool = false)-> &Declaration
        throws &ErrorMsg
    {
        let (a, _) = self:.readTokens ([Keys::IF, Keys::ASSERT]);
        match a.str () {
            Keys::IF => {
                let test = self:.readExpression ();
                let fst = self:.readClassDeclBlock (closing-> false, inProtection-> inProtection);
                let (next, ncomm) = self:.readIf ([Keys::ELSE]);
                if (next == Keys::ELSE) {
                    let scd = self:.readClassDeclBlock (closing-> false, inProtection-> inProtection);                    
                    CondBlock::new (loc, comm, fst, test, else_-> DeclBlock::new (next, ncomm, scd))
                } else {                
                    CondBlock::new (loc, comm, fst, test)
                }
            }
            _ => {
                self:.readTokens ([Tokens::LPAR]);
                let test = self:.readExpression ();
                let msg : &Expression = if (self:.readTokens ([Tokens::RPAR, Tokens::COMA])._0 == Tokens::COMA) {
                    let msg_ : &Expression = self:.readExpression ();
                    self:.readTokens ([Tokens::RPAR]);
                    msg_
                } else { cast!{&Expression} (EmptyExpression::new ()) }                  
                ExpressionWrapper::new (loc, comm, Assert::new (loc, test, msg))                
            }
        }
    }
   
    /**
     * Read a declaration inside a class definition
     * @verbatim: 
     * ===============
     * class_inner_decl :=   constructor 
     *                     | function
     *                     | field
     *                     | impl (if !inProtection)
     *                     | import (if !inProtection)
     * ===============
     * @params: 
     *    - inProtection: impl and import cannot be under protected declarators, and must be declared at root level of the class
     */
    def readClassInnerDecl (mut self, loc : &Word, comm : [c8], inProtection : bool = false)-> &Declaration
        throws &ErrorMsg
    {        
        match loc {
            Keys::SELF => { return self:.readClassConstructor (loc, comm); }
            Keys::DEF  => { return self:.readFunction (loc, comm, isMethod-> true); }
            Keys::OVER => { return self:.readFunction (loc, comm, isMethod-> true, isOver-> true); }
            Keys::LET  => { return self:.readGlobal (loc, comm, isField-> true); }
            Keys::IMPL => {
                if (inProtection) {
                    throw ErrorMsg::warn (loc, SyntaxErrorMessage::IMPL_IN_PROTECTION);
                }
                return self:.readImplement (loc, comm);
            }
            Keys::IMPORT => {
                if (inProtection) {
                    throw ErrorMsg::warn (loc, SyntaxErrorMessage::IMPORT_IN_PROTECTION);
                }
                return self:.readImport (loc, comm);
            }
            Keys::DTOR => {
                if (inProtection) {
                    throw ErrorMsg::warn (loc, SyntaxErrorMessage::DESTRUCTOR_IN_PROTECTION);
                }
                return self:.readClassDestructor (loc, comm);
            }
            _ => {
                if inProtection {
                    throw ErrorMsg::fatal (loc, format (SyntaxErrorMessage::UNEXPECTED_BUT_LST, loc.str (), [
                        Keys::SELF, Keys::DEF, Keys::OVER, Keys::LET
                    ]));
                } else {                    
                    throw ErrorMsg::fatal (loc, format (SyntaxErrorMessage::UNEXPECTED_BUT_LST, loc.str (), [
                        Keys::SELF, Keys::DEF, Keys::OVER, Keys::LET, Keys::IMPL, Keys::IMPORT, Keys::DTOR
                    ]));
                }
            }
        }
    }
    
    /**
     * Read a class constructor
     * @verbatim: 
     * ================
     * constructor :=   Keys::SELF Keys::IF expression:(0) (attribs)? (Identifier)? template_param_list param_list (with_decl)? (throws_decl)? expression:(0)
     *                | Keys::SELF (attribs)? (Identifier)? (template_param_list)? param_list (with_decl)? (throws_decl)? expression:(0)
     * ================
     */
    def readClassConstructor (mut self, loc : &Word, comm : [c8]) -> &Declaration
        throws &ErrorMsg
    {
        let (hasTest, test) = self:.readTemplateTest ();
        let attribs = self:.readAttributes ();
        let (name, _) = self:.readIfIdentifier ();
        let templates = self:.readTemplateParameters (ifLoc-> hasTest);
                 
        let proto = self:.readFunctionPrototype ();
        
        let dmut construction = Vec!{(&Word, &Expression)}::new ();
        let mut supers : [&Expression] = [];
        let mut auxCstrLoc = Word::eof ();
        if (!(self:.readIf ([Keys::WITH])._0).isEof ()) {
            loop {
                let (next, _) = self._lex:.next ();
                match next.str () {
                    Keys::SUPER | Keys::SELF => {
                        if (!auxCstrLoc.isEof ()) 
                            throw ErrorMsg::fatal (next, SyntaxErrorMessage::MULTIPLE_AUX_CSTRS, notes-> [ErrorMsg::note (auxCstrLoc, ""s8)]);
                                                
                        auxCstrLoc = next;
                        self:.readTokens ([Tokens::LPAR]);
                        supers = self:.readArgumentList ();
                        self:.readTokens ([Tokens::RPAR]);
                    }
                    _ => {
                        if (!self.isIdentifier (next.str ())) 
                            throw ErrorMsg::fatal (next, format (SyntaxErrorMessage::USED_AS_IDENTIFIER, next.str ()));
                        
                        self:.readTokens ([Tokens::EQUAL]);
                        construction:.push ((next, self:.readExpression ()));
                    }
                }
                
                if ((self:.readIf ([Tokens::COMA])._0).isEof ()) {
                    break {}
                }
            }
        }

        let throwers = self:.readThrowers ();
        let body = self:.readExpression ();

        let cstr = Constructor::new (loc, comm, rename-> name, proto, superParams-> supers, fields-> construction[], body-> body, explicitCstrsCall-> auxCstrLoc, attributes-> attribs, throwers-> throwers);
        
        if (templates.len != 0u64) {
            Template::new (loc, comm, templates, cstr, test-> test)
        } else {
            cstr
        }
    }

    /**
     * Read class destructor
     * @verbatim: 
     * ================
     * destructor := Keys::DTOR Tokens::LPAR Keys::MUT Keys::SELF Tokens::RPAR expression:(0)
     * ================
     */
    def readClassDestructor (mut self, loc : &Word, comm : [c8])-> &Declaration
        throws &ErrorMsg
    {
        self:.readTokens ([Tokens::LPAR]);
        let var = self:.readSingleVarDeclaration (mandType-> false, withValue-> false, isClass-> true);
        self:.readTokens ([Tokens::RPAR]);

        let content = self:.readExpression ();
        Destructor::new (loc, comm, var, content)
    }    

    /**
     * ================================================================================
     * ================================================================================
     * =========================          IMPLEMENT           =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Read an implementation of traits inside a class definition
     * @verbatim: 
     * ==================
     * impl := Keys::IMPL expression:(0) (((',' expression:(0))* ';') | class_block_decl)
     * ==================
     */
    def readImplement (mut self, loc : &Word, comm : [c8]) -> &Declaration
        throws &ErrorMsg
    {
        let trait_ = self:.readExpression ();
        let (next, _) = self:.readIf ([Tokens::SEMI_COLON, Tokens::COMA]);
        if (next != Tokens::SEMI_COLON || next != Tokens::COMA) {
            let content = self:.readClassDeclBlock (inProtection-> true);
            Impl::new (loc, comm, trait_, content-> content)
        } else if (next == Tokens::COMA) {
            let dmut impls = Vec!{&Declaration}::new ();
            impls:.push (Impl::new (loc, comm, trait_));
            loop {
                let tr = self:.readExpression ();
                let (n, _) = self:.readTokens ([Tokens::SEMI_COLON, Tokens::COMA]);
                impls:.push (Impl::new (loc, comm, tr));
                if (n == Tokens::SEMI_COLON) break {}
            }
            DeclBlock::new (loc, comm, impls[])
        } else {
            Impl::new (loc, comm, trait_)
        }
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================             ENUM             =========================
     * ================================================================================
     * ================================================================================
     */


    /**
     * Read an enumeration definition
     * @verbatim: 
     * =======================
     * enum_decl :=   Keys::ENUM Keys::IF expression:(0) enum_content Keys::ARROW Identifier template_param_list (Tokens::SEMI_COLON)?
     *              | Keys::ENUM enum_content Keys::ARROW Identifier (Tokens::SEMI_COLON)?
     * 
     * enum_content := (Tokens::PIPE Identifier ('=' expression:(0))?)*
     * =======================
     */
    def readEnum (mut self,  loc : &Word, comm : [c8])-> &Declaration
        throws &ErrorMsg
    {
        let (hasTest, test) = self:.readTemplateTest ();

        let type = if (!((self:.readIf ([Tokens::COLON]))._0).isEof ()) {
            self:.readExpression ()
        } else { cast!{&Expression} (EmptyExpression::new ()) }

        let dmut values = Vec!{&Expression}::new ();
        let dmut coms = Vec!{[c8]}::new ();
        let mut fst = true;
        loop {
            let (n, com) = self:.readTokens ([Tokens::PIPE, Tokens::ARROW]);
            if (!fst) coms:.push (com);

            if (n != Tokens::ARROW) {
                let (name, _) = self:.readIdentifier ();
                if (!(self:.readIf ([Tokens::EQUAL])._0).isEof ()) {
                    values:.push (VarDecl::new (name, name, value-> self:.readExpression (level-> BinaryOperatorsLevels::__members__.len), type-> EmptyExpression::new ()))
                } else {
                    values:.push (VarDecl::new (name, name, value-> EmptyExpression::new (), type-> EmptyExpression::new ()))
                }
            } else break {}
            fst = false;
        }

        let (name, _) = self:.readIdentifier ();
        let templates = self:.readTemplateParameters (ifLoc-> hasTest);
        self:.readIf ([Tokens::SEMI_COLON]);
        
        if (templates.len == 0us) {
            Enum::new (name, comm, type-> type, values-> values[], fieldComms-> coms[])
        } else {
            Template::new (loc, comm, templates, test-> test, content->
                           Enum::new (name, comm, type-> type, values-> values[], fieldComms-> coms[])
                           )
        }
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================           FUNCTION           =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Read a function definition
     * @verbatim: 
     * ====================
     * function :=   Keys::IF expression:(0) Identifier template_param_list function_proto throwers body
     *             | Identifier function_proto throwers body
     * ====================
     */
    def readFunction (mut self,  loc : &Word, comm : [c8], isMethod : bool = false, isOver : bool = false)-> &Declaration
        throws &ErrorMsg
    {
        let (hasTest, test) = self:.readTemplateTest ();
        let attribs = self:.readAttributes ();
        let (name, _) = self:.readIdentifier ();
        if (name == Keys::SELF) throw ErrorMsg::fatal (name, format (SyntaxErrorMessage::USED_AS_IDENTIFIER, name.str ()));
        let templates = self:.readTemplateParameters (ifLoc-> hasTest);

        let proto = self:.readFunctionPrototype (isClosure-> false, isClass-> isMethod);
        let throwers = self:.readThrowers ();

        let body = self:.readFunctionBody ();

        if (templates.len == 0us) {
            Function::new (loc, comm, proto, body, attrs-> attribs, throwers-> throwers, isOver-> isOver)
        } else {
            Template::new (loc, comm, templates, test-> test, content-> 
                           Function::new (loc, comm, proto, body, attrs-> attribs, throwers-> throwers, isOver-> isOver)
                           )
        }       
    }

    /**
     * Read a function body
     * @verbatim: 
     * ===================
     * body := ';' | expression:(0)
     * ===================
     */
    def readFunctionBody (mut self)-> &Expression
        throws &ErrorMsg
    {
        if (!(self:.readIf ([Tokens::SEMI_COLON])._0).isEof ()) self:.readExpression ()
        else { cast!{&Expression} (EmptyExpression::new ()) }
    }
    
    /**
     * Read a function prototype
     * @verbatim: 
     * ====================
     * closure_proto := Tokens::PIPE (var_decl (',' var_decl)*)? Tokens::PIPE (Tokens::ARROW expression:(0))? 
     * function_proto := Tokens::LPAR (var_decl (',' var_decl)*)? Tokens::RPAR (Tokens::ARROW expression:(0))?  
     * ====================
     */
    def readFunctionPrototype (mut self, isClosure : bool = false, isClass : bool = false)-> &FunctionProto
        throws &ErrorMsg
    {
        let (loc, hasParams) = if isClosure {
            let (n, _) = self:.readTokens ([Tokens::PIPE, Tokens::DPIPE]);
            (n, n == Tokens::PIPE)
        } else { (self:.readTokens ([Tokens::LPAR])._0, true) }

        let mut isVariadic = false;
        let dmut params = Vec!{&Expression}::new ();
        if hasParams {
            loop {
                if (isClosure) {
                    if ((self:.readIf ([Tokens::PIPE])._0).isEof ()) {
                        params:.push (self:.readSingleVarDeclaration (mandType-> false, withValue-> false, isClass-> false));
                        if ((self:.readTokens ([Tokens::PIPE, Tokens::COMA])._0) == Tokens::PIPE) break {}
                    } else break {}
                } else {
                    let tok = if (!isClass || params.len () > 0us) {
                        self:.readIf ([Tokens::RPAR, Tokens::TDOT])._0
                    } else { Word::eof () }
                    
                    if (tok == Tokens::TDOT) {
                        isVariadic = true;
                        self:.readTokens ([Tokens::RPAR]);
                        break {}
                    } else if (tok != Tokens::RPAR) {
                        params:.push (self:.readSingleVarDeclaration (mandType-> true, withValue-> true, isClass-> (isClass && params.len () == 0us)));
                        if ((self:.readTokens ([Tokens::RPAR, Tokens::COMA])._0) == Tokens::RPAR) break {}
                    } else break {}
                }
            }
        }
        
        if (!(self:.readIf ([Tokens::ARROW])._0).isEof ()) {
            FunctionProto::new (loc, params-> params [], retType-> self:.readExpression (), isVariadic-> isVariadic, forLambda-> isClosure)
        } else {
            FunctionProto::new (loc, params-> params [], retType-> EmptyExpression::new (), isVariadic-> isVariadic, forLambda-> isClosure)
        }       
    }

    /**
     * Read the list of throwers of a function 
     * @verbatim:
     * ====================
     * throwers: (Keys::THROWS expression:(0) (',' expression:(0))*)? 
     * ====================
     */
    def readThrowers (mut self)-> [&Expression]
        throws &ErrorMsg
    {
        let (th, _) = self:.readIf ([Keys::THROWS]);
        let dmut res = Vec!{&Expression}::new ();
        if (!th.isEof ()) {
            loop {
                res:.push (self:.readExpression ());
                let (n, _) = self:.readIf ([Tokens::COMA]);
                if (n.isEof ()) break {}
            }
        }
        
        res[]
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================            GLOBAL            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Read a global var declaration
     * @verbatim:
     * ====================
     * global := var_decl
     * ====================
     */
    def readGlobal (mut self,  loc : &Word, comm : [c8], isField : bool = false)-> &Global
        throws &ErrorMsg
    {        
        Global::new (loc, comm, self:.readSingleVarDeclaration (mandType-> false, withValue-> true, isClass-> false), isField-> isField)
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================            IMPORT            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Read an import declaration
     * @verbatim: 
     * ====================
     * import: Keys::IMPORT inner_import (Tokens::COMA inner_import)* (Tokens::SEMI_COLON)?
     * inner_import = path (Keys::AS Identifier)
     * ====================
     */
    def readImport (mut self,  loc : &Word, comm : [c8])-> &Declaration
        throws &ErrorMsg
    {
        let dmut imports = Vec!{&Declaration}::new ();
        loop {
            let space = self:.readPath ();
            let as_ = if (!(self:.readIf ([Keys::AS])._0).isEof ()) {
                self:.readIdentifier ()._0
            } else { Word::eof () }

            imports:.push (Import::new (loc, comm, space, as_-> as_));
            
            if (self:.readIf ([Tokens::COMA])._0.isEof ()) break {}
        }

        self:.readIf ([Tokens::SEMI_COLON]);

        DeclBlock::new (loc, comm, imports[])
    }


    /**
     * ================================================================================
     * ================================================================================
     * =========================            EXTERN            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Read an extern declaration
     * @verbatim: 
     * ====================
     * extern: Keys::EXTERN (Tokens::LPAR Language (Tokens::COMA path)? Tokens::RPAR)? decl_block
     * ====================
     */
    def readExtern (mut self,  loc : &Word, comm : [c8])-> &ExternBlock
        throws &ErrorMsg
    {
        let (n, _) = self:.readIf ([Tokens::LPAR]);
        let (language, space) = if (!n.isEof ()) {
            let (l, _) = self:.readTokens ([Keys::CLANG, Keys::CPPLANG, Keys::DLANG, Keys::YLANG]);
            let space = if (!(self:.readIf ([Tokens::COMA])._0).isEof ()) {
                self:.readPath ()
            } else { cast!{&Expression} (EmptyExpression::new ()) }
            (l, space)
        } else { (Word::new (Keys::YLANG, loc), cast!{&Expression} (EmptyExpression::new ())) }

        
        ExternBlock::new (loc, comm, language, space, self:.readProtectionBlock ())
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================            MACRO             =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Read a macro declaration
     * @verbatim: 
     * ==================
     * macro := Keys::MACRO Identifier macro_block
     * ==================
     */
    def readMacro (mut self,  _ : &Word, comm : [c8])-> &Macro
        throws &ErrorMsg
    {
        let (name, _) = self:.readIdentifier ();
        self:.readTokens ([Tokens::LACC]);
        Macro::new (name, comm, self:.readMacroBlock (closing-> true, inPub-> false))
    }



    /**
     * Read the content of a macro
     * @verbatim: 
     * =================
     * macro_block := Tokens::LACC (public_macro_block | version_macro_block)* Tokens::RACC
     * =================
     */
    def readMacroBlock (mut self, closing : bool = true, inPub : bool = false) -> [&Declaration]
        throws &ErrorMsg
    {
        let dmut decls = Vec!{&Declaration}::new ();
        loop {
            let (n, comm) = if (closing) {
                if (inPub) {
                    self:.readIf ([Keys::VERSION, Tokens::RACC, Tokens::LACC, Keys::IMPORT])
                } else {
                    self:.readIf ([Keys::PUBLIC, Keys::VERSION, Tokens::RACC, Tokens::LACC, Keys::IMPORT])
                }
            } else {
                if (inPub) { self:.readIf ([Keys::VERSION, Tokens::LACC, Keys::IMPORT]) }
                else { self:.readIf ([Keys::PUBLIC, Keys::VERSION, Tokens::LACC, Keys::IMPORT]) }
            }
            
            match n {
                Keys::PUBLIC => {
                    let block = self:.readMacroBlock (closing-> false, inPub-> true);                    
                    decls:.push (DeclBlock::new (n, comm, block, protection-> Protection::PUBLIC));
                    if (!closing) break {}
                }
                Keys::VERSION => {
                    decls:.push (self:.readVersionMacroBlock (n, comm, inPub));
                    if (!closing) break {}
                }
                Keys::IMPORT => {
                    decls:.push (self:.readImport (n, comm));
                    if (!closing) break {}
                }
                Tokens::RACC => {
                    // Necessary closing, otherwise it would not have been read
                    break {}
                }
                Tokens::LACC => {
                    let inner = self:.readMacroBlock (closing-> true, inPub-> inPub);
                    for r in inner {
                        decls:.push (r);
                    }
                    if (!closing) break {}
                }
                _ => {
                    decls:.push (self:.readMacroContent ());
                    if (!closing) break {}
                }
            }
        }
        
        decls []
    }

    /**
     * Visit a version part of a macro block
     * @verbatim: 
     * ======================
     * version_macro_block := Keys::VERSION Identifier macro_block (Keys::ELSE macro_block)
     * ======================
     */
    def readVersionMacroBlock (mut self, loc : &Word, comm : [c8], inPub : bool)-> &Declaration
        throws &ErrorMsg
    {
        let (ident, _) = self:.readIdentifier ();
        if (state::instance ().isVersionActive (ident.str ())) {
            let decls = self:.readMacroBlock (closing-> false, inPub-> inPub);
            if (!(self:.readIf ([Keys::ELSE])._0).isEof ()) {
                self:.ignoreBlock ();
            }

            DeclBlock::new (loc, comm, decls, protection-> if (inPub) Protection::PUBLIC else Protection::PRIVATE)
        } else {
            self:.ignoreBlock ();
            if (!(self:.readIf ([Keys::ELSE])._0).isEof ()) {
                let decls = self:.readMacroBlock (closing-> false, inPub-> inPub);
                DeclBlock::new (loc, comm, decls, protection-> if (inPub) Protection::PUBLIC else Protection::PRIVATE)
            } else {
                DeclBlock::new (loc, comm, [])
            }
        }
    }

    /**
     * Read the content of a macro definition
     * @verbatim: 
     * =================
     * marco_content := macro_constructor | macro_rule
     * =================
     */
    def readMacroContent (mut self) -> &Declaration
        throws &ErrorMsg
    {
        let (type, comm) = self:.readTokens ([Keys::DEF, Keys::SELF]);
        match type {
            Keys::DEF => {
                self:.readMacroRule (type, comm)
            }
            _ => self:.readMacroConstructor (type, comm)
        }
    }

    /**
     * Read a macro rule
     * @verbatim: 
     * ===============
     * macro_rule := Keys::DEF Identifier macro_head_rule (Tokens::SEMI_COLON | macro_body_rule)
     * ===============
     */
    def readMacroRule (mut self, _ : &Word, comm : [c8]) -> &Declaration
        throws &ErrorMsg
    {
        let (name, _) = self:.readIdentifier ();
        let (head, skips) = self:.readMacroRuleHead ();

        let (bodyLoc, body) = if (self:.readIf ([Tokens::SEMI_COLON])._0.isEof ()) {
            self:.readMacroRuleBody ()
        } else { (Word::eof (), ""s8) }

        MacroRule::new (name, comm, bodyLoc, body, head, skips-> skips, isConstructor-> false)
    }

    
    /**
     * Read a macro constructor
     * @verbatim: 
     * ==================
     * macro_constructor := Keys::SELF macro_head_rule macro_body_rule
     * ==================
     */
    def readMacroConstructor (mut self, loc : &Word, comm : [c8]) -> &Declaration
        throws &ErrorMsg
    {
        let (head, skips) = self:.readMacroRuleHead ();
        let (bodyLoc, body) = self:.readMacroRuleBody ()

        MacroRule::new (loc, comm, bodyLoc, body, head, skips-> skips, isConstructor-> true)
    }


    /**
     * Read the head (prototype) of a macro rule (or constructor)
     * @verbatim: 
     * =================
     * macro_rule_head :=  macro_inner_mult (Keys::SKIPS string_lit (Tokens::PIPE string_lit)*)?
     * =================
     */
    def readMacroRuleHead (mut self)-> (&MacroRuleExpression, [&Expression])
        throws &ErrorMsg
    {
        let (start, end, inner) = self:.readInnerMacroMult ();

        let dmut skips = Vec!{&Expression}::new ();
        if (!(self:.readIf ([Keys::SKIPS])._0).isEof ()) {
            self:.readTokens ([Tokens::LPAR]);
            loop {
                let str = self:.readString ();
                skips:.push (MacroToken::new (str.getLoc (), str));
                if (self:.readTokens ([Tokens::RPAR, Tokens::PIPE])._0 == Tokens::RPAR) break {}
            }
        }
        
        (cast!{&MacroRuleExpression} (MacroMult::new (start, end, inner)), skips[])
    }


    /**
     * Read the body of a macro rule (or constructor)
     * @verbatim: 
     * ================
     * marco_rule_body := Tokens::LACC Any* Tokens::RACC
     * ================
     */
    def readMacroRuleBody (mut self)-> (&Word, [c8])
        throws &ErrorMsg
    {
        let (start, _) = self:.readTokens ([Tokens::LACC]);
        let dmut res = StringStream::new ();
        { 
            self._lex:.setSkips ([]);
            let mut nb = 1us;
            loop {
                let (n, _) = self._lex:.next ();
                if (n.isEof ()) throw ErrorMsg::fatal (n, SyntaxErrorMessage::BLOCK_NEVER_CLOSED, notes-> [ErrorMsg::note (start, SyntaxErrorMessage::IN_DECL_BLOCK)]);

                match n {
                    Tokens::RACC => {
                        nb -= 1us;
                        if (nb != 0us) { res:.write (n.str ()); }
                        else break {}
                    }
                    Tokens::LACC => {
                        nb += 1us;
                        res:.write (n.str ());
                    }
                    _ => { res:.write (n.str ()); }
                }
            }
        } exit {        
            self._lex:.setSkips (SkipTokens::__members__);
        }

        (start, res[])
    }


    /**
     * Read the inner part of a macro mutliplicator
     * @verbatim: 
     * ==================
     * macro_inner_mult := Tokens::LPAR ((macro_expression*) | (macro_expression (Tokens::PIPE macro_expression)*) Tokens::RPAR
     * ==================
     */
    def readInnerMacroMult (mut self)-> (&Word, &Word, [&MacroRuleExpression])
        throws &ErrorMsg
    {
        let (start, _) = self:.readTokens ([Tokens::LPAR]);
        let dmut inner = Vec!{&MacroRuleExpression}::new ();
        let mut or = false;
        let mut tok = Word::eof ();
        
        loop {
            let next = {
                self:.readMacroExpression ()
            } catch {
                _ : &ErrorMsg => self:.readExpression (level-> BinaryOperatorsLevels::__members__.len)
            }
            
            if (!or) {
                inner:.push (next);
                if (inner.len () == 1u32) {
                    let (n, _) = self:.readIf ([Tokens::PIPE, Tokens::RPAR])
                        if (n == Tokens::PIPE) {
                            or = true;
                            tok = n;
                        } else if (n == Tokens::RPAR) break {}                    
                } else {
                    let (n, _) = self:.readIf ([Tokens::RPAR]);
                    tok = n;
                    if (!n.isEof ()) break {}
                }
            } else {
                __pragma!trusted ({
                    let last = inner:.pop ();
                    inner:.push (MacroOr::new (tok, last, next));
                });
            }
        }

        (start, tok, inner[])
    }
    

    /**
     * Read a macro rule expression
     * @verbatim: 
     * =================
     * macro_expression :=   macro_inner_mult (Multiplicator)?
     *                     | Identifier Tokens::EQUAL macro_expression
     *                     | String
     *                     | expression:(10)
     * =================
     */
    def readMacroExpression (mut self)-> &MacroRuleExpression
        throws &ErrorMsg
    {
        if (!(self:.readIf ([Tokens::LPAR])._0).isEof ()) {
            let (start, end, inner) = self:.readInnerMacroMult ();
            let (mult, _) = self:.readIf (MacroMultTokens::__members__);
            MacroMult::new (start, end, inner, mult-> mult)
        } else {
            let (ident, _) = self:.readIfIdentifier ();
            if (ident.isEof ()) {
                let str = self:.readString ();
                MacroToken::new (str.getLoc (), str)
            } else {
                self:.readTokens ([Tokens::EQUAL]);
                let inner = {
                    self:.readMacroExpression ()
                } catch {
                    _ => self:.readExpression (level-> BinaryOperatorsLevels::__members__.len)
                }
                
                MacroVar::new (ident, inner)
            }
        }
    }
               
    /**
     * ================================================================================
     * ================================================================================
     * =========================            MODULE            =========================
     * ================================================================================
     * ================================================================================
     */


    /**
     * Read a local module
     * @verbatim:
     * =====================
     * local_module :=   Keys::MODULE Keys::IF expression:(0) Identifier template_param_list decl_block
     *                 | Keys::MODULE Identifier decl_block
     * =====================
     */
    def readLocalModule (mut self,  _ : &Word, comm : [c8])-> &Declaration
        throws &ErrorMsg
    {
        let (hasTest, test) = self:.readTemplateTest ();
        let (ident, _) = self:.readIdentifier ();
        let templates = self:.readTemplateParameters (ifLoc-> hasTest);

        let (n, comm_) = self:.readTokens ([Tokens::LACC]);        
        let content = self:.readDeclBlock (n, comm_, closing-> true);

        if (templates.len == 0us) {
            Module::new (ident, EmptyExpression::new (), comm, content, isGlobal-> true)
        } else {
            Template::new (ident, comm, templates, test-> test,
                           Module::new (ident, EmptyExpression::new (), comm, content, isGlobal-> true)
                           )
        }
    }


    /**
     * ================================================================================
     * ================================================================================
     * =========================            STRUCT            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Read a struct declaration
     * @verbatim:
     * ==================
     * struct_decl :=   Keys::STRUCT Keys::IF expression:(0) (attributes_list)? field_list Tokens::ARROW Identifier template_param_list (Tokens::SEMI_COLON)?
     *                | Keys::STRUCT (attributes_list)? field_list Tokens::ARROW Identifier (Tokens::SEMI_COLON)?
     *
     * field_list := Tokens::PIPE var_decl:(10)  
     * ==================
     */
    def readStruct (mut self,  _ : &Word, comm : [c8])-> &Declaration
        throws &ErrorMsg
    {
        let (hasTest, test) = self:.readTemplateTest ();
        let attribs = self:.readAttributes ();
        
        let dmut vars = Vec!{&Expression}::new ();
        let dmut comms = Vec!{[c8]}::new ();
        let mut fst = true;
        loop {
            let (n, doc) = self:.readTokens ([Tokens::PIPE, Tokens::ARROW]);
            match n {
                Tokens::PIPE => {
                    if (!fst) comms:.push (doc);
                    vars:.push (self:.readSingleVarDeclaration (mandType-> false, withValue-> false, level-> BinaryOperatorsLevels::__members__.len));
                }
                Tokens::ARROW => break {}
            }
            fst = false;
        }
        
        let (name, _) = self:.readIdentifier ();
        let templates = self:.readTemplateParameters (ifLoc-> hasTest);
        self:.readIf ([Tokens::SEMI_COLON]);
        
        let str = Struct::new (name, comm, vars[], attributes-> attribs, fieldComms-> comms[]);
        
        if (templates.len == 0us) {
            str
        } else {
            Template::new (name, comm, templates, str, test-> test)
        }

    }    

    /**
     * ================================================================================
     * ================================================================================
     * =========================            TRAIT             =========================
     * ================================================================================
     * ================================================================================
     */


    /**
     * Visit a trait declaration
     * @verbatim: 
     * =================
     * trait_decl :=   Keys::TRAIT Keys::IF expression:(0) Identifier template_param_list class_block_decl
     *               | Keys::TRAIT Identifier class_block_decl
     * =================
     */    
    def readTrait (mut self,  _ : &Word, comm : [c8])-> &Declaration
        throws &ErrorMsg
    {

        let (hasTest, test) = self:.readTemplateTest ();
        let (name, _) = self:.readIdentifier ();
        let templates = self:.readTemplateParameters (ifLoc-> hasTest);

        self:.readTokens ([Tokens::LACC]);
        let decls = self:.readClassDeclBlock (closing-> true, inProtection-> false);

        let tra = Trait::new (name, comm, decls)
        
        if (templates.len == 0us) {
            tra
        } else {
            Template::new (name, comm, templates, test-> test, tra)
        }        
    }        


    /**
     * ================================================================================
     * ================================================================================
     * =========================           TEMPLATE           =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Read a list of template parameters 
     * @params: 
     *    - ifLoc: the location of the if test, if not eof, has to read the list, can't return an empty list
     * @throws:
     *    - ErrorMsg: if !ifLoc.isEof (), but there is no list to read
     */
    def readTemplateParameters (mut self, ifLoc : &Word = Word::eof ())-> [&Expression]
        throws &ErrorMsg
    {
        let (next, _) = if (!ifLoc.isEof ()) {
            let (x, c) = self._lex:.next ();
            if (x != Tokens::NOT) {
                throw ErrorMsg::fatal (x, format (SyntaxErrorMessage::UNEXPECTED_BUT_LST, x.str (), [Tokens::NOT]),
                                       notes-> [ErrorMsg::note (ifLoc, SyntaxErrorMessage::IF_NON_TEMPLATE)]);
            }
            (x, c)
        } else {
            self:.readIf ([Tokens::NOT])
        }

        if (!next.isEof ()) { // there are templates to read
            let dmut vec = Vec!{&Expression}::new ();
            let (begin, _) = self:.readTokens ([Tokens::LACC, Tokens::INF]);
            loop {
                let beginCur = self._lex.getCounter ();
                let (curr, _) = self._lex:.next ();
                match curr.str () {
                    Keys::STRUCT | Keys::CLASS | Keys::ALIAS | TemplateVarType::TUPLE => {
                        vec:.push (TemplateVar::new (curr, self.toTemplateVarType (curr.str ())));
                    }
                    _ => {
                        self._lex:.rewind (nb-> self._lex.getCounter () - beginCur);
                        vec:.push (
                            if self.isIdentifier (curr.str ()) {
                                self:.readTemplateVarParam ()
                            } else {
                                self:.readExpression ()
                            }
                        );
                    }
                }
                
                let (token, _) = if (begin == Tokens::LACC) {
                    self:.readTokens ([Tokens::RACC, Tokens::COMA])
                } else {
                    self:.readTokens ([Tokens::SUP, Tokens::COMA])
                }
                
                if (token.str () == Tokens::RACC || token.str () == Tokens::SUP)
                    break {}            
            }  catch {
                err : &ErrorMsg => {
                    throw err.appendNotes ([ErrorMsg::note (begin, SyntaxErrorMessage::IN_TEMPLATE_PARAMS)]);
                }
            }
            
            vec:.fit ();
            return vec [];
        } 
        
        []
    }

    /**
     * Read an expression that might be a variable inside a list of template parameters
     * @verbatim: 
     * ===============
     * template_var_decl :=    Identifier (Tokens::COLON expression:0)? (Tokens::EQUAL expression:0)?
     *                      |  Identifier (Keys::OF | Keys::OVER | Keys::IMPL) expression:0
     *                      |  Identifier (Tokens::COLON)?  Tokens::TDOT
     *                      |  expression:0
     * ===============
     */
    def readTemplateVarParam (mut self) -> &Expression
        throws &ErrorMsg
    {
        let beginCur = self._lex.getCounter ();
        let (name, _) = self:.readIdentifier ();
        let (next, _) = self:.readIf ([cast![c8] (Tokens::COLON), Tokens::TDOT,
                                       Tokens::EQUAL, Keys::OVER, Keys::OF,
                                       Keys::IMPL]);
        
        match next.str () {
            Tokens::COLON => {
                let (tok, _) = self:.readIf ([Tokens::TDOT]);
                if (tok.isEof ()) { // V : type ('=' value)?
                    let type = self:.readExpression ();
                    if (!(self:.readIf ([Tokens::EQUAL])._0).isEof ()) { // '=' value
                        return VarDecl::new (name, name, value-> self:.readExpression (), type-> type);
                    } else return VarDecl::new (name, name, value-> Unit::new (), type-> type);
                } else return TemplateVariadicVar::new (name, isValue-> true); // V:...
            }
            Tokens::EQUAL => {
                return VarDecl::new (name, name, value-> self:.readExpression (), type-> Unit::new ());
            }
            Tokens::TDOT  => {
                return TemplateVariadicVar::new (name, isValue-> false);
            }
            Keys::OVER | Keys::OF | Keys::IMPL => {
                let k = self.toTemplateOfVarType (next.str ());
                return TemplateOfVar::new (name, self:.readExpression (), kind-> k);
            }
        }

        self._lex:.rewind (nb-> self._lex.getCounter () - beginCur);
        return self:.readExpression ();
    }

    /**
     * Read a template test (if anyl
     * @returns: 
     *   - the location of the if token, (or eof)
     *   - the test expression, or Unit
     */
    def readTemplateTest (mut self)-> (&Word, &Expression)
        throws &ErrorMsg
    {    
        let (hasTest, _) = self:.readIf ([Keys::IF]);
        if hasTest.isEof () {
            (hasTest, const cast!(&Expression) (Unit::new ()))
        } else {
            (hasTest, self:.readExpression ())
        }
    }


    /**
     * ================================================================================
     * ================================================================================
     * =========================          ATTRIBUTES          =========================
     * ================================================================================
     * ================================================================================
     */
    
    /**
     * Read a list of custom attributes, if the token Tokens::AT is not read, then an empty list is returned
     * @verbatim:
     * =================
     * attributes_lst :=   Tokens::AT Keys::LACC Attribute (Tokens::COMA Attribute)* Keys::RACC
     *                   | Tokens::AT Attribute
     * =================
     */
    def readAttributes (mut self)-> [Attributes]
        throws &ErrorMsg
    {
        let (next, _) = self:.readIf ([Tokens::AT]);
        if (next.isEof ()) return [];

        let (open, _) = self:.readIf ([Tokens::LACC]);
        let dmut vec = Vec!(Attributes)::new ();
        loop {
            let (identifier, _) = self:.readIdentifier ();
            match identifier {
                Attributes::ABSTRACT => vec:.push (Attributes::ABSTRACT);
                Attributes::FINAL    => vec:.push (Attributes::FINAL);
                Attributes::PACKED   => vec:.push (Attributes::PACKED);
                Attributes::UNION    => vec:.push (Attributes::UNION);
                _ => {
                    throw ErrorMsg::fatal (identifier, format (SyntaxErrorMessage::UNDEFINED_ATTRIBUTE, identifier.str ()));
                }
            }
            
            if (open.isEof ()) break {}
            else {
                let (close, _) = self:.readTokens ([Tokens::COMA, Tokens::RACC]);
                if (close.str () == Tokens::RACC) break {}
            }
        }  catch {
            err : &ErrorMsg => {
                throw err.appendNotes ([ErrorMsg::note (open, SyntaxErrorMessage::IN_DECL_BLOCK)]);
            }
        }
        
        vec:.fit ()
        vec[]
    }



    /**
     * ================================================================================
     * ================================================================================
     * =========================         EXPRESSIONS          =========================
     * ================================================================================
     * ================================================================================
     */
    
    /**
     * Read an expression 
     * @verbatim: 
     * ==================
     * expression:(level) := expression:(level+1) (binary_operator:(level) expression:(level))?
     * expression:(10) := operand:(0)
     * ==================
     */
    def readExpression (mut self, level : usize = 0us)-> &Expression
        throws &ErrorMsg
    {
        if (cast!usize (level) == BinaryOperatorsLevels::__members__.len) {
            self:.readOperand0 ()
        } else {
            let left = self:.readExpression (level-> level + 1us);
            self:.readExpressionFollow (left, level-> level)
        }
    }

    /**
     * Read the following of an expression (for operators)
     */
    def readExpressionFollow (mut self, left : &Expression, level : usize = 0us)-> &Expression
        throws &ErrorMsg
    {
        let (tok, _) = self:.readIf (__pragma!trusted ({BinaryOperatorsLevels::__members__[level]}));
        if (!tok.isEof ()) {
            let right = self:.readExpression (level-> level + 1us);
            self:.readExpressionFollow (Binary::new (tok, left, right), level-> level)                
        } else {
            left
        }
    }

    /**
     * Read a highest level operand
     * @verbatim: 
     * ===================
     * operand:(0) := (unary_operator)? operand:(1) (Tokens::INTEG)?     
     * ===================
     */
    def readOperand0 (mut self) -> &Expression
        throws &ErrorMsg
    {
        let (tok, _) = self:.readIf (UnaryOperators::__members__);
        let ret = if (!tok.isEof ()) {
            Unary::new (tok, self:.readOperand1 ())
        } else { self:.readOperand1 () }

        let (post, _) = self:.readIf ([Tokens::INTEG]);
        
        if (!post.isEof ()) {
            Try::new (post, ret)
        } else { ret }
    }


    /**
     * Read an operand of level 1
     * @verbatim: 
     * =================
     * operand:(1) :=   block 
     *                | if_expr
     *                | while_expr
     *                | assert_expr
     *                | break_expr
     *                | dowhile_expr
     *                | for_expr
     *                | match_expr
     *                | vardecl
     *                | return_expr
     *                | function_expr
     *                | delegate_expr
     *                | loop_expr
     *                | throw_expr
     *                | version
     *                | pragma_expr
     *                | with_expr
     *                | atomic_expr
     *                | operand:(operand_follow)?
     * =================
     */
    def readOperand1 (mut self)-> &Expression
        throws &ErrorMsg
    {
        let (tok, _) = self:.readIf ([Tokens::LACC, Keys::IF, Keys::WHILE, Keys::ASSERT,
                                      Keys::BREAK, Keys::DO, Keys::FOR, Keys::MATCH,
                                      Keys::LET, Keys::RETURN, Keys::FUNCTION, Keys::DELEGATE,
                                      Keys::LOOP, Keys::THROW, Keys::VERSION, Keys::PRAGMA, Keys::WITH, Keys::ATOMIC]);

        match tok {
            // Keys::LOOP | Keys::WHILE => { self:.readLoop (tok) }
            // Tokens::ACC => { self:.readBlock (tok) }
            // Keys::IF => { self:.readIf (tok) }
            // Keys::ASSERT => { self:.readAssert (tok) }
            // Keys::BREAK => { self:.readBreak (tok) }
            // Keys::DO => { self:.readDoWhile (tok) }
            // Keys::FOR => { self:.readFor (tok) }
            // Keys::MATCH => { self:.readMatch (tok) }
            // Keys::LET => { self:.readVarDeclaration (tok) }
            // Keys::RETURN => { self:.readReturn (tok) }
            // Keys::FUNCTION => { self:.readFunctionType (tok) }
            // Keys::DELEGATE => { self:.readFunctionType (tok) }
            // Keys::THROW => { self:.readThrow (tok) }
            // Keys::VERSION => { self:.readVersionExpr (tok) }
            // Keys::PRAGMA => { self:.readPragma (tok) }
            // Keys::WITH => { self:.readWith (tok) }
            // Keys::ATOMIC => { self:.readAtomic (tok) }
            _ => { self:.readOperandFollow (self:.readOperand2 (self:.readOperand3 ())) }
        }
    }


    /**
     * Read the follow-up of an operand
     * @verbatim: 
     * =================
     * operand_follow :=   Tokens::LPAR param_list Tokens::RPAR (operand_follow)?
     *                   | Tokens::LCRO param_list Tokens::RCRO (operand_follow)?
     *                   | (Tokens::DOT | Tokens::DOT_AND) operand:(3) (template_call)? (operand_follow)?
     *                   | macro_call (operand_follow)?
     * =================
     */
    def readOperandFollow (mut self, left : &Expression)-> &Expression {
        let (n, _) = self:.readIf ([Tokens::LPAR, Tokens::LCRO, Tokens::MACRO_ACC, Tokens::MACRO_CRO, Tokens::MACRO_PAR, Tokens::DOT, Tokens::DOT_AND]);
        match n {
            // Tokens::LPAR | Tokens::LCRO => {
            //     let params = self:.readArgumentList (withNamed-> true, closing-> if (n == Tokens::LPAR) { Tokens::RPAR } else { Tokens::RCRO });
            //     let (end, _) = self:.readTokens ([if (n == Tokens::LPAR) { Tokens::RPAR } else { Tokens::RCRO }]);
            //     self:.readOperandFollow (MultOperator::new (n, end, left, params))
            // }
            // Tokens::MACRO_ACC | Tokens::MACRO_PAR | Tokens::MACRO_CRO => {
            //     self:.readOperandFollow (self:.readMacroCall (n, left))
            // }
            // Tokens::DOT | Tokens::DOT_AND => {
            //     let right = self:.readOperand3 (canBeTemplateCall-> false, canBeFloat-> false);
            //     self:.readOperandFollow (self:.readTemplateCall (Binary::new (n, left, right)))
            // }
            _ => { left }
        }
    }


    /**
     * Read a level 2 operand
     * @verbatim: 
     * ===============
     * operand:(2) := (Tokens::DCOLON template_call)?
     * ===============
     */
    def readOperand2 (mut self, left : &Expression) -> &Expression
        //throws &ErrorMsg
    {
        // let (n, _) = self:.readIf ([Tokens::DCOLON]);
        // if (!n.isEof ()) {
        //     let right = self:.readOperand3 (canBeTemplateCall-> false);
        //     self:.readOperand2 (self:.readTemplateCall (Binary::init (n, left, right)))
        // } else {
            left
        //}
    }

    /**
     * Read a level 3 operand
     * @verbatim: 
     * =================
     * operand:(3) :=   cast_expr
     *                | template_checker
     *                | array_lit
     *                | tuple_lit
     *                | lambda_lit
     *                | intrinsic
     *                | literal
     *                | decorated_expr
     *                | var
     * =================
     */
    def readOperand3 (mut self, canBeTemplateCall : bool = true, canBeFloat : bool = true) -> &Expression
        throws &ErrorMsg
    {
        canBeFloat;
        canBeTemplateCall;
        throw ErrorMsg::fatal (Word::eof (), ""s8);
        // let (n, _) = self:.readIf ([Keys::CAST, Keys::IS, Tokens::LCRO, Tokens::LPAR, Tokens::PIPE, Tokens::DPIPE]);
        // match n {
        //     Keys::CAST => { self:.readCast (n) }
        //     Keys::IS => { self:.readTemplateChecker (n) }
        //     Tokens::LCRO => { self:.readArray (n) }
        //     Tokens::LPAR => { self:.readTuple (n) }
        //     Tokens::PIPE | Tokens::DPIPE => { self:.readLambda (n) }
        //     _ => {
        //         let (i, _) = self:.readIf (IntrinsicKeys::__members__);
        //         if (!i.isEof ()) {
        //             let (p, _) = self:.readIf ([Tokens::LPAR]);
        //             let inner = if (p.isEof ()) {
        //                 self:.readExpression (level-> BinaryOperatorsLevels::__members__.len)
        //             } else { self:.readExpression () }
                    
        //             let ret = Intrinsic::new (i, self.toIntrinsic (i.str ()), inner);
        //             if (!p.isEof ()) self:.readTokens ([Tokens::RPAR]);
        //             ret 
        //         } else {
        //             {
        //                 self:.readLiteral (canBeFloat-> canBeFloat)
        //             } catch {
        //                 _ => self:.readVar (canBeTemplateCall-> canBeTemplateCall)
        //             }
        //         }
        //     }
        // }        
    }
    
    
    /**
     * Read a list of arguments
     * @params: 
     *    - withNamed: if true, named expression are allowed in the argument list
     *    - closing: the token that closes the list
     * @verbatim: 
     * ===================
     * 
     * ===================
     */
    def readArgumentList (mut self, withNamed : bool = false, closing : [c8] = Tokens::RPAR)-> [&Expression]
        throws &ErrorMsg
    {
        let dmut vec = Vec!{&Expression}::new ();
        loop {
            let (x, _) = self:.readIf ([closing]);
            if (!x.isEof ()) { self._lex:.rewind (); break {} }
            
            let beg = self._lex.getCounter ();
            let mut read = false;
            if (withNamed) {
                let (name, _) = self._lex:.next ();
                if (self.isIdentifier (name.str ())) {
                    let (arr, _) = self:.readIf ([Tokens::ARROW]);
                    if (!arr.isEof ()) {
                        vec:.push (NamedExpression::new (name, self:.readExpression ()));
                        read = true;
                    }
                }
            }
            
            if (!read) {
                self._lex:.rewind (nb-> self._lex.getCounter () - beg);
                vec:.push (self:.readExpression ());
            }
            
            if (self:.readTokens ([closing, Tokens::COMA])._0).str () != Tokens::COMA {
                break {}
            }
        }
        
        vec:.fit ();
        vec []
    }


    /**
     * ================================================================================
     * ================================================================================
     * =========================       VAR DECLARATION        =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Read a single var declaration
     * @params: 
     *    - mandType: the type is mandatory
     *    - withValue: there can be a value
     *    - isClass: self is a valid Identifier
     *    - level: the level of the expression (only applicable if withValue)
     * @verbatim: 
     * ==================
     * single_var_decl :=   (Decorator)* (Identifier | Keys::UNDER) (Tokens::COLON expression:(10))? (Tokens::EQUAL expression:(level))
     *                    | (Decorator)* Keys::SELF
     * ==================
     */
    def readSingleVarDeclaration (mut self, mandType : bool = false, withValue : bool = true, isClass : bool = false, level : usize = 0us)-> &VarDecl
        throws &ErrorMsg
    {
        let decos = self:.readDecorators ();
        let (ig, _) = self:.readIf ([Keys::UNDER]);
        let name = if (!ig.isEof ()) {
            ig
        } else { self:.readIdentifier ()._0 }

        match name {
            Keys::SELF => {
                if (!isClass) throw ErrorMsg::fatal (name, format (SyntaxErrorMessage::USED_AS_IDENTIFIER, name.str ()));
                VarDecl::new (name, name, decos-> decos, value-> EmptyExpression::new (), type-> EmptyExpression::new ())
            }
            _ => {
                if (isClass) throw ErrorMsg::fatal (name, format (SyntaxErrorMessage::UNEXPECTED_BUT_LST, name.str (), [Keys::SELF]));
                let type = if (mandType) {
                    self:.readTokens ([Tokens::COLON]);
                    self:.readExpression (level-> BinaryOperatorsLevels::__members__.len)
                } else { cast!{&Expression} (EmptyExpression::new ()) }

                let value = if (withValue) {
                    if (!(self:.readIf ([Tokens::EQUAL])._0).isEof ()) {
                        self:.readExpression (level-> level)
                    } else { cast!{&Expression} (EmptyExpression::new ()) }                    
                } else { cast!{&Expression} (EmptyExpression::new ()) }

                VarDecl::new (name, name, decos-> decos, value-> value, type-> type)
            }
        }
    }

    /**
     * Read a list of decorators
     * @verbatim: 
     * =====================
     * decorators := (Keys::REF | Keys::MUTABLE | Keys::DMUTABLE | Keys::STATIC | Keys::CTE | Keys::PURE)*
     * =====================
     */
    def readDecorators (mut self) -> [DecoratorWord] {
        let dmut res = Vec!{DecoratorWord}::new ();
        loop {
            let (x, _) = self:.readIf (Decorators::__members__);
            if (x.isEof ()) break {}
            res:.push (DecoratorWord (x, self.toDecorator (x.str ())))
        }

        res []
    }
        
    
    /**
     * ================================================================================
     * ================================================================================
     * =========================           LITERALS           =========================
     * ================================================================================
     * ================================================================================
     */
    
    /**
     * Read a namepath expression 
     * @verbatim: 
     * =============
     * namepath_expr := Identifier ('::' Identifier)* 
     * =============
     */
    def readPath (mut self) -> &Expression
        throws &ErrorMsg
    {
        let fst = self:.readIdentifier ();
        let mut res : &Expression = Var::new (fst._0);
        loop {
            let (next, _) = self:.readIf ([Tokens::DCOLON]);
            if (!next.isEof ())  {
                let af = {                    
                    let (x, _) = self:.readIf ([Keys::UNDER]);
                    if !x.isEof () { x }
                    else { self:.readIdentifier ()._0 }                        
                }
                res = PathExpr::new (next, res, Var::new (af));
            } else break {}
        }
        
        res
    }

    /**
     * Read an array literal
     * @verbatim: 
     * =================
     * array_lit := Tokens::LCRO (expression:(0) (Tokens::COMA expression:(0))*)? Tokens::RCRO
     * =================
     */
    def readArray (mut self, loc : &Word)-> &Expression
        throws &ErrorMsg        
    {
        let (n, _) = self:.readIf ([Tokens::RCRO]);
        if (n.isEof ()) return List::new (loc, n, []);

        let dmut params = Vec!{&Expression}::new ();
        params:.push (self:.readExpression ());
        let (e, _) = self:.readIf ([Tokens::SEMI_COLON, Tokens::RCRO, Tokens::COMA]);
        if (e == Tokens::SEMI_COLON) { // allocation
            let dyn = !(self:.readIf ([Keys::NEW])._0).isEof ();
            let size = self:.readExpression ();
            self:.readTokens ([Tokens::RCRO]);
            return SliceAllocator::new (loc, __pragma!trusted ({params [0us]}), size, isDynamic-> dyn)
        }

        let mut end = e;
        if (e != Tokens::RCRO) {
            loop {
                params:.push (self:.readExpression ());
                end = self:.readTokens([Tokens::RCRO, Tokens::COMA])._0;
                if (end == Tokens::RCRO) {
                    break {}
                }
            }
        }
        
        List::new (loc, end, params[])
    }

    /**
     * Read a block of code
     * @verbatim: 
     * ====================
     * 
     * ====================
     */
    def readBlock (mut self, loc : &Word, canBeCatcher : bool = false)-> &Expression
        throws &ErrorMsg
    {
        let dmut decls = Vec!{&Declaration}::new ();
        let dmut content = Vec!{&Expression}::new ();
        {
            let mut end = Word::eof ();
            let mut last = false;
            loop {
                end = self:.readIf ([Tokens::SEMI_COLON, Tokens::RACC])._0;
                if (end.isEof ()) {
                    if (!last && content.len () != 0us) {
                        if (self.needClosingExpr (content [content.len () - 1us])) {
                            let (n, _) = self._lex:.next ();
                            throw ErrorMsg::fatal (n, format (SyntaxErrorMessage::UNEXPECTED_BUT_LST, [Tokens::SEMI_COLON]));
                        }
                    }
                    
                    last = false;
                    let (d, _) = self:.readIf ([Keys::CLASS, Keys::ENUM, Keys::DEF, Keys::IMPORT, Keys::STRUCT, Keys::TRAIT]);
                    if (!d.isEof ()) {
                        self._lex:.rewind ();
                        decls:.push (self:.readDeclaration ());
                        last = true;
                    } else {
                        content:.push (self:.readExpression ());
                    }
                } else if (end == Tokens::SEMI_COLON) {
                    last = true;
                } else break {}
            }

            let (catcher, scopes) = if (canBeCatcher) {
                self:.readScopeGuards ()
            } else { (cast!{&Expression} (EmptyExpression::new ()), []) }

            if (last) content:.push (Unit::new ());
            if (decls.len () != 0us) {
                Block::new (loc, end, module-> DeclBlock::new (Word::new (Keys::UNDER, loc), ""s8, decls[]), content[], catcher-> catcher, guards-> scopes)
            } else {
                Block::new (loc, end, content[], catcher-> catcher, guards-> scopes)
            }
        } catch {
            _ : &OutOfArray => __pragma!panic ();
            err : &ErrorMsg => {
                throw err.appendNotes ([ErrorMsg::note (loc, SyntaxErrorMessage::IN_DECL_BLOCK)]);
            }
        }
    }


    /**
     * 
     */
    def readScopeGuards (mut self)-> (&Expression, [&ScopeGuard])
        //throws &ErrorMsg
    {
        let mut catcher = EmptyExpression::new ();
        let mut scopes = Vec!{&ScopeGuard}::new ();
        // loop {
        //     let (n, _) = match catcher {
        //         EmptyExpression () => { self:.readIf ([Keys::EXIT, Keys::SUCCESS, Keys::FAILURE, Keys::CATCH]) }
        //         _ => { self:.readIf ([Keys::EXIT, Keys::SUCCESS, Keys::FAILURE]) }
        //     }

        //     if (n == Keys::CATCH) {
        //         catcher = self:.readCatcher ();
        //     } else if (!n.isEof ()) {
        //         scopes:.push (ScopeGuard::new (n, self:.readBlock (canBeCatcher-> false)))
        //     } else break {}
        // }
        
        (catcher, scopes[])
    }    
    
    /**
     * Read a string literal
     */
    def readString (mut self)-> &String
        throws &ErrorMsg
    {
        throw ErrorMsg::fatal (Word::eof (), ""s8)
    }

    
    /**
     * Read an identifier from the lexer
     * @throws:
     *    - ErrorMsg: if the next token is not a valid identifier
     */
    def readIdentifier (mut self)-> (&Word, [c8])
        throws &ErrorMsg
    {
        let (ident, comm) = self._lex:.next ();
        if (!self.isIdentifier (ident.str ())) {
            throw ErrorMsg::fatal (ident, format (SyntaxErrorMessage::USED_AS_IDENTIFIER, ident.str ()));
        }

        (ident, comm)
    }

    /**
     * Read an identifier if there is an identifier to read
     * @returns: the identifier (and associated comment), or (Word::eof (), ""s8) if no identifier can be read
     */
    def readIfIdentifier (mut self)-> (&Word, [c8]) {
        let begin = self._lex.getCounter ();
        let x = self:.readIdentifier ()?
        match x {
            Ok (name:_) => { name }
            _ => {
                self._lex:.rewind (nb-> self._lex.getCounter () - begin);
                (Word::eof (), ""s8)
            }
        }
    }
    
    /**
     * @returns: true if str is a valid identifier, false otherwise
     */
    def isIdentifier (self, str : [c8])-> bool {
        if (str in self._forbiddenKeys) {
            return false;
        }

        let mut i = 0u64;
        let mut found = false;
        for j in str { // must start by a letter, but can be preceded by as many _ as wanted
            if (j >= 'a'c8 && j <= 'z'c8) || (j >= 'A'c8 && j <= 'Z'c8) {
                found = true;
                break {}
            } else if (j != '_'c8) {
                break {}
            }
            i += 1u64;
        }
        
        i += 1u64;
        if (i < str.len) { // the rest of the identifier must be composed of letters, numbers, or _
            {
                for j in str [cast!usize (i) .. $] {
                    if (j < 'a'c8 || j > 'z'c8) && (j < 'A'c8 || j > 'Z'c8) && (j != '_'c8) && (j < '0'c8 || j > '9'c8) {
                        return false;
                    }
                }
            } catch {
                _ => { return false; } // impossible
            }
            
        } else {
            if !found { // only a list of _ is not an identifier
                return false;
            }
        }
        
        true
    }


    
    /**
     * ================================================================================
     * ================================================================================
     * =========================        MISCELLANEOUS         =========================
     * ================================================================================
     * ================================================================================
     */
    
    
    /**
     * @returns: the next token inside the lexer, if it is equals to one of the token inside lst
     * @info: if none of lst token is found, the lexer is not incremented
     * @params: 
     *    - lst: a list of tokens 
     */
    def readIf (mut self, lst : [[c8]])-> (&Word, [c8]) {
        let (x, y) = self._lex:.next ();
        if (x.isEof ()) return (Word::eof (), ""s8);
        
        for i in lst {
            if i == x.str () {
                return (x, y);
            }
        }
        
        self._lex:.rewind ();
        (Word::eof (), ""s8)
    }    

    /**
     * @returns: the next token inside the lexer, if it is equals to one of the token inside lst
     * @throws: 
     *   - ErrorMsg: if none of the token in lst is equal to the token that have been read, or the next token is eof
     * @params: 
     *    - lst: a list of tokens 
     */
    def readTokens (mut self, lst : [[c8]])-> (&Word, [c8])
        throws &ErrorMsg
    {
        let (x, y) = self._lex:.next ();
        for i in lst {
            if i == x.str () {
                return (x, y);
            }
        }

        throw ErrorMsg::fatal (x, format (SyntaxErrorMessage::UNEXPECTED_BUT_LST, x.str (), lst));
    }


    /**
     * ================================================================================
     * ================================================================================
     * =========================            TESTS             =========================
     * ================================================================================
     * ================================================================================
     */
    
    /**
     * @returns: true, if this expression needs at the end, a semi colon to be separated from other expressions
     */
    def needClosingExpr (self, expr : &Expression)-> bool {
        match expr {
            a : &Atomic => { self.needClosingExpr (a.getValue ()) }
            Block () => { false }
            b : &Break => { self.needClosingExpr (b.getValue ()) }
            Conditional () => { false }
            EmptyExpression () => { false }
            ForLoop () => { false }
            Unit () => { false }
            Matcher () => { false }
            r : &Return =>  { self.needClosingExpr (r.getValue ()) }
            ScopeGuard () => { false }
            t : &Throw => { self.needClosingExpr (t.getValue ()) }
            WhileLoop () => { false }
            DisposeScope () => { false }
            _ => { true }
        }
    }
   
    /**
     * ================================================================================
     * ================================================================================
     * =========================             CONV             =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Transform a word into a protection
     * @info: if the word does not contain a protection, by default Protection::PRIVATE is returned
     */
    def toProtection (self, msg : [c8])-> Protection {
        match msg {
            Keys::PROTECTED => { Protection::PROTECTED }
            Keys::PUBLIC =>  { Protection::PUBLIC }
            _ => { Protection::PRIVATE }
        }
    }

    /**
     * Transform a word into a template var type
     * @info: if the word does not contain a template var type, by default TemplateVarType::TUPLE is returned
     */
    def toTemplateVarType (self, msg : [c8])-> TemplateVarType {
        match msg {
            Keys::ALIAS => { TemplateVarType::ALIAS }
            Keys::CLASS => { TemplateVarType::CLASS }
            Keys::STRUCT => { TemplateVarType::STRUCT }
            _ => { TemplateVarType::TUPLE }                
        }
    }

    /**
     * Transform a word into a template of var type
     * @info: if the word does not contain a template var type, by default TemplateOfVarType::IMPL is returned
     */
    def toTemplateOfVarType (self, msg : [c8])-> TemplateOfVarType {
        match msg {
            Keys::OF => { TemplateOfVarType::OF }
            Keys::OVER => { TemplateOfVarType::OVER }
            _ => { TemplateOfVarType::IMPL }                
        }
    }


    /**
     * Transform a word into a decorator
     * @info: if the word does not contain a decorator, by default Decorator::PURE is returned
     */
    def toDecorator (self, msg : [c8])-> Decorators {
        match msg {
            Keys::REF => { Decorators::REF }
            Keys::MUTABLE => { Decorators::MUT }
            Keys::DMUTABLE => { Decorators::DMUT }
            Keys::STATIC => { Decorators::STATIC }
            Keys::CTE => { Decorators::CTE }
            _ => { Decorators::PURE }                
        }
    }

    /**
     * Transform a word into an intrinsic key
     * @info: if the word does not contain a intrinsic name, by default IntrinsicKeys::DCOPY is returned
     */
    def toIntrinsic (self, msg : [c8])-> IntrinsicKeys {
        match msg {
            IntrinsicKeys::COPY => {             IntrinsicKeys::COPY }
            IntrinsicKeys::EXPAND => { IntrinsicKeys::EXPAND }
            IntrinsicKeys::TYPEOF => { IntrinsicKeys::TYPEOF }
            IntrinsicKeys::SIZEOF => { IntrinsicKeys::SIZEOF }
            IntrinsicKeys::ALIAS => { IntrinsicKeys::ALIAS }
            IntrinsicKeys::MOVE => { IntrinsicKeys::MOVE }
            _ => { IntrinsicKeys::DCOPY }
        }
    }


    

    
    
}
