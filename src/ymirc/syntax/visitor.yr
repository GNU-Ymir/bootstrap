mod ymirc::syntax::visitor;

import ymirc::syntax::errors;
import ymirc::errors::_;
import ymirc::syntax::expression::_;
import ymirc::syntax::declaration::_;
import ymirc::syntax::_;
import ymirc::lexing::_;
import ymirc::utils::_;
import ymirc::global::state;

import std::fs::_;
import std::collection::set;
import std::collection::vec;
import std::io;

import std::time::_;

static mut fulltime = dur::seconds (0us);

/**
 * This struct is used to alloc only one time the arrays of tokens, and avoid lost of perf for allocation of const arrays
 */
struct
| binaryOperators : [[[c8]]] = BinaryOperatorsLevels::__members__
| specialBinaryOperators : [[c8]] = [Keys::IS, Keys::OF, Keys::IN]
| macroMult : [[c8]] = MacroMultTokens::__members__
| unaryOperators : [[c8]] = UnaryOperators::__members__
| intrinsicKeys : [[c8]] = IntrinsicKeys::__members__
| decorators : [[c8]] = Decorators::__members__
| skipTokens : [[c8]] = SkipTokens::__members__
| stringSuffixes : [[c8]] = StringSuffixes::__members__
| charSuffixes : [[c8]] = CharSuffixes::__members__
| fixedSuffixes : [[c8]] = FixedSuffixes::__members__
| floatSuffixes : [[c8]] = FloatSuffixes::__members__
 -> SpecialKeysAndTokens;


/**
 * The syntax visitor class is the class used to transform a text content into an analyzable syntax tree
 * The syntax visitor will validated the content of the source code, but only at a syntaxic level
 */
pub class SyntaxVisitor {

    /// The lexer that is used to cut the content string in tokens
    let dmut _lex : &Lexer;

    /// The list of forbidden keys (for identifiers)
    let dmut _forbiddenKeys = HashSet!{[c8]}::new ();

    /// True iif currently reading template call expr without parentheses
    let mut _inTemplateCall = false;
    
    let _specials : SpecialKeysAndTokens;
    
    /**
     * Create a new visitor for a given file
     * @params: 
     *  - path: the path of the file to read
     */
    pub self open (path : &Path)
        with _lex = Lexer::new (path.toStr (), content-> {
            with dmut f = File::open (path) {
                f:.readAll ()
            }
        }, tokens-> Tokens::__members__, comments-> CommentTokens::__members__, skips-> SkipTokens::__members__),
    _specials = SpecialKeysAndTokens ()
        throws &FsError
    {
        for i in Tokens::members {
            self._forbiddenKeys:.insert (i);
        }

        for i in ForbiddenKeys::members {
            self._forbiddenKeys:.insert (i);            
        }
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================            MODULE            =========================
     * ================================================================================
     * ================================================================================
     */


    /**
     * Once the visitor is initialized, (with open for instance) 
     * the content can be read an transformed into a syntax tree
     * @example: 
     * =================
     * let dmut visitor = Visitor::open (Path::new ("foo.yr"));
     * { 
     *    // verify the grammar of the content of the file
     *    // And return it into a syntax tre
     *    let module = visitor:.read (); 
     *    println (format ("%"s8, module)); // pretty print the module that has been read
     * } catch {
     *    err : &ErrorMsg => {
     *          println (format ("%"s8, err)); // print the error that occured inside the file
     *    }
     * }
     * =================
     */    
    pub def read (mut self)-> &ModuleDecl
        throws &ErrorMsg
    {
        let (loc, path, comm) = self:.readGlobalPath ();
        ModuleDecl::new (loc, path, comm, self:.readBlockDecl (loc, comm), isGlobal-> true)
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================      DECLARATION BLOCKS      =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Read the first declaration line of the module (if any), and return the declared path
     * @returns: 
     *    - the path, or Unit if nothing was found was found
     *    - the comments above the path
     */
     def readGlobalPath (mut self) -> (&Word, &Expression, [c8])
        throws &ErrorMsg
    {
        let beginPos = self._lex.getCounter ();
        
        let (next, comm) = self._lex:.next ();
        if (next != Keys::MOD) {
            self._lex:.rewindTo (nb-> beginPos);
            return (next, cast!(&Expression) (const UnitExpr::new ()), ""s8);
        }
        
        let path = self:.readPath ();
        if (!(self:.readIf (Tokens::LACC)._0).isEof ()) {
            self._lex:.rewindTo (nb-> beginPos);
            (next, cast!(&Expression) (const UnitExpr::new ()), ""s8)
        } else {
            self:.readIf (Tokens::SEMI_COLON);
            (next, path, comm)
        }
    }

    /**
     * Read a set of declaration in a global module (or in a global sub symbol, such as local module, protection block, etc.)
     * @verbatim: 
     * ===================
     * decl_block := declaration | protection_block | version_block
     * ===================
     * @params: 
     *     - close: if false, then the reading stops when the token eof () is found
     *              , otherwise it stops when the token Tokens::RACC is found
     */
    def readBlockDecl (mut self, loc : &Word, comm : [c8], closing : bool = false, protection : Protection = Protection::PRIVATE, inProtection : bool = false) -> &BlockDecl
        throws &ErrorMsg    
    {        
        let dmut decls = Vec!(&Declaration)::new ();
        loop {
            let beginCur = self._lex.getCounter ();
            let (tok, comm_) = self._lex:.next ();
            if (closing && tok.str () == Tokens::RACC) break {}
            if (!tok.isEof ()) self._lex:.rewindTo (nb-> beginCur);
            
            match tok.str () {
                Keys::PUBLIC | Keys::PRIVATE => {
                    if (inProtection) {
                        decls:.push (self:.readDeclaration ());
                    } else {
                        decls:.push (self:.readProtectionBlock ());
                    }
                }
                Keys::VERSION =>
                    decls:.push (self:.readVersionBlock (protection-> protection));
                Tokens::LACC => {
                    self._lex:.next ();
                    decls:.push (self:.readBlockDecl (tok, comm_, closing-> true, protection-> protection, inProtection-> inProtection));
                }
                _ => {
                    if !tok.isEof () {
                        decls:.push (self:.readDeclaration ());
                    } else if (!closing) break {}
                    else throw ErrorMsg::fatal (tok, SyntaxErrorMessage::BLOCK_NEVER_CLOSED);
                }
            }            
        }
        
        BlockDecl::new (loc, comm, decls [], protection-> protection)
    }

    /**
     * Read a protection block
     * @verbatim: 
     * ===============
     * protection_block :=   (Keys::PRIVATE | Keys::PUBLIC) Tokens::LACC decl_block Tokens::RACC
     *                     | (Keys::PRIVATE | Keys::PUBLIC) declaration
     * ===============
     */
    def readProtectionBlock (mut self) -> &BlockDecl
        throws &ErrorMsg
    {
        let (loc, comm) = self:.readIf (Keys::PRIVATE, Keys::PUBLIC);
        {
            let protection = if (loc.str () == Keys::PRIVATE) { Protection::PRIVATE } else { Protection::PUBLIC };
            let (tok, _) = self:.readIf (Tokens::LACC);
            if (tok.isEof ()) {
                BlockDecl::new (loc, comm, [self:.readDeclaration ()], protection-> protection)
            } else {
                self:.readBlockDecl (loc, comm, closing-> true, protection-> protection, inProtection-> true)
            }
        } catch {
            err : &ErrorMsg => {
                throw ErrorMsg::note (loc, SyntaxErrorMessage::IN_DECL_BLOCK, notes-> [err]);
            }
        }
    }


    /**
     * Visit a version block
     * @verbatim: 
     * ================
     * version_block := Keys::VERSION Tokens::LACC decl_block Tokens::RACC (else Tokens::LACC decl_block Tokens::RACC)?
     * ================
     */
    def readVersionBlock (mut self, protection : Protection = Protection::PRIVATE, inProtection : bool = false)-> &BlockDecl
        throws &ErrorMsg
    {
        let (loc, comm) = self._lex:.next ();
        {
            let (v, _) = self:.readIdentifier ();
            return if state::instance ().isVersionActive (v.str ()) {
                self:.readTokens (Tokens::LACC);
                let block = self:.readBlockDecl (loc, comm, closing-> true, protection-> protection, inProtection-> inProtection);
                if (!(self:.readIf (Keys::ELSE)._0).isEof ())
                    self:.ignoreBlock ();
                block
            } else {
                self:.ignoreBlock ();
                if (!(self:.readIf (Keys::ELSE)._0).isEof ()) {
                    self:.readTokens (Tokens::LACC);
                    self:.readBlockDecl (loc, comm, closing-> true, protection-> protection, inProtection-> inProtection)
                } else {
                    BlockDecl::new (loc, comm, [])
                }
            } ;       
        } catch {
            err : &ErrorMsg => {
                throw err.appendNotes ([ErrorMsg::note (loc, SyntaxErrorMessage::IN_DECL_BLOCK)]);
            }
        }
    }

    /**
     * Ignore a block of element (no matters what is inside)
     * Basically, it can be used to consider the next block of code as a comment 
     * A block is enclosed by Tokens::LACC and Tokens::RACC
     */
    def ignoreBlock (mut self)
        throws &ErrorMsg
    {
        let _ = self:.readTokens (Tokens::LACC);
        let mut nb = 1u64;
        loop {
            let (next, _) = self._lex:.next ();
            if (next == Tokens::RACC) {
                nb -= 1u64;
                if (nb == 0u64) 
                    break {}                
            } else if (next == Tokens::LACC) nb += 1u64;
            else if (next.isEof ())
            throw ErrorMsg::fatal (next, SyntaxErrorMessage::UNTERMINATED_BLOCK);
        }
    }
    /**
     * Read a declaration
     * @verbatim:
     * ==================
     * decl :=   aka_decl
     *         | class_decl
     *         | enum_decl
     *         | func_decl
     *         | static_decl
     *         | import_decl
     *         | extern_decl
     *         | macro_decl
     *         | mod_decl
     *         | struct_decl
     *         | trait_decl
     *         | unittest
     * ==================
     */
    def readDeclaration (mut self)-> &Declaration
        throws &ErrorMsg
    {
        let (tok, comm) = self._lex:.next ();
        match tok.str () {
            Keys::AKA    => { return self:.readAka (tok, comm); }
            Keys::CLASS  => { return self:.readClass (tok, comm); }
            Keys::ENUM   => { return self:.readEnum (tok, comm); }
            Keys::DEF    => { return self:.readFunction (tok, comm); }
            Keys::LAZY   => { return self:.readGlobal (tok, comm); }
            Keys::IMPORT => { return self:.readImport (tok, comm); }
            Keys::EXTERN => { return self:.readExtern (tok, comm); }
            Keys::MACRO  => { return self:.readMacro (tok, comm); }
            Keys::MOD    => { return self:.readLocalModuleDecl (tok, comm); }
            Keys::STRUCT => { return self:.readStruct (tok, comm); }
            Keys::TRAIT  => { return self:.readTrait (tok, comm); }
            Keys::UNITTEST => { return self:.readUnitTest (tok, comm); }
            _ => {
                throw ErrorMsg::fatal (tok, format (SyntaxErrorMessage::UNEXPECTED_BUT_LST, tok.str (),
                                                    [Keys::AKA, Keys::CLASS, Keys::ENUM, Keys::LAZY,
                                                     Keys::IMPORT, Keys::EXTERN, Keys::MACRO, Keys::MOD,
                                                     Keys::STRUCT, Keys::TRAIT])
                                      );
            }
        }
    }


    /**
     * ================================================================================
     * ================================================================================
     * =========================             AKA              =========================
     * ================================================================================
     * ================================================================================
     */
    
    /**
     * Read an aka declaration
     * @verbatim: 
     * ===============
     * aka_decl :=   Keys::AKA Keys::IF expression:(0) Identifier template_param_list Tokens::EQUAL expression:(0)
     *             | Keys::AKA Identifier (template_param_list)? Tokens::EQUAL expression:(0)
     * ===============
     */
    def readAka (mut self, _ : &Word, comm : [c8])-> &Declaration
        throws &ErrorMsg
    {
        let (hasTest, test) = self:.readTemplateTest ();        
        let (ident, _) = self:.readIdentifier ();
        let templates = self:.readTemplateParameters (ifLoc-> hasTest);
        
        self:.readTokens (Tokens::EQUAL);
        let value = self:.readExpression ();
        self:.readIf (Tokens::SEMI_COLON);

        if (templates.len == 0us) {
            AkaDecl::new (ident, comm, value)            
        } else {
            TemplateDecl::new (ident, comm, templates, AkaDecl::new (ident, comm, value), test-> test)            
        }
    }


    /**
     * ================================================================================
     * ================================================================================
     * =========================            CLASS             =========================
     * ================================================================================
     * ================================================================================
     */
    
    /**
     * Read a class declaration
     * @verbatim: 
     * ===============
     * class_decl :=   Keys::CLASS Keys::IF expression:(0) (attribute_list)? Identifier template_param_list (Keys::OVER expression:(0))? class_block_decl
     *               | Keys::CLASS (attributes_list)? Identifier (template_param_list)? (Keys::OVER expression:(0))? class_block_decl
     * ===============
     */
    def readClass (mut self,  _ : &Word, comm : [c8])-> &Declaration
        throws &ErrorMsg
    {
        let (hasTest, test) = self:.readTemplateTest ();
        let attribs = self:.readAttributes ();
        let (ident, _) = self:.readIdentifier ();
        let templates = self:.readTemplateParameters (ifLoc-> hasTest);

        let ancestor =
            if (self:.readIf (Keys::OVER)._0).isEof () {
                EmptyExpression::new ()
            } else {
                self:.readExpression ()
            };

        let (open, _) = self:.readTokens (Tokens::LACC);
        let decls = {
            self:.readClassBlockDecl (closing-> true)
        } catch {
            err : &ErrorMsg => {
                throw err.appendNotes ([ErrorMsg::note (open, SyntaxErrorMessage::IN_DECL_BLOCK)]);
            }
        }
        
        let cls = ClassDecl::new (ident, comm, decls, attrs-> attribs, ancestor-> ancestor);

        if (templates.len == 0u64) {
            cls
        } else {
            TemplateDecl::new (ident, comm, templates, cls, test-> test)
        }
    }

    /**
     * Read the inner part of a class declaration
     * @verbatim: 
     * ================
     * class_block_decl :=   (Keys::PUBLIC | Keys::PRIVATE | Keys::PROTECTED) class_block_decl
     *                     | Keys::VERSION Identifier class_block_decl (Keys::ELSE class_block_decl)?
     *                     | Keys::CTE Keys::IF expression:(0) class_block_decl (Keys::ELSE class_block_decl)?
     *                     | class_inner_declaration*
     * ================
     * @params: 
     *     - close: if false, then the reading stops after the first declaration, otherwise it stops when the token Tokens::RACC is found
     */
    def readClassBlockDecl (mut self, closing : bool = false, inProtection : bool = false)-> [&Declaration]
        throws &ErrorMsg
    {
        let dmut vec = Vec!(&Declaration)::new ();
        loop {
            let (next, comm) = self._lex:.next ();
            match next.str () {
                Keys::PRIVATE | Keys::PUBLIC | Keys::PROTECTED  => {
                    if (inProtection) throw ErrorMsg::fatal (next, format (SyntaxErrorMessage::UNEXPECTED, next.str ()));
                    let inner = {
                        if ((self:.readIf (Tokens::LACC)._0).isEof ()) {
                            let (d, c) = self._lex:.next ();
                            [self:.readClassInnerDecl (d, c, inProtection-> true)]
                        } else {
                            self:.readClassBlockDecl (closing-> true, inProtection-> true)
                        }
                    }  catch {
                        err : &ErrorMsg => {
                            throw err.appendNotes ([ErrorMsg::note (next, SyntaxErrorMessage::IN_DECL_BLOCK)]);
                        }
                    }
                    vec:.push (BlockDecl::new (next, comm, inner, protection-> self.toProtection (next.str ())));
                }                
                Keys::VERSION => {
                    vec:.push (self:.readVersionClass (next, comm, inProtection-> inProtection));
                }
                Keys::CTE => {
                    vec:.push (self:.readIfClass (next, comm, inProtection-> inProtection));
                }
                Tokens::LACC => {
                    if (closing) throw ErrorMsg::fatal (next, format (SyntaxErrorMessage::UNEXPECTED_BUT_LST, next.str (), [Keys::PUBLIC, Keys::PROTECTED, Keys::PRIVATE]));
                    else {
                        let r = self:.readClassBlockDecl (closing-> true, inProtection-> inProtection);
                        for i in r { vec:.push (i); }
                    }
                }
                Tokens::RACC => {
                    if (closing) break {}
                    else throw ErrorMsg::fatal (next, format (SyntaxErrorMessage::UNEXPECTED_BUT_LST, next.str (), [Keys::PUBLIC, Keys::PROTECTED, Keys::PRIVATE]));
                }                
                _ => {
                    vec:.push (self:.readClassInnerDecl (next, comm, inProtection-> inProtection));
                }
            }
            
            if (!closing) {
                break {}
            }
        }

        
        vec:.fit ();
        vec []
    }

    /**
     * Read a version inside a class definition
     * @verbatim:
     * ===================
     * version_class := __version Identifier class_block_decl ('else' class_block_decl)?
     * ===================
     * @params: 
     *   - inProtection: impl and import cannot be under protected declarators, and must be declared at root level of the class
     */
    def readVersionClass (mut self, loc : &Word, comm : [c8], inProtection : bool = false)-> &Declaration
        throws &ErrorMsg
    {       
        let (v, _) = self:.readIdentifier ();
        return if state::instance ().isVersionActive (v.str ()) {
            self:.readTokens (Tokens::LACC);
            let block = self:.readClassBlockDecl (closing-> true, inProtection-> inProtection);
            if (!(self:.readIf (Keys::ELSE)._0).isEof ()) {
                self:.ignoreBlock ();
            }
            
            BlockDecl::new (loc, comm, block)
        } else {
            self:.ignoreBlock ();
            if (!(self:.readIf (Keys::ELSE)._0).isEof ()) {
                self:.readTokens (Tokens::LACC);
                let block = self:.readClassBlockDecl (closing-> true, inProtection-> inProtection);
                BlockDecl::new (loc, comm, block)
            } else {
                BlockDecl::new (loc, comm, [])
            }
        }        
    }

    /**
     * Read a if condition or assert inside a class definition
     * @verbatim: 
     * ================
     * if_class := Keys::CTE (Keys::IF expression block (Keys::ELSE block)?) | (Keys::ASSERT Tokens::LPAR expression (Tokens::COMA expression)? Tokens::RPAR ) 
     * ================
     */
    def readIfClass (mut self, loc : &Word, comm : [c8], inProtection : bool = false)-> &Declaration
        throws &ErrorMsg
    {
        let (a, _) = self:.readTokens (Keys::IF, Keys::ASSERT);
        match a.str () {
            Keys::IF => {
                let test = self:.readExpression ();
                let fst = self:.readClassBlockDecl (closing-> false, inProtection-> inProtection);
                let (next, ncomm) = self:.readIf (Keys::ELSE);
                if (next == Keys::ELSE) {
                    let scd = self:.readClassBlockDecl (closing-> false, inProtection-> inProtection);                    
                    CondBlockDecl::new (loc, comm, fst, test, else_-> BlockDecl::new (next, ncomm, scd))
                } else {                
                    CondBlockDecl::new (loc, comm, fst, test)
                }
            }
            _ => {
                self:.readTokens (Tokens::LPAR);
                let test = self:.readExpression ();
                let msg : &Expression = if (self:.readTokens (Tokens::RPAR, Tokens::COMA)._0 == Tokens::COMA) {
                    let msg_ : &Expression = self:.readExpression ();
                    self:.readTokens (Tokens::RPAR);
                    msg_
                } else { cast!{&Expression} (EmptyExpression::new ()) }
                self:.readIf (Tokens::SEMI_COLON);
                
                ExpressionWrapperDecl::new (loc, comm, AssertExpr::new (loc, test, msg))                
            }
        }
    }
   
    /**
     * Read a declaration inside a class definition
     * @verbatim: 
     * ===============
     * class_inner_decl :=   constructor 
     *                     | function
     *                     | field
     *                     | impl (if !inProtection)
     *                     | import (if !inProtection)
     * ===============
     * @params: 
     *    - inProtection: impl and import cannot be under protected declarators, and must be declared at root level of the class
     */
    def readClassInnerDecl (mut self, loc : &Word, comm : [c8], inProtection : bool = false)-> &Declaration
        throws &ErrorMsg
    {        
        match loc {
            Keys::SELF => { return self:.readClassConstructor (loc, comm); }
            Keys::DEF  => { return self:.readFunction (loc, comm, isMethod-> true); }
            Keys::OVER => { return self:.readFunction (loc, comm, isMethod-> true, isOver-> true); }
            Keys::LET  => { return self:.readGlobal (loc, comm, isField-> true); }
            Keys::IMPL => {
                if (inProtection) {
                    throw ErrorMsg::warn (loc, SyntaxErrorMessage::IMPL_IN_PROTECTION);
                }
                return self:.readImplement (loc, comm);
            }
            Keys::IMPORT => {
                if (inProtection) {
                    throw ErrorMsg::warn (loc, SyntaxErrorMessage::IMPORT_IN_PROTECTION);
                }
                return self:.readImport (loc, comm);
            }
            Keys::DTOR => {
                if (inProtection) {
                    throw ErrorMsg::warn (loc, SyntaxErrorMessage::DESTRUCTOR_IN_PROTECTION);
                }
                return self:.readClassDestructor (loc, comm);
            }
            _ => {
                if inProtection {
                    throw ErrorMsg::fatal (loc, format (SyntaxErrorMessage::UNEXPECTED_BUT_LST, loc.str (), [
                        Keys::SELF, Keys::DEF, Keys::OVER, Keys::LET
                    ]));
                } else {                    
                    throw ErrorMsg::fatal (loc, format (SyntaxErrorMessage::UNEXPECTED_BUT_LST, loc.str (), [
                        Keys::SELF, Keys::DEF, Keys::OVER, Keys::LET, Keys::IMPL, Keys::IMPORT, Keys::DTOR
                    ]));
                }
            }
        }
    }
    
    /**
     * Read a class constructor
     * @verbatim: 
     * ================
     * constructor :=   Keys::SELF Keys::IF expression:(0) (attribs)? (Identifier)? template_param_list param_list (with_decl)? (throws_decl)? expression:(0)
     *                | Keys::SELF (attribs)? (Identifier)? (template_param_list)? param_list (with_decl)? (throws_decl)? expression:(0)
     * ================
     */
    def readClassConstructor (mut self, loc : &Word, comm : [c8]) -> &Declaration
        throws &ErrorMsg
    {
        let (hasTest, test) = self:.readTemplateTest ();
        let attribs = self:.readAttributes ();
        let (name, _) = self:.readIfIdentifier ();
        let templates = self:.readTemplateParameters (ifLoc-> hasTest);
                 
        let proto = self:.readFunctionPrototype ();
        
        let dmut construction = Vec!{(&Word, &Expression)}::new ();
        let mut supers : [&Expression] = [];
        let mut auxCstrLoc = EOF_WORD;
        if (!(self:.readIf (Keys::WITH)._0).isEof ()) {
            loop {
                let (next, _) = self._lex:.next ();
                match next.str () {
                    Keys::SUPER | Keys::SELF => {
                        if (!auxCstrLoc.isEof ()) 
                            throw ErrorMsg::fatal (next, SyntaxErrorMessage::MULTIPLE_AUX_CSTRS, notes-> [ErrorMsg::note (auxCstrLoc, ""s8)]);
                                                
                        auxCstrLoc = next;
                        self:.readTokens (Tokens::LPAR);
                        supers = self:.readArgumentList (withNamed-> true)._0;
                    }
                    _ => {
                        if (!self.isIdentifier (next.str ())) 
                            throw ErrorMsg::fatal (next, format (SyntaxErrorMessage::USED_AS_IDENTIFIER, next.str ()));
                        
                        self:.readTokens (Tokens::EQUAL);
                        construction:.push ((next, self:.readExpression ()));
                    }
                }
                
                if ((self:.readIf (Tokens::COMA)._0).isEof ()) {
                    break {}
                }
            }
        }

        let (throwLoc, throwers) = self:.readThrowers ();
        let body = self:.readExpression ();

        let cstr = ConstructorDecl::new (loc, comm, rename-> name, proto, superParams-> supers, fields-> construction[], body-> body, explicitCstrsCall-> auxCstrLoc, attributes-> attribs, throwers-> throwers, throwerLoc-> throwLoc);
        
        if (templates.len != 0u64) {
            TemplateDecl::new (loc, comm, templates, cstr, test-> test)
        } else {
            cstr
        }
    }

    /**
     * Read class destructor
     * @verbatim: 
     * ================
     * destructor := Keys::DTOR Tokens::LPAR Keys::MUT Keys::SELF Tokens::RPAR expression:(0)
     * ================
     */
    def readClassDestructor (mut self, loc : &Word, comm : [c8])-> &Declaration
        throws &ErrorMsg
    {
        self:.readTokens (Tokens::LPAR);
        let var = self:.readSingleVarDeclaration (mandType-> false, withValue-> false, isClass-> true);
        self:.readTokens (Tokens::RPAR);

        let content = self:.readExpression ();
        DestructorDecl::new (loc, comm, var, content)
    }    

    /**
     * ================================================================================
     * ================================================================================
     * =========================          IMPLEMENT           =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Read an implementation of traits inside a class definition
     * @verbatim: 
     * ==================
     * impl := Keys::IMPL expression:(0) (((',' expression:(0))* ';') | class_block_decl)
     * ==================
     */
    def readImplement (mut self, loc : &Word, comm : [c8]) -> &Declaration
        throws &ErrorMsg
    {
        let trait_ = self:.readExpression ();
        let (next, _) = self:.readIf (Tokens::SEMI_COLON, Tokens::COMA, Tokens::LACC);
        if (next == Tokens::LACC) {
            let content = self:.readClassBlockDecl (inProtection-> false, closing-> true);
            ImplDecl::new (loc, comm, trait_, content-> content)
        } else if (next == Tokens::COMA) {
            let dmut impls = Vec!{&Declaration}::new ();
            impls:.push (ImplDecl::new (loc, comm, trait_));
            loop {
                let tr = self:.readExpression ();
                let (n, _) = self:.readTokens (Tokens::SEMI_COLON, Tokens::COMA);
                impls:.push (ImplDecl::new (loc, comm, tr));
                if (n == Tokens::SEMI_COLON) break {}
            }
            BlockDecl::new (loc, comm, impls[])
        } else {
            ImplDecl::new (loc, comm, trait_)
        }
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================             ENUM             =========================
     * ================================================================================
     * ================================================================================
     */


    /**
     * Read an enumeration definition
     * @verbatim: 
     * =======================
     * enum_decl :=   Keys::ENUM Keys::IF expression:(0) enum_content Keys::ARROW Identifier template_param_list (Tokens::SEMI_COLON)?
     *              | Keys::ENUM enum_content Keys::ARROW Identifier (Tokens::SEMI_COLON)?
     * 
     * enum_content := (Tokens::PIPE Identifier ('=' expression:(0))?)*
     * =======================
     */
    def readEnum (mut self,  loc : &Word, comm : [c8])-> &Declaration
        throws &ErrorMsg
    {
        let (hasTest, test) = self:.readTemplateTest ();

        let type = if (!((self:.readIf (Tokens::COLON))._0).isEof ()) {
            self:.readOperand3 ()
        } else { cast!{&Expression} (EmptyExpression::new ()) }

        let dmut values = Vec!{&VarDeclExpr}::new ();
        let dmut coms = Vec!{[c8]}::new ();
        let mut fst = true;
        loop {
            let (n, com) = self:.readTokens (Tokens::PIPE, Tokens::ARROW);
            if (!fst) coms:.push (com);

            if (n != Tokens::ARROW) {
                let (name, _) = self:.readIdentifier ();
                if (!(self:.readIf (Tokens::EQUAL)._0).isEof ()) {
                    values:.push (VarDeclExpr::new (name, name, value-> self:.readExpression (level-> self._specials.binaryOperators.len), type-> EmptyExpression::new ()))
                } else {
                    values:.push (VarDeclExpr::new (name, name, value-> EmptyExpression::new (), type-> EmptyExpression::new ()))
                }
            } else break {}
            fst = false;
        }

        let (name, _) = self:.readIdentifier ();
        let templates = self:.readTemplateParameters (ifLoc-> hasTest);
        self:.readIf (Tokens::SEMI_COLON);
        
        if (templates.len == 0us) {
            EnumDecl::new (name, comm, type-> type, values-> values[], fieldComms-> coms[])
        } else {
            TemplateDecl::new (loc, comm, templates, test-> test, content->
                           EnumDecl::new (name, comm, type-> type, values-> values[], fieldComms-> coms[])
                           )
        }
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================           FUNCTION           =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Read a function definition
     * @verbatim: 
     * ====================
     * function :=   Keys::IF expression:(0) Identifier template_param_list function_proto throwers body
     *             | Identifier function_proto throwers body
     * ====================
     */
    def readFunction (mut self,  _ : &Word, comm : [c8], isMethod : bool = false, isOver : bool = false)-> &Declaration
        throws &ErrorMsg
    {
        let (hasTest, test) = self:.readTemplateTest ();
        let attribs = self:.readAttributes ();
        let (name, _) = self:.readIdentifier ();
        if (name == Keys::SELF) throw ErrorMsg::fatal (name, format (SyntaxErrorMessage::USED_AS_IDENTIFIER, name.str ()));
        let templates = self:.readTemplateParameters (ifLoc-> hasTest);

        let proto = self:.readFunctionPrototype (isClosure-> false, isClass-> isMethod);
        let (throwLoc, throwers) = self:.readThrowers ();
        let body = self:.readFunctionBody ();
        
        if (templates.len == 0us) {
            FunctionDecl::new (name, comm, proto, body, attrs-> attribs, throwers-> throwers, isOver-> isOver, throwerLoc-> throwLoc)
        } else {
            TemplateDecl::new (name, comm, templates, test-> test, content-> 
                           FunctionDecl::new (name, comm, proto, body, attrs-> attribs, throwers-> throwers, isOver-> isOver, throwerLoc-> throwLoc)
                           )
        }       
    }

    /**
     * Read a function body
     * @verbatim: 
     * ===================
     * body := ';' | expression:(0)
     * ===================
     */
    def readFunctionBody (mut self)-> &Expression
        throws &ErrorMsg
    {
        if ((self:.readIf (Tokens::SEMI_COLON)._0).isEof ()) {
            self:.readExpression () 
        } else {
            cast!{&Expression} (EmptyExpression::new ())
        }
    }
    
    /**
     * Read a function prototype
     * @verbatim: 
     * ====================
     * closure_proto := Tokens::PIPE (var_decl (',' var_decl)*)? Tokens::PIPE (Tokens::ARROW expression:(0))? 
     * function_proto := Tokens::LPAR (var_decl (',' var_decl)*)? Tokens::RPAR (Tokens::ARROW expression:(0))?  
     * ====================
     */
    def readFunctionPrototype (mut self, isClosure : bool = false, isClass : bool = false)-> &FunctionProtoDecl
        throws &ErrorMsg
    {
        let (loc, hasParams) = if isClosure {
            let (n, _) = self:.readTokens (Tokens::PIPE, Tokens::DPIPE);
            (n, n == Tokens::PIPE)
        } else { (self:.readTokens (Tokens::LPAR)._0, true) }

        let mut isVariadic = false;
        let dmut params = Vec!{&Expression}::new ();
        if hasParams {
            loop {
                if (isClosure) {
                    if ((self:.readIf (Tokens::PIPE)._0).isEof ()) {
                        params:.push (self:.readSingleVarDeclaration (mandType-> false, withValue-> false, isClass-> false));
                        if ((self:.readTokens (Tokens::PIPE, Tokens::COMA)._0) == Tokens::PIPE) break {}
                    } else break {}
                } else {
                    let tok = if (!isClass || params.len () > 0us) {
                        self:.readIf (Tokens::RPAR, Tokens::TDOT)._0
                    } else { EOF_WORD }
                    
                    if (tok == Tokens::TDOT) {
                        isVariadic = true;
                        self:.readTokens (Tokens::RPAR);
                        break {}
                    } else if (tok != Tokens::RPAR) {
                        params:.push (self:.readSingleVarDeclaration (mandType-> true, withValue-> true, isClass-> (isClass && params.len () == 0us)));
                        if ((self:.readTokens (Tokens::RPAR, Tokens::COMA)._0) == Tokens::RPAR) break {}
                    } else break {}
                }
            }
        }
        
        if (!(self:.readIf (Tokens::ARROW)._0).isEof ()) {
            FunctionProtoDecl::new (loc, params-> params [], retType-> self:.readExpression (), isVariadic-> isVariadic, forLambda-> isClosure)
        } else {
            FunctionProtoDecl::new (loc, params-> params [], retType-> EmptyExpression::new (), isVariadic-> isVariadic, forLambda-> isClosure)
        }       
    }

    /**
     * Read the list of throwers of a function 
     * @verbatim:
     * ====================
     * throwers: (Keys::THROWS expression:(0) (',' expression:(0))*)? 
     * ====================
     */
    def readThrowers (mut self)-> (&Word, [&Expression])
        throws &ErrorMsg
    {
        let (th, _) = self:.readIf (Keys::THROWS);
        let dmut res = Vec!{&Expression}::new ();
        if (!th.isEof ()) {
            loop {
                res:.push (self:.readExpression ());
                let (n, _) = self:.readIf (Tokens::COMA);
                if (n.isEof ()) break {}
            }
        }
        
        (th, res[])
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================            GLOBAL            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Read a global var declaration
     * @verbatim:
     * ====================
     * global := var_decl
     * ====================
     */
    def readGlobal (mut self,  loc : &Word, comm : [c8], isField : bool = false)-> &GlobalDecl
        throws &ErrorMsg
    {        
        let glb = GlobalDecl::new (loc, comm, self:.readSingleVarDeclaration (mandType-> false, withValue-> true, isClass-> false), isField-> isField);
        self:.readTokens (Tokens::SEMI_COLON);

        glb
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================            IMPORT            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Read an import declaration
     * @verbatim: 
     * ====================
     * import: Keys::IMPORT inner_import (Tokens::COMA inner_import)* (Tokens::SEMI_COLON)?
     * inner_import = path (Keys::AS Identifier)
     * ====================
     */
    def readImport (mut self,  loc : &Word, comm : [c8])-> &Declaration
        throws &ErrorMsg
    {
        let dmut imports = Vec!{&Declaration}::new ();
        loop {
            let space = self:.readPath ();
            let as_ = if (!(self:.readIf (Keys::AS)._0).isEof ()) {
                self:.readIdentifier ()._0
            } else { EOF_WORD }

            imports:.push (ImportDecl::new (loc, comm, space, as_-> as_));
            
            if (self:.readIf (Tokens::COMA)._0.isEof ()) break {}
        }

        self:.readIf (Tokens::SEMI_COLON);

        BlockDecl::new (loc, comm, imports[])
    }


    /**
     * ================================================================================
     * ================================================================================
     * =========================            EXTERN            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Read an extern declaration
     * @verbatim: 
     * ====================
     * extern: Keys::EXTERN (Tokens::LPAR Language (Tokens::COMA path)? Tokens::RPAR)? decl_block
     * ====================
     */
    def readExtern (mut self,  loc : &Word, comm : [c8])-> &ExternBlockDecl
        throws &ErrorMsg
    {
        let (n, _) = self:.readIf (Tokens::LPAR);
        let (language, space) = if (!n.isEof ()) {
            let (l, _) = self:.readTokens (Keys::CLANG, Keys::CPPLANG, Keys::DLANG, Keys::YLANG);
            let space = if (!(self:.readIf (Tokens::COMA)._0).isEof ()) {
                self:.readPath ()
            } else { cast!{&Expression} (EmptyExpression::new ()) }
            self:.readTokens (Tokens::RPAR);
            (l, space)
        } else { (Word::new (Keys::YLANG, loc), cast!{&Expression} (EmptyExpression::new ())) }

        let (tok, _) = self:.readIf (Tokens::LACC);
        if (tok.isEof ()) {
            ExternBlockDecl::new (loc, comm, language, space, self:.readDeclaration ())
        } else {
            ExternBlockDecl::new (loc, comm, language, space, self:.readBlockDecl (loc, comm, closing-> true, inProtection-> true))
        }
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================            MACRO             =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Read a macro declaration
     * @verbatim: 
     * ==================
     * macro := Keys::MACRO Identifier macro_block
     * ==================
     */
    def readMacro (mut self,  _ : &Word, comm : [c8])-> &MacroDecl
        throws &ErrorMsg
    {
        let (name, _) = self:.readIdentifier ();
        self:.readTokens (Tokens::LACC);
        MacroDecl::new (name, comm, self:.readMacroBlock (closing-> true, inPub-> false))
    }



    /**
     * Read the content of a macro
     * @verbatim: 
     * =================
     * macro_block := Tokens::LACC (public_macro_block | version_macro_block)* Tokens::RACC
     * =================
     */
    def readMacroBlock (mut self, closing : bool = true, inPub : bool = false) -> [&Declaration]
        throws &ErrorMsg
    {
        let dmut decls = Vec!{&Declaration}::new ();
        loop {
            let (n, comm) = if (closing) {
                if (inPub) {
                    self:.readIf (Keys::VERSION, Tokens::RACC, Tokens::LACC, Keys::IMPORT)
                } else {
                    self:.readIf (Keys::PUBLIC, Keys::VERSION, Tokens::RACC, Tokens::LACC, Keys::IMPORT)
                }
            } else {
                if (inPub) { self:.readIf (Keys::VERSION, Tokens::LACC, Keys::IMPORT) }
                else { self:.readIf (Keys::PUBLIC, Keys::VERSION, Tokens::LACC, Keys::IMPORT) }
            }
            
            match n {
                Keys::PUBLIC => {
                    let block = self:.readMacroBlock (closing-> false, inPub-> true);                    
                    decls:.push (BlockDecl::new (n, comm, block, protection-> Protection::PUBLIC));
                    if (!closing) break {}
                }
                Keys::VERSION => {
                    decls:.push (self:.readVersionMacroBlock (n, comm, inPub));
                    if (!closing) break {}
                }
                Keys::IMPORT => {
                    decls:.push (self:.readImport (n, comm));
                    if (!closing) break {}
                }
                Tokens::RACC => {
                    // Necessary closing, otherwise it would not have been read
                    break {}
                }
                Tokens::LACC => {
                    let inner = self:.readMacroBlock (closing-> true, inPub-> inPub);
                    for r in inner {
                        decls:.push (r);
                    }
                    if (!closing) break {}
                }
                _ => {
                    decls:.push (self:.readMacroContent ());
                    if (!closing) break {}
                }
            }
        }
        
        decls []
    }

    /**
     * Visit a version part of a macro block
     * @verbatim: 
     * ======================
     * version_macro_block := Keys::VERSION Identifier macro_block (Keys::ELSE macro_block)
     * ======================
     */
    def readVersionMacroBlock (mut self, loc : &Word, comm : [c8], inPub : bool)-> &Declaration
        throws &ErrorMsg
    {
        let (ident, _) = self:.readIdentifier ();
        if (state::instance ().isVersionActive (ident.str ())) {
            let decls = self:.readMacroBlock (closing-> false, inPub-> inPub);
            if (!(self:.readIf (Keys::ELSE)._0).isEof ()) {
                self:.ignoreBlock ();
            }

            BlockDecl::new (loc, comm, decls, protection-> if (inPub) Protection::PUBLIC else Protection::PRIVATE)
        } else {
            self:.ignoreBlock ();
            if (!(self:.readIf (Keys::ELSE)._0).isEof ()) {
                let decls = self:.readMacroBlock (closing-> false, inPub-> inPub);
                BlockDecl::new (loc, comm, decls, protection-> if (inPub) Protection::PUBLIC else Protection::PRIVATE)
            } else {
                BlockDecl::new (loc, comm, [])
            }
        }
    }

    /**
     * Read the content of a macro definition
     * @verbatim: 
     * =================
     * marco_content := macro_constructor | macro_rule
     * =================
     */
    def readMacroContent (mut self) -> &Declaration
        throws &ErrorMsg
    {
        let (type, comm) = self:.readTokens (Keys::DEF, Keys::SELF);
        match type {
            Keys::DEF => {
                self:.readMacroRule (type, comm)
            }
            _ => self:.readMacroConstructor (type, comm)
        }
    }

    /**
     * Read a macro rule
     * @verbatim: 
     * ===============
     * macro_rule := Keys::DEF Identifier macro_head_rule (Tokens::SEMI_COLON | macro_body_rule)
     * ===============
     */
    def readMacroRule (mut self, _ : &Word, comm : [c8]) -> &Declaration
        throws &ErrorMsg
    {
        let (name, _) = self:.readIdentifier ();
        let (head, skips) = self:.readMacroRuleHead ();

        let (bodyLoc, body) = if (self:.readIf (Tokens::SEMI_COLON)._0.isEof ()) {
            self:.readMacroRuleBody ()
        } else { (EOF_WORD, ""s8) }

        MacroRuleDecl::new (name, comm, bodyLoc, body, head, skips-> skips, isConstructor-> false)
    }

    
    /**
     * Read a macro constructor
     * @verbatim: 
     * ==================
     * macro_constructor := Keys::SELF macro_head_rule macro_body_rule
     * ==================
     */
    def readMacroConstructor (mut self, loc : &Word, comm : [c8]) -> &Declaration
        throws &ErrorMsg
    {
        let (head, skips) = self:.readMacroRuleHead ();
        let (bodyLoc, body) = self:.readMacroRuleBody ();

        MacroRuleDecl::new (loc, comm, bodyLoc, body, head, skips-> skips, isConstructor-> true)
    }


    /**
     * Read the head (prototype) of a macro rule (or constructor)
     * @verbatim: 
     * =================
     * macro_rule_head :=  macro_inner_mult (Keys::SKIPS string_lit (Tokens::PIPE string_lit)*)?
     * =================
     */
    def readMacroRuleHead (mut self)-> (&MacroRuleExpression, [&Expression])
        throws &ErrorMsg
    {
        let (start, end, inner) = self:.readInnerMacroMult ();

        let dmut skips = Vec!{&Expression}::new ();
        if (!(self:.readIf (Keys::SKIPS)._0).isEof ()) {
            self:.readTokens (Tokens::LPAR);
            loop {
                let str = self:.readString ();
                skips:.push (MacroTokenExpr::new (str.getLoc (), str));
                if (self:.readTokens (Tokens::RPAR, Tokens::PIPE)._0 == Tokens::RPAR) break {}
            }
        }
        
        (cast!{&MacroRuleExpression} (MacroMultExpr::new (start, end, inner)), skips[])
    }


    /**
     * Read the body of a macro rule (or constructor)
     * @verbatim: 
     * ================
     * marco_rule_body := Tokens::LACC Any* Tokens::RACC
     * ================
     */
    def readMacroRuleBody (mut self)-> (&Word, [c8])
        throws &ErrorMsg
    {
        let (start, _) = self:.readTokens (Tokens::LACC);
        let (res, closing) = self._lex:.getString (closing-> Tokens::RACC, opening-> [Tokens::LACC, Tokens::MACRO_ACC]);
        if (closing.isEof ()) {
            throw ErrorMsg::fatal (closing, SyntaxErrorMessage::BLOCK_NEVER_CLOSED, notes-> [ErrorMsg::note (start, SyntaxErrorMessage::IN_DECL_BLOCK)]);
        }

        (start, res)
    }


    /**
     * Read the inner part of a macro mutliplicator
     * @verbatim: 
     * ==================
     * macro_inner_mult := Tokens::LPAR ((macro_expression*) | (macro_expression (Tokens::PIPE macro_expression)*) Tokens::RPAR
     * ==================
     */
    def readInnerMacroMult (mut self)-> (&Word, &Word, [&MacroRuleExpression])
        throws &ErrorMsg
    {
        let (start, _) = self:.readTokens (Tokens::LPAR);
        let dmut inner = Vec!{&MacroRuleExpression}::new ();
        let mut or = false;
        let mut tok = EOF_WORD;
        
        loop {
            let t = self._lex.getCounter ();            
            let next = {
                self:.readMacroExpression ()
            } catch {
                _ : &ErrorMsg => {
                    self._lex:.rewindTo (nb-> t);
                    self:.readExpression (level-> self._specials.binaryOperators.len)
                }
            }
            
            if (!or) {
                inner:.push (next);
                if (inner.len () == 1u32) {
                    let (n, _) = self:.readIf (Tokens::PIPE, Tokens::RPAR);
                    if (n == Tokens::PIPE) {
                        or = true;
                        tok = n;
                    } else if (n == Tokens::RPAR) break {}                    
                } else {
                    let (n, _) = self:.readIf (Tokens::RPAR);
                    tok = n;
                    if (!n.isEof ()) break {}
                }
            } else {
                __pragma!trusted ({
                    let last = inner:.pop ();
                    inner:.push (MacroOrExpr::new (tok, last, next));
                });
            }
        }

        (start, tok, inner[])
    }
    

    /**
     * Read a macro rule expression
     * @verbatim: 
     * =================
     * macro_expression :=   macro_inner_mult (Multiplicator)?
     *                     | Identifier Tokens::EQUAL macro_expression
     *                     | String
     *                     | expression:(10)
     * =================
     */
    def readMacroExpression (mut self)-> &MacroRuleExpression
        throws &ErrorMsg
    {
        let (n, _) = self:.readIf (Tokens::LPAR);
        if (n == Tokens::LPAR) {
            self._lex:.rewind ();
            let (start, end, inner) = self:.readInnerMacroMult ();
            let (mult, _) = self:.readIf (self._specials.macroMult);
            MacroMultExpr::new (start, end, inner, mult-> mult)
        } else {
            let (ident, _) = self:.readIfIdentifier ();
            if (ident.isEof ()) {
                let str = self:.readString ();
                MacroTokenExpr::new (str.getLoc (), str)
            } else {
                self:.readTokens (Tokens::EQUAL);
                let t = self._lex.getCounter ();
                let inner = {
                    self:.readMacroExpression ()
                } catch {
                    _ => {
                        self._lex:.rewindTo (nb-> t);
                        self:.readExpression (level-> self._specials.binaryOperators.len)
                    }
                }
                
                MacroVarExpr::new (ident, inner)
            }
        }
    }
               
    /**
     * ================================================================================
     * ================================================================================
     * =========================            MODULE            =========================
     * ================================================================================
     * ================================================================================
     */


    /**
     * Read a local module
     * @verbatim:
     * =====================
     * local_module :=   Keys::MODULE Keys::IF expression:(0) Identifier template_param_list decl_block
     *                 | Keys::MODULE Identifier decl_block
     * =====================
     */
    def readLocalModuleDecl (mut self,  _ : &Word, comm : [c8])-> &Declaration
        throws &ErrorMsg
    {
        let (hasTest, test) = self:.readTemplateTest ();
        let (ident, _) = self:.readIdentifier ();
        let templates = self:.readTemplateParameters (ifLoc-> hasTest);

        let (n, comm_) = self:.readTokens (Tokens::LACC);        
        let content = self:.readBlockDecl (n, comm_, closing-> true, inProtection-> false);

        if (templates.len == 0us) {
            ModuleDecl::new (ident, EmptyExpression::new (), comm, content, isGlobal-> false)
        } else {
            TemplateDecl::new (ident, comm, templates, test-> test,
                           ModuleDecl::new (ident, EmptyExpression::new (), comm, content, isGlobal-> false)
                           )
        }
    }


    /**
     * ================================================================================
     * ================================================================================
     * =========================            STRUCT            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Read a struct declaration
     * @verbatim:
     * ==================
     * struct_decl :=   Keys::STRUCT Keys::IF expression:(0) (attributes_list)? field_list Tokens::ARROW Identifier template_param_list (Tokens::SEMI_COLON)?
     *                | Keys::STRUCT (attributes_list)? field_list Tokens::ARROW Identifier (Tokens::SEMI_COLON)?
     *
     * field_list := Tokens::PIPE var_decl:(10)  
     * ==================
     */
    def readStruct (mut self,  _ : &Word, comm : [c8])-> &Declaration
        throws &ErrorMsg
    {
        let (hasTest, test) = self:.readTemplateTest ();
        let attribs = self:.readAttributes ();
        
        let dmut vars = Vec!{&Expression}::new ();
        let dmut comms = Vec!{[c8]}::new ();
        let mut fst = true;
        loop {
            let (n, doc) = self:.readTokens (Tokens::PIPE, Tokens::ARROW);
            match n {
                Tokens::PIPE => {
                    if (!fst) comms:.push (doc);
                    vars:.push (self:.readSingleVarDeclaration (mandType-> false, withValue-> true, level-> self._specials.binaryOperators.len));
                }
                Tokens::ARROW => break {}
            }
            fst = false;
        }
        
        let (name, _) = self:.readIdentifier ();
        let templates = self:.readTemplateParameters (ifLoc-> hasTest);
        self:.readIf (Tokens::SEMI_COLON);
        
        let str = StructDecl::new (name, comm, vars[], attributes-> attribs, fieldComms-> comms[]);
        
        if (templates.len == 0us) {
            str
        } else {
            TemplateDecl::new (name, comm, templates, str, test-> test)
        }

    }    

    /**
     * ================================================================================
     * ================================================================================
     * =========================            TRAIT             =========================
     * ================================================================================
     * ================================================================================
     */


    /**
     * Visit a trait declaration
     * @verbatim: 
     * =================
     * trait_decl :=   Keys::TRAIT Keys::IF expression:(0) Identifier template_param_list class_block_decl
     *               | Keys::TRAIT Identifier class_block_decl
     * =================
     */    
    def readTrait (mut self,  _ : &Word, comm : [c8])-> &Declaration
        throws &ErrorMsg
    {

        let (hasTest, test) = self:.readTemplateTest ();
        let (name, _) = self:.readIdentifier ();
        let templates = self:.readTemplateParameters (ifLoc-> hasTest);

        self:.readTokens (Tokens::LACC);
        let decls = self:.readClassBlockDecl (closing-> true, inProtection-> false);

        let tra = TraitDecl::new (name, comm, decls);
        
        if (templates.len == 0us) {
            tra
        } else {
            TemplateDecl::new (name, comm, templates, test-> test, tra)
        }        
    }        

    /**
     * ================================================================================
     * ================================================================================
     * =========================           UNITTEST           =========================
     * ================================================================================
     * ================================================================================
     */


    /**
     * Visit a unittest declaration
     * @verbatim: 
     * ==================
     * unittest := Keys::UNITTEST expression:(0)
     * ==================
     */
    def readUnitTest (mut self, loc : &Word, comm : [c8])-> &Declaration
        throws &ErrorMsg
    {
        UnitTestDecl::new (loc, comm, self:.readExpression ())
    }
    
    /**
     * ================================================================================
     * ================================================================================
     * =========================           TEMPLATE           =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Read a list of template parameters 
     * @params: 
     *    - ifLoc: the location of the if test, if not eof, has to read the list, can't return an empty list
     * @throws:
     *    - ErrorMsg: if !ifLoc.isEof (), but there is no list to read
     */
    def readTemplateParameters (mut self, ifLoc : &Word, force : bool = false)-> [&Expression]
        throws &ErrorMsg
    {
        let (begin, _) = if (!ifLoc.isEof () || force) {
            let (x, c) = self._lex:.next ();
            if (x != Tokens::LACC) {
                throw ErrorMsg::fatal (x, format (SyntaxErrorMessage::UNEXPECTED_BUT_LST, x.str (), [Tokens::NOT]),
                                       notes-> [ErrorMsg::note (ifLoc, SyntaxErrorMessage::IF_NON_TEMPLATE)]);
            }
            (x, c)
        } else {
            self:.readIf (Tokens::LACC)
        }
       
        if (!begin.isEof ()) { // there are templates to read
            let dmut vec = Vec!{&Expression}::new ();
            loop {
                let (curr, _) = self._lex:.next ();
                match curr.str () {
                    Keys::STRUCT | Keys::CLASS | Keys::ALIAS | TemplateVarType::TUPLE => {
                        let (ident, _) = self:.readIdentifier ();
                        vec:.push (TemplateVarExpr::new (ident, self.toTemplateVarType (curr.str ())));
                    }
                    _ => {
                        self._lex:.rewindToSeek (cursor-> cast!u64 (curr.seek ()));
                        vec:.push (
                            if self.isIdentifier (curr.str ()) {
                                self:.readTemplateVarParam ()
                            } else {
                                self:.readOperand3 ()
                            }
                        );
                    }
                }
                let (token, _) = self:.readTokens (Tokens::RACC, Tokens::COMA);
                
                if (token.str () == Tokens::RACC)
                    break {}            
            }  catch {
                _ : &ErrorMsg => {
                    self._lex:.rewindToSeek (cast!u64 (begin.seek ()));
                    return [];
                }
            }
            
            vec:.fit ();
            return vec [];
        } 
        
        []
    }

    /**
     * Read an expression that might be a variable inside a list of template parameters
     * @verbatim: 
     * ===============
     * template_var_decl :=    Identifier (Tokens::COLON expression:0)? (Tokens::EQUAL expression:0)?
     *                      |  Identifier (Keys::OF | Keys::OVER | Keys::IMPL) expression:0
     *                      |  Identifier (Tokens::COLON)?  Tokens::TDOT
     *                      |  expression:0
     * ===============
     */
    def readTemplateVarParam (mut self) -> &Expression
        throws &ErrorMsg
    {
        let beginCur = self._lex.getCounter ();
        let (name, _) = self:.readIdentifier ();
        let (next, _) = self:.readIf (cast![c8] (Tokens::COLON), Tokens::TDOT,
                                       Tokens::EQUAL, Keys::OVER, Keys::OF,
                                       Keys::IMPL);
        
        match next.str () {
            Tokens::COLON => {
                let (tok, _) = self:.readIf (Tokens::TDOT);
                if (tok.isEof ()) { // V : type ('=' value)?
                    let type = self:.readExpression (level-> self._specials.binaryOperators.len);
                    if (!(self:.readIf (Tokens::EQUAL)._0).isEof ()) { // '=' value
                        return VarDeclExpr::new (name, name, value-> self:.readExpression (), type-> type);
                    } else return VarDeclExpr::new (name, name, value-> UnitExpr::new (), type-> type);
                } else return TemplateVariadicVarExpr::new (name, isValue-> true); // V:...
            }
            Tokens::EQUAL => {
                return VarDeclExpr::new (name, name, value-> self:.readExpression (), type-> UnitExpr::new ());
            }
            Tokens::TDOT  => {
                return TemplateVariadicVarExpr::new (name, isValue-> false);
            }
            Keys::OVER | Keys::OF | Keys::IMPL => {
                let k = self.toTemplateOfVarType (next.str ());
                return TemplateOfVarExpr::new (name, self:.readExpression (), kind-> k);
            }
        }

        self._lex:.rewindTo (nb-> beginCur);
        return self:.readExpression ();
    }

    /**
     * Read a template test (if anyl
     * @returns: 
     *   - the location of the if token, (or eof)
     *   - the test expression, or Unit
     */
    def readTemplateTest (mut self)-> (&Word, &Expression)
        throws &ErrorMsg
    {    
        let (hasTest, _) = self:.readIf (Keys::IF);
        if hasTest.isEof () {
            (hasTest, const cast!(&Expression) (UnitExpr::new ()))
        } else {
            (hasTest, self:.readExpression ())
        }
    }


    /**
     * ================================================================================
     * ================================================================================
     * =========================          ATTRIBUTES          =========================
     * ================================================================================
     * ================================================================================
     */
    
    /**
     * Read a list of custom attributes, if the token Tokens::AT is not read, then an empty list is returned
     * @verbatim:
     * =================
     * attributes_lst :=   Tokens::AT Keys::LACC Attribute (Tokens::COMA Attribute)* Keys::RACC
     *                   | Tokens::AT Attribute
     * =================
     */
    def readAttributes (mut self)-> [AttributeWord]
        throws &ErrorMsg
    {
        let (next, _) = self:.readIf (Tokens::AT);
        if (next.isEof ()) return [];

        let (open, _) = self:.readIf (Tokens::LACC);
        let dmut vec = Vec!(AttributeWord)::new ();
        loop {
            let (identifier, _) = self:.readIdentifier ();
            match identifier {
                Attributes::ABSTRACT => vec:.push (AttributeWord (identifier, Attributes::ABSTRACT));
                Attributes::FINAL    => vec:.push (AttributeWord (identifier, Attributes::FINAL));
                Attributes::PACKED   => vec:.push (AttributeWord (identifier, Attributes::PACKED));
                Attributes::UNION    => vec:.push (AttributeWord (identifier, Attributes::UNION));
                _ => {
                    throw ErrorMsg::fatal (identifier, format (SyntaxErrorMessage::UNDEFINED_ATTRIBUTE, identifier.str ()));
                }
            }
            
            if (open.isEof ()) break {}
            else {
                let (close, _) = self:.readTokens (Tokens::COMA, Tokens::RACC);
                if (close.str () == Tokens::RACC) break {}
            }
        }  catch {
            err : &ErrorMsg => {
                throw err.appendNotes ([ErrorMsg::note (open, SyntaxErrorMessage::IN_DECL_BLOCK)]);
            }
        }
        
        vec:.fit ();
        vec[]
    }



    /**
     * ================================================================================
     * ================================================================================
     * =========================         EXPRESSIONS          =========================
     * ================================================================================
     * ================================================================================
     */
    
    /**
     * Read an expression 
     * @verbatim: 
     * ==================
     * expression:(level) := expression:(level+1) (binary_operator:(level) expression:(level))?
     * expression:(10) := operand:(0)
     * ==================
     */
    def readExpression (mut self, level : usize = 0us)-> &Expression
        throws &ErrorMsg
    {
        if (cast!usize (level) == self._specials.binaryOperators.len) {
            self:.readOperand0 ()
        } else {            
            let left = self:.readExpression (level-> level + 1us);
            self:.readExpressionFollow (left, level-> level)
        }
    }

    /**
     * Read the following of an expression (for operators)
     */
    def readExpressionFollow (mut self, left : &Expression, level : usize = 0us)-> &Expression
        throws &ErrorMsg
    {
        let (tok, _) = self:.readIf (self._specials.binaryOperators[level]);
        if (!tok.isEof ()) {
            let right = self:.readExpression (level-> level + 1us);
            self:.readExpressionFollow (BinaryExpr::new (tok, left, right), level-> level)                
        } else if (level == 3us) {
            let (n, _) = self:.readIf (Tokens::NOT);
            if (!n.isEof ()) {
                let (op, _) = self:.readIf (self._specials.specialBinaryOperators);
                if (op.isEof ()) {
                    self._lex:.rewind ();
                    left
                } else {
                    let right = self:.readExpression (level-> level + 1us);
                    self:.readExpressionFollow (BinaryExpr::new (Word::new (n.str () ~ op.str (), n), left, right), level-> level)                
                }
            } else { left }
        } else { left }
    }

    /**
     * Read a highest level operand
     * @verbatim: 
     * ===================
     * operand:(0) := (unary_operator)? operand:(1) (Tokens::INTEG)?     
     * ===================
     */
    def readOperand0 (mut self) -> &Expression
        throws &ErrorMsg
    {
        let (tok, _) = self:.readIf (self._specials.unaryOperators);
        let ret = if (!tok.isEof ()) {
            UnaryExpr::new (tok, self:.readOperand1 ())
        } else { self:.readOperand1 () }

        let (post, _) = self:.readIf (Tokens::INTEG);        
        if (!post.isEof ()) {
            TryExpr::new (post, ret)
        } else { ret }
    }


    /**
     * Read an operand of level 1
     * @verbatim: 
     * =================
     * operand:(1) :=   block 
     *                | if_expr
     *                | while_expr
     *                | assert_expr
     *                | break_expr
     *                | dowhile_expr
     *                | for_expr
     *                | match_expr
     *                | vardecl
     *                | return_expr
     *                | function_expr
     *                | delegate_expr
     *                | loop_expr
     *                | throw_expr
     *                | version
     *                | pragma_expr
     *                | with_expr
     *                | atomic_expr
     *                | operand:(operand_follow)?
     * =================
     */
    def readOperand1 (mut self)-> &Expression
        throws &ErrorMsg
    {
        let (tok, _) = self:.readIf (Tokens::LACC, Keys::IF, Keys::WHILE, Keys::ASSERT,
                                      Keys::BREAK, Keys::DO, Keys::FOR, Keys::MATCH,
                                      Keys::LET, Keys::RETURN, Keys::FUNCTION, Keys::DELEGATE,
                                      Keys::LOOP, Keys::THROW, Keys::VERSION, Keys::PRAGMA, Keys::WITH, Keys::ATOMIC);

        match tok {
            Keys::LOOP => { self:.readLoop (tok) }
            Keys::WHILE => { self:.readWhile (tok) }
            Tokens::LACC => { self:.readBlock (tok) }
            Keys::IF => { self:.readIfExpression (tok) }
            Keys::ASSERT => { self:.readAssert (tok) }
            Keys::BREAK => { self:.readBreak (tok) }
            Keys::DO => { self:.readDoWhile (tok) }
            Keys::FOR => { self:.readFor (tok) }
            Keys::MATCH => { self:.readMatch (tok) }
            Keys::LET => { self:.readVarDeclaration (tok) }
            Keys::RETURN => { self:.readReturn (tok) }
            Keys::FUNCTION => { self:.readFunctionType (tok) }
            Keys::DELEGATE => { self:.readFunctionType (tok) }
            Keys::THROW => { self:.readThrow (tok) }
            Keys::VERSION => { self:.readVersionExpr (tok) }
            Keys::PRAGMA => { self:.readPragma (tok) }
            Keys::WITH => { self:.readWith (tok) }
            Keys::ATOMIC => { self:.readAtomic (tok) }
            _ => { self:.readOperandFollow (self:.readOperand2 (self:.readOperand3 ())) }
        }
    }


    /**
     * Read the follow-up of an operand
     * @verbatim: 
     * =================
     * operand_follow :=   Tokens::LPAR param_list Tokens::RPAR (operand_follow)?
     *                   | Tokens::LCRO param_list Tokens::RCRO (operand_follow)?
     *                   | (Tokens::DOT | Tokens::DOT_AND) operand:(3) (template_call)? (operand_follow)?
     *                   | macro_call (operand_follow)?
     * =================
     */
    def readOperandFollow (mut self, left : &Expression)-> &Expression
        throws &ErrorMsg
    {
        let (n, _) = self:.readIf (Tokens::LPAR, Tokens::LCRO, Tokens::MACRO_ACC, Tokens::MACRO_CRO, Tokens::MACRO_PAR, Tokens::DOT, Tokens::DOT_AND);
        match n {
            Tokens::LPAR | Tokens::LCRO => {
                let (params, end) = self:.readArgumentList (withNamed-> true, closing-> if (n == Tokens::LPAR) { Tokens::RPAR } else { Tokens::RCRO });
                self:.readOperandFollow (MultOperatorExpr::new (n, end, left, params))
            }
            Tokens::MACRO_ACC | Tokens::MACRO_PAR | Tokens::MACRO_CRO => {
                self:.readOperandFollow (self:.readMacroCall (n, left))
            }
            Tokens::DOT | Tokens::DOT_AND => {
                let right = self:.readOperand3 (canBeTemplateCall-> false, canBeFloat-> false);
                self:.readOperandFollow (self:.readTemplateCall (BinaryExpr::new (n, left, right)))
            }
            _ => { left }
        }
    }


    /**
     * Read a level 2 operand
     * @verbatim: 
     * ===============
     * operand:(2) := (Tokens::DCOLON template_call)?
     * ===============
     */
    def readOperand2 (mut self, left : &Expression) -> &Expression
        throws &ErrorMsg
    {
        let (n, _) = self:.readIf (Tokens::DCOLON);
        if (!n.isEof ()) {
            let right = self:.readOperand3 (canBeTemplateCall-> false);
            self:.readOperand2 (self:.readTemplateCall (BinaryExpr::new (n, left, right)))
        } else { 
            left
        }
    }

    /**
     * Read a level 3 operand
     * @verbatim: 
     * =================
     * operand:(3) :=   cast_expr
     *                | template_checker
     *                | array_lit
     *                | tuple_lit
     *                | lambda_lit
     *                | intrinsic
     *                | literal
     *                | decorated_expr
     *                | var
     * =================
     */
    def readOperand3 (mut self, canBeTemplateCall : bool = true, canBeFloat : bool = true) -> &Expression
        throws &ErrorMsg
    {
        let (n, _) = self:.readIf (Keys::CAST, Keys::IS, Tokens::LCRO, Tokens::LPAR, Tokens::PIPE, Tokens::DPIPE, Tokens::NOT);
        
        if (n == Tokens::NOT) {
            let (e, _) = self:.readIf(Keys::IS);
            if (!e.isEof ()) {
                return cast!{&Expression} (UnaryExpr::new (n, self:.readTemplateChecker (e)));
            } else self._lex:.rewind ();
        }

        match n {
            Keys::CAST => { self:.readCast (n) }
            Keys::IS => { self:.readTemplateChecker (n) }
            Tokens::LCRO => { self:.readArray (n) }
            Tokens::LPAR => { self:.readTuple (n) }
            Tokens::PIPE | Tokens::DPIPE => { self:.readLambda (n) }
            _ => {
                let (i, _) = self:.readIf (self._specials.intrinsicKeys);
                if (!i.isEof ()) {
                    let (p, _) = self:.readIf (Tokens::LPAR);
                    let inner = if (p.isEof ()) {
                        self:.readExpression (level-> self._specials.binaryOperators.len)
                    } else { self:.readExpression () }
                    
                    let ret = IntrinsicExpr::new (i, self.toIntrinsic (i.str ()), inner);
                    if (!p.isEof ()) self:.readTokens (Tokens::RPAR);
                    cast!{&Expression} (ret)
                } else {
                    let (j, _) = self:.readIf (self._specials.decorators);
                    if (!j.isEof ()) {
                        self:.readDecoratedExpression (j)
                    } else {
                        let (ident, _) = self:.readIfIdentifier ();
                        if (!ident.isEof ()) {
                            self._lex:.rewind ();
                            self:.readVar (canBeTemplateCall-> canBeTemplateCall)
                        } else {
                            self:.readLiteral (canBeFloat-> canBeFloat)                            
                        }
                    }
                }
            }
        }        
    }
    
    
    /**
     * Read a list of arguments
     * @params: 
     *    - withNamed: if true, named expression are allowed in the argument list
     *    - closing: the token that closes the list
     * @verbatim: 
     * ===================
     * 
     * ===================
     */
    def readArgumentList (mut self, withNamed : bool = false, closing : [c8] = Tokens::RPAR)-> ([&Expression], &Word)
        throws &ErrorMsg
    {
        let dmut vec = Vec!{&Expression}::new ();
        let mut end = EOF_WORD;
        loop {
            let (x, _) = self:.readIf (closing);
            if (!x.isEof ()) { end = x; break {} }
            
            let beg = self._lex.getCounter ();
            let mut read = false;
            if (withNamed) {
                let (name, _) = self._lex:.next ();
                if (self.isIdentifier (name.str ())) {
                    let (arr, _) = self:.readIf (Tokens::ARROW);
                    if (!arr.isEof ()) {
                        vec:.push (NamedExpr::new (name, self:.readExpression ()));
                        read = true;
                    }
                }
            }
            
            if (!read) {
                self._lex:.rewindTo (nb-> beg);
                vec:.push (self:.readExpression ());
            }
            
            let (n, _) = self:.readTokens (closing, Tokens::COMA);
            if (n != Tokens::COMA) {
                end = n;
                break {}
            }
        }
        
        vec:.fit ();
        (vec [], end)
    }


    /**
     * ================================================================================
     * ================================================================================
     * =========================       VAR DECLARATION        =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Read a single var declaration
     * @params: 
     *    - mandType: the type is mandatory
     *    - withValue: there can be a value
     *    - isClass: self is a valid Identifier
     *    - level: the level of the expression (only applicable if withValue)
     * @verbatim: 
     * ==================
     * single_var_decl :=   (Decorator)* (Identifier | Keys::UNDER) (Tokens::COLON expression:(10))? (Tokens::EQUAL expression:(level))
     *                    | (Decorator)* Keys::SELF
     * ==================
     */
    def readSingleVarDeclaration (mut self, mandType : bool = false, withValue : bool = true, isClass : bool = false, level : usize = 0us)-> &VarDeclExpr
        throws &ErrorMsg
    {
        let decos = self:.readDecorators ();
        let (ig, _) = self:.readIf (Keys::UNDER);
        let name = if (!ig.isEof ()) {
            ig
        } else { self:.readIdentifier ()._0 }

        match name {
            Keys::SELF => {
                if (!isClass) throw ErrorMsg::fatal (name, format (SyntaxErrorMessage::USED_AS_IDENTIFIER, name.str ()));
                VarDeclExpr::new (name, name, decos-> decos, value-> EmptyExpression::new (), type-> EmptyExpression::new ())
            }
            _ => {
                if (isClass) throw ErrorMsg::fatal (name, format (SyntaxErrorMessage::UNEXPECTED_BUT_LST, name.str (), [Keys::SELF]));
                let type = if (mandType) {
                    self:.readTokens (Tokens::COLON);
                    self:.readExpression (level-> self._specials.binaryOperators.len)
                } else if (!(self:.readIf (Tokens::COLON)._0).isEof ()) {
                    self:.readExpression (level-> self._specials.binaryOperators.len)
                } else { cast!{&Expression} (EmptyExpression::new ()) }

                let value = if (withValue) {
                    if (!(self:.readIf (Tokens::EQUAL)._0).isEof ()) {
                        self:.readExpression (level-> level)
                    } else { cast!{&Expression} (EmptyExpression::new ()) }                    
                } else { cast!{&Expression} (EmptyExpression::new ()) }

                VarDeclExpr::new (name, name, decos-> decos, value-> value, type-> type)
            }
        }
    }

    /**
     * Read a destruct var declaration
     * @verbatim: 
     * ===============================
     * destruct_decl := Keys::LET Tokens::LPAR (single_var_decl (Tokens::COMA single_var_decl)* Tokens::RPAR Tokens::EQUAL expression:(0) 
     * ===============================
     */
    def readDestructVarDecl (mut self, loc : &Word)-> &Expression
        throws &ErrorMsg
    {
        let dmut vars = Vec!{&Expression}::new ();
        let mut isVariadic = false;
        loop {
            vars:.push (self:.readSingleVarDeclaration (mandType-> false, withValue-> false, isClass-> false));
            let (n, _) = if (vars.len () == 1us) {
                self:.readTokens (Tokens::COMA, Tokens::RPAR)
            } else {
                let (a, _) = self:.readTokens (Tokens::COMA, Tokens::RPAR, Tokens::TDOT);
                if (a == Tokens::TDOT) {
                    isVariadic = true;
                    self:.readTokens (Tokens::RPAR)
                } else { (a, ""s8) }                
            }

            if (n == Tokens::RPAR) break {}
        }

        self:.readTokens (Tokens::EQUAL);
        
        DestructVarDeclExpr::new (loc, vars[], self:.readExpression (), isVariadic-> isVariadic)
    }
    

    /**
     * Read a list of decorators
     * @verbatim: 
     * =====================
     * decorators := (Keys::MUTABLE | Keys::DMUTABLE | Keys::LAZY | Keys::CTE | Keys::PURE)*
     * =====================
     */
    def readDecorators (mut self) -> [DecoratorWord] {
        let dmut res = Vec!{DecoratorWord}::new ();
        loop {
            let (x, _) = self:.readIf (self._specials.decorators);
            if (x.isEof ()) break {}
            res:.push (DecoratorWord (x, self.toDecorator (x.str ())))
        }

        res []
    }


    
    /**
     * ================================================================================
     * ================================================================================
     * =========================            BLOCKS            =========================
     * ================================================================================
     * ================================================================================
     */

    
    /**
     * Read a block of code
     * @verbatim: 
     * ====================
     * block := Tokens::LACC ((n=expression:(0) (Tokens::SEMI_COLON)!if(self:.needClosingExpr (n))* (expression:(0))?) Tokens::RACC (scope_guards)?
     * ====================
     */
    def readBlock (mut self, loc : &Word, canBeCatcher : bool = true)-> &Expression
        throws &ErrorMsg
    {
        let dmut decls = Vec!{&Declaration}::new ();
        let dmut content = Vec!{&Expression}::new ();
        {
            let mut end = EOF_WORD;
            let mut last = false;
            loop {
                end = self:.readIf (Tokens::SEMI_COLON, Tokens::RACC)._0;
                if (end.isEof ()) {
                    if (!last && content.len () != 0us) {
                        if (self.needClosingExpr (content[][$ - 1us])) {
                            let (n, _) = self._lex:.next ();
                            throw ErrorMsg::fatal (n, format (SyntaxErrorMessage::UNEXPECTED_BUT_LST, n.str (), [Tokens::SEMI_COLON]));
                        }
                    }
                    
                    last = false;
                    let (d, _) = self:.readIf (Keys::CLASS, Keys::ENUM, Keys::DEF, Keys::IMPORT, Keys::STRUCT, Keys::TRAIT);
                    if (!d.isEof ()) {
                        self._lex:.rewind ();
                        decls:.push (self:.readDeclaration ());
                        last = true;
                    } else {
                        content:.push (self:.readExpression ());
                    }
                } else if (end == Tokens::SEMI_COLON) {
                    last = true;
                } else break {}
            }

            let (catcher, scopes) = if (canBeCatcher) {
                self:.readScopeGuards ()
            } else { (cast!{&Expression} (EmptyExpression::new ()), []) }

            if (last) content:.push (UnitExpr::new (loc-> end));
            if (decls.len () != 0us) {
                BlockExpr::new (loc, end, module-> BlockDecl::new (Word::new (Keys::UNDER, loc), ""s8, decls[]), content[], catcher-> catcher, guards-> scopes)
            } else {
                BlockExpr::new (loc, end, content[], catcher-> catcher, guards-> scopes)
            }
        } catch {
            err : &ErrorMsg => {
                throw err.appendNotes ([ErrorMsg::note (loc, SyntaxErrorMessage::IN_DECL_BLOCK)]);
            }
        }
    }
    

    /**
     * Read scope guards
     * @verbatim:
     * ==================
     * scope_guards :=   Keys::EXIT block 
     *                 | Keys::SUCCESS block
     *                 | Keys::FAILURE block
     *                 | catcher
     * ==================
     */
    def readScopeGuards (mut self)-> (&Expression, [&ScopeGuardExpr])
        throws &ErrorMsg
    {
        let mut catcher : &Expression = EmptyExpression::new ();
        let dmut scopes = Vec!{&ScopeGuardExpr}::new ();
        loop {
            let (n, _) = match catcher {
                EmptyExpression () => { self:.readIf (Keys::EXIT, Keys::SUCCESS, Keys::FAILURE, Keys::CATCH) }
                _ => { self:.readIf (Keys::EXIT, Keys::SUCCESS, Keys::FAILURE) }
            }

            if (n == Keys::CATCH) {
                catcher = self:.readCatcher (n);
            } else if (!n.isEof ()) {
                let (a, _) = self:.readTokens (Tokens::LACC);
                scopes:.push (ScopeGuardExpr::new (n, self:.readBlock (a, canBeCatcher-> false), kind-> self.toScopeGuard (n.str ())))
            } else break {}
        }
        
        (catcher, scopes[])
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================          CONDITIONS          =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Read an If expression
     * @verbatim: 
     * ======================
     * if_expr := Keys::IF expression:(0) ((expression:(0) (Tokens::SEMI_COLON)?) | (block)) (Keys::ELSE expression:(0))?
     * ======================
     */
    def readIfExpression (mut self, loc : &Word)-> &Expression
        throws &ErrorMsg
    {
        let test = self:.readExpression ();
        let mut content = self:.readExpression ();

        match content {
            BlockExpr () => {}
            _ => {
                let (tok, _) = self:.readIf (Tokens::SEMI_COLON);
                if (!tok.isEof ()) {
                    let dmut inner = Vec!{&Expression}::new ();
                    inner:.push (content);
                    inner:.push (UnitExpr::new ());
                    content = BlockExpr::new (content.getLoc (), tok, content-> inner[]);
                }
            }
        }

        let (next, _) = self:.readIf (Keys::ELSE);
        if (!next.isEof ()) {
            let (n, _) = self:.readIf (Keys::IF);
            if (!n.isEof ()) return ConditionalExpr::new (loc, test, content, else_-> self:.readIfExpression (n));
            else {
                let mut el_content = self:.readExpression ();
                match el_content {
                    BlockExpr () => {}
                    _ => {
                        let (tok, _) = self:.readIf (Tokens::SEMI_COLON);
                        if (!tok.isEof ()) {
                            let dmut inner = Vec!{&Expression}::new ();
                            inner:.push (el_content);
                            inner:.push (UnitExpr::new ());
                            el_content = BlockExpr::new (content.getLoc (), tok, content-> inner[]);
                        }
                    }
                }            
                return ConditionalExpr::new (loc, test, content, else_-> el_content);
            }
        }

        ConditionalExpr::new (loc, test, content)
    }


    /**
     * Read an atomic
     * @verbatim:
     * ==============
     * atomic_expr := Keys::ATOMIC (expression:(0))? Tokens::LACC expression:(0) Tokens::RACC
     * ==============
     */
    def readAtomic (mut self, loc : &Word) -> &Expression
        throws &ErrorMsg
    {
        let (n, _) = self:.readIf (Tokens::LACC);
        if (!n.isEof ()) {
            let content = self:.readExpression ();
            return AtomicExpr::new (loc, content);
        } else {
            let (par, _) = self:.readIf (Tokens::LPAR);
            let monitor = self:.readExpression ();
            if (!par.isEof ()) self:.readTokens (Tokens::RPAR);
            return AtomicExpr::new (loc, self:.readExpression (), monitor-> monitor);            
        }
    }



    /**
     * Read a dispose scope
     * @verbatim:
     * ====================
     * with_expr := Keys::WITH (single_var_decl (',' single_var_decl)*) block
     * ====================
     */
    def readWith (mut self, loc : &Word)-> &Expression
        throws &ErrorMsg
    {
        let (par, _) = self:.readIf (Tokens::LPAR);
        let dmut vars = Vec!{&Expression}::new ();
        loop {
            vars:.push (self:.readSingleVarDeclaration (mandType-> false, withValue-> true, isClass-> false));
            if ((self:.readIf (Tokens::COMA)._0).isEof ()) break {}
        }
        if (!par.isEof ()) self:.readTokens (Tokens::RPAR);

        let (a, _) = self:.readTokens (Tokens::LACC);
        let block = self:.readBlock (a, canBeCatcher-> true);
        DisposeScopeExpr::new (loc, vars[], block)
    }


    /**
     * Read a pragma expr
     * @verbatim: 
     * ===================
     * pragma_expr := Keys::PRAGMA Tokens::NOT Identifier (Tokens::LPAR param_list Tokens::RPAR)
     * ===================
     */
    def readPragma (mut self, _ : &Word)-> &Expression
        throws &ErrorMsg
    {
        self:.readIf (Tokens::NOT);
        let (ident, _) = self:.readIdentifier ();

        self:.readTokens (Tokens::LPAR);
        let (params, _) = self:.readArgumentList ();

        PragmaExpr::new (ident, params)
    }


    /**
     * Read a version block expr
     * @verbatim:
     * =========================
     * version_block := Keys::VERSION Identifier block (Keys::ELSE block)?
     * =========================     
     */
    def readVersionExpr (mut self, loc : &Word)-> &Expression
        throws &ErrorMsg
    {
        let (ident, _) = self:.readIdentifier ();
        return if state::instance ().isVersionActive (ident.str ()) {
            let (n, _) = self:.readIf (Tokens::LACC);
            let value = self:.readBlock (n, canBeCatcher-> false);
            if (!(self:.readIf (Keys::ELSE)._0).isEof ()) {
                self:.ignoreBlock ();
            }

            value
        } else {
            self:.ignoreBlock ();
            if (!(self:.readIf (Keys::ELSE)._0).isEof ()) {
                let (n, _) = self:.readIf (Tokens::LACC);
                self:.readBlock (n, canBeCatcher-> false)
            } else UnitExpr::new (loc-> loc)            
        }
    }
    
    /**
     * Read a throw expression
     * @verbatim:
     * =======================
     * throw_expr := Keys::THROW expression:(0)
     * =======================
     */
    def readThrow (mut self, loc : &Word)-> &Expression
        throws &ErrorMsg
    {
        ThrowExpr::new (loc, self:.readExpression ())
    }


    /**
     * Read a function type
     * @verbatim:
     * ====================
     * function_type := (Keys::FN | Keys::DG) function_type_prototype function_type_return_type
     * function_type_prototype := Tokens::LPAR (expression:(10) (Tokens::COMA expression:(10))*) Tokens::RPAR 
     * function_type_return_type := (Tokens::ARROW expression:(10))?
     * ====================
     */
    def readFunctionType (mut self, loc : &Word)-> &Expression
        throws &ErrorMsg
    {
        self:.readTokens (Tokens::LPAR);
        let (args, _) = self:.readArgumentList (withNamed-> false);
        let (t, _) = self:.readIf (Tokens::ARROW);
        if (!t.isEof ()) {
            FunctionPtrTypeExpr::new (loc, args, self:.readExpression (level-> self._specials.binaryOperators.len))
        } else {
            FunctionPtrTypeExpr::new (loc, args, EmptyExpression::new ())
        }
    }

    /**
     * Read a return expression
     * @verbatim: 
     * ========================
     * return_expr := Keys::RETURN ( expression:(0) | ';' )
     * ========================
     */
    def readReturn (mut self, loc : &Word)-> &Expression
        throws &ErrorMsg
    {
        let (semiCol, _) = self:.readIf (Tokens::SEMI_COLON);
        if (!semiCol.isEof ()) {
            ReturnExpr::new (loc, EmptyExpression::new ())
        } else {
            ReturnExpr::new (loc, self:.readExpression ())
        }
    }

    /**
     * Read a var declaration
     * @verbatim:
     * ========================
     * var_decl :=   Keys::LET (single_var_decl) (Tokens::COMA (single_var_decl))*
     *             | Keys::LET destruct_decl
     * ========================
     */
    def readVarDeclaration (mut self, loc : &Word)-> &Expression
        throws &ErrorMsg
    {
        let dmut decls = Vec!{&Expression}::new ();
        loop {
            let (tok, _) = self:.readIf (Tokens::LPAR);
            if (!tok.isEof ()) {
                decls:.push (self:.readDestructVarDecl (tok));
                break {}
            } else {
                decls:.push (self:.readSingleVarDeclaration (mandType-> false, isClass-> false, withValue-> true));
                if ((self:.readIf (Tokens::COMA)._0).isEof ()) break {}
            }
        }

        if (decls.len () == 1us)
            __pragma!trusted (decls [0us])
        else cast!{&Expression} (SetExpr::new (loc, decls[]))
    }


    /**
     * Read a for loop 
     * @verbatim:
     * ===========================
     * for_loop := Keys::FOR ((Tokens::LPAR for_loop_decl Tokens::RPAR) | for_loop_decl) expression:(0)
     * for_loop_decl := (single_var_decl:(no_value) (Tokens::COMA single_var_decl:(no_value))* Keys::IN expression:(10)
     * ===========================
     */    
    def readFor (mut self, loc : &Word)-> &Expression
        throws &ErrorMsg
    {
        let dmut decls = Vec!{&Expression}::new ();
        let (par, _) = self:.readIf (Tokens::LPAR);
        loop {
            decls:.push (self:.readSingleVarDeclaration (mandType-> false, withValue-> false));
            let (n, _) = self:.readTokens (Tokens::COMA, Keys::IN);
            if (n == Keys::IN) break {}
        }

        let iter = self:.readExpression ();
        if (!par.isEof ()) self:.readTokens (Tokens::RPAR);

        let mut content = self:.readExpression ();
        match content {
            BlockExpr () => {}
            _ => {
                let (n, _) = self:.readIf (Tokens::SEMI_COLON);
                if (!n.isEof ()) {
                    let dmut inner = Vec!{&Expression}::new ();
                    inner:.push (content);
                    inner:.push (UnitExpr::new ());
                    content = BlockExpr::new (content.getLoc (), n, inner[]);
                }
            }
        }

        ForLoopExpr::new (loc, decls[], iter, content)
    }


    /**
     * Read a do while loop
     * @verbatim:
     * =====================
     * =====================
     */
    def readDoWhile (mut self, loc : &Word) -> &Expression
        throws &ErrorMsg
    {
        let content = self:.readExpression ();
        self:.readTokens (Keys::WHILE);
        let test = self:.readExpression ();
        
        WhileLoopExpr::new (loc, test-> test, content, isDo-> true)
    }

    /**
     * Read a break expression
     * @verbatim: 
     * =======================
     * break_expr := Keys::BREAK ( expression:(0) | ';' )
     * =======================
     */
    def readBreak (mut self, loc : &Word)-> &Expression
        throws &ErrorMsg
    {
        let (semiCol, _) = self:.readIf (Tokens::SEMI_COLON);
        if (!semiCol.isEof ()) {
            BreakExpr::new (loc, EmptyExpression::new ())
        } else {
            BreakExpr::new (loc, self:.readExpression ())
        }
    }            


    /**
     * Read an assert expression
     * @verbatim:
     * ==========================
     * assert_expr := Keys::ASSERT Tokens::LPAR expression:(0) (Tokens::COMA expression:(0))? Tokens::RPAR
     * ==========================
     */
    def readAssert (mut self, _ : &Word)-> &Expression
        throws &ErrorMsg
    {
        let (start, _) = self:.readTokens (Tokens::LPAR);
        let test = self:.readExpression ();
        let (n, _) = self:.readTokens (Tokens::RPAR, Tokens::COMA);
        let msg = if (n == Tokens::COMA) {
            let exp = self:.readExpression ();
            self:.readTokens (Tokens::RPAR);
            exp 
        } else {
            cast!{&Expression} ( EmptyExpression::new () )
        }
        
        AssertExpr::new (start, test, msg)
    }

    /**
     * Read a loop expression
     * @verbatim: 
     * =========================
     * loop_expr := Keys::LOOP expression:(0)
     * =========================     
     */
    def readLoop (mut self, loc : &Word)-> &Expression
        throws &ErrorMsg
    {
        let mut content = self:.readExpression ();
        match content {
            BlockExpr () => {}
            _ => {
                let (n, _) = self:.readIf (Tokens::SEMI_COLON);
                if (!n.isEof ()) {
                    let dmut inner = Vec!{&Expression}::new ();
                    inner:.push (content);
                    inner:.push (UnitExpr::new ());
                    content = BlockExpr::new (content.getLoc (), n, inner[]);
                }
            }
        }

        WhileLoopExpr::new (loc, content, isDo-> false)
    }


    /**
     * Read a while loop
     * @verbatim: 
     * ===========================
     * while_expr := Keys::WHILE expression:(0) expression:(0)
     * ===========================
     */
    def readWhile (mut self, loc : &Word)-> &Expression
        throws &ErrorMsg
    {
        let test = self:.readExpression ();
        let mut content = self:.readExpression ();
        match content {
            BlockExpr () => {}
            _ => {
                let (n, _) = self:.readIf (Tokens::SEMI_COLON);
                if (!n.isEof ()) {
                    let dmut inner = Vec!{&Expression}::new ();
                    inner:.push (content);
                    inner:.push (UnitExpr::new ());
                    content = BlockExpr::new (content.getLoc (), n, inner[]);
                }
            }
        }
        
        WhileLoopExpr::new (loc, test-> test, content, isDo-> false)
    }

    /**
     * Read a template call expr
     * @verbatim: 
     * ===========================
     * template_call_expr := expression:(0) Tokens::NOT ((Tokens::LACC param_list Tokens::RACC) | operand:(3))
     * ===========================
     */
    def readTemplateCall (mut self, var : &Expression)-> &Expression
        throws &ErrorMsg
    {

        let (n, _) = self:.readIf (Tokens::NOT);
        if (!self._inTemplateCall && n == Tokens::NOT) {
            let (a, _) = self:.readIf (self._specials.specialBinaryOperators);            
            if (!a.isEof ()) {
                self._lex:.rewind (nb-> 2u64);
                return var;
            }
            
            let (n2, _) = self:.readIf (Tokens::LACC);
            let res = self._inTemplateCall;
            {
                if (!n2.isEof ()) {                
                    self._inTemplateCall = false;
                    let (lst, _) = self:.readArgumentList (withNamed-> false, closing-> Tokens::RACC);
                    self._inTemplateCall = res;
                    
                    return TemplateCallExpr::new (n, var, lst);                
                } else {
                    self._inTemplateCall = true;
                    let lst = [self:.readOperand3 ()];
                    self._inTemplateCall = res;
                    
                    return TemplateCallExpr::new (n, var, lst);
                }
            } catch {
                err : &ErrorMsg => {
                    self._inTemplateCall = res;
                    throw err;
                }
            }            
        } else if (n == Tokens::NOT) {
            throw ErrorMsg::fatal (n, SyntaxErrorMessage::MISSING_TEMPLATE_ACC);
        }
        
        var
    }
    

    /**
     * Read a macro call
     * @verbatim: 
     * ==================
     * macro_call_expr :=   expression:(0) Tokens::MACRO_ACC (Any)* Tokens::RACC
     *                    | expression:(0) Tokens::MACRO_PAR (Any)* Tokens::RPAR
     *                    | expression:(0) Tokens::MACRO_CRO (Any)* Tokens::RCRO
     * ==================
     */
    def readMacroCall (mut self, loc : &Word, var : &Expression)-> &Expression
        throws &ErrorMsg
    {
        let (open, close) = match loc.str () {
            Tokens::MACRO_ACC => { (Tokens::LACC, Tokens::RACC) }
            Tokens::MACRO_PAR => { (Tokens::LPAR, Tokens::RPAR) }
            _ => { (Tokens::LCRO, Tokens::RCRO) }
        }

        let (res, closing) = self._lex:.getString (opening-> [open, loc.str ()], closing-> close);
        if (closing.isEof ()) throw ErrorMsg::fatal (closing, SyntaxErrorMessage::BLOCK_NEVER_CLOSED, notes-> [ErrorMsg::note (loc, SyntaxErrorMessage::IN_DECL_BLOCK)]);
        
       
        MacroCallExpr::new (loc, closing, var, res)
    }
    


    /**
     * Read a variable 
     * @verbatim:
     * ===================
     * var := Identifier (template_call)?
     * ===================
     */
    def readVar (mut self, canBeTemplateCall : bool = true)-> &Expression
        throws &ErrorMsg
    {
        let (var, _) = self:.readIdentifier ();
        if (canBeTemplateCall) {
            self:.readTemplateCall (VarExpr::new (var))
        } else {
            cast!{&Expression} (VarExpr::new (var))
        }
    }

    /**
     * Read a lambda expression
     * @verbatim: 
     * ========================
     * lambda_expr := function_proto:(lambda) (Tokens::DARROW)? expression:(0)
     * ========================
     */
    def readLambda (mut self, loc : &Word)-> &Expression
        throws &ErrorMsg
    {
        self._lex:.rewind ();
        let proto = self:.readFunctionPrototype (isClosure-> true, isClass-> false);
        self:.readIf (Tokens::DARROW);
        LambdaValueExpr::new (loc, proto, self:.readExpression ())
    }


    /**
     * Read a tuple expression
     * @verbatim:
     * ========================
     * param_expr := Tokens::LPAR (expression:(0) (Tokens::COMA | (Tokens::COMA expression:(0))*))? Tokens::RPAR
     * ========================
     */
    def readTuple (mut self, loc : &Word)-> &Expression
        throws &ErrorMsg
    {
        let mut end = self:.readIf (Tokens::RPAR)._0;
        if (end == Tokens::RPAR) { return ListExpr::new (loc, end, []); }

        let dmut params = Vec!{&Expression}::new ();
        params:.push (self:.readExpression ());

        let (n, _) = self:.readTokens (Tokens::COMA, Tokens::RPAR);
        if (n == Tokens::COMA) {
            end = self:.readIf (Tokens::RPAR)._0;
            if (end.isEof ()) {
                loop {
                    params:.push (self:.readExpression ());
                    end = self:.readTokens (Tokens::COMA, Tokens::RPAR)._0;
                    if (end == Tokens::RPAR) break {}
                }

                return ListExpr::new (loc, end, params[]);
            } else {
                return ListExpr::new (loc, end, params[]);
            }
        }
        
        __pragma!trusted (params [0us])
    }


    /**
     * Read a template checker expr
     * @verbatim: 
     * ============================
     * template_check := Keys::IS template_call template_param_list
     * ============================
     */
    def readTemplateChecker (mut self, loc : &Word)-> &Expression
        throws &ErrorMsg
    {
        let call = self:.readTemplateCall (VarExpr::new (loc));
        match call {
            t : &TemplateCallExpr => {
                let params = self:.readTemplateParameters (ifLoc-> EOF_WORD, force-> true);
                cast!{&Expression} (TemplateCheckerExpr::new (loc, t.getRights (), params))
            }
            _ => {
                self:.readTokens (Tokens::NOT);
                cast!{&Expression} (EmptyExpression::new ())
            }
        }
    }

    /**
     * Read a decorated expression
     * @verbatim:
     * ===========================
     * deco_expr := (Decorator)* expression:(10)
     * ===========================
     */
    def readDecoratedExpression (mut self, loc : &Word)-> &Expression
        throws &ErrorMsg
    {
        let mut decos = self:.readDecorators ();
        decos = [DecoratorWord (loc, self.toDecorator (loc.str ()))] ~ decos;

        DecoratedExpr::new (loc, self:.readExpression (level-> self._specials.binaryOperators.len), decos)
    }
    

    /**
     * Read a cast expression
     * @verbatim:
     * =======================
     * cast_expr := Keys::CAST Tokens::NOT ((Tokens::LACC expression:(0) Tokens::RACC) | (operand:(3)) (Tokens::LPAR expression:(0) Tokens::RPAR)
     * =======================
     */
    def readCast (mut self, loc : &Word)-> &Expression
        throws &ErrorMsg
    {
        self:.readTokens (Tokens::NOT);
        let type = if (!(self:.readIf (Tokens::LACC)._0).isEof ()) {
            let e = self:.readExpression ();
            self:.readTokens (Tokens::RACC);
            e
        } else {
            self:.readOperand3 ()
        }

        self:.readTokens (Tokens::LPAR);
        let inner = self:.readExpression ();
        self:.readTokens (Tokens::RPAR);
        
        CastExpr::new (loc, type, inner)
    }

    
    /**
     * ================================================================================
     * ================================================================================
     * =========================           MATCHERS           =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Read a catcher expression
     * @verbatim:
     * =========================
     * =========================
     */
    def readCatcher (mut self, loc : &Word)-> &Expression
        throws &ErrorMsg
    {
        let dmut matchers = Vec!{(&Expression, &Expression)}::new ();
        self:.readTokens (Tokens::LACC);
        loop {
            let e = self:.readMatchExpression ();            
            self:.readTokens (Tokens::DARROW);
            let mut a = self:.readExpression(level-> self._specials.binaryOperators.len);
            let (tok, _) = self:.readIf (Tokens::SEMI_COLON);
            if (!tok.isEof ()) {
                let dmut inner = Vec!{&Expression}::new ();
                inner:.push (a);
                inner:.push (UnitExpr::new ());
                a = BlockExpr::new (a.getLoc (), tok, content-> inner[]);
            }

            matchers:.push ((e, a));
            if (!(self:.readIf (Tokens::RACC)._0).isEof ()) break {}
        }
        
        MatcherExpr::new (loc, EmptyExpression::new (), matchers[], isCatcher-> true)
    }
    
    /**
     * Read a match expression
     * @verbatim:
     * ========================
     * match_expr := Keys::MATCH expression:(0) Tokens::LACC (inner_matcher_expr Tokens::ARROW expression:(10))+ Tokens::RACC
     * ========================
     */
    def readMatch (mut self, loc : &Word)-> &Expression
        throws &ErrorMsg
    {
        let dmut matchers = Vec!{(&Expression, &Expression)}::new ();
        let content = self:.readExpression ();
        self:.readTokens (Tokens::LACC);
        loop {
            let e = self:.readMatchExpression ();
            self:.readTokens (Tokens::DARROW);            
            let mut a = self:.readExpression(level-> self._specials.binaryOperators.len);
            let (tok, _) = self:.readIf (Tokens::SEMI_COLON);
            if (!tok.isEof ()) {
                let dmut inner = Vec!{&Expression}::new ();
                inner:.push (a);
                inner:.push (UnitExpr::new ());
                a = BlockExpr::new (a.getLoc (), tok, content-> inner[]);
            }

            matchers:.push ((e, a));
            if (!(self:.readIf (Tokens::RACC)._0).isEof ()) break {}
        }
        MatcherExpr::new (loc, content, matchers[], isCatcher-> false)
    }

    /**
     * Read an matching expression
     * @verbatim: 
     * ============================
     * inner_matcher_expr :=   single_var_decl_match
     *                       | calling_match
     *                       | par_match
     *                       | cro_match
     *                       | expression:(0)
     * ============================
     */
    def readMatchExpression (mut self)-> &Expression
        throws &ErrorMsg
    {
        let t = self._lex.getCounter ();
        {
            self:.readSingleVarDeclarationForMatch ()
        } catch {
            _ => {
                self._lex:.rewindTo (nb-> t);
                let (n, _) = self._lex:.next ();
                if (self:.isIdentifier (n.str ()) || n == Keys::UNDER) {
                    self:.readCallingMatch (n)
                } else if (n == Tokens::LPAR) {
                    self:.readParMatch (n, endTok-> Tokens::RPAR)
                } else if (n == Tokens::LACC) {
                    self:.readParMatch (n, endTok-> Tokens::RCRO)
                } else {
                    self._lex:.rewind ();
                    self:.readExpression ()
                }
            }
        }
    }

    /**
     * Read a single var declaration for a pattern matcher
     * @verbatim:
     * ========================
     * single_var_decl_match := (Decorator)* (Identifier | Keys::UNDER) Tokens::COLON (Keys::UNDER | expression:(10))  (Tokens::EQUAL inner_matcher_expr)? 
     * ========================
     */
    def readSingleVarDeclarationForMatch (mut self)-> &Expression
        throws &ErrorMsg
    {
        let decos = self:.readDecorators ();
        let (ig, _) = self:.readIf (Keys::UNDER);
        let name = if (!ig.isEof ()) {
            ig
        } else { self:.readIdentifier ()._0 }
        
        if (name == Keys::SELF) throw ErrorMsg::fatal (name, format (SyntaxErrorMessage::USED_AS_IDENTIFIER, name.str ()));
        self:.readTokens (Tokens::COLON);
        let type = if ((self:.readIf (Keys::UNDER)._0).isEof ()) {
            self:.readExpression (level-> self._specials.binaryOperators.len)
        } else { cast!{&Expression} (EmptyExpression::new ()) }

        let value = if (!(self:.readIf (Tokens::EQUAL)._0).isEof ()) {
            self:.readMatchExpression ()
        } else { cast!{&Expression} (EmptyExpression::new ()) }

        VarDeclExpr::new (name, name, decos-> decos, value-> value, type-> type)
    }


    /**
     * Read a calling match expression
     * @verbatim:
     * ===============================
     * calling_match :=   (Identifier | Keys::UNDER) (Tokens::DCOLON Identifier)* (template_call)? ((Tokens::LPAR inner_matcher_expr Tokens::RPAR) | (Tokens::ARROW inner_matcher_expr))
     *                  | Keys::UNDER
     *                  | expression:(0)
     * ===============================
     */
    def readCallingMatch (mut self, loc : &Word)-> &Expression
        throws &ErrorMsg
    {
        let mut var : &Expression = VarExpr::new (loc);
        if (loc != Keys::UNDER) {
            loop {
                let (n, _) = self:.readIf(Tokens::NOT, Tokens::DCOLON);
                if (n == Tokens::NOT) {
                    self._lex:.rewind ();
                    var = self:.readTemplateCall (var);
                    break {}
                } else if (n == Tokens::DCOLON) {
                    var = BinaryExpr::new (n, var, VarExpr::new (self:.readIdentifier ()._0));
                } else break {}
            }
        }

        let (start, _) = self:.readIf (Tokens::LPAR);
        if (!start.isEof ()) {
            let dmut params = Vec!{&Expression}::new ();
            let mut e = self:.readIf (Tokens::RPAR, Tokens::COMA)._0;
            while e != Tokens::RPAR {
                params:.push (self:.readMatchExpression ());
                e = self:.readTokens (Tokens::RPAR, Tokens::COMA)._0;
            }

            MultOperatorExpr::new (start, e, var, params[])
        } else if (!(self:.readIf (Tokens::ARROW)._0).isEof ()) {
            NamedExpr::new (loc, self:.readMatchExpression ())
        } else {
            if (loc == Keys::UNDER) { var }
            else {
                self._lex:.rewindToSeek (cursor-> cast!u64 (loc.seek ()));
                self:.readExpression ()
            }
        }
    }


    /**
     * Read a list in match expression
     * @verbatim: 
     * ===============================
     * par_match :=   Tokens::LPAR (inner_matcher_expr (Tokens::COMA inner_matcher_expr)*)? Tokens::RPAR
     *              | Tokens::LCRO (inner_matcher_expr (Tokens::COMA inner_matcher_expr)*)? Tokens::RCRO
     * ===============================
     */
    def readParMatch (mut self, loc : &Word, endTok : [c8] = Tokens::RPAR)-> &Expression
        throws &ErrorMsg
    {
        let dmut params = Vec!{&Expression}::new ();
        let mut e = self:.readIf (endTok)._0;
        while e != Tokens::RPAR {
            params:.push (self:.readMatchExpression ());
            e = self:.readTokens (Tokens::COMA, endTok)._0;
        }

        ListExpr::new (loc, e, params[])
    }
    
    
    /**
     * ================================================================================
     * ================================================================================
     * =========================           LITERALS           =========================
     * ================================================================================
     * ================================================================================
     */


    /**
     * Read a literal 
     * @verbatim:
     * ================
     * literal :=   Numeric 
     *            | Float
     *            | Char
     *            | String
     *            | (Keys::TRUE | Keys::FALSE)
     *            | Keys::NULL
     *            | Tokens::DOLLAR
     * ================
     */
    def readLiteral (mut self, canBeFloat : bool = true)-> &Expression
        throws &ErrorMsg
    {
        let (start, _) = self._lex:.next ();
        self._lex:.rewind ();
        
        if (start.str ().len > 0us) {
            let c = start.str ()[0];
            if ((c >= '0'c8 && c <= '9'c8) || (c == '_'c8 && start.str ().len != 1us)) return self:.readNumeric (canBeFloat-> canBeFloat);            
        }

        if (start == Tokens::DOT && canBeFloat) {
            return self:.readFloat (begin-> EOF_WORD);
        } else if (start == Tokens::SQUOTE) {
            return self:.readString ();
        } else if (start == Tokens::DQUOTE) {
            return self:.readString ();
        } else if (start == Keys::TRUE || start == Keys::FALSE) {
            return BoolExpr::new (self._lex:.next ()._0);
        } else if (start == Keys::NULL) {
            return NullExpr::new (self._lex:.next ()._0);
        } else if (start == Tokens::DOLLAR) {
            return DollarExpr::new (self._lex:.next ()._0);
        } else if (start == Tokens::DDOT) {
            let tok = self._lex:.next ()._0;
            let type = self:.readOperand3 ();
            return RangeTypeExpr::new (tok, type);
        } else {
            throw ErrorMsg::fatal (start, format (SyntaxErrorMessage::UNEXPECTED, start.str ()));
        }
    }

    
    
    /**
     * Read a namepath expression 
     * @verbatim: 
     * =============
     * namepath_expr := Identifier ('::' Identifier)* 
     * =============
     */
    def readPath (mut self) -> &Expression
        throws &ErrorMsg
    {
        let fst = self:.readIdentifier ();
        let mut res : &Expression = VarExpr::new (fst._0);
        loop {
            let (next, _) = self:.readIf (Tokens::DCOLON);
            if (!next.isEof ())  {
                let af = {                    
                    let (x, _) = self:.readIf (Keys::UNDER);
                    if !x.isEof () { x }
                    else { self:.readIdentifier ()._0 }                        
                }
                res = PathExpr::new (next, res, VarExpr::new (af));
            } else break {}
        }
        
        res
    }

    /**
     * Read an array literal
     * @verbatim: 
     * =================
     * array_lit := Tokens::LCRO (expression:(0) (Tokens::COMA expression:(0))*)? Tokens::RCRO
     * =================
     */
    def readArray (mut self, loc : &Word)-> &Expression
        throws &ErrorMsg        
    {
        let (n, _) = self:.readIf (Tokens::RCRO);
        if (!n.isEof ()) return ListExpr::new (loc, n, [], isArray-> true);

        let dmut params = Vec!{&Expression}::new ();
        params:.push (self:.readExpression ());
        let (e, _) = self:.readIf (Tokens::SEMI_COLON, Tokens::RCRO, Tokens::COMA);
        if (e == Tokens::SEMI_COLON) { // allocation
            let dyn = !(self:.readIf (Keys::NEW)._0).isEof ();
            let size = self:.readExpression ();
            self:.readTokens (Tokens::RCRO);
            return SliceAllocatorExpr::new (loc, __pragma!trusted ({params [0us]}), size, isDynamic-> dyn)
        }

        let mut end = e;
        if (e != Tokens::RCRO) {
            loop {
                params:.push (self:.readExpression ());
                end = self:.readTokens([Tokens::RCRO, Tokens::COMA])._0;
                if (end == Tokens::RCRO) {
                    break {}
                }
            }
        }
        
        ListExpr::new (loc, end, params[], isArray-> true)
    }

    /**
     * Read a numeric value
     */
    def readNumeric (mut self, canBeFloat : bool = true)-> &Expression
        throws &ErrorMsg
    {        
        let (begin, _) = self._lex:.next ();
        if (begin.str ().len >= 4us) {
            let str_suff = begin.str ()[$ - 3us .. $];
            if (self.isFixedSuffix (str_suff)) {
                let suff = Word::new (str_suff, begin);
                let value = begin.str ()[0us .. $ - 3us];
                self.verifNumeric (begin, value);
                return FixedExpr::new (Word::new (value, begin), suffix-> suff);
            }
        }

        if (begin.str ().len >= 3us) {
            let str_suff = begin.str ()[$ - 2us .. $];
            if (self.isFixedSuffix (str_suff)) {
                let suff = Word::new (str_suff, begin);
                let value = begin.str ()[0us .. $ - 2us];
                self.verifNumeric (begin, value);
                return FixedExpr::new (Word::new (value, begin), suffix-> suff);
            }            
        }

        let value = begin.str ();
        if (!self.verifNumeric (begin, value) && canBeFloat) {
            let n = self:.readDirectIf (Tokens::DOT);
            if (n == Tokens::DOT) {
                self._lex:.rewind ();
                return self:.readFloat (begin-> begin);
            }
        }
        
        FixedExpr::new (begin)
    } 

    /**
     * Read a float expr
     * @params: 
     * - begin: the content before the dot
     */
    def readFloat (mut self, begin : &Word)-> &Expression
        throws &ErrorMsg
    {
        let (dot, after) = (self:.readDirectTokens (Tokens::DOT), 
                            self._lex:.directNext ());

        if (after.str ()[0] >= '0'c8 && after.str ()[0] <= '9'c8) {
            if (after.str ().len >= 2us) {
                if (self.isFloatSuffix (after.str ()[$ - 1us .. $])) {
                    let suff = Word::new (after.str ()[$ - 1us .. $], after);
                    let value = after.str ()[0us .. $ - 1us];
                    self.verifNumeric (after, value, canHexa-> false);
                    return FloatExpr::new (dot, begin, Word::new (value, after), suffix-> suff);
                }            
            }

            let value = after.str ();
            self.verifNumeric (after, value, canHexa-> false);
            return FloatExpr::new (dot, begin, after, suffix-> EOF_WORD)                
        } else if (begin.isEof ()) {
            throw ErrorMsg::fatal (after, format (SyntaxErrorMessage::UNEXPECTED, after.str ()));
        } else if (self.isFloatSuffix (after.str ())) {
            return FloatExpr::new (dot, begin, EOF_WORD, suffix-> after)
        } else {
            self._lex:.rewind ();
            return FloatExpr::new (dot, begin, EOF_WORD, suffix-> EOF_WORD)
        }
    } 


        
    /**
     * Read a string literal
     * @verbatim:
     * =======================
     * string_lit :=   Tokens::DQUOTE Any* Tokens::DQUOTE (StringSuffixes::UTF8 | StringSuffixes::UTF32)?
     *               | Tokens::SQUOTE Any* Tokens::SQUOTE (CharSuffixes::UTF8 | CharSuffixes::UTF32)?
     * =======================
     */
    def readString (mut self)-> &Expression
        throws &ErrorMsg
    {
        let (start, _) = self:.readTokens (Tokens::DQUOTE, Tokens::SQUOTE);
        let closing = start.str ();
        let (res, end) = self._lex:.getString (closing-> closing, escaping-> true);
        if (end.isEof ()) throw ErrorMsg::fatal (end, SyntaxErrorMessage::BLOCK_NEVER_CLOSED, notes-> [ErrorMsg::note (start, SyntaxErrorMessage::IN_DECL_BLOCK)]);

        let format = if (start == Tokens::DQUOTE) {
            self:.readDirectIf (self._specials.stringSuffixes)
        } else { self:.readDirectIf (self._specials.charSuffixes) }
        
        if (start == Tokens::DQUOTE) 
            StringExpr::new (start, end, res, suffix-> format)
        else CharExpr::new (start, end, res, suffix-> format)
    }

    
    
    
    /**
     * Read an identifier from the lexer
     * @throws:
     *    - ErrorMsg: if the next token is not a valid identifier
     */
    def readIdentifier (mut self)-> (&Word, [c8])
        throws &ErrorMsg
    {
        let (ident, comm) = self._lex:.next ();
        if (!self.isIdentifier (ident.str ())) {
            throw ErrorMsg::fatal (ident, format (SyntaxErrorMessage::USED_AS_IDENTIFIER, ident.str ()));
        }

        (ident, comm)
    }

    /**
     * Read an identifier if there is an identifier to read
     * @returns: the identifier (and associated comment), or (EOF_WORD, ""s8) if no identifier can be read
     */
    def readIfIdentifier (mut self)-> (&Word, [c8]) {
        let begin = self._lex.getCounter ();
        let x = self:.readIdentifier ()?;
        match x {
            Ok (name:_) => { name }
            _ => {
                self._lex:.rewindTo (nb-> begin);
                (EOF_WORD, ""s8)
            }
        }
    }
    
    /**
     * @returns: true if str is a valid identifier, false otherwise
     */
    def isIdentifier (self, str : [c8])-> bool {
        if (str in self._forbiddenKeys) {
            return false;
        }

        let mut i = 0u64;
        let mut found = false;
        for j in str { // must start by a letter, but can be preceded by as many _ as wanted
            if (j >= 'a'c8 && j <= 'z'c8) || (j >= 'A'c8 && j <= 'Z'c8) {
                found = true;
                break {}
            } else if (j != '_'c8) {
                return false;
            }
            i += 1u64;
        }
        
        i += 1u64;
        if (i < str.len) { // the rest of the identifier must be composed of letters, numbers, or _            
            for j in str [cast!usize (i) .. $] {
                if (j < 'a'c8 || j > 'z'c8) && (j < 'A'c8 || j > 'Z'c8) && (j != '_'c8) && (j < '0'c8 || j > '9'c8) {
                    return false;
                }
            }                        
        } else {
            return found;
        }
        
        true
    }


    
    /**
     * ================================================================================
     * ================================================================================
     * =========================        MISCELLANEOUS         =========================
     * ================================================================================
     * ================================================================================
     */
    
    
    /**
     * @returns: the next token inside the lexer, if it is equals to one of the token inside lst
     * @info: if none of lst token is found, the lexer is not incremented
     * @params: 
     *    - lst: a list of tokens 
     */
    def readIf {R...} (mut self, f : [c8], lst : R)-> (&Word, [c8]) {
        let (x, y) = self._lex:.next ();
        if (x.isEof ()) return (EOF_WORD, ""s8);

        if (self.equals (x.str (), f, expand lst)) return (x, y);
        
        self._lex:.rewind ();
        (EOF_WORD, ""s8)
    }

    def equals {A, R...} (self, r : [c8], a : A, b : R) -> bool {
        if a == r {
            true
        } else {
            cte if (R,)::arity != 1us {
                for i in b {
                    if i == r { return true; }
                }
                
                false
            } else {
                b == r
            }            
        }
    }

    def equals {A} (self, r : [c8], a : A)-> bool {
        r == a
    }
    
    /**
     * @returns: the next token inside the lexer, if it is equals to one of the token inside lst
     * @info: if none of lst token is found, the lexer is not incremented
     * @params: 
     *    - lst: a list of tokens 
     */
    def readIf (mut self, lst : [[c8]])-> (&Word, [c8]) {
        let (x, y) = self._lex:.next ();
        if (x.isEof ()) return (EOF_WORD, ""s8);

        for i in lst {
            if i == x.str () {
                return (x, y);
            }
        }
        
        self._lex:.rewind ();
        (EOF_WORD, ""s8)
    }

    /**
     * @returns: the next token inside the lexer, if it is equals to one of the token inside lst
     * @info: if none of lst token is found, the lexer is not incremented
     * @params: 
     *    - lst: a list of tokens 
     */
    def readDirectIf (mut self, lst : [[c8]])-> &Word {
        let x = self._lex:.directNext ();
        if (x.isEof ()) return EOF_WORD;

        for i in lst {
            if i == x.str () {
                return x;
            }
        }
        
        self._lex:.rewind ();
        EOF_WORD
    }


    /**
     * @returns: the next token inside the lexer, if it is equals to one of the token inside lst
     * @info: if none of lst token is found, the lexer is not incremented
     * @params: 
     *    - lst: a token 
     */
    def readIf (mut self, lst : [c8])-> (&Word, [c8]) {
        let (x, y) = self._lex:.next ();
        if (x.isEof ()) return (EOF_WORD, ""s8);
                          
        if (x.str () == lst) return (x, y);
        
        self._lex:.rewind ();
        (EOF_WORD, ""s8)
    }

    /**
     * @returns: the direct next token inside the lexer, if it is equals to one of the token inside lst
     * @info: if none of lst token is found, the lexer is not incremented
     * @params: 
     *    - lst: a token 
     */
    def readDirectIf (mut self, lst : [c8])-> &Word {
        let x = self._lex:.directNext ();
        if (x.isEof ()) return EOF_WORD;
                          
        if (x.str () == lst) return x;
        
        self._lex:.rewind ();
        EOF_WORD
    }    

    /**
     * @returns: the next token inside the lexer, if it is equals to one of the token inside lst
     * @throws: 
     *   - ErrorMsg: if none of the token in lst is equal to the token that have been read, or the next token is eof
     * @params: 
     *    - lst: a list of tokens 
     */
    def readTokens {R...} (mut self, f : [c8], lst : R)-> (&Word, [c8])
        throws &ErrorMsg
    {
        let (x, y) = self._lex:.next ();
        if (self.equals (x.str (), f, expand lst)) return (x, y);

        throw ErrorMsg::fatal (x, format (SyntaxErrorMessage::UNEXPECTED_BUT_LST, x.str (), lst));
    }

    /**
     * @returns: the next token inside the lexer, if it is equals to one of the token inside lst
     * @throws: 
     *   - ErrorMsg: if none of the token in lst is equal to the token that have been read, or the next token is eof
     * @params: 
     *    - lst: a list of tokens 
     */
    def readTokens (mut self, lst : [[c8]])-> (&Word, [c8])
        throws &ErrorMsg
    {
        let (x, y) = self._lex:.next ();
        for i in lst {
            if i == x.str () {
                return (x, y);
            }
        }

        throw ErrorMsg::fatal (x, format (SyntaxErrorMessage::UNEXPECTED_BUT_LST, x.str (), lst));
    }

    /**
     * @returns: the direct next token inside the lexer, if it is equals to one of the token inside lst
     * @throws: 
     *   - ErrorMsg: if none of the token in lst is equal to the token that have been read, or the next token is eof
     * @params: 
     *    - lst: a list of tokens 
     */
    def readDirectTokens (mut self, lst : [[c8]])-> &Word
        throws &ErrorMsg
    {
        let x = self._lex:.directNext ();
        for i in lst {
            if i == x.str () {
                return x;
            }
        }

        throw ErrorMsg::fatal (x, format (SyntaxErrorMessage::UNEXPECTED_BUT_LST, x.str (), lst));
    }


    /**
     * @returns: the next token inside the lexer, if it is equals to one of the token inside lst
     * @throws: 
     *   - ErrorMsg: if none of the token in lst is equal to the token that have been read, or the next token is eof
     * @params: 
     *    - lst: a token 
     */
    def readTokens (mut self, lst : [c8])-> (&Word, [c8])
        throws &ErrorMsg
    {
        let (x, y) = self._lex:.next ();
        if (x.str () == lst) return (x, y);

        throw ErrorMsg::fatal (x, format (SyntaxErrorMessage::UNEXPECTED_BUT_LST, x.str (), lst));
    }

    /**
     * @returns: the direct next token inside the lexer, if it is equals to one of the token inside lst
     * @throws: 
     *   - ErrorMsg: if none of the token in lst is equal to the token that have been read, or the next token is eof
     * @params: 
     *    - lst: a token 
     */
    def readDirectTokens (mut self, lst : [c8])-> &Word
        throws &ErrorMsg
    {
        let x = self._lex:.directNext ();
        if (x.str () == lst) return x;

        throw ErrorMsg::fatal (x, format (SyntaxErrorMessage::UNEXPECTED_BUT_LST, x.str (), lst));
    }

    

    /**
     * ================================================================================
     * ================================================================================
     * =========================            TESTS             =========================
     * ================================================================================
     * ================================================================================
     */
    
    /**
     * @returns: true, if this expression needs at the end, a semi colon to be separated from other expressions
     */
    def needClosingExpr (self, expr : &Expression)-> bool {
        match expr {
            a : &AtomicExpr => { self.needClosingExpr (a.getValue ()) }
            BlockExpr () => { false }
            b : &BreakExpr => { self.needClosingExpr (b.getValue ()) }
            ConditionalExpr () => { false }
            EmptyExpression () => { false }
            ForLoopExpr () => { false }
            UnitExpr () => { false }
            MatcherExpr () => { false }
            r : &ReturnExpr =>  { self.needClosingExpr (r.getValue ()) }
            ScopeGuardExpr () => { false }
            t : &ThrowExpr => { self.needClosingExpr (t.getValue ()) }
            l : &WhileLoopExpr => { l.isDo () }
            DisposeScopeExpr () => { false }
            s : &SetExpr => {
                if (s.getContent ().len != 0us) {
                    __pragma!trusted ({
                        self.needClosingExpr (s.getContent ()[$ - 1us])
                    })
                } else { false }
            }
            v : &VarDeclExpr => {
                match v.getValue () {
                    EmptyExpression () => { true }
                    
                    _ => {
                        self.needClosingExpr (v.getValue ())
                    }
                }
            }
            v : &DestructVarDeclExpr => {
                match v.getValue () {
                    EmptyExpression () => { true }
                    _ => {
                        self.needClosingExpr (v.getValue ())
                    }
                }
            }
            d : &DecoratedExpr => {
                if (d.getDecorators ().len == 1us && d.getDecorators ()[0us].deco == Decorators::CTE) {
                    self.needClosingExpr (d.getContent ())
                } else { true }
            }
            _ => { true }            
        }
    }

    /**
     * Verification of the content of the numeric
     * @returns: true iif in hexa decimal or octal
     */
    def verifNumeric (self, loc : &Word, value : [c8], canHexa : bool = true)-> bool 
        throws &ErrorMsg
    {
        if (value.len > 2us && value [0us] == '0'c8 && value [1] == 'x'c8 && canHexa) {
            for i in 2us .. value.len {
                if (value [i] < '0'c8 || value [i] > '9'c8) && (value [i] < 'A'c8 || value [i] > 'F'c8) && (value [i] < 'a'c8 && value [i] > 'f'c8) && value [i] != Keys::UNDER[0] {
                    throw ErrorMsg::fatal (loc, format (SyntaxErrorMessage::UNEXPECTED, value));
                }
            }

            true
        } else if (value.len > 2us && value [0] == '0'c8 && value [1] == 'o'c8 && canHexa) {
            for i in 2us .. value.len {
                if (value [i] < '0'c8 || value [i] > '7'c8) && value [i] != Keys::UNDER[0] {
                    throw ErrorMsg::fatal (loc, format (SyntaxErrorMessage::UNEXPECTED, value));
                }
            }

            true
        } else {
            for i in 0us .. value.len {
                if (value [i] < '0'c8 || value [i] > '9'c8) && value [i] != Keys::UNDER[0] {
                    throw ErrorMsg::fatal (loc, format (SyntaxErrorMessage::UNEXPECTED, value));
                }
            }

            false
        }
    } 

    
    /**
     * ================================================================================
     * ================================================================================
     * =========================             CONV             =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Transform a word into a protection
     * @info: if the word does not contain a protection, by default Protection::PRIVATE is returned
     */
    def toProtection (self, msg : [c8])-> Protection {
        match msg {
            Keys::PROTECTED => { Protection::PROTECTED }
            Keys::PUBLIC =>  { Protection::PUBLIC }
            _ => { Protection::PRIVATE }
        }
    }

    /**
     * Transform a word into a template var type
     * @info: if the word does not contain a template var type, by default TemplateVarType::TUPLE is returned
     */
    def toTemplateVarType (self, msg : [c8])-> TemplateVarType {
        match msg {
            Keys::ALIAS => { TemplateVarType::ALIAS }
            Keys::CLASS => { TemplateVarType::CLASS }
            Keys::STRUCT => { TemplateVarType::STRUCT }
            _ => { TemplateVarType::TUPLE }                
        }
    }

    /**
     * Transform a word into a template of var type
     * @info: if the word does not contain a template var type, by default TemplateOfVarType::IMPL is returned
     */
    def toTemplateOfVarType (self, msg : [c8])-> TemplateOfVarType {
        match msg {
            Keys::OF => { TemplateOfVarType::OF }
            Keys::OVER => { TemplateOfVarType::OVER }
            _ => { TemplateOfVarType::IMPL }                
        }
    }


    /**
     * Transform a word into a decorator
     * @info: if the word does not contain a decorator, by default Decorator::PURE is returned
     */
    def toDecorator (self, msg : [c8])-> Decorators {
        match msg {
            Keys::MUTABLE => { Decorators::MUT }
            Keys::DMUTABLE => { Decorators::DMUT }
            Keys::LAZY => { Decorators::LAZY }
            Keys::CTE => { Decorators::CTE }
            Keys::CONST => { Decorators::CONST }
            Keys::REF => { Decorators::REF }
            _ => { Decorators::PURE }                
        }
    }

    /**
     * Transform a word into an scope guard key
     * @info: if the word does not contain a scope guard name, by default ScopeGuardType::EXIT is returned
     */
    def toScopeGuard (self, msg : [c8])-> ScopeGuardType {
        match msg {
            ScopeGuardType::FAILURE => { ScopeGuardType::FAILURE }
            ScopeGuardType::SUCCESS => { ScopeGuardType::SUCCESS }
            _ => { ScopeGuardType::EXIT }
        }
    }
    
    /**
     * Transform a word into an intrinsic key
     * @info: if the word does not contain a intrinsic name, by default IntrinsicKeys::DCOPY is returned
     */
    def toIntrinsic (self, msg : [c8])-> IntrinsicKeys {
        match msg {
            IntrinsicKeys::COPY => {             IntrinsicKeys::COPY }
            IntrinsicKeys::EXPAND => { IntrinsicKeys::EXPAND }
            IntrinsicKeys::TYPEOF => { IntrinsicKeys::TYPEOF }
            IntrinsicKeys::SIZEOF => { IntrinsicKeys::SIZEOF }
            IntrinsicKeys::ALIAS => { IntrinsicKeys::ALIAS }
            _ => { IntrinsicKeys::DCOPY }
        }
    }

    /**
     * @returns: true if msg is a fixed suffix
     */
    def isFixedSuffix (self, msg : [c8])-> bool {
        for i in self._specials.fixedSuffixes {
            if (i == msg) return true;
        }

        false
    }

    /**
     * @returns: true if msg is a fixed suffix
     */
    def isFloatSuffix (self, msg : [c8])-> bool {
        for i in self._specials.floatSuffixes {
            if (i == msg) return true;
        }

        false
    }

    

    
    
}
    
