mod ymirc::syntax::visitor;

import ymirc::syntax::errors;
import ymirc::errors::_;
import ymirc::syntax::expression::_;
import ymirc::syntax::declaration::_;
import ymirc::syntax::_;
import ymirc::lexing::_;
import ymirc::utils::_;
import ymirc::global::state;

import std::fs::_;
import std::collection::set;
import std::collection::vec;
import std::collection::map;
import std::io;

import std::time::_;



/**
 * This struct is used to alloc only one time the arrays of tokens, and avoid lost of perf for allocation of const arrays
 */
struct
| binaryOperators : [[[c8]]] = BinaryOperatorsLevels::__members__
| specialBinaryOperators : [[c8]] = [Keys::IS, Keys::OF, Keys::IN]
| macroMult : [[c8]] = MacroMultTokens::__members__
| unaryOperators : [[c8]] = UnaryOperators::__members__
| intrinsicKeys : [[c8]] = IntrinsicKeys::__members__
| decorators : [[c8]] = Decorators::__members__
| skipTokens : [[c8]] = SkipTokens::__members__
| stringSuffixes : [[c8]] = StringSuffixes::__members__
| charSuffixes : [[c8]] = CharSuffixes::__members__
| fixedSuffixes : [[c8]] = FixedSuffixes::__members__
| floatSuffixes : [[c8]] = FloatSuffixes::__members__
 -> SpecialKeysAndTokens;


/**
 * The syntax visitor class is the class used to transform a text content into an analyzable syntax tree
 * The syntax visitor will validated the content of the source code, but only at a syntaxic level
 */
pub class SyntaxVisitor {

    /// The path of the file being read
    let _path : &Path;

    /// The lexer that is used to cut the content string in tokens
    let dmut _lex : &Lexer;

    /// The list of forbidden keys (for identifiers)
    let dmut _forbiddenKeys = HashSet!{[c8]}::new ();

    /// True iif currently reading template call expr without parentheses
    let mut _inTemplateCall = false;

    let _specials : SpecialKeysAndTokens;

    /**
     * Create a new visitor for a given file
     * @params:
     *  - path: the path of the file to read
     */
    pub self open (path : &Path)
        with _lex = Lexer::new (path.toStr (), content-> {
            with dmut f = File::open (path) {
                f:.readAll ()
            }
        }, tokens-> Tokens::__members__, comments-> CommentTokens::__members__, skips-> SkipTokens::__members__)
        , _specials = SpecialKeysAndTokens ()
        , _path = path
        throws &FsError
    {
        for i in Tokens::members {
            self._forbiddenKeys:.insert (i);
        }

        for i in ForbiddenKeys::members {
            self._forbiddenKeys:.insert (i);
        }
    }

    /**
     * Create a new visitor from string content
     * @params:
     *    - path: the path of the file containing the string
     *    - content: the content of the string
     *    - addLine: the location of the beginning of the string
     *    - addCol: the location of the beginning of the string
     * */
    pub self fromStr (path : [c8], content : [c8])
        with _lex = Lexer::new (path, content-> content,
                                tokens-> Tokens::__members__, comments-> CommentTokens::__members__, skips-> SkipTokens::__members__)
        , _specials = SpecialKeysAndTokens ()
        , _path = Path::new (path)
    {
        for i in Tokens::members {
            self._forbiddenKeys:.insert (i);
        }

        for i in ForbiddenKeys::members {
            self._forbiddenKeys:.insert (i);
        }
    }


    /*!
     * ================================================================================
     * ================================================================================
     * ========================            GETTERS            =========================
     * ================================================================================
     * ================================================================================
     */


    /**
     * @returns: the lexer
     * */
    pub fn getLexer (mut self)-> dmut &Lexer {
        alias self._lex
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================            MODULE            =========================
     * ================================================================================
     * ================================================================================
     */


    /**
     * Once the visitor is initialized, (with open for instance)
     * the content can be read an transformed into a syntax tree
     * @example:
     * =================
     * let dmut visitor = Visitor::open (Path::new ("foo.yr"));
     * {
     *    // verify the grammar of the content of the file
     *    // And return it into a syntax tre
     *    let module = visitor:.read ();
     *    println (format ("%"s8, module)); // pretty print the module that has been read
     * } catch {
     *    err : &ErrorMsg => {
     *          println (format ("%"s8, err)); // print the error that occured inside the file
     *    }
     * }
     * =================
     */
    pub fn read (mut self)-> &ModuleDecl
        throws &ErrorMsg
    {
        let start = instant::now ();
        let (loc, path, comm) = self:.readGlobalPath ();
        let ret = ModuleDecl::new (loc, path, comm, self:.readBlockDecl (loc, comm), isGlobal-> true);
        let end = instant::now ();

        timer::instance ():.getSyntaxMap ():.insert (self._path.toStr (), (end - start));
        ret
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================      DECLARATION BLOCKS      =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Read the first declaration line of the module (if any), and return the declared path
     * @returns:
     *    - the path, or Unit if nothing was found was found
     *    - the comments above the path
     */
    fn readGlobalPath (mut self) -> (&Word, &Word, [c8])
        throws &ErrorMsg
    {
        let beginPos = self._lex.getCounter ();

        let (next, comm) = self._lex:.next ();
        if (next != Keys::IN) {
            self._lex:.rewindTo (nb-> beginPos);
            return (next, EOF_WORD, ""s8);
        }

        let (path, _) = self:.readIdentifier ();
        self:.readTokens (Tokens::SEMI_COLON);
        (next, path, comm)
    }

    /**
     * Read a set of declaration in a global module (or in a global sub symbol, such as local module, protection block, etc.)
     * @verbatim:
     * ===================
     * decl_block := declaration | protection_block | version_block
     * ===================
     * @params:
     *     - close: if false, then the reading stops when the token eof () is found
     *              , otherwise it stops when the token Tokens::RACC is found
     */
    fn readBlockDecl (mut self, loc : &Word, comm : [c8], closing : bool = false, protection : Protection = Protection::PRIVATE, inProtection : bool = false) -> &BlockDecl
        throws &ErrorMsg
    {
        let dmut decls = Vec!(&Declaration)::new ();
        loop {
            let (attrLoc, attribs) = self:.readAttributes ();

            let beginCur = self._lex.getCounter ();
            let (tok, comm_) = self._lex:.next ();
            if (closing && tok.str () == Tokens::RACC) break {}
            if (!tok.isEof ()) self._lex:.rewindTo (nb-> beginCur);

            match tok.str () {
                Keys::PUBLIC | Keys::PRIVATE => {
                    if (inProtection) {
                        decls:.push (self:.readDeclaration (comm-> comm_, attribs-> (attrLoc, attribs)));
                    } else {
                        decls:.push (self:.readProtectionBlock (attribs-> (attrLoc, attribs)));
                    }
                }
                Keys::VERSION => {
                    self.checkNoAttributes (tok, attrLoc, attribs);
                    decls:.push (self:.readVersionBlock (protection-> protection));
                }
                Tokens::LACC => {
                    self.checkNoAttributes (tok, attrLoc, attribs);
                    self._lex:.next ();
                    decls:.push (self:.readBlockDecl (tok, comm_, closing-> true, protection-> protection, inProtection-> inProtection));
                }
                _ => {
                    if !tok.isEof () {
                        decls:.push (self:.readDeclaration (comm-> comm_, attribs-> (attrLoc, attribs)));
                    } else if (!closing) {
                        self.checkNoAttributes (tok, attrLoc, attribs);
                        break {}
                    }
                    else throw ErrorMsg::fatal (tok, SyntaxErrorMessage::BLOCK_NEVER_CLOSED);
                }
            }
        }

        BlockDecl::new (loc, comm, decls [], protection-> protection)
    }

    /**
     * Read a protection block
     * @verbatim:
     * ===============
     * protection_block :=   (Keys::PRIVATE | Keys::PUBLIC) Tokens::LACC decl_block Tokens::RACC
     *                     | (Keys::PRIVATE | Keys::PUBLIC) declaration
     * ===============
     */
    fn readProtectionBlock (mut self, attribs : (&Word, [AttributeWord]) = (EOF_WORD, [])) -> &BlockDecl
        throws &ErrorMsg
    {
        let (loc, comm) = self:.readIf (Keys::PRIVATE, Keys::PUBLIC);
        {
            let protection = if (loc.str () == Keys::PRIVATE) { Protection::PRIVATE } else { Protection::PUBLIC };
            let (tok, _) = self:.readIf (Tokens::LACC);
            if (tok.isEof ()) {
                BlockDecl::new (loc, comm, [self:.readDeclaration (comm-> comm, attribs-> attribs)], protection-> protection)
            } else {
                self.checkNoAttributes (tok, attribs._0, attribs._1);
                self:.readBlockDecl (loc, comm, closing-> true, protection-> protection, inProtection-> true)
            }
        } catch {
            err : &ErrorMsg => {
                if (!loc.isEof ()) {
                    throw ErrorMsg::note (loc, SyntaxErrorMessage::IN_DECL_BLOCK, notes-> [err]);
                } else {
                    throw err;
                }
            }
        }
    }

    /**
     * Visit a version block
     * @verbatim:
     * ================
     * version_block := Keys::VERSION Tokens::LACC decl_block Tokens::RACC (else Tokens::LACC decl_block Tokens::RACC)?
     * ================
     */
    fn readVersionBlock (mut self, protection : Protection = Protection::PRIVATE, inProtection : bool = false)-> &BlockDecl
        throws &ErrorMsg
    {
        let (loc, comm) = self._lex:.next ();
        {
            let (v, _) = self:.readIdentifier ();
            return if state::instance ().isVersionActive (v.str ()) {
                self:.readTokens (Tokens::LACC);
                let block = self:.readBlockDecl (loc, comm, closing-> true, protection-> protection, inProtection-> inProtection);
                if (!(self:.readIf (Keys::ELSE)._0).isEof ())
                    self:.ignoreBlock ();
                block
            } else {
                self:.ignoreBlock ();
                if (!(self:.readIf (Keys::ELSE)._0).isEof ()) {
                    self:.readTokens (Tokens::LACC);
                    self:.readBlockDecl (loc, comm, closing-> true, protection-> protection, inProtection-> inProtection)
                } else {
                    BlockDecl::new (loc, comm, [])
                }
            } ;
        } catch {
            err : &ErrorMsg => {
                if (!loc.isEof ()) {
                    throw err.appendNotes ([ErrorMsg::note (loc, SyntaxErrorMessage::IN_DECL_BLOCK)]);
                } else {
                    throw err;
                }
            }
        }
    }

    /**
     * Ignore a block of element (no matters what is inside)
     * Basically, it can be used to consider the next block of code as a comment
     * A block is enclosed by Tokens::LACC and Tokens::RACC
     */
    fn ignoreBlock (mut self)
        throws &ErrorMsg
    {
        let _ = self:.readTokens (Tokens::LACC);
        let mut nb = 1u64;
        loop {
            let (next, _) = self._lex:.next ();
            if (next == Tokens::RACC) {
                nb -= 1u64;
                if (nb == 0u64)
                    break {}
            } else if (next == Tokens::LACC) nb += 1u64;
            else if (next.isEof ())
            throw ErrorMsg::fatal (next, SyntaxErrorMessage::UNTERMINATED_BLOCK);
        }
    }
    /**
     * Read a declaration
     * @verbatim:
     * ==================
     * decl :=   aka_decl
     *         | class_decl
     *         | enum_decl
     *         | func_decl
     *         | static_decl
     *         | import_decl
     *         | extern_decl
     *         | macro_decl
     *         | mod_decl
     *         | struct_decl
     *         | trait_decl
     *         | unittest
     * ==================
     */
    fn readDeclaration (mut self, comm : [c8] = [], attribs : (&Word, [AttributeWord]) = (EOF_WORD, []))-> &Declaration
        throws &ErrorMsg
    {
        let (tok, postComm) = self._lex:.next ();
        match tok.str () {
            Keys::CLASS    => { return self:.readClass (tok, comm ~ postComm, attribs-> attribs._1, isStruct-> false); }
            Keys::FUNCTION => { return self:.readFunction (tok, comm ~ postComm, attribs-> attribs._1); }
            Keys::STRUCT   => { return self:.readClass (tok, comm ~ postComm, attribs-> attribs._1, isStruct-> true, isRecord-> false); }
            Keys::RECORD   => { return self:.readClass (tok, comm ~ postComm, attribs-> attribs._1, isStruct-> true, isRecord-> true); }
            Keys::STATIC   => { return self:.readGlobal (tok, comm ~ postComm, isStatic-> true, attribs-> attribs._1); }
            Keys::LAZY     => { return self:.readGlobal (tok, comm ~ postComm, attribs-> attribs._1); }
            Keys::EXTERN   => { return self:.readExtern (tok, comm ~ postComm, attribs-> attribs); }
            _ => {
                self.checkNoAttributes (tok, attribs._0, attribs._1);
                match tok.str () {
                    Keys::AKA    => { return self:.readAka (tok, comm ~ postComm); }
                    Keys::ENUM   => { return self:.readEnum (tok, comm ~ postComm); }
                    Keys::MACRO  => { return self:.readMacro (tok, comm ~ postComm); }
                    Keys::MOD    => { return self:.readLocalModuleDecl (tok, comm ~ postComm); }
                    Keys::TRAIT  => { return self:.readTrait (tok, comm ~ postComm); }
                    Keys::UNITTEST => { return self:.readUnitTest (tok, comm ~ postComm); }
                    Keys::USE => { return self:.readUse (tok, comm ~ postComm); }
                }

                throw ErrorMsg::fatal (tok, format (SyntaxErrorMessage::UNEXPECTED_BUT_LST, tok.str (),
                                                    [Keys::AKA, Keys::CLASS, Keys::ENUM,
                                                     Keys::USE, Keys::EXTERN, Keys::MACRO, Keys::MOD,
                                                     Keys::STRUCT, Keys::RECORD, Keys::TRAIT, Keys::STATIC, Keys::LAZY])
                                      );
            }
        }
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================             AKA              =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Read an aka declaration
     * @verbatim:
     * ===============
     * aka_decl :=   Keys::AKA Keys::IF expression:(0) Identifier template_param_list Tokens::EQUAL expression:(0)
     *             | Keys::AKA Identifier (template_param_list)? Tokens::EQUAL expression:(0)
     * ===============
     */
    fn readAka (mut self, _ : &Word, comm : [c8])-> &Declaration
        throws &ErrorMsg
    {
        let (hasTest, test) = self:.readTemplateTest ();
        let (ident, _) = self:.readIdentifier ();
        let (templates, tmpErr) = self:.readTemplateParameters (ifLoc-> hasTest);

        let a = {
            self:.readTokens (Tokens::EQUAL, Tokens::COLON)._0
        } catch {
            err : &ErrorMsg => {
                throw err.appendNotes (notes-> tmpErr);
            }
        };

        let value = self:.readExpression ();
        self:.readIf (Tokens::SEMI_COLON);

        if (templates.len == 0us) {
            AkaDecl::new (ident, comm, value, a)
        } else {
            TemplateDecl::new (ident, comm, templates, AkaDecl::new (ident, comm, value, a), test-> test)
        }
    }


    /*!
     * ================================================================================
     * ================================================================================
     * =========================            CLASS             =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Read a class declaration
     * @verbatim:
     * ===============
     * class_decl :=   Keys::CLASS Keys::IF expression:(0) (attribute_list)? Identifier template_param_list (Keys::OVER expression:(0))? class_block_decl
     *               | Keys::CLASS (attributes_list)? Identifier (template_param_list)? (Keys::OVER expression:(0))? class_block_decl
     * ===============
     */
    fn readClass (mut self,  _ : &Word, comm : [c8], attribs : [AttributeWord], isStruct : bool, isRecord : bool = false)-> &Declaration
        throws &ErrorMsg
    {
        let (hasTest, test) = self:.readTemplateTest ();
        let (ident, _) = self:.readIdentifier ();
        let (templates, tmpErr) = self:.readTemplateParameters (ifLoc-> hasTest);

        let ancestor =
            if (isStruct || (self:.readIf (Keys::OVER)._0).isEof ()) {
                EmptyExpression::new ()
            } else {
                self:.readExpression ()
            };

        let open = {
            self:.readTokens (Tokens::LACC)._0
        } catch {
            err : &ErrorMsg => throw err.appendNotes (notes-> tmpErr);
        };

        let decls = {
            self:.readClassBlockDecl (closing-> true, isStruct-> isStruct)
        } catch {
            err : &ErrorMsg => {
                if (!open.isEof ()) {
                    throw err.appendNotes ([ErrorMsg::note (open, SyntaxErrorMessage::IN_DECL_BLOCK)]);
                } else throw err;
            }
        }

        let cls = ClassDecl::new (ident, comm, decls, attrs-> attribs, ancestor-> ancestor, isStruct-> isStruct, isRecord-> isRecord);

        if (templates.len == 0u64) {
            cls
        } else {
            TemplateDecl::new (ident, comm, templates, cls, test-> test)
        }
    }

    /**
     * Read the inner part of a class declaration
     * @verbatim:
     * ================
     * class_block_decl :=   (Keys::PUBLIC | Keys::PRIVATE | Keys::PROTECTED) class_block_decl
     *                     | Keys::VERSION Identifier class_block_decl (Keys::ELSE class_block_decl)?
     *                     | Keys::CTE Keys::IF expression:(0) class_block_decl (Keys::ELSE class_block_decl)?
     *                     | class_inner_declaration*
     * ================
     * @params:
     *     - close: if false, then the reading stops after the first declaration, otherwise it stops when the token Tokens::RACC is found
     */
    fn readClassBlockDecl (mut self, closing : bool = false, inImpl : bool = false, inProtection : bool = false, isStruct : bool)-> [&Declaration]
        throws &ErrorMsg
    {
        let dmut vec = Vec!(&Declaration)::new ();
        loop {
            let (attrLoc, attribs) = self:.readAttributes ();

            let (next, comm) = self._lex:.next ();
            match next.str () {
                Keys::PRIVATE | Keys::PUBLIC | Keys::PROTECTED  => {
                    if (next.str () == Keys::PROTECTED && isStruct) throw ErrorMsg::fatal (next, format (SyntaxErrorMessage::UNEXPECTED, next.str ())); // no protected in struct
                    if (inProtection) throw ErrorMsg::fatal (next, format (SyntaxErrorMessage::UNEXPECTED, next.str ()));
                    let inner = {
                        let (acc, _) = self:.readIf (Tokens::LACC);
                        if (acc.isEof ()) {
                            let (d, c) = self._lex:.next ();
                            [self:.readClassInnerDecl (d, c, inImpl-> inImpl, inProtection-> true, attribs-> (attrLoc, attribs), isStruct-> isStruct)]
                        } else {
                            self.checkNoAttributes (next, attrLoc, attribs);
                            self:.readClassBlockDecl (inImpl-> inImpl, closing-> true, inProtection-> true, isStruct-> isStruct)
                        }
                    }  catch {
                        err : &ErrorMsg => {
                            if (!next.isEof ()) {
                                throw err.appendNotes ([ErrorMsg::note (next, SyntaxErrorMessage::IN_DECL_BLOCK)]);
                            } else throw err;
                        }
                    }
                    vec:.push (BlockDecl::new (next, comm, inner, protection-> self.toProtection (next.str ())));
                }
                Keys::VERSION => {
                    if (inImpl) throw ErrorMsg::fatal (next, format (SyntaxErrorMessage::UNEXPECTED, next.str ()));
                    self.checkNoAttributes (next, attrLoc, attribs);
                    vec:.push (self:.readVersionClass (next, comm, inProtection-> inProtection, isStruct-> isStruct));
                }
                Keys::CTE => {
                    if (inImpl) throw ErrorMsg::fatal (next, format (SyntaxErrorMessage::UNEXPECTED, next.str ()));
                    self.checkNoAttributes (next, attrLoc, attribs);
                    vec:.push (self:.readIfClass (next, comm, inProtection-> inProtection, isStruct-> isStruct));
                }
                Tokens::LACC => {
                    self.checkNoAttributes (next, attrLoc, attribs);
                    if (closing) throw ErrorMsg::fatal (next, format (SyntaxErrorMessage::UNEXPECTED_BUT_LST, next.str (), [Keys::PUBLIC, Keys::PROTECTED, Keys::PRIVATE]));
                    else {
                        let r = self:.readClassBlockDecl (inImpl-> inImpl, closing-> true, inProtection-> inProtection, isStruct-> isStruct);
                        for i in r { vec:.push (i); }
                    }
                }
                Tokens::RACC => {
                    self.checkNoAttributes (next, attrLoc, attribs);
                    if (closing) break {}
                    else {
                        if (!isStruct) {
                            throw ErrorMsg::fatal (next, format (SyntaxErrorMessage::UNEXPECTED_BUT_LST, next.str (), [Keys::PUBLIC, Keys::PROTECTED, Keys::PRIVATE]));
                        } else
                            throw ErrorMsg::fatal (next, format (SyntaxErrorMessage::UNEXPECTED_BUT_LST, next.str (), [Keys::PUBLIC, Keys::PRIVATE]));
                    } 
                }
                _ => {
                    vec:.push (self:.readClassInnerDecl (next, comm, inImpl-> inImpl, inProtection-> inProtection, attribs-> (attrLoc, attribs), isStruct-> isStruct));
                }
            }

            if (!closing) {
                break {}
            }
        }


        vec:.fit ();
        vec []
    }

    /**
     * Read a version inside a class definition
     * @verbatim:
     * ===================
     * version_class := __version Identifier class_block_decl ('else' class_block_decl)?
     * ===================
     * @params:
     *   - inProtection: impl and import cannot be under protected declarators, and must be declared at root level of the class
     */
    fn readVersionClass (mut self, loc : &Word, comm : [c8], inProtection : bool = false, isStruct : bool)-> &Declaration
        throws &ErrorMsg
    {
        let (v, _) = self:.readIdentifier ();
        return if state::instance ().isVersionActive (v.str ()) {
            self:.readTokens (Tokens::LACC);
            let block = self:.readClassBlockDecl (closing-> true, inProtection-> inProtection, isStruct-> isStruct);
            if (!(self:.readIf (Keys::ELSE)._0).isEof ()) {
                self:.ignoreBlock ();
            }

            BlockDecl::new (loc, comm, block, isSet-> true)
        } else {
            self:.ignoreBlock ();
            if (!(self:.readIf (Keys::ELSE)._0).isEof ()) {
                self:.readTokens (Tokens::LACC);
                let block = self:.readClassBlockDecl (closing-> true, inProtection-> inProtection, isStruct-> isStruct);
                BlockDecl::new (loc, comm, block, isSet-> true)
            } else {
                BlockDecl::new (loc, comm, [], isSet-> true)
            }
        }
    }

    /**
     * Read a if condition or assert inside a class definition
     * @verbatim:
     * ================
     * if_class := Keys::CTE (Keys::IF expression block (Keys::ELSE block)?) | (Keys::ASSERT Tokens::LPAR expression (Tokens::COMA expression)? Tokens::RPAR )
     * ================
     */
    fn readIfClass (mut self, loc : &Word, comm : [c8], inProtection : bool = false, isStruct : bool)-> &Declaration
        throws &ErrorMsg
    {
        let (a, _) = self:.readTokens (Keys::IF, Keys::ASSERT);
        match a.str () {
            Keys::IF => {
                let test = self:.readExpression ();
                let fst = self:.readClassBlockDecl (closing-> false, inProtection-> inProtection, isStruct-> isStruct);
                let (next, ncomm) = self:.readIf (Keys::ELSE);
                if (next == Keys::ELSE) {
                    let scd = self:.readClassBlockDecl (closing-> false, inProtection-> inProtection, isStruct-> isStruct);
                    CondBlockDecl::new (loc, comm, fst, test, else_-> BlockDecl::new (next, ncomm, scd))
                } else {
                    CondBlockDecl::new (loc, comm, fst, test)
                }
            }
            _ => {
                self:.readTokens (Tokens::LPAR);
                let test = self:.readExpression ();
                let msg : &Expression = if (self:.readTokens (Tokens::RPAR, Tokens::COMA)._0 == Tokens::COMA) {
                    let msg_ : &Expression = self:.readExpression ();
                    self:.readTokens (Tokens::RPAR);
                    msg_
                } else { cast!{&Expression} (EmptyExpression::new ()) }
                self:.readIf (Tokens::SEMI_COLON);

                ExpressionWrapperDecl::new (loc, comm, AssertExpr::new (loc, test, msg))
            }
        }
    }

    /**
     * Read a declaration inside a class definition
     * @verbatim:
     * ===============
     * class_inner_decl :=   constructor
     *                     | function
     *                     | field
     *                     | impl (if !inProtection)
     *                     | import (if !inProtection)
     * ===============
     * @params:
     *    - inProtection: impl and import cannot be under protected declarators, and must be declared at root level of the class
     */
    fn readClassInnerDecl (mut self, loc : &Word, comm : [c8], inImpl : bool = false, inProtection : bool = false, attribs : (&Word, [AttributeWord]) = (EOF_WORD, []), isStruct : bool)-> &Declaration
        throws &ErrorMsg
    {
        if (inImpl && loc != Keys::FUNCTION && loc != Keys::OVER) {
            throw ErrorMsg::fatal (loc, format (SyntaxErrorMessage::UNEXPECTED_BUT_LST, loc.str (), [Keys::FUNCTION, Keys::OVER]));
        }

        match loc {
            Keys::SELF => { return self:.readClassConstructor (loc, comm, attribs-> attribs._1, isStruct-> isStruct); }
            Keys::FUNCTION  => { return self:.readFunction (loc, comm, isMethod-> true, attribs-> attribs._1); }
            Keys::OVER => { if (!isStruct) return self:.readFunction (loc, comm, isMethod-> true, isOver-> true, attribs-> attribs._1); }
        }

        self.checkNoAttributes (loc, attribs._0, attribs._1);
        match loc {
            Keys::LET  => {
                return self:.readGlobal (loc, comm, isField-> true, attribs-> []);
            }
            Keys::IMPL => {
                if (inProtection) {
                    throw ErrorMsg::warn (loc, SyntaxErrorMessage::IMPL_IN_PROTECTION);
                }
                return self:.readImplement (loc, comm);
            }
            Keys::USE => {
                if (inProtection) {
                    throw ErrorMsg::warn (loc, SyntaxErrorMessage::USE_IN_PROTECTION);
                }
                return self:.readUse (loc, comm);
            }
            Keys::DTOR => {
                // if (isStruct) throw ErrorMsg::fatal (loc, format (SyntaxErrorMessage::UNEXPECTED, loc.str ()));
                if (inProtection) {
                    throw ErrorMsg::warn (loc, SyntaxErrorMessage::DESTRUCTOR_IN_PROTECTION);
                }
                return self:.readClassDestructor (loc, comm);
            }
            _ => {
                let lst = if inProtection {
                    if isStruct {
                        [Keys::SELF, Keys::FUNCTION, Keys::LET]
                    } else { [Keys::SELF, Keys::FUNCTION, Keys::OVER, Keys::LET] }
                } else {
                    if (isStruct) {
                        [Keys::SELF, Keys::FUNCTION, Keys::LET, Keys::IMPL, Keys::USE]
                    } else {
                        [Keys::SELF, Keys::FUNCTION, Keys::OVER, Keys::LET, Keys::IMPL, Keys::USE, Keys::DTOR]
                    }
                };

                throw ErrorMsg::fatal (loc, format (SyntaxErrorMessage::UNEXPECTED_BUT_LST, loc.str (), lst));
            }
        }
    }

    /**
     * Read a class constructor
     * @verbatim:
     * ================
     * constructor :=   Keys::SELF Keys::IF expression:(0) (attribs)? (Identifier)? template_param_list param_list (with_decl)? (throws_decl)? expression:(0)
     *                | Keys::SELF (attribs)? (Identifier)? (template_param_list)? param_list (with_decl)? (throws_decl)? expression:(0)
     * ================
     */
    fn readClassConstructor (mut self, loc : &Word, comm : [c8], attribs : [AttributeWord], isStruct : bool) -> &Declaration
        throws &ErrorMsg
    {
        let (hasTest, test) = self:.readTemplateTest ();
        let (name, _) = self:.readIfIdentifier ();
        let (templates, tmpErr) = self:.readTemplateParameters (ifLoc-> hasTest);

        let proto = self:.readFunctionPrototype (tmpError-> tmpErr);

        let dmut construction = Vec!{(&Word, &Expression)}::new ();
        let mut supers : [&Expression] = [], mut tmpCall : &Expression = EmptyExpression::new ();
        let mut auxCstrLoc = EOF_WORD, mut auxCstrName = EOF_WORD;
        if (!(self:.readIf (Keys::WITH)._0).isEof ()) {
            loop {
                let (next, _) = self._lex:.next ();
                match next.str () {
                    Keys::SUPER | Keys::SELF => {
                        if (isStruct && next.str () == Keys::SUPER) throw ErrorMsg::fatal (next, format (SyntaxErrorMessage::UNEXPECTED, next.str ()));
                        if (!auxCstrLoc.isEof ())
                            throw ErrorMsg::fatal (next, SyntaxErrorMessage::MULTIPLE_AUX_CSTRS, notes-> [ErrorMsg::note (auxCstrLoc, ""s8)]);

                        auxCstrLoc = next;
                        auxCstrName = if (self:.readIf (Tokens::DCOLON)._0.isEof ()) {
                            EOF_WORD
                        } else {
                            self:.readIdentifier ()._0
                        };

                        tmpCall = self:.readTemplateCall (tmpCall);
                        self:.readTokens (Tokens::LPAR);
                        supers = self:.readArgumentList (withNamed-> true)._0;
                    }
                    _ => {
                        if (!self.isIdentifier (next.str ()))
                            throw ErrorMsg::fatal (next, format (SyntaxErrorMessage::USED_AS_IDENTIFIER, next.str ()));

                        self:.readTokens (Tokens::EQUAL);
                        construction:.push ((next, self:.readExpression ()));
                    }
                }

                if ((self:.readIf (Tokens::COMA)._0).isEof ()) {
                    break {}
                }
            }
        }

        let (throwLoc, throwers) = self:.readThrowers ();
        let body = self:.readExpression ();

        let cstr = ConstructorDecl::new (loc, comm, rename-> name, proto,
                                         superParams-> supers, superTemplateParams-> tmpCall,
                                         fields-> construction[],
                                         body-> body,
                                         explicitCstrsCall-> auxCstrLoc, explicitSuperName-> auxCstrName, attributes-> attribs,
                                         throwers-> throwers, throwerLoc-> throwLoc);

        if (templates.len != 0u64) {
            TemplateDecl::new (loc, comm, templates, cstr, test-> test)
        } else {
            cstr
        }
    }

    /**
     * Read class destructor
     * @verbatim:
     * ================
     * destructor := Keys::DTOR Tokens::LPAR Keys::MUT Keys::SELF Tokens::RPAR expression:(0)
     * ================
     */
    fn readClassDestructor (mut self, loc : &Word, comm : [c8])-> &Declaration
        throws &ErrorMsg
    {
        self:.readTokens (Tokens::LPAR);
        let var = self:.readSingleVarDeclaration (mandType-> false, withValue-> false, isClass-> true);
        self:.readTokens (Tokens::RPAR);

        let content = self:.readExpression ();
        DestructorDecl::new (loc, comm, var, content)
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================          IMPLEMENT           =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Read an implementation of traits inside a class definition
     * @verbatim:
     * ==================
     * impl := Keys::IMPL expression:(0) (((',' expression:(0))* ';') | class_block_decl)
     * ==================
     */
    fn readImplement (mut self, loc : &Word, comm : [c8]) -> &Declaration
        throws &ErrorMsg
    {
        let trait_ = self:.readExpression ();
        let (next, _) = self:.readIf (Tokens::SEMI_COLON, Tokens::COMA, Tokens::LACC);
        if (next == Tokens::LACC) {
            let content = self:.readClassBlockDecl (inImpl-> true, inProtection-> false, closing-> true, isStruct-> false);
            ImplDecl::new (loc, comm, trait_, content-> content)
        } else if (next == Tokens::COMA) {
            let dmut impls = Vec!{&Declaration}::new ();
            impls:.push (ImplDecl::new (loc, comm, trait_));
            loop {
                let tr = self:.readExpression ();
                let (n, _) = self:.readTokens (Tokens::SEMI_COLON, Tokens::COMA);
                impls:.push (ImplDecl::new (loc, comm, tr));
                if (n == Tokens::SEMI_COLON) break {}
            }
            BlockDecl::new (loc, comm, impls[])
        } else {
            ImplDecl::new (loc, comm, trait_)
        }
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================             ENUM             =========================
     * ================================================================================
     * ================================================================================
     */


    /**
     * Read an enumeration definition
     * @verbatim:
     * =======================
     * enum_decl :=   Keys::ENUM Keys::IF expression:(0) enum_content Keys::ARROW Identifier template_param_list (Tokens::SEMI_COLON)?
     *              | Keys::ENUM enum_content Keys::ARROW Identifier (Tokens::SEMI_COLON)?
     *
     * enum_content := (Tokens::PIPE Identifier ('=' expression:(0))?)*
     * =======================
     */
    fn readEnum (mut self,  loc : &Word, comm : [c8])-> &Declaration
        throws &ErrorMsg
    {
        let (hasTest, test) = self:.readTemplateTest ();

        let type = if (!((self:.readIf (Tokens::COLON))._0).isEof ()) {
            self:.readOperand3 ()
        } else { cast!{&Expression} (EmptyExpression::new ()) }

        let dmut values = Vec!{&VarDeclExpr}::new ();
        let dmut coms = Vec!{[c8]}::new ();
        let mut fst = true;
        loop {
            let (n, com) = self:.readTokens (Tokens::PIPE, Tokens::ARROW);
            if (!fst) coms:.push (com);

            if (n != Tokens::ARROW) {
                let (name, _) = self:.readIdentifier ();
                if (!(self:.readIf (Tokens::EQUAL)._0).isEof ()) {
                    values:.push (VarDeclExpr::new (name, name, value-> self:.readExpression (level-> self._specials.binaryOperators.len), type-> EmptyExpression::new ()))
                } else {
                    values:.push (VarDeclExpr::new (name, name, value-> EmptyExpression::new (), type-> EmptyExpression::new ()))
                }
            } else break {}
            fst = false;
        }

        let (name, _) = self:.readIdentifier ();
        let (templates, tmpErr) = self:.readTemplateParameters (ifLoc-> hasTest);

        {
            self:.readTokens (Tokens::SEMI_COLON);
        } catch {
            err : &ErrorMsg => throw err.appendNotes (notes-> tmpErr);
        }

        if (templates.len == 0us) {
            EnumDecl::new (name, comm, type-> type, values-> values[], fieldComms-> coms[])
        } else {
            TemplateDecl::new (loc, comm, templates, test-> test, content->
                           EnumDecl::new (name, comm, type-> type, values-> values[], fieldComms-> coms[])
                           )
        }
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================           FUNCTION           =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Read a function definition
     * @verbatim:
     * ====================
     * function :=   Keys::IF expression:(0) Identifier template_param_list function_proto throwers body
     *             | Identifier function_proto throwers body
     * ====================
     */
    fn readFunction (mut self,  _ : &Word, comm : [c8], attribs : [AttributeWord], isMethod : bool = false, isOver : bool = false)-> &Declaration
        throws &ErrorMsg
    {
        let (hasTest, test) = self:.readTemplateTest ();
        let (name, _) = self:.readIdentifier ();
        if (name == Keys::SELF) throw ErrorMsg::fatal (name, format (SyntaxErrorMessage::USED_AS_IDENTIFIER, name.str ()));
        let (templates, tmpErr) = self:.readTemplateParameters (ifLoc-> hasTest);

        let proto = self:.readFunctionPrototype (isClosure-> false, isClass-> isMethod, tmpError-> tmpErr);
        let (throwLoc, throwers) = self:.readThrowers ();
        let body = self:.readFunctionBody ();

        if (templates.len == 0us) {
            FunctionDecl::new (name, comm, proto, body, attrs-> attribs, throwers-> throwers, isOver-> isOver, throwerLoc-> throwLoc)
        } else {
            TemplateDecl::new (name, comm, templates, test-> test, content->
                           FunctionDecl::new (name, comm, proto, body, attrs-> attribs, throwers-> throwers, isOver-> isOver, throwerLoc-> throwLoc)
                           )
        }
    }

    /**
     * Read a function body
     * @verbatim:
     * ===================
     * body := ';' | expression:(0)
     * ===================
     */
    fn readFunctionBody (mut self)-> &Expression
        throws &ErrorMsg
    {
        if ((self:.readIf (Tokens::SEMI_COLON)._0).isEof ()) {
            self:.readExpression ()
        } else {
            cast!{&Expression} (EmptyExpression::new ())
        }
    }

    /**
     * Read a function prototype
     * @verbatim:
     * ====================
     * closure_proto := Tokens::PIPE (var_decl (',' var_decl)*)? Tokens::PIPE (Tokens::ARROW expression:(0))?
     * function_proto := Tokens::LPAR (var_decl (',' var_decl)*)? Tokens::RPAR (Tokens::ARROW expression:(0))?
     * ====================
     */
    fn readFunctionPrototype (mut self, tmpError : [&ErrorMsg] = [], isClosure : bool = false, isClass : bool = false)-> &FunctionProtoDecl
        throws &ErrorMsg
    {
        let (loc, hasParams) = {
            if isClosure {
                let (n, _) = self:.readTokens (Tokens::PIPE, Tokens::DPIPE);
                (n, n == Tokens::PIPE)
            } else { (self:.readTokens (Tokens::LPAR)._0, true) }
        } catch {
            err : &ErrorMsg => throw err.appendNotes (notes-> tmpError);
        };

        let mut isVariadic = false;
        let dmut params = Vec!{&VarDeclExpr}::new ();
        if hasParams {
            loop {
                if (isClosure) {
                    if ((self:.readIf (Tokens::PIPE)._0).isEof ()) {
                        params:.push (self:.readSingleVarDeclaration (mandType-> false, withValue-> false, isClass-> false));
                        if ((self:.readTokens (Tokens::PIPE, Tokens::COMA)._0) == Tokens::PIPE) break {}
                    } else break {}
                } else {
                    let tok = if (!isClass || params.len () > 0us) {
                        self:.readIf (Tokens::RPAR, Tokens::TDOT)._0
                    } else { EOF_WORD }

                    if (tok == Tokens::TDOT) {
                        isVariadic = true;
                        self:.readTokens (Tokens::RPAR);
                        break {}
                    } else if (tok != Tokens::RPAR) {
                        params:.push (self:.readSingleVarDeclaration (mandType-> true, withValue-> true, isClass-> (isClass && params.len () == 0us)));
                        if ((self:.readTokens (Tokens::RPAR, Tokens::COMA)._0) == Tokens::RPAR) break {}
                    } else break {}
                }
            }
        }

        if (!(self:.readIf (Tokens::ARROW)._0).isEof ()) {
            FunctionProtoDecl::new (loc, params-> params [], retType-> self:.readExpression (), isVariadic-> isVariadic, forLambda-> isClosure)
        } else {
            FunctionProtoDecl::new (loc, params-> params [], retType-> EmptyExpression::new (), isVariadic-> isVariadic, forLambda-> isClosure)
        }
    }

    /**
     * Read the list of throwers of a function
     * @verbatim:
     * ====================
     * throwers: (Keys::THROWS expression:(0) (',' expression:(0))*)?
     * ====================
     */
    fn readThrowers (mut self)-> (&Word, [&Expression])
        throws &ErrorMsg
    {
        let (th, _) = self:.readIf (Keys::THROWS);
        let dmut res = Vec!{&Expression}::new ();
        if (!th.isEof ()) {
            loop {
                res:.push (self:.readExpression ());
                let (n, _) = self:.readIf (Tokens::COMA);
                if (n.isEof ()) break {}
            }
        }

        (th, res[])
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================            GLOBAL            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Read a global var declaration
     * @verbatim:
     * ====================
     * global := var_decl
     * ====================
     */
    fn readGlobal (mut self,  loc : &Word, comm : [c8], isField : bool = false, isStatic : bool = false, forceType : bool = false, attribs : [AttributeWord])-> &GlobalDecl
        throws &ErrorMsg
    {
        let (_, isMutOrDmut) = self:.readDecoratorVariable (canBeLazyOrRef-> false);
        let name = self:.readIdentifier ()._0;
        if (name == Keys::SELF) {
            throw ErrorMsg::fatal (name, format (SyntaxErrorMessage::USED_AS_IDENTIFIER, name.str ()));
        }

        let type = if (forceType) {
            self:.readTokens (Tokens::COLON);
            self:.readExpression (level-> self._specials.binaryOperators.len)
        } else if (self:.readIf (Tokens::COLON)._0 == Tokens::COLON) {
            self:.readExpression (level-> self._specials.binaryOperators.len)
        } else {
            cast!{&Expression} (EmptyExpression::new ())
        };

        let value = if (self:.readIf (Tokens::EQUAL)._0 == Tokens::EQUAL) {
            self:.readExpression (level-> 0us)
        } else {
            cast!{&Expression} (EmptyExpression::new ())
        };

        let overLazyOrRef = if (!isStatic && !isField) {
            Word::new (Keys::LAZY, loc)
        } else {
            EOF_WORD
        };

        let inner = VarDeclExpr::new (name, name,
                                      isMutOrDmut-> isMutOrDmut,
                                      isLazyOrRef-> overLazyOrRef,
                                      value-> value,
                                      type-> type);

        let glb = GlobalDecl::new (loc, comm, inner, isField-> isField, isStatic-> isStatic, attrs-> attribs);
        self:.readTokens (Tokens::SEMI_COLON);

        glb
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================            EXTERN            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Read an extern declaration
     * @verbatim:
     * ====================
     * extern: Keys::EXTERN (Tokens::LPAR Language (Tokens::COMA path)? Tokens::RPAR)? decl_block
     * ====================
     */
    fn readExtern (mut self,  loc : &Word, comm : [c8], attribs : (&Word, [AttributeWord]))-> &ExternBlockDecl
        throws &ErrorMsg
    {
        let (n, _) = self:.readIf (Tokens::LPAR);
        let (language, space) = if (!n.isEof ()) {
            let (l, _) = self:.readTokens (Keys::CLANG);
            let space = if (!(self:.readIf (Tokens::COMA)._0).isEof ()) {
                self:.readPath ()
            } else { cast!{&Expression} (EmptyExpression::new ()) }
            self:.readTokens (Tokens::RPAR);
            (l, space)
        } else { (Word::new (Keys::YLANG, loc), cast!{&Expression} (EmptyExpression::new ())) }

        let (tok, _) = self:.readIf (Tokens::LACC);
        if (tok.isEof ()) {
            ExternBlockDecl::new (loc, comm, language, space, self:.readDeclaration (comm-> comm, attribs-> attribs))
        } else {
            self.checkNoAttributes (tok, attribs._0, attribs._1);
            ExternBlockDecl::new (loc, comm, language, space, self:.readBlockDecl (loc, comm, closing-> true, inProtection-> true))
        }
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================            MACRO             =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Read a macro declaration
     * @verbatim:
     * ==================
     * macro := Keys::MACRO Identifier macro_block
     * ==================
     */
    fn readMacro (mut self,  _ : &Word, comm : [c8])-> &MacroDecl
        throws &ErrorMsg
    {
        let (name, _) = self:.readIdentifier ();
        self:.readTokens (Tokens::LACC);
        MacroDecl::new (name, comm, self:.readMacroBlock ())
    }



    /**
     * Read the content of a macro
     * @verbatim:
     * =================
     * macro_block := Tokens::LACC (public_macro_block | version_macro_block)* Tokens::RACC
     * =================
     */
    fn readMacroBlock (mut self) -> [&Declaration]
        throws &ErrorMsg
    {
        let dmut decls = Vec!{&Declaration}::new ();
        loop {
            let (n, comm) = self:.readIf (Keys::VERSION, Keys::USE, Tokens::RACC);
            match n {
                Tokens::RACC => { break {} }
                Keys::VERSION => {
                    decls:.push (self:.readVersionMacroBlock (n, comm));
                }
                Keys::USE => {
                    decls:.push (self:.readUse (n, comm));
                }
                _ => {
                    decls:.push (self:.readMacroContent ());
                }
            }
        }

        decls []
    }

    /**
     * Visit a version part of a macro block
     * @verbatim:
     * ======================
     * version_macro_block := Keys::VERSION Identifier macro_block (Keys::ELSE macro_block)
     * ======================
     */
    fn readVersionMacroBlock (mut self, loc : &Word, comm : [c8])-> &Declaration
        throws &ErrorMsg
    {
        let (ident, _) = self:.readIdentifier ();
        if (state::instance ().isVersionActive (ident.str ())) {
            self:.readTokens (Tokens::LACC);
            let decls = self:.readMacroBlock ();
            if (!(self:.readIf (Keys::ELSE)._0).isEof ()) {
                self:.ignoreBlock ();
            }

            BlockDecl::new (loc, comm, decls, protection-> Protection::PUBLIC)
        } else {
            self:.ignoreBlock ();
            if (!(self:.readIf (Keys::ELSE)._0).isEof ()) {
                self:.readTokens (Tokens::LACC);
                let decls = self:.readMacroBlock ();
                BlockDecl::new (loc, comm, decls, protection-> Protection::PUBLIC)
            } else {
                BlockDecl::new (loc, comm, [])
            }
        }
    }

    /**
     * Read the content of a macro definition
     * @verbatim:
     * =================
     * marco_content := macro_constructor | macro_rule
     * =================
     */
    fn readMacroContent (mut self) -> &Declaration
        throws &ErrorMsg
    {
        let (type, comm) = self:.readTokens (Keys::FUNCTION, Keys::SELF);
        match type {
            Keys::FUNCTION => {
                self:.readMacroRule (type, comm)
            }
            _ => self:.readMacroConstructor (type, comm)
        }
    }

    /**
     * Read a macro rule
     * @verbatim:
     * ===============
     * macro_rule := Keys::FUNCTION Identifier macro_head_rule (Tokens::SEMI_COLON | macro_body_rule)
     * ===============
     */
    fn readMacroRule (mut self, _ : &Word, comm : [c8]) -> &Declaration
        throws &ErrorMsg
    {
        let (name, _) = self:.readIdentifier ();
        let (head, skips) = self:.readMacroRuleHead ();

        let (bodyLoc, body) = if (self:.readIf (Tokens::SEMI_COLON)._0.isEof ()) {
            self:.readMacroRuleBody ()
        } else { (EOF_WORD, ""s8) }

        MacroRuleDecl::new (name, comm, bodyLoc, body, head, skips-> skips, isConstructor-> false)
    }


    /**
     * Read a macro constructor
     * @verbatim:
     * ==================
     * macro_constructor := Keys::SELF macro_head_rule macro_body_rule
     * ==================
     */
    fn readMacroConstructor (mut self, loc : &Word, comm : [c8]) -> &Declaration
        throws &ErrorMsg
    {
        let (head, skips) = self:.readMacroRuleHead ();
        let (bodyLoc, body) = self:.readMacroRuleBody ();

        MacroRuleDecl::new (loc, comm, bodyLoc, body, head, skips-> skips, isConstructor-> true)
    }


    /**
     * Read the head (prototype) of a macro rule (or constructor)
     * @verbatim:
     * =================
     * macro_rule_head :=  macro_inner_mult (Keys::SKIPS string_lit (Tokens::PIPE string_lit)*)?
     * =================
     */
    fn readMacroRuleHead (mut self)-> (&MacroMultExpr, [&Expression])
        throws &ErrorMsg
    {
        let (start, end, inner) = self:.readInnerMacroMult ();

        let dmut skips = Vec!{&Expression}::new ();
        if (!(self:.readIf (Keys::SKIPS)._0).isEof ()) {
            self:.readTokens (Tokens::LPAR);
            loop {
                let str = self:.readString (forceDouble-> true);
                match str {
                    s : &StringExpr => {  skips:.push (MacroTokenExpr::new (s.getLoc (), s)) }
                    _ => __pragma!panic ();
                }

                if (self:.readTokens (Tokens::RPAR, Tokens::PIPE)._0 == Tokens::RPAR) break {}
            }
        }

        (MacroMultExpr::new (start, end, inner), skips[])
    }


    /**
     * Read the body of a macro rule (or constructor)
     * @verbatim:
     * ================
     * marco_rule_body := Tokens::LACC Any* Tokens::RACC
     * ================
     */
    fn readMacroRuleBody (mut self)-> (&Word, [c8])
        throws &ErrorMsg
    {
        let (start, _) = self:.readTokens (Tokens::LACC);
        let (res, closing) = self._lex:.getString (closing-> Tokens::RACC, opening-> [Tokens::LACC, Tokens::MACRO_ACC]);
        if (closing.isEof ()) {
            throw ErrorMsg::fatal (closing, SyntaxErrorMessage::BLOCK_NEVER_CLOSED, notes-> [ErrorMsg::note (start, SyntaxErrorMessage::IN_DECL_BLOCK)]);
        }

        (start, res)
    }


    /**
     * Read the inner part of a macro mutliplicator
     * @verbatim:
     * ==================
     * macro_inner_mult := Tokens::LPAR ((macro_expression*) | (macro_expression (Tokens::PIPE macro_expression)*) Tokens::RPAR
     * ==================
     */
    fn readInnerMacroMult (mut self)-> (&Word, &Word, [&MacroRuleExpression])
        throws &ErrorMsg
    {
        let (start, _) = self:.readTokens (Tokens::LPAR);
        let dmut inner = Vec!{&MacroRuleExpression}::new ();

        let mut fst = self:.readMacroExpression ();
        let (n, _) = self:.readIf (Tokens::PIPE, Tokens::RPAR);
        if (n.str () == Tokens::RPAR) return (start, n, [fst]);
        else if (n.str () == Tokens::PIPE) { // a list of pipes i.e. /(a | b | c)/
            let mut end = EOF_WORD;
            loop {
                let next = self:.readMacroExpression ();
                fst = MacroOrExpr::new (n, fst, next);
                end = self:.readTokens (Tokens::PIPE, Tokens::RPAR)._0;
                if (end == Tokens::RPAR) break {}
            }

             return (start, end, [fst]);
        }

        // a simple list, i.e. (a b c)
        inner:.push (fst);
        let mut end = EOF_WORD;
        loop {
            inner:.push (self:.readMacroExpression ());
            end = self:.readIf (Tokens::RPAR)._0;
            if (!end.isEof ()) break {}
        }

        (start, end, inner[])
    }


    /**
     * Read a macro rule expression
     * @verbatim:
     * =================
     * macro_expression :=   macro_inner_mult (Multiplicator)?
     *                     | Identifier (Tokens::EQUAL macro_expression)?
     *                     | String
     * =================
     */
    fn readMacroExpression (mut self)-> &MacroRuleExpression
        throws &ErrorMsg
    {
        let (n, _) = self:.readIf (Tokens::LPAR);
        if (n == Tokens::LPAR) {
            self._lex:.rewind ();
            let (start, end, inner) = self:.readInnerMacroMult ();
            let (mult, _) = self:.readIf (self._specials.macroMult);
            MacroMultExpr::new (start, end, inner, mult-> mult)
        } else {
            let (ident, _) = self:.readIfIdentifier ();
            if (ident.isEof ()) {
                let str = self:.readString (forceDouble-> true);
                match str {
                    s : &StringExpr => { MacroTokenExpr::new (s.getLoc (), s) }
                    _ => __pragma!panic ();
                }
            } else {
                if (self:.readIf (Tokens::EQUAL)._0.isEof ()) {
                    cast!{&MacroRuleExpression} (MacroIdentExpr::new (ident))
                } else {
                    let (rule, _) = self:.readIfIdentifier ();
                    let inner = if (!rule.isEof ()) {
                        cast!{&MacroRuleExpression} (MacroIdentExpr::new (rule))
                    } else {
                        self:.readMacroExpression ()
                    };

                    MacroVarExpr::new (ident, inner)
                }
            }
        }
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================            MODULE            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Read a use declaration
     * */
    fn readUse (mut self, loc : &Word, comm : [c8])-> &Declaration
        throws &ErrorMsg
    {

        let (fst, _) = self:.readIdentifier ();
        let dmut res = Vec!{&Expression}::new ();
        self:.readComplexPath (VarExpr::new (fst), alias res);
        self:.readTokens (Tokens::SEMI_COLON);


        let dmut use = Vec!{&Declaration}::new ();
        for i in res[] {
            use:.push (UseDecl::new (loc, comm, i))
        }

        BlockDecl::new (loc, comm, use[], isSet-> true)
    }

    /**
     * Read a local module
     * @verbatim:
     * =====================
     * local_module :=   Keys::MOD Keys::IF expression:(0) Identifier template_param_list decl_block
     *                 | Keys::MOD Identifier decl_block
     *                 | Keys::MOD Identifier Tokens::SEMI_COLON
     * =====================
     */
    fn readLocalModuleDecl (mut self, loc : &Word, comm : [c8])-> &Declaration
        throws &ErrorMsg
    {
        let (hasTest, test) = self:.readTemplateTest ();
        let (ident, _) = self:.readIdentifier ();

        let (end, _) = self:.readIf (Tokens::SEMI_COLON, Tokens::COMA);
        if (!end.isEof ()) {
            if (end == Tokens::COMA) {
                let dmut im = Vec!{&Declaration}::new ();
                im:.push (ImportDecl::new (loc, ""s8, ident));
                loop {
                    let (current, _) = self:.readIdentifier ();
                    im:.push (ImportDecl::new (loc, ""s8, current));
                    if (self:.readTokens (Tokens::SEMI_COLON, Tokens::COMA)._0 == Tokens::SEMI_COLON) break {}
                }

                BlockDecl::new (loc, comm, im[], isSet-> true)
            } else {
                ImportDecl::new (loc, comm, ident)
            }
        } else {
            let (templates, tmpErr) = self:.readTemplateParameters (ifLoc-> hasTest);

            let (n, comm_) = {
                self:.readTokens (Tokens::LACC)
            } catch {
                err : &ErrorMsg => throw err.appendNotes (notes-> tmpErr);
            };

            let content = self:.readBlockDecl (n, comm_, closing-> true, inProtection-> false);

            if (templates.len == 0us) {
                ModuleDecl::new (ident, EOF_WORD, comm, content, isGlobal-> false)
            } else {
                TemplateDecl::new (ident, comm, templates, test-> test,
                                   ModuleDecl::new (ident, EOF_WORD, comm, content, isGlobal-> false)
                           )
        }
        }
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================            TRAIT             =========================
     * ================================================================================
     * ================================================================================
     */


    /**
     * Visit a trait declaration
     * @verbatim:
     * =================
     * trait_decl :=   Keys::TRAIT Keys::IF expression:(0) Identifier template_param_list class_block_decl
     *               | Keys::TRAIT Identifier class_block_decl
     * =================
     */
    fn readTrait (mut self,  _ : &Word, comm : [c8])-> &Declaration
        throws &ErrorMsg
    {

        let (hasTest, test) = self:.readTemplateTest ();
        let (name, _) = self:.readIdentifier ();
        let (templates, tmpErr) = self:.readTemplateParameters (ifLoc-> hasTest);

        {
            self:.readTokens (Tokens::LACC);
            let decls = self:.readClassBlockDecl (inImpl-> true, isStruct-> false, closing-> true, inProtection-> false);

            let tra = TraitDecl::new (name, comm, decls);

            if (templates.len == 0us) {
                tra
            } else {
                TemplateDecl::new (name, comm, templates, test-> test, tra)
            }

        } catch {
            err : &ErrorMsg => throw err.appendNotes (notes-> tmpErr);
        }
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================           UNITTEST           =========================
     * ================================================================================
     * ================================================================================
     */


    /**
     * Visit a unittest declaration
     * @verbatim:
     * ==================
     * unittest := Keys::UNITTEST expression:(0)
     * ==================
     */
    fn readUnitTest (mut self, loc : &Word, comm : [c8])-> &Declaration
        throws &ErrorMsg
    {
        UnitTestDecl::new (loc, comm, self:.readExpression ())
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================           TEMPLATE           =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Read a list of template parameters
     * @params:
     *    - ifLoc: the location of the if test, if not eof, has to read the list, can't return an empty list
     * @throws:
     *    - ErrorMsg: if !ifLoc.isEof (), but there is no list to read
     */
    fn readTemplateParameters (mut self, ifLoc : &Word, force : bool = false)-> ([&Expression], [&ErrorMsg])
        throws &ErrorMsg
    {
        let (begin, _) = if (!ifLoc.isEof () || force) {
            let (x, c) = self._lex:.next ();
            if (x != Tokens::LACC) {
                throw ErrorMsg::fatal (x, format (SyntaxErrorMessage::UNEXPECTED_BUT_LST, x.str (), [Tokens::NOT]),
                                       notes-> [ErrorMsg::note (ifLoc, SyntaxErrorMessage::IF_NON_TEMPLATE)]);
            }
            (x, c)
        } else {
            self:.readIf (Tokens::LACC)
        }

        if (!begin.isEof ()) { // there are templates to read
            let dmut vec = Vec!{&Expression}::new ();
            loop {
                let (curr, _) = self._lex:.next ();
                match curr.str () {
                    Keys::STRUCT | Keys::CLASS | Keys::ALIAS | TemplateVarType::TUPLE | Keys::RECORD => {
                        let (ident, _) = self:.readIdentifier ();
                        vec:.push (TemplateVarExpr::new (ident, self.toTemplateVarType (curr.str ())));
                    }
                    _ => {
                        self._lex:.rewindToSeek (cursor-> cast!u64 (curr.seek ()));
                        vec:.push (
                            if self.isIdentifier (curr.str ()) {
                                self:.readTemplateVarParamWithNext ()
                            } else {
                                self:.readOperand3 ()
                            }
                        );
                    }
                }
                let (token, _) = self:.readTokens (Tokens::RACC, Tokens::COMA);

                if (token.str () == Tokens::RACC)
                    break {}
            }  catch {
                err : &ErrorMsg => {
                    self._lex:.rewindToSeek (cast!u64 (begin.seek ()));
                    return ([], [err]);
                }
            }

            vec:.fit ();
            return (vec [], []);
        }

        ([],[])
    }

    /**
     * Read an expression that checks template specialization
     * @verbatim:
     * ===============
     * template_var_decl_with_next :=    Identifier (Tokens::COLON expression:0)? (Tokens::EQUAL expression:0)?
     *                               |  Identifier (Keys::OF | Keys::OVER | Keys::IMPL) expression:0 (Tokens::DAND Identifier (Keys::OF | Keys::OVER | Keys::IMPL) expression:0)*
     *                               |  Identifier (Tokens::COLON)?  Tokens::TDOT
     *                               |  expression:0
     * ===============
     */
    fn readTemplateVarParamWithNext (mut self)-> &Expression
        throws &ErrorMsg
    {
        let dmut inners = Vec!{&TemplateOfVarExpr}::new ();
        let mut name = EOF_WORD;

        loop {
            let z = if (inners.len () == 0us) {
                let (x, y) = self:.readTemplateVarParam ();
                if (!y) return x; // cannot &&
                match x {
                    z : &TemplateOfVarExpr => {
                        name = z.getLoc ();
                        z
                    }
                    _ => return x; // ??, but cannot && anyway
                }
            } else {
                let (innerNext, _) = self:.readTokens (Keys::OVER, Keys::OF, Keys::IMPL);
                let k = self.toTemplateOfVarType (innerNext.str ());
                TemplateOfVarExpr::new (Word::new (format ("%.%", name.str (), inners.len ()), innerNext),
                                        self:.readExpression (level-> self._specials.binaryOperators.len),
                                        kind-> k)
            };

            inners:.push (z);

            let (n, _) = self:.readIf (Tokens::DAND);
            if (n.isEof ()) break {}
        }

        if inners.len () == 1us { return inners [0]; }
        match inners [0] {
            z : &TemplateOfVarExpr => {
                (alias inners) [0] = TemplateOfVarExpr::new (Word::new (format ("%.0", z.getLoc ().str ()), z.getLoc ()),
                                                     z.getSpecialization (),
                                                     z.getKind ());
            }
            _ => __pragma!panic ();
        }

        TemplateAndExpr::new (name, inners[])
    }

    /**
     * Read an expression that might be a variable inside a list of template parameters
     * @verbatim:
     * ===============
     * template_var_decl :=    Identifier (Tokens::COLON expression:0)? (Tokens::EQUAL expression:0)?
     *                      |  Identifier (Keys::OF | Keys::OVER | Keys::IMPL) expression:0
     *                      |  Identifier (Tokens::COLON)?  Tokens::TDOT
     *                      |  expression:0
     * ===============
     */
    fn readTemplateVarParam (mut self) -> (&Expression, bool)
        throws &ErrorMsg
    {
        let beginCur = self._lex.getCounter ();
        let (name, _) = self:.readIdentifier ();
        let (next, _) = self:.readIf (cast![c8] (Tokens::COLON), Tokens::TDOT,
                                       Tokens::EQUAL, Keys::OVER, Keys::OF,
                                       Keys::IMPL);

        match next.str () {
            Tokens::COLON => {
                let (tok, _) = self:.readIf (Tokens::TDOT);
                if (tok.isEof ()) { // V : type ('=' value)?
                    let type = self:.readExpression (level-> self._specials.binaryOperators.len);
                    if (!(self:.readIf (Tokens::EQUAL)._0).isEof ()) { // '=' value
                        return (VarDeclExpr::new (name, name, value-> self:.readExpression (), type-> type), false);
                    } else return (VarDeclExpr::new (name, name, value-> UnitExpr::new (), type-> type), false);
                } else return (TemplateVariadicVarExpr::new (name, isValue-> true), false); // V:...
            }
            Tokens::EQUAL => {
                return (VarDeclExpr::new (name, name, value-> self:.readExpression (), type-> UnitExpr::new ()), false);
            }
            Tokens::TDOT  => {
                return (TemplateVariadicVarExpr::new (name, isValue-> false), false);
            }
            Keys::OVER | Keys::OF | Keys::IMPL => {
                let k = self.toTemplateOfVarType (next.str ());
                return (TemplateOfVarExpr::new (name, self:.readExpression (level-> self._specials.binaryOperators.len), kind-> k), true);
            }
        }

        self._lex:.rewindTo (nb-> beginCur);
        return (self:.readExpression (), false);
    }

    /**
     * Read a template test (if anyl
     * @returns:
     *   - the location of the if token, (or eof)
     *   - the test expression, or Unit
     */
    fn readTemplateTest (mut self)-> (&Word, &Expression)
        throws &ErrorMsg
    {
        let (hasTest, _) = self:.readIf (Keys::IF);
        if hasTest.isEof () {
            (hasTest, const cast!(&Expression) (UnitExpr::new ()))
        } else {
            (hasTest, self:.readExpression (level-> self._specials.binaryOperators.len))
        }
    }


    /*!
     * ================================================================================
     * ================================================================================
     * =========================          ATTRIBUTES          =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Read a list of custom attributes, if the token Tokens::AT is not read, then an empty list is returned
     * @verbatim:
     * =================
     * attributes_lst :=   Tokens::AT Keys::LACC Attribute (Tokens::COMA Attribute)* Keys::RACC
     *                   | Tokens::AT Attribute
     * =================
     */
    fn readAttributes (mut self)-> (&Word, [AttributeWord])
        throws &ErrorMsg
    {
        let (next, _) = self:.readIf (Tokens::AT);
        if (next.isEof ()) return (EOF_WORD, []);

        let (open, _) = self:.readIf (Tokens::LACC);
        let dmut vec = Vec!(AttributeWord)::new ();
        loop {
            let (identifier, _) = self:.readTokens (Attributes::__members__);
            for j in vec[] {
                if j.attr == identifier {
                    throw ErrorMsg::fatal (j.loc, end-> identifier, format (SyntaxErrorMessage::MULTIPLE_ATTRS, j.attr));
                }
            }

            match identifier {
                Attributes::ABSTRACT => vec:.push (AttributeWord (identifier, Attributes::ABSTRACT));
                Attributes::FINAL    => vec:.push (AttributeWord (identifier, Attributes::FINAL));
                Attributes::UNSAFE   => vec:.push (AttributeWord (identifier, Attributes::UNSAFE));
                Attributes::INLINE   => vec:.push (AttributeWord (identifier, Attributes::INLINE));
                Attributes::FIELD    => vec:.push (AttributeWord (identifier, Attributes::FIELD));
                Attributes::THREAD   => vec:.push (AttributeWord (identifier, Attributes::THREAD));
                _ => {
                    throw ErrorMsg::fatal (identifier, format (SyntaxErrorMessage::UNDEFINED_ATTRIBUTE, identifier.str ()));
                }
            }

            if (open.isEof ()) {
                let (at,_) = self:.readIf (Tokens::AT);
                if (at.isEof ()) break {}
            } else {
                let (close, _) = self:.readTokens (Tokens::COMA, Tokens::RACC);
                if (close.str () == Tokens::RACC) break {}
            }
        }  catch {
            err : &ErrorMsg => {
                if (!open.isEof ()) {
                    throw err.appendNotes ([ErrorMsg::note (open, SyntaxErrorMessage::IN_DECL_BLOCK)]);
                } else throw err;
            }
        }

        vec:.fit ();
        (next, vec[])
    }

    /**
     * Throw a syntax error if there are attributes in a wrong position
     * */
    fn checkNoAttributes (self, loc : &Word, attrLoc : &Word, attribs : [AttributeWord])
        throws &ErrorMsg
    {
        import std::algorithm::iteration;

        if (!attrLoc.isEof ()) {
            if (!loc.isEof ()) {
                throw ErrorMsg::fatal (attrLoc, format (SyntaxErrorMessage::UNEXPECTED_ATTRIBUTES, attribs.map!{|x| => x.attr} ()),
                                       notes-> [ErrorMsg::note (loc, ""s8)]);
            } else {
                throw ErrorMsg::fatal (attrLoc, format (SyntaxErrorMessage::UNEXPECTED_ATTRIBUTES, attribs.map!{|x| => x.attr} ()));
            }
        }
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================         EXPRESSIONS          =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Read an expression
     * @verbatim:
     * ==================
     * expression:(level) := expression:(level+1) (binary_operator:(level) expression:(level))?
     * expression:(10) := operand:(0)
     * ==================
     */
    pub fn readExpression (mut self, level : usize = 0us)-> &Expression
        throws &ErrorMsg
    {
        if (cast!usize (level) == self._specials.binaryOperators.len) {
            self:.readOperand0 ()
        } else {
            let left = self:.readExpression (level-> level + 1us);
            self:.readExpressionFollow (left, level-> level)
        }
    }

    /**
     * Read the following of an expression (for operators)
     */
    fn readExpressionFollow (mut self, left : &Expression, level : usize = 0us)-> &Expression
        throws &ErrorMsg
    {
        let (tok, _) = self:.readIf (self._specials.binaryOperators[level]);
        if (!tok.isEof ()) {
            let right = self:.readExpression (level-> level + 1us);
            self:.readExpressionFollow (BinaryExpr::new (tok, left, right), level-> level)
        } else if (level == 3us) {
            let (n, _) = self:.readIf (Tokens::NOT);
            if (!n.isEof ()) {
                let (op, _) = self:.readIf (self._specials.specialBinaryOperators);
                if (op.isEof ()) {
                    self._lex:.rewind ();
                    left
                } else {
                    let right = self:.readExpression (level-> level + 1us);
                    self:.readExpressionFollow (BinaryExpr::new (Word::new (n.str () ~ op.str (), n), left, right), level-> level)
                }
            } else { left }
        } else { left }
    }

    /**
     * Read a highest level operand
     * @verbatim:
     * ===================
     * operand:(0) := (unary_operator)? operand:(1) (Tokens::INTEG)?
     * ===================
     */
    pub fn readOperand0 (mut self) -> &Expression
        throws &ErrorMsg
    {
        let (tok, _) = self:.readIf (self._specials.unaryOperators);
        let ret = if (!tok.isEof ()) {
            UnaryExpr::new (tok, self:.readOperand1 ())
        } else { self:.readOperand1 () }

        let (post, _) = self:.readIf (Tokens::INTEG);
        if (!post.isEof ()) {
            TryExpr::new (post, ret)
        } else { ret }
    }


    /**
     * Read an operand of level 1
     * @verbatim:
     * =================
     * operand:(1) :=   block
     *                | if_expr
     *                | while_expr
     *                | assert_expr
     *                | break_expr
     *                | dowhile_expr
     *                | for_expr
     *                | match_expr
     *                | vardecl
     *                | return_expr
     *                | function_expr
     *                | delegate_expr
     *                | loop_expr
     *                | throw_expr
     *                | version
     *                | pragma_expr
     *                | with_expr
     *                | atomic_expr
     *                | operand:(operand_follow)?
     * =================
     */
    fn readOperand1 (mut self)-> &Expression
        throws &ErrorMsg
    {
        let (tok, _) = self:.readIf (Tokens::LACC, Keys::IF, Keys::WHILE, Keys::ASSERT,
                                     Keys::BREAK, Keys::DO, Keys::FOR, Keys::MATCH, Keys::FUTURE,
                                     Keys::LET, Keys::RETURN, Keys::FUNCTION, Keys::DELEGATE,
                                     Keys::LOOP, Keys::THROW, Keys::PANIC, Keys::VERSION, Keys::PRAGMA,
                                     Keys::ATOMIC, Keys::UNSAFE);

        match tok {
            Keys::LOOP     => { self:.readLoop (tok) }
            Keys::WHILE    => { self:.readWhile (tok) }
            Tokens::LACC   => { self:.readBlock (tok) }
            Keys::IF       => { self:.readIfExpression (tok) }
            Keys::ASSERT   => { self:.readAssert (tok) }
            Keys::BREAK    => { self:.readBreak (tok) }
            Keys::DO       => { self:.readDoWhile (tok) }
            Keys::FOR      => { self:.readFor (tok) }
            Keys::MATCH    => { self:.readMatch (tok) }
            Keys::LET      => { self:.readVarDeclaration (tok) }
            Keys::RETURN   => { self:.readReturn (tok) }
            Keys::FUNCTION => { self:.readFunctionType (tok) }
            Keys::DELEGATE => { self:.readFunctionType (tok) }
            Keys::FUTURE   => { self:.readFutureType (tok) }
            Keys::THROW    => { self:.readThrow (tok) }
            Keys::VERSION  => { self:.readVersionExpr (tok) }
            Keys::PRAGMA   => { self:.readPragma (tok) }
            Keys::ATOMIC   => { self:.readAtomic (tok) }
            Keys::UNSAFE   => { self:.readUnsafe (tok) }
            Keys::PANIC    => { self:.readPanic (tok) }
            _ => { self:.readOperandFollow (self:.readOperand2 (self:.readOperand3 ())) }
        }
    }


    /**
     * Read the follow-up of an operand
     * @verbatim:
     * =================
     * operand_follow :=   Tokens::LPAR param_list Tokens::RPAR (operand_follow)?
     *                   | Tokens::LCRO param_list Tokens::RCRO (operand_follow)?
     *                   | (Tokens::DOT | Tokens::DOT_AND) operand:(3) (template_call)? (operand_follow)?
     *                   | macro_call (operand_follow)?
     * =================
     */
    fn readOperandFollow (mut self, left : &Expression)-> &Expression
        throws &ErrorMsg
    {
        let (n, _) = self:.readIf (Tokens::LPAR, Tokens::LCRO, Tokens::LCRO_AND, Tokens::MACRO_ACC, Tokens::MACRO_CRO, Tokens::MACRO_PAR, Tokens::DOT, Tokens::DOT_AND);
        match n {
            Tokens::LPAR | Tokens::LCRO | Tokens::LCRO_AND => {
                let (params, end) = self:.readArgumentList (withNamed-> true, closing-> if (n == Tokens::LPAR) { Tokens::RPAR } else { Tokens::RCRO });
                self:.readOperandFollow (MultOperatorExpr::new (n, end, left, params))
            }
            Tokens::MACRO_ACC | Tokens::MACRO_PAR | Tokens::MACRO_CRO => {
                self:.readOperandFollow (self:.readMacroCall (n, left))
            }
            Tokens::DOT | Tokens::DOT_AND => {
                let right = self:.readOperand3 (canBeTemplateCall-> false, canBeFloat-> false);
                self:.readOperandFollow (self:.readTemplateCall (BinaryExpr::new (n, left, right)))
            }
            _ => { left }
        }
    }


    /**
     * Read a level 2 operand
     * @verbatim:
     * ===============
     * operand:(2) := (Tokens::DCOLON template_call)?
     * ===============
     */
    fn readOperand2 (mut self, left : &Expression) -> &Expression
        throws &ErrorMsg
    {
        let (n, _) = self:.readIf (Tokens::DCOLON);
        if (!n.isEof ()) {
            let right = self:.readOperand3 (canBeTemplateCall-> false);
            self:.readOperand2 (self:.readTemplateCall (BinaryExpr::new (n, left, right)))
        } else {
            left
        }
    }

    /**
     * Read a level 3 operand
     * @verbatim:
     * =================
     * operand:(3) :=   cast_expr
     *                | template_checker
     *                | array_lit
     *                | tuple_lit
     *                | lambda_lit
     *                | intrinsic
     *                | literal
     *                | decorated_expr
     *                | var
     * =================
     */
    fn readOperand3 (mut self, canBeTemplateCall : bool = true, canBeFloat : bool = true) -> &Expression
        throws &ErrorMsg
    {
        let (n, _) = self:.readIf (Keys::CAST, Keys::IS, Keys::FUTURE, Tokens::LCRO, Tokens::LPAR, Tokens::PIPE, Tokens::DPIPE, Tokens::NOT);

        if (n == Tokens::NOT) {
            let (e, _) = self:.readIf(Keys::IS);
            if (!e.isEof ()) {
                return cast!{&Expression} (UnaryExpr::new (n, self:.readTemplateChecker (e)));
            } else self._lex:.rewind ();
        }

        match n {
            Keys::CAST                    => { self:.readCast (n) }
            Keys::IS                      => { self:.readTemplateChecker (n) }
            Tokens::LCRO                  => { self:.readArray (n) }
            Tokens::LPAR                  => { self:.readTuple (n) }
            Tokens::PIPE | Tokens::DPIPE  => { self:.readLambda (n) }
            _ => {
                let (i, _) = self:.readIf (self._specials.intrinsicKeys);
                if (!i.isEof ()) {
                    let (p, _) = self:.readIf (Tokens::LPAR);
                    let inner = if (p.isEof ()) {
                        self:.readExpression (level-> self._specials.binaryOperators.len)
                    } else { self:.readExpression () }

                    let ret = IntrinsicExpr::new (i, self.toIntrinsic (i.str ()), inner);
                    if (!p.isEof ()) self:.readTokens (Tokens::RPAR);
                    cast!{&Expression} (ret)
                } else {
                    let (j, _) = self:.readIf (self._specials.decorators);
                    if (!j.isEof ()) {
                        let inner = self:.readExpression (level-> self._specials.binaryOperators.len);
                        cast!{&Expression} (DecoratedExpr::new (j, inner, j))
                    } else {
                        let (ident, _) = self:.readIfIdentifier ();
                        if (!ident.isEof ()) {
                            self._lex:.rewind ();
                            self:.readVar (canBeTemplateCall-> canBeTemplateCall)
                        } else {
                            self:.readLiteral (canBeFloat-> canBeFloat)
                        }
                    }
                }
            }
        }
    }


    /**
     * Read a list of arguments
     * @params:
     *    - withNamed: if true, named expression are allowed in the argument list
     *    - closing: the token that closes the list
     * @verbatim:
     * ===================
     *
     * ===================
     */
    fn readArgumentList (mut self, withNamed : bool = false, closing : [c8] = Tokens::RPAR)-> ([&Expression], &Word)
        throws &ErrorMsg
    {
        let dmut vec = Vec!{&Expression}::new ();
        let mut end = EOF_WORD;
        let (x, _) = self:.readIf (closing);
        if (!x.isEof ()) { end = x; }
        else {
            loop {
                let beg = self._lex.getCounter ();
                let mut read = false;
                if (withNamed) {
                    let (name, _) = self._lex:.next ();
                    if (self.isIdentifier (name.str ())) {
                        let (arr, _) = self:.readIf (Tokens::ARROW);
                        if (!arr.isEof ()) {
                            vec:.push (NamedExpr::new (name, self:.readExpression ()));
                            read = true;
                        }
                    }
                }

                if (!read) {
                    self._lex:.rewindTo (nb-> beg);
                    vec:.push (self:.readExpression ());
                }

                let (n, _) = self:.readTokens (closing, Tokens::COMA);
                if (n != Tokens::COMA) {
                    end = n;
                    break {}
                }
            }
        }
        vec:.fit ();
        (vec [], end)
    }


    /*!
     * ================================================================================
     * ================================================================================
     * =========================       VAR DECLARATION        =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Read the decorators in front a variable declaration
     * @returns:
     *    - .0: the lazy or ref decorator
     *    - .1: the mut or dmut decorator
     * */
    fn readDecoratorVariable (mut self, canBeLazyOrRef : bool = true)-> (&Word, &Word) {
        let mut isLazyOrRef = if (canBeLazyOrRef) {
            self:.readIf (Keys::LAZY, Keys::REF)._0
        } else {
            EOF_WORD
        };

        let isMutOrDmut = self:.readIf (Keys::MUTABLE, Keys::DMUTABLE)._0;
        if (isLazyOrRef.isEof () && !isMutOrDmut.isEof () && canBeLazyOrRef) {
            isLazyOrRef = self:.readIf (Keys::LAZY, Keys::REF)._0;
        }

        (isLazyOrRef, isMutOrDmut)
    }

    /**
     * Read a single var declaration
     * @params:
     *    - mandType: the type is mandatory
     *    - withValue: there can be a value
     *    - isClass: self is a valid Identifier
     *    - level: the level of the expression (only applicable if withValue)
     * @verbatim:
     * ==================
     * single_var_decl :=   (Decorator)* (Identifier | Keys::UNDER) (Tokens::COLON expression:(10))? (Tokens::EQUAL expression:(level))
     *                    | (Decorator)* Keys::SELF
     * ==================
     */
    fn readSingleVarDeclaration (mut self, mandType : bool = false, withValue : bool = true, mandValue : bool = false, isClass : bool = false, level : usize = 0us)-> &VarDeclExpr
        throws &ErrorMsg
    {
        let (isLazyOrRef, isMutOrDmut) = self:.readDecoratorVariable (canBeLazyOrRef-> !isClass);
        let (ig, _) = self:.readIf (Keys::UNDER);
        let name = if (!ig.isEof ()) {
            ig
        } else { self:.readIdentifier ()._0 }

        match name {
            Keys::SELF => {
                if (!isClass) throw ErrorMsg::fatal (name, format (SyntaxErrorMessage::USED_AS_IDENTIFIER, name.str ()));
                VarDeclExpr::new (name, name, isMutOrDmut-> isMutOrDmut, value-> EmptyExpression::new (), type-> EmptyExpression::new ())
            }
            _ => {
                if (isClass) throw ErrorMsg::fatal (name, format (SyntaxErrorMessage::UNEXPECTED_BUT_LST, name.str (), [Keys::SELF]));
                let type = if (mandType) {
                    self:.readTokens (Tokens::COLON);
                    self:.readExpression (level-> self._specials.binaryOperators.len)
                } else if (!(self:.readIf (Tokens::COLON)._0).isEof ()) {
                    self:.readExpression (level-> self._specials.binaryOperators.len)
                } else { cast!{&Expression} (EmptyExpression::new ()) }

                let value = if (withValue || mandValue) {
                    if (mandValue) {
                        self:.readTokens (Tokens::EQUAL);
                        self:.readExpression (level-> level)
                    } else if (!(self:.readIf (Tokens::EQUAL)._0).isEof ()) {
                        self:.readExpression (level-> level)
                    } else { cast!{&Expression} (EmptyExpression::new ()) }
                } else { cast!{&Expression} (EmptyExpression::new ()) }

                VarDeclExpr::new (name, name, isMutOrDmut-> isMutOrDmut, isLazyOrRef-> isLazyOrRef, value-> value, type-> type)
            }
        }
    }


    /*!
     * ================================================================================
     * ================================================================================
     * =========================            BLOCKS            =========================
     * ================================================================================
     * ================================================================================
     */


    /**
     * Read a block of code
     * @verbatim:
     * ====================
     * block := Tokens::LACC ((n=expression:(0) (Tokens::SEMI_COLON)!if(self:.needClosingExpr (n))* (expression:(0))?) Tokens::RACC (scope_guards)?
     * ====================
     */
    fn readBlock (mut self, loc : &Word, canBeCatcher : bool = true)-> &Expression
        throws &ErrorMsg
    {
        let dmut decls = Vec!{&Declaration}::new ();
        let dmut content = Vec!{&Expression}::new ();
        {
            let mut end = EOF_WORD;
            let mut last = false;
            loop {
                end = self:.readIf (Tokens::SEMI_COLON, Tokens::RACC)._0;
                if (end.isEof ()) {
                    if (!last && content.len () != 0us) {
                        if (self.needClosingExpr (content[][$ - 1us])) {
                            let (n, _) = self._lex:.next ();
                            throw ErrorMsg::fatal (n, format (SyntaxErrorMessage::UNEXPECTED_BUT_LST, n.str (), [Tokens::SEMI_COLON]));
                        }
                    }

                    last = false;
                    let (attrLoc, attribs) = self:.readAttributes ();
                    let (d, _) = self:.readIf (Keys::CLASS, Keys::ENUM, Keys::FUNCTION, Keys::USE, Keys::STRUCT, Keys::RECORD, Keys::TRAIT);
                    if (!d.isEof ()) {
                        self._lex:.rewind ();
                        decls:.push (self:.readDeclaration (attribs-> (attrLoc, attribs)));
                        last = true;
                    } else {
                        self.checkNoAttributes (EOF_WORD, attrLoc, attribs);
                        content:.push (self:.readExpression ());
                    }
                } else if (end == Tokens::SEMI_COLON) {
                    last = true;
                } else break {}
            }

            let (catcher, scopes) = if (canBeCatcher) {
                self:.readScopeGuards ()
            } else { (cast!{&Expression} (EmptyExpression::new ()), []) }

            if (last) content:.push (UnitExpr::new (loc-> end));
            if (decls.len () != 0us) {
                BlockExpr::new (loc, end, module-> BlockDecl::new (Word::new (Keys::UNDER, loc), ""s8, decls[]), content[], catcher-> catcher, guards-> scopes)
            } else {
                BlockExpr::new (loc, end, content[], catcher-> catcher, guards-> scopes)
            }
        } catch {
            err : &ErrorMsg => {
                 if (!loc.isEof ()) {
                    throw ErrorMsg::note (loc, SyntaxErrorMessage::IN_DECL_BLOCK, notes-> [err]);
                } else throw err;
            }
        }
    }


    /**
     * Read scope guards
     * @verbatim:
     * ==================
     * scope_guards :=   Keys::EXIT block
     *                 | Keys::SUCCESS block
     *                 | Keys::FAILURE block
     *                 | catcher
     * ==================
     */
    fn readScopeGuards (mut self)-> (&Expression, [&ScopeGuardExpr])
        throws &ErrorMsg
    {
        let mut catcher : &Expression = EmptyExpression::new ();
        let dmut scopes = Vec!{&ScopeGuardExpr}::new ();
        let dmut seen = HashMap!{[c8], &Word}::new ();
        loop {
            let (n, _) = self:.readIf (Keys::EXIT, Keys::SUCCESS, Keys::FAILURE, Keys::CATCH);
            if (!n.isEof ()) {
                match seen.find (n.str ()) {
                    Ok (val : &Word) => {
                        throw ErrorMsg::fatal (n, end-> val, format (SyntaxErrorMessage::MULTIPLE_SAME_GUARD, n.str ()));
                    }
                }

                seen:.insert (n.str (), n);
            }

            if (n == Keys::CATCH) {
                catcher = self:.readCatcher (n);
            } else if (!n.isEof ()) {
                let (a, _) = self:.readTokens (Tokens::LACC);
                scopes:.push (ScopeGuardExpr::new (n, self:.readBlock (a, canBeCatcher-> false), kind-> self.toScopeGuard (n.str ())))
            } else break {}
        }

        (catcher, scopes[])
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================          CONDITIONS          =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Read an If expression
     * @verbatim:
     * ======================
     * if_expr := Keys::IF expression:(0) ((expression:(0) (Tokens::SEMI_COLON)?) | (block)) (Keys::ELSE expression:(0))?
     * ======================
     */
    fn readIfExpression (mut self, loc : &Word)-> &Expression
        throws &ErrorMsg
    {
        let (isLet, _) = self:.readIf (Keys::LET);
        let (test : &Expression, guard : &Expression) = if (isLet.isEof ()) {
            (self:.readExpression (), EmptyExpression::new ())
        } else {
            let vdecl = self:.readVarDeclaration (isLet, onlyOne-> true, level-> 3us);
            let guard = if (!self:.readIf (Tokens::DAND)._0.isEof ()) {
                self:.readExpression ()
            } else { cast!{&Expression} (EmptyExpression::new ()) };

            (vdecl, guard)
        };

        let mut content = self:.readExpression ();

        match content {
            BlockExpr () => {}
            _ => {
                let (tok, _) = self:.readIf (Tokens::SEMI_COLON);
                if (!tok.isEof ()) {
                    let dmut inner = Vec!{&Expression}::new ();
                    inner:.push (content);
                    inner:.push (UnitExpr::new ());
                    content = BlockExpr::new (content.getLoc (), tok, content-> inner[]);
                }
            }
        }

        let (next, _) = self:.readIf (Keys::ELSE);
        if (!next.isEof ()) {
            let (n, _) = self:.readIf (Keys::IF);
            if (!n.isEof ()) return ConditionalExpr::new (loc, test, content, else_-> self:.readIfExpression (n), guard-> guard, isLet-> !isLet.isEof ());
            else {
                let mut el_content = self:.readExpression ();
                match el_content {
                    BlockExpr () => {}
                    _ => {
                        let (tok, _) = self:.readIf (Tokens::SEMI_COLON);
                        if (!tok.isEof ()) {
                            let dmut inner = Vec!{&Expression}::new ();
                            inner:.push (el_content);
                            inner:.push (UnitExpr::new ());
                            el_content = BlockExpr::new (content.getLoc (), tok, content-> inner[]);
                        }
                    }
                }
                return ConditionalExpr::new (loc, test, content, else_-> el_content, isLet-> !isLet.isEof (), guard-> guard);
            }
        }

        ConditionalExpr::new (loc, test, content, isLet-> !isLet.isEof (), guard-> guard)
    }


    /**
     * Read an atomic
     * @verbatim:
     * ==============
     * atomic_expr := Keys::ATOMIC (expression:(0))? Tokens::LACC expression:(0) Tokens::RACC
     * ==============
     */
    fn readAtomic (mut self, loc : &Word) -> &Expression
        throws &ErrorMsg
    {
        let (n, _) = self:.readIf (Tokens::LACC);
        if (!n.isEof ()) {
            let content = self:.readBlock (n);
            return AtomicExpr::new (loc, content, monitor-> UnitExpr::new (loc-> loc));
        } else {
            let monitor = self:.readExpression ();
            let (tok, _) = self:.readTokens (Tokens::LACC);
            let content = self:.readBlock (tok, canBeCatcher-> false);
            return AtomicExpr::new (loc, content, monitor-> monitor);
        }
    }

    /**
     * Read an unsafe block
     * @verbatim:
     * ==========
     * unsafe_expr := Keys::UNSAFE Tokens::LACC expression:(0) Tokens::RACC
     * ==========
     * */
    fn readUnsafe (mut self, loc : &Word)-> &Expression
        throws &ErrorMsg
    {
        let content = self:.readExpression ();
        return UnsafeExpr::new (loc, content);
    }

    /**
     * Read a pragma expr
     * @verbatim:
     * ===================
     * pragma_expr := Keys::PRAGMA Tokens::NOT Identifier (Tokens::LPAR param_list Tokens::RPAR)
     * ===================
     */
    fn readPragma (mut self, _ : &Word)-> &Expression
        throws &ErrorMsg
    {
        self:.readIf (Tokens::NOT);
        let (ident, _) = self:.readIdentifier ();

        self:.readTokens (Tokens::LPAR);
        let (params, _) = self:.readArgumentList ();

        PragmaExpr::new (ident, params)
    }


    /**
     * Read a version block expr
     * @verbatim:
     * =========================
     * version_block := Keys::VERSION Identifier block (Keys::ELSE block)?
     * =========================
     */
    fn readVersionExpr (mut self, loc : &Word)-> &Expression
        throws &ErrorMsg
    {
        let (ident, _) = self:.readIdentifier ();
        return if state::instance ().isVersionActive (ident.str ()) {
            let (n, _) = self:.readIf (Tokens::LACC);
            let value = self:.readBlock (n, canBeCatcher-> false);
            if (!(self:.readIf (Keys::ELSE)._0).isEof ()) {
                self:.ignoreBlock ();
            }

            value
        } else {
            self:.ignoreBlock ();
            if (!(self:.readIf (Keys::ELSE)._0).isEof ()) {
                let (n, _) = self:.readIf (Tokens::LACC);
                self:.readBlock (n, canBeCatcher-> false)
            } else UnitExpr::new (loc-> loc)
        }
    }

    /**
     * Read a throw expression
     * @verbatim:
     * =======================
     * throw_expr := Keys::THROW expression:(0)
     * =======================
     */
    fn readThrow (mut self, loc : &Word)-> &Expression
        throws &ErrorMsg
    {
        let expr = self:.readExpression ();
        ThrowExpr::new (loc, expr)
    }

    /**
     * Read a panic instruction
     * @verbatim:
     * =======================
     * panic := Keys::PANIC
     * =======================
     * */
    fn readPanic (mut self, loc : &Word)-> &Expression {
        PanicExpr::new (loc)
    }


    /**
     * Read a function type
     * @verbatim:
     * ====================
     * function_type := (Keys::FUNCTION | Keys::DG) function_type_prototype function_type_return_type
     * function_type_prototype := Tokens::LPAR (expression:(10) (Tokens::COMA expression:(10))*) Tokens::RPAR
     * function_type_return_type := (Tokens::ARROW expression:(10))?
     * ====================
     */
    fn readFunctionType (mut self, loc : &Word)-> &Expression
        throws &ErrorMsg
    {
        self:.readTokens (Tokens::LPAR);
        let args = self:.readFptrParameters ();
        let (t, _) = self:.readIf (Tokens::ARROW);
        if (!t.isEof ()) {
            FunctionPtrTypeExpr::new (loc, args, self:.readExpression (level-> self._specials.binaryOperators.len))
        } else {
            FunctionPtrTypeExpr::new (loc, args, EmptyExpression::new ())
        }
    }

    /**
     * Read a future type
     * @verbatim
     * ============
     * future_type := Keys::FUTURE Tokens::ARROW operand:(3)
     * ============
     * */
    fn readFutureType (mut self, loc : &Word)-> &Expression
        throws &ErrorMsg
    {
        self:.readTokens (Tokens::ARROW);
        let param = self:.readOperand3 ();

        FutureTypeExpr::new (loc, param)
    }

    /**
     * Read the parameters of a function pointer type
     * */
    fn readFptrParameters (mut self)-> [&VarDeclExpr]
        throws &ErrorMsg
    {
        let x = self:.readIf (Tokens::RPAR)._0;
        if (!x.isEof ()) return [];

        let dmut params = Vec!{&VarDeclExpr}::new ();
        loop {
            let (isLazyOrRef, isMutOrDmut) = self:.readDecoratorVariable (canBeLazyOrRef-> true);

            let type = self:.readExpression (level-> self._specials.binaryOperators.len);
            let name = Word::new (Keys::UNDER, type.getLoc ());
            params:.push (VarDeclExpr::new (name, name,
                                            isLazyOrRef-> isLazyOrRef,
                                            isMutOrDmut-> isMutOrDmut,
                                            type-> type,
                                            value-> EmptyExpression::new ()));

            let (next, _) = self:.readTokens (Tokens::RPAR, Tokens::COMA);
            if (next == Tokens::RPAR) break {}
        }

        params[]
    }

    /**
     * Read a return expression
     * @verbatim:
     * ========================
     * return_expr := Keys::RETURN ( expression:(0) | ';' )
     * ========================
     */
    fn readReturn (mut self, loc : &Word)-> &Expression
        throws &ErrorMsg
    {
        let (semiCol, _) = self:.readIf (Tokens::SEMI_COLON);
        if (!semiCol.isEof ()) {
            ReturnExpr::new (loc, EmptyExpression::new ())
        } else {
            let expr = self:.readExpression ();
            ReturnExpr::new (loc, expr)
        }
    }

    /**
     * Read a var declaration
     * @verbatim:
     * ========================
     * var_decl :=   Keys::LET (single_var_decl Tokens::EQUAL value) (Tokens::COMA (single_var_decl Tokens::EQUAL value))*
     *             | Keys::LET pattern Tokens::EQUAL value
     * ========================
     */
    fn readVarDeclaration (mut self, loc : &Word, onlyOne : bool = false, level : usize = 0us)-> &Expression
        throws &ErrorMsg
    {
        let t = self._lex.getCounter ();
        let mut succeed = false;
        let (tok, _) = self:.readIf (Tokens::LPAR, Tokens::LCRO);
        if (tok == Tokens::LPAR || tok == Tokens::LCRO) {
            let pattern = self:.readParMatch (tok, endTok-> if (tok == Tokens::LPAR) { Tokens::RPAR } else { Tokens::RCRO });
            self:.readTokens (Tokens::EQUAL);
            let value = self:.readExpression (level-> level);

            return PatternVarDeclExpr::new (loc, pattern, value);
        } else {
            {
                let dmut decls = Vec!{&Expression}::new ();
                loop {
                    decls:.push (self:.readSingleVarDeclaration (mandType-> false, isClass-> false, mandValue-> true, level-> level));
                    succeed = true; // read at least one
                    if (!onlyOne) {
                        if ((self:.readIf (Tokens::COMA)._0).isEof ()) break {}
                    } else break {}
                }

                return if (decls.len () == 1us)
                    __pragma!trusted (decls [0us])
                else cast!{&Expression} (SetExpr::new (loc, decls[]))

            } catch {
                err : &ErrorMsg => {
                    if (succeed) throw err; // pattern var decl cannot be grouped with other kind of declarations
                    {
                        self._lex:.rewindTo (nb-> t);
                        let pattern = self:.readMatchExpression ();

                        self:.readTokens (Tokens::EQUAL);
                        let value = self:.readExpression (level-> level);

                        return PatternVarDeclExpr::new (loc, pattern, value);
                    } catch {
                        subErr : &ErrorMsg => {
                            throw err.withNote ([ErrorMsg::note (loc, oneLine-> true, SyntaxErrorMessage::READING_PATTERN_DECLARATION, notes-> [subErr])]);
                        }
                    }
                }
            }
        }
    }


    /**
     * Read a for loop
     * @verbatim:
     * ===========================
     * for_loop := Keys::FOR ((Tokens::LPAR for_loop_decl Tokens::RPAR) | for_loop_decl) expression:(0)
     * for_loop_decl := (single_var_decl:(no_value) (Tokens::COMA single_var_decl:(no_value))* Keys::IN expression:(10)
     * ===========================
     */
    fn readFor (mut self, loc : &Word)-> &Expression
        throws &ErrorMsg
    {
        let dmut decls = Vec!{&Expression}::new ();
        let (par, _) = self:.readIf (Tokens::LPAR);
        loop {
            decls:.push (self:.readSingleVarDeclaration (mandType-> false, withValue-> false));
            let (n, _) = self:.readTokens (Tokens::COMA, Keys::IN);
            if (n == Keys::IN) break {}
        }

        let iter = self:.readExpression ();
        if (!par.isEof ()) self:.readTokens (Tokens::RPAR);

        let mut content = self:.readExpression ();
        match content {
            BlockExpr () => {}
            _ => {
                let (n, _) = self:.readIf (Tokens::SEMI_COLON);
                if (!n.isEof ()) {
                    let dmut inner = Vec!{&Expression}::new ();
                    inner:.push (content);
                    inner:.push (UnitExpr::new ());
                    content = BlockExpr::new (content.getLoc (), n, inner[]);
                }
            }
        }

        ForLoopExpr::new (loc, decls[], iter, content)
    }


    /**
     * Read a do while loop
     * @verbatim:
     * =====================
     * =====================
     */
    fn readDoWhile (mut self, loc : &Word) -> &Expression
        throws &ErrorMsg
    {
        let content = self:.readExpression ();
        self:.readTokens (Keys::WHILE);
        let test = self:.readExpression ();

        WhileLoopExpr::new (loc, test-> test, content, isDo-> true)
    }

    /**
     * Read a break expression
     * @verbatim:
     * =======================
     * break_expr := Keys::BREAK ( expression:(0) | ';' )
     * =======================
     */
    fn readBreak (mut self, loc : &Word)-> &Expression
        throws &ErrorMsg
    {
        let (semiCol, _) = self:.readIf (Tokens::SEMI_COLON);
        if (!semiCol.isEof ()) {
            BreakExpr::new (loc, EmptyExpression::new ())
        } else {
            let expr = self:.readExpression ();
            BreakExpr::new (loc, expr)
        }
    }


    /**
     * Read an assert expression
     * @verbatim:
     * ==========================
     * assert_expr := Keys::ASSERT Tokens::LPAR expression:(0) (Tokens::COMA expression:(0))? Tokens::RPAR
     * ==========================
     */
    fn readAssert (mut self, tok : &Word)-> &Expression
        throws &ErrorMsg
    {
        let _ = self:.readTokens (Tokens::LPAR);
        let test = self:.readExpression ();
        let (n, _) = self:.readTokens (Tokens::RPAR, Tokens::COMA);
        let msg = if (n == Tokens::COMA) {
            let exp = self:.readExpression ();
            self:.readTokens (Tokens::RPAR);
            exp
        } else {
            cast!{&Expression} ( EmptyExpression::new () )
        }
        self:.readTokens (Tokens::SEMI_COLON);
        self._lex:.rewind ();

        AssertExpr::new (tok, test, msg)
    }

    /**
     * Read a loop expression
     * @verbatim:
     * =========================
     * loop_expr := Keys::LOOP expression:(0)
     * =========================
     */
    fn readLoop (mut self, loc : &Word)-> &Expression
        throws &ErrorMsg
    {
        let mut content = self:.readExpression ();
        match content {
            BlockExpr () => {}
            _ => {
                let (n, _) = self:.readIf (Tokens::SEMI_COLON);
                if (!n.isEof ()) {
                    let dmut inner = Vec!{&Expression}::new ();
                    inner:.push (content);
                    inner:.push (UnitExpr::new ());
                    content = BlockExpr::new (content.getLoc (), n, inner[]);
                }
            }
        }

        WhileLoopExpr::new (loc, content, isDo-> false)
    }


    /**
     * Read a while loop
     * @verbatim:
     * ===========================
     * while_expr := Keys::WHILE expression:(0) expression:(0)
     * ===========================
     */
    fn readWhile (mut self, loc : &Word)-> &Expression
        throws &ErrorMsg
    {

        let (isLet, _) = self:.readIf (Keys::LET);
        let (test : &Expression, guard : &Expression) = if (isLet.isEof ()) {
            (self:.readExpression (), EmptyExpression::new ())
        } else {
            let vdecl = self:.readVarDeclaration (isLet, onlyOne-> true, level-> 3us);
            let guard = if (!self:.readIf (Tokens::DAND)._0.isEof ()) {
                self:.readExpression ()
            } else { cast!{&Expression} (EmptyExpression::new ()) };

            (vdecl, guard)
        };

        let mut content = self:.readExpression ();
        match content {
            BlockExpr () => {}
            _ => {
                let (n, _) = self:.readIf (Tokens::SEMI_COLON);
                if (!n.isEof ()) {
                    let dmut inner = Vec!{&Expression}::new ();
                    inner:.push (content);
                    inner:.push (UnitExpr::new ());
                    content = BlockExpr::new (content.getLoc (), n, inner[]);
                }
            }
        }

        if (isLet.isEof ()) {
            WhileLoopExpr::new (loc, test-> test, content, isDo-> false)
        } else {
            let elseBr = BreakExpr::new (loc, EmptyExpression::new ());
            let innerCond = ConditionalExpr::new (loc, test, content, else_-> elseBr, isLet-> true, guard-> guard);
            WhileLoopExpr::new (loc, innerCond, isDo-> false)
        }
    }

    /**
     * Read a template call expr
     * @verbatim:
     * ===========================
     * template_call_expr := expression:(0) Tokens::NOT ((Tokens::LACC param_list Tokens::RACC) | operand:(3))
     * ===========================
     */
    fn readTemplateCall (mut self, var : &Expression)-> &Expression
        throws &ErrorMsg
    {

        let (n, _) = self:.readIf (Tokens::NOT);
        if (!self._inTemplateCall && n == Tokens::NOT) {
            let (a, _) = self:.readIf (self._specials.specialBinaryOperators);
            if (!a.isEof ()) {
                self._lex:.rewind (nb-> 2u64);
                return var;
            }

            let (n2, _) = self:.readIf (Tokens::LACC);
            let res = self._inTemplateCall;
            {
                if (!n2.isEof ()) {
                    self._inTemplateCall = false;
                    let (lst, _) = self:.readArgumentList (withNamed-> false, closing-> Tokens::RACC);
                    self._inTemplateCall = res;

                    return TemplateCallExpr::new (n, var, lst);
                } else {
                    self._inTemplateCall = true;
                    let lst = [self:.readOperand3 ()];
                    self._inTemplateCall = res;

                    return TemplateCallExpr::new (n, var, lst);
                }
            } catch {
                err : &ErrorMsg => {
                    self._inTemplateCall = res;
                    throw err;
                }
            }
        } else if (n == Tokens::NOT) {
            throw ErrorMsg::fatal (n, SyntaxErrorMessage::MISSING_TEMPLATE_ACC);
        }

        var
    }


    /**
     * Read a macro call
     * @verbatim:
     * ==================
     * macro_call_expr :=   expression:(0) Tokens::MACRO_ACC (Any)* Tokens::RACC
     *                    | expression:(0) Tokens::MACRO_PAR (Any)* Tokens::RPAR
     *                    | expression:(0) Tokens::MACRO_CRO (Any)* Tokens::RCRO
     * ==================
     */
    fn readMacroCall (mut self, loc : &Word, var : &Expression)-> &Expression
        throws &ErrorMsg
    {
        let (open, close) = match loc.str () {
            Tokens::MACRO_ACC => { (Tokens::LACC, Tokens::RACC) }
            Tokens::MACRO_PAR => { (Tokens::LPAR, Tokens::RPAR) }
            _ => { (Tokens::LCRO, Tokens::RCRO) }
        }

        let (res, closing) = self._lex:.getString (opening-> [open, loc.str ()], closing-> close);
        if (closing.isEof ()) throw ErrorMsg::fatal (closing, SyntaxErrorMessage::BLOCK_NEVER_CLOSED, notes-> [ErrorMsg::note (loc, SyntaxErrorMessage::IN_DECL_BLOCK)]);


        MacroCallExpr::new (loc, closing, var, res)
    }



    /**
     * Read a variable
     * @verbatim:
     * ===================
     * var := Identifier (template_call)?
     * ===================
     */
    fn readVar (mut self, canBeTemplateCall : bool = true)-> &Expression
        throws &ErrorMsg
    {
        let (var, _) = self:.readIdentifier ();
        if (canBeTemplateCall) {
            self:.readTemplateCall (VarExpr::new (var))
        } else {
            cast!{&Expression} (VarExpr::new (var))
        }
    }

    /**
     * Read a lambda expression
     * @verbatim:
     * ========================
     * lambda_expr := function_proto:(lambda) (Tokens::DARROW)? expression:(0)
     * ========================
     */
    fn readLambda (mut self, loc : &Word)-> &Expression
        throws &ErrorMsg
    {
        self._lex:.rewind ();
        let proto = self:.readFunctionPrototype (isClosure-> true, isClass-> false);
        self:.readIf (Tokens::DARROW);
        LambdaValueExpr::new (loc, proto, self:.readExpression ())
    }


    /**
     * Read a tuple expression
     * @verbatim:
     * ========================
     * param_expr := Tokens::LPAR (expression:(0) (Tokens::COMA | (Tokens::COMA expression:(0))*))? Tokens::RPAR
     * ========================
     */
    fn readTuple (mut self, loc : &Word)-> &Expression
        throws &ErrorMsg
    {
        let mut end = self:.readIf (Tokens::RPAR)._0;
        if (end == Tokens::RPAR) { return ListExpr::new (loc, end, []); }

        let dmut params = Vec!{&Expression}::new ();
        params:.push (self:.readExpression ());

        let (n, _) = self:.readTokens (Tokens::COMA, Tokens::RPAR, Keys::FOR);
        if (n == Keys::FOR) {
            let forLoc = n;
            let dmut decls = Vec!{&Expression}::new ();
            let (par, _) = self:.readIf (Tokens::LPAR);
            loop {
                decls:.push (self:.readSingleVarDeclaration (mandType-> false, withValue-> false));
                let (n2, _) = self:.readTokens (Tokens::COMA, Keys::IN);
                if (n2 == Keys::IN) break {}
            }

            let iter = self:.readExpression ();
            if (!par.isEof ()) self:.readTokens (Tokens::RPAR);
            self:.readTokens (Tokens::COMA);
            self:.readTokens (Tokens::RPAR);

            return SliceForAllocatorExpr::new (loc, forLoc, params[0us], decls[], iter, isTuple-> true);
        } else if (n == Tokens::COMA) {
            end = self:.readIf (Tokens::RPAR)._0;
            if (end.isEof ()) {
                loop {
                    params:.push (self:.readExpression ());
                    end = self:.readTokens (Tokens::COMA, Tokens::RPAR)._0;
                    if (end == Tokens::RPAR) break {}
                }

                return ListExpr::new (loc, end, params[]);
            } else {
                return ListExpr::new (loc, end, params[]);
            }
        }

        __pragma!trusted (params [0us])
    }


    /**
     * Read a template checker expr
     * @verbatim:
     * ============================
     * template_check := Keys::IS template_call template_param_list
     * ============================
     */
    fn readTemplateChecker (mut self, loc : &Word)-> &Expression
        throws &ErrorMsg
    {
        let call = self:.readTemplateCall (VarExpr::new (loc));
        match call {
            t : &TemplateCallExpr => {
                let (params, _) = self:.readTemplateParameters (ifLoc-> EOF_WORD, force-> true);
                cast!{&Expression} (TemplateCheckerExpr::new (loc, t.getRights (), params))
            }
            _ => {
                self:.readTokens (Tokens::NOT);
                cast!{&Expression} (EmptyExpression::new ())
            }
        }
    }

    /**
     * Read a cast expression
     * @verbatim:
     * =======================
     * cast_expr := Keys::CAST Tokens::NOT ((Tokens::LACC expression:(0) Tokens::RACC) | (operand:(3)) (Tokens::LPAR expression:(0) Tokens::RPAR)
     * =======================
     */
    fn readCast (mut self, loc : &Word)-> &Expression
        throws &ErrorMsg
    {
        self:.readTokens (Tokens::NOT);
        let type = if (!(self:.readIf (Tokens::LACC)._0).isEof ()) {
            let e = self:.readExpression ();
            self:.readTokens (Tokens::RACC);
            e
        } else {
            self:.readOperand3 ()
        }

        self:.readTokens (Tokens::LPAR);
        let inner = self:.readExpression ();
        self:.readTokens (Tokens::RPAR);

        CastExpr::new (loc, type, inner)
    }


    /*!
     * ================================================================================
     * ================================================================================
     * =========================           MATCHERS           =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Read a catcher expression
     * @verbatim:
     * =========================
     * =========================
     */
    fn readCatcher (mut self, loc : &Word)-> &Expression
        throws &ErrorMsg
    {
        let dmut matchers = Vec!{(&Expression, &Expression, &Expression)}::new ();
        self:.readTokens (Tokens::LACC);
        loop {
            let e = self:.readMatchExpression ();
            let (cd, _) = self:.readTokens (Keys::IF, Tokens::DARROW);
            let condition = if (cd == Keys::IF) {
                let x = self:.readExpression (level-> 1us);
                self:.readTokens (Tokens::DARROW);
                x
            } else {
                cast!{&Expression} (EmptyExpression::new ())
            };

            let mut a = self:.readExpression(level-> self._specials.binaryOperators.len);
            let (tok, _) = self:.readIf (Tokens::SEMI_COLON);
            if (!tok.isEof ()) {
                let dmut inner = Vec!{&Expression}::new ();
                inner:.push (a);
                inner:.push (UnitExpr::new ());
                a = BlockExpr::new (a.getLoc (), tok, content-> inner[]);
            }

            matchers:.push ((e, condition, a));
            if (!(self:.readIf (Tokens::RACC)._0).isEof ()) break {}
        }

        MatcherExpr::new (loc, EmptyExpression::new (), matchers[], isCatcher-> true)
    }

    /**
     * Read a match expression
     * @verbatim:
     * ========================
     * match_expr := Keys::MATCH expression:(0) Tokens::LACC (inner_matcher_expr Tokens::DARROW expression:(10))+ Tokens::RACC
     * ========================
     */
    fn readMatch (mut self, loc : &Word)-> &Expression
        throws &ErrorMsg
    {
        let dmut matchers = Vec!{(&Expression, &Expression, &Expression)}::new ();
        let content = self:.readExpression ();
        self:.readTokens (Tokens::LACC);
        loop {
            let e = self:.readMatchExpression ();
            let (cd, _) = self:.readTokens (Keys::IF, Tokens::DARROW);
            let condition = if (cd == Keys::IF) {
                let x = self:.readExpression (level-> 1us);
                self:.readTokens (Tokens::DARROW);
                x
            } else {
                cast!{&Expression} (EmptyExpression::new ())
            }

            let mut a = self:.readExpression(level-> self._specials.binaryOperators.len);
            let (tok, _) = self:.readIf (Tokens::SEMI_COLON);
            if (!tok.isEof ()) {
                let dmut inner = Vec!{&Expression}::new ();
                inner:.push (a);
                inner:.push (UnitExpr::new ());
                a = BlockExpr::new (a.getLoc (), tok, content-> inner[]);
            }

            matchers:.push ((e, condition, a));
            if (!(self:.readIf (Tokens::RACC)._0).isEof ()) break {}
        }
        MatcherExpr::new (loc, content, matchers[], isCatcher-> false)
    }

    /**
     * Read an matching expression
     * @verbatim:
     * ============================
     * inner_matcher_expr :=   single_var_decl_match
     *                       | calling_match
     *                       | par_match
     *                       | cro_match
     *                       | expression:(0)
     * ============================
     */
    fn readMatchExpression (mut self)-> &Expression
        throws &ErrorMsg
    {
        let (n, _) = self:.readIf (Tokens::LPAR, Tokens::LCRO);
        if (n == Tokens::LPAR) {
            return self:.readParMatch (n, endTok-> Tokens::RPAR);
        } else if (n == Tokens::LCRO) {
            return self:.readParMatch (n, endTok-> Tokens::RCRO);
        } else {
            return self:.readSingleVarDeclarationForMatch ();
        }
    }

    /**
     * Read a single var declaration for a pattern matcher
     * @params:
     *   - empty: allows for var to have no type nor value
     * @verbatim:
     * ========================
     * single_var_decl_match := (Decorator)* (Identifier | Keys::UNDER) Tokens::COLON (Keys::UNDER | expression:(10))  (Tokens::EQUAL inner_matcher_expr)?
     * ========================
     */
    fn readSingleVarDeclarationForMatch (mut self)-> &Expression
        throws &ErrorMsg
    {
        let (isLazyOrRef, isMutOrDmut) = self:.readDecoratorVariable (canBeLazyOrRef-> true);
        if (isLazyOrRef == Keys::LAZY) {
            throw ErrorMsg::fatal (isLazyOrRef, format (SyntaxErrorMessage::UNDEF_DECORATOR_IN_MATCH, isLazyOrRef.str ()));
        }

        let (ig, _) = self:.readIf (Keys::UNDER);
        let name = if (!ig.isEof ()) {
            ig
        } else if (!isLazyOrRef.isEof () || !isMutOrDmut.isEof ()) {
            self:.readIdentifier ()._0
        } else {
            self:.readIfIdentifier ()._0
        };

        // No identifier means no mut/lazy ident, thus it is an expression
        if (name.isEof ()) return self:.readExpression (level-> self._specials.binaryOperators.len);

        // cannot use /self/
        else if (name == Keys::SELF) throw ErrorMsg::fatal (name, format (SyntaxErrorMessage::USED_AS_IDENTIFIER, name.str ()));

        // Option pattern-> /Ok (...), Err (...)/
        else if (name == OptionKeys::MATCH_SOME || name == OptionKeys::MATCH_NONE) {
            // dmut Ok (...) means nothing
            if (isLazyOrRef != EOF_WORD) throw ErrorMsg::fatal (isLazyOrRef, format (SyntaxErrorMessage::UNEXPECTED, isLazyOrRef));
            if (isMutOrDmut != EOF_WORD) throw ErrorMsg::fatal (isMutOrDmut, format (SyntaxErrorMessage::UNEXPECTED, isMutOrDmut));

            return self:.readOptionMatch (name);
        }

        let (tok, _) = self:.readIf (Tokens::COLON, Tokens::EQUAL, Tokens::LPAR, Tokens::NOT, Tokens::DCOLON);

        // Type pattern-> /(ident | _ | ident::ident... | ident!templates...) (...)/
        if (tok == Tokens::LPAR || tok == Tokens::NOT || tok == Tokens::DCOLON) {
            // dmut Type (fields...) means nothing, cannot dmut the type test

            if (isLazyOrRef != EOF_WORD) throw ErrorMsg::fatal (isLazyOrRef, format (SyntaxErrorMessage::UNEXPECTED, isLazyOrRef));
            if (isMutOrDmut != EOF_WORD) throw ErrorMsg::fatal (isMutOrDmut, format (SyntaxErrorMessage::UNEXPECTED, isMutOrDmut));

            self._lex:.rewind ();
            return self:.readCallingMatch (name);
        }

        // var decl with a type -> /decos ident : Type = Value/
        else if (tok == Tokens::COLON) {
            let type = if ((self:.readIf (Keys::UNDER)._0).isEof ()) {
                self:.readExpression (level-> self._specials.binaryOperators.len)
            } else { cast!{&Expression} (EmptyExpression::new ()) }

            // With a value
            let value = if (!(self:.readIf (Tokens::EQUAL)._0).isEof ()) {
                self:.readMatchExpression ()
            } else { cast!{&Expression} (EmptyExpression::new ()) }

            return VarDeclExpr::new (name, name, isMutOrDmut-> isMutOrDmut, isLazyOrRef-> isLazyOrRef, value-> value, type-> type);
        }

        // var decl with a value but not type -> /decos ident = Value/
        else if (tok == Tokens::EQUAL) {
            return VarDeclExpr::new (name, name, isMutOrDmut-> isMutOrDmut, isLazyOrRef-> isLazyOrRef, value-> self:.readMatchExpression (), type-> EmptyExpression::new ());
        }

        // var decl with no type and no value, just an identifier (or even just /_/)
        else  {
            if (name != Keys::UNDER && isMutOrDmut.isEof () && isLazyOrRef.isEof ()) {
                self._lex:.rewind ();
                let content = self:.readExpression (level-> self._specials.binaryOperators.len);
                match content {
                    v : &VarExpr => {
                        return VarDeclExpr::new (v.getLoc (), v.getLoc (), isMutOrDmut-> isMutOrDmut, isLazyOrRef-> isLazyOrRef, value-> EmptyExpression::new (), type-> EmptyExpression::new ());
                    }
                    _ => return content;
                }
            } else {
                return VarDeclExpr::new (name, name, isMutOrDmut-> isMutOrDmut, isLazyOrRef-> isLazyOrRef, value-> EmptyExpression::new (), type-> EmptyExpression::new ());
            }
        }
    }


    /**
     * Read a calling match expression
     * @verbatim:
     * ===============================
     * calling_match :=   (Identifier | Keys::UNDER) (Tokens::DCOLON Identifier)* (template_call)? (Tokens::LPAR (ident Tokens::ARROW inner_matcher_expr (',' ident Tokens::ARROW inner_matcher_expr)*)? Tokens::RPAR)
     *                  | Keys::UNDER
     *                  | option_match
     *                  | expression:(0)
     * ===============================
     */
    fn readCallingMatch (mut self, loc : &Word)-> &Expression
        throws &ErrorMsg
    {
        // a type can be a bit more complex than just an identifier
        // it can be a path to a type, and a template type
        // This pattern does not apply to slices, and tuple, their patterns are different
        let mut var : &Expression = VarExpr::new (loc);
        if (loc != Keys::UNDER) {
            loop {
                let (n, _) = self:.readIf(Tokens::NOT, Tokens::DCOLON);
                if (n == Tokens::NOT) {
                    self._lex:.rewind ();
                    var = self:.readTemplateCall (var);
                    break {}
                } else if (n == Tokens::DCOLON) {
                    var = BinaryExpr::new (n, var, VarExpr::new (self:.readIdentifier ()._0));
                } else break {}
            }
        }

        let (start, _) = self:.readIf (Tokens::LPAR);

        // If read a (, then it is a call pattern
        // calling function, and compare the value should be done within a match guard
        if (!start.isEof ()) {
            let dmut params = Vec!{&Expression}::new ();
            let mut e = self:.readIf (Tokens::RPAR, Tokens::COMA)._0;
            while e != Tokens::RPAR {
                let (ident, _) = self:.readIdentifier ();
                self:.readTokens (Tokens::ARROW);

                params:.push (NamedExpr::new (ident, self:.readMatchExpression ()));
                e = self:.readTokens (Tokens::RPAR, Tokens::COMA)._0;
            }

            MultOperatorExpr::new (start, e, var, params[])
        } else {
            // a variable that is not a var declaration, supposedly read /::/ or /!/
            if (loc == Keys::UNDER) { var }
            else {
                self._lex:.rewindToSeek (cursor-> cast!u64 (loc.seek ()));
                self:.readExpression ()
            }
        }
    }

    /**
     * Read an option match
     * @verbatim:
     * =========================
     * option_match := (OptionKeys::MATCH_SOME | OptionKeys::MATCH_NONE) Tokens::LPAR inner_matcher_expr Tokens::RPAR
     * =========================
     * */
    fn readOptionMatch (mut self, loc : &Word)-> &Expression
        throws &ErrorMsg
    {
        self:.readTokens (Tokens::LPAR);
        let inner = if (self:.readIf (Tokens::RPAR)._0.isEof ()) { // some (inner) =>
            let inner = self:.readMatchExpression ();
            self:.readTokens (Tokens::RPAR);
            inner
        } else { // some () =>
            cast!{&Expression} (EmptyExpression::new ())
        }

        OptionMatcherExpr::new (loc, inner)
    }

    /**
     * Read a list in match expression
     * @verbatim:
     * ===============================
     * par_match :=   Tokens::LPAR (inner_matcher_expr (Tokens::COMA inner_matcher_expr )* (Tokens::COMA inner_matcher_expr Tokens::TDOT))? Tokens::RPAR
     *              | Tokens::LPAR (inner_matcher_expr (Tokens::TDOT)? Tokens::COMA) Tokens::RPAR
     *              | Tokens::LCRO (inner_matcher_expr (Tokens::COMA inner_matcher_expr)*)? Tokens::RCRO
     * ===============================
     */
    fn readParMatch (mut self, loc : &Word, endTok : [c8] = Tokens::RPAR)-> &Expression
        throws &ErrorMsg
    {
        let dmut params = Vec!{&Expression}::new ();
        let mut e = self:.readIf (endTok)._0;
        while e != endTok {
            params:.push (self:.readMatchExpression ());

            e = self:.readTokens (Tokens::COMA, endTok, Tokens::TDOT)._0;
            if (e == Tokens::TDOT) {
                if (endTok == Tokens::RPAR && params.len () == 1us) {
                    self:.readTokens (Tokens::COMA);
                }
                e = self:.readTokens (endTok)._0;
                return ListMatcherExpr::new (loc, e, params[], true);
            }

            if (params.len () == 1us) {
                if (e == Tokens::COMA && endTok == Tokens::RPAR && !self:.readIf (Tokens::RPAR)._0.isEof ()) { // (x,) is a tuple
                    return ListMatcherExpr::new (loc, e, params[], false);
                }
            }
        }

        // (x) is not a tuple, just x, but () is a tuple
        if (endTok == Tokens::RPAR && params.len () == 1us) return params [0us];
        ListMatcherExpr::new (loc, e, params[], false)
    }


    /*!
     * ================================================================================
     * ================================================================================
     * =========================           LITERALS           =========================
     * ================================================================================
     * ================================================================================
     */


    /**
     * Read a literal
     * @verbatim:
     * ================
     * literal :=   Numeric
     *            | Float
     *            | Char
     *            | String
     *            | (Keys::TRUE | Keys::FALSE)
     *            | Keys::NULL
     *            | Tokens::DOLLAR
     * ================
     */
    pub fn readLiteral (mut self, canBeFloat : bool = true)-> &Expression
        throws &ErrorMsg
    {
        let (start, _) = self._lex:.next ();
        self._lex:.rewind ();

        if (start.str ().len > 0us) {
            let c = start.str ()[0];
            if ((c >= '0'c8 && c <= '9'c8) || (c == '_'c8 && start.str ().len != 1us)) return self:.readNumeric (canBeFloat-> canBeFloat);
        }

        if (start == Tokens::SQUOTE) {
            return self:.readString ();
        } else if (start == Tokens::DQUOTE) {
            return self:.readString ();
        } else if (start == Keys::TRUE || start == Keys::FALSE) {
            return BoolExpr::new (self._lex:.next ()._0);
        } else if (start == Keys::NULL) {
            return NullExpr::new (self._lex:.next ()._0);
        } else if (start == Keys::NONE) {
            return NoneExpr::new (self._lex:.next ()._0);
        } else if (start == Tokens::DOLLAR) {
            return DollarExpr::new (self._lex:.next ()._0);
        } else if (start == Tokens::DDOT) {
            let tok = self._lex:.next ()._0;
            let type = self:.readOperand3 ();
            return RangeTypeExpr::new (tok, type);
        } else {
            throw ErrorMsg::fatal (start, format (SyntaxErrorMessage::UNEXPECTED, start.str ()));
        }
    }



    /**
     * Read a namepath expression
     * @verbatim:
     * =============
     * namepath_expr := Identifier ('::' Identifier)*
     * =============
     */
    fn readPath (mut self) -> &Expression
        throws &ErrorMsg
    {
        let fst = self:.readIdentifier ();
        let mut res : &Expression = VarExpr::new (fst._0);
        loop {
            let (next, _) = self:.readIf (Tokens::DCOLON);
            if (!next.isEof ())  {
                let af = {
                    let (x, _) = self:.readIf (Keys::UNDER);
                    if !x.isEof () { x }
                    else { self:.readIdentifier ()._0 }
                }
                res = PathExpr::new (next, res, VarExpr::new (af));
            } else break {}
        }

        res
    }

    /**
     * Read a complex path
     * @example:
     * ====
     * foo::{bar, baz} => [ foo::bar, foo::baz ]
     * foo::{bar::{baz, bad::ouch}, fee} ==> [ foo::bar::baz, foo::bar::bad::ouch, foo::fee ]
     * ====
     * */
    fn readComplexPath (mut self, root : &Expression, dmut result : &Vec!{&Expression})
        throws &ErrorMsg
    {
        let mut res = root;
        loop {
            let (next, _) = self:.readIf (Tokens::DCOLON);
            if (!next.isEof ()) {
                if (!self:.readIf (Tokens::LACC)._0.isEof ()) {
                    loop {
                        let (under, _) = self:.readIf (Keys::UNDER);
                        if (!under.isEof ()) {
                            result:.push (PathExpr::new (next, res, VarExpr::new (under)));
                        } else {
                            let current = PathExpr::new (next, res, VarExpr::new (self:.readIdentifier ()._0));
                            self:.readComplexPath (current, alias result);
                        }

                        if (self:.readTokens (Tokens::RACC, Tokens::COMA)._0 == Tokens::RACC) break {}
                    }
                    break {}
                } else {
                    let (under, _) = self:.readIf (Keys::UNDER);
                    if (!under.isEof ()) {
                        result:.push (PathExpr::new (next, res, VarExpr::new (under)));
                        break {}
                    }
                    res = PathExpr::new (next, res, VarExpr::new (self:.readIdentifier ()._0));
                }
            } else {
                result:.push (res);
                break {}
            }
        }
    }

    /**
     * Read an array literal
     * @verbatim:
     * =================
     * array_lit := Tokens::LCRO (expression:(0) (Tokens::COMA expression:(0))*)? Tokens::RCRO
     *              | Tokens::AND_LCRO (expression:(0) (Tokens::COMA expression:(0))*)? Tokens::RCRO
     * =================
     */
    fn readArray (mut self, loc : &Word)-> &Expression
        throws &ErrorMsg
    {
        let (n, _) = self:.readIf (Tokens::RCRO);
        if (!n.isEof ()) return ListExpr::new (loc, n, [], isArray-> true);

        let dmut params = Vec!{&Expression}::new ();
        params:.push (self:.readExpression ());
        let (e, _) = self:.readIf (Tokens::SEMI_COLON, Tokens::RCRO, Tokens::COMA, Keys::FOR, Tokens::DARROW);

        if (e == Tokens::SEMI_COLON) { // allocation
            let size = self:.readExpression ();
            self:.readTokens (Tokens::RCRO);
            return SliceAllocatorExpr::new (loc, __pragma!trusted ({params [0us]}), size)
        }

        if (e == Keys::FOR) {
            let forLoc = e;
            let dmut decls = Vec!{&Expression}::new ();
            let (par, _) = self:.readIf (Tokens::LPAR);
            loop {
                decls:.push (self:.readSingleVarDeclaration (mandType-> false, withValue-> false));
                let (n2, _) = self:.readTokens (Tokens::COMA, Keys::IN);
                if (n2 == Keys::IN) break {}
            }

            let iter = self:.readExpression ();
            if (!par.isEof ()) self:.readTokens (Tokens::RPAR);
            self:.readTokens (Tokens::RCRO);

            return SliceForAllocatorExpr::new (loc, forLoc, params[0us], decls[], iter, isTuple-> false);
        }

        if (e == Tokens::DARROW) { // map [a => ...
            return self:.readListMap (loc, alias params);
        }

        let mut end = e;
        if (e != Tokens::RCRO) {
            loop {
                params:.push (self:.readExpression ());
                end = self:.readTokens([Tokens::RCRO, Tokens::COMA])._0;
                if (end == Tokens::RCRO) {
                    break {}
                }
            }
        }

        ListExpr::new (loc, end, params[], isArray-> true)
    }

    /**
     * Read a map literal
     * @verbatim:
     * ===============
     * listmap_lit := Tokens::LCRO  map_element (Tokens::COMA map_element)* Tokens::RCRO
     * map_element := expression:(10) Tokens::ARROW expression:(10)
     * ===============
     * */
    fn readListMap (mut self, loc : &Word, dmut keys : &Vec!{&Expression})-> &Expression
        throws &ErrorMsg
    {
        let dmut values = Vec!{&Expression}::new ();
        values:.push (self:.readExpression ());

        let mut end : &Word = EOF_WORD;
        loop {
            end = self:.readTokens (Tokens::RCRO, Tokens::COMA)._0;
            if (end == Tokens::RCRO) {
                break {}
            }

            keys:.push (self:.readExpression ());
            self:.readTokens (Tokens::DARROW);
            values:.push (self:.readExpression ());
        }

        return ListMapExpr::new (loc, end-> end, keys[], values[]);
    }

    /**
     * Read a numeric value
     */
    fn readNumeric (mut self, canBeFloat : bool = true)-> &Expression
        throws &ErrorMsg
    {
        let (begin, _) = self._lex:.next ();
        if (begin.str ().len >= 4us) { // ends with i32, i16, ...
            let str_suff = begin.str ()[$ - 3us .. $];
            if (self.isFixedSuffix (str_suff)) {
                let suff = Word::new (str_suff, begin);
                let value = begin.str ()[0us .. $ - 3us];
                self.verifNumeric (begin, value);
                return FixedExpr::new (Word::new (value, begin), suffix-> suff);
            }
        }

        if (begin.str ().len >= 3us) { // ends with is, us for isize and usize
            let str_suff = begin.str ()[$ - 2us .. $];
            if (self.isFixedSuffix (str_suff)) {
                let suff = Word::new (str_suff, begin);
                let value = begin.str ()[0us .. $ - 2us];
                self.verifNumeric (begin, value);
                return FixedExpr::new (Word::new (value, begin), suffix-> suff);
            }
        }

        let value = begin.str ();
        let isStrictlyInt = self.verifNumeric (begin, value); // return true iif starts with 0x, 0o, 0b
        if (!isStrictlyInt && canBeFloat) {
            let n = self:.readDirectIf (Tokens::DOT);
            if (n == Tokens::DOT) {
                self._lex:.rewind ();
                return self:.readFloat (begin-> begin);
            }
        } else if (isStrictlyInt && value.len > 2us && value [0] == '0'c8 && value [1] == 'x'c8) { // but float can also start with 0x, e.g. 0xA.89p+29f
            let n = self:.readDirectIf (Tokens::DOT);
            if (n == Tokens::DOT) { // but has to contain a dot directly afterwards
                self._lex:.rewind ();
                return self:.readHexFloat (begin-> begin);
            }
        }

        FixedExpr::new (begin)
    }

    /**
     * Read a float expr (in decimal mode)
     * @params:
     * - begin: the content before the dot
     */
    fn readFloat (mut self, begin : &Word)-> &Expression
        throws &ErrorMsg
    {
        let (dot, after) =
            (self:.readDirectTokens (Tokens::DOT), self._lex:.directNext ());

        if (self.isFloatScientific (after.str ())) { // 1.e+89f
            return self:.readScientificFloat (begin, dot, after);
        } else if (after.str ().len > 0us && after.str ()[0] >= '0'c8 && after.str ()[0] <= '9'c8) { // 1.0839f
            if (after.str ().len >= 2us) {
                if (self.isFloatSuffix (after.str ()[$ - 1us .. $])) {
                    let suff = Word::new (after.str ()[$ - 1us .. $], after);
                    let value = after.str ()[0us .. $ - 1us];
                    self.verifNumeric (after, value, canHexa-> false);
                    return FloatExpr::new (dot, begin, Word::new (value, after), suffix-> suff);
                }
            }

            let value = after.str ();
            self.verifNumeric (after, value, canHexa-> false);
            return FloatExpr::new (dot, begin, after, suffix-> EOF_WORD)
        } else if (self.isFloatSuffix (after.str ())) { // 1.f
            return FloatExpr::new (dot, begin, EOF_WORD, suffix-> after)
        } else { // 1.
            self._lex:.rewind ();
            return FloatExpr::new (dot, begin, EOF_WORD, suffix-> EOF_WORD)
        }
    }

    /**
     * Read a float in scientific notation format
     * @params:
     *    - begin: the integral part
     *    - dot: the dot
     *    - after: the decimal part
     * */
    fn readScientificFloat (mut self, begin : &Word, dot : &Word, after : &Word)-> &Expression
        throws &ErrorMsg
    {
        let (suffDec, mut suffExp) = self.getFloatScientific (after.str ());
        let mut pos = true;
        let suff = if (suffExp.len == 0us) { // e+, e-, E+, E-
            pos = (self:.readDirectTokens ([Tokens::MINUS, Tokens::PLUS]) == Tokens::PLUS); // read the +, -
            suffExp = self._lex:.directNext ().str (); // read the numeric values after E+, E-...
            if (suffExp.len > 0us && self.isFloatSuffix (suffExp [$ - 1us .. $])) { // if may contain a float suffix
                let s = Word::new (suffExp[$-1us .. $], after);
                suffExp = suffExp [0us .. $ - 1us];
                s
            } else { EOF_WORD }
        } else { // just e1029f...
            if (self.isFloatSuffix (after.str ()[$ - 1us .. $])) {
                Word::new (after.str ()[$-1us .. $], after)
            } else { EOF_WORD }
        };

        self.verifNumeric (after, suffExp, canHexa-> false);
        self.verifNumeric (after, suffDec, canHexa-> false);
        return FloatExpr::new (dot, begin, Word::new (suffDec, after), suffix-> suff, exp-> Word::new (suffExp, after), expPositive-> pos);
    }

    /**
     * Read a float in hexadecimal notation
     * */
    fn readHexFloat (mut self, begin : &Word)-> &Expression
        throws &ErrorMsg
    {
        let (dot, after) =
            (self:.readDirectTokens (Tokens::DOT), self._lex:.directNext ());

        let mut pos = true;
        let (suffDec, mut suffExp) = self.getFloatHexExp (after, after.str ()); // unlike scientific notation, 'p' is mandatory

        let suff = if (suffExp.len == 0us) { // p+, p-, P+, P-
            pos = (self:.readDirectTokens ([Tokens::MINUS, Tokens::PLUS]) == Tokens::PLUS); // read the +, -
            suffExp = self._lex:.directNext ().str (); // read the numerix values after P+, P-, ...
            if (suffExp.len > 0us && self.isFloatSuffix (suffExp [$ - 1us .. $])) { // maybe it ends with "f"
                let s = Word::new (suffExp [$ - 1us .. $], after);
                suffExp = suffExp [0us .. $ - 1us];
                s
            } else { EOF_WORD }
        } else {
            if (self.isFloatSuffix (after.str ()[$ - 1us .. $])) { // ending with "f"
                Word::new (after.str ()[$ - 1us .. $], after)
            } else { EOF_WORD }
        };

        for i in 0us .. suffDec.len { // only hex chars
            if ((suffDec [i] < '0'c8 || suffDec [i] > '9'c8) && (suffDec [i] < 'A'c8 || suffDec [i] > 'F'c8) && (suffDec [i] < 'a'c8 || suffDec [i] > 'f'c8) && suffDec [i] != Keys::UNDER [0]) {
                throw ErrorMsg::fatal (after, format (SyntaxErrorMessage::UNEXPECTED, suffDec), notes-> [
                    ErrorMsg::note (Word::new (suffDec [i .. i + 1us], after, addCol-> cast!u64 (i)), ""s8)]);
            }
        }

        self.verifNumeric (after, suffExp, canHexa-> false);
        return FloatExpr::new (dot, begin, Word::new (suffDec, after), suffix-> suff, exp-> Word::new (suffExp, after), expPositive-> pos, isHex-> true);
    }



    /**
     * Read a string literal
     * @verbatim:
     * =======================
     * string_lit :=   Tokens::DQUOTE Any* Tokens::DQUOTE (StringSuffixes::UTF8 | StringSuffixes::UTF32)?
     *               | Tokens::SQUOTE Any* Tokens::SQUOTE (CharSuffixes::UTF8 | CharSuffixes::UTF32)?
     * =======================
     */
    pub fn readString (mut self, forceDouble : bool = false)-> &Expression
        throws &ErrorMsg
    {
        let (start, _) = if (forceDouble) {
            self:.readTokens (Tokens::DQUOTE)
        } else {
            self:.readTokens (Tokens::DQUOTE, Tokens::SQUOTE)
        };

        let closing = start.str ();
        let (res, end) = self._lex:.getString (closing-> closing, escaping-> true);
        if (end.isEof ()) throw ErrorMsg::fatal (end, SyntaxErrorMessage::BLOCK_NEVER_CLOSED, notes-> [ErrorMsg::note (start, SyntaxErrorMessage::IN_DECL_BLOCK)]);

        let format = if (start == Tokens::DQUOTE) {
            self:.readDirectIf (self._specials.stringSuffixes)
        } else { self:.readDirectIf (self._specials.charSuffixes) }

        if (start == Tokens::DQUOTE)
            StringExpr::new (start, end, res, suffix-> format)
        else CharExpr::new (start, end, res, suffix-> format)
    }




    /**
     * Read an identifier from the lexer
     * @throws:
     *    - ErrorMsg: if the next token is not a valid identifier
     */
    pub fn readIdentifier (mut self)-> (&Word, [c8])
        throws &ErrorMsg
    {
        let (ident, comm) = self._lex:.next ();
        if (!self.isIdentifier (ident.str ())) {
            throw ErrorMsg::fatal (ident, format (SyntaxErrorMessage::USED_AS_IDENTIFIER, ident.str ()));
        }

        (ident, comm)
    }

    /**
     * Read an identifier if there is an identifier to read
     * @returns: the identifier (and associated comment), or (EOF_WORD, ""s8) if no identifier can be read
     */
    fn readIfIdentifier (mut self)-> (&Word, [c8]) {
        let begin = self._lex.getCounter ();
        let x = self:.readIdentifier ()?;
        match x {
            Ok (name:_) => { name }
            _ => {
                self._lex:.rewindTo (nb-> begin);
                (EOF_WORD, ""s8)
            }
        }
    }

    /**
     * @returns: true if str is a valid identifier, false otherwise
     */
    fn isIdentifier (self, str : [c8])-> bool {
        if (str in self._forbiddenKeys) {
            return false;
        }

        let mut i = 0u64;
        let mut found = false;
        for j in str { // must start by a letter, but can be preceded by as many _ as wanted
            if (j >= 'a'c8 && j <= 'z'c8) || (j >= 'A'c8 && j <= 'Z'c8) {
                found = true;
                break {}
            } else if (j != '_'c8) {
                return false;
            }
            i += 1u64;
        }

        i += 1u64;
        if (i < str.len) { // the rest of the identifier must be composed of letters, numbers, or _
            for j in str [cast!usize (i) .. $] {
                if (j < 'a'c8 || j > 'z'c8) && (j < 'A'c8 || j > 'Z'c8) && (j != '_'c8) && (j < '0'c8 || j > '9'c8) {
                    return false;
                }
            }
        } else {
            return found;
        }

        true
    }


    /*!
     * ================================================================================
     * ================================================================================
     * =========================        MISCELLANEOUS         =========================
     * ================================================================================
     * ================================================================================
     */


    /**
     * @returns: the next token inside the lexer, if it is equals to one of the token inside lst
     * @info: if none of lst token is found, the lexer is not incremented
     * @params:
     *    - lst: a list of tokens
     */
    fn readIf {R...} (mut self, f : [c8], lst : R)-> (&Word, [c8]) {
        let (x, y) = self._lex:.next ();
        if (x.isEof ()) return (EOF_WORD, ""s8);

        if (self.equals (x.str (), f, expand lst)) return (x, y);

        self._lex:.rewind ();
        (EOF_WORD, ""s8)
    }

    fn equals {A, R...} (self, r : [c8], a : A, b : R) -> bool {
        if a == r {
            true
        } else {
            cte if (R,)::arity != 1us {
                for i in b {
                    if i == r { return true; }
                }

                false
            } else {
                b == r
            }
        }
    }

    fn equals {A} (self, r : [c8], a : A)-> bool {
        r == a
    }

    /**
     * @returns: the next token inside the lexer, if it is equals to one of the token inside lst
     * @info: if none of lst token is found, the lexer is not incremented
     * @params:
     *    - lst: a list of tokens
     */
    fn readIf (mut self, lst : [[c8]])-> (&Word, [c8]) {
        let (x, y) = self._lex:.next ();
        if (x.isEof ()) return (EOF_WORD, ""s8);

        for i in lst {
            if i == x.str () {
                return (x, y);
            }
        }

        self._lex:.rewind ();
        (EOF_WORD, ""s8)
    }

    /**
     * @returns: the next token inside the lexer, if it is equals to one of the token inside lst
     * @info: if none of lst token is found, the lexer is not incremented
     * @params:
     *    - lst: a list of tokens
     */
    fn readDirectIf (mut self, lst : [[c8]])-> &Word {
        let x = self._lex:.directNext ();
        if (x.isEof ()) return EOF_WORD;

        for i in lst {
            if i == x.str () {
                return x;
            }
        }

        self._lex:.rewind ();
        EOF_WORD
    }


    /**
     * @returns: the next token inside the lexer, if it is equals to one of the token inside lst
     * @info: if none of lst token is found, the lexer is not incremented
     * @params:
     *    - lst: a token
     */
    fn readIf (mut self, lst : [c8])-> (&Word, [c8]) {
        let (x, y) = self._lex:.next ();
        if (x.isEof ()) return (EOF_WORD, ""s8);

        if (x.str () == lst) return (x, y);

        self._lex:.rewind ();
        (EOF_WORD, ""s8)
    }

    /**
     * @returns: the direct next token inside the lexer, if it is equals to one of the token inside lst
     * @info: if none of lst token is found, the lexer is not incremented
     * @params:
     *    - lst: a token
     */
    fn readDirectIf (mut self, lst : [c8])-> &Word {
        let x = self._lex:.directNext ();
        if (x.isEof ()) return EOF_WORD;

        if (x.str () == lst) return x;

        self._lex:.rewind ();
        EOF_WORD
    }

    /**
     * @returns: the next token inside the lexer, if it is equals to one of the token inside lst
     * @throws:
     *   - ErrorMsg: if none of the token in lst is equal to the token that have been read, or the next token is eof
     * @params:
     *    - lst: a list of tokens
     */
    fn readTokens {R...} (mut self, f : [c8], lst : R)-> (&Word, [c8])
        throws &ErrorMsg
    {
        let (x, y) = self._lex:.next ();
        if (self.equals (x.str (), f, expand lst)) return (x, y);

        let dmut err = Vec!{[c8]}::new ();
        err:.push (f);
        for i in (expand lst,) {
            err:.push (i);
        }

        throw ErrorMsg::fatal (x, format (SyntaxErrorMessage::UNEXPECTED_BUT_LST, x.str (), err[]));
    }

    /**
     * @returns: the next token inside the lexer, if it is equals to one of the token inside lst
     * @throws:
     *   - ErrorMsg: if none of the token in lst is equal to the token that have been read, or the next token is eof
     * @params:
     *    - lst: a list of tokens
     */
    pub fn readTokens (mut self, lst : [[c8]])-> (&Word, [c8])
        throws &ErrorMsg
    {
        let (x, y) = self._lex:.next ();
        for i in lst {
            if i == x.str () {
                return (x, y);
            }
        }

        throw ErrorMsg::fatal (x, format (SyntaxErrorMessage::UNEXPECTED_BUT_LST, x.str (), lst));
    }

    /**
     * @returns: the direct next token inside the lexer, if it is equals to one of the token inside lst
     * @throws:
     *   - ErrorMsg: if none of the token in lst is equal to the token that have been read, or the next token is eof
     * @params:
     *    - lst: a list of tokens
     */
    fn readDirectTokens (mut self, lst : [[c8]])-> &Word
        throws &ErrorMsg
    {
        let x = self._lex:.directNext ();
        for i in lst {
            if i == x.str () {
                return x;
            }
        }

        throw ErrorMsg::fatal (x, format (SyntaxErrorMessage::UNEXPECTED_BUT_LST, x.str (), lst));
    }


    /**
     * @returns: the next token inside the lexer, if it is equals to one of the token inside lst
     * @throws:
     *   - ErrorMsg: if none of the token in lst is equal to the token that have been read, or the next token is eof
     * @params:
     *    - lst: a token
     */
    fn readTokens (mut self, lst : [c8])-> (&Word, [c8])
        throws &ErrorMsg
    {
        let (x, y) = self._lex:.next ();
        if (x.str () == lst) return (x, y);

        throw ErrorMsg::fatal (x, format (SyntaxErrorMessage::UNEXPECTED_BUT_LST, x.str (), lst));
    }

    /**
     * @returns: the direct next token inside the lexer, if it is equals to one of the token inside lst
     * @throws:
     *   - ErrorMsg: if none of the token in lst is equal to the token that have been read, or the next token is eof
     * @params:
     *    - lst: a token
     */
    fn readDirectTokens (mut self, lst : [c8])-> &Word
        throws &ErrorMsg
    {
        let x = self._lex:.directNext ();
        if (x.str () == lst) return x;

        throw ErrorMsg::fatal (x, format (SyntaxErrorMessage::UNEXPECTED_BUT_LST, x.str (), lst));
    }



    /*!
     * ================================================================================
     * ================================================================================
     * =========================            TESTS             =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * @returns: true, if this expression needs at the end, a semi colon to be separated from other expressions
     */
    fn needClosingExpr (self, expr : &Expression)-> bool {
        match expr {
            a : &AtomicExpr => { self.needClosingExpr (a.getValue ()) }
            BlockExpr () => { false }
            b : &BreakExpr => { self.needClosingExpr (b.getValue ()) }
            ConditionalExpr () => { false }
            EmptyExpression () => { false }
            ForLoopExpr () => { false }
            UnitExpr () => { false }
            MatcherExpr () => { false }
            r : &ReturnExpr =>  { self.needClosingExpr (r.getValue ()) }
            ScopeGuardExpr () => { false }
            t : &ThrowExpr => { self.needClosingExpr (t.getValue ()) }
            l : &WhileLoopExpr => { l.isDo () }
            UnsafeExpr () => { false }
            s : &SetExpr => {
                if (s.getContent ().len != 0us) {
                    __pragma!trusted ({
                        self.needClosingExpr (s.getContent ()[$ - 1us])
                    })
                } else { false }
            }
            v : &VarDeclExpr => {
                match v.getValue () {
                    EmptyExpression () => { true }

                    _ => {
                        self.needClosingExpr (v.getValue ())
                    }
                }
            }
            v : &PatternVarDeclExpr => {
                match v.getValue () {
                    EmptyExpression () => { true }
                    _ => {
                        self.needClosingExpr (v.getValue ())
                    }
                }
            }
            i : &IntrinsicExpr => {
                if (i.getType () == IntrinsicKeys::CTE) {
                    self.needClosingExpr (i.getContent ())
                } else { true }
            }
            _ => { true }
        }
    }

    /**
     * Verification of the content of the numeric
     * @returns: true iif in hexa decimal or octal, or binary
     */
    fn verifNumeric (self, loc : &Word, value : [c8], canHexa : bool = true)-> bool
        throws &ErrorMsg
    {
        if (value.len > 2us && value [0us] == '0'c8 && value [1] == 'x'c8 && canHexa) {
            for i in 2us .. value.len {
                if (value [i] < '0'c8 || value [i] > '9'c8) && (value [i] < 'A'c8 || value [i] > 'F'c8) && (value [i] < 'a'c8 && value [i] > 'f'c8) && value [i] != Keys::UNDER[0] {
                    throw ErrorMsg::fatal (loc, format (SyntaxErrorMessage::UNEXPECTED, value), notes-> [
                        ErrorMsg::note (Word::new (value [i .. i + 1us], loc, addCol-> cast!u64 (i)), ""s8)]);
                }
            }

            true
        } else if (value.len > 2us && value [0] == '0'c8 && value [1] == 'o'c8 && canHexa) {
            for i in 2us .. value.len {
                if (value [i] < '0'c8 || value [i] > '7'c8) && value [i] != Keys::UNDER[0] {
                    throw ErrorMsg::fatal (loc, format (SyntaxErrorMessage::UNEXPECTED, value), notes-> [
                        ErrorMsg::note (Word::new (value [i .. i + 1us], loc, addCol-> cast!u64 (i)), ""s8)]);
                }
            }

            true
        } else if (value.len > 2us && value [0] == '0'c8 && value [1] == 'b'c8 && canHexa) {
            for i in 2us .. value.len {
                if (value [i] != '0'c8 && value [i] != '1'c8 && value [i] != Keys::UNDER [0]) {
                    throw ErrorMsg::fatal (loc, format (SyntaxErrorMessage::UNEXPECTED, value), notes-> [
                        ErrorMsg::note (Word::new (value [i .. i + 1us], loc, addCol-> cast!u64 (i)), ""s8)]);
                }
            }

            true
        } else {
            for i in 0us .. value.len {
                if (value [i] < '0'c8 || value [i] > '9'c8) && value [i] != Keys::UNDER[0] {
                    throw ErrorMsg::fatal (loc, format (SyntaxErrorMessage::UNEXPECTED, value), notes-> [
                        ErrorMsg::note (Word::new (value [i .. i + 1us], loc, addCol-> cast!u64 (i)), ""s8)]);
                }
            }

            false
        }
    }


    /*!
     * ================================================================================
     * ================================================================================
     * =========================             CONV             =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Transform a word into a protection
     * @info: if the word does not contain a protection, by default Protection::PRIVATE is returned
     */
    fn toProtection (self, msg : [c8])-> Protection {
        match msg {
            Keys::PUBLIC => { Protection::PUBLIC }
            Keys::PRIVATE => { Protection::PRIVATE }
            Keys::PROTECTED => { Protection::PROTECTED }
            _ => {
                __pragma!panic ();
            }
        }
    }

    /**
     * Transform a word into a template var type
     * @info: if the word does not contain a template var type, by default TemplateVarType::TUPLE is returned
     */
    fn toTemplateVarType (self, msg : [c8])-> TemplateVarType {
        for i in TemplateVarType::__members__ {
            if i == msg {
                return i;
            }
        }

        __pragma!panic ();
    }

    /**
     * Transform a word into a template of var type
     * @info: if the word does not contain a template var type, by default TemplateOfVarType::IMPL is returned
     */
    fn toTemplateOfVarType (self, msg : [c8])-> TemplateOfVarType {
        for i in TemplateOfVarType::__members__ {
            if i == msg {
                return i;
            }
        }

        __pragma!panic ();
    }

    /**
     * Transform a word into an scope guard key
     * @info: if the word does not contain a scope guard name, by default ScopeGuardType::EXIT is returned
     */
    fn toScopeGuard (self, msg : [c8])-> ScopeGuardType {
        for i in ScopeGuardType::__members__ {
            if i == msg {
                return i;
            }
        }

        __pragma!panic ();
    }

    /**
     * Transform a word into an intrinsic key
     * @info: if the word does not contain a intrinsic name, by default IntrinsicKeys::DCOPY is returned
     */
    fn toIntrinsic (self, msg : [c8])-> IntrinsicKeys {
        for i in IntrinsicKeys::__members__ {
            if i == msg {
                return i;
            }
        }

        __pragma!panic ();
    }

    /**
     * @returns: true if msg is a fixed suffix
     */
    fn isFixedSuffix (self, msg : [c8])-> bool {
        for i in self._specials.fixedSuffixes {
            if (i == msg) return true;
        }

        false
    }

    /**
     * @returns: true if msg is a float suffix
     */
    fn isFloatSuffix (self, msg : [c8])-> bool {
        for i in self._specials.floatSuffixes {
            if (i == msg) return true;
        }

        false
    }

    /**
     * @returns: true if part is a float exp decimal part (e.g. 45e78f)
     */
    fn isFloatScientific (self, part : [c8])-> bool {
        let mut readE = false;
        if (part.len == 0us) return false;
        let p = if (self.isFloatSuffix (part [$-1us .. $]))
            part [0us .. $ - 1us]
        else { part };

        let mut i = 0us;
        while i < p.len {
            if (p[i] == FloatExp::LE [0] || p[i] == FloatExp::BE [0]) {
                if (readE) return false; // already read exp
                readE = true;
            }
            else if ((p [i] < '0'c8 || p [i] > '9'c8) && p [i] != Keys::UNDER[0]) return false;

            i += 1us;
        }

        readE
    }

    /**
     * @returns: the two parts of a float exp decimal part (e.g. 45e78f => (45, 78)
     * */
    fn getFloatScientific (self, part : [c8])-> ([c8], [c8]) {
        if (part.len == 0us) return (""s8, ""s8);
        let p = if (self.isFloatSuffix (part [$ - 1us .. $]))
            part [0us .. $ - 1us]
        else { part };

        let mut i = 0us;
        while i < p.len {
            if (p[i] == FloatExp::LE [0] || p[i] == FloatExp::BE [0]) {
                return (p[0us .. i], p[i + 1us .. $])
            }

            i += 1us;
        }

        (p, ""s8)
    }

    /**
     * @returns: the two parts of a float hex exp decimal part (e.g. Ap10f => (1, 10)
     * */
    fn getFloatHexExp (self, loc : &Word, part : [c8])-> ([c8], [c8])
        throws &ErrorMsg
    {
        if (part.len == 0us) {
            throw ErrorMsg::fatal (loc, format (SyntaxErrorMessage::UNEXPECTED_BUT_LST, part, [FloatExp::LP, FloatExp::BP]));
        }

        let p = if (self.isFloatSuffix (part [$ - 1us .. $]))
            part [0us .. $ - 1us]
        else { part };

        let mut i = 0us;
        while i < p.len {
            if (p[i] == FloatExp::LP [0] || p[i] == FloatExp::BP [0]) {
                return (p[0us .. i], p[i + 1us .. $])
            }

            i += 1us;
        }

        throw ErrorMsg::fatal (loc, format (SyntaxErrorMessage::UNEXPECTED_BUT_LST, part, [FloatExp::LP, FloatExp::BP]),
                               notes-> [
                                   ErrorMsg::note (Word::new (part [$ - 1us .. $], loc, addCol-> cast!u64 (part.len - 1us)), ""s8)]);
    }



}
