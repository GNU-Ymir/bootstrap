in visitor;

mod ::global;
mod ::special;
mod ::class_;
mod ::expr;
mod ::enum_;
mod ::def_;
mod ::macro_;
mod ::union_;

use ymirc::syntax::errors;
use ymirc::errors::_;
use ymirc::syntax::{_,
                    visitor::_,
                    declaration::_,
                    expression::{_, literal::_, macro_::_, operator::_, template::_}};

use ymirc::lexing::_;
use ymirc::utils::_;
use ymirc::global::state;

use std::{fs::_, io};

/**
 * Open a file and read it's content
 * 
 * @params:
 *    - path: the path to the file
 * */
fn readFile (path : Path)-> [c8]
    throws FsError
{    
    let dmut f = File::open (path);
    f:.readAll ()
}

/**
 * The syntax visitor class is the class used to transform a text content into an analyzable syntax tree
 * The syntax visitor will validated the content of the source code, but only at a syntaxic level
 */
@final
pub class SyntaxVisitor {

    // The path of the file being read
    let _path : Path;

    // The lexer that is used to cut the content string in tokens
    let dmut _lex : &SrcLexer;

    // True iif currently reading template call expr without parentheses
    let mut _inTemplateCall : bool = false;

    // The collection of special tokens and keys
    let _specials : SpecialKeysAndTokens = special::__SPECIAL_TOKENS__;    
    
    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          VISITORS          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    // The visitor for class and struct declarations
    let _classVisitor: ClassVisitor = ClassVisitor (); 

    // The visitor for `def` declarations
    let _defVisitor: DefVisitor = DefVisitor ();
    
    // The visitor for enumerations
    let _enumVisitor: EnumVisitor = EnumVisitor ();

    // The visitor for expressions and instructions
    let _exprVisitor: ExpressionVisitor = ExpressionVisitor ();
    
    // The visitor for global declarations
    let _globalVisitor: GlobalVisitor = GlobalVisitor ();

    // The visitor for reading `macro` declarations
    let _macroVisitor: MacroVisitor = MacroVisitor ();

    // The visitor for reading `union` declarations
    let _unionVisitor: UnionVisitor = UnionVisitor ();
    
    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =====================================          CTORS          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */
    
    /**
     * Create a new visitor for a given file
     * @params:
     *  - path: the path of the file to read
     */
    pub self open (path : Path)
        with _lex = copy SrcLexer (path.toStr (), readFile (path))        
        , _path = path
        throws FsError, ErrorMsg
    {}                    

    /**
     * Create a new visitor from string content
     * @params:
     *    - path: the path of the file containing the string
     *    - content: the content of the string
     * */
    pub self fromStr (path : [c8], content : [c8])
        with _lex = copy SrcLexer (path, content)                                        
        , _path = Path (path)

        throws ErrorMsg
    {}            

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          GETTERS          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * @returns: the lexer
     * */
    pub fn getLexer (mut self)-> dmut &SrcLexer {
        alias self._lex
    }

    /**
     * @returns: the visitor reading global blocks
     * */
    pub fn getGlobalVisitor (self)-> GlobalVisitor {
        self._globalVisitor
    }

    /**
     * @returns: the visitor reading class and struct blocks
     * */
    pub fn getClassVisitor (self)-> ClassVisitor {
        self._classVisitor
    }

    /**
     * @returns: the visitor reading expressions and instructions
     * */
    pub fn getExpressionVisitor (self)-> ExpressionVisitor {
        self._exprVisitor
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          READING          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */
    
    /**
     * Once the visitor is initialized, (with open for instance)
     * the content can be read an transformed into a syntax tree
     * @example:
     * ```
     * let dmut visitor = copy Visitor::open (Path ("foo.yr"));
     * {
     *    // verify the grammar of the content of the file
     *    // And return it into a syntax tre
     *    let module = visitor:.read ();
     *    println (format ("%", module)); // pretty print the module that has been read
     * } catch {
     *    err : &ErrorMsg => {
     *          println (format ("%", err)); // print the error that occured inside the file
     *    }
     * }
     * ```
     */
    pub fn read (mut self)-> &ModuleDecl
        throws ErrorMsg
    {                 
        let (loc, path, comm) = self:.readGlobalModuleName ();
        let block = self._globalVisitor.readBlock (alias self, loc, comm);
        let ret = copy ModuleDecl (loc, path, comm, block, isGlobal-> true);
        ret
    }

    /**
     * Read the first declaration line of the module (if any), and return the declared path
     * @returns:
     *    - .0: the location of the `in` keyword was read, EOF if not
     *    - .1: the identifier of the current module if `in` was read, EOF if not
     *    - .2: the comments describing the current global module
     *
     *
     * @grammar
     * ```
     * GlobalModuleName :=
     *      'in' Identifier ';'
     *    | <empty>
     *    
     * ```
     */
    fn readGlobalModuleName (mut self) -> (&Word, &Word, [c8])
        throws ErrorMsg
    {
        let next = self:.readIf (Keys::IN);
        if (next != Keys::IN) {
            return (EOF_WORD, EOF_WORD, "");
        }
        
        let (path, comm) = self:.readIdentifier ();
        self:.readTokens (Tokens::SEMI_COLON);
        (next, path, comm)
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          ATTRIBUTES          ===================================
     * ====================================================================================================
     * ====================================================================================================
     */


    /**
     * Throw a syntax error if there are attributes in a wrong position (i.e. !attrLoc.isEof)
     * @params:
     *    - loc: the location of the declaration that cannot have attributes
     *    - attrLoc: the attributes location (or EOF if not read)
     *    - attrs: the list of read attributes
     * */
    pub fn checkNoAttributes (self, loc: &Word, attrLoc: &Word, attrs: [AttributeWord])
        throws ErrorMsg
    {        
        if (attrLoc.isEof) return;
        
        let mut notes: [&ErrorMsg] = [];
        if !loc.isEof {
            notes = copy [copy ErrorMsg::note (loc, "")];
        }                
        
        throw copy ErrorMsg::fatal (attrLoc,
                                    format (SyntaxErrorMessage::UNEXPECTED_ATTRIBUTES, copy [x.attr for x in attrs]),
                                    notes-> notes);                
    }

    /**
     * Read a list of custom attributes, if the token Tokens::AT is not read, then an empty list is returned
     * @info: Not rewindable, if start with Tokens::AT, it is an attribute
     * @verbatim:
     * ```
     * attributes_lst :=  '@' '{' Attribute (Tokens::COMA Attribute)* '}')
     *                   | '@' Attribute ('@' Attribute)*
     * ```
     * @returns:
     *   - .0: the location of the attribute reading (or EOF if nothing read)
     *   - .1: the list of attributes read
     *   - .2: the comments on top of the attribute list
     */
    pub fn readAttributes (mut self)-> (&Word, [AttributeWord], [c8])
        throws ErrorMsg
    {
        // All attributes start with Tokens::AT '@'
        let (next, comm) = self:.readIf (Tokens::AT);
        if (next.isEof) return (EOF_WORD, [], []);

        // List starts with '@' '{
        let (open, _) = self:.readIf (Tokens::LACC);
        let mut vec: [mut AttributeWord] = [];
        loop {
            let (identifier, _) = self:.readTokens (expand Attributes::__members__);

            // Check if already read
            for j in vec if j.attr == identifier {
                throw copy ErrorMsg::fatal (j.loc, end-> identifier, format (SyntaxErrorMessage::MULTIPLE_ATTRS, j.attr));            
            }

            // No need to check wether it exists, it necessarily does, we read it in self:.readTokens
            for id in Attributes::__members__ if id == identifier {
                vec ~= [AttributeWord (identifier, id)];                    
                break;            
            }
            

            // Only one, not a list (not read '{')
            if (open.isEof) {
                // But they can be chained with another '@'
                let (at,_) = self:.readIf (Tokens::AT);
                if (at.isEof) break;
            } else {
                // multiple, either ',' or '}'
                let (close, _) = self:.readTokens (Tokens::COMA, Tokens::RACC);
                if (close.str == Tokens::RACC) break;
            }
        }        

        (next, vec, comm)
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ==================================          DECLARATIONS          ==================================
     * ====================================================================================================
     * ====================================================================================================
     */
    
    /**
     * Read a declaration introduced by the keyword `def`
     * @params:
     *    - loc: the location of the `def` keyword
     *    - comm: the comment above the `def`
     *    
     * @grammar: cf. `DefVisitor`     
     */
    pub fn readDef (mut self, loc: &Word, comm: [c8])-> &Declaration
        throws ErrorMsg
    {
        self._defVisitor.read (alias self, loc, comm);
    }    

    /**
     * Read a class declaration cf. ClassVisitor
     *
     * @params:
     *   - loc:     the token introducing the class
     *   - comm:    the comment on top of the class
     *   - attrs: the list of attributes on top of the class
     *
     * @grammar: cf. `ClassVisitor`
     */
    pub fn readClass (mut self,  loc: &Word, comm: [c8], attrs: [AttributeWord])-> &Declaration
        throws ErrorMsg
    {
        return self._classVisitor.read (alias self, loc, comm, attrs);
    }

    /**
     * Read an union type, introduced by the `union` keyword
     *
     * @params:
     *    - loc: the location of the `union` keyword
     *    - comm: the comment above the union
     *
     * @grammar: cf. `UnionVisitor`
     * 
     * */
    pub fn readUnion (mut self, loc: &Word, comm: [c8])-> &Declaration
        throws ErrorMsg
    {
        return self._unionVisitor.read (alias self, loc, comm, attrs);
    }
    
    /**
     * Read an enumeration definition
     *
     * @params:
     *    - loc: the location of the `enum` keyword
     *    - comm: the comment above the enum
     *
     * @grammar: cf. `EnumVisitor`
     */
    pub fn readEnum (mut self,  loc: &Word, comm: [c8])-> &Declaration
        throws ErrorMsg
    {
        return self._enumVisitor.read (loc, comm);
    }

    /**
     * Read a function definition
     *
     * @params:
     *    - loc: the location of the `fn` keyword
     *    - comm: the comment above the function
     *    - attrs: the list of attributes above the function
     *
     * @grammar: cf. `FunctionVisitor`
     *     
     */
    pub fn readFunction (mut self, loc: &Word, comm: [c8], attrs: [AttributeWord])-> &Declaration
        throws ErrorMsg
    {
        self._functionVisitor.readFunction (loc, comm, attrs);
    }
    
    /**
     * Read a macro declaration
     * 
     * @params:
     *    - loc: the location of the `macro` keyword
     *    - comm: the comment above the macro
     *
     * @grammar: cf. `MacroVisitor`
     */
    pub fn readMacro (mut self,  loc: &Word, comm: [c8])-> &MacroDecl
        throws ErrorMsg
    {
        self._macroVisitor.read (loc, comm);
    }

    /**
     * Read a trait declaration
     *
     * @params:
     *    - loc: the location of the `trait` keyword
     *    - comm: the comment above the trait
     *
     * @grammar: cf. `TraitVisitor`
     */
    pub fn readTrait (mut self,  loc: &Word, comm: [c8])-> &Declaration
        throws ErrorMsg
    {
        self._traitVisitor.read (loc, comm);
    }

    /**
     * Read a unittest declaration
     *
     * @params
     *    - loc: the location of the `__test` keyword
     *    - comm: the comment above the unittest
     *
     * @grammar: cf. `FunctionVisitor`
     */
    pub fn readUnitTest (mut self, loc: &Word, comm: [c8])-> &Declaration
        throws ErrorMsg
    {
        self._functionVisitor.readUnittest (loc, comm);        
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          TEMPLATES          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Read a list of template parameters
     *
     * @grammar:
     * ```
     * TemplateParameters :=
     *    '{' TemplateParameter (',' TemplateParameter)* '}'
     *
     * TemplateParameter :=
     *     TemplateVarDeco Identifier
     *   | TemplateVarParam
     *   | ExpressionSimple(0)
     *
     * TemplateVarDeco :=
     *      'alias'
     *    | 'class'
     *    | 'entity'
     *    | 'tuple'
     *    | 'record'
     *    | 'union'
     *    | 'enum'
     *
     *
     * TemplateVarParam :=
     *      Identifier (':' ExpressionSimple(0))? ('=' ExpressionSimple(0))?
     *    | Identifier ':' '...'
     *    | Identifier '...'
     *    | Identifier TemplateFilter ExpressionSimple(0) ('&&' TemplateFilter ExpressionSimple (0))*
     *    | ExpressionSimple(0)
     * ```
     */
    pub fn readTemplateParameters (mut self, ifLoc: &Word)-> [&Expression]
        throws ErrorMsg
    {        
        let (begin, _) = self:.readIf (Tokens::LACC);            
        if (begin.isEof) { // We don't use readTokens, because we want to check wether the ifLoc is set
            let mut notes: [&ErrorMsg] = [];
            if !ifLoc.isEof { // There's a template test, but no template
                notes = copy [copy ErrorMsg::note (ifLoc, SyntaxErrorMessage::IF_NON_TEMPLATE)];
            } 

            // Expecting a list of template parameters
            throw copy ErrorMsg::fatal (begin, format (SyntaxErrorMessage::UNEXPECTED_BUT_LST, begin.str, Tokens::LACC),
                                        notes-> notes);
        }
        
        // read the template expressions
        let mut vec: [mut &Expression] = [];
        loop {
            let (curr, _) = self:.readToken ();
            match curr.str {
                Keys::ALIAS | Keys::CLASS | Keys::ENTITY | TemplateVarType::TUPLE | Keys::RECORD | Keys::UNION | Keys::ENUM => {
                    let (ident, _) = self:.readIdentifier ();
                    vec ~= [copy TemplateVarExpr (ident, self.toTemplateVarType (curr.str))];
                }
                _ => {
                    self:.rewindToSeek (curr);
                    if curr.isName && curr != Keys::SELF {
                        vec ~= [self:.readTemplateVarParamWithNext ()];
                    } else {
                        vec ~= [self._exprVisitor.readExpressionSimple (alias self)];
                    }
                }
            }

            let (token, _) = self:.readTokens (Tokens::RACC, Tokens::COMA);
            if (token.str == Tokens::RACC) break;
        }

        vec
    }

    /**
     * Read an expression that checks template specialization
     * @verbatim:
     * ===============
     * template_var_decl_with_next :=    Identifier (Tokens::COLON expression:0)? (Tokens::EQUAL expression:0)?
     *                               |  Identifier (Keys::OF | Keys::OVER | Keys::IMPL) expression:0 (Tokens::DAND Identifier (Keys::OF | Keys::OVER | Keys::IMPL) expression:0)?
     *                               |  Identifier (Tokens::COLON)?  Tokens::TDOT
     *                               |  expression:0
     * ===============
     */
    fn readTemplateVarParam (mut self)-> &Expression
        throws ErrorMsg
    {

        let (id, _) = self:.readIfIdentifier ();
        if id.isEof { // All filters, start with an Identifier, but ExpressionSimple(0)
            return self._exprVisitor.readExpressionSimple (0);
        }

        let next = self:.readToken ();
        match next.str {
            Tokens::COLON => {                
                return self:.readTemplateVarValue (id, next);
            }

            Tokens::TDOT => {
                return copy TemplateVariadicVarExpr (id, isValue-> false);   
            }
            Keys::OVER | Keys::OF | Keys::IMPL => {
                return self:.readTemplateVarOf (id, next);
            }
            
            Tokens::EQUAL => {
                let value = self._exprVisitor.readExpressionSimple (0);
                
                return VarDeclExpr (id,
                                    name-> id,
                                    type-> EMPTY_EXPR,
                                    value-> value,
                                    isMutOrDmut-> EOF_WORD,
                                    isLazyOrRef-> EOF_WORD);
            }
            
        }

        self:.rewind ();
        return copy VarExpr (name-> id);
    }

    /**
     * Read a template var value, introduced by the token ':'
     *
     * @params:
     *    - id: the identifier of the variable
     *    - colon: the location of the ':' token
     *
     * @grammar: cf. `self:.readTemplateVarParam`
     * */
    fn readTemplateVarValue (mut self, id: &Word, colon: &Word)-> &Expression
        throws ErrorMsg
    {
        let type = self._expr:.readExpressionSimple (alias self);
        
        let mut value: &Expression = EMPTY_EXPR;
        let hasValue = self:.readIf (Tokens::EQUAL);
        if !has.isEof {
            value = self._expr:.readExpressionSimple (alias self);
        }

        return VarDeclExpr (id,
                            name-> id,
                            type-> type,
                            value-> value,
                            isMutOrDmut-> EOF_WORD,
                            isLazyOrRef-> EOF_WORD);        
    }

    /**
     * Read a template of var filter
     * 
     * @params:
     *    - id: the identifier of the variable being specialized
     *    - filter: the first filter that was read (of, over, impl)
     *
     * @grammar: cf. `self:.readTemplateVarParam`
     * */
    fn readTemplateVarOf (mut self, id: &Word, filter: &Word)-> &Expression
        throws ErrorMsg
    {
        let mut lst: [&TemplateOfVarExpr] = [];
        let mut currFilter: &Word = filter;
        loop {
            let spec = self._expr:.readExpressionSimple (0);
            let kind = self.toTemplateOfVarType (currFilter);
            lst ~= [copy TemplateOfVarExpr (id, spec, kind-> kind)];

            let (hasAnd, _) = self:.readIf (Tokens::DAND);
            if hasAnd.isEof
                break;

            let (nextFilter, _) = self:.readTokens (Keys::OVER, Keys::OF, Keys::IMPL);
            currFilter = nextFilter;
        }

        if lst.len == 1
            return lst [0];

        return copy TemplateAndExpr (id, lst);
    }
        

    /**
     * Read a template test (if any)
     * 
     * @returns:
     *   - the location of the if token, (or eof)
     *   - the test expression, or EmptyExpr
     *
     * @grammar:
     * ```
     * TemplateTest :=
     *    'if' ExpressionSimple(0)
     * ```
     */
    pub fn readTemplateTest (mut self)-> (&Word, &Expression)
        throws ErrorMsg
    {
        let (hasTest, _) = self:.readIf (Keys::IF);
        if hasTest.isEof {
            return (hasTest, EMPTY_EXPR);
        }
        
        (hasTest, self._exprVisitor.readExpressionSimple (alias self))        
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ================================          VAR DECLARATION          =================================
     * ====================================================================================================
     * ====================================================================================================
     */
    
    /**
     * Read a variable modifier. The function normalizes the order of modifiers
     * so that the return tuple always places the evaluation modifier (lazy/ref)
     * first and the mutability modifier (mut/dmut) second, regardless of the
     * order in the source code.
     *
     * @grammar:
     * ```
     * VariableModifier :=
     *   | <empty>
     *   | MutOrDmutKw
     *   | LazyOrRefKw
     *   | MutOrDmutKw LazyOrRefKw
     *   | LazyOrRefKw MutOrDmutKw
     *
     * MutOrDmutKw := 'mut' | 'dmut'
     * LazyOrRefKw := 'lazy' | 'ref'             
     * ```
     *
     * @returns:
     *    - .0: the location of the `lazy` | `ref` keyword or EOF
     *    - .1: the location of the `mut` | `dmut` keyword or EOF
     * */
    pub fn readVariableModifiers (mut self)-> (&Word, &Word) {
        let (isLazyOrRef, _) = self:.readIf (Keys::LAZY, Keys::REF);        
        let (isMutOrDmut, _) = self:.readIf (Keys::MUTABLE, Keys::DMUTABLE);
        
        if (isLazyOrRef.isEof && !isMutOrDmut.isEof) {
            let (retry, _) = self:.readIf (Keys::LAZY, Keys::REF);

            return (retry, isMutOrDmut);
        }

        (isLazyOrRef, isMutOrDmut)
    }        


    /**
     * Read a variable modifier omitting lazy. The function normalizes the order of modifiers
     * so that the return tuple always places the evaluation modifier (lazy/ref)
     * first and the mutability modifier (mut/dmut) second, regardless of the
     * order in the source code.
     *
     * @grammar:
     * ```
     * VariableModifierNoLazy :=
     *   | <empty>
     *   | MutOrDmutKw
     *   | RefKw
     *   | MutOrDmutKw RefKw
     *   | RefKw MutOrDmutKw
     *
     * MutOrDmutKw := 'mut' | 'dmut'
     * RefKw := 'ref'             
     * ```
     *
     * @returns:
     *    - .0: the location of the `ref` keyword or EOF
     *    - .1: the location of the `mut` | `dmut` keyword or EOF
     * */
    pub fn readVariableModifiersNoLazy (mut self)-> (&Word, &Word) {
        let (isLazyOrRef, _) = self:.readIf (Keys::REF);        
        let (isMutOrDmut, _) = self:.readIf (Keys::MUTABLE, Keys::DMUTABLE);
        
        if (isLazyOrRef.isEof && !isMutOrDmut.isEof) {
            let (retry, _) = self:.readIf (Keys::REF);

            return (retry, isMutOrDmut);
        }

        (isLazyOrRef, isMutOrDmut)
    }        
    
    
    // /**
    //  * Read a single var declaration
    //  * @params:
    //  *    - mandType: the type is mandatory
    //  *    - withValue: there can be a value
    //  *    - isClass: self is a valid Identifier
    //  *    - level: the level of the expression (only applicable if withValue)
    //  * @verbatim:
    //  * ==================
    //  * single_var_decl :=   (Decorator)* (Identifier | Keys::UNDER) (Tokens::COLON expression:(10))? (Tokens::EQUAL expression:(level))
    //  *                    | (Decorator)* Keys::SELF
    //  * ==================
    //  */
    // fn readSingleVarDeclaration (mut self, mandType : bool = false, withValue : bool = true, mandValue : bool = false, isClass : bool = false, level : usize = 0us)-> &VarDeclExpr
    //     throws ErrorMsg
    // {
    //     let (isLazyOrRef, isMutOrDmut) = self:.readDecoratorVariable (canBeLazyOrRef-> !isClass);
    //     let (ig, _) = self:.readIf (Keys::UNDER);
    //     let name = if (!ig.isEof) {
    //         ig
    //     } else { self:.readIdentifier ()._0 }

    //     match name {
    //         Keys::SELF => {
    //             if (!isClass) throw copy ErrorMsg::fatal (name, format (SyntaxErrorMessage::USED_AS_IDENTIFIER, name.str));
    //             return copy VarDeclExpr (name, name, isMutOrDmut-> isMutOrDmut, value-> EMPTY_EXPR, type-> EMPTY_EXPR);
    //         }
    //     }


    //     if (isClass) throw copy ErrorMsg::fatal (name, format (SyntaxErrorMessage::UNEXPECTED_BUT_LST, name.str, Keys::SELF));
    //     let type = if (mandType) {
    //         self:.readTokens (Tokens::COLON);
    //         self:.readExpression (level-> self._specials.binaryOperators.len)
    //     } else if (!(self:.readIf (Tokens::COLON)._0).isEof) {
    //         self:.readExpression (level-> self._specials.binaryOperators.len)
    //     } else { EMPTY_EXPR }

    //     let value = if (withValue || mandValue) {
    //         if (mandValue) {
    //             self:.readTokens (Tokens::EQUAL);
    //             self:.readExpression (level-> level)
    //         } else if (!(self:.readIf (Tokens::EQUAL)._0).isEof) {
    //             self:.readExpression (level-> level)
    //         } else { EMPTY_EXPR }
    //     } else { EMPTY_EXPR };

    //     copy VarDeclExpr (name, name, isMutOrDmut-> isMutOrDmut, isLazyOrRef-> isLazyOrRef, value-> value, type-> type)
    // }

    // /*!
    //  * ================================================================================
    //  * ================================================================================
    //  * =========================            BLOCKS            =========================
    //  * ================================================================================
    //  * ================================================================================
    //  */

    // /**
    //  * Read a block of code
    //  * @verbatim:
    //  * ====================
    //  * block := Tokens::LACC ((n=expression:(0) (Tokens::SEMI_COLON)!if(self:.needClosingExpr (n))* (expression:(0))?) Tokens::RACC (scope_guards)?
    //  * ====================
    //  */
    // fn readBlock (mut self, loc : &Word, canBeCatcher : bool = true)-> &Expression
    //     throws ErrorMsg
    // {
    //     let mut decls : [mut &Declaration] = [];
    //     let mut content : [mut &Expression] = [];
    //     {
    //         let mut end = EOF_WORD;
    //         let mut last = false;
    //         loop {
    //             end = self:.readIf (Tokens::SEMI_COLON, Tokens::RACC)._0;
    //             if (end.isEof) {
    //                 if (!last && content.len != 0us) {
    //                     if (self.needClosingExpr (content [$ - 1us])) {
    //                         let (n, _) = self:.readToken ();
    //                         throw copy ErrorMsg::fatal (n, format (SyntaxErrorMessage::UNEXPECTED_BUT_LST, n.str, Tokens::SEMI_COLON));
    //                     }
    //                 }
                    
    //                 if self._globalVisitor.isLocalDeclaration (self) {
    //                     let d = self._globalVisitor.readLocalDeclaration (alias self);
    //                     decls ~= [d];
    //                     last = true;
    //                 } else {
    //                     let e = self:.readExpression ();
    //                     content ~= [e];
    //                     last = false;
    //                 }                                                                                                
    //             } else if (end == Tokens::SEMI_COLON) {
    //                 last = true;
    //             } else break;
    //         }

    //         let (catcher, scopes) = if (canBeCatcher) {
    //             self:.readScopeGuards ()
    //         } else { (EMPTY_EXPR, []) }

    //         if (last) content ~= [copy EmptyExpression (loc-> end)];
    //         if (decls.len != 0us) {
    //             copy BlockExpr (loc, end, module-> copy BlockDecl (loc.locate (Keys::UNDER), "", decls), content, catcher-> catcher, guards-> scopes)
    //         } else {
    //             copy BlockExpr (loc, end, content, catcher-> catcher, guards-> scopes)
    //         }
    //     } catch {
    //         err : &ErrorMsg => {
    //             if (!loc.isEof) {
    //                 throw copy ErrorMsg::note (loc, SyntaxErrorMessage::IN_DECL_BLOCK, notes-> copy [err]);
    //             } else throw err;
    //         }
    //     }
    // }


    // /**
    //  * Read scope guards
    //  * @verbatim:
    //  * ==================
    //  * scope_guards :=   Keys::EXIT block
    //  *                 | Keys::SUCCESS block
    //  *                 | Keys::FAILURE block
    //  *                 | catcher
    //  * ==================
    //  */
    // fn readScopeGuards (mut self)-> (&Expression, [&ScopeGuardExpr])
    //     throws ErrorMsg
    // {
    //     let mut catcher : &Expression = EMPTY_EXPR;
    //     let mut scopes : [mut &ScopeGuardExpr] = [];
    //     let mut seen : [[c8] => mut &Word] = copy [];
    //     loop {
    //         let (n, _) = self:.readIf (Keys::EXIT, Keys::SUCCESS, Keys::FAILURE, Keys::CATCH);
    //         if (!n.isEof) {
    //             if let Ok (val) = seen [n.str] {
    //                 throw copy ErrorMsg::fatal (n, end-> val, format (SyntaxErrorMessage::MULTIPLE_SAME_GUARD, n.str));
    //             }

    //             seen [n.str] = n;
    //         }

    //         if (n == Keys::CATCH) {
    //             catcher = self:.readCatcher (n);
    //         } else if (!n.isEof) {
    //             let (a, _) = self:.readTokens (Tokens::LACC);
    //             scopes ~= [copy ScopeGuardExpr (n, self:.readBlock (a, canBeCatcher-> false), kind-> self.toScopeGuard (n.str))];
    //         } else break;
    //     }

    //     (catcher, scopes)
    // }

    // /*!
    //  * ================================================================================
    //  * ================================================================================
    //  * =========================          CONDITIONS          =========================
    //  * ================================================================================
    //  * ================================================================================
    //  */

    // /**
    //  * Read an If expression
    //  * @verbatim:
    //  * ======================
    //  * if_expr := Keys::IF expression:(0) ((expression:(0) (Tokens::SEMI_COLON)?) | (block)) (Keys::ELSE expression:(0))?
    //  * ======================
    //  */
    // fn readIfExpression (mut self, loc : &Word)-> &Expression
    //     throws ErrorMsg
    // {
    //     let (isLet, _) = self:.readIf (Keys::LET);
    //     let (test : &Expression, guard : &Expression) = if (isLet.isEof) {
    //         (self:.readExpression (), EMPTY_EXPR)
    //     } else {
    //         let vdecl = self:.readVarDeclaration (isLet, onlyOne-> true, level-> 3us);
    //         let guard = if (!self:.readIf (Tokens::DAND)._0.isEof) {
    //             self:.readExpression ()
    //         } else { EMPTY_EXPR };

    //         (vdecl, guard)
    //     };

    //     let mut content = self:.readExpression ();
    //     match content {
    //         BlockExpr () => {}
    //         _ => {
    //             let (tok, _) = self:.readIf (Tokens::SEMI_COLON);
    //             if (!tok.isEof) {
    //                 let mut inner = copy [content, EMPTY_EXPR];
    //                 content = copy BlockExpr (content.getLoc (), tok, content-> inner);
    //             }
    //         }
    //     }

    //     let (next, _) = self:.readIf (Keys::ELSE);
    //     if (!next.isEof) {
    //         let (n, _) = self:.readIf (Keys::IF);
    //         if (!n.isEof) return copy ConditionalExpr (loc, test, content, else_-> self:.readIfExpression (n), guard-> guard, isLet-> !isLet.isEof);
    //         else {
    //             let mut el_content = self:.readExpression ();
    //             match el_content {
    //                 BlockExpr () => {}
    //                 _ => {
    //                     let (tok, _) = self:.readIf (Tokens::SEMI_COLON);
    //                     if (!tok.isEof) {
    //                         let mut inner : [mut &Expression] = copy [el_content, EMPTY_EXPR];
    //                         el_content = copy BlockExpr (content.getLoc (), tok, content-> inner);
    //                     }
    //                 }
    //             }

    //             return copy ConditionalExpr (loc, test, content, else_-> el_content, isLet-> !isLet.isEof, guard-> guard);
    //         }
    //     }

    //     copy ConditionalExpr (loc, test, content, isLet-> !isLet.isEof, guard-> guard)
    // }


    // /**
    //  * Read an atomic
    //  * @verbatim:
    //  * ==============
    //  * atomic_expr := Keys::ATOMIC (expression:(0))? Tokens::LACC expression:(0) Tokens::RACC
    //  * ==============
    //  */
    // fn readAtomic (mut self, loc : &Word) -> &Expression
    //     throws ErrorMsg
    // {
    //     let (n, _) = self:.readIf (Tokens::LACC);
    //     if (!n.isEof) {
    //         let content = self:.readBlock (n);
    //         return copy AtomicExpr (loc, content, monitor-> EMPTY_EXPR);
    //     } else {
    //         let monitor = self:.readExpression ();
    //         let (tok, _) = self:.readTokens (Tokens::LACC);
    //         let content = self:.readBlock (tok, canBeCatcher-> false);
    //         return copy AtomicExpr (loc, content, monitor-> monitor);
    //     }
    // }

    // /**
    //  * Read an unsafe block
    //  * @verbatim:
    //  * ==========
    //  * unsafe_expr := Keys::UNSAFE Tokens::LACC expression:(0) Tokens::RACC
    //  * ==========
    //  * */
    // fn readUnsafe (mut self, loc : &Word)-> &Expression
    //     throws ErrorMsg
    // {
    //     let content = self:.readExpression ();
    //     return copy UnsafeExpr (loc, content);
    // }

    // /**
    //  * Read a pragma expr
    //  * @verbatim:
    //  * ===================
    //  * pragma_expr := Keys::PRAGMA Tokens::NOT Identifier (Tokens::LPAR param_list Tokens::RPAR)
    //  * ===================
    //  */
    // fn readPragma (mut self, _ : &Word)-> &Expression
    //     throws ErrorMsg
    // {
    //     self:.readIf (Tokens::NOT);
    //     let (ident, _) = self:.readIdentifier ();

    //     self:.readTokens (Tokens::LPAR);
    //     let (params, _) = self:.readArgumentList ();

    //     copy PragmaExpr (ident, params)
    // }

    // /**
    //  * Read a throw expression
    //  * @verbatim:
    //  * =======================
    //  * throw_expr := Keys::THROW expression:(0)
    //  * =======================
    //  */
    // fn readThrow (mut self, loc : &Word)-> &Expression
    //     throws ErrorMsg
    // {
    //     let expr = self:.readExpression ();
    //     copy ThrowExpr (loc, expr)
    // }

    // /**
    //  * Read a panic instruction
    //  * @verbatim:
    //  * =======================
    //  * panic := Keys::PANIC
    //  * =======================
    //  * */
    // fn readPanic (mut self, loc : &Word)-> &Expression {
    //     copy PanicExpr (loc)
    // }

    // /**
    //  * Read a version evaluation expression
    //  * @verbatim:
    //  * ```
    //  * version_lit := Keys::VERSION '(' Identifier ')'
    //  * ```
    //  * */
    // fn readVersion (mut self, loc : &Word)-> &Expression
    //     throws ErrorMsg
    // {
    //     self:.readTokens (Tokens::LPAR);
    //     let (version, _) = self:.readIdentifier ();
    //     self:.readTokens (Tokens::RPAR);
        
    //     copy VersionExpr (loc, version)
    // }

    // /**
    //  * Read a function type
    //  * @verbatim:
    //  * ====================
    //  * function_type := (Keys::FUNCTION | Keys::DG) function_type_prototype function_type_return_type
    //  * function_type_prototype := Tokens::LPAR (expression:(10) (Tokens::COMA expression:(10))*) Tokens::RPAR
    //  * function_type_return_type := (Tokens::ARROW expression:(10))?
    //  * ====================
    //  */
    // fn readFunctionType (mut self, loc : &Word)-> &Expression
    //     throws ErrorMsg
    // {
    //     self:.readTokens (Tokens::LPAR);
    //     let args = self:.readFptrParameters ();
    //     let (t, _) = self:.readIf (Tokens::ARROW);
    //     if (!t.isEof) {
    //         copy FunctionPtrTypeExpr (loc, args, self:.readExpression (level-> self._specials.binaryOperators.len))
    //     } else {
    //         copy FunctionPtrTypeExpr (loc, args, EMPTY_EXPR)
    //     }
    // }

    // /**
    //  * Read a future type
    //  * @verbatim
    //  * ============
    //  * future_type := Keys::FUTURE Tokens::ARROW operand:(3)
    //  * ============
    //  * */
    // fn readFutureType (mut self, loc : &Word)-> &Expression
    //     throws ErrorMsg
    // {
    //     self:.readTokens (Tokens::ARROW);
    //     let param = self:.readOperand3 ();

    //     copy FutureTypeExpr (loc, param)
    // }

    // /**
    //  * Read the parameters of a function pointer type
    //  * */
    // fn readFptrParameters (mut self)-> [&VarDeclExpr]
    //     throws ErrorMsg
    // {
    //     let x = self:.readIf (Tokens::RPAR)._0;
    //     if (!x.isEof) return [];

    //     let mut params : [mut &VarDeclExpr] = [];
    //     loop {
    //         let (isLazyOrRef, isMutOrDmut) = self:.readDecoratorVariable (canBeLazyOrRef-> true);

    //         let type = self:.readExpression (level-> self._specials.binaryOperators.len);
    //         let name = type.getLoc ().locate (Keys::UNDER);
    //         params ~= [copy VarDeclExpr (name, name,
    //                                      isLazyOrRef-> isLazyOrRef,
    //                                      isMutOrDmut-> isMutOrDmut,
    //                                      type-> type,
    //                                      value-> EMPTY_EXPR)];

    //         let (next, _) = self:.readTokens (Tokens::RPAR, Tokens::COMA);
    //         if (next == Tokens::RPAR) break;
    //     }

    //     params
    // }

    // /**
    //  * Read a return expression
    //  * @verbatim:
    //  * ========================
    //  * return_expr := Keys::RETURN ( expression:(0) | ';' )
    //  * ========================
    //  */
    // fn readReturn (mut self, loc : &Word)-> &Expression
    //     throws ErrorMsg
    // {
    //     let (semiCol, _) = self:.readIf (Tokens::SEMI_COLON);
    //     if (!semiCol.isEof) {
    //         copy ReturnExpr (loc, EMPTY_EXPR)
    //     } else {
    //         let expr = self:.readExpression ();
    //         copy ReturnExpr (loc, expr)
    //     }
    // }

    // /**
    //  * Read a var declaration
    //  * @verbatim:
    //  * ========================
    //  * var_decl :=   Keys::LET (single_var_decl Tokens::EQUAL value) (Tokens::COMA (single_var_decl Tokens::EQUAL value))*
    //  *             | Keys::LET pattern Tokens::EQUAL value
    //  * ========================
    //  */
    // fn readVarDeclaration (mut self, loc : &Word, onlyOne : bool = false, level : usize = 0us)-> &Expression
    //     throws ErrorMsg
    // {
    //     let begCursor = self.getSeek ();
    //     let mut succeed = false;
    //     let (tok, _) = self:.readIf (Tokens::LPAR, Tokens::LCRO);
    //     if (tok == Tokens::LPAR || tok == Tokens::LCRO) {
    //         let pattern = self:.readParMatch (tok, endTok-> if (tok == Tokens::LPAR) { Tokens::RPAR } else { Tokens::RCRO });
    //         self:.readTokens (Tokens::EQUAL);
    //         let value = self:.readExpression (level-> level);

    //         return copy PatternVarDeclExpr (loc, pattern, value);
    //     } else {
    //         {
    //             let mut decls : [mut &Expression] = [];
    //             loop {
    //                 decls ~= [self:.readSingleVarDeclaration (mandType-> false, isClass-> false, mandValue-> true, level-> level)];
    //                 succeed = true; // read at least one
    //                 if (!onlyOne) {
    //                     if ((self:.readIf (Tokens::COMA)._0).isEof) break;
    //                 } else break;
    //             }

    //             if (decls.len == 1) return decls [0];
    //             return copy SetExpr (loc, decls);
    //         } catch {
    //             err : &ErrorMsg => {
    //                 if (succeed) throw err; // pattern var decl cannot be grouped with other kind of declarations
    //                 {
    //                     self:.rewindToSeek (begCursor);
    //                     let pattern = self:.readMatchExpression ();

    //                     self:.readTokens (Tokens::EQUAL);
    //                     let value = self:.readExpression (level-> level);

    //                     return copy PatternVarDeclExpr (loc, pattern, value);
    //                 } catch {
    //                     subErr : &ErrorMsg => {
    //                         throw err.withNote (copy [copy ErrorMsg::note (loc, oneLine-> true, SyntaxErrorMessage::READING_PATTERN_DECLARATION, notes-> copy [subErr])]);
    //                     }
    //                 }
    //             }
    //         }
    //     }
    // }

    // /**
    //  * Read a for loop
    //  * @verbatim:
    //  * ===========================
    //  * for_loop := Keys::FOR ((Tokens::LPAR for_loop_decl Tokens::RPAR) | for_loop_decl) expression:(0)
    //  * for_loop_decl := (single_var_decl:(no_value) (Tokens::COMA single_var_decl:(no_value))* Keys::IN expression:(10)
    //  * ===========================
    //  */
    // fn readFor (mut self, loc : &Word)-> &Expression
    //     throws ErrorMsg
    // {
    //     let mut decls : [mut &Expression] = [];
    //     let (par, _) = self:.readIf (Tokens::LPAR);
    //     loop {
    //         decls ~= [self:.readSingleVarDeclaration (mandType-> false, withValue-> false)];
    //         let (n, _) = self:.readTokens (Tokens::COMA, Keys::IN);
    //         if (n == Keys::IN) break;
    //     }

    //     let iter = self:.readExpression ();
    //     if (!par.isEof) self:.readTokens (Tokens::RPAR);

    //     let mut content = self:.readExpression ();
    //     match content {
    //         BlockExpr () => {}
    //         _ => {
    //             let (n, _) = self:.readIf (Tokens::SEMI_COLON);
    //             if (!n.isEof) {
    //                 let inner = copy [content, EMPTY_EXPR];
    //                 content = copy BlockExpr (content.getLoc (), n, inner);
    //             }
    //         }
    //     }

    //     copy ForLoopExpr (loc, decls, iter, content)
    // }


    // /**
    //  * Read a do while loop
    //  * @verbatim:
    //  * =====================
    //  * =====================
    //  */
    // fn readDoWhile (mut self, loc : &Word) -> &Expression
    //     throws ErrorMsg
    // {
    //     let content = self:.readExpression ();
    //     self:.readTokens (Keys::WHILE);
    //     let test = self:.readExpression ();

    //     copy WhileLoopExpr (loc, test-> test, content, isDo-> true)
    // }

    // /**
    //  * Read a break expression
    //  * @verbatim:
    //  * =======================
    //  * break_expr := Keys::BREAK ( expression:(0) | ';' )
    //  * =======================
    //  */
    // fn readBreak (mut self, loc : &Word)-> &Expression
    //     throws ErrorMsg
    // {
    //     let (semiCol, _) = self:.readIf (Tokens::SEMI_COLON);
    //     if (!semiCol.isEof) {
    //         copy BreakExpr (loc, EMPTY_EXPR)
    //     } else {
    //         let expr = self:.readExpression ();
    //         copy BreakExpr (loc, expr)
    //     }
    // }


    // /**
    //  * Read an assert expression
    //  * @verbatim:
    //  * ==========================
    //  * assert_expr := Keys::ASSERT Tokens::LPAR expression:(0) (Tokens::COMA expression:(0))? Tokens::RPAR
    //  * ==========================
    //  */
    // fn readAssert (mut self, tok : &Word)-> &Expression
    //     throws ErrorMsg
    // {
    //     let _ = self:.readTokens (Tokens::LPAR);
    //     let test = self:.readExpression ();
    //     let (n, _) = self:.readTokens (Tokens::RPAR, Tokens::COMA);
    //     let msg = if (n == Tokens::COMA) {
    //         let exp = self:.readExpression ();
    //         self:.readTokens (Tokens::RPAR);
    //         exp
    //     } else {
    //         EMPTY_EXPR
    //     }
    //     self:.readTokens (Tokens::SEMI_COLON);
    //     self:.rewind ();

    //     copy AssertExpr (tok, test, msg)
    // }

    // /**
    //  * Read a loop expression
    //  * @verbatim:
    //  * =========================
    //  * loop_expr := Keys::LOOP expression:(0)
    //  * =========================
    //  */
    // fn readLoop (mut self, loc : &Word)-> &Expression
    //     throws ErrorMsg
    // {
    //     let mut content = self:.readExpression ();
    //     match content {
    //         BlockExpr () => {}
    //         _ => {
    //             let (n, _) = self:.readIf (Tokens::SEMI_COLON);
    //             if (!n.isEof) {
    //                 let inner = copy [content, EMPTY_EXPR];
    //                 content = copy BlockExpr (content.getLoc (), n, inner);
    //             }
    //         }
    //     }

    //     copy WhileLoopExpr (loc, content, isDo-> false)
    // }


    // /**
    //  * Read a while loop
    //  * @verbatim:
    //  * ===========================
    //  * while_expr := Keys::WHILE expression:(0) expression:(0)
    //  * ===========================
    //  */
    // fn readWhile (mut self, loc : &Word)-> &Expression
    //     throws ErrorMsg
    // {

    //     let (isLet, _) = self:.readIf (Keys::LET);
    //     let (test : &Expression, guard : &Expression) = if (isLet.isEof) {
    //         (self:.readExpression (), EMPTY_EXPR)
    //     } else {
    //         let vdecl = self:.readVarDeclaration (isLet, onlyOne-> true, level-> 3us);
    //         let guard = if (!self:.readIf (Tokens::DAND)._0.isEof) {
    //             self:.readExpression ()
    //         } else { EMPTY_EXPR };

    //         (vdecl, guard)
    //     };

    //     let mut content = self:.readExpression ();
    //     match content {
    //         BlockExpr () => {}
    //         _ => {
    //             let (n, _) = self:.readIf (Tokens::SEMI_COLON);
    //             if (!n.isEof) {
    //                 let inner = copy [content, EMPTY_EXPR];
    //                 content = copy BlockExpr (content.getLoc (), n, inner);
    //             }
    //         }
    //     }

    //     if (isLet.isEof) {
    //         copy WhileLoopExpr (loc, test-> test, content, isDo-> false)
    //     } else {
    //         let elseBr = copy BreakExpr (loc, EMPTY_EXPR);
    //         let innerCond = copy ConditionalExpr (loc, test, content, else_-> elseBr, isLet-> true, guard-> guard);
    //         copy WhileLoopExpr (loc, innerCond, isDo-> false)
    //     }
    // }

    // /**
    //  * Read a template call expr
    //  * @verbatim:
    //  * ===========================
    //  * template_call_expr := expression:(0) Tokens::NOT ((Tokens::LACC param_list Tokens::RACC) | operand:(3))
    //  * ===========================
    //  */
    // fn readTemplateCall (mut self, var : &Expression)-> &Expression
    //     throws ErrorMsg
    // {
    //     let (n, _) = self:.readIf (Tokens::NOT);
    //     if (!self._inTemplateCall && n == Tokens::NOT) {          
    //         let (n2, _) = self:.readIf (Tokens::LACC);
    //         let res = self._inTemplateCall;
    //         {
    //             if (!n2.isEof) {
    //                 self._inTemplateCall = false;
    //                 let (lst, _) = self:.readArgumentList (withNamed-> false, closing-> Tokens::RACC);
    //                 self._inTemplateCall = res;

    //                 return copy TemplateCallExpr (n, var, lst);
    //             } else {
    //                 self._inTemplateCall = true;
    //                 let lst = copy [self:.readOperand3 ()];
    //                 self._inTemplateCall = res;

    //                 return copy TemplateCallExpr (n, var, lst);
    //             }
    //         } catch {
    //             err : &ErrorMsg => {
    //                 self._inTemplateCall = res;
    //                 throw err;
    //             }
    //         }
    //     } else if (n == Tokens::NOT) {
    //         throw copy ErrorMsg::fatal (n, SyntaxErrorMessage::MISSING_TEMPLATE_ACC);
    //     }

    //     var
    // }

    // /**
    //  * Read a variable
    //  * @verbatim:
    //  * ===================
    //  * var := Identifier (template_call)?
    //  * ===================
    //  */
    // fn readVar (mut self, name : &Word, canBeTemplateCall : bool = true)-> &Expression
    //     throws ErrorMsg
    // {        
    //     if (canBeTemplateCall) {
    //         self:.readTemplateCall (copy VarExpr (name))
    //     } else {
    //         copy VarExpr (name)
    //     }
    // }

    // /**
    //  * Read a lambda expression
    //  * @verbatim:
    //  * ========================
    //  * lambda_expr := function_proto:(lambda) (Tokens::DARROW)? expression:(0)
    //  * ========================
    //  */
    // fn readLambda (mut self, loc : &Word)-> &Expression
    //     throws ErrorMsg
    // {
    //     self:.rewind ();
    //     let proto = self:.readFunctionPrototype (isClosure-> true, isClass-> false);
    //     self:.readIf (Tokens::DARROW);
    //     copy LambdaValueExpr (loc, proto, self:.readExpression ())
    // }


    // /**
    //  * Read a tuple expression
    //  * @verbatim:
    //  * ========================
    //  * param_expr := Tokens::LPAR (expression:(0) (Tokens::COMA | (Tokens::COMA expression:(0))*))? Tokens::RPAR
    //  * ========================
    //  */
    // fn readTuple (mut self, loc : &Word)-> &Expression
    //     throws ErrorMsg
    // {
    //     let mut end = self:.readIf (Tokens::RPAR)._0;
    //     if (end == Tokens::RPAR) { return copy ListExpr (loc, end, []); }

    //     let mut params : [mut &Expression] = copy [self:.readExpression ()];
    //     let (n, _) = self:.readTokens (Tokens::COMA, Tokens::RPAR, Keys::FOR);
    //     if (n == Keys::FOR) {
    //         let forLoc = n;
    //         let mut decls : [mut &Expression] = [];
    //         let (par, _) = self:.readIf (Tokens::LPAR);
    //         loop {
    //             decls ~= [self:.readSingleVarDeclaration (mandType-> false, withValue-> false)];
    //             let (n2, _) = self:.readTokens (Tokens::COMA, Keys::IN);
    //             if (n2 == Keys::IN) break;
    //         }

    //         let iter = self:.readExpression ();
    //         if (!par.isEof) self:.readTokens (Tokens::RPAR);
    //         self:.readTokens (Tokens::COMA);
    //         self:.readTokens (Tokens::RPAR);

    //         return copy SliceForAllocatorExpr (loc, forLoc, params [0], decls, iter, isTuple-> true);
    //     } else if (n == Tokens::COMA) {
    //         end = self:.readIf (Tokens::RPAR)._0;
    //         if (end.isEof) {
    //             loop {
    //                 params ~= [self:.readExpression ()];
    //                 end = self:.readTokens (Tokens::COMA, Tokens::RPAR)._0;
    //                 if (end == Tokens::RPAR) break;
    //             }

    //             return copy ListExpr (loc, end, params);
    //         } else {
    //             return copy ListExpr (loc, end, params);
    //         }
    //     }

    //     params [0]
    // }


    // /**
    //  * Read a template checker expr
    //  * @verbatim:
    //  * ============================
    //  * template_check := Keys::IS template_call template_param_list
    //  * ============================
    //  */
    // fn readTemplateChecker (mut self, loc : &Word)-> &Expression
    //     throws ErrorMsg
    // {
    //     let call = self:.readTemplateCall (copy VarExpr (loc));
    //     match call {
    //         t : &TemplateCallExpr => {
    //             let params = self:.readTemplateParameters (ifLoc-> EOF_WORD);
    //             copy TemplateCheckerExpr (loc, t.getRights (), params)
    //         }
    //         _ => {
    //             self:.readTokens (Tokens::NOT);
    //             EMPTY_EXPR
    //         }
    //     }
    // }

    // /**
    //  * Read a cast expression
    //  * @verbatim:
    //  * =======================
    //  * cast_expr := Keys::CAST Tokens::NOT ((Tokens::LACC expression:(0) Tokens::RACC) | (operand:(3)) (Tokens::LPAR expression:(0) Tokens::RPAR)
    //  * =======================
    //  */
    // fn readCast (mut self, loc : &Word)-> &Expression
    //     throws ErrorMsg
    // {
    //     self:.readTokens (Tokens::NOT);
    //     let type = if (!(self:.readIf (Tokens::LACC)._0).isEof) {
    //         let e = self:.readExpression ();
    //         self:.readTokens (Tokens::RACC);
    //         e
    //     } else {
    //         self:.readOperand3 ()
    //     }

    //     self:.readTokens (Tokens::LPAR);
    //     let inner = self:.readExpression ();
    //     self:.readTokens (Tokens::RPAR);

    //     copy CastExpr (loc, type, inner)
    // }


    // /*!
    //  * ================================================================================
    //  * ================================================================================
    //  * =========================           MATCHERS           =========================
    //  * ================================================================================
    //  * ================================================================================
    //  */

    // /**
    //  * Read a catcher expression
    //  * @verbatim:
    //  * =========================
    //  * =========================
    //  */
    // fn readCatcher (mut self, loc : &Word)-> &Expression
    //     throws ErrorMsg
    // {
    //     let mut matchers : [mut (&Expression, &Expression, &Expression)] = [];
    //     self:.readTokens (Tokens::LACC);
    //     loop {
    //         let e = self:.readMatchExpression ();
    //         let (cd, _) = self:.readTokens (Keys::IF, Tokens::DARROW);
    //         let condition = if (cd == Keys::IF) {
    //             let x = self:.readExpression (level-> 1us);
    //             self:.readTokens (Tokens::DARROW);
    //             x
    //         } else {
    //             EMPTY_EXPR
    //         };

    //         let mut a = self:.readExpression(level-> self._specials.binaryOperators.len);
    //         let (tok, _) = self:.readIf (Tokens::SEMI_COLON);
    //         if (!tok.isEof) {
    //             let inner = copy [a, EMPTY_EXPR];
    //             a = copy BlockExpr (a.getLoc (), tok, content-> inner);
    //         }

    //         matchers ~= [(e, condition, a)];
    //         if (!(self:.readIf (Tokens::RACC)._0).isEof) break;
    //     }

    //     copy MatcherExpr (loc, EMPTY_EXPR, matchers, isCatcher-> true)
    // }

    // /**
    //  * Read a match expression
    //  * @verbatim:
    //  * ========================
    //  * match_expr := Keys::MATCH expression:(0) Tokens::LACC (inner_matcher_expr Tokens::DARROW expression:(10))+ Tokens::RACC
    //  * ========================
    //  */
    // fn readMatch (mut self, loc : &Word)-> &Expression
    //     throws ErrorMsg
    // {
    //     let mut matchers : [mut (&Expression, &Expression, &Expression)] = [];
    //     let content = self:.readExpression ();
    //     self:.readTokens (Tokens::LACC);
    //     loop {
    //         let e = self:.readMatchExpression ();
    //         let (cd, _) = self:.readTokens (Keys::IF, Tokens::DARROW);
    //         let condition = if (cd == Keys::IF) {
    //             let x = self:.readExpression (level-> 1us);
    //             self:.readTokens (Tokens::DARROW);
    //             x
    //         } else {
    //             EMPTY_EXPR
    //         };

    //         let mut a = self:.readExpression(level-> self._specials.binaryOperators.len);
    //         let (tok, _) = self:.readIf (Tokens::SEMI_COLON);
    //         if (!tok.isEof) {
    //             let inner = copy [a, EMPTY_EXPR];
    //             a = copy BlockExpr (a.getLoc (), tok, content-> inner);
    //         }

    //         matchers ~= [(e, condition, a)];
    //         if (!(self:.readIf (Tokens::RACC)._0).isEof) break;
    //     }

    //     copy MatcherExpr (loc, content, matchers, isCatcher-> false)
    // }

    // /**
    //  * Read an matching expression
    //  * @verbatim:
    //  * ============================
    //  * inner_matcher_expr :=   single_var_decl_match
    //  *                       | calling_match
    //  *                       | par_match
    //  *                       | cro_match
    //  *                       | expression:(0)
    //  * ============================
    //  */
    // fn readMatchExpression (mut self)-> &Expression
    //     throws ErrorMsg
    // {
    //     let (n, _) = self:.readIf (Tokens::LPAR, Tokens::LCRO);
    //     if (n == Tokens::LPAR) {
    //         return self:.readParMatch (n, endTok-> Tokens::RPAR);
    //     } else if (n == Tokens::LCRO) {
    //         return self:.readParMatch (n, endTok-> Tokens::RCRO);
    //     } else {
    //         return self:.readSingleVarDeclarationForMatch ();
    //     }
    // }

    // /**
    //  * Read a single var declaration for a pattern matcher
    //  * @params:
    //  *   - empty: allows for var to have no type nor value
    //  * @verbatim:
    //  * ========================
    //  * single_var_decl_match := (Decorator)* (Identifier | Keys::UNDER) Tokens::COLON (Keys::UNDER | expression:(10))  (Tokens::EQUAL inner_matcher_expr)?
    //  * ========================
    //  */
    // fn readSingleVarDeclarationForMatch (mut self)-> &Expression
    //     throws ErrorMsg
    // {
    //     let (isLazyOrRef, isMutOrDmut) = self:.readDecoratorVariable (canBeLazyOrRef-> true);
    //     if (isLazyOrRef == Keys::LAZY) {
    //         throw copy ErrorMsg::fatal (isLazyOrRef, format (SyntaxErrorMessage::UNDEF_DECORATOR_IN_MATCH, isLazyOrRef.str));
    //     }

    //     let (ig, _) = self:.readIf (Keys::UNDER);
    //     let name = if (!ig.isEof) {
    //         ig
    //     } else if (!isLazyOrRef.isEof || !isMutOrDmut.isEof) {
    //         self:.readIdentifier ()._0
    //     } else {
    //         self:.readIfIdentifier ()._0
    //     };

    //     // No identifier means no mut/lazy ident, thus it is an expression
    //     if (name.isEof) return self:.readExpression (level-> 4us);

    //     // cannot use /self/
    //     else if (name == Keys::SELF) throw copy ErrorMsg::fatal (name, format (SyntaxErrorMessage::USED_AS_IDENTIFIER, name.str));

    //     // Option pattern-> /Ok (...), Err (...)/
    //     else if (name == OptionKeys::MATCH_SOME || name == OptionKeys::MATCH_NONE) {
    //         // dmut Ok (...) means nothing
    //         if (isLazyOrRef != EOF_WORD) throw copy ErrorMsg::fatal (isLazyOrRef, format (SyntaxErrorMessage::UNEXPECTED, isLazyOrRef));
    //         if (isMutOrDmut != EOF_WORD) throw copy ErrorMsg::fatal (isMutOrDmut, format (SyntaxErrorMessage::UNEXPECTED, isMutOrDmut));

    //         return self:.readOptionMatch (name);
    //     }

    //     let (tok, _) = self:.readIf (Tokens::COLON, Tokens::EQUAL, Tokens::LPAR, Tokens::NOT, Tokens::DCOLON);

    //     // Type pattern-> /(ident | _ | ident::ident... | ident!templates...) (...)/
    //     if (tok == Tokens::LPAR || tok == Tokens::NOT || tok == Tokens::DCOLON) {
    //         // dmut Type (fields...) means nothing, cannot dmut the type test

    //         if (isLazyOrRef != EOF_WORD) throw copy ErrorMsg::fatal (isLazyOrRef, format (SyntaxErrorMessage::UNEXPECTED, isLazyOrRef));
    //         if (isMutOrDmut != EOF_WORD) throw copy ErrorMsg::fatal (isMutOrDmut, format (SyntaxErrorMessage::UNEXPECTED, isMutOrDmut));

    //         self:.rewind ();
    //         return self:.readCallingMatch (name);
    //     }

    //     // var decl with a type -> /decos ident : Type = Value/
    //     else if (tok == Tokens::COLON) {
    //         let type = if ((self:.readIf (Keys::UNDER)._0).isEof) {
    //             self:.readExpression (level-> self._specials.binaryOperators.len)
    //         } else { EMPTY_EXPR }

    //         // With a value
    //         let value = if (!(self:.readIf (Tokens::EQUAL)._0).isEof) {
    //             self:.readMatchExpression ()
    //         } else { EMPTY_EXPR }

    //         return copy VarDeclExpr (name, name, isMutOrDmut-> isMutOrDmut, isLazyOrRef-> isLazyOrRef, value-> value, type-> type);
    //     }

    //     // var decl with a value but not type -> /decos ident = Value/
    //     else if (tok == Tokens::EQUAL) {
    //         return copy VarDeclExpr (name, name, isMutOrDmut-> isMutOrDmut, isLazyOrRef-> isLazyOrRef,
    //                                  value-> self:.readMatchExpression (),
    //                                  type-> EMPTY_EXPR);
    //     }

    //     // var decl with no type and no value, just an identifier (or even just /_/)
    //     else  {
    //         if (name != Keys::UNDER && isMutOrDmut.isEof && isLazyOrRef.isEof) {
    //             self:.rewind ();
    //             let content = self:.readExpression (level-> self._specials.binaryOperators.len);
    //             match content {
    //                 v : &VarExpr => {
    //                     return copy VarDeclExpr (v.getLoc (), v.getLoc (), isMutOrDmut-> isMutOrDmut, isLazyOrRef-> isLazyOrRef,
    //                                              value-> EMPTY_EXPR,
    //                                              type-> EMPTY_EXPR);
    //                 }
    //                 _ => return content;
    //             }
    //         } else {
    //             return copy VarDeclExpr (name, name, isMutOrDmut-> isMutOrDmut, isLazyOrRef-> isLazyOrRef,
    //                                      value-> EMPTY_EXPR,
    //                                      type-> EMPTY_EXPR);
    //         }
    //     }
    // }


    // /**
    //  * Read a calling match expression
    //  * @verbatim:
    //  * ===============================
    //  * calling_match :=   (Identifier | Keys::UNDER) (Tokens::DCOLON Identifier)* (template_call)? (Tokens::LPAR (ident Tokens::ARROW inner_matcher_expr (',' ident Tokens::ARROW inner_matcher_expr)*)? Tokens::RPAR)
    //  *                  | Keys::UNDER
    //  *                  | option_match
    //  *                  | expression:(0)
    //  * ===============================
    //  */
    // fn readCallingMatch (mut self, loc : &Word)-> &Expression
    //     throws ErrorMsg
    // {
    //     // a type can be a bit more complex than just an identifier
    //     // it can be a path to a type, and a template type
    //     // This pattern does not apply to slices, and tuple, their patterns are different
    //     let mut var : &Expression = copy VarExpr (loc);
    //     if (loc != Keys::UNDER) {
    //         loop {
    //             let (n, _) = self:.readIf(Tokens::NOT, Tokens::DCOLON);
    //             if (n == Tokens::NOT) {
    //                 self:.rewind ();
    //                 var = self:.readTemplateCall (var);
    //                 break;
    //             } else if (n == Tokens::DCOLON) {
    //                 var = copy BinaryExpr (n, var, copy VarExpr (self:.readIdentifier ()._0));
    //             } else break;
    //         }
    //     }

    //     let (start, _) = self:.readIf (Tokens::LPAR);

    //     // If read a (, then it is a call pattern
    //     // calling function, and compare the value should be done within a match guard
    //     if (!start.isEof) {
    //         let mut params : [mut &Expression] = [];
    //         let mut e = self:.readIf (Tokens::RPAR, Tokens::COMA)._0;
    //         while e != Tokens::RPAR {
    //             let (ident, _) = self:.readIdentifier ();
    //             self:.readTokens (Tokens::ARROW);

    //             params ~= [copy NamedExpr (ident, self:.readMatchExpression ())];
    //             e = self:.readTokens (Tokens::RPAR, Tokens::COMA)._0;
    //         }

    //         copy MultOperatorExpr (start, e, var, params)
    //     } else {
    //         // a variable that is not a var declaration, supposedly read /::/ or /!/
    //         if (loc == Keys::UNDER) { var }
    //         else {
    //             self:.rewindToSeek (loc);
    //             self:.readExpression ()
    //         }
    //     }
    // }

    // /**
    //  * Read an option match
    //  * @verbatim:
    //  * =========================
    //  * option_match := (OptionKeys::MATCH_SOME | OptionKeys::MATCH_NONE) Tokens::LPAR inner_matcher_expr Tokens::RPAR
    //  * =========================
    //  * */
    // fn readOptionMatch (mut self, loc : &Word)-> &Expression
    //     throws ErrorMsg
    // {
    //     self:.readTokens (Tokens::LPAR);
    //     let inner = if (self:.readIf (Tokens::RPAR)._0.isEof) { // some (inner) =>
    //         let inner = self:.readMatchExpression ();
    //         self:.readTokens (Tokens::RPAR);
    //         inner
    //     } else { // some () =>
    //         EMPTY_EXPR
    //     }

    //     copy OptionMatcherExpr (loc, inner)
    // }

    // /**
    //  * Read a list in match expression
    //  * @verbatim:
    //  * ===============================
    //  * par_match :=   Tokens::LPAR (inner_matcher_expr (Tokens::COMA inner_matcher_expr )* (Tokens::COMA inner_matcher_expr Tokens::TDOT))? Tokens::RPAR
    //  *              | Tokens::LPAR (inner_matcher_expr (Tokens::TDOT)? Tokens::COMA) Tokens::RPAR
    //  *              | Tokens::LCRO (inner_matcher_expr (Tokens::COMA inner_matcher_expr)*)? Tokens::RCRO
    //  * ===============================
    //  */
    // fn readParMatch (mut self, loc : &Word, endTok : [c8] = Tokens::RPAR)-> &Expression
    //     throws ErrorMsg
    // {
    //     let mut params : [mut &Expression] = [];
    //     let mut e = self:.readIf (endTok)._0;
    //     while e != endTok {
    //         params ~= [self:.readMatchExpression ()];

    //         e = self:.readTokens (Tokens::COMA, endTok, Tokens::TDOT)._0;
    //         if (e == Tokens::TDOT) {
    //             if (endTok == Tokens::RPAR && params.len == 1us) {
    //                 self:.readTokens (Tokens::COMA);
    //             }
    //             e = self:.readTokens (endTok)._0;
    //             return copy ListMatcherExpr (loc, e, params, true);
    //         }

    //         if (params.len == 1us) {
    //             if (e == Tokens::COMA && endTok == Tokens::RPAR && !self:.readIf (Tokens::RPAR)._0.isEof) { // (x,) is a tuple
    //                 return copy ListMatcherExpr (loc, e, params, false);
    //             }
    //         }
    //     }

    //     // (x) is not a tuple, just x, but () is a tuple
    //     if (endTok == Tokens::RPAR && params.len == 1us) return params [0];
    //     copy ListMatcherExpr (loc, e, params, false)
    // }


    // /*!
    //  * ================================================================================
    //  * ================================================================================
    //  * =========================           LITERALS           =========================
    //  * ================================================================================
    //  * ================================================================================
    //  */


    // /**
    //  * Read a literal
    //  * @verbatim:
    //  * ================
    //  * literal :=   Numeric
    //  *            | Float
    //  *            | Char
    //  *            | String
    //  *            | (Keys::TRUE | Keys::FALSE)
    //  *            | Keys::NULL
    //  *            | Tokens::DOLLAR
    //  * ================
    //  */
    // pub fn readLiteral (mut self, token : &Word)-> &Expression
    //     throws ErrorMsg
    // {                        
    //     if let str: &StringWord = token { // String literal            
    //         match str.open {
    //             Tokens::SQUOTE => {
    //                 return copy CharExpr (str.open, str.close, str.str, suffix-> str.suffix);                    
    //             }
    //             Tokens::DQUOTE | Tokens::TRIPLE_DQUOTE => {
    //                 return copy StringExpr (str.open, str.close, str.str, suffix-> str.suffix);                    
    //             }
    //         }
            
    //         throw copy ErrorMsg::fatal (str.open, format (SyntaxErrorMessage::UNEXPECTED, str.open.str));
    //     }

    //     if let num: &NumericWord = token {
    //         return copy FixedExpr (num, suffix-> num.suffix);
    //     }

    //     if let fl: &FloatWord = token {
    //         throw copy ErrorMsg::fatal (fl, "");
    //     }
        
    //     match token {
    //         Keys::TRUE | Keys::FALSE => {
    //             return copy BoolExpr (token);    
    //         }
    //         Keys::NULL => {
    //             return copy NullExpr (token);    
    //         }
    //         Keys::NONE => {
    //             return copy NoneExpr (token);    
    //         }
    //         Tokens::DOLLAR => {
    //             return copy DollarExpr (token);    
    //         }
    //         Tokens::DDOT => { // ..i32 is a range type
    //             let type = self:.readOperand3 ();
    //             return copy RangeTypeExpr (token, type);
    //         }
    //     }
        
    //     throw copy ErrorMsg::fatal (token, format (SyntaxErrorMessage::UNEXPECTED, token.str));            
    // }

    // /**
    //  * Read an array literal
    //  * @verbatim:
    //  * =================
    //  * array_lit := Tokens::LCRO (expression:(0) (Tokens::COMA expression:(0))*)? Tokens::RCRO
    //  *              | Tokens::AND_LCRO (expression:(0) (Tokens::COMA expression:(0))*)? Tokens::RCRO
    //  * =================
    //  */
    // fn readArray (mut self, loc : &Word)-> &Expression
    //     throws ErrorMsg
    // {
    //     let (n, _) = self:.readIf (Tokens::RCRO);
    //     if (!n.isEof) return copy ListExpr (loc, n, [], isArray-> true);

    //     let mut params : [mut &Expression] = copy [self:.readExpression ()];
    //     let (e, _) = self:.readIf (Tokens::SEMI_COLON, Tokens::RCRO, Tokens::COMA, Keys::FOR, Tokens::DARROW);

    //     if (e == Tokens::SEMI_COLON) { // allocation
    //         let size = self:.readExpression ();
    //         self:.readTokens (Tokens::RCRO);
    //         return copy SliceAllocatorExpr (loc, params [0], size);
    //     }

    //     if (e == Keys::FOR) {
    //         let forLoc = e;
    //         let mut decls : [mut &Expression] = [];
    //         let (par, _) = self:.readIf (Tokens::LPAR);
    //         loop {
    //             decls ~= [self:.readSingleVarDeclaration (mandType-> false, withValue-> false)];
    //             let (n2, _) = self:.readTokens (Tokens::COMA, Keys::IN);
    //             if (n2 == Keys::IN) break;
    //         }

    //         let iter = self:.readExpression ();
    //         if (!par.isEof) self:.readTokens (Tokens::RPAR);
    //         self:.readTokens (Tokens::RCRO);

    //         return copy SliceForAllocatorExpr (loc, forLoc, params [0], decls, iter, isTuple-> false);
    //     }

    //     if (e == Tokens::DARROW) { // map [a => ...
    //         return self:.readListMap (loc, params [0]);
    //     }

    //     let mut end = e;
    //     if (e != Tokens::RCRO) {
    //         loop {
    //             params ~= [self:.readExpression ()];
    //             end = self:.readTokens (Tokens::RCRO, Tokens::COMA)._0;
    //             if (end == Tokens::RCRO) {
    //                 break;
    //             }
    //         }
    //     }

    //     copy ListExpr (loc, end, params, isArray-> true)
    // }

    // /**
    //  * Read a map literal
    //  * @verbatim:
    //  * ===============
    //  * listmap_lit := Tokens::LCRO  map_element (Tokens::COMA map_element)* Tokens::RCRO
    //  * map_element := expression:(10) Tokens::ARROW expression:(10)
    //  * ===============
    //  * */
    // fn readListMap (mut self, loc : &Word, fstKey : &Expression)-> &Expression
    //     throws ErrorMsg
    // {
    //     let mut keys : [mut &Expression] = copy [fstKey];
    //     let mut values : [mut &Expression] = copy [self:.readExpression ()];
    //     let mut end : &Word = EOF_WORD;
    //     loop {
    //         end = self:.readTokens (Tokens::RCRO, Tokens::COMA)._0;
    //         if (end == Tokens::RCRO) break;

    //         keys ~= [self:.readExpression ()];
    //         self:.readTokens (Tokens::DARROW);
    //         values ~= [self:.readExpression ()];
    //     }

    //     copy ListMapExpr (loc, end-> end, keys, values)
    // }
    
    /**
     * Read an identifier from the lexer
     * @throws:
     *    - ErrorMsg: if the next token is not a valid identifier 
     */
    pub fn readIdentifier (mut self)-> (&Word, [c8])
        throws ErrorMsg
    {        
        let (ident, comm) = self:.readToken ();
        if !ident.isName {
            throw copy ErrorMsg::fatal (ident, format (SyntaxErrorMessage::UNEXPECTED, ident.str));
        }

        (ident, comm)
    }

    /**
     * Read an identifier if there is an identifier to read
     * @returns: the identifier (and associated comment), or (EOF_WORD, "") if no identifier can be read
     */
    pub fn readIfIdentifier (mut self)-> (&Word, [c8]) {
        let ident = self.peekToken ();
        if !ident.isName {
            return (EOF_WORD, "");
        }
                
        return self:.readToken ();
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =================================          CONTEXT SWITCH          =================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Set the location of the current '!' calling templates values (EOF otherwise)
     *
     * @params:
     *    - loc: the location of the '!' operator
     *  
     * */
    pub fn setInTemplate (mut self, loc: &Word) {
        self._inTemplateCall = loc;
    }

    /**
     * @returns: the location of the current '!' calling template values, if any (EOF otherwise)
     * */
    pub fn isInNoAccTemplate (self)-> &Word {
        self._inTemplateCall
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ================================          READING HELPERS          =================================
     * ====================================================================================================
     * ====================================================================================================
     */
    
    /**
     * @returns: the next token inside the lexer, if it is equals to one of the token inside lst
     * @info: if none of lst token is found, the lexer is not incremented
     * @params:
     *    - lst: a list of tokens
     */
    pub fn readIf {R...} (mut self, f : [c8], l : R)-> (&Word, [c8]) {                
        let x = self._lex.peek ();        
        if (x.isEof) return (EOF_WORD, "");

        if x == f {
            return self._lex:.next ();
        }
        
        
        cte if (R,)::arity > 1 {
            cte for i in l if x.str == i {
                return self._lex:.next ();    
            } 
        } else {
            if x == l {
                return self._lex:.next ();
            }
        }
        
        return (EOF_WORD, "");
    }
    
    /**
     * @returns: the next token inside the lexer, if it is equals to one of the token inside lst
     * @info: if none of lst token is found, the lexer is not incremented
     * @params:
     *    - lst: a list of tokens
     */
    pub fn readIf (mut self, lst : [[c8]])-> (&Word, [c8]) {
        let x = self._lex.peek ();
        if (x.isEof) return (EOF_WORD, "");

        for i in lst {
            if i == x.str {
                return self._lex:.next ();
            }
        }

        return (EOF_WORD, "");
    }

    /**
     * @returns: the next token inside the lexer, if it is equals to one of the token inside lst
     * @info: if none of lst token is found, the lexer is not incremented
     * @params:
     *    - lst: a token
     */
    pub fn readIf (mut self, lst : [c8])-> (&Word, [c8]) {
        let x = self._lex.peek ();
        if (x.str == lst) return self._lex:.next ();

        return (EOF_WORD, "");
    }

    /**
     * @returns: the next token inside the lexer
     * */
    pub fn readToken (mut self)-> (&Word, [c8]) {
        self._lex:.next ()
    }

    /**
     * Read a string token, starting with `open` or `lst`
     * */
    pub fn readStringTokens {R...} (mut self, start : [c8], l : R)-> (&StringWord, [c8])
        throws ErrorMsg
    {
        let (x, y) = self._lex:.next ();
        if let str : &StringWord = x {                         
            if str.open == start {                                
                return (str, y);
            }
                    
            cte if (R,)::arity > 1 {
                cte for i in l if str.open == i {
                    return (str, y);            
                }
                
            } else {
                if str.open == l {
                    return (str, y);
                }                        
            }    
        }

        throw copy ErrorMsg::fatal (x, format (SyntaxErrorMessage::UNEXPECTED, x.str));        
    }

    /**
     * Read a string token, starting with `open`
     * */
    pub fn readStringTokens (mut self, start : [c8], suffix : bool = true)-> (&StringWord, [c8])
        throws ErrorMsg
    {
        let (x, y) = self._lex:.next ();
        if let str : &StringWord = x {
            if !suffix && !str.suffix.isEof {
                throw copy ErrorMsg::fatal (str.suffix, format (SyntaxErrorMessage::UNEXPECTED, str.suffix.str));                
            }
            
            if str.open == start {
                return (str, y);
            }                    
        }

        throw copy ErrorMsg::fatal (x, format (SyntaxErrorMessage::UNEXPECTED, x.str));        
    }
    
    /**
     * @returns: the next token inside the lexer without moving the cursor
     * */
    pub fn peekToken (self)-> &Word {
        self._lex.peek ()
    }

    /**
     * @returns: the next token in the lexer without making the cursor progress
     * */
    pub fn isEof (self)-> bool {
        self._lex.isEof
    }

    /**
     * @returns: the next token inside the lexer, if it is equals to one of the token inside lst
     * @throws:
     *   - ErrorMsg: if none of the token in lst is equal to the token that have been read, or the next token is eof
     * @params:
     *    - lst: a list of tokens
     */
    pub fn readTokens {R...} (mut self, f : [c8], l : R)-> (&Word, [c8])
        throws ErrorMsg
    {                        
        let (x, y) = self._lex:.next ();
        if x == f {
            return (x, y);
        }

        cte if (R,)::arity > 1 {
            cte for i in l if x.str == i {
                return (x, y);            
            }
            
            throw copy ErrorMsg::fatal (x, format (SyntaxErrorMessage::UNEXPECTED_BUT_LST, x.str, copy [f, expand l]));
        } else {
            if x.str == l {
                return (x, y);
            }
            
            throw copy ErrorMsg::fatal (x, format (SyntaxErrorMessage::UNEXPECTED_BUT_LST, x.str, copy [f, l]));
        }                                 
    }
    
    /**
     * @returns: the next token inside the lexer, if it is equals to one of the token inside lst
     * @throws:
     *   - ErrorMsg: if none of the token in lst is equal to the token that have been read, or the next token is eof
     * @params:
     *    - lst: a list of tokens
     */
    pub fn readTokens (mut self, lst : [[c8]])-> (&Word, [c8])
        throws ErrorMsg
    {
        let (x, y) = self._lex:.next ();
        for i in lst {
            if i == x.str {
                return (x, y);
            }
        }

        throw copy ErrorMsg::fatal (x, format (SyntaxErrorMessage::UNEXPECTED_BUT_LST, x.str, lst));
    }

    /**
     * @returns: the next token inside the lexer, if it is equals to one of the token inside lst
     * @throws:
     *   - ErrorMsg: if none of the token in lst is equal to the token that have been read, or the next token is eof
     * @params:
     *    - lst: a token
     */
    pub fn readTokens (mut self, lst : [c8])-> (&Word, [c8])
        throws ErrorMsg
    {
        let (x, y) = self._lex:.next ();
        if (x.str == lst) return (x, y);

        throw copy ErrorMsg::fatal (x, format (SyntaxErrorMessage::UNEXPECTED_BUT_LST, x.str, lst));
    }

    /**
     * @returns: the cursor of the lexer
     * */
    pub fn getSeek (self)-> usize {
        self._lex.getSeek ()
    }
    
    /**
     * @returns: the next token inside the lexer
     * */
    pub fn rewind (mut self) {
        self._lex:.rewind ()
    }

    /**
     * Rewind to the cursor of a word, right before the word
     * thus self:.readToken () might return the word after that if this is a token
     * */
    pub fn rewindToSeek (mut self, loc : &Word) {
        self._lex:.rewindToSeek (loc.seek)
    }

    /**
     * Rewind the cursor to seek     
     * */
    pub fn rewindToSeek (mut self, seek : usize) {
        self._lex:.rewindToSeek (seek)
    }
    
    /*!
     * ================================================================================
     * ================================================================================
     * =========================            TESTS             =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * @returns: true, if this expression needs at the end, a semi colon to be separated from other expressions
     */
    pub fn needClosingExpr (self, expr: &Expression)-> bool {
        match expr {
            a : &AtomicExpr => { self.needClosingExpr (a.getValue ()) }
            BlockExpr () => { false }
            b : &BreakExpr => { self.needClosingExpr (b.getValue ()) }
            ConditionalExpr () => { false }
            EmptyExpression () => { false }
            ForLoopExpr () => { false }
            MatcherExpr () => { false }
            r : &ReturnExpr =>  { self.needClosingExpr (r.getValue ()) }
            ScopeGuardExpr () => { false }
            t : &ThrowExpr => { self.needClosingExpr (t.getValue ()) }
            l : &WhileLoopExpr => { l.isDo () }
            UnsafeExpr () => { false }
            s : &SetExpr => {
                if (s.getContent ().len != 0us) {
                    self.needClosingExpr (s.getContent ()[$ - 1us])
                } else { false }
            }
            v : &VarDeclExpr => {
                match v.getValue () {
                    EmptyExpression () => { true }

                    _ => {
                        self.needClosingExpr (v.getValue ())
                    }
                }
            }
            v : &PatternVarDeclExpr => {
                match v.getValue () {
                    EmptyExpression () => { true }
                    _ => {
                        self.needClosingExpr (v.getValue ())
                    }
                }
            }
            i : &IntrinsicExpr => {
                if (i.getType () == IntrinsicKeys::CTE) {
                    self.needClosingExpr (i.getContent ())
                } else { true }
            }
            _ => { true }
        }
    }

    
    /*!
     * ================================================================================
     * ================================================================================
     * =========================             CONV             =========================
     * ================================================================================
     * ================================================================================
     */

    
}
