in visitor;

use ymirc::syntax::errors;
use ymirc::errors::_;
use ymirc::syntax::{_,
                    declaration::_,
                    expression::{_, literal::_, macro_::_, operator::_, template::_}};

use ymirc::lexing::_;
use ymirc::utils::_;
use ymirc::global::state;

use std::{fs::_, io};

lazy __SPECIAL_TOKENS__ = SpecialKeysAndTokens ();

/**
 * This struct is used to alloc only one time the arrays of tokens, and avoid lost of perf for allocation of const arrays
 */
record SpecialKeysAndTokens {
    pub let binaryOperators = copy BinaryOperatorsLevels::__members__;
    pub let specialBinaryOperators = copy [Keys::IS, Keys::OF, Keys::IN];
    pub let macroMult = copy MacroMultTokens::__members__;
    pub let unaryOperators = copy UnaryOperators::__members__;
    pub let intrinsicKeys = copy IntrinsicKeys::__members__;
    pub let decorators = copy Decorators::__members__;
    pub let skipTokens = copy SkipTokens::__members__;
    pub let stringSuffixes = copy StringSuffixes::__members__;
    pub let charSuffixes = copy CharSuffixes::__members__;
    pub let fixedSuffixes = copy FixedSuffixes::__members__;
    pub let floatSuffixes = copy FloatSuffixes::__members__;

    pub self () {}
}

/**
 * Create a lexer over a file
 * @params:
 *    - path: the path to the file
 * */
fn createLexer (path : Path)-> dmut &Lexer
    throws FsError
{
    let content = {
        let dmut f = File::open (path);
        f:.readAll ()
    };

    return copy Lexer (path.toStr (),
                       content-> content,
                       tokens-> tokens::TokenList,
                       comments-> tokens::CommentList,
                       skips-> tokens::SkipList);
}


/**
 * The syntax visitor class is the class used to transform a text content into an analyzable syntax tree
 * The syntax visitor will validated the content of the source code, but only at a syntaxic level
 */
@final
pub class SyntaxVisitor {

    // The path of the file being read
    let _path : Path;

    // The lexer that is used to cut the content string in tokens
    let dmut _lex : &Lexer;

    // The list of forbidden keys (for identifiers)
    let dmut _forbiddenKeys : [[c8] => ()] = copy [];

    // True iif currently reading template call expr without parentheses
    let mut _inTemplateCall = false;

    let _specials : SpecialKeysAndTokens;

    /**
     * Create a new visitor for a given file
     * @params:
     *  - path: the path of the file to read
     */
    pub self open (path : Path)
        with _lex = createLexer (path)
        , _specials = __SPECIAL_TOKENS__
        , _path = path
        throws FsError
    {
        for i in Tokens::__members__ {
            self._forbiddenKeys [i] = ();
        }

        for i in ForbiddenKeys::__members__ {
            self._forbiddenKeys [i] = ();
        }
    }

    /**
     * Create a new visitor from string content
     * @params:
     *    - path: the path of the file containing the string
     *    - content: the content of the string
     *    - addLine: the location of the beginning of the string
     *    - addCol: the location of the beginning of the string
     * */
    pub self fromStr (path : [c8], content : [c8])
        with _lex = copy Lexer (path,
                                content-> content,
                                tokens-> tokens::TokenList,
                                comments-> tokens::CommentList,
                                skips-> tokens::SkipList)
        , _specials = __SPECIAL_TOKENS__
        , _path = Path (path)
    {
        for i in Tokens::members {
            self._forbiddenKeys [i] = ();
        }

        for i in ForbiddenKeys::members {
            self._forbiddenKeys [i] = ();
        }
    }


    /*!
     * ================================================================================
     * ================================================================================
     * ========================            GETTERS            =========================
     * ================================================================================
     * ================================================================================
     */


    /**
     * @returns: the lexer
     * */
    pub fn getLexer (mut self)-> dmut &Lexer {
        alias self._lex
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================            MODULE            =========================
     * ================================================================================
     * ================================================================================
     */


    /**
     * Once the visitor is initialized, (with open for instance)
     * the content can be read an transformed into a syntax tree
     * @example:
     * =================
     * let dmut visitor = copy Visitor::open (Path ("foo.yr"));
     * {
     *    // verify the grammar of the content of the file
     *    // And return it into a syntax tre
     *    let module = visitor:.read ();
     *    println (format ("%", module)); // pretty print the module that has been read
     * } catch {
     *    err : &ErrorMsg => {
     *          println (format ("%", err)); // print the error that occured inside the file
     *    }
     * }
     * =================
     */
    pub fn read (mut self)-> &ModuleDecl
        throws ErrorMsg
    {
        let (loc, path, comm) = self:.readGlobalPath ();
        let ret = copy ModuleDecl (loc, path, comm, self:.readBlockDecl (loc, comm), isGlobal-> true);
        ret
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================      DECLARATION BLOCKS      =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Read the first declaration line of the module (if any), and return the declared path
     * @returns:
     *    - the path, or Unit if nothing was found was found
     *    - the comments above the path
     */
    fn readGlobalPath (mut self) -> (&Word, &Word, [c8])
        throws ErrorMsg
    {
        let (next, comm) = self._lex.nextNoConsume ();
        if (next != Keys::IN) {
            return (next, EOF_WORD, "");
        }
        self._lex:.next ();

        let (path, _) = self:.readIdentifier (canBeSelf-> false);
        self:.readTokens (Tokens::SEMI_COLON);
        (next, path, comm)
    }

    /**
     * Read a set of declaration in a global module (or in a global sub symbol, such as local module, protection block, etc.)
     * @verbatim:
     * ===================
     * decl_block := declaration | protection_block | version_block
     * ===================
     * @params:
     *     - close: if false, then the reading stops when the token eof () is found
     *              , otherwise it stops when the token Tokens::RACC is found
     */
    fn readBlockDecl (mut self, loc : &Word, comm : [c8], closing : bool = false, protection : Protection = Protection::PRIVATE, inProtection : bool = false) -> &BlockDecl
        throws ErrorMsg
    {
        let mut decls : [mut &Declaration] = [];
        loop {
            let (attrLoc, attribs, attrComm) = self:.readAttributes ();

            let (tok, comm_) = self._lex:.next ();
            if (closing && tok.str == Tokens::RACC) break;
            if (!tok.isEof ()) self._lex:.rewind ();

            match tok.str {
                Keys::PUBLIC | Keys::PRIVATE => {
                    if (inProtection) {
                        decls ~= [self:.readDeclaration (comm-> attrComm ~ comm_, attribs-> (attrLoc, attribs))];
                    } else {
                        decls ~= [self:.readProtectionBlock (attribs-> (attrLoc, attribs, attrComm))];
                    }
                }
                Keys::VERSION => {
                    self.checkNoAttributes (tok, attrLoc, attribs);
                    decls ~= [self:.readVersionBlock (protection-> protection)];
                }
                Tokens::LACC => {
                    self.checkNoAttributes (tok, attrLoc, attribs);
                    self._lex:.next ();
                    decls ~= [self:.readBlockDecl (tok, attrComm ~ comm_, closing-> true, protection-> protection, inProtection-> inProtection)];
                }
                _ => {
                    if !tok.isEof () {
                        decls ~= [self:.readDeclaration (comm-> attrComm ~ comm_, attribs-> (attrLoc, attribs))];
                    } else if (!closing) {
                        self.checkNoAttributes (tok, attrLoc, attribs);
                        break;
                    } else throw copy ErrorMsg::fatal (tok, SyntaxErrorMessage::BLOCK_NEVER_CLOSED);
                }
            }
        }

        copy BlockDecl (loc, comm, decls, protection-> protection)
    }

    /**
     * Read a protection block
     * @verbatim:
     * ===============
     * protection_block :=   (Keys::PRIVATE | Keys::PUBLIC) Tokens::LACC decl_block Tokens::RACC
     *                     | (Keys::PRIVATE | Keys::PUBLIC) declaration
     * ===============
     */
    fn readProtectionBlock (mut self, attribs : (&Word, [AttributeWord], [c8]) = (EOF_WORD, [], [])) -> &BlockDecl
        throws ErrorMsg
    {
        let (loc, comm) = self:.readIf (Keys::PRIVATE, Keys::PUBLIC);
        {
            let protection = if (loc.str == Keys::PRIVATE) { Protection::PRIVATE } else { Protection::PUBLIC };
            let (tok, _) = self:.readIf (Tokens::LACC);
            if (tok.isEof ()) {
                copy BlockDecl (loc, comm, copy [self:.readDeclaration (comm-> comm ~ attribs.2, attribs-> (attribs.0, attribs.1))], protection-> protection)
            } else {
                self.checkNoAttributes (tok, attribs._0, attribs._1);
                self:.readBlockDecl (loc, comm, closing-> true, protection-> protection, inProtection-> true)
            }
        } catch {
            err : &ErrorMsg => {
                if (!loc.isEof ()) {
                    throw copy ErrorMsg::note (loc, SyntaxErrorMessage::IN_DECL_BLOCK, notes-> copy [err]);
                } else {
                    throw err;
                }
            }
        }
    }

    /**
     * Visit a version block
     * @verbatim:
     * ================
     * version_block := Keys::VERSION Tokens::LACC decl_block Tokens::RACC (else Tokens::LACC decl_block Tokens::RACC)?
     * ================
     */
    fn readVersionBlock (mut self, protection : Protection = Protection::PRIVATE, inProtection : bool = false)-> &BlockDecl
        throws ErrorMsg
    {
        let (loc, comm) = self._lex:.next ();
        {
            let (v, _) = self:.readIdentifier (canBeSelf-> false);
            return if state::instance ().isVersionActive (v.str) {
                self:.readTokens (Tokens::LACC);
                let block = self:.readBlockDecl (loc, comm, closing-> true, protection-> protection, inProtection-> inProtection);
                if (!(self:.readIf (Keys::ELSE)._0).isEof ())
                    self:.ignoreBlock ();
                block
            } else {
                self:.ignoreBlock ();
                if (!(self:.readIf (Keys::ELSE)._0).isEof ()) {
                    self:.readTokens (Tokens::LACC);
                    self:.readBlockDecl (loc, comm, closing-> true, protection-> protection, inProtection-> inProtection)
                } else {
                    copy BlockDecl (loc, comm, [])
                }
            } ;
        } catch {
            err : &ErrorMsg => {
                if (!loc.isEof ()) {
                    throw err.appendNotes (copy [copy ErrorMsg::note (loc, SyntaxErrorMessage::IN_DECL_BLOCK)]);
                } else {
                    throw err;
                }
            }
        }
    }

    /**
     * Ignore a block of element (no matters what is inside)
     * Basically, it can be used to consider the next block of code as a comment
     * A block is enclosed by Tokens::LACC and Tokens::RACC
     */
    fn ignoreBlock (mut self)
        throws ErrorMsg
    {
        let _ = self:.readTokens (Tokens::LACC);
        let mut nb = 1u64;
        loop {
            let (next, _) = self._lex:.next ();
            if (next == Tokens::RACC) {
                nb -= 1u64;
                if (nb == 0u64)
                    break;
            } else if (next == Tokens::LACC) nb += 1u64;
            else if (next.isEof ())
            throw copy ErrorMsg::fatal (next, SyntaxErrorMessage::UNTERMINATED_BLOCK);
        }
    }
    /**
     * Read a declaration
     * @verbatim:
     * ==================
     * decl :=   aka_decl
     *         | class_decl
     *         | enum_decl
     *         | func_decl
     *         | static_decl
     *         | import_decl
     *         | extern_decl
     *         | macro_decl
     *         | mod_decl
     *         | struct_decl
     *         | trait_decl
     *         | unittest
     * ==================
     */
    fn readDeclaration (mut self, comm : [c8] = [], attribs : (&Word, [AttributeWord]) = (EOF_WORD, []))-> &Declaration
        throws ErrorMsg
    {
        let (tok, postComm) = self._lex:.next ();
        match tok.str {
            Keys::CLASS    => { return self:.readClass (tok, comm ~ postComm, attribs-> attribs._1, isStruct-> false); }
            Keys::FUNCTION => { return self:.readFunction (tok, comm ~ postComm, attribs-> attribs._1); }
            Keys::STRUCT   => { return self:.readClass (tok, comm ~ postComm, attribs-> attribs._1, isStruct-> true, isRecord-> false); }
            Keys::RECORD   => { return self:.readClass (tok, comm ~ postComm, attribs-> attribs._1, isStruct-> true, isRecord-> true); }
            Keys::STATIC   => { return self:.readGlobal (tok, comm ~ postComm, isStatic-> true, attribs-> attribs._1); }
            Keys::LAZY     => { return self:.readGlobal (tok, comm ~ postComm, attribs-> attribs._1); }
            Keys::EXTERN   => { return self:.readExtern (tok, comm ~ postComm, attribs-> attribs); }
            _ => {
                self.checkNoAttributes (tok, attribs._0, attribs._1);
                match tok.str {
                    Keys::AKA    => { return self:.readAka (tok, comm ~ postComm); }
                    Keys::ENUM   => { return self:.readEnum (tok, comm ~ postComm); }
                    Keys::MACRO  => { return self:.readMacro (tok, comm ~ postComm); }
                    Keys::MOD    => { return self:.readLocalModuleDecl (tok, comm ~ postComm); }
                    Keys::TRAIT  => { return self:.readTrait (tok, comm ~ postComm); }
                    Keys::UNITTEST => { return self:.readUnitTest (tok, comm ~ postComm); }
                    Keys::USE => { return self:.readUse (tok, comm ~ postComm); }
                }

                throw copy ErrorMsg::fatal (tok, format (SyntaxErrorMessage::UNEXPECTED_BUT_LST, tok.str,
                                                         copy [Keys::AKA, Keys::CLASS, Keys::ENUM,
                                                               Keys::USE, Keys::EXTERN, Keys::MACRO, Keys::MOD,
                                                               Keys::STRUCT, Keys::RECORD, Keys::TRAIT, Keys::STATIC, Keys::LAZY]));
            }
        }
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================             AKA              =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Read an aka declaration
     * @verbatim:
     * ===============
     * aka_decl :=   Keys::AKA Keys::IF expression:(0) Identifier template_param_list Tokens::EQUAL expression:(0)
     *             | Keys::AKA Identifier (template_param_list)? Tokens::EQUAL expression:(0)
     * ===============
     */
    fn readAka (mut self, _ : &Word, comm : [c8])-> &Declaration
        throws ErrorMsg
    {
        let (hasTest, test) = self:.readTemplateTest ();
        let (ident, _) = self:.readIdentifier (canBeSelf-> false);
        let (templates, tmpErr) = self:.readTemplateParameters (ifLoc-> hasTest);

        let a = {
            self:.readTokens (Tokens::EQUAL, Tokens::COLON)._0
        } catch {
            err : &ErrorMsg => {
                throw err.appendNotes (notes-> tmpErr);
            }
        };

        let value = self:.readExpression ();
        self:.readIf (Tokens::SEMI_COLON);

        if (templates.len == 0us) {
            copy AkaDecl (ident, comm, value, a)
        } else {
            copy TemplateDecl (ident, comm, templates, copy AkaDecl (ident, comm, value, a), test-> test)
        }
    }


    /*!
     * ================================================================================
     * ================================================================================
     * =========================            CLASS             =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Read a class declaration
     * @verbatim:
     * ===============
     * class_decl :=   Keys::CLASS Keys::IF expression:(0) (attribute_list)? Identifier template_param_list (Keys::OVER expression:(0))? class_block_decl
     *               | Keys::CLASS (attributes_list)? Identifier (template_param_list)? (Keys::OVER expression:(0))? class_block_decl
     * ===============
     */
    fn readClass (mut self,  _ : &Word, comm : [c8], attribs : [AttributeWord], isStruct : bool, isRecord : bool = false)-> &Declaration
        throws ErrorMsg
    {
        let (hasTest, test) = self:.readTemplateTest ();
        let (ident, _) = self:.readIdentifier (canBeSelf-> false);
        let (templates, tmpErr) = self:.readTemplateParameters (ifLoc-> hasTest);

        let ancestor =
            if (isStruct || (self:.readIf (Keys::OVER)._0).isEof ()) {
                EMPTY_EXPR
            } else {
                self:.readExpression ()
            };

        let open = {
            self:.readTokens (Tokens::LACC)._0
        } catch {
            err : &ErrorMsg => throw err.appendNotes (notes-> tmpErr);
        };

        let decls = {
            self:.readClassBlockDecl (closing-> true, isStruct-> isStruct)
        } catch {
            err : &ErrorMsg => {
                if (!open.isEof ()) {
                    throw err.appendNotes (copy [copy ErrorMsg::note (open, SyntaxErrorMessage::IN_DECL_BLOCK)]);
                } else throw err;
            }
        }

        let cls = copy ClassDecl (ident, comm, decls, attrs-> attribs, ancestor-> ancestor, isStruct-> isStruct, isRecord-> isRecord);

        if (templates.len == 0u64) {
            cls
        } else {
            copy TemplateDecl (ident, comm, templates, cls, test-> test)
        }
    }

    /**
     * Read the inner part of a class declaration
     * @verbatim:
     * ================
     * class_block_decl :=   (Keys::PUBLIC | Keys::PRIVATE | Keys::PROTECTED) class_block_decl
     *                     | Keys::VERSION Identifier class_block_decl (Keys::ELSE class_block_decl)?
     *                     | Keys::CTE Keys::IF expression:(0) class_block_decl (Keys::ELSE class_block_decl)?
     *                     | class_inner_declaration*
     * ================
     * @params:
     *     - close: if false, then the reading stops after the first declaration, otherwise it stops when the token Tokens::RACC is found
     */
    fn readClassBlockDecl (mut self, closing : bool = false, inImpl : bool = false, inProtection : bool = false, isStruct : bool)-> [&Declaration]
        throws ErrorMsg
    {
        let mut vec : [mut &Declaration] = [];
        loop {
            let (attrLoc, attribs, attrComm) = self:.readAttributes ();

            let (next, comm) = self._lex:.next ();
            match next.str {
                Keys::PRIVATE | Keys::PUBLIC | Keys::PROTECTED  => {
                    if (next.str == Keys::PROTECTED && isStruct) throw copy ErrorMsg::fatal (next, format (SyntaxErrorMessage::UNEXPECTED, next.str)); // no protected in struct
                    if (inProtection) throw copy ErrorMsg::fatal (next, format (SyntaxErrorMessage::UNEXPECTED, next.str));
                    let inner = {
                        let (acc, _) = self:.readIf (Tokens::LACC);
                        if (acc.isEof ()) {
                            let (d, c) = self._lex:.next ();
                            copy [self:.readClassInnerDecl (d, c, inImpl-> inImpl, inProtection-> true, attribs-> (attrLoc, attribs), isStruct-> isStruct)]
                        } else {
                            self.checkNoAttributes (next, attrLoc, attribs);
                            self:.readClassBlockDecl (inImpl-> inImpl, closing-> true, inProtection-> true, isStruct-> isStruct)
                        }
                    }  catch {
                        err : &ErrorMsg => {
                            if (!next.isEof ()) {
                                throw err.appendNotes (copy [copy ErrorMsg::note (next, SyntaxErrorMessage::IN_DECL_BLOCK)]);
                            } else throw err;
                        }
                    }
                    vec ~= [copy BlockDecl (next, attrComm ~ comm, inner, protection-> self.toProtection (next.str))];
                }
                Keys::VERSION => {
                    // if (inImpl) throw copy ErrorMsg::fatal (next, format (SyntaxErrorMessage::UNEXPECTED, next.str));
                    self.checkNoAttributes (next, attrLoc, attribs);
                    vec ~= [self:.readVersionClass (next, attrComm ~ comm, inProtection-> inProtection, isStruct-> isStruct, inImpl-> inImpl)];
                }
                Keys::CTE => {
                    // if (inImpl) throw copy ErrorMsg::fatal (next, format (SyntaxErrorMessage::UNEXPECTED, next.str));
                    self.checkNoAttributes (next, attrLoc, attribs);
                    vec ~= [self:.readIfClass (next, attrComm ~ comm, inProtection-> inProtection, isStruct-> isStruct, inImpl-> inImpl)];
                }
                Tokens::LACC => {
                    self.checkNoAttributes (next, attrLoc, attribs);
                    if (closing) throw copy ErrorMsg::fatal (next, format (SyntaxErrorMessage::UNEXPECTED_BUT_LST, next.str, copy [Keys::PUBLIC, Keys::PROTECTED, Keys::PRIVATE]));
                    else {
                        let r = self:.readClassBlockDecl (inImpl-> inImpl, closing-> true, inProtection-> inProtection, isStruct-> isStruct);
                        for i in r { vec ~= [i]; }
                    }
                }
                Tokens::RACC => {
                    self.checkNoAttributes (next, attrLoc, attribs);
                    if (closing) break;
                    else {
                        if (!isStruct) {
                            throw copy ErrorMsg::fatal (next, format (SyntaxErrorMessage::UNEXPECTED_BUT_LST, next.str, copy [Keys::PUBLIC, Keys::PROTECTED, Keys::PRIVATE]));
                        } else
                        throw copy ErrorMsg::fatal (next, format (SyntaxErrorMessage::UNEXPECTED_BUT_LST, next.str, copy [Keys::PUBLIC, Keys::PRIVATE]));
                    }
                }
                _ => {
                    vec ~= [(self:.readClassInnerDecl (next, attrComm ~ comm, inImpl-> inImpl, inProtection-> inProtection, attribs-> (attrLoc, attribs), isStruct-> isStruct))];
                }
            }

            if (!closing) {
                break;
            }
        }

        vec
    }

    /**
     * Read a version inside a class definition
     * @verbatim:
     * ===================
     * version_class := __version Identifier class_block_decl ('else' class_block_decl)?
     * ===================
     * @params:
     *   - inProtection: impl and import cannot be under protected declarators, and must be declared at root level of the class
     */
    fn readVersionClass (mut self, loc : &Word, comm : [c8], inProtection : bool = false, isStruct : bool, inImpl : bool)-> &Declaration
        throws ErrorMsg
    {
        let (v, _) = self:.readIdentifier (canBeSelf-> false);
        return if state::instance ().isVersionActive (v.str) {
            self:.readTokens (Tokens::LACC);
            let block = self:.readClassBlockDecl (closing-> true, inProtection-> inProtection, isStruct-> isStruct, inImpl-> inImpl);
            if (!(self:.readIf (Keys::ELSE)._0).isEof ()) {
                self:.ignoreBlock ();
            }

            copy BlockDecl (loc, comm, block, isSet-> true)
        } else {
            self:.ignoreBlock ();
            if (!(self:.readIf (Keys::ELSE)._0).isEof ()) {
                self:.readTokens (Tokens::LACC);
                let block = self:.readClassBlockDecl (closing-> true, inProtection-> inProtection, isStruct-> isStruct, inImpl-> inImpl);
                copy BlockDecl (loc, comm, block, isSet-> true)
            } else {
                copy BlockDecl (loc, comm, [], isSet-> true)
            }
        }
    }

    /**
     * Read a if condition or assert inside a class definition
     * @verbatim:
     * ================
     * if_class := Keys::CTE (Keys::IF expression block (Keys::ELSE block)?) | (Keys::ASSERT Tokens::LPAR expression (Tokens::COMA expression)? Tokens::RPAR )
     * ================
     */
    fn readIfClass (mut self, loc : &Word, comm : [c8], inProtection : bool = false, isStruct : bool, inImpl : bool)-> &Declaration
        throws ErrorMsg
    {
        let (a, _) = self:.readTokens (Keys::IF, Keys::ASSERT);
        match a.str {
            Keys::IF => {
                let test = self:.readExpression ();
                let fst = self:.readClassBlockDecl (closing-> false, inProtection-> inProtection, isStruct-> isStruct, inImpl-> inImpl);
                let (next, ncomm) = self:.readIf (Keys::ELSE);
                if (next == Keys::ELSE) {
                    let scd = self:.readClassBlockDecl (closing-> false, inProtection-> inProtection, isStruct-> isStruct, inImpl-> inImpl);
                    copy CondBlockDecl (loc, comm, fst, test, else_-> copy BlockDecl (next, ncomm, scd))
                } else {
                    copy CondBlockDecl (loc, comm, fst, test)
                }
            }
            _ => {
                self:.readTokens (Tokens::LPAR);
                let test = self:.readExpression ();
                let msg : &Expression = if (self:.readTokens (Tokens::RPAR, Tokens::COMA)._0 == Tokens::COMA) {
                    let msg_ : &Expression = self:.readExpression ();
                    self:.readTokens (Tokens::RPAR);
                    msg_
                } else { EMPTY_EXPR }
                self:.readIf (Tokens::SEMI_COLON);

                copy ExpressionWrapperDecl (loc, comm, copy AssertExpr (loc, test, msg))
            }
        }
    }

    /**
     * Read a declaration inside a class definition
     * @verbatim:
     * ===============
     * class_inner_decl :=   constructor
     *                     | function
     *                     | field
     *                     | impl (if !inProtection)
     *                     | import (if !inProtection)
     * ===============
     * @params:
     *    - inProtection: impl and import cannot be under protected declarators, and must be declared at root level of the class
     */
    fn readClassInnerDecl (mut self, loc : &Word, comm : [c8], inImpl : bool = false, inProtection : bool = false, attribs : (&Word, [AttributeWord]) = (EOF_WORD, []), isStruct : bool)-> &Declaration
        throws ErrorMsg
    {
        if (inImpl && loc != Keys::FUNCTION && loc != Keys::OVER) {
            throw copy ErrorMsg::fatal (loc, format (SyntaxErrorMessage::UNEXPECTED_BUT_LST, loc.str, copy [Keys::FUNCTION, Keys::OVER]));
        }

        match loc {
            Keys::SELF => { return self:.readClassConstructor (loc, comm, attribs-> attribs._1, isStruct-> isStruct); }
            Keys::FUNCTION  => { return self:.readFunction (loc, comm, isMethod-> true, attribs-> attribs._1); }
            Keys::OVER => { if (!isStruct) return self:.readFunction (loc, comm, isMethod-> true, isOver-> true, attribs-> attribs._1); }
        }

        self.checkNoAttributes (loc, attribs._0, attribs._1);
        match loc {
            Keys::LET  => {
                return self:.readGlobal (loc, comm, isField-> true, attribs-> []);
            }
            Keys::IMPL => {
                if (inProtection) {
                    throw copy ErrorMsg::warn (loc, SyntaxErrorMessage::IMPL_IN_PROTECTION);
                }
                return self:.readImplement (loc, comm);
            }
            Keys::USE => {
                if (inProtection) {
                    throw copy ErrorMsg::warn (loc, SyntaxErrorMessage::USE_IN_PROTECTION);
                }
                return self:.readUse (loc, comm);
            }
            Keys::DTOR => {
                // if (isStruct) throw copy ErrorMsg::fatal (loc, format (SyntaxErrorMessage::UNEXPECTED, loc.str));
                if (inProtection) {
                    throw copy ErrorMsg::warn (loc, SyntaxErrorMessage::DESTRUCTOR_IN_PROTECTION);
                }
                return self:.readClassDestructor (loc, comm);
            }
            _ => {
                let lst = if inProtection {
                    if isStruct {
                        copy [Keys::SELF, Keys::FUNCTION, Keys::LET]
                    } else { copy [Keys::SELF, Keys::FUNCTION, Keys::OVER, Keys::LET] }
                } else {
                    if (isStruct) {
                        copy [Keys::SELF, Keys::FUNCTION, Keys::LET, Keys::IMPL, Keys::USE]
                    } else {
                        copy [Keys::SELF, Keys::FUNCTION, Keys::OVER, Keys::LET, Keys::IMPL, Keys::USE, Keys::DTOR]
                    }
                };

                throw copy ErrorMsg::fatal (loc, format (SyntaxErrorMessage::UNEXPECTED_BUT_LST, loc.str, lst));
            }
        }
    }

    /**
     * Read a class constructor
     * @verbatim:
     * ================
     * constructor :=   Keys::SELF Keys::IF expression:(0) (attribs)? (Identifier)? template_param_list param_list (with_decl)? (throws_decl)? expression:(0)
     *                | Keys::SELF (attribs)? (Identifier)? (template_param_list)? param_list (with_decl)? (throws_decl)? expression:(0)
     * ================
     */
    fn readClassConstructor (mut self, loc : &Word, comm : [c8], attribs : [AttributeWord], isStruct : bool) -> &Declaration
        throws ErrorMsg
    {
        let (hasTest, test) = self:.readTemplateTest ();
        let (name, _) = self:.readIfIdentifier (canBeSelf-> false);
        let (templates, tmpErr) = self:.readTemplateParameters (ifLoc-> hasTest);

        let proto = self:.readFunctionPrototype (tmpError-> tmpErr);

        let dmut construction : [(&Word, &Expression)] = [];
        let mut supers : [&Expression] = [], mut tmpCall : &Expression = EMPTY_EXPR;
        let mut auxCstrLoc = EOF_WORD, mut auxCstrName = EOF_WORD;
        if (!(self:.readIf (Keys::WITH)._0).isEof ()) {
            loop {
                let (next, _) = self._lex:.next ();
                match next.str {
                    Keys::SUPER | Keys::SELF => {
                        if (isStruct && next.str == Keys::SUPER) throw copy ErrorMsg::fatal (next, format (SyntaxErrorMessage::UNEXPECTED, next.str));
                        if (!auxCstrLoc.isEof ())
                        throw copy ErrorMsg::fatal (next, SyntaxErrorMessage::MULTIPLE_AUX_CSTRS, notes-> copy [copy ErrorMsg::note (auxCstrLoc, "")]);

                        auxCstrLoc = next;
                        auxCstrName = if (self:.readIf (Tokens::DCOLON)._0.isEof ()) {
                            EOF_WORD
                        } else {
                            self:.readIdentifier (canBeSelf-> false)._0
                        };

                        tmpCall = self:.readTemplateCall (tmpCall);
                        self:.readTokens (Tokens::LPAR);
                        supers = self:.readArgumentList (withNamed-> true)._0;
                    }
                    _ => {
                        if (!self.isIdentifier (next.str, canBeSelf-> false))
                        throw copy ErrorMsg::fatal (next, format (SyntaxErrorMessage::USED_AS_IDENTIFIER, next.str));

                        self:.readTokens (Tokens::EQUAL);
                        construction ~= [(next, self:.readExpression ())];
                    }
                }

                if ((self:.readIf (Tokens::COMA)._0).isEof ()) {
                    break;
                }
            }
        }

        let (throwLoc, throwers) = self:.readThrowers ();
        let body = self:.readExpression ();

        let cstr = copy ConstructorDecl (loc, comm, rename-> name, proto,
                                         superParams-> supers, superTemplateParams-> tmpCall,
                                         fields-> construction,
                                         body-> body,
                                         explicitCstrsCall-> auxCstrLoc, explicitSuperName-> auxCstrName, attributes-> attribs,
                                         throwers-> throwers, throwerLoc-> throwLoc);

        if (templates.len != 0u64) {
            copy TemplateDecl (loc, comm, templates, cstr, test-> test)
        } else {
            cstr
        }
    }

    /**
     * Read class destructor
     * @verbatim:
     * ================
     * destructor := Keys::DTOR Tokens::LPAR Keys::MUT Keys::SELF Tokens::RPAR expression:(0)
     * ================
     */
    fn readClassDestructor (mut self, loc : &Word, comm : [c8])-> &Declaration
        throws ErrorMsg
    {
        self:.readTokens (Tokens::LPAR);
        let var = self:.readSingleVarDeclaration (mandType-> false, withValue-> false, isClass-> true);
        self:.readTokens (Tokens::RPAR);

        let content = self:.readExpression ();
        copy DestructorDecl (loc, comm, var, content)
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================          IMPLEMENT           =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Read an implementation of traits inside a class definition
     * @verbatim:
     * ==================
     * impl := Keys::IMPL expression:(0) (((',' expression:(0))* ';') | class_block_decl)
     * ==================
     */
    fn readImplement (mut self, loc : &Word, comm : [c8]) -> &Declaration
        throws ErrorMsg
    {
        let trait_ = self:.readExpression ();
        let (next, _) = self:.readIf (Tokens::SEMI_COLON, Tokens::COMA, Tokens::LACC);
        if (next == Tokens::LACC) {
            let content = self:.readClassBlockDecl (inImpl-> true, inProtection-> false, closing-> true, isStruct-> false);
            copy ImplDecl (loc, comm, trait_, content-> content)
        } else if (next == Tokens::COMA) {
            let mut impls : [mut &Declaration] = [];
            impls ~= [copy ImplDecl (loc, comm, trait_)];
            loop {
                let tr = self:.readExpression ();
                let (n, _) = self:.readTokens (Tokens::SEMI_COLON, Tokens::COMA);
                impls ~= [copy ImplDecl (loc, comm, tr)];
                if (n == Tokens::SEMI_COLON) break;
            }

            copy BlockDecl (loc, comm, impls)
        } else {
            copy ImplDecl (loc, comm, trait_)
        }
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================             ENUM             =========================
     * ================================================================================
     * ================================================================================
     */


    /**
     * Read an enumeration definition
     * @verbatim:
     * =======================
     * enum_decl :=   Keys::ENUM Keys::IF expression:(0) enum_content Keys::ARROW Identifier template_param_list (Tokens::SEMI_COLON)?
     *              | Keys::ENUM enum_content Keys::ARROW Identifier (Tokens::SEMI_COLON)?
     *
     * enum_content := (Tokens::PIPE Identifier ('=' expression:(0))?)*
     * =======================
     */
    fn readEnum (mut self,  loc : &Word, comm : [c8])-> &Declaration
        throws ErrorMsg
    {
        let (hasTest, test) = self:.readTemplateTest ();

        let type = if (!((self:.readIf (Tokens::COLON))._0).isEof ()) {
            self:.readOperand3 ()
        } else { EMPTY_EXPR }

        let mut values : [mut &VarDeclExpr] = [];
        let mut coms : [[c8]] = [];
        let mut fst = true;
        loop {
            let (n, com) = self:.readTokens (Tokens::PIPE, Tokens::ARROW);
            if (!fst) coms ~= [com];

            if (n != Tokens::ARROW) {
                let (name, _) = self:.readIdentifier (canBeSelf-> false);
                if (!(self:.readIf (Tokens::EQUAL)._0).isEof ()) {
                    values ~= [copy VarDeclExpr (name, name, value-> self:.readExpression (level-> self._specials.binaryOperators.len), type-> EMPTY_EXPR)]
                } else {
                    values ~= [copy VarDeclExpr (name, name, value-> EMPTY_EXPR, type-> EMPTY_EXPR)]
                }
            } else break;

            fst = false;
        }

        let (name, _) = self:.readIdentifier (canBeSelf-> false);
        let (templates, tmpErr) = self:.readTemplateParameters (ifLoc-> hasTest);

        {
            self:.readTokens (Tokens::SEMI_COLON);
        } catch {
            err : &ErrorMsg => throw err.appendNotes (notes-> tmpErr);
        }

        let en = copy EnumDecl (name, comm, type-> type, values-> values, fieldComms-> coms);
        if (templates.len == 0us) {
            en
        } else {
            copy TemplateDecl (loc, comm, templates, test-> test, content-> en)
        }
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================           FUNCTION           =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Read a function definition
     * @verbatim:
     * ====================
     * function :=   Keys::IF expression:(0) Identifier template_param_list function_proto throwers body
     *             | Identifier function_proto throwers body
     * ====================
     */
    fn readFunction (mut self,  _ : &Word, comm : [c8], attribs : [AttributeWord], isMethod : bool = false, isOver : bool = false)-> &Declaration
        throws ErrorMsg
    {
        let (hasTest, test) = self:.readTemplateTest ();
        let (name, _) = self:.readIdentifier (canBeSelf-> false);
        if (name == Keys::SELF) throw copy ErrorMsg::fatal (name, format (SyntaxErrorMessage::USED_AS_IDENTIFIER, name.str));
        let (templates, tmpErr) = self:.readTemplateParameters (ifLoc-> hasTest);

        let proto = self:.readFunctionPrototype (isClosure-> false, isClass-> isMethod, tmpError-> tmpErr);
        let (throwLoc, throwers) = self:.readThrowers ();
        let body = self:.readFunctionBody ();

        let func = copy FunctionDecl (name, comm, proto, body, attrs-> attribs, throwers-> throwers, isOver-> isOver, throwerLoc-> throwLoc);
        if (templates.len == 0us) {
            func
        } else {
            copy TemplateDecl (name, comm, templates, test-> test, content-> func)
        }
    }

    /**
     * Read a function body
     * @verbatim:
     * ===================
     * body := ';' | expression:(0)
     * ===================
     */
    fn readFunctionBody (mut self)-> &Expression
        throws ErrorMsg
    {
        if ((self:.readIf (Tokens::SEMI_COLON)._0).isEof ()) {
            self:.readExpression ()
        } else {
            EMPTY_EXPR
        }
    }

    /**
     * Read a function prototype
     * @verbatim:
     * ====================
     * closure_proto := Tokens::PIPE (var_decl (',' var_decl)*)? Tokens::PIPE (Tokens::ARROW expression:(0))?
     * function_proto := Tokens::LPAR (var_decl (',' var_decl)*)? Tokens::RPAR (Tokens::ARROW expression:(0))?
     * ====================
     */
    fn readFunctionPrototype (mut self, tmpError : [&ErrorMsg] = [], isClosure : bool = false, isClass : bool = false)-> &FunctionProtoDecl
        throws ErrorMsg
    {
        let (loc, hasParams) = {
            if isClosure {
                let (n, _) = self:.readTokens (Tokens::PIPE, Tokens::DPIPE);
                (n, n == Tokens::PIPE)
            } else { (self:.readTokens (Tokens::LPAR)._0, true) }
        } catch {
            err : &ErrorMsg => throw err.appendNotes (notes-> tmpError);
        };

        let mut isVariadic = false;
        let mut params : [mut &VarDeclExpr] = [];
        if hasParams {
            loop {
                if (isClosure) {
                    if ((self:.readIf (Tokens::PIPE)._0).isEof ()) {
                        params ~= [self:.readSingleVarDeclaration (mandType-> false, withValue-> false, isClass-> false)];
                        if ((self:.readTokens (Tokens::PIPE, Tokens::COMA)._0) == Tokens::PIPE) break;
                    } else break;
                } else {
                    let tok = if (!isClass || params.len > 0us) {
                        self:.readIf (Tokens::RPAR, Tokens::TDOT)._0
                    } else { EOF_WORD }

                    if (tok == Tokens::TDOT) {
                        isVariadic = true;
                        self:.readTokens (Tokens::RPAR);
                        break;
                    } else if (tok != Tokens::RPAR) {
                        params ~= [self:.readSingleVarDeclaration (mandType-> true, withValue-> true, isClass-> (isClass && params.len == 0us))];
                        if ((self:.readTokens (Tokens::RPAR, Tokens::COMA)._0) == Tokens::RPAR) break;
                    } else break;
                }
            }
        }

        if (!(self:.readIf (Tokens::ARROW)._0).isEof ()) {
            copy FunctionProtoDecl (loc, params-> params, retType-> self:.readExpression (), isVariadic-> isVariadic, forLambda-> isClosure)
        } else {
            copy FunctionProtoDecl (loc, params-> params, retType-> EMPTY_EXPR, isVariadic-> isVariadic, forLambda-> isClosure)
        }
    }

    /**
     * Read the list of throwers of a function
     * @verbatim:
     * ====================
     * throwers: (Keys::THROWS expression:(0) (',' expression:(0))*)?
     * ====================
     */
    fn readThrowers (mut self)-> (&Word, [&Expression])
        throws ErrorMsg
    {
        let (th, _) = self:.readIf (Keys::THROWS);
        let mut res : [mut &Expression] = [];
        if (!th.isEof ()) {
            loop {
                res ~= [self:.readExpression ()];
                let (n, _) = self:.readIf (Tokens::COMA);
                if (n.isEof ()) break;
            }
        }

        (th, res)
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================            GLOBAL            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Read a global var declaration
     * @verbatim:
     * ====================
     * global := var_decl
     * ====================
     */
    fn readGlobal (mut self,  loc : &Word, comm : [c8], isField : bool = false, isStatic : bool = false, forceType : bool = false, attribs : [AttributeWord])-> &GlobalDecl
        throws ErrorMsg
    {
        let (_, isMutOrDmut) = self:.readDecoratorVariable (canBeLazyOrRef-> false);
        let name = self:.readIdentifier (canBeSelf-> false)._0;

        let type = if (forceType) {
            self:.readTokens (Tokens::COLON);
            self:.readExpression (level-> self._specials.binaryOperators.len)
        } else if (self:.readIf (Tokens::COLON)._0 == Tokens::COLON) {
            self:.readExpression (level-> self._specials.binaryOperators.len)
        } else {
            EMPTY_EXPR
        };

        let value = if (self:.readIf (Tokens::EQUAL)._0 == Tokens::EQUAL) {
            self:.readExpression (level-> 0us)
        } else {
            EMPTY_EXPR
        };

        let overLazyOrRef = if (!isStatic && !isField) {
            copy Word (Keys::LAZY, loc)
        } else {
            EOF_WORD
        };

        let inner = copy VarDeclExpr (name, name,
                                      isMutOrDmut-> isMutOrDmut,
                                      isLazyOrRef-> overLazyOrRef,
                                      value-> value,
                                      type-> type);

        let glb = copy GlobalDecl (loc, comm, inner, isField-> isField, isStatic-> isStatic, attrs-> attribs);
        self:.readTokens (Tokens::SEMI_COLON);

        glb
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================            EXTERN            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Read an extern declaration
     * @verbatim:
     * ====================
     * extern: Keys::EXTERN (Tokens::LPAR Language (Tokens::COMA path)? Tokens::RPAR)? decl_block
     * ====================
     */
    fn readExtern (mut self,  loc : &Word, comm : [c8], attribs : (&Word, [AttributeWord]))-> &ExternBlockDecl
        throws ErrorMsg
    {
        let (n, _) = self:.readIf (Tokens::LPAR);
        let (language, space) = if (!n.isEof ()) {
            let (l, _) = self:.readTokens (Keys::CLANG);
            let space = if (!(self:.readIf (Tokens::COMA)._0).isEof ()) {
                self:.readPath ()
            } else { EMPTY_EXPR }
            self:.readTokens (Tokens::RPAR);
            (l, space)
        } else { (copy Word (Keys::YLANG, loc), EMPTY_EXPR) }

        let (tok, _) = self:.readIf (Tokens::LACC);
        if (tok.isEof ()) {
            copy ExternBlockDecl (loc, comm, language, space, self:.readDeclaration (comm-> comm, attribs-> attribs))
        } else {
            self.checkNoAttributes (tok, attribs._0, attribs._1);
            copy ExternBlockDecl (loc, comm, language, space, self:.readBlockDecl (loc, comm, closing-> true, inProtection-> true))
        }
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================            MACRO             =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Read a macro declaration
     * @verbatim:
     * ==================
     * macro := Keys::MACRO Identifier macro_block
     * ==================
     */
    fn readMacro (mut self,  _ : &Word, comm : [c8])-> &MacroDecl
        throws ErrorMsg
    {
        let (name, _) = self:.readIdentifier (canBeSelf-> false);
        self:.readTokens (Tokens::LACC);
        copy MacroDecl (name, comm, self:.readMacroBlock ())
    }



    /**
     * Read the content of a macro
     * @verbatim:
     * =================
     * macro_block := Tokens::LACC (public_macro_block | version_macro_block)* Tokens::RACC
     * =================
     */
    fn readMacroBlock (mut self) -> [&Declaration]
        throws ErrorMsg
    {
        let mut decls : [mut &Declaration] = [];
        loop {
            let (n, comm) = self:.readIf (Keys::VERSION, Keys::USE, Tokens::RACC);
            match n {
                Tokens::RACC => { break; }
                Keys::VERSION => {
                    decls ~= [self:.readVersionMacroBlock (n, comm)];
                }
                Keys::USE => {
                    decls ~= [self:.readUse (n, comm)];
                }
                _ => {
                    decls ~= [self:.readMacroContent ()];
                }
            }
        }

        decls
    }

    /**
     * Visit a version part of a macro block
     * @verbatim:
     * ======================
     * version_macro_block := Keys::VERSION Identifier macro_block (Keys::ELSE macro_block)
     * ======================
     */
    fn readVersionMacroBlock (mut self, loc : &Word, comm : [c8])-> &Declaration
        throws ErrorMsg
    {
        let (ident, _) = self:.readIdentifier (canBeSelf-> false);
        if (state::instance ().isVersionActive (ident.str)) {
            self:.readTokens (Tokens::LACC);
            let decls = self:.readMacroBlock ();
            if (!(self:.readIf (Keys::ELSE)._0).isEof ()) {
                self:.ignoreBlock ();
            }

            copy BlockDecl (loc, comm, decls, protection-> Protection::PUBLIC)
        } else {
            self:.ignoreBlock ();
            if (!(self:.readIf (Keys::ELSE)._0).isEof ()) {
                self:.readTokens (Tokens::LACC);
                let decls = self:.readMacroBlock ();
                copy BlockDecl (loc, comm, decls, protection-> Protection::PUBLIC)
            } else {
                copy BlockDecl (loc, comm, [])
            }
        }
    }

    /**
     * Read the content of a macro definition
     * @verbatim:
     * =================
     * marco_content := macro_constructor | macro_rule
     * =================
     */
    fn readMacroContent (mut self) -> &Declaration
        throws ErrorMsg
    {
        let (type, comm) = self:.readTokens (Keys::FUNCTION, Keys::SELF);
        match type {
            Keys::FUNCTION => {
                self:.readMacroRule (type, comm)
            }
            _ => self:.readMacroConstructor (type, comm)
        }
    }

    /**
     * Read a macro rule
     * @verbatim:
     * ===============
     * macro_rule := Keys::FUNCTION Identifier macro_head_rule (Tokens::SEMI_COLON | macro_body_rule)
     * ===============
     */
    fn readMacroRule (mut self, _ : &Word, comm : [c8]) -> &Declaration
        throws ErrorMsg
    {
        let (name, _) = self:.readIdentifier (canBeSelf-> false);
        let (head, skips) = self:.readMacroRuleHead ();

        let (bodyLoc, body) = if (self:.readIf (Tokens::SEMI_COLON)._0.isEof ()) {
            self:.readMacroRuleBody ()
        } else { (EOF_WORD, "") }

        copy MacroRuleDecl (name, comm, bodyLoc, body, head, skips-> skips, isConstructor-> false)
    }


    /**
     * Read a macro constructor
     * @verbatim:
     * ==================
     * macro_constructor := Keys::SELF macro_head_rule macro_body_rule
     * ==================
     */
    fn readMacroConstructor (mut self, loc : &Word, comm : [c8]) -> &Declaration
        throws ErrorMsg
    {
        let (head, skips) = self:.readMacroRuleHead ();
        let (bodyLoc, body) = self:.readMacroRuleBody ();

        copy MacroRuleDecl (loc, comm, bodyLoc, body, head, skips-> skips, isConstructor-> true)
    }


    /**
     * Read the head (prototype) of a macro rule (or constructor)
     * @verbatim:
     * =================
     * macro_rule_head :=  macro_inner_mult (Keys::SKIPS string_lit (Tokens::PIPE string_lit)*)?
     * =================
     */
    fn readMacroRuleHead (mut self)-> (&MacroMultExpr, [&Expression])
        throws ErrorMsg
    {
        let (start, end, inner) = self:.readInnerMacroMult ();

        let mut skips : [mut &Expression] = [];
        if (!(self:.readIf (Keys::SKIPS)._0).isEof ()) {
            self:.readTokens (Tokens::LPAR);
            loop {
                let str = self:.readString (forceDouble-> true);
                match str {
                    s : &StringExpr => {
                        skips ~= [copy MacroTokenExpr (s.getLoc (), s)];
                    }
                    _ => panic;
                }

                if (self:.readTokens (Tokens::RPAR, Tokens::PIPE)._0 == Tokens::RPAR) break;
            }
        }

        (copy MacroMultExpr (start, end, inner), skips)
    }


    /**
     * Read the body of a macro rule (or constructor)
     * @verbatim:
     * ================
     * marco_rule_body := Tokens::LACC Any* Tokens::RACC
     * ================
     */
    fn readMacroRuleBody (mut self)-> (&Word, [c8])
        throws ErrorMsg
    {
        let (start, _) = self:.readTokens (Tokens::LACC);
        let (res, closing) = self._lex:.getString (closing-> Tokens::RACC, opening-> copy [Tokens::LACC, Tokens::MACRO_ACC]);
        if (closing.isEof ()) {
            throw copy ErrorMsg::fatal (closing, SyntaxErrorMessage::BLOCK_NEVER_CLOSED, notes-> copy [copy ErrorMsg::note (start, SyntaxErrorMessage::IN_DECL_BLOCK)]);
        }

        (start, res)
    }


    /**
     * Read the inner part of a macro mutliplicator
     * @verbatim:
     * ==================
     * macro_inner_mult := Tokens::LPAR ((macro_expression*) | (macro_expression (Tokens::PIPE macro_expression)*) Tokens::RPAR
     * ==================
     */
    fn readInnerMacroMult (mut self)-> (&Word, &Word, [&MacroRuleExpression])
        throws ErrorMsg
    {
        let (start, _) = self:.readTokens (Tokens::LPAR);

        let mut fst = self:.readMacroExpression ();
        let (n, _) = self:.readIf (Tokens::PIPE, Tokens::RPAR);
        if (n.str == Tokens::RPAR) return (start, n, copy [fst]);
        else if (n.str == Tokens::PIPE) { // a list of pipes i.e. /(a | b | c)/
            let mut end = EOF_WORD;
            loop {
                let next = self:.readMacroExpression ();
                fst = copy MacroOrExpr (n, fst, next);
                end = self:.readTokens (Tokens::PIPE, Tokens::RPAR)._0;
                if (end == Tokens::RPAR) break;
            }

            return (start, end, copy [fst]);
        }

        // a simple list, i.e. (a b c)
        let mut inner : [mut &MacroRuleExpression] = copy [fst];
        let mut end = EOF_WORD;
        loop {
            inner ~= [self:.readMacroExpression ()];
            end = self:.readIf (Tokens::RPAR)._0;
            if (!end.isEof ()) break;
        }

        (start, end, inner)
    }


    /**
     * Read a macro rule expression
     * @verbatim:
     * =================
     * macro_expression :=   macro_inner_mult (Multiplicator)?
     *                     | Identifier (Tokens::EQUAL macro_expression)?
     *                     | String
     * =================
     */
    fn readMacroExpression (mut self)-> &MacroRuleExpression
        throws ErrorMsg
    {
        let (n, _) = self:.readIf (Tokens::LPAR);
        if (n == Tokens::LPAR) {
            self._lex:.rewind ();
            let (start, end, inner) = self:.readInnerMacroMult ();
            let (mult, _) = self:.readIf (self._specials.macroMult);
            copy MacroMultExpr (start, end, inner, mult-> mult)
        } else {
            let (ident, _) = self:.readIfIdentifier (canBeSelf-> false);
            if (ident.isEof ()) {
                let str = self:.readString (forceDouble-> true);
                match str {
                    s : &StringExpr => { copy MacroTokenExpr (s.getLoc (), s) }
                    _ => panic;
                }
            } else {
                if (self:.readIf (Tokens::EQUAL)._0.isEof ()) {
                    copy MacroIdentExpr (ident)
                } else {
                    let (rule, _) = self:.readIfIdentifier (canBeSelf-> false);
                    let inner = if (!rule.isEof ()) {
                        copy MacroIdentExpr (rule)
                    } else {
                        self:.readMacroExpression ()
                    };

                    copy MacroVarExpr (ident, inner)
                }
            }
        }
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================            MODULE            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Read a use declaration
     * */
    fn readUse (mut self, loc : &Word, comm : [c8])-> &Declaration
        throws ErrorMsg
    {
        let (fst, _) = self:.readIdentifier (canBeSelf-> false);
        let mut res : [mut &Expression] = [];
        self:.readComplexPath (copy VarExpr (fst), ref res);
        self:.readTokens (Tokens::SEMI_COLON);

        copy BlockDecl (loc,
                        comm,
                        copy [copy UseDecl (loc, comm, i) for i in res],
                        isSet-> true)
    }

    /**
     * Read a local module
     * @verbatim:
     * =====================
     * local_module :=   Keys::MOD Keys::IF expression:(0) Identifier template_param_list decl_block
     *                 | Keys::MOD Identifier decl_block
     *                 | Keys::MOD Identifier Tokens::SEMI_COLON
     * =====================
     */
    fn readLocalModuleDecl (mut self, loc : &Word, comm : [c8])-> &Declaration
        throws ErrorMsg
    {
        let (hasTest, test) = self:.readTemplateTest ();
        let isSub = if (hasTest.isEof ()) {
            self:.readIf (Tokens::DCOLON, Tokens::DOT)._0
        } else {
            EOF_WORD
        };

        let (ident, _) = self:.readIdentifier (canBeSelf-> false);

        let end = if (!hasTest.isEof ()) {
            EOF_WORD
        } else if (isSub.isEof ()) {
            self:.readIf (Tokens::SEMI_COLON, Tokens::COMA)._0
        } else {
            self:.readTokens (Tokens::SEMI_COLON, Tokens::COMA)._0
        };

        if (!end.isEof ()) {
            if (end == Tokens::COMA) {
                let mut im : [mut &Declaration] = [];
                im ~= [copy ImportDecl (loc, "", ident, isSub-> isSub)];
                loop {
                    let (innerIsSub, _) = self:.readIf (Tokens::DCOLON, Tokens::DOT);
                    let (current, _) = self:.readIdentifier (canBeSelf-> false);
                    im ~= [copy ImportDecl (loc, "", current, isSub-> innerIsSub)];
                    if (self:.readTokens (Tokens::SEMI_COLON, Tokens::COMA)._0 == Tokens::SEMI_COLON) break;
                }

                copy BlockDecl (loc, comm, im, isSet-> true)
            } else {
                copy ImportDecl (loc, comm, ident, isSub-> isSub)
            }
        } else {
            let (templates, tmpErr) = self:.readTemplateParameters (ifLoc-> hasTest);

            let (n, comm_) = {
                self:.readTokens (Tokens::LACC)
            } catch {
                err : &ErrorMsg => throw err.appendNotes (notes-> tmpErr);
            };

            let content = self:.readBlockDecl (n, comm_, closing-> true, inProtection-> false);

            if (templates.len == 0us) {
                copy ModuleDecl (ident, EOF_WORD, comm, content, isGlobal-> false)
            } else {
                copy TemplateDecl (ident, comm, templates, test-> test,
                                   copy ModuleDecl (ident, EOF_WORD, comm, content, isGlobal-> false))
            }
        }
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================            TRAIT             =========================
     * ================================================================================
     * ================================================================================
     */


    /**
     * Visit a trait declaration
     * @verbatim:
     * =================
     * trait_decl :=   Keys::TRAIT Keys::IF expression:(0) Identifier template_param_list class_block_decl
     *               | Keys::TRAIT Identifier class_block_decl
     * =================
     */
    fn readTrait (mut self,  _ : &Word, comm : [c8])-> &Declaration
        throws ErrorMsg
    {

        let (hasTest, test) = self:.readTemplateTest ();
        let (name, _) = self:.readIdentifier (canBeSelf-> false);
        let (templates, tmpErr) = self:.readTemplateParameters (ifLoc-> hasTest);

        {
            self:.readTokens (Tokens::LACC);
            let decls = self:.readClassBlockDecl (inImpl-> true, isStruct-> false, closing-> true, inProtection-> false);

            let tra = copy TraitDecl (name, comm, decls);

            if (templates.len == 0us) {
                tra
            } else {
                copy TemplateDecl (name, comm, templates, test-> test, tra)
            }

        } catch {
            err : &ErrorMsg => throw err.appendNotes (notes-> tmpErr);
        }
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================           UNITTEST           =========================
     * ================================================================================
     * ================================================================================
     */


    /**
     * Visit a unittest declaration
     * @verbatim:
     * ==================
     * unittest := Keys::UNITTEST expression:(0)
     * ==================
     */
    fn readUnitTest (mut self, loc : &Word, comm : [c8])-> &Declaration
        throws ErrorMsg
    {
        copy UnitTestDecl (loc, comm, self:.readExpression ())
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================           TEMPLATE           =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Read a list of template parameters
     * @params:
     *    - ifLoc: the location of the if test, if not eof, has to read the list, can't return an empty list
     * @throws:
     *    - ErrorMsg: if !ifLoc.isEof (), but there is no list to read
     */
    fn readTemplateParameters (mut self, ifLoc : &Word, force : bool = false)-> ([&Expression], [&ErrorMsg])
        throws ErrorMsg
    {
        let (begin, _) = if (!ifLoc.isEof () || force) {
            let (x, c) = self._lex:.next ();
            if (x != Tokens::LACC) {
                throw copy ErrorMsg::fatal (x, format (SyntaxErrorMessage::UNEXPECTED_BUT_LST, x.str, Tokens::LACC),
                                            notes-> copy [copy ErrorMsg::note (ifLoc, SyntaxErrorMessage::IF_NON_TEMPLATE)]);
            }
            (x, c)
        } else {
            self:.readIf (Tokens::LACC)
        };

        if (!begin.isEof ()) { // there are templates to read
            let mut vec : [mut &Expression] = [];
            loop {
                let (curr, _) = self._lex:.next ();
                match curr.str {
                    Keys::STRUCT | Keys::CLASS | Keys::ALIAS | TemplateVarType::TUPLE | Keys::RECORD => {
                        let (ident, _) = self:.readIdentifier (canBeSelf-> false);
                        vec ~= [copy TemplateVarExpr (ident, self.toTemplateVarType (curr.str))];
                    }
                    _ => {
                        self._lex:.rewindToSeek (cursor-> curr.seek);
                        if self.isIdentifier (curr.str, canBeSelf-> false) {
                            vec ~= [self:.readTemplateVarParamWithNext ()];
                        } else {
                            vec ~= [self:.readOperand3 ()];
                        }
                    }
                }

                let (token, _) = self:.readTokens (Tokens::RACC, Tokens::COMA);
                if (token.str == Tokens::RACC) break;
            } catch {
                err : &ErrorMsg => {
                    self._lex:.rewindToSeek (begin.seek);
                    if (!ifLoc.isEof () || force) {
                        throw err.withNote (notes-> copy [copy ErrorMsg::note (ifLoc, SyntaxErrorMessage::IF_NON_TEMPLATE)]);
                    }

                    return ([], copy [err]);
                }
            }

            return (vec, []);
        }

        ([], [])
    }

    /**
     * Read an expression that checks template specialization
     * @verbatim:
     * ===============
     * template_var_decl_with_next :=    Identifier (Tokens::COLON expression:0)? (Tokens::EQUAL expression:0)?
     *                               |  Identifier (Keys::OF | Keys::OVER | Keys::IMPL) expression:0 (Tokens::DAND Identifier (Keys::OF | Keys::OVER | Keys::IMPL) expression:0)?
     *                               |  Identifier (Tokens::COLON)?  Tokens::TDOT
     *                               |  expression:0
     * ===============
     */
    fn readTemplateVarParamWithNext (mut self)-> &Expression
        throws ErrorMsg
    {
        let mut inners : [mut &TemplateOfVarExpr] = [];
        let mut name = EOF_WORD;

        loop {
            let z = if (inners.len == 0us) {
                let (x, y) = self:.readTemplateVarParam ();
                if (!y) return x; // cannot &&
                match x {
                    z : &TemplateOfVarExpr => {
                        name = z.getLoc ();
                        z
                    }
                    _ => return x; // ??, but cannot && anyway
                }
            } else {
                let (innerNext, _) = self:.readTokens (Keys::OVER, Keys::OF, Keys::IMPL);
                let k = self.toTemplateOfVarType (innerNext.str);
                copy TemplateOfVarExpr (copy Word (format ("%.%", name.str, inners.len), innerNext),
                                        self:.readExpression (level-> self._specials.binaryOperators.len),
                                        kind-> k)
            };

            inners ~= [z];

            let (n, _) = self:.readIf (Tokens::DAND);
            if (n.isEof ()) break;
        }

        if inners.len == 1us { return inners [0]; }
        let z : &TemplateOfVarExpr = inners [0];
        inners [0] = copy TemplateOfVarExpr (copy Word (format ("%.0", z.getLoc ().str), z.getLoc ()),
                                             z.getSpecialization (),
                                             z.getKind ());

        copy TemplateAndExpr (name, inners)
    }

    /**
     * Read an expression that might be a variable inside a list of template parameters
     * @verbatim:
     * ===============
     * template_var_decl :=    Identifier (Tokens::COLON expression:0)? (Tokens::EQUAL expression:0)?
     *                      |  Identifier (Keys::OF | Keys::OVER | Keys::IMPL) expression:0
     *                      |  Identifier (Tokens::COLON)?  Tokens::TDOT
     *                      |  expression:0
     * ===============
     */
    fn readTemplateVarParam (mut self) -> (&Expression, bool)
        throws ErrorMsg
    {
        let (name, _) = self:.readIdentifier (canBeSelf-> false);
        let (next, _) = self:.readIf (cast![c8] (Tokens::COLON), Tokens::TDOT,
                                      Tokens::EQUAL, Keys::OVER, Keys::OF,
                                      Keys::IMPL);

        match next.str {
            Tokens::COLON => {
                let (tok, _) = self:.readIf (Tokens::TDOT);
                if (tok.isEof ()) { // V : type ('=' value)?
                    let type = self:.readExpression (level-> self._specials.binaryOperators.len);
                    if (!(self:.readIf (Tokens::EQUAL)._0).isEof ()) { // '=' value
                        return (copy VarDeclExpr (name, name, value-> self:.readExpression (), type-> type), false);
                    } else return (copy VarDeclExpr (name, name, value-> EMPTY_EXPR, type-> type), false);
                } else return (copy TemplateVariadicVarExpr (name, isValue-> true), false); // V:...
            }
            Tokens::EQUAL => {
                return (copy VarDeclExpr (name, name, value-> self:.readExpression (), type-> EMPTY_EXPR), false);
            }
            Tokens::TDOT  => {
                return (copy TemplateVariadicVarExpr (name, isValue-> false), false);
            }
            Keys::OVER | Keys::OF | Keys::IMPL => {
                let k = self.toTemplateOfVarType (next.str);
                return (copy TemplateOfVarExpr (name, self:.readExpression (level-> self._specials.binaryOperators.len), kind-> k), true);
            }
        }

        self._lex:.rewindToSeek (cursor-> name.seek);
        return (self:.readExpression (), false);
    }

    /**
     * Read a template test (if anyl
     * @returns:
     *   - the location of the if token, (or eof)
     *   - the test expression, or Unit
     */
    fn readTemplateTest (mut self)-> (&Word, &Expression)
        throws ErrorMsg
    {
        let (hasTest, _) = self:.readIf (Keys::IF);
        if hasTest.isEof () {
            (hasTest, EMPTY_EXPR)
        } else {
            (hasTest, self:.readExpression (level-> self._specials.binaryOperators.len))
        }
    }


    /*!
     * ================================================================================
     * ================================================================================
     * =========================          ATTRIBUTES          =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Read a list of custom attributes, if the token Tokens::AT is not read, then an empty list is returned
     * @verbatim:
     * =================
     * attributes_lst :=   Tokens::AT Keys::LACC Attribute (Tokens::COMA Attribute)* Keys::RACC
     *                   | Tokens::AT Attribute
     * =================
     */
    fn readAttributes (mut self)-> (&Word, [AttributeWord], [c8])
        throws ErrorMsg
    {
        let (next, comm) = self:.readIf (Tokens::AT);
        if (next.isEof ()) return (EOF_WORD, [], []);

        let (open, _) = self:.readIf (Tokens::LACC);
        let mut vec : [mut AttributeWord] = [];
        loop {
            let (identifier, _) = self:.readTokens (expand Attributes::__members__);
            for j in vec {
                if j.attr == identifier {
                    throw copy ErrorMsg::fatal (j.loc, end-> identifier, format (SyntaxErrorMessage::MULTIPLE_ATTRS, j.attr));
                }
            }

            match identifier {
                Attributes::ABSTRACT => { vec ~= [AttributeWord (identifier, Attributes::ABSTRACT)]; }
                Attributes::FINAL    => { vec ~= [AttributeWord (identifier, Attributes::FINAL)]; }
                Attributes::UNSAFE   => { vec ~= [AttributeWord (identifier, Attributes::UNSAFE)]; }
                Attributes::INLINE   => { vec ~= [AttributeWord (identifier, Attributes::INLINE)]; }
                Attributes::FIELD    => { vec ~= [AttributeWord (identifier, Attributes::FIELD)]; }
                Attributes::THREAD   => { vec ~= [AttributeWord (identifier, Attributes::THREAD)]; }
                _ => {
                    throw copy ErrorMsg::fatal (identifier, format (SyntaxErrorMessage::UNDEFINED_ATTRIBUTE, identifier.str));
                }
            }

            if (open.isEof ()) {
                let (at,_) = self:.readIf (Tokens::AT);
                if (at.isEof ()) break;
            } else {
                let (close, _) = self:.readTokens (Tokens::COMA, Tokens::RACC);
                if (close.str == Tokens::RACC) break;
            }
        }  catch {
            err : &ErrorMsg => {
                if (!open.isEof ()) {
                    throw err.appendNotes (copy [copy ErrorMsg::note (open, SyntaxErrorMessage::IN_DECL_BLOCK)]);
                } else throw err;
            }
        }

        (next, vec, comm)
    }

    /**
     * Throw a syntax error if there are attributes in a wrong position
     * */
    fn checkNoAttributes (self, loc : &Word, attrLoc : &Word, attribs : [AttributeWord])
        throws ErrorMsg
    {
        if (!attrLoc.isEof ()) {
            if (!loc.isEof ()) {
                throw copy ErrorMsg::fatal (attrLoc, format (SyntaxErrorMessage::UNEXPECTED_ATTRIBUTES, copy [x.attr for x in attribs]),
                                            notes-> copy [copy ErrorMsg::note (loc, "")]);
            } else {
                throw copy ErrorMsg::fatal (attrLoc, format (SyntaxErrorMessage::UNEXPECTED_ATTRIBUTES, copy [x.attr for x in attribs]));
            }
        }
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================         EXPRESSIONS          =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Read an expression
     * @verbatim:
     * ==================
     * expression:(level) := expression:(level+1) (binary_operator:(level) expression:(level))?
     * expression:(10) := operand:(0)
     * ==================
     */
    pub fn readExpression (mut self, level : usize = 0us)-> &Expression
        throws ErrorMsg
    {
        if (cast!usize (level) == self._specials.binaryOperators.len) {
            self:.readOperand0 ()
        } else {
            let left = self:.readExpression (level-> level + 1);
            self:.readExpressionFollow (left, level-> level)
        }
    }

    /**
     * Read the following of an expression (for operators)
     */
    fn readExpressionFollow (mut self, left : &Expression, level : usize = 0us)-> &Expression
        throws ErrorMsg
    {
        let (tok, _) = self:.readIf (self._specials.binaryOperators [level]);
        if (!tok.isEof ()) {
            let right = self:.readExpression (level-> level + 1us);
            self:.readExpressionFollow (copy BinaryExpr (tok, left, right), level-> level)
        } else if (level == 3us) {
            let (n, _) = self:.readIf (Tokens::NOT);
            if (!n.isEof ()) {
                let (op, _) = self:.readIf (self._specials.specialBinaryOperators);
                if (op.isEof ()) {
                    self._lex:.rewind ();
                    left
                } else {
                    let right = self:.readExpression (level-> level + 1us);
                    self:.readExpressionFollow (copy BinaryExpr (copy Word (n.str ~ op.str, n), left, right), level-> level)
                }
            } else { left }
        } else { left }
    }

    /**
     * Read a highest level operand
     * @verbatim:
     * ===================
     * operand:(0) := (unary_operator)? operand:(1) (Tokens::INTEG)?
     * ===================
     */
    pub fn readOperand0 (mut self) -> &Expression
        throws ErrorMsg
    {
        let (tok, _) = self:.readIf (self._specials.unaryOperators);
        let ret = if (!tok.isEof ()) {
            copy UnaryExpr (tok, self:.readOperand1 ())
        } else { self:.readOperand1 () }

        let (post, _) = self:.readIf (Tokens::INTEG);
        if (!post.isEof ()) {
            copy TryExpr (post, ret)
        } else { ret }
    }


    /**
     * Read an operand of level 1
     * @verbatim:
     * =================
     * operand:(1) :=   block
     *                | if_expr
     *                | while_expr
     *                | assert_expr
     *                | break_expr
     *                | dowhile_expr
     *                | for_expr
     *                | match_expr
     *                | vardecl
     *                | return_expr
     *                | function_expr
     *                | delegate_expr
     *                | loop_expr
     *                | throw_expr
     *                | version
     *                | pragma_expr
     *                | with_expr
     *                | atomic_expr
     *                | operand:(operand_follow)?
     * =================
     */
    fn readOperand1 (mut self)-> &Expression
        throws ErrorMsg
    {
        let (tok, _) = self:.readIf (Tokens::LACC, Keys::IF, Keys::WHILE, Keys::ASSERT,
                                     Keys::BREAK, Keys::DO, Keys::FOR, Keys::MATCH, Keys::FUTURE,
                                     Keys::LET, Keys::RETURN, Keys::FUNCTION, Keys::DELEGATE,
                                     Keys::LOOP, Keys::THROW, Keys::PANIC, Keys::VERSION, Keys::PRAGMA,
                                     Keys::ATOMIC, Keys::UNSAFE);

        match tok {
            Keys::LOOP     => { self:.readLoop (tok) }
            Keys::WHILE    => { self:.readWhile (tok) }
            Tokens::LACC   => { self:.readBlock (tok) }
            Keys::IF       => { self:.readIfExpression (tok) }
            Keys::ASSERT   => { self:.readAssert (tok) }
            Keys::BREAK    => { self:.readBreak (tok) }
            Keys::DO       => { self:.readDoWhile (tok) }
            Keys::FOR      => { self:.readFor (tok) }
            Keys::MATCH    => { self:.readMatch (tok) }
            Keys::LET      => { self:.readVarDeclaration (tok) }
            Keys::RETURN   => { self:.readReturn (tok) }
            Keys::FUNCTION => { self:.readFunctionType (tok) }
            Keys::DELEGATE => { self:.readFunctionType (tok) }
            Keys::FUTURE   => { self:.readFutureType (tok) }
            Keys::THROW    => { self:.readThrow (tok) }
            Keys::VERSION  => { self:.readVersionExpr (tok) }
            Keys::PRAGMA   => { self:.readPragma (tok) }
            Keys::ATOMIC   => { self:.readAtomic (tok) }
            Keys::UNSAFE   => { self:.readUnsafe (tok) }
            Keys::PANIC    => { self:.readPanic (tok) }
            _ => { self:.readOperandFollow (self:.readOperand2 (self:.readOperand3 ())) }
        }
    }


    /**
     * Read the follow-up of an operand
     * @verbatim:
     * =================
     * operand_follow :=   Tokens::LPAR param_list Tokens::RPAR (operand_follow)?
     *                   | Tokens::LCRO param_list Tokens::RCRO (operand_follow)?
     *                   | (Tokens::DOT | Tokens::DOT_AND) operand:(3) (template_call)? (operand_follow)?
     *                   | macro_call (operand_follow)?
     * =================
     */
    fn readOperandFollow (mut self, left : &Expression)-> &Expression
        throws ErrorMsg
    {
        let (n, _) = self:.readIf (Tokens::LPAR, Tokens::LCRO, Tokens::LCRO_AND, Tokens::MACRO_ACC, Tokens::MACRO_CRO, Tokens::MACRO_PAR, Tokens::DOT, Tokens::DOT_AND);
        match n {
            Tokens::LPAR | Tokens::LCRO | Tokens::LCRO_AND => {
                let (params, end) = self:.readArgumentList (withNamed-> true, closing-> if (n == Tokens::LPAR) { Tokens::RPAR } else { Tokens::RCRO });
                self:.readOperandFollow (copy MultOperatorExpr (n, end, left, params))
            }
            Tokens::MACRO_ACC | Tokens::MACRO_PAR | Tokens::MACRO_CRO => {
                self:.readOperandFollow (self:.readMacroCall (n, left))
            }
            Tokens::DOT | Tokens::DOT_AND => {
                let right = self:.readOperand3 (canBeTemplateCall-> false, canBeFloat-> false);
                self:.readOperandFollow (self:.readTemplateCall (copy BinaryExpr (n, left, right)))
            }
            _ => { left }
        }
    }


    /**
     * Read a level 2 operand
     * @verbatim:
     * ===============
     * operand:(2) := (Tokens::DCOLON template_call)?
     * ===============
     */
    fn readOperand2 (mut self, left : &Expression) -> &Expression
        throws ErrorMsg
    {
        let (n, _) = self:.readIf (Tokens::DCOLON);
        if (!n.isEof ()) {
            let right = self:.readOperand3 (canBeTemplateCall-> false);
            self:.readOperand2 (self:.readTemplateCall (copy BinaryExpr (n, left, right)))
        } else {
            left
        }
    }

    /**
     * Read a level 3 operand
     * @verbatim:
     * =================
     * operand:(3) :=   cast_expr
     *                | template_checker
     *                | array_lit
     *                | tuple_lit
     *                | lambda_lit
     *                | intrinsic
     *                | literal
     *                | decorated_expr
     *                | var
     * =================
     */
    fn readOperand3 (mut self, canBeTemplateCall : bool = true, canBeFloat : bool = true) -> &Expression
        throws ErrorMsg
    {
        let (n, _) = self:.readIf (Keys::CAST, Keys::IS, Keys::FUTURE, Tokens::LCRO, Tokens::LPAR, Tokens::PIPE, Tokens::DPIPE, Tokens::NOT);

        if (n == Tokens::NOT) {
            let (e, _) = self:.readIf(Keys::IS);
            if (!e.isEof ()) {
                return copy UnaryExpr (n, self:.readTemplateChecker (e));
            }

            self._lex:.rewind ();
        }

        match n {
            Keys::CAST                    => { return self:.readCast (n); }
            Keys::IS                      => { return self:.readTemplateChecker (n); }
            Tokens::LCRO                  => { return self:.readArray (n); }
            Tokens::LPAR                  => { return self:.readTuple (n); }
            Tokens::PIPE | Tokens::DPIPE  => { return self:.readLambda (n); }
        }

        let (i, _) = self:.readIf (self._specials.intrinsicKeys);
        if (!i.isEof ()) {
            let (p, _) = self:.readIf (Tokens::LPAR);
            let inner = if (p.isEof ()) {
                self:.readExpression (level-> self._specials.binaryOperators.len)
            } else { self:.readExpression () }

            let ret = copy IntrinsicExpr (i, self.toIntrinsic (i.str), inner);
            if (!p.isEof ()) self:.readTokens (Tokens::RPAR);
            return ret;
        }

        let (j, _) = self:.readIf (self._specials.decorators);
        if (!j.isEof ()) {
            let inner = self:.readExpression (level-> self._specials.binaryOperators.len);
            return copy DecoratedExpr (j, inner, j);
        }

        let (ident, _) = self:.readIfIdentifier (canBeSelf-> true);
        if (!ident.isEof ()) {
            self._lex:.rewind ();
            return self:.readVar (canBeTemplateCall-> canBeTemplateCall)
        }

        return self:.readLiteral (canBeFloat-> canBeFloat);
    }


    /**
     * Read a list of arguments
     * @params:
     *    - withNamed: if true, named expression are allowed in the argument list
     *    - closing: the token that closes the list
     * @verbatim:
     * ===================
     *
     * ===================
     */
    fn readArgumentList (mut self, withNamed : bool = false, closing : [c8] = Tokens::RPAR)-> ([&Expression], &Word)
        throws ErrorMsg
    {
        let mut vec : [mut &Expression] = [];
        let mut end = EOF_WORD;
        let (x, _) = self:.readIf (closing);
        if (!x.isEof ()) { end = x; }
        else {
            loop {
                if (withNamed) {
                    let mut read = false;
                    let (name, _) = self._lex:.next ();
                    if (self.isIdentifier (name.str, canBeSelf-> false)) {
                        let (arr, _) = self:.readIf (Tokens::ARROW);
                        if (!arr.isEof ()) {
                            vec ~= [copy NamedExpr (name, self:.readExpression ())];
                            read = true;
                        }
                    }

                    if !read {
                        self._lex:.rewindToSeek (name.seek);
                        vec ~= [self:.readExpression ()];
                    }
                } else {
                    vec ~= [self:.readExpression ()];
                }

                let (n, _) = self:.readTokens (closing, Tokens::COMA);
                if (n != Tokens::COMA) {
                    end = n;
                    break;
                }
            }
        }

        (vec, end)
    }


    /*!
     * ================================================================================
     * ================================================================================
     * =========================       VAR DECLARATION        =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Read the decorators in front a variable declaration
     * @returns:
     *    - .0: the lazy or ref decorator
     *    - .1: the mut or dmut decorator
     * */
    fn readDecoratorVariable (mut self, canBeLazyOrRef : bool = true)-> (&Word, &Word) {
        let mut isLazyOrRef = if (canBeLazyOrRef) {
            self:.readIf (Keys::LAZY, Keys::REF)._0
        } else {
            EOF_WORD
        };

        let isMutOrDmut = self:.readIf (Keys::MUTABLE, Keys::DMUTABLE)._0;
        if (isLazyOrRef.isEof () && !isMutOrDmut.isEof () && canBeLazyOrRef) {
            isLazyOrRef = self:.readIf (Keys::LAZY, Keys::REF)._0;
        }

        (isLazyOrRef, isMutOrDmut)
    }

    /**
     * Read a single var declaration
     * @params:
     *    - mandType: the type is mandatory
     *    - withValue: there can be a value
     *    - isClass: self is a valid Identifier
     *    - level: the level of the expression (only applicable if withValue)
     * @verbatim:
     * ==================
     * single_var_decl :=   (Decorator)* (Identifier | Keys::UNDER) (Tokens::COLON expression:(10))? (Tokens::EQUAL expression:(level))
     *                    | (Decorator)* Keys::SELF
     * ==================
     */
    fn readSingleVarDeclaration (mut self, mandType : bool = false, withValue : bool = true, mandValue : bool = false, isClass : bool = false, level : usize = 0us)-> &VarDeclExpr
        throws ErrorMsg
    {
        let (isLazyOrRef, isMutOrDmut) = self:.readDecoratorVariable (canBeLazyOrRef-> !isClass);
        let (ig, _) = self:.readIf (Keys::UNDER);
        let name = if (!ig.isEof ()) {
            ig
        } else { self:.readIdentifier (canBeSelf-> isClass)._0 }

        match name {
            Keys::SELF => {
                if (!isClass) throw copy ErrorMsg::fatal (name, format (SyntaxErrorMessage::USED_AS_IDENTIFIER, name.str));
                return copy VarDeclExpr (name, name, isMutOrDmut-> isMutOrDmut, value-> EMPTY_EXPR, type-> EMPTY_EXPR);
            }
        }


        if (isClass) throw copy ErrorMsg::fatal (name, format (SyntaxErrorMessage::UNEXPECTED_BUT_LST, name.str, Keys::SELF));
        let type = if (mandType) {
            self:.readTokens (Tokens::COLON);
            self:.readExpression (level-> self._specials.binaryOperators.len)
        } else if (!(self:.readIf (Tokens::COLON)._0).isEof ()) {
            self:.readExpression (level-> self._specials.binaryOperators.len)
        } else { EMPTY_EXPR }

        let value = if (withValue || mandValue) {
            if (mandValue) {
                self:.readTokens (Tokens::EQUAL);
                self:.readExpression (level-> level)
            } else if (!(self:.readIf (Tokens::EQUAL)._0).isEof ()) {
                self:.readExpression (level-> level)
            } else { EMPTY_EXPR }
        } else { EMPTY_EXPR };

        copy VarDeclExpr (name, name, isMutOrDmut-> isMutOrDmut, isLazyOrRef-> isLazyOrRef, value-> value, type-> type)
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================            BLOCKS            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Read a block of code
     * @verbatim:
     * ====================
     * block := Tokens::LACC ((n=expression:(0) (Tokens::SEMI_COLON)!if(self:.needClosingExpr (n))* (expression:(0))?) Tokens::RACC (scope_guards)?
     * ====================
     */
    fn readBlock (mut self, loc : &Word, canBeCatcher : bool = true)-> &Expression
        throws ErrorMsg
    {
        let mut decls : [mut &Declaration] = [];
        let mut content : [mut &Expression] = [];
        {
            let mut end = EOF_WORD;
            let mut last = false;
            loop {
                end = self:.readIf (Tokens::SEMI_COLON, Tokens::RACC)._0;
                if (end.isEof ()) {
                    if (!last && content.len != 0us) {
                        if (self.needClosingExpr (content [$ - 1us])) {
                            let (n, _) = self._lex:.next ();
                            throw copy ErrorMsg::fatal (n, format (SyntaxErrorMessage::UNEXPECTED_BUT_LST, n.str, Tokens::SEMI_COLON));
                        }
                    }

                    last = false;
                    let (attrLoc, attribs, attrComm) = self:.readAttributes ();
                    let (d, _) = self:.readIf (Keys::CLASS, Keys::ENUM, Keys::FUNCTION, Keys::USE, Keys::STRUCT, Keys::RECORD, Keys::TRAIT);
                    if (!d.isEof ()) {
                        self._lex:.rewind ();
                        decls ~= [self:.readDeclaration (comm-> attrComm, attribs-> (attrLoc, attribs))];
                        last = true;
                    } else {
                        self.checkNoAttributes (EOF_WORD, attrLoc, attribs);
                        content ~= [self:.readExpression ()];
                    }
                } else if (end == Tokens::SEMI_COLON) {
                    last = true;
                } else break;
            }

            let (catcher, scopes) = if (canBeCatcher) {
                self:.readScopeGuards ()
            } else { (EMPTY_EXPR, []) }

            if (last) content ~= [copy EmptyExpression (loc-> end)];
            if (decls.len != 0us) {
                copy BlockExpr (loc, end, module-> copy BlockDecl (copy Word (Keys::UNDER, loc), "", decls), content, catcher-> catcher, guards-> scopes)
            } else {
                copy BlockExpr (loc, end, content, catcher-> catcher, guards-> scopes)
            }
        } catch {
            err : &ErrorMsg => {
                if (!loc.isEof ()) {
                    throw copy ErrorMsg::note (loc, SyntaxErrorMessage::IN_DECL_BLOCK, notes-> copy [err]);
                } else throw err;
            }
        }
    }


    /**
     * Read scope guards
     * @verbatim:
     * ==================
     * scope_guards :=   Keys::EXIT block
     *                 | Keys::SUCCESS block
     *                 | Keys::FAILURE block
     *                 | catcher
     * ==================
     */
    fn readScopeGuards (mut self)-> (&Expression, [&ScopeGuardExpr])
        throws ErrorMsg
    {
        let mut catcher : &Expression = EMPTY_EXPR;
        let mut scopes : [mut &ScopeGuardExpr] = [];
        let mut seen : [[c8] => mut &Word] = copy [];
        loop {
            let (n, _) = self:.readIf (Keys::EXIT, Keys::SUCCESS, Keys::FAILURE, Keys::CATCH);
            if (!n.isEof ()) {
                if let Ok (val) = seen [n.str] {
                    throw copy ErrorMsg::fatal (n, end-> val, format (SyntaxErrorMessage::MULTIPLE_SAME_GUARD, n.str));
                }

                seen [n.str] = n;
            }

            if (n == Keys::CATCH) {
                catcher = self:.readCatcher (n);
            } else if (!n.isEof ()) {
                let (a, _) = self:.readTokens (Tokens::LACC);
                scopes ~= [copy ScopeGuardExpr (n, self:.readBlock (a, canBeCatcher-> false), kind-> self.toScopeGuard (n.str))];
            } else break;
        }

        (catcher, scopes)
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================          CONDITIONS          =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Read an If expression
     * @verbatim:
     * ======================
     * if_expr := Keys::IF expression:(0) ((expression:(0) (Tokens::SEMI_COLON)?) | (block)) (Keys::ELSE expression:(0))?
     * ======================
     */
    fn readIfExpression (mut self, loc : &Word)-> &Expression
        throws ErrorMsg
    {
        let (isLet, _) = self:.readIf (Keys::LET);
        let (test : &Expression, guard : &Expression) = if (isLet.isEof ()) {
            (self:.readExpression (), EMPTY_EXPR)
        } else {
            let vdecl = self:.readVarDeclaration (isLet, onlyOne-> true, level-> 3us);
            let guard = if (!self:.readIf (Tokens::DAND)._0.isEof ()) {
                self:.readExpression ()
            } else { EMPTY_EXPR };

            (vdecl, guard)
        };

        let mut content = self:.readExpression ();
        match content {
            BlockExpr () => {}
            _ => {
                let (tok, _) = self:.readIf (Tokens::SEMI_COLON);
                if (!tok.isEof ()) {
                    let mut inner = copy [content, EMPTY_EXPR];
                    content = copy BlockExpr (content.getLoc (), tok, content-> inner);
                }
            }
        }

        let (next, _) = self:.readIf (Keys::ELSE);
        if (!next.isEof ()) {
            let (n, _) = self:.readIf (Keys::IF);
            if (!n.isEof ()) return copy ConditionalExpr (loc, test, content, else_-> self:.readIfExpression (n), guard-> guard, isLet-> !isLet.isEof ());
            else {
                let mut el_content = self:.readExpression ();
                match el_content {
                    BlockExpr () => {}
                    _ => {
                        let (tok, _) = self:.readIf (Tokens::SEMI_COLON);
                        if (!tok.isEof ()) {
                            let mut inner : [mut &Expression] = copy [el_content, EMPTY_EXPR];
                            el_content = copy BlockExpr (content.getLoc (), tok, content-> inner);
                        }
                    }
                }

                return copy ConditionalExpr (loc, test, content, else_-> el_content, isLet-> !isLet.isEof (), guard-> guard);
            }
        }

        copy ConditionalExpr (loc, test, content, isLet-> !isLet.isEof (), guard-> guard)
    }


    /**
     * Read an atomic
     * @verbatim:
     * ==============
     * atomic_expr := Keys::ATOMIC (expression:(0))? Tokens::LACC expression:(0) Tokens::RACC
     * ==============
     */
    fn readAtomic (mut self, loc : &Word) -> &Expression
        throws ErrorMsg
    {
        let (n, _) = self:.readIf (Tokens::LACC);
        if (!n.isEof ()) {
            let content = self:.readBlock (n);
            return copy AtomicExpr (loc, content, monitor-> EMPTY_EXPR);
        } else {
            let monitor = self:.readExpression ();
            let (tok, _) = self:.readTokens (Tokens::LACC);
            let content = self:.readBlock (tok, canBeCatcher-> false);
            return copy AtomicExpr (loc, content, monitor-> monitor);
        }
    }

    /**
     * Read an unsafe block
     * @verbatim:
     * ==========
     * unsafe_expr := Keys::UNSAFE Tokens::LACC expression:(0) Tokens::RACC
     * ==========
     * */
    fn readUnsafe (mut self, loc : &Word)-> &Expression
        throws ErrorMsg
    {
        let content = self:.readExpression ();
        return copy UnsafeExpr (loc, content);
    }

    /**
     * Read a pragma expr
     * @verbatim:
     * ===================
     * pragma_expr := Keys::PRAGMA Tokens::NOT Identifier (Tokens::LPAR param_list Tokens::RPAR)
     * ===================
     */
    fn readPragma (mut self, _ : &Word)-> &Expression
        throws ErrorMsg
    {
        self:.readIf (Tokens::NOT);
        let (ident, _) = self:.readIdentifier (canBeSelf-> false);

        self:.readTokens (Tokens::LPAR);
        let (params, _) = self:.readArgumentList ();

        copy PragmaExpr (ident, params)
    }


    /**
     * Read a version block expr
     * @verbatim:
     * =========================
     * version_block := Keys::VERSION Identifier block (Keys::ELSE block)?
     * =========================
     */
    fn readVersionExpr (mut self, loc : &Word)-> &Expression
        throws ErrorMsg
    {
        let (ident, _) = self:.readIdentifier (canBeSelf-> false);
        return if state::instance ().isVersionActive (ident.str) {
            let (n, _) = self:.readIf (Tokens::LACC);
            let value = self:.readBlock (n, canBeCatcher-> false);
            if (!(self:.readIf (Keys::ELSE)._0).isEof ()) {
                self:.ignoreBlock ();
            }
            value
        } else {
            self:.ignoreBlock ();
            if (!(self:.readIf (Keys::ELSE)._0).isEof ()) {
                let (n, _) = self:.readIf (Tokens::LACC);
                self:.readBlock (n, canBeCatcher-> false)
            } else { copy EmptyExpression (loc-> loc) }
        }
    }

    /**
     * Read a throw expression
     * @verbatim:
     * =======================
     * throw_expr := Keys::THROW expression:(0)
     * =======================
     */
    fn readThrow (mut self, loc : &Word)-> &Expression
        throws ErrorMsg
    {
        let expr = self:.readExpression ();
        copy ThrowExpr (loc, expr)
    }

    /**
     * Read a panic instruction
     * @verbatim:
     * =======================
     * panic := Keys::PANIC
     * =======================
     * */
    fn readPanic (mut self, loc : &Word)-> &Expression {
        copy PanicExpr (loc)
    }


    /**
     * Read a function type
     * @verbatim:
     * ====================
     * function_type := (Keys::FUNCTION | Keys::DG) function_type_prototype function_type_return_type
     * function_type_prototype := Tokens::LPAR (expression:(10) (Tokens::COMA expression:(10))*) Tokens::RPAR
     * function_type_return_type := (Tokens::ARROW expression:(10))?
     * ====================
     */
    fn readFunctionType (mut self, loc : &Word)-> &Expression
        throws ErrorMsg
    {
        self:.readTokens (Tokens::LPAR);
        let args = self:.readFptrParameters ();
        let (t, _) = self:.readIf (Tokens::ARROW);
        if (!t.isEof ()) {
            copy FunctionPtrTypeExpr (loc, args, self:.readExpression (level-> self._specials.binaryOperators.len))
        } else {
            copy FunctionPtrTypeExpr (loc, args, EMPTY_EXPR)
        }
    }

    /**
     * Read a future type
     * @verbatim
     * ============
     * future_type := Keys::FUTURE Tokens::ARROW operand:(3)
     * ============
     * */
    fn readFutureType (mut self, loc : &Word)-> &Expression
        throws ErrorMsg
    {
        self:.readTokens (Tokens::ARROW);
        let param = self:.readOperand3 ();

        copy FutureTypeExpr (loc, param)
    }

    /**
     * Read the parameters of a function pointer type
     * */
    fn readFptrParameters (mut self)-> [&VarDeclExpr]
        throws ErrorMsg
    {
        let x = self:.readIf (Tokens::RPAR)._0;
        if (!x.isEof ()) return [];

        let mut params : [mut &VarDeclExpr] = [];
        loop {
            let (isLazyOrRef, isMutOrDmut) = self:.readDecoratorVariable (canBeLazyOrRef-> true);

            let type = self:.readExpression (level-> self._specials.binaryOperators.len);
            let name = copy Word (Keys::UNDER, type.getLoc ());
            params ~= [copy VarDeclExpr (name, name,
                                         isLazyOrRef-> isLazyOrRef,
                                         isMutOrDmut-> isMutOrDmut,
                                         type-> type,
                                         value-> EMPTY_EXPR)];

            let (next, _) = self:.readTokens (Tokens::RPAR, Tokens::COMA);
            if (next == Tokens::RPAR) break;
        }

        params
    }

    /**
     * Read a return expression
     * @verbatim:
     * ========================
     * return_expr := Keys::RETURN ( expression:(0) | ';' )
     * ========================
     */
    fn readReturn (mut self, loc : &Word)-> &Expression
        throws ErrorMsg
    {
        let (semiCol, _) = self:.readIf (Tokens::SEMI_COLON);
        if (!semiCol.isEof ()) {
            copy ReturnExpr (loc, EMPTY_EXPR)
        } else {
            let expr = self:.readExpression ();
            copy ReturnExpr (loc, expr)
        }
    }

    /**
     * Read a var declaration
     * @verbatim:
     * ========================
     * var_decl :=   Keys::LET (single_var_decl Tokens::EQUAL value) (Tokens::COMA (single_var_decl Tokens::EQUAL value))*
     *             | Keys::LET pattern Tokens::EQUAL value
     * ========================
     */
    fn readVarDeclaration (mut self, loc : &Word, onlyOne : bool = false, level : usize = 0us)-> &Expression
        throws ErrorMsg
    {
        let begCursor = self._lex.getSeek ();
        let mut succeed = false;
        let (tok, _) = self:.readIf (Tokens::LPAR, Tokens::LCRO);
        if (tok == Tokens::LPAR || tok == Tokens::LCRO) {
            let pattern = self:.readParMatch (tok, endTok-> if (tok == Tokens::LPAR) { Tokens::RPAR } else { Tokens::RCRO });
            self:.readTokens (Tokens::EQUAL);
            let value = self:.readExpression (level-> level);

            return copy PatternVarDeclExpr (loc, pattern, value);
        } else {
            {
                let mut decls : [mut &Expression] = [];
                loop {
                    decls ~= [self:.readSingleVarDeclaration (mandType-> false, isClass-> false, mandValue-> true, level-> level)];
                    succeed = true; // read at least one
                    if (!onlyOne) {
                        if ((self:.readIf (Tokens::COMA)._0).isEof ()) break;
                    } else break;
                }

                if (decls.len == 1) return decls [0];
                return copy SetExpr (loc, decls);
            } catch {
                err : &ErrorMsg => {
                    if (succeed) throw err; // pattern var decl cannot be grouped with other kind of declarations
                    {
                        self._lex:.rewindToSeek (begCursor);
                        let pattern = self:.readMatchExpression ();

                        self:.readTokens (Tokens::EQUAL);
                        let value = self:.readExpression (level-> level);

                        return copy PatternVarDeclExpr (loc, pattern, value);
                    } catch {
                        subErr : &ErrorMsg => {
                            throw err.withNote (copy [copy ErrorMsg::note (loc, oneLine-> true, SyntaxErrorMessage::READING_PATTERN_DECLARATION, notes-> copy [subErr])]);
                        }
                    }
                }
            }
        }
    }


    /**
     * Read a for loop
     * @verbatim:
     * ===========================
     * for_loop := Keys::FOR ((Tokens::LPAR for_loop_decl Tokens::RPAR) | for_loop_decl) expression:(0)
     * for_loop_decl := (single_var_decl:(no_value) (Tokens::COMA single_var_decl:(no_value))* Keys::IN expression:(10)
     * ===========================
     */
    fn readFor (mut self, loc : &Word)-> &Expression
        throws ErrorMsg
    {
        let mut decls : [mut &Expression] = [];
        let (par, _) = self:.readIf (Tokens::LPAR);
        loop {
            decls ~= [self:.readSingleVarDeclaration (mandType-> false, withValue-> false)];
            let (n, _) = self:.readTokens (Tokens::COMA, Keys::IN);
            if (n == Keys::IN) break;
        }

        let iter = self:.readExpression ();
        if (!par.isEof ()) self:.readTokens (Tokens::RPAR);

        let mut content = self:.readExpression ();
        match content {
            BlockExpr () => {}
            _ => {
                let (n, _) = self:.readIf (Tokens::SEMI_COLON);
                if (!n.isEof ()) {
                    let inner = copy [content, EMPTY_EXPR];
                    content = copy BlockExpr (content.getLoc (), n, inner);
                }
            }
        }

        copy ForLoopExpr (loc, decls, iter, content)
    }


    /**
     * Read a do while loop
     * @verbatim:
     * =====================
     * =====================
     */
    fn readDoWhile (mut self, loc : &Word) -> &Expression
        throws ErrorMsg
    {
        let content = self:.readExpression ();
        self:.readTokens (Keys::WHILE);
        let test = self:.readExpression ();

        copy WhileLoopExpr (loc, test-> test, content, isDo-> true)
    }

    /**
     * Read a break expression
     * @verbatim:
     * =======================
     * break_expr := Keys::BREAK ( expression:(0) | ';' )
     * =======================
     */
    fn readBreak (mut self, loc : &Word)-> &Expression
        throws ErrorMsg
    {
        let (semiCol, _) = self:.readIf (Tokens::SEMI_COLON);
        if (!semiCol.isEof ()) {
            copy BreakExpr (loc, EMPTY_EXPR)
        } else {
            let expr = self:.readExpression ();
            copy BreakExpr (loc, expr)
        }
    }


    /**
     * Read an assert expression
     * @verbatim:
     * ==========================
     * assert_expr := Keys::ASSERT Tokens::LPAR expression:(0) (Tokens::COMA expression:(0))? Tokens::RPAR
     * ==========================
     */
    fn readAssert (mut self, tok : &Word)-> &Expression
        throws ErrorMsg
    {
        let _ = self:.readTokens (Tokens::LPAR);
        let test = self:.readExpression ();
        let (n, _) = self:.readTokens (Tokens::RPAR, Tokens::COMA);
        let msg = if (n == Tokens::COMA) {
            let exp = self:.readExpression ();
            self:.readTokens (Tokens::RPAR);
            exp
        } else {
            EMPTY_EXPR
        }
        self:.readTokens (Tokens::SEMI_COLON);
        self._lex:.rewind ();

        copy AssertExpr (tok, test, msg)
    }

    /**
     * Read a loop expression
     * @verbatim:
     * =========================
     * loop_expr := Keys::LOOP expression:(0)
     * =========================
     */
    fn readLoop (mut self, loc : &Word)-> &Expression
        throws ErrorMsg
    {
        let mut content = self:.readExpression ();
        match content {
            BlockExpr () => {}
            _ => {
                let (n, _) = self:.readIf (Tokens::SEMI_COLON);
                if (!n.isEof ()) {
                    let inner = copy [content, EMPTY_EXPR];
                    content = copy BlockExpr (content.getLoc (), n, inner);
                }
            }
        }

        copy WhileLoopExpr (loc, content, isDo-> false)
    }


    /**
     * Read a while loop
     * @verbatim:
     * ===========================
     * while_expr := Keys::WHILE expression:(0) expression:(0)
     * ===========================
     */
    fn readWhile (mut self, loc : &Word)-> &Expression
        throws ErrorMsg
    {

        let (isLet, _) = self:.readIf (Keys::LET);
        let (test : &Expression, guard : &Expression) = if (isLet.isEof ()) {
            (self:.readExpression (), EMPTY_EXPR)
        } else {
            let vdecl = self:.readVarDeclaration (isLet, onlyOne-> true, level-> 3us);
            let guard = if (!self:.readIf (Tokens::DAND)._0.isEof ()) {
                self:.readExpression ()
            } else { EMPTY_EXPR };

            (vdecl, guard)
        };

        let mut content = self:.readExpression ();
        match content {
            BlockExpr () => {}
            _ => {
                let (n, _) = self:.readIf (Tokens::SEMI_COLON);
                if (!n.isEof ()) {
                    let inner = copy [content, EMPTY_EXPR];
                    content = copy BlockExpr (content.getLoc (), n, inner);
                }
            }
        }

        if (isLet.isEof ()) {
            copy WhileLoopExpr (loc, test-> test, content, isDo-> false)
        } else {
            let elseBr = copy BreakExpr (loc, EMPTY_EXPR);
            let innerCond = copy ConditionalExpr (loc, test, content, else_-> elseBr, isLet-> true, guard-> guard);
            copy WhileLoopExpr (loc, innerCond, isDo-> false)
        }
    }

    /**
     * Read a template call expr
     * @verbatim:
     * ===========================
     * template_call_expr := expression:(0) Tokens::NOT ((Tokens::LACC param_list Tokens::RACC) | operand:(3))
     * ===========================
     */
    fn readTemplateCall (mut self, var : &Expression)-> &Expression
        throws ErrorMsg
    {
        let (n, _) = self:.readIf (Tokens::NOT);
        if (!self._inTemplateCall && n == Tokens::NOT) {
            let (a, _) = self:.readIf (self._specials.specialBinaryOperators);
            if (!a.isEof ()) {
                self._lex:.rewindToSeek (n.seek);
                return var;
            }

            let (n2, _) = self:.readIf (Tokens::LACC);
            let res = self._inTemplateCall;
            {
                if (!n2.isEof ()) {
                    self._inTemplateCall = false;
                    let (lst, _) = self:.readArgumentList (withNamed-> false, closing-> Tokens::RACC);
                    self._inTemplateCall = res;

                    return copy TemplateCallExpr (n, var, lst);
                } else {
                    self._inTemplateCall = true;
                    let lst = copy [self:.readOperand3 ()];
                    self._inTemplateCall = res;

                    return copy TemplateCallExpr (n, var, lst);
                }
            } catch {
                err : &ErrorMsg => {
                    self._inTemplateCall = res;
                    throw err;
                }
            }
        } else if (n == Tokens::NOT) {
            throw copy ErrorMsg::fatal (n, SyntaxErrorMessage::MISSING_TEMPLATE_ACC);
        }

        var
    }


    /**
     * Read a macro call
     * @verbatim:
     * ==================
     * macro_call_expr :=   expression:(0) Tokens::MACRO_ACC (Any)* Tokens::RACC
     *                    | expression:(0) Tokens::MACRO_PAR (Any)* Tokens::RPAR
     *                    | expression:(0) Tokens::MACRO_CRO (Any)* Tokens::RCRO
     * ==================
     */
    fn readMacroCall (mut self, loc : &Word, var : &Expression)-> &Expression
        throws ErrorMsg
    {
        let (open, close) = match loc.str {
            Tokens::MACRO_ACC => { (Tokens::LACC, Tokens::RACC) }
            Tokens::MACRO_PAR => { (Tokens::LPAR, Tokens::RPAR) }
            _ => { (Tokens::LCRO, Tokens::RCRO) }
        }

        let (res, closing) = self._lex:.getString (opening-> copy [open, loc.str], closing-> close);
        if (closing.isEof ()) throw copy ErrorMsg::fatal (closing, SyntaxErrorMessage::BLOCK_NEVER_CLOSED, notes-> copy [copy ErrorMsg::note (loc, SyntaxErrorMessage::IN_DECL_BLOCK)]);

        copy MacroCallExpr (loc, closing, var, res)
    }



    /**
     * Read a variable
     * @verbatim:
     * ===================
     * var := Identifier (template_call)?
     * ===================
     */
    fn readVar (mut self, canBeTemplateCall : bool = true)-> &Expression
        throws ErrorMsg
    {
        let (var, _) = self:.readIdentifier (canBeSelf-> true);
        if (canBeTemplateCall) {
            self:.readTemplateCall (copy VarExpr (var))
        } else {
            copy VarExpr (var)
        }
    }

    /**
     * Read a lambda expression
     * @verbatim:
     * ========================
     * lambda_expr := function_proto:(lambda) (Tokens::DARROW)? expression:(0)
     * ========================
     */
    fn readLambda (mut self, loc : &Word)-> &Expression
        throws ErrorMsg
    {
        self._lex:.rewind ();
        let proto = self:.readFunctionPrototype (isClosure-> true, isClass-> false);
        self:.readIf (Tokens::DARROW);
        copy LambdaValueExpr (loc, proto, self:.readExpression ())
    }


    /**
     * Read a tuple expression
     * @verbatim:
     * ========================
     * param_expr := Tokens::LPAR (expression:(0) (Tokens::COMA | (Tokens::COMA expression:(0))*))? Tokens::RPAR
     * ========================
     */
    fn readTuple (mut self, loc : &Word)-> &Expression
        throws ErrorMsg
    {
        let mut end = self:.readIf (Tokens::RPAR)._0;
        if (end == Tokens::RPAR) { return copy ListExpr (loc, end, []); }

        let mut params : [mut &Expression] = copy [self:.readExpression ()];
        let (n, _) = self:.readTokens (Tokens::COMA, Tokens::RPAR, Keys::FOR);
        if (n == Keys::FOR) {
            let forLoc = n;
            let mut decls : [mut &Expression] = [];
            let (par, _) = self:.readIf (Tokens::LPAR);
            loop {
                decls ~= [self:.readSingleVarDeclaration (mandType-> false, withValue-> false)];
                let (n2, _) = self:.readTokens (Tokens::COMA, Keys::IN);
                if (n2 == Keys::IN) break;
            }

            let iter = self:.readExpression ();
            if (!par.isEof ()) self:.readTokens (Tokens::RPAR);
            self:.readTokens (Tokens::COMA);
            self:.readTokens (Tokens::RPAR);

            return copy SliceForAllocatorExpr (loc, forLoc, params [0], decls, iter, isTuple-> true);
        } else if (n == Tokens::COMA) {
            end = self:.readIf (Tokens::RPAR)._0;
            if (end.isEof ()) {
                loop {
                    params ~= [self:.readExpression ()];
                    end = self:.readTokens (Tokens::COMA, Tokens::RPAR)._0;
                    if (end == Tokens::RPAR) break;
                }

                return copy ListExpr (loc, end, params);
            } else {
                return copy ListExpr (loc, end, params);
            }
        }

        params [0]
    }


    /**
     * Read a template checker expr
     * @verbatim:
     * ============================
     * template_check := Keys::IS template_call template_param_list
     * ============================
     */
    fn readTemplateChecker (mut self, loc : &Word)-> &Expression
        throws ErrorMsg
    {
        let call = self:.readTemplateCall (copy VarExpr (loc));
        match call {
            t : &TemplateCallExpr => {
                let (params, _) = self:.readTemplateParameters (ifLoc-> EOF_WORD, force-> true);
                copy TemplateCheckerExpr (loc, t.getRights (), params)
            }
            _ => {
                self:.readTokens (Tokens::NOT);
                EMPTY_EXPR
            }
        }
    }

    /**
     * Read a cast expression
     * @verbatim:
     * =======================
     * cast_expr := Keys::CAST Tokens::NOT ((Tokens::LACC expression:(0) Tokens::RACC) | (operand:(3)) (Tokens::LPAR expression:(0) Tokens::RPAR)
     * =======================
     */
    fn readCast (mut self, loc : &Word)-> &Expression
        throws ErrorMsg
    {
        self:.readTokens (Tokens::NOT);
        let type = if (!(self:.readIf (Tokens::LACC)._0).isEof ()) {
            let e = self:.readExpression ();
            self:.readTokens (Tokens::RACC);
            e
        } else {
            self:.readOperand3 ()
        }

        self:.readTokens (Tokens::LPAR);
        let inner = self:.readExpression ();
        self:.readTokens (Tokens::RPAR);

        copy CastExpr (loc, type, inner)
    }


    /*!
     * ================================================================================
     * ================================================================================
     * =========================           MATCHERS           =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Read a catcher expression
     * @verbatim:
     * =========================
     * =========================
     */
    fn readCatcher (mut self, loc : &Word)-> &Expression
        throws ErrorMsg
    {
        let mut matchers : [mut (&Expression, &Expression, &Expression)] = [];
        self:.readTokens (Tokens::LACC);
        loop {
            let e = self:.readMatchExpression ();
            let (cd, _) = self:.readTokens (Keys::IF, Tokens::DARROW);
            let condition = if (cd == Keys::IF) {
                let x = self:.readExpression (level-> 1us);
                self:.readTokens (Tokens::DARROW);
                x
            } else {
                EMPTY_EXPR
            };

            let mut a = self:.readExpression(level-> self._specials.binaryOperators.len);
            let (tok, _) = self:.readIf (Tokens::SEMI_COLON);
            if (!tok.isEof ()) {
                let inner = copy [a, EMPTY_EXPR];
                a = copy BlockExpr (a.getLoc (), tok, content-> inner);
            }

            matchers ~= [(e, condition, a)];
            if (!(self:.readIf (Tokens::RACC)._0).isEof ()) break;
        }

        copy MatcherExpr (loc, EMPTY_EXPR, matchers, isCatcher-> true)
    }

    /**
     * Read a match expression
     * @verbatim:
     * ========================
     * match_expr := Keys::MATCH expression:(0) Tokens::LACC (inner_matcher_expr Tokens::DARROW expression:(10))+ Tokens::RACC
     * ========================
     */
    fn readMatch (mut self, loc : &Word)-> &Expression
        throws ErrorMsg
    {
        let mut matchers : [mut (&Expression, &Expression, &Expression)] = [];
        let content = self:.readExpression ();
        self:.readTokens (Tokens::LACC);
        loop {
            let e = self:.readMatchExpression ();
            let (cd, _) = self:.readTokens (Keys::IF, Tokens::DARROW);
            let condition = if (cd == Keys::IF) {
                let x = self:.readExpression (level-> 1us);
                self:.readTokens (Tokens::DARROW);
                x
            } else {
                EMPTY_EXPR
            };

            let mut a = self:.readExpression(level-> self._specials.binaryOperators.len);
            let (tok, _) = self:.readIf (Tokens::SEMI_COLON);
            if (!tok.isEof ()) {
                let inner = copy [a, EMPTY_EXPR];
                a = copy BlockExpr (a.getLoc (), tok, content-> inner);
            }

            matchers ~= [(e, condition, a)];
            if (!(self:.readIf (Tokens::RACC)._0).isEof ()) break;
        }

        copy MatcherExpr (loc, content, matchers, isCatcher-> false)
    }

    /**
     * Read an matching expression
     * @verbatim:
     * ============================
     * inner_matcher_expr :=   single_var_decl_match
     *                       | calling_match
     *                       | par_match
     *                       | cro_match
     *                       | expression:(0)
     * ============================
     */
    fn readMatchExpression (mut self)-> &Expression
        throws ErrorMsg
    {
        let (n, _) = self:.readIf (Tokens::LPAR, Tokens::LCRO);
        if (n == Tokens::LPAR) {
            return self:.readParMatch (n, endTok-> Tokens::RPAR);
        } else if (n == Tokens::LCRO) {
            return self:.readParMatch (n, endTok-> Tokens::RCRO);
        } else {
            return self:.readSingleVarDeclarationForMatch ();
        }
    }

    /**
     * Read a single var declaration for a pattern matcher
     * @params:
     *   - empty: allows for var to have no type nor value
     * @verbatim:
     * ========================
     * single_var_decl_match := (Decorator)* (Identifier | Keys::UNDER) Tokens::COLON (Keys::UNDER | expression:(10))  (Tokens::EQUAL inner_matcher_expr)?
     * ========================
     */
    fn readSingleVarDeclarationForMatch (mut self)-> &Expression
        throws ErrorMsg
    {
        let (isLazyOrRef, isMutOrDmut) = self:.readDecoratorVariable (canBeLazyOrRef-> true);
        if (isLazyOrRef == Keys::LAZY) {
            throw copy ErrorMsg::fatal (isLazyOrRef, format (SyntaxErrorMessage::UNDEF_DECORATOR_IN_MATCH, isLazyOrRef.str));
        }

        let (ig, _) = self:.readIf (Keys::UNDER);
        let name = if (!ig.isEof ()) {
            ig
        } else if (!isLazyOrRef.isEof () || !isMutOrDmut.isEof ()) {
            self:.readIdentifier (canBeSelf-> false)._0
        } else {
            self:.readIfIdentifier (canBeSelf-> false)._0
        };

        // No identifier means no mut/lazy ident, thus it is an expression
        if (name.isEof ()) return self:.readExpression (level-> 4us);

        // cannot use /self/
        else if (name == Keys::SELF) throw copy ErrorMsg::fatal (name, format (SyntaxErrorMessage::USED_AS_IDENTIFIER, name.str));

        // Option pattern-> /Ok (...), Err (...)/
        else if (name == OptionKeys::MATCH_SOME || name == OptionKeys::MATCH_NONE) {
            // dmut Ok (...) means nothing
            if (isLazyOrRef != EOF_WORD) throw copy ErrorMsg::fatal (isLazyOrRef, format (SyntaxErrorMessage::UNEXPECTED, isLazyOrRef));
            if (isMutOrDmut != EOF_WORD) throw copy ErrorMsg::fatal (isMutOrDmut, format (SyntaxErrorMessage::UNEXPECTED, isMutOrDmut));

            return self:.readOptionMatch (name);
        }

        let (tok, _) = self:.readIf (Tokens::COLON, Tokens::EQUAL, Tokens::LPAR, Tokens::NOT, Tokens::DCOLON);

        // Type pattern-> /(ident | _ | ident::ident... | ident!templates...) (...)/
        if (tok == Tokens::LPAR || tok == Tokens::NOT || tok == Tokens::DCOLON) {
            // dmut Type (fields...) means nothing, cannot dmut the type test

            if (isLazyOrRef != EOF_WORD) throw copy ErrorMsg::fatal (isLazyOrRef, format (SyntaxErrorMessage::UNEXPECTED, isLazyOrRef));
            if (isMutOrDmut != EOF_WORD) throw copy ErrorMsg::fatal (isMutOrDmut, format (SyntaxErrorMessage::UNEXPECTED, isMutOrDmut));

            self._lex:.rewind ();
            return self:.readCallingMatch (name);
        }

        // var decl with a type -> /decos ident : Type = Value/
        else if (tok == Tokens::COLON) {
            let type = if ((self:.readIf (Keys::UNDER)._0).isEof ()) {
                self:.readExpression (level-> self._specials.binaryOperators.len)
            } else { EMPTY_EXPR }

            // With a value
            let value = if (!(self:.readIf (Tokens::EQUAL)._0).isEof ()) {
                self:.readMatchExpression ()
            } else { EMPTY_EXPR }

            return copy VarDeclExpr (name, name, isMutOrDmut-> isMutOrDmut, isLazyOrRef-> isLazyOrRef, value-> value, type-> type);
        }

        // var decl with a value but not type -> /decos ident = Value/
        else if (tok == Tokens::EQUAL) {
            return copy VarDeclExpr (name, name, isMutOrDmut-> isMutOrDmut, isLazyOrRef-> isLazyOrRef,
                                     value-> self:.readMatchExpression (),
                                     type-> EMPTY_EXPR);
        }

        // var decl with no type and no value, just an identifier (or even just /_/)
        else  {
            if (name != Keys::UNDER && isMutOrDmut.isEof () && isLazyOrRef.isEof ()) {
                self._lex:.rewind ();
                let content = self:.readExpression (level-> self._specials.binaryOperators.len);
                match content {
                    v : &VarExpr => {
                        return copy VarDeclExpr (v.getLoc (), v.getLoc (), isMutOrDmut-> isMutOrDmut, isLazyOrRef-> isLazyOrRef,
                                                 value-> EMPTY_EXPR,
                                                 type-> EMPTY_EXPR);
                    }
                    _ => return content;
                }
            } else {
                return copy VarDeclExpr (name, name, isMutOrDmut-> isMutOrDmut, isLazyOrRef-> isLazyOrRef,
                                         value-> EMPTY_EXPR,
                                         type-> EMPTY_EXPR);
            }
        }
    }


    /**
     * Read a calling match expression
     * @verbatim:
     * ===============================
     * calling_match :=   (Identifier | Keys::UNDER) (Tokens::DCOLON Identifier)* (template_call)? (Tokens::LPAR (ident Tokens::ARROW inner_matcher_expr (',' ident Tokens::ARROW inner_matcher_expr)*)? Tokens::RPAR)
     *                  | Keys::UNDER
     *                  | option_match
     *                  | expression:(0)
     * ===============================
     */
    fn readCallingMatch (mut self, loc : &Word)-> &Expression
        throws ErrorMsg
    {
        // a type can be a bit more complex than just an identifier
        // it can be a path to a type, and a template type
        // This pattern does not apply to slices, and tuple, their patterns are different
        let mut var : &Expression = copy VarExpr (loc);
        if (loc != Keys::UNDER) {
            loop {
                let (n, _) = self:.readIf(Tokens::NOT, Tokens::DCOLON);
                if (n == Tokens::NOT) {
                    self._lex:.rewind ();
                    var = self:.readTemplateCall (var);
                    break;
                } else if (n == Tokens::DCOLON) {
                    var = copy BinaryExpr (n, var, copy VarExpr (self:.readIdentifier (canBeSelf-> false)._0));
                } else break;
            }
        }

        let (start, _) = self:.readIf (Tokens::LPAR);

        // If read a (, then it is a call pattern
        // calling function, and compare the value should be done within a match guard
        if (!start.isEof ()) {
            let mut params : [mut &Expression] = [];
            let mut e = self:.readIf (Tokens::RPAR, Tokens::COMA)._0;
            while e != Tokens::RPAR {
                let (ident, _) = self:.readIdentifier (canBeSelf-> false);
                self:.readTokens (Tokens::ARROW);

                params ~= [copy NamedExpr (ident, self:.readMatchExpression ())];
                e = self:.readTokens (Tokens::RPAR, Tokens::COMA)._0;
            }

            copy MultOperatorExpr (start, e, var, params)
        } else {
            // a variable that is not a var declaration, supposedly read /::/ or /!/
            if (loc == Keys::UNDER) { var }
            else {
                self._lex:.rewindToSeek (cursor-> loc.seek);
                self:.readExpression ()
            }
        }
    }

    /**
     * Read an option match
     * @verbatim:
     * =========================
     * option_match := (OptionKeys::MATCH_SOME | OptionKeys::MATCH_NONE) Tokens::LPAR inner_matcher_expr Tokens::RPAR
     * =========================
     * */
    fn readOptionMatch (mut self, loc : &Word)-> &Expression
        throws ErrorMsg
    {
        self:.readTokens (Tokens::LPAR);
        let inner = if (self:.readIf (Tokens::RPAR)._0.isEof ()) { // some (inner) =>
            let inner = self:.readMatchExpression ();
            self:.readTokens (Tokens::RPAR);
            inner
        } else { // some () =>
            EMPTY_EXPR
        }

        copy OptionMatcherExpr (loc, inner)
    }

    /**
     * Read a list in match expression
     * @verbatim:
     * ===============================
     * par_match :=   Tokens::LPAR (inner_matcher_expr (Tokens::COMA inner_matcher_expr )* (Tokens::COMA inner_matcher_expr Tokens::TDOT))? Tokens::RPAR
     *              | Tokens::LPAR (inner_matcher_expr (Tokens::TDOT)? Tokens::COMA) Tokens::RPAR
     *              | Tokens::LCRO (inner_matcher_expr (Tokens::COMA inner_matcher_expr)*)? Tokens::RCRO
     * ===============================
     */
    fn readParMatch (mut self, loc : &Word, endTok : [c8] = Tokens::RPAR)-> &Expression
        throws ErrorMsg
    {
        let mut params : [mut &Expression] = [];
        let mut e = self:.readIf (endTok)._0;
        while e != endTok {
            params ~= [self:.readMatchExpression ()];

            e = self:.readTokens (Tokens::COMA, endTok, Tokens::TDOT)._0;
            if (e == Tokens::TDOT) {
                if (endTok == Tokens::RPAR && params.len == 1us) {
                    self:.readTokens (Tokens::COMA);
                }
                e = self:.readTokens (endTok)._0;
                return copy ListMatcherExpr (loc, e, params, true);
            }

            if (params.len == 1us) {
                if (e == Tokens::COMA && endTok == Tokens::RPAR && !self:.readIf (Tokens::RPAR)._0.isEof ()) { // (x,) is a tuple
                    return copy ListMatcherExpr (loc, e, params, false);
                }
            }
        }

        // (x) is not a tuple, just x, but () is a tuple
        if (endTok == Tokens::RPAR && params.len == 1us) return params [0];
        copy ListMatcherExpr (loc, e, params, false)
    }


    /*!
     * ================================================================================
     * ================================================================================
     * =========================           LITERALS           =========================
     * ================================================================================
     * ================================================================================
     */


    /**
     * Read a literal
     * @verbatim:
     * ================
     * literal :=   Numeric
     *            | Float
     *            | Char
     *            | String
     *            | (Keys::TRUE | Keys::FALSE)
     *            | Keys::NULL
     *            | Tokens::DOLLAR
     * ================
     */
    pub fn readLiteral (mut self, canBeFloat : bool = true)-> &Expression
        throws ErrorMsg
    {
        let (start, _) = self._lex:.next ();
        self._lex:.rewind ();

        if (start.str.len > 0us) {
            let c = start.str[0];
            if ((c >= '0' && c <= '9') || (c == '_' && start.str.len != 1us)) {
                return self:.readNumeric (canBeFloat-> canBeFloat);
            }
        }

        if (start == Tokens::SQUOTE) {
            return self:.readString ();
        } else if (start == Tokens::DQUOTE) {
            return self:.readString ();
        } else if (start == Keys::TRUE || start == Keys::FALSE) {
            return copy BoolExpr (self._lex:.next ()._0);
        } else if (start == Keys::NULL) {
            return copy NullExpr (self._lex:.next ()._0);
        } else if (start == Keys::NONE) {
            return copy NoneExpr (self._lex:.next ()._0);
        } else if (start == Tokens::DOLLAR) {
            return copy DollarExpr (self._lex:.next ()._0);
        } else if (start == Tokens::DDOT) {
            let tok = self._lex:.next ()._0;
            let type = self:.readOperand3 ();
            return copy RangeTypeExpr (tok, type);
        } else {
            throw copy ErrorMsg::fatal (start, format (SyntaxErrorMessage::UNEXPECTED, start.str));
        }
    }



    /**
     * Read a namepath expression
     * @verbatim:
     * =============
     * namepath_expr := Identifier ('::' Identifier)*
     * =============
     */
    fn readPath (mut self) -> &Expression
        throws ErrorMsg
    {
        let fst = self:.readIdentifier (canBeSelf-> false);
        let mut res : &Expression = copy VarExpr (fst._0);
        loop {
            let (next, _) = self:.readIf (Tokens::DCOLON);
            if (!next.isEof ())  {
                let af = {
                    let (x, _) = self:.readIf (Keys::UNDER);
                    if !x.isEof () { x }
                    else { self:.readIdentifier (canBeSelf-> false)._0 }
                }
                res = copy PathExpr (next, res, copy VarExpr (af));
            } else break;
        }

        res
    }

    /**
     * Read a complex path
     * @example:
     * ====
     * foo::{bar, baz} => [ foo::bar, foo::baz ]
     * foo::{bar::{baz, bad::ouch}, fee} ==> [ foo::bar::baz, foo::bar::bad::ouch, foo::fee ]
     * ====
     * */
    fn readComplexPath (mut self, root : &Expression, ref mut result : [mut &Expression])
        throws ErrorMsg
    {
        let mut res = root;
        loop {
            let (next, _) = self:.readIf (Tokens::DCOLON);
            if (!next.isEof ()) {
                if (!self:.readIf (Tokens::LACC)._0.isEof ()) {
                    loop {
                        let (under, _) = self:.readIf (Keys::UNDER);
                        if (!under.isEof ()) {
                            result ~= [copy PathExpr (next, res, copy VarExpr (under))];
                        } else {
                            let current = copy PathExpr (next, res, copy VarExpr (self:.readIdentifier (canBeSelf-> false)._0));
                            self:.readComplexPath (current, ref result);
                        }

                        if (self:.readTokens (Tokens::RACC, Tokens::COMA)._0 == Tokens::RACC) break;
                    }

                    break;
                } else {
                    let (under, _) = self:.readIf (Keys::UNDER);
                    if (!under.isEof ()) {
                        result ~= [copy PathExpr (next, res, copy VarExpr (under))];
                        break;
                    }

                    res = copy PathExpr (next, res, copy VarExpr (self:.readIdentifier (canBeSelf-> false)._0));
                }
            } else {
                result ~= [res];
                break;
            }
        }
    }

    /**
     * Read an array literal
     * @verbatim:
     * =================
     * array_lit := Tokens::LCRO (expression:(0) (Tokens::COMA expression:(0))*)? Tokens::RCRO
     *              | Tokens::AND_LCRO (expression:(0) (Tokens::COMA expression:(0))*)? Tokens::RCRO
     * =================
     */
    fn readArray (mut self, loc : &Word)-> &Expression
        throws ErrorMsg
    {
        let (n, _) = self:.readIf (Tokens::RCRO);
        if (!n.isEof ()) return copy ListExpr (loc, n, [], isArray-> true);

        let mut params : [mut &Expression] = copy [self:.readExpression ()];
        let (e, _) = self:.readIf (Tokens::SEMI_COLON, Tokens::RCRO, Tokens::COMA, Keys::FOR, Tokens::DARROW);

        if (e == Tokens::SEMI_COLON) { // allocation
            let size = self:.readExpression ();
            self:.readTokens (Tokens::RCRO);
            return copy SliceAllocatorExpr (loc, params [0], size);
        }

        if (e == Keys::FOR) {
            let forLoc = e;
            let mut decls : [mut &Expression] = [];
            let (par, _) = self:.readIf (Tokens::LPAR);
            loop {
                decls ~= [self:.readSingleVarDeclaration (mandType-> false, withValue-> false)];
                let (n2, _) = self:.readTokens (Tokens::COMA, Keys::IN);
                if (n2 == Keys::IN) break;
            }

            let iter = self:.readExpression ();
            if (!par.isEof ()) self:.readTokens (Tokens::RPAR);
            self:.readTokens (Tokens::RCRO);

            return copy SliceForAllocatorExpr (loc, forLoc, params [0], decls, iter, isTuple-> false);
        }

        if (e == Tokens::DARROW) { // map [a => ...
            return self:.readListMap (loc, params [0]);
        }

        let mut end = e;
        if (e != Tokens::RCRO) {
            loop {
                params ~= [self:.readExpression ()];
                end = self:.readTokens (Tokens::RCRO, Tokens::COMA)._0;
                if (end == Tokens::RCRO) {
                    break;
                }
            }
        }

        copy ListExpr (loc, end, params, isArray-> true)
    }

    /**
     * Read a map literal
     * @verbatim:
     * ===============
     * listmap_lit := Tokens::LCRO  map_element (Tokens::COMA map_element)* Tokens::RCRO
     * map_element := expression:(10) Tokens::ARROW expression:(10)
     * ===============
     * */
    fn readListMap (mut self, loc : &Word, fstKey : &Expression)-> &Expression
        throws ErrorMsg
    {
        let mut keys : [mut &Expression] = copy [fstKey];
        let mut values : [mut &Expression] = copy [self:.readExpression ()];
        let mut end : &Word = EOF_WORD;
        loop {
            end = self:.readTokens (Tokens::RCRO, Tokens::COMA)._0;
            if (end == Tokens::RCRO) break;

            keys ~= [self:.readExpression ()];
            self:.readTokens (Tokens::DARROW);
            values ~= [self:.readExpression ()];
        }

        copy ListMapExpr (loc, end-> end, keys, values)
    }

    /**
     * Read a numeric value
     */
    fn readNumeric (mut self, canBeFloat : bool = true)-> &Expression
        throws ErrorMsg
    {
        let (begin, _) = self._lex:.next ();
        if (begin.str.len >= 4us) { // ends with i32, i16, ...
            let str_suff = begin.str[$ - 3us .. $];
            if (self.isFixedSuffix (str_suff)) {
                let suff = copy Word (str_suff, begin);
                let value = begin.str[0us .. $ - 3us];
                self.verifNumeric (begin, value);
                return copy FixedExpr (copy Word (value, begin), suffix-> suff);
            }
        }

        if (begin.str.len >= 3us) { // ends with is, us for isize and usize
            let str_suff = begin.str[$ - 2us .. $];
            if (self.isFixedSuffix (str_suff)) {
                let suff = copy Word (str_suff, begin);
                let value = begin.str[0us .. $ - 2us];
                self.verifNumeric (begin, value);
                return copy FixedExpr (copy Word (value, begin), suffix-> suff);
            }
        }

        let value = begin.str;
        let isStrictlyInt = self.verifNumeric (begin, value); // return true iif starts with 0x, 0o, 0b
        if (!isStrictlyInt && canBeFloat) {
            let n = self:.readDirectIf (Tokens::DOT);
            if (n == Tokens::DOT) {
                self._lex:.rewind ();
                return self:.readFloat (begin-> begin);
            }
        } else if (isStrictlyInt && value.len > 2us && value [0] == '0' && value [1] == 'x') { // but float can also start with 0x, e.g. 0xA.89p+29f
            let n = self:.readDirectIf (Tokens::DOT);
            if (n == Tokens::DOT) { // but has to contain a dot directly afterwards
                self._lex:.rewind ();
                return self:.readHexFloat (begin-> begin);
            }
        }

        copy FixedExpr (begin)
    }

    /**
     * Read a float expr (in decimal mode)
     * @params:
     * - begin: the content before the dot
     */
    fn readFloat (mut self, begin : &Word)-> &Expression
        throws ErrorMsg
    {
        let (dot, after) =
            (self:.readDirectTokens (Tokens::DOT), self._lex:.directNext ());

        if (self.isFloatScientific (after.str)) { // 1.e+89f
            return self:.readScientificFloat (begin, dot, after);
        } else if (after.str.len > 0us && after.str[0] >= '0' && after.str[0] <= '9') { // 1.0839f
            if (after.str.len >= 2us) {
                if (self.isFloatSuffix (after.str[$ - 1us .. $])) {
                    let suff = copy Word (after.str[$ - 1us .. $], after);
                    let value = after.str[0us .. $ - 1us];
                    self.verifNumeric (after, value, canHexa-> false);
                    return copy FloatExpr (dot, begin, copy Word (value, after), suffix-> suff);
                }
            }

            let value = after.str;
            self.verifNumeric (after, value, canHexa-> false);
            return copy FloatExpr (dot, begin, after, suffix-> EOF_WORD)
        } else if (self.isFloatSuffix (after.str)) { // 1.f
            return copy FloatExpr (dot, begin, EOF_WORD, suffix-> after)
        } else { // 1.
            self._lex:.rewind ();
            return copy FloatExpr (dot, begin, EOF_WORD, suffix-> EOF_WORD)
        }
    }

    /**
     * Read a float in scientific notation format
     * @params:
     *    - begin: the integral part
     *    - dot: the dot
     *    - after: the decimal part
     * */
    fn readScientificFloat (mut self, begin : &Word, dot : &Word, after : &Word)-> &Expression
        throws ErrorMsg
    {
        let (suffDec, mut suffExp) = self.getFloatScientific (after.str);
        let mut pos = true;
        let suff = if (suffExp.len == 0us) { // e+, e-, E+, E-
            pos = (self:.readDirectTokens (Tokens::MINUS, Tokens::PLUS) == Tokens::PLUS); // read the +, -
            suffExp = self._lex:.directNext ().str; // read the numeric values after E+, E-...
            if (suffExp.len > 0us && self.isFloatSuffix (suffExp [$ - 1us .. $])) { // if may contain a float suffix
                let s = copy Word (suffExp[$ - 1us .. $], after);
                suffExp = suffExp [0us .. $ - 1us];
                s
            } else { EOF_WORD }
        } else { // just e1029f...
            if (self.isFloatSuffix (after.str[$ - 1us .. $])) {
                copy Word (after.str[$-1us .. $], after)
            } else { EOF_WORD }
        };

        self.verifNumeric (after, suffExp, canHexa-> false);
        self.verifNumeric (after, suffDec, canHexa-> false);
        return copy FloatExpr (dot, begin, copy Word (suffDec, after), suffix-> suff, exp-> copy Word (suffExp, after), expPositive-> pos);
    }

    /**
     * Read a float in hexadecimal notation
     * */
    fn readHexFloat (mut self, begin : &Word)-> &Expression
        throws ErrorMsg
    {
        let (dot, after) =
            (self:.readDirectTokens (Tokens::DOT), self._lex:.directNext ());

        let mut pos = true;
        let (suffDec, mut suffExp) = self.getFloatHexExp (after, after.str); // unlike scientific notation, 'p' is mandatory

        let suff = if (suffExp.len == 0us) { // p+, p-, P+, P-
            pos = (self:.readDirectTokens (Tokens::MINUS, Tokens::PLUS) == Tokens::PLUS); // read the +, -
            suffExp = self._lex:.directNext ().str; // read the numerix values after P+, P-, ...
            if (suffExp.len > 0us && self.isFloatSuffix (suffExp [$ - 1us .. $])) { // maybe it ends with "f"
                let s = copy Word (suffExp [$ - 1us .. $], after);
                suffExp = suffExp [0us .. $ - 1us];
                s
            } else { EOF_WORD }
        } else {
            if (self.isFloatSuffix (after.str[$ - 1us .. $])) { // ending with "f"
                copy Word (after.str[$ - 1us .. $], after)
            } else { EOF_WORD }
        };

        for i in 0us .. suffDec.len { // only hex chars
            if ((suffDec [i] < '0' || suffDec [i] > '9') && (suffDec [i] < 'A' || suffDec [i] > 'F') && (suffDec [i] < 'a' || suffDec [i] > 'f') && suffDec [i] != Keys::UNDER [0]) {
                throw copy ErrorMsg::fatal (after, format (SyntaxErrorMessage::UNEXPECTED, suffDec), notes-> copy [
                    copy ErrorMsg::note (copy Word (suffDec [i .. i + 1us], after, addCol-> cast!u64 (i)), "")]);
            }
        }

        self.verifNumeric (after, suffExp, canHexa-> false);
        return copy FloatExpr (dot, begin, copy Word (suffDec, after), suffix-> suff, exp-> copy Word (suffExp, after), expPositive-> pos, isHex-> true);
    }

    /**
     * Read a string literal
     * @verbatim:
     * =======================
     * string_lit :=   Tokens::DQUOTE Any* Tokens::DQUOTE (StringSuffixes::UTF8 | StringSuffixes::UTF32)?
     *               | Tokens::SQUOTE Any* Tokens::SQUOTE (CharSuffixes::UTF8 | CharSuffixes::UTF32)?
     * =======================
     */
    pub fn readString (mut self, forceDouble : bool = false)-> &Expression
        throws ErrorMsg
    {
        let (start, _) = if (forceDouble) {
            self:.readTokens (Tokens::DQUOTE)
        } else {
            self:.readTokens (Tokens::DQUOTE, Tokens::SQUOTE)
        };

        let closing = start.str;
        let (res, end) = self._lex:.getString (closing-> closing, escaping-> true);
        if (end.isEof ()) throw copy ErrorMsg::fatal (end, SyntaxErrorMessage::BLOCK_NEVER_CLOSED, notes-> copy [copy ErrorMsg::note (start, SyntaxErrorMessage::IN_DECL_BLOCK)]);

        let format = if (start == Tokens::DQUOTE) {
            self:.readDirectIf (self._specials.stringSuffixes)
        } else { self:.readDirectIf (self._specials.charSuffixes) }

        if (start == Tokens::DQUOTE)
            copy StringExpr (start, end, res, suffix-> format)
        else copy CharExpr (start, end, res, suffix-> format)
    }

    /**
     * Read an identifier from the lexer
     * @throws:
     *    - ErrorMsg: if the next token is not a valid identifier
     */
    pub fn readIdentifier (mut self, canBeSelf : bool)-> (&Word, [c8])
        throws ErrorMsg
    {
        let (ident, comm) = self._lex:.next ();
        if (!self.isIdentifier (ident.str, canBeSelf-> canBeSelf)) {
            throw copy ErrorMsg::fatal (ident, format (SyntaxErrorMessage::USED_AS_IDENTIFIER, ident.str));
        }

        (ident, comm)
    }

    /**
     * Read an identifier if there is an identifier to read
     * @returns: the identifier (and associated comment), or (EOF_WORD, "") if no identifier can be read
     */
    fn readIfIdentifier (mut self, canBeSelf : bool)-> (&Word, [c8]) {
        let (ident, _) = self._lex.nextNoConsume ();
        if (!self.isIdentifier (ident.str, canBeSelf-> canBeSelf)) {
            return (EOF_WORD, "");
        }

        return self._lex:.next ();
    }

    /**
     * @returns: true if str is a valid identifier, false otherwise
     */
    fn isIdentifier (self, str : [c8], canBeSelf : bool)-> bool {
        if (!canBeSelf && str == Keys::SELF) return false;
        if (str in self._forbiddenKeys) {
            return false;
        }

        let mut i = 0u64;
        let mut found = false;
        for j in str { // must start by a letter, but can be preceded by as many _ as wanted
            if (j >= 'a' && j <= 'z') || (j >= 'A' && j <= 'Z') {
                found = true;
                break;
            } else if (j != '_') {
                return false;
            }
            i += 1u64;
        }

        i += 1u64;
        if (i < str.len) { // the rest of the identifier must be composed of letters, numbers, or _
            for j in str [cast!usize (i) .. $] {
                if (j < 'a' || j > 'z') && (j < 'A' || j > 'Z') && (j != '_') && (j < '0' || j > '9') {
                    return false;
                }
            }
        } else {
            return found;
        }

        true
    }


    /*!
     * ================================================================================
     * ================================================================================
     * =========================        MISCELLANEOUS         =========================
     * ================================================================================
     * ================================================================================
     */


    /**
     * @returns: the next token inside the lexer, if it is equals to one of the token inside lst
     * @info: if none of lst token is found, the lexer is not incremented
     * @params:
     *    - lst: a list of tokens
     */
    fn readIf {R...} (mut self, f : [c8], lst : R)-> (&Word, [c8]) {
        let (x, _) = self._lex.nextNoConsume ();
        if (x.isEof ()) return (EOF_WORD, "");

        if (x.str == f) return self._lex:.next ();
        cte if (R,)::arity > 1 {
            for i in lst if i == x.str {
                return self._lex:.next ();
            }
        } else {
            if lst == x.str { return self._lex:.next (); }
        }

        return (EOF_WORD, "");
    }

    /**
     * @returns: the next token inside the lexer, if it is equals to one of the token inside lst
     * @info: if none of lst token is found, the lexer is not incremented
     * @params:
     *    - lst: a list of tokens
     */
    fn readIf (mut self, lst : [[c8]])-> (&Word, [c8]) {
        let (x, _) = self._lex.nextNoConsume ();
        if (x.isEof ()) return (EOF_WORD, "");

        for i in lst {
            if i == x.str {
                return self._lex:.next ();
            }
        }

        return (EOF_WORD, "");
    }

    /**
     * @returns: the next token inside the lexer, if it is equals to one of the token inside lst
     * @info: if none of lst token is found, the lexer is not incremented
     * @params:
     *    - lst: a list of tokens
     */
    fn readDirectIf (mut self, lst : [[c8]])-> &Word {
        let x = self._lex:.directNext ();
        if (x.isEof ()) return EOF_WORD;

        for i in lst {
            if i == x.str {
                return x;
            }
        }

        self._lex:.rewind ();
        EOF_WORD
    }


    /**
     * @returns: the next token inside the lexer, if it is equals to one of the token inside lst
     * @info: if none of lst token is found, the lexer is not incremented
     * @params:
     *    - lst: a token
     */
    fn readIf (mut self, lst : [c8])-> (&Word, [c8]) {
        let (x, _) = self._lex.nextNoConsume ();
        if (x.str == lst) return self._lex:.next ();

        return (EOF_WORD, "");
    }

    /**
     * @returns: the direct next token inside the lexer, if it is equals to one of the token inside lst
     * @info: if none of lst token is found, the lexer is not incremented
     * @params:
     *    - lst: a token
     */
    fn readDirectIf (mut self, lst : [c8])-> &Word {
        let x = self._lex:.directNext ();
        if (x.isEof ()) return EOF_WORD;

        if (x.str == lst) return x;

        self._lex:.rewind ();
        EOF_WORD
    }

    /**
     * @returns: the next token inside the lexer, if it is equals to one of the token inside lst
     * @throws:
     *   - ErrorMsg: if none of the token in lst is equal to the token that have been read, or the next token is eof
     * @params:
     *    - lst: a list of tokens
     */
    fn readTokens {R...} (mut self, f : [c8], lst : R)-> (&Word, [c8])
        throws ErrorMsg
    {
        let (x, y) = self._lex:.next ();
        if (x.str == f) return (x, y);
        cte if (R,)::arity > 1 {
            for i in lst if i == x.str {
                return (x, y);
            }

            let  err = copy [f] ~ [i for i in (expand lst,)];
            throw copy ErrorMsg::fatal (x, format (SyntaxErrorMessage::UNEXPECTED_BUT_LST, x.str, err));
        } else {
            if lst == x.str { return (x, y); }

            let  err = copy [f] ~ [lst];
            throw copy ErrorMsg::fatal (x, format (SyntaxErrorMessage::UNEXPECTED_BUT_LST, x.str, err));
        }

    }

    /**
     * @returns: the next token inside the lexer, if it is equals to one of the token inside lst
     * @throws:
     *   - ErrorMsg: if none of the token in lst is equal to the token that have been read, or the next token is eof
     * @params:
     *    - lst: a list of tokens
     */
    pub fn readTokens (mut self, lst : [[c8]])-> (&Word, [c8])
        throws ErrorMsg
    {
        let (x, y) = self._lex:.next ();
        for i in lst {
            if i == x.str {
                return (x, y);
            }
        }

        throw copy ErrorMsg::fatal (x, format (SyntaxErrorMessage::UNEXPECTED_BUT_LST, x.str, lst));
    }

    /**
     * @returns: the direct next token inside the lexer, if it is equals to one of the token inside lst
     * @throws:
     *   - ErrorMsg: if none of the token in lst is equal to the token that have been read, or the next token is eof
     * @params:
     *    - lst: a list of tokens
     */
    fn readDirectTokens (mut self, lst : [[c8]])-> &Word
        throws ErrorMsg
    {
        let x = self._lex:.directNext ();
        for i in lst {
            if i == x.str {
                return x;
            }
        }

        throw copy ErrorMsg::fatal (x, format (SyntaxErrorMessage::UNEXPECTED_BUT_LST, x.str, lst));
    }

    /**
     * @returns: the direct next token inside the lexer, if it is equals to one of the token inside lst
     * @throws:
     *   - ErrorMsg: if none of the token in lst is equal to the token that have been read, or the next token is eof
     * @params:
     *    - lst: a list of tokens
     */
    fn readDirectTokens {R...} (mut self, f : [c8], lst : R)-> &Word
        throws ErrorMsg
    {
        let x = self._lex:.directNext ();
        if x.str == f { return x; }
        cte if (R,)::arity > 1 {
            for i in lst if i == x.str {
                return x;
            }

            let  err = copy [f] ~ [i for i in (expand lst,)];
            throw copy ErrorMsg::fatal (x, format (SyntaxErrorMessage::UNEXPECTED_BUT_LST, x.str, err));
        }

        else {
            if lst == x.str { return x; }
            throw copy ErrorMsg::fatal (x, format (SyntaxErrorMessage::UNEXPECTED_BUT_LST, x.str, copy [f] ~ [lst]));
        }
    }


    /**
     * @returns: the next token inside the lexer, if it is equals to one of the token inside lst
     * @throws:
     *   - ErrorMsg: if none of the token in lst is equal to the token that have been read, or the next token is eof
     * @params:
     *    - lst: a token
     */
    fn readTokens (mut self, lst : [c8])-> (&Word, [c8])
        throws ErrorMsg
    {
        let (x, y) = self._lex:.next ();
        if (x.str == lst) return (x, y);

        throw copy ErrorMsg::fatal (x, format (SyntaxErrorMessage::UNEXPECTED_BUT_LST, x.str, lst));
    }

    /**
     * @returns: the direct next token inside the lexer, if it is equals to one of the token inside lst
     * @throws:
     *   - ErrorMsg: if none of the token in lst is equal to the token that have been read, or the next token is eof
     * @params:
     *    - lst: a token
     */
    fn readDirectTokens (mut self, lst : [c8])-> &Word
        throws ErrorMsg
    {
        let x = self._lex:.directNext ();
        if (x.str == lst) return x;

        throw copy ErrorMsg::fatal (x, format (SyntaxErrorMessage::UNEXPECTED_BUT_LST, x.str, lst));
    }



    /*!
     * ================================================================================
     * ================================================================================
     * =========================            TESTS             =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * @returns: true, if this expression needs at the end, a semi colon to be separated from other expressions
     */
    fn needClosingExpr (self, expr : &Expression)-> bool {
        match expr {
            a : &AtomicExpr => { self.needClosingExpr (a.getValue ()) }
            BlockExpr () => { false }
            b : &BreakExpr => { self.needClosingExpr (b.getValue ()) }
            ConditionalExpr () => { false }
            EmptyExpression () => { false }
            ForLoopExpr () => { false }
            MatcherExpr () => { false }
            r : &ReturnExpr =>  { self.needClosingExpr (r.getValue ()) }
            ScopeGuardExpr () => { false }
            t : &ThrowExpr => { self.needClosingExpr (t.getValue ()) }
            l : &WhileLoopExpr => { l.isDo () }
            UnsafeExpr () => { false }
            s : &SetExpr => {
                if (s.getContent ().len != 0us) {
                    self.needClosingExpr (s.getContent ()[$ - 1us])
                } else { false }
            }
            v : &VarDeclExpr => {
                match v.getValue () {
                    EmptyExpression () => { true }

                    _ => {
                        self.needClosingExpr (v.getValue ())
                    }
                }
            }
            v : &PatternVarDeclExpr => {
                match v.getValue () {
                    EmptyExpression () => { true }
                    _ => {
                        self.needClosingExpr (v.getValue ())
                    }
                }
            }
            i : &IntrinsicExpr => {
                if (i.getType () == IntrinsicKeys::CTE) {
                    self.needClosingExpr (i.getContent ())
                } else { true }
            }
            _ => { true }
        }
    }

    /**
     * Verification of the content of the numeric
     * @returns: true iif in hexa decimal or octal, or binary
     */
    fn verifNumeric (self, loc : &Word, value : [c8], canHexa : bool = true)-> bool
        throws ErrorMsg
    {
        if (value.len > 2us && value [0us] == '0' && value [1] == 'x' && canHexa) {
            for i in 2us .. value.len {
                if (value [i] < '0' || value [i] > '9') && (value [i] < 'A' || value [i] > 'F') && (value [i] < 'a' && value [i] > 'f') && value [i] != Keys::UNDER[0] {
                    throw copy ErrorMsg::fatal (loc, format (SyntaxErrorMessage::UNEXPECTED, value), notes-> copy [
                        copy ErrorMsg::note (copy Word (value [i .. i + 1us], loc, addCol-> cast!u64 (i)), "")]);
                }
            }

            true
        } else if (value.len > 2us && value [0] == '0' && value [1] == 'o' && canHexa) {
            for i in 2us .. value.len {
                if (value [i] < '0' || value [i] > '7') && value [i] != Keys::UNDER[0] {
                    throw copy ErrorMsg::fatal (loc, format (SyntaxErrorMessage::UNEXPECTED, value), notes-> copy [
                        copy ErrorMsg::note (copy Word (value [i .. i + 1us], loc, addCol-> cast!u64 (i)), "")]);
                }
            }

            true
        } else if (value.len > 2us && value [0] == '0' && value [1] == 'b' && canHexa) {
            for i in 2us .. value.len {
                if (value [i] != '0' && value [i] != '1' && value [i] != Keys::UNDER [0]) {
                    throw copy ErrorMsg::fatal (loc, format (SyntaxErrorMessage::UNEXPECTED, value), notes-> copy [
                        copy ErrorMsg::note (copy Word (value [i .. i + 1us], loc, addCol-> cast!u64 (i)), "")]);
                }
            }

            true
        } else {
            for i in 0us .. value.len {
                if (value [i] < '0' || value [i] > '9') && value [i] != Keys::UNDER[0] {
                    throw copy ErrorMsg::fatal (loc, format (SyntaxErrorMessage::UNEXPECTED, value), notes-> copy [
                        copy ErrorMsg::note (copy Word (value [i .. i + 1us], loc, addCol-> cast!u64 (i)), "")]);
                }
            }

            false
        }
    }


    /*!
     * ================================================================================
     * ================================================================================
     * =========================             CONV             =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Transform a word into a protection
     * @info: if the word does not contain a protection, by default Protection::PRIVATE is returned
     */
    fn toProtection (self, msg : [c8])-> Protection {
        match msg {
            Keys::PUBLIC => { Protection::PUBLIC }
            Keys::PRIVATE => { Protection::PRIVATE }
            Keys::PROTECTED => { Protection::PROTECTED }
            _ => {
                panic;
            }
        }
    }

    /**
     * Transform a word into a template var type
     * @info: if the word does not contain a template var type, by default TemplateVarType::TUPLE is returned
     */
    fn toTemplateVarType (self, msg : [c8])-> TemplateVarType {
        for i in TemplateVarType::__members__ {
            if i == msg {
                return i;
            }
        }

        panic;
    }

    /**
     * Transform a word into a template of var type
     * @info: if the word does not contain a template var type, by default TemplateOfVarType::IMPL is returned
     */
    fn toTemplateOfVarType (self, msg : [c8])-> TemplateOfVarType {
        for i in TemplateOfVarType::__members__ {
            if i == msg {
                return i;
            }
        }

        panic;
    }

    /**
     * Transform a word into an scope guard key
     * @info: if the word does not contain a scope guard name, by default ScopeGuardType::EXIT is returned
     */
    fn toScopeGuard (self, msg : [c8])-> ScopeGuardType {
        for i in ScopeGuardType::__members__ {
            if i == msg {
                return i;
            }
        }

        panic;
    }

    /**
     * Transform a word into an intrinsic key
     * @info: if the word does not contain a intrinsic name, by default IntrinsicKeys::DCOPY is returned
     */
    fn toIntrinsic (self, msg : [c8])-> IntrinsicKeys {
        for i in IntrinsicKeys::__members__ {
            if i == msg {
                return i;
            }
        }

        panic;
    }

    /**
     * @returns: true if msg is a fixed suffix
     */
    fn isFixedSuffix (self, msg : [c8])-> bool {
        for i in self._specials.fixedSuffixes {
            if (i == msg) return true;
        }

        false
    }

    /**
     * @returns: true if msg is a float suffix
     */
    fn isFloatSuffix (self, msg : [c8])-> bool {
        for i in self._specials.floatSuffixes {
            if (i == msg) return true;
        }

        false
    }

    /**
     * @returns: true if part is a float exp decimal part (e.g. 45e78f)
     */
    fn isFloatScientific (self, part : [c8])-> bool {
        let mut readE = false;
        if (part.len == 0us) return false;
        let p = if (self.isFloatSuffix (part [$-1us .. $]))
            part [0us .. $ - 1us]
        else { part };

        let mut i = 0us;
        while i < p.len {
            if (p[i] == FloatExp::LE [0] || p[i] == FloatExp::BE [0]) {
                if (readE) return false; // already read exp
                readE = true;
            }
            else if ((p [i] < '0' || p [i] > '9') && p [i] != Keys::UNDER [0]) return false;

            i += 1us;
        }

        readE
    }

    /**
     * @returns: the two parts of a float exp decimal part (e.g. 45e78f => (45, 78)
     * */
    fn getFloatScientific (self, part : [c8])-> ([c8], [c8]) {
        if (part.len == 0us) return ("", "");
        let p = if (self.isFloatSuffix (part [$ - 1us .. $]))
            part [0us .. $ - 1us]
        else { part };

        let mut i = 0us;
        while i < p.len {
            if (p[i] == FloatExp::LE [0] || p[i] == FloatExp::BE [0]) {
                return (p[0us .. i], p[i + 1us .. $])
            }

            i += 1us;
        }

        (p, "")
    }

    /**
     * @returns: the two parts of a float hex exp decimal part (e.g. Ap10f => (1, 10)
     * */
    fn getFloatHexExp (self, loc : &Word, part : [c8])-> ([c8], [c8])
        throws ErrorMsg
    {
        if (part.len == 0us) {
            throw copy ErrorMsg::fatal (loc, format (SyntaxErrorMessage::UNEXPECTED_BUT_LST, part, copy [FloatExp::LP, FloatExp::BP]));
        }

        let p = if (self.isFloatSuffix (part [$ - 1us .. $]))
            part [0us .. $ - 1us]
        else { part };

        let mut i = 0us;
        while i < p.len {
            if (p[i] == FloatExp::LP [0] || p[i] == FloatExp::BP [0]) {
                return (p[0us .. i], p[i + 1us .. $])
            }

            i += 1us;
        }

        throw copy ErrorMsg::fatal (loc, format (SyntaxErrorMessage::UNEXPECTED_BUT_LST, part, copy [FloatExp::LP, FloatExp::BP]),
                                    notes-> copy [
                                        copy ErrorMsg::note (copy Word (part [$ - 1us .. $], loc, addCol-> cast!u64 (part.len - 1us)), "")]);
    }
}
