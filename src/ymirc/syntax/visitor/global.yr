in global;

use ymirc::errors::_;
use ymirc::syntax::{_,
                    visitor::_,
                    declaration::_,
                    expression::{_, literal::_, macro_::_, operator::_, template::_}};

use ymirc::lexing::{word, tokens, keys};
use ymirc::utils::_;


lazy __SPECIAL_GLOBAL__ = SpecialGlobal ();

pub record SpecialGlobal {
    
    pub let listKeys                : [[c8]] = copy GlobalDeclKeys::__members__;    
    pub let listKeysExtern          : [[c8]];    
    pub let listKeysExternPubPrvUse : [[c8]];    
    pub let listKeysExternUse       : [[c8]];

    pub self ()
        with listKeysExtern = self.listKeys ~ [Keys::EXTERN]
        ,listKeysExternUse = self.listKeysExtern ~ [Keys::USE]
        ,listKeysExternPubPrvUse = self.listKeysExternUse ~ [Keys::PUBLIC, Keys::PRIVATE]
    {}
}

/**
 * Syntax visitor to read global symbol declaration
 * This visitor is executed on the top level of a file
 * */
pub record GlobalVisitor {

    let _special : SpecialGlobal = __SPECIAL_GLOBAL__;
    
    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ======================================          CTOR          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */

    pub self () {}            

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =================================          IMPLEMENTATION          =================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Read a declaration block
     * @params:
     *   - context: the context of the reading
     *   - loc: the location of the first read word
     *   - comm: the comment on top of the block to read
     * @returns: the block read
     * */
    pub fn readBlock (self, dmut context : &SyntaxVisitor, loc : &Word, comm : [c8])-> &BlockDecl
        throws ErrorMsg
    {
        self.readBlock (alias context,
                        loc, 
                        comm,
                        closing-> false,
                        inProtection-> false)
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =====================================          BLOCKS          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */
    
    /**
     * Read a declaration block
     * @params:
     *   - context: the context of the reading
     *   - loc: the location of the block being read
     *   - comm: the comment on top of the block to read
     *   - closing: true iif a Tokens::LACC was read, and a RACC needs to be read to close the current block
     * @returns: the block read
     * @verbatim:
     * ```
     * decl_block :=   protection_block
     *               | 'use' complex_path ';' 
     *               | extern_decl_block
     *               | (attributes? declaration)*
     *
     * protection_block := (attributes)? (Keys::PUBLIC | Keys::PRIVATE) declaration
     *                     | (Keys::PUBLIC | Keys::PRIVATE) '{' protected_decl_block '}'
     *                     | (Keys::PUBLIC | Keys::PRIVATE) extern_decl_block     
     *
     * extern_decl_block := (attributes)? Keys::EXTERN Lang? declaration     
     * 
     * protected_decl_block :=   extern_decl_block
     *                         | (attributes? declaration)*
     *
     * Lang :=   '(' 'C' ')'
     *         | '(' 'Y' (',' Path)? ')' 
     * ```
     * */
    fn readBlock (self, dmut context : &SyntaxVisitor, loc : &Word, comm : [c8], closing : bool, inProtection : bool)-> &BlockDecl
        throws ErrorMsg
    {
        let mut decls : [mut &Declaration] = [];
        {
            loop {
                // Read attributes for the next declaration
                let (attrLoc, attribs, attrComm) = self.readAttributes (alias context);

                let (tok, comm_) = context:.readToken ();                                                            
                match tok.str {
                    Keys::PUBLIC | Keys::PRIVATE => {
                        if inProtection throw copy ErrorMsg::fatal (tok, format (SyntaxErrorMessage::UNEXPECTED, tok));                         
                        decls ~= [self.readProtectionBlock (alias context, tok, comm ~ comm_, attribs-> (attrLoc, attribs, attrComm))];                    
                    }
                    Keys::USE  => {                        
                        if inProtection throw copy ErrorMsg::fatal (tok, format (SyntaxErrorMessage::UNEXPECTED, tok));

                        self.checkNoAttributes (tok, attrLoc, attribs);
                        decls ~= self.readUse (alias context, tok, comm ~ comm_);
                    }
                    Keys::EXTERN => {                        
                        decls ~= [self.readExternBlock (alias context,
                                                        loc-> tok,
                                                        comm-> comm ~ attrComm ~ comm_,
                                                        attribs-> (attrLoc, attribs, attrComm))]
                    }
                    Tokens::RACC => {                        
                        if !closing throw copy ErrorMsg::fatal (tok, format (SyntaxErrorMessage::UNEXPECTED, tok));
                        self.checkNoAttributes (tok, attrLoc, attribs);
                        break;
                    }
                    _ => {                        
                        // We read nothing, because there's nothing to read
                        if tok.isEof {
                            if closing throw copy ErrorMsg::fatal (loc, end-> tok, SyntaxErrorMessage::BLOCK_NEVER_CLOSED);
                            self.checkNoAttributes (tok, attrLoc, attribs);
                            break;
                        }

                        context:.rewind ();
                        // Or a declaration
                        let expected = if inProtection { self._special.listKeysExtern } else { self._special.listKeysExternPubPrvUse };
                        decls ~= [self.readDeclaration (alias context,
                                                        comm-> comm ~ attrComm ~ comm_,
                                                        attribs-> (attrLoc, attribs),
                                                        expected-> expected)];                     
                    }
                }
            }
        } catch {
            err => {
                if (!loc.isEof) {
                    throw copy ErrorMsg::note (loc, SyntaxErrorMessage::IN_DECL_BLOCK, notes-> copy [err]);
                } else {
                    throw err;
                }
            }
        }
        
        copy BlockDecl (loc, comm, decls, protection-> Protection::PRIVATE)        
    }
    
    /**
     * Read a protection block
     * @verbatim:
     * ```
     * protection_block :=   (attributes)? (Keys::PUBLIC | Keys::PRIVATE) declaration
     *                     | (attributes)? (Keys::PUBLIC | Keys::PRIVATE) Keys::EXTERN Lang? declaration
     *                     | (Keys::PUBLIC | Keys::PRIVATE) '{' protected_decl_block '}'
     * ```
     */
    fn readProtectionBlock (self, dmut context : &SyntaxVisitor, loc : &Word, comm : [c8], attribs : (&Word, [AttributeWord], [c8])) -> &BlockDecl
        throws ErrorMsg
    {                
        let protection = if (loc.str == Keys::PRIVATE) {
            Protection::PRIVATE
        } else {
            Protection::PUBLIC
        };
        
        let (tok, _) = context:.readToken ();
        let decls = match tok.str {
            Tokens::LACC => {
                self.checkNoAttributes (tok, attribs._0, attribs._1);
                let blk = self.readBlock (alias context,
                                          loc,
                                          "",
                                          closing-> true,
                                          inProtection-> true);
                blk.getDeclarations ()
            }
            Keys::EXTERN => {
                copy [self.readExternBlock (alias context,
                                            loc-> tok,
                                            comm-> comm,
                                            attribs-> attribs)]                
            }
            _ => {
                context:.rewind ();
                copy [self.readDeclaration (alias context,
                                            comm-> comm,
                                            attribs-> (attribs._0, attribs._1),
                                            expected-> self._special.listKeysExtern)]    
            }
        }
        
        copy BlockDecl (loc, comm, decls, protection-> protection)
    }

    /**
     * Read an external declaration block
     * @verbatim:
     * ```
     * extern :=   attributes? Keys::EXTERN (language)? declaration
     *
     * language := '(' 'C' ')'
     *             | '(' 'Y' (',' path)? ')'
     * 
     * ```
     */
    pub fn readExternBlock (self, dmut context : &SyntaxVisitor,
                            loc : &Word,
                            comm : [c8],
                            attribs : (&Word, [AttributeWord], [c8]))-> &ExternBlockDecl
        throws ErrorMsg
    {
        let (fst, _) = context:.readIf (Tokens::LPAR);
        
        let (lang, space) = if !fst.isEof {
            let (ln, _) = context:.readTokens (Keys::CLANG, Keys::YLANG);
            let space = if ln == Keys::YLANG && !context:.readIf (Tokens::COMA)._0.isEof {
                self.readPath (alias context) 
            } else {
                EMPTY_EXPR
            };
            
            context:.readTokens (Tokens::RPAR);
            (ln, space)
        } else {
            (loc.locate (Keys::YLANG), EMPTY_EXPR)
        };
        
        let content = self.readDeclaration (alias context,
                                            comm-> comm ~ attribs._2,
                                            attribs-> (attribs._0, attribs._1),
                                            expected-> self._special.listKeys);                                                    

        copy ExternBlockDecl (loc, comm, lang, space, content)
    }    

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ==================================          LOCAL MODULE          ==================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Read a local module
     * @verbatim:
     * ```
     * local_module :=   Keys::MOD Identifier '{' decl_block '}'
     *                 | Keys::MOD ('if' expression:(0))? Identifier template_param_list decl_block
     *                 | Keys::MOD ('.' | '::')? Identifier ';'
     * ```
     * */
    fn readLocalModule (self, dmut context : &SyntaxVisitor, loc : &Word, comm : [c8])-> &Declaration
        throws ErrorMsg
    {
        let (hasTest, test) = context:.readTemplateTest ();
        if !hasTest.isEof { // a template local module
            let (ident, _) = context:.readIdentifier ();
            return self.readTemplateLocalModule (alias context, comm, ident, ifLoc-> hasTest, test);
        }
        
        let (isSub, _) = context:.readIf (Tokens::DCOLON, Tokens::DOT);        
        let (ident, _) = context:.readIdentifier ();

        let (isEnd, _) = context:.readIf (Tokens::SEMI_COLON);        
        if isSub.isEof && isEnd.isEof { // mod Ident '{' decl_block '}'
            return self.readLocalModule (alias context, comm, ident); 
        }

        // 'mod' ('.' | '::')? Ident
        copy ImportDecl (loc, comm, ident, isSub-> isSub)        
    }
    
    /**
     * Read a local module (with no if test) but a declaration block
     * @verbatim:
     * ```
     * local_module_block := 'mod' Identifier (template_param_list)? '{' decl_block '}'
     * ```
     * */
    pub fn readLocalModule (self, dmut context : &SyntaxVisitor, comm : [c8], ident : &Word)-> &Declaration
        throws ErrorMsg
    {
        let (templates, _) = context:.readTemplateParameters (ifLoc-> EOF_WORD, force-> false);
        let (start, comm_) = context:.readTokens (Tokens::LACC);

        let content = self.readBlock (alias context, start, comm_, closing-> true, inProtection-> false);
        if (templates.len != 0) {
            copy TemplateDecl (ident, comm, templates, test-> EMPTY_EXPR,
                               copy ModuleDecl (ident, EOF_WORD, comm, content, isGlobal-> false))       
        } else {
            copy ModuleDecl (ident, EOF_WORD, comm, content, isGlobal-> false)       
        }                
    }   

    /**
     * Read a template local module
     * @verbatim:
     * ```     
     * local_module_template := 'mod' ('if' expression:0)? Identifier (template_param_list) '{' decl_block '}'
     * ```
     * */
    pub fn readTemplateLocalModule (self, dmut context : &SyntaxVisitor, comm : [c8], ident : &Word, ifLoc : &Word, test : &Expression)-> &Declaration
        throws ErrorMsg
    {
        let (templates, _) = context:.readTemplateParameters (ifLoc-> ifLoc, force-> true);
        let (start, comm_) = context:.readTokens (Tokens::LACC);

        let content = self.readBlock (alias context, start, comm_, closing-> true, inProtection-> false);        
        copy TemplateDecl (ident, comm, templates, test-> test,
                           copy ModuleDecl (ident, EOF_WORD, comm, content, isGlobal-> false))        
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ======================================          USE          =======================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Read a use declaration
     * @verbatim:
     * ```
     * use_decl := 'use' '::'? Identifier (complex_path)? ';'
     * ```
     * */
    pub fn readUse (self, dmut context : &SyntaxVisitor, loc : &Word, comm : [c8])-> [&Declaration]
        throws ErrorMsg
    {
        let mut res : [mut &Expression] = [];
        
        let (isRoot, _) = context:.readIf (Tokens::DCOLON);        
        let (fst, _) = context:.readIdentifier ();

        self.readComplexPath (alias context, copy VarExpr (fst), ref res);

        
        context:.readTokens (Tokens::SEMI_COLON);

        copy [copy UseDecl (loc, comm, i, isRoot-> !isRoot.isEof) for i in res]                        
    }

    
    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ==================================          DECLARATIONS          ==================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Read a declaration inside a local block (i.e. inside a function)
     * @verbatim:
     * ```
     * local_declaration :=  'use' complex_path ';' 
     *                      | extern_decl_block                            
     *                      | declaration
     * ```
     * */
    pub fn readLocalDeclaration (self, dmut context : &SyntaxVisitor)-> &Declaration
        throws ErrorMsg
    {
        let (n, _) = context:.readIf (Keys::USE, Keys::EXTERN);
        {
            match n.str {
                Keys::USE => {
                    let decls = self.readUse (alias context,
                                              loc-> n,
                                              comm-> "");      
                    copy BlockDecl (n, "", decls, protection-> Protection::PRIVATE, isSet-> true)
                }
                Keys::EXTERN => {
                    self.readExternBlock (alias context,
                                          loc-> n,
                                          comm-> "",
                                          attribs-> (EOF_WORD, [], ""))
                }
                _ => {
                    let (attrLoc, attribs, attrComm) = self.readAttributes (alias context);
                    self.readDeclaration (alias context,
                                          attrComm,
                                          attribs-> (attrLoc, attribs),
                                          expected-> self._special.listKeysExternUse)        
                }                
            }
        } catch {
            err => {
                let prevNotes = err.getNotes ();
                let nNote = copy ErrorMsg::note (EOF_WORD, format (SyntaxErrorMessage::READING_LOCAL_DECLARATION));
                throw err.withNote (copy [nNote] ~ prevNotes);
            }
        }
    }                                                                   

    /**
     * @returns: true if the next token starts a local declaration
     * */
    pub fn isLocalDeclaration (self, context : &SyntaxVisitor)-> bool {
        let n = context.peekToken ();
        for z in self._special.listKeysExternUse if z == n.str {
            return true;
        }
        
        false
    }
    
    /**
     * Read a declaration
     * @verbatim:
     * ```
     * declaration :=   class_decl
     *                | function_decl
     *                | lazy_decl
     *                | record_decl
     *                | static_decl
     *                | entity_decl
     *                | union_decl     
     *                | mod_decl
     *                | def_decl
     *                | enum_decl
     *                | macro_decl
     *                | trait_decl
     *                | unittest_decl
     *                | use_decl
     * ```
     */
    fn readDeclaration (self,
                        dmut context : &SyntaxVisitor,
                        comm : [c8],
                        attribs : (&Word, [AttributeWord]),
                        expected : [[c8]])-> &Declaration
        
        throws ErrorMsg
    {
        
        let (tok, postComm) = context:.readToken ();

        // Globals with attributes
        match tok.str {
            Keys::CLASS    => { return context:.readClass (tok, comm ~ postComm, attribs-> attribs._1); }
            Keys::FUNCTION => { return context:.readFunction (tok, comm ~ postComm, attribs-> attribs._1); }
            Keys::LAZY     => { return context:.readGlobal (tok, comm ~ postComm, attribs-> attribs._1); }
            Keys::RECORD   => { return context:.readClass (tok, comm ~ postComm, attribs-> attribs._1, isRecord-> true); }
            Keys::STATIC   => { return context:.readGlobal (tok, comm ~ postComm, isStatic-> true, attribs-> attribs._1); }
            Keys::ENTITY   => { return context:.readClass (tok, comm ~ postComm, attribs-> attribs._1, isEntity-> true); }
            Keys::UNION    => { return context:.readClass (tok, comm ~ postComm, attribs-> attribs._1,  isUnion-> true); }
        }
        
        // Global without attributes
        self.checkNoAttributes (tok, attribs._0, attribs._1);
        match tok.str {
            Keys::MOD      => { return self.readLocalModule (alias context, tok, comm ~ postComm); }
            
            Keys::DEF      => { return context:.readDef (tok, comm ~ postComm); }
            Keys::ENUM     => { return context:.readEnum (tok, comm ~ postComm); }
            Keys::MACRO    => { return context:.readMacro (tok, comm ~ postComm); }            
            Keys::TRAIT    => { return context:.readTrait (tok, comm ~ postComm); }
            Keys::UNITTEST => { return context:.readUnitTest (tok, comm ~ postComm); }                        
        }                          
        
        throw copy ErrorMsg::fatal (tok, format (SyntaxErrorMessage::UNEXPECTED_BUT_LST, tok.str, expected));
    }
    
    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =====================================          UTILS          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */
    
    /**
     * Read a list of custom attributes, if the token Tokens::AT is not read, then an empty list is returned
     * @info: Not rewindable, if start with Tokens::AT, it is an attribute
     * @verbatim:
     * ```
     * attributes_lst :=  '@' '{' Attribute (Tokens::COMA Attribute)* '}')
     *                   | '@' Attribute ('@' Attribute)*
     * ```
     * @returns:
     *   - .0: the location of the attribute reading (or EOF if nothing read)
     *   - .1: the list of attributes read
     *   - .2: the comments on top of the attribute list
     */
    pub fn readAttributes (self, dmut context : &SyntaxVisitor)-> (&Word, [AttributeWord], [c8])
        throws ErrorMsg
    {
        // All attributes start with Tokens::AT '@'
        let (next, comm) = context:.readIf (Tokens::AT);
        if (next.isEof) return (EOF_WORD, [], []);

        // List starts with '@' '{
        let (open, _) = context:.readIf (Tokens::LACC);
        let mut vec : [mut AttributeWord] = [];
        loop {
            let (identifier, _) = context:.readTokens (expand Attributes::__members__);

            // Check if already read
            for j in vec if j.attr == identifier {
                throw copy ErrorMsg::fatal (j.loc, end-> identifier, format (SyntaxErrorMessage::MULTIPLE_ATTRS, j.attr));            
            }

            // No need to check wether it exists, it necessarily does, we read it in context:.readTokens
            for id in Attributes::__members__ if id == identifier {
                vec ~= [AttributeWord (identifier, id)];                    
                break;            
            }
            

            // Only one, not a list (not read '{')
            if (open.isEof) {
                // But they can be chained with another '@'
                let (at,_) = context:.readIf (Tokens::AT);
                if (at.isEof) break;
            } else {
                // multiple, either ',' or '}'
                let (close, _) = context:.readTokens (Tokens::COMA, Tokens::RACC);
                if (close.str == Tokens::RACC) break;
            }
        }        

        (next, vec, comm)
    }

    /**
     * Throw a syntax error if there are attributes in a wrong position (i.e. !attrLoc.isEof)
     * @params:
     *    - loc: the location of the declaration that cannot have attributes
     *    - attrLoc: the attributes location (or EOF if not read)
     *    - attribs: the list of read attributes
     * */
    pub fn checkNoAttributes (self, loc : &Word, attrLoc : &Word, attribs : [AttributeWord])
        throws ErrorMsg
    {        
        if (attrLoc.isEof) return;
        
        let mut notes : [&ErrorMsg] = [];
        if !loc.isEof {
            notes = copy [copy ErrorMsg::note (loc, "")];
        }                
        
        throw copy ErrorMsg::fatal (attrLoc,
                                    format (SyntaxErrorMessage::UNEXPECTED_ATTRIBUTES, copy [x.attr for x in attribs]),
                                    notes-> notes);                
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =====================================          PATHS          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Read a namepath expression
     * @verbatim:
     * ```
     * namepath_expr := Identifier ('::' Identifier)*
     * ```
     */
    pub fn readPath (self, dmut context : &SyntaxVisitor) -> &Expression
        throws ErrorMsg
    {
        let (fst, _) = context:.readIdentifier ();
        let mut res : &Expression = copy VarExpr (fst);
        while let (colon, _) = context:.readIf (Tokens::DCOLON) && !colon.isEof {            
            let (next, _) = context:.readIf (Keys::UNDER);
            match next.str {
                Keys::UNDER => {
                    return copy PathExpr (colon, res, copy VarExpr (next));
                }
                _ => {
                    let (ident, _) = context:.readIdentifier ();
                    res = copy PathExpr (colon, res, copy VarExpr (ident));
                }
            }
        }         

        res
    }

    /**
     * Read a complex path
     * @example:
     * ====
     * foo::{bar, baz} => [ foo::bar, foo::baz ]
     * foo::{bar::{baz, bad::ouch}, fee} ==> [ foo::bar::baz, foo::bar::bad::ouch, foo::fee ]
     * ====
     * @verbatim:
     * ```
     * complex_path :=   ('::' Identifier)* ('::' '{' sub_complex '}')?
     *                 | ('::' Identifier)* ('::' '_')?
     * ```
     * */
    fn readComplexPath (self, dmut context : &SyntaxVisitor, root : &Expression, ref mut result : [&Expression])
        throws ErrorMsg
    {
        let mut res = root;        
        while let (colon, _) = context:.readIf (Tokens::DCOLON) && !colon.isEof {
            let (next, _) = context:.readIf (Tokens::LACC, Keys::UNDER);
            match next.str {
                Tokens::LACC => {
                    self.readSubComplexPath (alias context, colon, res, ref result);

                    // We return to avoid adding the current that is not imported by this use
                    return;
                }
                Keys::UNDER => {
                    res = copy PathExpr (colon, res, copy VarExpr (next));
                    break;
                }
                _ => {                    
                    let (ident, _) = context:.readIdentifier ();
                    res = copy PathExpr (next, res, copy VarExpr (ident));
                }
            }
        }
        
        result ~= [res];        
    }

    /**
     * Read the sub part of a complex path
     * @verbatim:
     * ```
     * sub_complex :=  inner_sub_complex (',' inner_sub_complex)*
     * inner_sub_complex :=   Identifier complex_path
     *                      | '_'
     * ```
     * */
    fn readSubComplexPath (self, dmut context : &SyntaxVisitor, colon : &Word, root : &Expression, ref mut result : [&Expression])
        throws ErrorMsg
    {
        loop {
            let (next, _) = context:.readIf (Keys::UNDER);
            match next.str {
                Keys::UNDER => {
                    result ~= [copy PathExpr (next, root, copy VarExpr (next))];
                }
                _ => {                    
                    let (ident, _) = context:.readIdentifier ();
                    let current = copy PathExpr (colon, root, copy VarExpr (ident));
                    self.readComplexPath (alias context, current, ref result);
                }
            }

            let (end, _) = context:.readTokens (Tokens::RACC, Tokens::COMA); 
            if (end == Tokens::RACC) break;
        }
    }
    
    
} 
