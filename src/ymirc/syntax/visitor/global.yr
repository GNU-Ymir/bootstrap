/*
 * Syntax visitor of global symbols that are declared within a module
 *
 * <hr>
 * 
 * @Package: ymirc        
 * @Module: ymirc::syntax::visitor::global
 * @File: ymirc/syntax/visitor/global.yr
 * @Author(s):
 *   - Emile Cadorel <ecadorel@gmail.com>
 *
 * @Created (YYYY-MM-DD): 2026-02-06
 * @Copyright (C) 2021–2026 GNU-Ymir
 * @License
 *   ```text
 *   This file is part of the Ymir language project.
 *
 *   Ymir is free software: you can redistribute it and/or modify it
 *   under the terms of the GNU General Public License as published by
 *   the Free Software Foundation, either version 3 of the License, or
 *   (at your option) any later version.
 *
 *   Ymir is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with Ymir.  If not, see <https://www.gnu.org/licenses/>.
 *   ```
 */

in global;

use ymirc::errors::_;
use ymirc::syntax::{_,
                    visitor::_,
                    declaration::_,
                    expression::{_, literal::_, macro_::_, operator::_, template::_}};

use ymirc::lexing::{word, tokens, keys};
use ymirc::utils::_;


/**
 *  Lazy initialization of global declaration keys*/
lazy __SPECIAL_GLOBAL__ = SpecialGlobal ();


/**
 * Global keys, to list what keys are allowed in given context
 * */
record SpecialGlobal {
    
    pub let listKeys:                [[c8]] = copy GlobalDeclKeys:: __members__;    
    pub let listKeysExtern:          [[c8]];    
    pub let listKeysExternPubPrvUse: [[c8]];    
    pub let listKeysExternUse:       [[c8]];

    pub self ()
        with listKeysExtern       = self.listKeys ~ [Keys::EXTERN]
        , listKeysExternUse       = self.listKeysExtern ~ [Keys::USE]
        , listKeysExternPubPrvUse = self.listKeysExternUse ~ [Keys::PUBLIC, Keys::PRIVATE]
    {}
}

/**
 * Syntax visitor to read global symbol declaration
 * This visitor is executed on the top level of a file
 * 
 * */
pub record GlobalVisitor {

    let _special: SpecialGlobal = __SPECIAL_GLOBAL__;
    
    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ======================================          CTOR          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */

    pub self () {}            

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =================================          IMPLEMENTATION          =================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Read a declaration block
     * @params:
     *   - context: the context of the reading
     *   - loc: the location of the first read word
     *   - comm: the comment on top of the block to read
     * @returns: the block read
     *
     *
     * @verbatim
     * ```
     * Module ->
     *    DeclBlock EOF
     *    
     * ```
     * */
    pub fn readBlock (self, dmut context: &SyntaxVisitor, loc: &Word, comm: [c8])-> &BlockDecl
        throws ErrorMsg
    {
        self.readBlockTop (alias context,
                           loc, 
                           comm,
                           closing-> false)                        
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =====================================          BLOCKS          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */
    
    /**
     * Read a declaration block at top level (module level)
     * @params:
     *   - context: the context of the reading
     *   - loc:     the location of the block being read
     *   - comm:    the comment on top of the block to read
     *   - closing: true iif a Tokens: : LACC was read, and a RACC needs to be read to close the current block
     *   
     * @returns: the block read
     * 
     * @verbatim:
     * ```
     * DeclBlock ->
     *   DeclBlockItem DeclBlock
     *   | ε
     *
     * DeclBlockItem ->
     *      ProtectionBlock
     *    | UseDecl
     *    | ExternDeclBlock     
     *    | Declaration         
     * ```
     * */
    fn readBlockTop (self, dmut context: &SyntaxVisitor, loc: &Word, comm: [c8], closing: bool)-> &BlockDecl
        throws ErrorMsg
    {
        let mut decls: [mut &Declaration] = [];
        {
            loop {
                // Read attributes for the next declaration
                let (attrLoc, attribs, attrComm) = self.readAttributes (alias context);

                let (tok, tokComm) = context:.readToken ();                                                            
                match tok.str {
                    Keys::PUBLIC | Keys::PRIVATE => {                                            
                        decls ~= [self.readProtectionBlock (alias context, tok, tokComm, attribs-> (attrLoc, attribs, attrComm))];                    
                    }
                    Keys::USE  => {                                                
                        self.checkNoAttributes (tok, attrLoc, attribs);
                        decls ~= self.readUse (alias context, tok, tokComm);
                    }                                                                    
                    Keys::EXTERN => {                        
                        decls ~= [self.readExternBlock (alias context,
                                                        loc-> tok,
                                                        comm-> attrComm ~ tokComm,
                                                        attribs-> (attrLoc, attribs, attrComm))]
                    }
                    Tokens::RACC => {                        
                        if !closing throw copy ErrorMsg::fatal (tok, format (SyntaxErrorMessage::UNEXPECTED, tok));
                        self.checkNoAttributes (tok, attrLoc, attribs);
                        break;
                    }
                    _ => {                        
                        // We read nothing, because there's nothing to read
                        if tok.isEof {
                            if closing throw copy ErrorMsg::fatal (loc, end-> tok, SyntaxErrorMessage::BLOCK_NEVER_CLOSED);
                            self.checkNoAttributes (tok, attrLoc, attribs);
                            break;
                        }
                        
                        decls ~= [self.readDeclaration (alias context,
                                                        tok, 
                                                        comm-> attrComm ~ tokComm,
                                                        attribs-> (attrLoc, attribs),
                                                        expected-> self._special.listKeysExternPubPrvUse)];                     
                    }
                }
            }
        } catch {
            err => {
                if (!loc.isEof) {
                    throw copy ErrorMsg::note (loc, SyntaxErrorMessage::IN_DECL_BLOCK, notes-> copy [err]);
                } else {
                    throw err;
                }
            }
        }
        
        copy BlockDecl (loc, comm, decls, protection-> Protection::PRIVATE)        
    }


    /**
     * Read a declaration block within a pub { ... }, prv { ... } block
     * */
    fn readBlockProtected (self, dmut context: &SyntaxVisitor, loc: &Word)-> [&Declaration]
        throws ErrorMsg
    {
        let mut decls: [mut &Declaration] = [];
        {
            loop {
                // Read attributes for the next declaration
                let (attrLoc, attribs, attrComm) = self.readAttributes (alias context);

                let (tok, tokComm) = context:.readToken ();                                                            
                match tok.str {                                                            
                    Keys::EXTERN => {                        
                        decls ~= [self.readExternBlock (alias context,
                                                        loc-> tok,
                                                        comm-> attrComm ~ tokComm,
                                                        attribs-> (attrLoc, attribs, attrComm))]
                    }
                    Tokens::RACC => {                                                
                        self.checkNoAttributes (tok, attrLoc, attribs);
                        break;
                    }
                    _ => {                        
                        // We read nothing, because there's nothing to read, but protection block are always opened
                        if tok.isEof {
                            throw copy ErrorMsg::fatal (loc, end-> tok, SyntaxErrorMessage::BLOCK_NEVER_CLOSED);                            
                        }
                        
                        // Or a declaration a protected declaration
                        decls ~= [self.readDeclaration (alias context,
                                                        tok, 
                                                        comm-> attrComm ~ tokComm,
                                                        attribs-> (attrLoc, attribs),
                                                        expected-> self._special.listKeysExtern)];                     
                    }
                }
            }
        } catch {
            err => {
                if (!loc.isEof) {
                    throw copy ErrorMsg::note (loc, SyntaxErrorMessage::IN_DECL_BLOCK, notes-> copy [err]);
                } else {
                    throw err;
                }
            }
        }
        
        decls    
    }
    
    /**
     * Read a protection block
     * @verbatim:
     * ```
     * protection_block :=   (attributes)? (Keys::PUBLIC | Keys::PRIVATE) declaration
     *                     | (attributes)? (Keys::PUBLIC | Keys::PRIVATE) Keys::EXTERN Lang? declaration
     *                     | (Keys::PUBLIC | Keys::PRIVATE) '{' protected_decl_block '}'
     * ```
     */
    fn readProtectionBlock (self, dmut context: &SyntaxVisitor, loc: &Word, comm: [c8], attribs: (&Word, [AttributeWord], [c8])) -> &BlockDecl
        throws ErrorMsg
    {                
        let protection = if (loc.str == Keys::PRIVATE) {
            Protection::PRIVATE
        } else {
            Protection::PUBLIC
        };
        
        let (tok, _) = context:.readToken ();
        let decls = match tok.str {
            Tokens::LACC => {
                self.checkNoAttributes (tok, attribs._0, attribs._1);
                self.readBlockProtected (alias context, loc)                                                               
            }
            Keys::EXTERN => {
                copy [self.readExternBlock (alias context,
                                            loc-> tok,
                                            comm-> comm,
                                            attribs-> attribs)]                
            }
            _ => {
                context:.rewind ();
                copy [self.readDeclaration (alias context,
                                            tok,
                                            comm-> comm,
                                            attribs-> (attribs._0, attribs._1),
                                            expected-> self._special.listKeysExtern)]    
            }
        }
        
        copy BlockDecl (loc, comm, decls, protection-> protection)
    }

    /**
     * Read an external declaration block
     * @verbatim:
     * ```
     * extern :=   attributes? Keys::EXTERN (language)? declaration
     *
     * language := '(' 'C' ')'
     *             | '(' 'Y' (',' path)? ')'
     * 
     * ```
     */
    pub fn readExternBlock (self, dmut context: &SyntaxVisitor,
                            loc: &Word,
                            comm: [c8],
                            attribs: (&Word, [AttributeWord], [c8]))-> &ExternBlockDecl
        throws ErrorMsg
    {
        let (fst, _) = context:.readIf (Tokens::LPAR);
        
        let (lang, space) = if !fst.isEof {
            let (ln, _) = context:.readTokens (Keys::CLANG, Keys::YLANG);
            let space = if ln == Keys::YLANG && !context:.readIf (Tokens::COMA)._0.isEof {
                self.readPath (alias context) 
            } else {
                EMPTY_EXPR
            };
            
            context:.readTokens (Tokens::RPAR);
            (ln, space)
        } else {
            (loc.locate (Keys::YLANG), EMPTY_EXPR)
        };

        let (tok, _) = context:.readToken (); 
        let content = self.readDeclaration (alias context,
                                            tok,
                                            comm-> comm ~ attribs._2,
                                            attribs-> (attribs._0, attribs._1),
                                            expected-> self._special.listKeys);                                                    

        copy ExternBlockDecl (loc, comm, lang, space, content)
    }    
    
    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ==================================          LOCAL MODULE          ==================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Read a local module
     * @verbatim:
     * ```
     * local_module :=   Keys::MOD Identifier '{' decl_block '}'
     *                 | Keys::MOD ('if' expression:(0))? Identifier template_param_list decl_block
     *                 | Keys::MOD ('.' | '::')? Identifier ';'
     * ```
     * */
    fn readLocalModule (self, dmut context: &SyntaxVisitor, loc: &Word, comm: [c8])-> &Declaration
        throws ErrorMsg
    {
        let (hasTest, test) = context:.readTemplateTest ();
        if !hasTest.isEof { // a template local module
            let (ident, _) = context:.readIdentifier ();
            return self.readTemplateLocalModule (alias context, comm, ident, ifLoc-> hasTest, test);
        }
        
        let (isSub, _) = context:.readIf (Tokens::DCOLON, Tokens::DOT);        
        let (ident, _) = context:.readIdentifier ();

        let (isEnd, _) = context:.readIf (Tokens::SEMI_COLON);        
        if isSub.isEof && isEnd.isEof { // mod Ident '{' decl_block '}'
            return self.readLocalModule (alias context, comm, ident); 
        }

        // 'mod' ('.' | '::')? Ident
        copy ImportDecl (loc, comm, ident, isSub-> isSub)        
    }
    
    /**
     * Read a local module (with no if test) but a declaration block
     * @verbatim:
     * ```
     * local_module_block := 'mod' Identifier (template_param_list)? '{' decl_block '}'
     * ```
     * */
    pub fn readLocalModule (self, dmut context: &SyntaxVisitor, comm: [c8], ident: &Word)-> &Declaration
        throws ErrorMsg
    {
        let (templates, _) = context:.readTemplateParameters (ifLoc-> EOF_WORD, force-> false);
        let (start, tokComm) = context:.readTokens (Tokens::LACC);

        let content = self.readBlockTop (alias context, start, tokComm, closing-> true);
        if (templates.len != 0) {
            copy TemplateDecl (ident, comm, templates, test-> EMPTY_EXPR,
                               copy ModuleDecl (ident, EOF_WORD, comm, content, isGlobal-> false))       
        } else {
            copy ModuleDecl (ident, EOF_WORD, comm, content, isGlobal-> false)       
        }                
    }   

    /**
     * Read a template local module
     * @verbatim:
     * ```     
     * local_module_template := 'mod' ('if' expression:0)? Identifier (template_param_list) '{' decl_block '}'
     * ```
     * */
    pub fn readTemplateLocalModule (self, dmut context: &SyntaxVisitor, comm: [c8], ident: &Word, ifLoc: &Word, test: &Expression)-> &Declaration
        throws ErrorMsg
    {
        let (templates, _) = context:.readTemplateParameters (ifLoc-> ifLoc, force-> true);
        let (start, tokComm) = context:.readTokens (Tokens::LACC);

        let content = self.readBlockTop (alias context, start, tokComm, closing-> true);        
        copy TemplateDecl (ident, comm, templates, test-> test,
                           copy ModuleDecl (ident, EOF_WORD, comm, content, isGlobal-> false))        
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ======================================          USE          =======================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Read a use declaration
     * @verbatim:
     * ```
     * use_decl := 'use' '::'? Identifier (complex_path)? ';'
     * ```
     * */
    pub fn readUse (self, dmut context: &SyntaxVisitor, loc: &Word, comm: [c8])-> [&Declaration]
        throws ErrorMsg
    {
        let mut res: [mut &Expression] = [];
        
        let (isRoot, _) = context:.readIf (Tokens::DCOLON);        
        let (fst, _) = context:.readIdentifier ();

        self.readComplexPath (alias context, copy VarExpr (fst), ref res);

        
        context:.readTokens (Tokens::SEMI_COLON);

        copy [copy UseDecl (loc, comm, i, isRoot-> !isRoot.isEof) for i in res]                        
    }

    
    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ==================================          DECLARATIONS          ==================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Read a declaration inside a local block (i.e. inside a function)
     * @verbatim:
     * ```
     * local_declaration :=  'use' complex_path ';' 
     *                      | extern_decl_block                            
     *                      | declaration
     * ```
     * */
    pub fn readLocalDeclaration (self, dmut context: &SyntaxVisitor)-> &Declaration
        throws ErrorMsg
    {
        // Read attributes for the next declaration
        let (attrLoc, attribs, attrComm) = self.readAttributes (alias context);        
        let (tok, tokComm) = context:.readToken ();
        {
            match tok.str {
                Keys::USE => {
                    self.checkNoAttributes (tok, attrLoc, attribs);
                    let decls = self.readUse (alias context,
                                              loc-> tok,
                                              comm-> tokComm);      
                    copy BlockDecl (tok, "", decls, protection-> Protection::PRIVATE, isSet-> true)
                }
                Keys::EXTERN => {
                    self.checkNoAttributes (tok, attrLoc, attribs);
                    self.readExternBlock (alias context,
                                          loc-> tok,
                                          comm-> tokComm,
                                          attribs-> (EOF_WORD, [], ""))
                }
                _ => {                    
                    self.readDeclaration (alias context,
                                          tok, 
                                          attrComm ~ tokComm,
                                          attribs-> (attrLoc, attribs),
                                          expected-> self._special.listKeysExternUse)        
                }                
            }
        } catch {
            err => {
                let prevNotes = err.getNotes ();
                let nNote = copy ErrorMsg::note (EOF_WORD, format (SyntaxErrorMessage::READING_LOCAL_DECLARATION));
                throw err.withNote (copy [nNote] ~ prevNotes);
            }
        }
    }                                                                   

    /**
     * @returns: true if the next token starts a local declaration
     * */
    pub fn isLocalDeclaration (self, context: &SyntaxVisitor)-> bool {
        let n = context.peekToken ();
        for z in self._special.listKeysExternUse if z == n.str {
            return true;
        }
        
        false
    }
    
    /**
     * Read a declaration
     * @verbatim:
     * ```
     * declaration :=   class_decl
     *                | function_decl
     *                | lazy_decl
     *                | record_decl
     *                | static_decl
     *                | entity_decl
     *                | union_decl     
     *                | mod_decl
     *                | def_decl
     *                | enum_decl
     *                | macro_decl
     *                | trait_decl
     *                | unittest_decl
     *                | use_decl
     * ```
     */
    fn readDeclaration (self,
                        dmut context: &SyntaxVisitor,
                        tok: &Word,                        
                        comm: [c8],
                        attribs: (&Word, [AttributeWord]),
                        expected: [[c8]])-> &Declaration
        
        throws ErrorMsg
    {            
        // Globals with attributes
        match tok.str {
            Keys::CLASS    => { return context:.readClass (tok, comm, attribs-> attribs._1); }
            Keys::FUNCTION => { return context:.readFunction (tok, comm, attribs-> attribs._1); }
            Keys::LAZY     => { return context:.readGlobal (tok, comm, attribs-> attribs._1); }
            Keys::RECORD   => { return context:.readClass (tok, comm, attribs-> attribs._1, isRecord-> true); }
            Keys::STATIC   => { return context:.readGlobal (tok, comm, isStatic-> true, attribs-> attribs._1); }
            Keys::ENTITY   => { return context:.readClass (tok, comm, attribs-> attribs._1, isEntity-> true); }
            Keys::UNION    => { return context:.readClass (tok, comm, attribs-> attribs._1,  isUnion-> true); }
        }
        
        // Global without attributes
        self.checkNoAttributes (tok, attribs._0, attribs._1);
        match tok.str {
            Keys::MOD      => { return self.readLocalModule (alias context, tok, comm); }
            
            Keys::DEF      => { return context:.readDef (tok, comm); }
            Keys::ENUM     => { return context:.readEnum (tok, comm); }
            Keys::MACRO    => { return context:.readMacro (tok, comm); }            
            Keys::TRAIT    => { return context:.readTrait (tok, comm); }
            Keys::UNITTEST => { return context:.readUnitTest (tok, comm); }                        
        }                          
        
        throw copy ErrorMsg::fatal (tok, format (SyntaxErrorMessage::UNEXPECTED_BUT_LST, tok.str, expected));
    }
    
    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =====================================          UTILS          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */
    
    /**
     * Read a list of custom attributes, if the token Tokens::AT is not read, then an empty list is returned
     * @info: Not rewindable, if start with Tokens::AT, it is an attribute
     * @verbatim:
     * ```
     * attributes_lst :=  '@' '{' Attribute (Tokens::COMA Attribute)* '}')
     *                   | '@' Attribute ('@' Attribute)*
     * ```
     * @returns:
     *   - .0: the location of the attribute reading (or EOF if nothing read)
     *   - .1: the list of attributes read
     *   - .2: the comments on top of the attribute list
     */
    pub fn readAttributes (self, dmut context: &SyntaxVisitor)-> (&Word, [AttributeWord], [c8])
        throws ErrorMsg
    {
        // All attributes start with Tokens::AT '@'
        let (next, comm) = context:.readIf (Tokens::AT);
        if (next.isEof) return (EOF_WORD, [], []);

        // List starts with '@' '{
        let (open, _) = context:.readIf (Tokens::LACC);
        let mut vec: [mut AttributeWord] = [];
        loop {
            let (identifier, _) = context:.readTokens (expand Attributes::__members__);

            // Check if already read
            for j in vec if j.attr == identifier {
                throw copy ErrorMsg::fatal (j.loc, end-> identifier, format (SyntaxErrorMessage::MULTIPLE_ATTRS, j.attr));            
            }

            // No need to check wether it exists, it necessarily does, we read it in context:.readTokens
            for id in Attributes::__members__ if id == identifier {
                vec ~= [AttributeWord (identifier, id)];                    
                break;            
            }
            

            // Only one, not a list (not read '{')
            if (open.isEof) {
                // But they can be chained with another '@'
                let (at,_) = context:.readIf (Tokens::AT);
                if (at.isEof) break;
            } else {
                // multiple, either ',' or '}'
                let (close, _) = context:.readTokens (Tokens::COMA, Tokens::RACC);
                if (close.str == Tokens::RACC) break;
            }
        }        

        (next, vec, comm)
    }

    /**
     * Throw a syntax error if there are attributes in a wrong position (i.e. !attrLoc.isEof)
     * @params:
     *    - loc: the location of the declaration that cannot have attributes
     *    - attrLoc: the attributes location (or EOF if not read)
     *    - attribs: the list of read attributes
     * */
    pub fn checkNoAttributes (self, loc: &Word, attrLoc: &Word, attribs: [AttributeWord])
        throws ErrorMsg
    {        
        if (attrLoc.isEof) return;
        
        let mut notes: [&ErrorMsg] = [];
        if !loc.isEof {
            notes = copy [copy ErrorMsg::note (loc, "")];
        }                
        
        throw copy ErrorMsg::fatal (attrLoc,
                                    format (SyntaxErrorMessage::UNEXPECTED_ATTRIBUTES, copy [x.attr for x in attribs]),
                                    notes-> notes);                
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =====================================          PATHS          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Read a namepath expression
     * @verbatim:
     * ```
     * namepath_expr := Identifier ('::' Identifier)*
     * ```
     */
    pub fn readPath (self, dmut context: &SyntaxVisitor) -> &Expression
        throws ErrorMsg
    {
        let (fst, _) = context:.readIdentifier ();
        let mut res: &Expression = copy VarExpr (fst);
        while let (colon, _) = context:.readIf (Tokens::DCOLON) && !colon.isEof {            
            let (next, _) = context:.readIf (Keys::UNDER);
            match next.str {
                Keys::UNDER => {
                    return copy PathExpr (colon, res, copy VarExpr (next));
                }
                _ => {
                    let (ident, _) = context:.readIdentifier ();
                    res = copy PathExpr (colon, res, copy VarExpr (ident));
                }
            }
        }         

        res
    }

    /**
     * Read a complex path
     * @example:
     * ====
     * foo::{bar, baz} => [ foo::bar, foo::baz ]
     * foo::{bar::{baz, bad::ouch}, fee} ==> [ foo::bar::baz, foo::bar::bad::ouch, foo::fee ]
     * ====
     * @verbatim:
     * ```
     * complex_path :=   ('::' Identifier)* ('::' '{' sub_complex '}')?
     *                 | ('::' Identifier)* ('::' '_')?
     * ```
     * */
    fn readComplexPath (self, dmut context: &SyntaxVisitor, root: &Expression, ref mut result: [&Expression])
        throws ErrorMsg
    {
        let mut res = root;        
        while let (colon, _) = context:.readIf (Tokens::DCOLON) && !colon.isEof {
            let (next, _) = context:.readIf (Tokens::LACC, Keys::UNDER);
            match next.str {
                Tokens::LACC => {
                    self.readSubComplexPath (alias context, colon, res, ref result);

                    // We return to avoid adding the current that is not imported by this use
                    return;
                }
                Keys::UNDER => {
                    res = copy PathExpr (colon, res, copy VarExpr (next));
                    break;
                }
                _ => {                    
                    let (ident, _) = context:.readIdentifier ();
                    res = copy PathExpr (next, res, copy VarExpr (ident));
                }
            }
        }
        
        result ~= [res];        
    }

    /**
     * Read the sub part of a complex path
     * @verbatim:
     * ```
     * sub_complex :=  inner_sub_complex (',' inner_sub_complex)*
     * inner_sub_complex :=   Identifier complex_path
     *                      | '_'
     * ```
     * */
    fn readSubComplexPath (self, dmut context: &SyntaxVisitor, colon: &Word, root: &Expression, ref mut result: [&Expression])
        throws ErrorMsg
    {
        loop {
            let (next, _) = context:.readIf (Keys::UNDER);
            match next.str {
                Keys::UNDER => {
                    result ~= [copy PathExpr (next, root, copy VarExpr (next))];
                }
                _ => {                    
                    let (ident, _) = context:.readIdentifier ();
                    let current = copy PathExpr (colon, root, copy VarExpr (ident));
                    self.readComplexPath (alias context, current, ref result);
                }
            }

            let (end, _) = context:.readTokens (Tokens::RACC, Tokens::COMA); 
            if (end == Tokens::RACC) break;
        }
    }
    
    
} 
