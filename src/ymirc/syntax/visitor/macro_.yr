/*
 * Syntax visitor of a `macro` symbol.
 *
 * <hr>
 * 
 * @Package: ymirc        
 * @Module: ymirc::syntax::visitor::macro_
 * @File: ymirc/syntax/visitor/macro_.yr
 * @Author(s):
 *   - Emile Cadorel <ecadorel@gmail.com>
 *
 * @Created (YYYY-MM-DD): 2026-02-14
 * @Copyright (C) 2021â€“2026 GNU-Ymir
 * @License
 *   ```text
 *   This file is part of the Ymir language project.
 *
 *   Ymir is free software: you can redistribute it and/or modify it
 *   under the terms of the GNU General Public License as published by
 *   the Free Software Foundation, either version 3 of the License, or
 *   (at your option) any later version.
 *
 *   Ymir is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with Ymir.  If not, see <https://www.gnu.org/licenses/>.
 *   ```
 */

in macro_;


use ymirc::errors::_;
use ymirc::syntax::{_,
                    visitor::_,
                    declaration::_,
                    expression::{empty, macro_, literal}};


use ymirc::lexing::{word, tokens, keys};
use ymirc::utils::_;

use std::io;


/**
 * Visitor in charge of reading a `macro` declaration.
 * */
pub record MacroVisitor {
    
    pub self () {}

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =================================          IMPLEMENTATION          =================================
     * ====================================================================================================
     * ====================================================================================================
     */


    /**
     * Read a macro declaration
     *
     * @params:
     *    - context: the context of the declaration
     *    - loc:     the location of the `macro` keyword
     *    - comm:    the comment above the macro declaration
     *
     * @grammar
     * ```
     * MacroDecl :=
     *   `macro` Identifier '{' MacroDecl* '}'
     *
     * MacroDecl :=
     *      MacroCtor
     *    | MacroRule
     *    | UseDecl
     *    
     * ```
     * */
    pub fn read (self, dmut context: &SyntaxVisitor, loc: &Word, comm: [c8])-> &MacroDecl
        throws ErrorMsg
    {
        // `macro` Identifier '{'
        let (ident, _) = context:.readIdentifier ();
        context:.readTokens (Tokens::LACC);
        
        let mut decls: [&Declaration] = [];
        loop {
            let (n, comm_) = context:.readToken ();
            match n.str {
                Tokens::RACC =>
                    break;
                
                Keys::USE => {
                    decls ~= context.getGlobalVisitor ().readUse (alias context, n, comm_);
                }

                Keys::FUNCTION => {
                    decls ~= [self.readRule (alias context, n, comm_)];
                }
                
                Keys::SELF => {
                    decls ~= [self.readCtor (alias context, n, comm_)];
                }
                
                _ => {
                    throw copy ErrorMsg::fatal (n, format (SyntaxErrorMessage::UNEXPECTED_BUT_LST,
                                                           copy [Keys::FUNCTION, Keys::SELF, Keys::USE]));
                }
            }            
        }

        return copy MacroDecl (loc-> loc,
                               comm-> comm,
                               name-> ident,
                               decls-> decls);
    }

    /**
     * Read a macro rule
     *
     * @grammar
     * ```
     * MacroRuleDecl :=
     *   'fn' Identifier MacroRuleHead MacroRuleBody
     *
     * MacroRuleBody :=
     *      StringExpr
     *    | ';'
     *
     * ```
     * */
    fn readRule (self, dmut context: &SyntaxVisitor, loc: &Word, comm: [c8])-> &MacroRuleDecl
        throws ErrorMsg
    {
        let (name, _) = context:.readIdentifier ();
        let (rule, skips) = self.readMacroRuleHead (alias context);
        
        let mut body: &Expression = EMPTY_EXPR;
        let (next, _) = context:.readToken ();
        if let str: &StringWord = next {
            match str.open {
                Tokens::MACRO_ACC | Tokens::MACRO_PAR | Tokens::MACRO_CRO => {
                    body = copy StringExpr (str.open, str.close, str.str, suffix-> str.suffix, trim-> str.trim);
                }
                
                _ => {
                    throw copy ErrorMsg::fatal (str.open,
                                                format (SyntaxErrorMessage::UNEXPECTED_BUT_LST, str.open.str,
                                                        copy [Tokens::MACRO_ACC, Tokens::MACRO_PAR, Tokens::MACRO_CRO]));
                }
            }
        }

        else if next.str != Tokens::SEMI_COLON {
            throw copy ErrorMsg::fatal (next, format (SyntaxErrorMessage::UNEXPECTED, next.str));
        }

        return copy MacroRuleDecl (loc-> loc,
                                   comm-> comm,
                                   name-> name,
                                   body-> body,
                                   rule-> rule,
                                   skips-> skips,
                                   isCtor-> false);
    }

    /**
     * Read a macro ctor
     *
     * @grammar
     * ```
     * MacroRuleDecl :=
     *   'self' MacroRuleHead StringExpr
     * ```
     * */
    fn readCtor (self, dmut context: &SyntaxVisitor, loc: &Word, comm: [c8])-> &MacroRuleDecl
        throws ErrorMsg
    {        
        let (rule, skips) = self.readMacroRuleHead (alias context);
        
        let mut body: &Expression = EMPTY_EXPR;
        let (next, _) = context:.readToken ();
        if let str: &StringWord = next {
            match str.open {
                Tokens::MACRO_ACC | Tokens::MACRO_PAR | Tokens::MACRO_CRO => {
                    body = copy StringExpr (str.open, str.close, str.str, suffix-> str.suffix, str.trim);
                }
                
                _ => {
                    throw copy ErrorMsg::fatal (str.open,
                                                format (SyntaxErrorMessage::UNEXPECTED_BUT_LST, str.open.str,
                                                        copy [Tokens::MACRO_ACC, Tokens::MACRO_PAR, Tokens::MACRO_CRO]));
                }
            }
        }

        else {
            throw copy ErrorMsg::fatal (next, format (SyntaxErrorMessage::UNEXPECTED, next.str));
        }

        return copy MacroRuleDecl (loc-> loc,
                                   comm-> comm,
                                   name-> EOF_WORD,
                                   body-> body,
                                   rule-> rule,
                                   skips-> skips,
                                   isCtor-> true);
    }



    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          RULE HEAD          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Read the head rule of a macro rule, or a macro ctor
     *
     * @params:
     *    - context: the context of the reading
     *
     * @returns:
     *    - .0: the rule
     *    - .1: the list of skip tokens
     *
     * @grammar:
     * ```     
     * MacroRuleHead :=
     *    MacroRuleExpression(0) (Keys::SKIPS StringExpr (Tokens::PIPE StringExpr)*)?
     *    
     * MacroRuleExpression(0) :=
     *    '(' MacroExpressionInner(0) ')'
     *
     * MacroExpressionInner(0) :=
     *      MacroExpression(1) (MacroExpression(1))*
     *    | MacroExpression(1) ('|' MacroExpression(1))*
     *
     * MacroExpression(1) :=
     *      MacroExpression(0) Multiplicator?
     *    | Identifier (Tokens::EQUAL MacroRuleInner)?
     *    | StringExpr
     *
     *
     * Multiplicator := '+' | '*' | '?'     
     * ```
     * */
    fn readMacroRuleHead (self, dmut context: &SyntaxVisitor)-> (&MacroMultExpr, [&StringExpr])
        throws ErrorMsg
    {
        let (open, _) = context:.readTokens (Tokens::LPAR);
        let (lst, end) = self.readExpression0 (alias context);        

        let mut skips: [&StringExpr] = []; 
        let (sk, _) = context:.readIf (Keys::SKIPS);
        if !sk.isEof loop {
            let (tok, _) = context:.readToken ();
            
            if let str: &StringWord = tok {
                match str.open {
                    Tokens::DQUOTE => {
                        skips ~= [copy StringExpr (str.open, str.close, str.str, suffix-> str.suffix, trim-> str.trim)];
                    }
                    
                    _ => {
                        throw copy ErrorMsg::fatal (str.open,
                                                    format (SyntaxErrorMessage::UNEXPECTED_BUT_LST, str.open.str,
                                                            copy [Tokens::DQUOTE]));
                    }
                }
            }

            else {
                throw copy ErrorMsg::fatal (tok, format (SyntaxErrorMessage::UNEXPECTED, tok.str));
            }

            let (stop, _) = context:.readIf (Tokens::PIPE);
            if stop.isEof
                break;
        }

        let mlt = copy MacroMultExpr (open, end, content-> lst);
        (mlt, skips)
    }

    /**
     * Read a first level macro expression (either a list or a Or)
     *
     * @params:
     *    - context: the context of the reading
     *
     * @returns:
     *    - .0: the list of read macro rules
     *    - .1: the location of the closing ')'
     *
     * @grammar: cf. `self.readMacroRuleHead`     
     * */
    fn readExpression0 (self, dmut context: &SyntaxVisitor)-> ([&MacroRuleExpression], &Word)
        throws ErrorMsg
    {
        let mut fst = self.readExpression1 (alias context);
        let (pipe, _) = context:.readIf (Tokens::PIPE);

        // Read a MacroOr
        if !pipe.isEof {
            let mut currPipe = pipe;
            loop {
                let scd = self.readExpression1 (alias context);
                fst = copy MacroOrExpr (currPipe, fst, scd);

                let (p, _) = context:.readTokens (Tokens::PIPE, Tokens::RPAR);
                currPipe = p;
                
                if p.isEof
                    break;                
            }

            return (copy [fst], currPipe);
        }
        
        // Read a macro list
        let mut end: &Word = EOF_WORD;
        let mut lst: [&MacroRuleExpression] = copy [fst];
        loop {
            let (e, _) = context:.readIf (Tokens::RPAR);
            if !e.isEof {
                end = e;
                break;                
            }
            
            lst ~= [self.readExpression1 (alias context)];
        }
        
        return (lst, end);
    }

    /**
     * Read a second level macro expression
     *
     * @params:
     *    - context: the context of the reading
     *
     * @returns: the read rule
     * 
     * @grammar: cf. `self.readMacroRuleHead`
     * */
    fn readExpression1 (self, dmut context: &SyntaxVisitor)-> &MacroRuleExpression
        throws ErrorMsg
    {
        let (open, _) = context:.readToken ();
        match open {
            //  MacroExpression(0) Multiplicator?
            Tokens::LPAR => {
                let (lst, end) = self.readExpression0 (alias context);

                let (mult, _) = context:.readIf (Tokens::PLUS, Tokens::STAR, Tokens::INTEG);
                return copy MacroMultExpr (open, end, content-> lst, mult-> mult);
            }
            str: &StringWord => { // "str"                         
                if str.open == Tokens::DQUOTE {
                    let ret = copy StringExpr (str.open, str.close, str.str, suffix-> str.suffix, trim-> str.trim);
                    return copy MacroTokenExpr (open, ret);
                }
                else throw copy ErrorMsg::fatal (str.open, format (SyntaxErrorMessage::UNEXPECTED_BUT_LST, str.open.str,
                                                                   copy [Tokens::DQUOTE]));
            }
            NameWord () => { // Identifier ('=' MacroRuleExpression(0))?
                let (i, _) = context:.readIf (Tokens::EQUAL);
                if !i.isEof {
                    let (par, _) = context:.readTokens (Tokens::LPAR);
                    let (lst, end) = self.readExpression0 (alias context);

                    let mult = copy MacroMultExpr (par, end, content-> lst);
                    return copy MacroVarExpr (name-> open, rule-> mult);
                }

                return copy MacroIdentExpr (name-> open);
            }
        }

        throw copy ErrorMsg::fatal (open, format (SyntaxErrorMessage::UNEXPECTED, open.str));
    }
    
}
