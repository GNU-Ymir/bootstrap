/*
 * Declares the value visitor in charge of reading value expressions
 *
 * <hr>
 * 
 * @Package: ymirc        
 * @Module: ymirc::syntax::visitor::value
 * @File: ymirc/syntax/visitor/value.yr
 * @Author(s):
 *   - Emile Cadorel <ecadorel@gmail.com>
 *
 * @Created (YYYY-MM-DD): 2026-02-11
 * @Copyright (C) 2021â€“2026 GNU-Ymir
 * @License
 *   ```text
 *   This file is part of the Ymir language project.
 *
 *   Ymir is free software: you can redistribute it and/or modify it
 *   under the terms of the GNU General Public License as published by
 *   the Free Software Foundation, either version 3 of the License, or
 *   (at your option) any later version.
 *
 *   Ymir is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with Ymir.  If not, see <https://www.gnu.org/licenses/>.
 *   ```
 */

in expr;

use ymirc::syntax::errors;
use ymirc::errors::_;
use ymirc::syntax::{_,
                    visitor::_,
                    declaration::_,
                    expression::{_, literal::_, macro_::_, operator::_, template::_}};

use ymirc::lexing::_;
use ymirc::utils::_;
use ymirc::global::state;

use std::io;

pub record ExpressionVisitor {

    // Holding operators precedence
    let _specials: SpecialKeysAndTokens = __SPECIAL_TOKENS__;
    
    
    pub self () {}

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =================================          IMPLEMENTATION          =================================
     * ====================================================================================================
     * ====================================================================================================
     */
    
    /**
     * Read a top level expression
     *
     * @params:
     *   - context: the context of the reading
     *
     * @grammar:
     * ```
     * InstrOrExpr :=
     *    ExpressionComplex(0)
     *  | Instruction
     *
     * Instruction :=
     *    Assert
     *  | Break
     *  | Let
     *  | Return
     *  | Throw
     *  | Panic
     * 
     * ExpressionComplex(level) :=
     *    ExpressionComplex(level + 1) (BinaryOperators(level) ExpressionComplex(level + 1))*
     *     
     * ExpressionComplex(10) :=
     *    OperandComplex(0)
     *    
     * ```     
     * 
     * */
    pub fn readInstrOrExpr (self, dmut context: &SyntaxVisitor)-> &Expression
        throws ErrorMsg
    {
        let (tok, _) = context:.readToken (); 
        match tok { // Top level expression that cannot be found inside an binary operator            
            Keys::ASSERT   => { // assert (Test (, message)?)
                return self.readAssert (alias context, tok);
            }
            Keys::BREAK    => { // break X;
                return self.readBreak (alias context, tok);
            }            
            Keys::LET      => { // let (var,...) = expression(0);
                return self.readLet (alias context, tok, inControl-> false);
            }
            Keys::RETURN   => { // return expression(0);
                return self.readReturn (alias context, tok);
            }
            Keys::YIELD   => { // yield expression(0);
                return self.readYield (alias context, tok);
            }
            Keys::THROW    => { // throw expression(0);
                return self.readThrow (alias context, tok);
            }            
            Keys::PANIC    => { // panic;
                return self.readPanic (alias context, tok);
            }            
        }

        context:.rewind ();        
        self.readExpressionComplex (alias context, level-> 0)
    }    

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ==================================          INSTRUCTIONS          ==================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Read an instruction introduced by the keyword `assert`
     *
     * @params:
     *    - context: the context of the reading
     *    - loc:     the location of the `assert` keyword
     *
     * @grammar
     * ```
     * AssertExpr :=
     *     'assert' '(' ExpressionComplex (BOOL_LOGIC) (',' ExpressionComplex(BOOL_LOGIC))? ')'
     * ```
     * */
    fn readAssert (self, dmut context: &SyntaxVisitor, loc: &Word)-> &Expression
        throws ErrorMsg
    {
        context:.readTokens (Tokens::LPAR);
        let test = self.readExpressionComplex (alias context, BinaryOperatorsLevelNames::BOOL_LOGIC);
                
        let mut msg: &Expression = EMPTY_EXPR;
        let (hasMsg, _) = context:.readTokens (Tokens::COMA, Tokens::RPAR);
        if hasMsg == Tokens::COMA {
            msg = self.readExpressionComplex (alias context, BinaryOperatorsLevelNames::BOOL_LOGIC);
            context:.readTokens (Tokens::RPAR);
        }

        return copy AssertExpr (loc, test, msg);
    }

    /**
     * Read an instruction introduced by the keyword `break`
     *
     * @params:
     *    - context: the context of the reading
     *    - loc:     the location of the keyword `break`
     *
     * @grammar
     * ```
     * BreakExpr :=
     *    'break' (ExpressionComplex(BOOL_LOGIC))? ';'
     * ```
     * */
    fn readBreak (self, dmut context: &SyntaxVisitor, loc: &Word)-> &Expression
        throws ErrorMsg
    {        
        let mut value: &Expression = EMPTY_EXPR;
        let (hasValue, _) = context:.readIf (Tokens::SEMI_COLON);
        if hasValue.isEof {
            value = self.readExpressionComplex (alias context, BinaryOperatorsLevelNames::BOOL_LOGIC);
            context:.readTokens (Tokens::SEMI_COLON);
        }

        return copy BreakExpr (loc, value);
    }

    /**
     * Read an instruction introduced by the keyword `return`
     *
     * @params:
     *    - context: the context of the reading
     *    - loc:     the location of the keyword `return`
     *
     * @grammar
     * ```
     * ReturnExpr :=
     *    'return' (ExpressionComplex(BOOL_LOGIC))? ';'
     * ```
     * */
    fn readReturn (self, dmut context: &SyntaxVisitor, loc: &Word)-> &Expression
        throws ErrorMsg
    {        
        let mut value: &Expression = EMPTY_EXPR;
        let (hasValue, _) = context:.readIf (Tokens::SEMI_COLON);
        if hasValue.isEof {
            value = self.readExpressionComplex (alias context, BinaryOperatorsLevelNames::BOOL_LOGIC);
            context:.readTokens (Tokens::SEMI_COLON);
        }

        return copy ReturnExpr (loc, value);
    }

    /**
     * Read an instruction introduced by the keyword `yield`
     *
     * @params:
     *    - context: the context of the reading
     *    - loc:     the location of the keyword `yield`
     *
     * @grammar
     * ```
     * YieldExpr :=
     *    'yield' ExpressionComplex(BOOL_LOGIC) ';'
     * ```
     * */
    fn readYield (self, dmut context: &SyntaxVisitor, loc: &Word)-> &Expression
        throws ErrorMsg
    {                                
        let value = self.readExpressionComplex (alias context, BinaryOperatorsLevelNames::BOOL_LOGIC);
        context:.readTokens (Tokens::SEMI_COLON);        

        return copy YieldExpr (loc, value);
    }

    /**
     * Read an instruction introduced by the keyword `throw`
     *
     * @params:
     *    - context: the context of the reading
     *    - loc:     the location of the keyword `throw`
     *
     * @grammar
     * ```
     * ThrowExpr :=
     *    'throw' ExpressionComplex(BOOL_LOGIC) ';'
     * ```
     * */
    fn readThrow (self, dmut context: &SyntaxVisitor, loc: &Word)-> &Expression
        throws ErrorMsg
    {                                
        let value = self.readExpressionComplex (alias context, BinaryOperatorsLevelNames::BOOL_LOGIC);
        context:.readTokens (Tokens::SEMI_COLON);        

        return copy ThrowExpr (loc, value);
    }    

    /**
     * Read an instruction introduced by the keyword `panic`
     *
     * @params:
     *    - context: the context of the reading
     *    - loc:     the location of the keyword `panic`
     *
     * @grammar
     * ```
     * PanicExpr :=
     *    'panic' (ExpressionComplex(BOOL_LOGIC))? ';'
     * ```
     * */
    fn readPanic (self, dmut context: &SyntaxVisitor, loc: &Word)-> &Expression
        throws ErrorMsg
    {        
        let mut value: &Expression = EMPTY_EXPR;
        let (hasValue, _) = context:.readIf (Tokens::SEMI_COLON);
        if hasValue.isEof {
            value = self.readExpressionComplex (alias context, BinaryOperatorsLevelNames::BOOL_LOGIC);
            context:.readTokens (Tokens::SEMI_COLON);
        }

        return copy PanicExpr (loc, value);
    }

    
    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ==================================          EXPRESSIONS          ===================================
     * ====================================================================================================
     * ====================================================================================================
     */
        
    /**
     * Read an expression of level `level`, with complex inner operations (such as loops, blocks, etc.)
     *
     * @params:
     *    - context: the context of the reading
     *    - level:   the level of the expression
     * 
     * */
    pub fn readExpressionComplex (self, dmut context: &SyntaxVisitor, level: u32)-> &Expression
        throws ErrorMsg
    {
        if level == self._specials.binaryOperators.len {
            return self.readOperandComplex0 (alias context);
        }

        let mut left = self.readExpressionComplex (alias context, level + 1);

        // While we find an operator following the expression, we append a right operand to it
        while let (op, _) = context:.readIf (self._specials.binaryOperators [level]) && !op.isEof {        
            let right = self.readExpressionComplex (alias context, level + 1);
            left = copy BinaryExpr (op, left, right);
        }
        
        left
    }
    
    /**
     * Read an complex operand of level 1
     *
     * @params:
     *    - context: the context of the syntax reader
     *
     * @grammar
     * ```
     * OperandComplex(0) :=
     *      ComplexOperation
     *    | MemoryOperation
     *    | DecoratedOperand
     *    | OperandSimple(1) 
     *     
     *
     * ComplexOperation :=
     *      Loop
     *    | While
     *    | '{' Value* '}'
     *    | IfElse
     *    | DoWhile
     *    | For
     *    | Match
     *    | Fptr
     *    | DgPtr
     *    | Future
     *    | Pragma
     *    | Unsafe
     *    | Version     
     *    | Future
     *    | Lambda
     *    | Cast
     *    | TemplateChecker
     *    | CteComplex
     *
     * DecoratedExpr := MutableKw OperandSimple(0)
     * MutableKw := 'mut' | 'dmut'
     *
     * MemoryOperation :=
     *    MemoryOperatorKw OperandSimple(0)
     *
     * MemoryOperatorKw :=
     *     'copy'
     *   | 'dcopy'
     *   | 'expand'
     *   | 'alias'
     *   | 'ref'
     *   | 'move'
     * 
     *    
     * ```
     * */
    fn readOperandComplex0 (self, dmut context: &SyntaxVisitor)-> &Expression
        throws ErrorMsg
    {
        // Test if it's a complex operand
        let (tok, _) = context:.readToken ();        
        match tok {
            Keys::LOOP => // loop { ... } | COMPLEX
                return self.readLoop (alias context, tok);            
            Keys::WHILE =>  // while Expression(0) { ... }
                return self.readWhile (alias context, tok);            
            Tokens::LACC => // { ... } block 
                return self.readBlock (alias context, tok, withGuards-> true);        
            Keys::IF => // if { ... } (else if { ... })  
                return self.readCond (alias context, tok);                                
            Keys::FOR => // for vars... in X { ... }
                return self.readFor (alias context, tok, isCte-> EOF_WORD);            
            Keys::MATCH => // match X { ... }
                return self.readMatch (alias context, tok);                    
            Keys::FUNCTION => // fn (X...)-> X
                return self.readFunctionType (alias context, tok);            
            Keys::DELEGATE => // dg (X...) -> X
                return self.readFunctionType (alias context, tok);            
            Keys::FUTURE => // future-> X
                return self.readFutureType (alias context, tok);
            Keys::ASYNC => // async-> X
                return self.readAsyncType (alias context, tok);
            Keys::YIELD => // yield-> X
                return self.readYieldType (alias context, tok);
            Keys::SPAWN => // spawn { ... }
                return self.readSpawn (alias context, tok);
            Keys::LAZY => // lazy { ... }
                return self.readLazy (alias context, tok);            
            Keys::PRAGMA => // __pragma!X (....)
                return self.readPragma (alias context, tok);            
            Keys::ATOMIC => // atomic X { ... }
                return self.readAtomic (alias context, tok);
            Keys::AWAIT => // await X
                return self.readAwait (alias context, tok);
            Keys::UNSAFE => // unsafe { ... }
                return self.readUnsafe (alias context, tok);                            
            Keys::VERSION  => // __version { ... }
                return self.readVersion (alias context, tok);
            Tokens::PIPE | Tokens::DPIPE => // |vars...| => X, |vars...| { ... }
                return self.readLambda (alias context, tok);
            Keys::CAST => // cast!{T} (X)
                return self.readCast (alias context, tok);
            Keys::TEMPLATE => // template!{T...}{U...}
                return self.readTemplateChecker (alias context, tok);            
            Keys::CTE => // cte if, cte for, cte X
                return self.readCteComplex (alias context, tok);
            Keys::MUTABLE | Keys::DMUTABLE => // mut X, dmut X
                return copy DecoratedTypeExpr (tok,
                                               deco-> toEnum!{Decorators} (tok.str),
                                               content-> self.readOperandSimple1 (alias context));
            Keys::TYPEOF => // typeof (X) 
                return copy TypeOfExpr (tok, self.readOperandSimple1 (alias context));
            Tokens::DDOT =>  // ..i32 is a range type                
                return copy RangeTypeExpr (tok, self.readOperandSimple1 (alias context));            
        }
        
        for i in MemoryKeys::__members__ if tok.str == i {
            return self.readMemoryExpr (alias context, tok);
        }
         
                
        // If not it's a second level operand
        context:.rewind ();        
        return self.readOperandSimple1 (alias context);
    }

    /**
     * Read a expression introduced by the keyword `cte` in a complex operand
     *
     * @params:
     *    - context: the context of the reading
     *    - loc:     the location of the `cte` keyword
     *
     * @grammar:
     * ```
     * CteComplex :=
     *     If
     *   | For
     *   | OperandSimple(4)     
     * ```
     *  
     * */
    fn readCteComplex (self, dmut context: &SyntaxVisitor, loc: &Word)-> &Expression
        throws ErrorMsg
    {
        let (op, _) = context:.readIf (Keys::IF, Keys::FOR);
        match op.str {
            Keys::IF => {
                return self.readCond (alias context, op, isCte-> loc);
            }
            Keys::FOR => {
                return self.readFor (alias context, op, isCte-> loc);
            }
        };

        let operand = self.readOperandSimple1 (alias context);
        copy CteExpr (loc, operand)        
    }

    /**
     * Read a memory operation introduced by a memory key
     *
     * @params:
     *    - context: the context of the reading
     *    - loc:     the location of the memory keyword
     *
     * @grammar
     * ```
     * MemoryExpr :=
     *   MemoryKey OperandSimple(0)
     *
     * MemoryKey :=
     *      'alias'
     *    | 'copy'
     *    | 'dcopy'
     *    | 'expand'
     *    | 'move'
     *    | 'ref'
     *    
     * ```
     * */
    fn readMemoryExpr (self, dmut context: &SyntaxVisitor, loc: &Word)-> &Expression
        throws ErrorMsg
    {
        let operand = self.readOperandSimple0 (alias context);
        match loc.str {
            MemoryKeys::ALIAS =>
                return copy AliasExpr (loc, operand);
            MemoryKeys::COPY =>
                return copy CopyExpr (loc, operand, isDeep-> false);
            MemoryKeys::DCOPY =>
                return copy CopyExpr (loc, operand, isDeep-> true);
            MemoryKeys::EXPAND =>
                return copy ExpandExpr (loc, operand);
            MemoryKeys::MOVE =>
                return copy MoveExpr (loc, operand);
            MemoryKeys::REF =>
                return copy RefExpr (loc, operand);
        }
        
        throw copy ErrorMsg::fatal (loc, format (SyntaxErrorMessage::UNEXPECTED, loc.str));            
    }

    
    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===============================          SIMPLE EXPRESSION          ================================
     * ====================================================================================================
     * ====================================================================================================
     */
    
    /**
     * Read an expression of level `level`, forbidding complex construction (loops, let, match, and even blocks, etc.)
     * To return to a complex context, expression has to be enclosed with parentheses
     *
     * @params:
     *    - context: the context of the reading
     *    - level:   the level of the expression
     * 
     * */
    pub fn readExpressionSimple (self, dmut context: &SyntaxVisitor, level: u32)-> &Expression
        throws ErrorMsg
    {
        if level == self._specials.binaryOperators.len
            return self.readOperandSimple0 (alias context);


        let mut left = self.readExpressionSimple (alias context, level + 1);

        // While we find an operator following the expression, we append a right operand to it
        while let (op, _) = context:.readIf (self._specials.binaryOperators [level]) && !op.isEof {        
            let right = self.readExpressionSimple (alias context, level + 1);
            left = copy BinaryExpr (op, left, right);
        }
        
        left
    }


    /**
     * Read a simple operand of level 0, unlike complex operands operand(0) is
     * way simpler, but operand1 and follow up are similar.     
     *
     * @params:
     *    - context: the context of the syntax reader
     *
     * @grammar
     * ```
     * OperandSimple(0) :=
     *      SimpleOperation
     *    | MemoryOperation
     *    | DecoratedOperand
     *    | OperandSimple(1) 
     *     
     *
     * SimpleOperation :=          
     *    | Pragma     
     *    | Version     
     *    | Cast
     *    | TemplateChecker
     *     
     *    
     * ```
     * */
    pub fn readOperandSimple0 (self, dmut context: &SyntaxVisitor)-> &Expression
        throws ErrorMsg
    {
        // Test if it's a complex operand
        let (tok, _) = context:.readToken ();        
        match tok {
            Keys::FUNCTION => // fn (X...)-> X
                return self.readFunctionType (alias context, tok);            
            Keys::DELEGATE => // dg (X...) -> X
                return self.readFunctionType (alias context, tok);            
            Keys::FUTURE => // future-> X
                return self.readFutureType (alias context, tok);
            Keys::ASYNC => // async-> X
                return self.readAsyncType (alias context, tok);
            Keys::YIELD => // yield-> X
                return self.readYieldType (alias context, tok);
            Keys::PRAGMA => // __pragma!X (....)
                return self.readPragma (alias context, tok);
            Keys::CAST => // cast!{T} (X)
                return self.readCast (alias context, tok);
            Keys::TEMPLATE => // template!{T...}{U...}
                return self.readTemplateChecker (alias context, tok);
            Keys::MUTABLE | Keys::DMUTABLE => // mut X, dmut X
                return copy DecoratedTypeExpr (tok,
                                               deco-> toEnum!{Decorators} (tok.str),
                                               content-> self.readOperandSimple1 (alias context));
            Keys::TYPEOF => // typeof (X) 
                return copy TypeOfExpr (tok, self.readOperandSimple1 (alias context));
            Tokens::DDOT =>  // ..i32 is a range type                
                return copy RangeTypeExpr (tok, self.readOperandSimple1 (alias context));                                    
        }

        // Maybe a memory operation?
        for i in MemoryKeys::__members__ if tok.str == i {
            return self.readMemoryExpr (alias context, tok);            
        }
        
        // If not it's a second level operand
        context:.rewind ();        
        return self.readOperandSimple1 (alias context);
    }

    /**
    
     *
     * To return to a complex operand context, parentheses have to be used, i.e.
     * '(' complex ')' is a simple operand
     * 
     * @params:
     *    - context: the context of the reading     
     *
     * @grammar:
     * ```
     * OperandSimple(1) :=
     *      UnaryOp OperandSimple(2)
     *    | OperandSimple(2) '?'
     *    | OperandSimple(2)
     *
     * UnaryOp :=
     *      '+'
     *    | '-'
     *    | '*'
     *    | '!'
     * ```
     * 
     * */
    fn readOperandSimple1 (self, dmut context: &SyntaxVisitor)-> &Expression
        throws ErrorMsg
    {
        // Try to read an unary operator
        let (tok, _) = context:.readIf (self._specials.unaryOperators);
        let operand = self.readOperandSimple2 (alias context); // read the operand

        if !tok.isEof { // an unary operator was found
            return copy UnaryExpr (tok, operand);
        }

        // -10? is not allowed, (-10)? has to be written to avoid confusion
        let (post, _) = context:.readIf (Tokens::INTEG);
        if !post.isEof { // an option operator was found
            return copy TryExpr (post, operand);
        }

        return operand;
    }
    
    /**
     * Read a second level operand in a simple
     *
     * @grammar
     * ```
     * OperandSimple(2) :=
     *    OperandSimple(3) OperandSimpleFollow?
     *     
     * OperandSimpleFollow :=
     *      '[' (ExpressionSimple(0) (',' ExpressionSimple(0))* ']' OperandSimpleFollow?
     *    | '.' OperandSimple(4) OperandSimpleFollow?
     *    | ':.' OperandSimple(4) OperandSimpleFollow?
     *    | MacroCall
     *
     * ```
     * 
     * */
    fn readOperandSimple2 (self, dmut context: &SyntaxVisitor)-> &Expression
        throws ErrorMsg
    {
        let mut left = self.readOperandSimple3 (alias context);
        
        loop {
            let (open, _) = context:.readToken ();
            match open.str {
                Tokens::LPAR | Tokens::LCRO | Tokens::LCRO_AND => { // left (...), left [...], left :[...]                   
                    let (params, end) = self.readArgumentList (alias context, open, withNamed-> true);
                    left = copy MultOperatorExpr (start-> open,
                                                  end-> end,
                                                  op-> toEnum!{MultOperators} (open.str),
                                                  left-> left,
                                                  rights-> params);
                }
                Tokens::DOT | Tokens::DOT_AND => { // left.right, left:.right

                    // an operand4 because left.A::B is...meh, which would be valid with operand3,
                    // write left.(A::B) instead, in any case it'd be rejected by semantic, but filtering here seems better anyway
                    // 
                    let right = self.readOperandSimple4 (alias context); 
                    left = copy BinaryExpr (open, left, right);
                }                
                _ => {
                    if let str: &StringWord = open match str.open { // left #{...}
                        Tokens::MACRO_ACC | Tokens::MACRO_PAR | Tokens::MACRO_CRO => {

                            // Macro call is already a full read token from Lexer
                            left = copy MacroCallExpr (str.open, who-> left, content-> str.str);
                            break; // break to consume open
                        }
                    }

                    // rewind fallback, nothing interesting read
                    context:.rewind (); 
                    break; 
                }
                
            }
        }

        left
    }

    /**
     * Read a simple operand of level 3, with is a list of template calls and '::' linking operand4
     *
     * @params:
     *    - context: the context syntax visitor of the reading
     *
     * @grammar:
     * ```
     * OperandSimple(3) :=
     *    OperandSimple(4) ('!' templates)? OperandSimple3Follow
     *
     * OperandSimple3Follow := '::' OperandSimple(3)     
     * ```
     * */
    fn readOperandSimple3 (self, dmut context: &SyntaxVisitor)-> &Expression
        throws ErrorMsg
    {
        // First operand that might be followed: operand4 ('!' templates)?
        let mut left = self.readOperandSimple4 (alias context);
        let (not, _) = context:.readIf (Tokens::NOT);
        if !not.isEof {
            let lst = self.readTemplateCallList (alias context, not);
            left = copy TemplateCallExpr (not, left, lst);
        }
        
        // Reading the followings '::' operand4 ('!' templates)?
        while let (colon, _) = context:.readIf (Tokens::DCOLON) && !colon.isEof {
            let right = self.readOperandSimple4 (alias context);
            left = copy BinaryExpr (colon, left, right);

            let (notF, _) = context:.readIf (Tokens::NOT);
            if !notF.isEof {
                let lst = self.readTemplateCallList (alias context, notF);
                left = copy TemplateCallExpr (notF, left, lst);
            }            
        }
        
        left
    }

    /**
     * Read a simple operand of level 4, which defines literals, e.g. ints, floats, arrays, tuples, etc.
     *
     * @params:
     *    - context: the context of the reading
     *
     * @grammar:
     * ```
     *
     * OperandSimple(4) :=
     *      Tuple
     *    | Array
     *    | Literal
     *    | Var
     *    
     * ```
     * */
    fn readOperandSimple4 (self, dmut context: &SyntaxVisitor)-> &Expression
        throws ErrorMsg
    {
        let (tok, _) = context:.readToken ();
        if tok == Tokens::LPAR // ( ... )
            return self.readTuple (alias context, tok);

        if tok == Tokens::LCRO // [ ... ]
            return self.readArray (alias context, tok);

        if tok.isName || tok.isKey && tok == Keys::SELF { // ident | self
            return copy VarExpr (tok);
        }

        // anything else
        return self.readLiteral (tok);
    }

    /**
     * Read an array literal, or allocator expression introduced by the token '['
     *
     * @params:
     *    - context: the context of the reading
     *    - open:    the location of the '[' token
     *
     * @grammar
     * ```
     * ArrayExpr :=
     *      '[' ']'
     *    | '[' ExpressionComplex(BOOL_LOGIC) (','' ExpressionComplex(BOOL_LOGIC))* ']'
     *    | '[' ExpressionComplex(BOOL_LOGIC) 'for' ForIterVarDecl (',' ForIterVarDecl)* 'in' ExpressionSimple(BOOL_LOGIC)]'
     *    | '[' ExpressionComplex(BOOL_LOGIC) ';' ExpressionSimple(0) ']'
     *    | ListMapExpr
     *    
     * ```
     * */
    fn readArray (self, dmut context: &SyntaxVisitor, open: &Word)-> &Expression
        throws ErrorMsg
    {
        let (isEmpty, _) = context:.readIf (Tokens::RCRO);
        if !isEmpty.isEof { // '[]'
            return copy ListExpr (open, isEmpty, [], isArray-> true);
        }

        let mut fstParam: &Expression = self.readExpressionComplex (alias context, BinaryOperatorsLevelNames::BOOL_LOGIC);
        let (mut next, _) = context:.readIf (Tokens::SEMI_COLON, Tokens::RCRO, Tokens::COMA, Keys::FOR, Tokens::DARROW);

        match next.str {
            Tokens::SEMI_COLON => { // '[ x ; size ]'
                let size = self.readExpressionSimple (alias context, BinaryOperatorsLevelNames::BOOL_LOGIC);
                context:.readTokens (Tokens::RCRO);
                return copy SliceAllocatorExpr (open, fstParam, size);
            }
            Keys::FOR => { // '[ x for iters... in value ]'
                let mut vars: [&Expression] = [];
                loop {
                    vars ~= [self.readForIterVarDecl (alias context)];
                    let (n, _) = context:.readTokens (Tokens::COMA, Keys::IN);
                    if n.str == Keys::IN
                        break;
                }

                let iter = self.readExpressionSimple (alias context, BinaryOperatorsLevelNames::BOOL_LOGIC);
                context:.readTokens (Tokens::RCRO);
                
                return copy SliceForAllocatorExpr (open, next, fstParam, vars, iter, isArray-> true);
            }
            Tokens::DARROW => { // '[ X => Y... ]'
                return self.readListMap (alias context, open, fstParam);
            }            
        }

        let mut params = copy [fstParam];
        while next != Tokens::RCRO { // '[x, y, z]'
            params ~= [self.readExpressionComplex (alias context, BinaryOperatorsLevelNames::BOOL_LOGIC)];                        
            next = context:.readTokens (Tokens::COMA, Tokens::RCRO)._0;
        }

        return copy ListExpr (open, next, params, isArray-> true);
    }
    
    /**
     * Read a map literal
     *    
     * @params:
     *    - context: the context of the reading
     *    - open: the location of the opening '['
     *    - fstKey: the first read key
     *
     * @assume
     *    The cursor of context is right after the '=>' token.
     *
     *
     * @grammar
     * ```
     * ListMapExpr :=
     *     '[' Pair 'for' ForIterVarDecl (',' ForIterVarDecl)* 'in' ExpressionSimple(BOOL_LOGIC) ']'
     *   | '[' Pair (',' Pair)* ']'
     *
     * Pair :=
     *   ExpressionComplex(BOOL_LOGIC) '=>' ExpressionComplex(BOOL_LOGIC)
     *  
     * ```
     * */
    fn readListMap (self, dmut context: &SyntaxVisitor, open: &Word, fstKey: &Expression)-> &Expression
        throws ErrorMsg
    {
        let fstValue = self.readExpressionComplex (alias context, BinaryOperatorsLevelNames::BOOL_LOGIC);
        let (mut next, _) = context:.readIf (Tokens::RCRO, Tokens::COMA, Keys::FOR);
            
        if next.str == Keys::FOR { // '[' X => Y for iters... in value ']'
            let mut vars: [&Expression] = [];
            loop {
                vars ~= [self.readForIterVarDecl (alias context)];
                let (n, _) = context:.readTokens (Tokens::COMA, Keys::IN);
                if n.str == Keys::IN
                    break;
            }

            let iter = self.readExpressionSimple (alias context, BinaryOperatorsLevelNames::BOOL_LOGIC);
            context:.readTokens (Tokens::RCRO);
            
            return copy MapForAllocatorExpr (open, next, fstKey, fstValue, vars, iter);
        }                        

        let mut keys: [&Expression] = copy [fstKey];
        let mut values: [&Expression] = copy [fstValue];
        
        while next != Tokens::RCRO { // '[ X => Y (',' X => Y)* ]'
            keys ~= [self.readExpressionComplex (alias context, BinaryOperatorsLevelNames::BOOL_LOGIC)];
            context:.readTokens (Tokens::DARROW);
            values ~= [self.readExpressionComplex (alias context, BinaryOperatorsLevelNames::BOOL_LOGIC)];
            
            next = context:.readTokens (Tokens::COMA, Tokens::RCRO)._0;
        }     

        return copy ListMapExpr (open, next, keys, values);
    }

    /**
     * Read a tuple literal introduced by the token '('
     *
     * @params:
     *    - context: the context of the reading
     *    - open:    the location of the '(' token
     *
     * @grammar
     * ```
     * TupleExpr :=
     *     '(' ')'     
     *   | '(' ExpressionComplex(BOOL_LOGIC) ',' ')'
     *   | '(' ExpressionComplex(BOOL_LOGIC) 'for' ForIterVarDecl (',' ForIterVarDecl)* 'in' ExpressionSimple(BOOL_LOGIC) ')'
     *   | '(' ExpressionComplex(BOOL_LOGIC) (',' ExpressionComplex(BOOL_LOGIC))* ')'
     * ```
     * */
    fn readTuple (self, dmut context: &SyntaxVisitor, open: &Word)-> &Expression
        throws ErrorMsg
    {
        let (mut end, _) = context:.readIf (Tokens::RPAR);
        if !end.isEof {
            return copy ListExpr (open, end, [], isArray-> false);
        }

        let mut fstParam: &Expression = self.readExpressionComplex (alias context, BinaryOperatorsLevelNames::BOOL_LOGIC);
        let (mut next, _) = context:.readIf (Tokens::RPAR, Tokens::COMA, Keys::FOR);

        if next.str == Keys::FOR {  // '( x for iters... in value )'            
            let mut vars: [&Expression] = [];
            loop {
                vars ~= [self.readForIterVarDecl (alias context)];
                let (n, _) = context:.readTokens (Tokens::COMA, Keys::IN);
                if n.str == Keys::IN
                    break;
            }

            let iter = self.readExpressionSimple (alias context, BinaryOperatorsLevelNames::BOOL_LOGIC);
            context:.readTokens (Tokens::RPAR);
            
            return copy SliceForAllocatorExpr (open, next, fstParam, vars, iter, isArray-> false);                                    
        }

        if next.str == Tokens::COMA { // '(x,)', '(x, y)', etc.
            let mut params = copy [fstParam];
            end = context:.readIf (Tokens::RPAR)._0;
            while end != Tokens::RPAR {
                params ~= [self.readExpressionComplex (alias context, BinaryOperatorsLevelNames::BOOL_LOGIC)];
                end = context:.readTokens (Tokens::RPAR, Tokens::COMA)._0;
            }

            return copy ListExpr (open, end, params, isArray-> false);
        }

        // (x) is not a tuple
        return fstParam;
    }

    
    /**
     * Read a literal expression, final level of recurive reading of complex or simple operands.
     * We don't need context, literals are written in one token from the Lexer.
     *
     * @params:     
     *    - tok: the token that had been read
     *  
     * */
    fn readLiteral (self, tok: &Word)-> &Expression
        throws ErrorMsg
    {
        if let str: &StringWord = tok { // String literal            
            match str.open {
                Tokens::SQUOTE => {
                    return copy CharExpr (str.open, str.close, str.str, suffix-> str.suffix);                    
                }
                Tokens::DQUOTE | Tokens::TRIPLE_DQUOTE => {
                    return copy StringExpr (str.open, str.close, str.str, suffix-> str.suffix, str.trim);                    
                }
            }
            
            throw copy ErrorMsg::fatal (str.open, format (SyntaxErrorMessage::UNEXPECTED, str.open.str));
        }

        if let num: &NumericWord = tok {
            return copy FixedExpr (num, suffix-> num.suffix);
        }

        if let fl: &FloatWord = tok {
            return copy FloatExpr (int-> fl,
                                   dec-> fl.dec,
                                   suffix-> fl.suffix,
                                   exp-> fl.exp,
                                   expSign-> (fl.sign.isEof || fl.sign == Tokens::PLUS),
                                   isHex-> (fl.notation == FloatNotation::HEX));
        }
        
        match tok {
            Keys::TRUE | Keys::FALSE => {
                return copy BoolExpr (tok);    
            }
            Keys::NULL => {
                return copy NullExpr (tok);    
            }
            Keys::NONE => {
                return copy NoneExpr (tok);    
            }
            Tokens::DOLLAR => {
                return copy DollarExpr (tok);    
            }            
        }
        
        throw copy ErrorMsg::fatal (tok, format (SyntaxErrorMessage::UNEXPECTED, tok.str));    
    }

    
    /**
     * Read a list of template calls values (after a '!' was encountered within
     * a Operand2). Template call is not representable in CFG as it depends on a
     * parent context, indeed since A!B!C is not allowed, the second ! has to be
     * aware of the existance of the first one.
     *     
     *
     * @returns: the list of template values that where read. This list contains at least one element
     *
     * @grammar:
     * ```
     * TemplateCallList :=
     *    '!' OperandSimple(4)
     *    | '!' '{ ExpressionList }'
     *
     * ExpressionList :=
     *    ExpressionSimple(BOOL_LOGIC) (',' ExpressionSimple(BOOL_LOGIC))*
     *    
     * ```
     * */
    pub fn readTemplateCallList (self, dmut context: &SyntaxVisitor, loc: &Word)-> [&Expression]
        throws ErrorMsg
    {
        // Template inside a simple template call is not allowed
        if let inTemplate = context.isInNoAccTemplate () && !inTemplate.isEof {
            throw copy ErrorMsg::fatal (loc, format (SyntaxErrorMessage::UNEXPECTED, loc.str),
                                        notes-> copy [copy ErrorMsg::note (inTemplate, format (SyntaxErrorMessage::MISSING_TEMPLATE_ACC))]);
        }
        
        let (open, _) = context:.readTokens (Tokens::LACC);
        if open.isEof { // simple operand value 
            // To avoid recursive A!B!C or A!B!{C} -> A!{B!C}
            context:.setInTemplate (loc);
            let ret = {
                self.readOperandSimple4 (alias context) // tuples, arrays, vars, literals                
            } exit {
                context:.setInTemplate (EOF_WORD);
            };

            return copy [ret];
        }

        // We don't set in template, A!{B!C} is allowed
        
        let dmut values: [&Expression] = [];                
        loop {
            let value = self.readExpressionSimple (alias context, level-> BinaryOperatorsLevelNames::BOOL_LOGIC);
            values ~= [value];

            let (close, _) = context:.readTokens (Tokens::COMA, Tokens::RACC);
            if close == Tokens::RACC {
                break;
            }
        }

        values        
    }

    /**
     * Read a list of arguments introduced by a call expression (multoperator '[]', '()' or ':[]')
     *
     * @params:
     *    - context:   the context of the reading
     *    - loc:       the location of the opening token ('(', '[' or ': [')
     *    - withNamed: true iif named expression are allowed 
     *
     * @returns:
     *    - .0: the list of arguments
     *    - .1: the location of the closing token
     *    
     * @grammar
     * ```
     * ArgumentList(withNamed) :=
     *      '(' (Argument(withNamed) (',' Argument(withNamed))*)? ')'
     *    | '[' (Argument(withNamed) (',' Argument(withNamed))*)? ']'
     *    | ':[' (Argument(withNamed) (',' Argument(withNamed))*)? ']'
     *
     * Argument(withNamed = true) :=
     *      Identifier '->' ExpressionComplex(BOOL_LOGIC)
     *    | ExpressionComplex(BOOL_LOGIC)
     *
     * Argument(withNamed = false) :=     
     *    ExpressionComplex(BOOL_LOGIC)
     * 
     * ```
     * */
    fn readArgumentList (self, dmut context: &SyntaxVisitor, loc: &Word, withNamed: bool)-> ([&Expression], &Word)
        throws ErrorMsg
    {
        let closing = if loc.str == Tokens::LPAR {
            Tokens::RPAR
        } else {
            Tokens::RCRO
        };

        let mut lst: [&Expression] = [];
        
        let (mut end, _) = context:.readIf (closing);        
        while end != closing { // empty list never enter
            if !withNamed { // (x, y, z), with no names
                lst ~= [self.readExpressionComplex (alias context, BinaryOperatorsLevelNames::BOOL_LOGIC)];
            }

            else { // (name-> x, name-> y, z)
                let mut read = false;
                let seek = context.getSeek ();
                let (id, _) = context:.readIfIdentifier ();
                if !id.isEof { 
                    let (hasArrow, _) = context:.readIf (Tokens::ARROW);
                    if !hasArrow.isEof { // x-> Expr
                        let value = self.readExpressionComplex (alias context, BinaryOperatorsLevelNames::BOOL_LOGIC);
                        lst ~= [copy NamedExpr (hasArrow, name-> id, value-> value)];
                        read = true;
                    }
                }

                if !read { // no arrow or no identifier, just an expression
                    context:.rewindToSeek (seek);
                    lst ~= [self.readExpressionComplex (alias context, BinaryOperatorsLevelNames::BOOL_LOGIC)];                    
                }
            }

            end = context:.readTokens (closing, Tokens::COMA)._0;            
        }

        return (lst, end);
    }

    /**
     * Read a pragma expression introduced by the keyword `__pragma`
     *
     * @params:
     *    - context: the context of the reading
     *    - loc:     the location of the `__pragma` keyword
     *
     * @grammar
     * ```
     * PragmaExpr :=
     *     '__pragma' '!' Identifier '(' ArgumentList(false) ')'
     * ```
     * */
    fn readPragma (self, dmut context: &SyntaxVisitor, loc: &Word)-> &Expression
        throws ErrorMsg
    {
        context:.readTokens (Tokens::NOT);
        let (ident, _) = context:.readIdentifier ();

        let (open, _) = context:.readTokens (Tokens::LPAR);
        let (lst, _) = self.readArgumentList (alias context, open, withNamed-> false);

        return copy PragmaExpr (loc, ident, lst);  
    }

    /**
     * Read a cast expression introduced by the keyword `cast`
     *
     * @params:
     *    - context: the context of the reading
     *    - loc:     the location of the `cast` keyword
     *
     * @grammar
     * ```
     * CastExpr :=
     *    'cast' '!' CastType '(' ExpressionSimple(BOOL_LOGIC) ')'
     *
     * CastType :=
     *       OperandSimple(4)
     *     | '{' ExpressionSimple (BOOL_LOGIC) '}'
     * ```
     * */
    fn readCast (self, dmut context: &SyntaxVisitor, loc: &Word)-> &Expression
        throws ErrorMsg
    {
        let mut type: &Expression = EMPTY_EXPR;
        
        context:.readTokens (Tokens::NOT);
        let (complexType, _) = context:.readIf (Tokens::LACC);
        if complexType.isEof { // cast!X (V)
            type = self.readOperandSimple4 (alias context);
        } else { // cast!{X} (V)
            type = self.readExpressionSimple (alias context, BinaryOperatorsLevelNames::BOOL_LOGIC);
            context:.readTokens (Tokens::RACC);
        }

        context:.readTokens (Tokens::LPAR); // (V)
        let value = self.readExpressionSimple (alias context, BinaryOperatorsLevelNames::BOOL_LOGIC);
        context:.readTokens (Tokens::RPAR);

        return copy CastExpr (loc,
                              type-> type,
                              value-> value);
    }

    /**
     * Read a version expression introduced by the keyword `__version`
     *
     * @params:
     *    - context: the context of the reading
     *    - loc:     the location of the `__version` keyword
     *
     * @grammar
     * ```
     * VersionExpr :=
     *      '__version' '!' Identifier     
     * ```
     * */
    fn readVersion (self, dmut context: &SyntaxVisitor, loc: &Word)-> &Expression
        throws ErrorMsg
    {
        context:.readTokens (Tokens::NOT);
        let (ident, _) = context:.readIdentifier ();

        return copy VersionExpr (loc, ident);
    }

    /**
     * Read a template checker expression introduced by the keyword `template`
     *
     * @params:
     *    - context: the context of the reading
     *    - loc:     the location of the `template` keyword
     *
     * @grammar
     * ```
     * TemplateCheckerExpr :=
     *     `template` '!' templates TemplateParameters
     * ```
     * */
    fn readTemplateChecker (self, dmut context: &SyntaxVisitor, loc: &Word)-> &Expression
        throws ErrorMsg
    {
        let (call, _) = context:.readTokens (Tokens::NOT);
        let lst = self.readTemplateCallList (alias context, call);
                
        let hasAcc = context.peekToken ();
        if hasAcc.isEof || hasAcc != Tokens::LACC {
            throw copy ErrorMsg::fatal (hasAcc, format (SyntaxErrorMessage::UNEXPECTED_BUT_LST, hasAcc.str, Tokens::LACC));            
        }
        
        let rules = context:.readTemplateParameters (EOF_WORD);

        
        return copy TemplateCheckerExpr (loc, lst, rules);
    }

    /**     
     * Read a lambda expression     
     *
     * @params:
     *    - context: the context of the reading
     *    - loc:     the location of the start of the lambda
     *
     * @grammar
     * ```
     * LambdaExpr :=
     *     '||' LambdaRetType? LambdaBody
     *     '|' LambdaParamList? '|' LambdaRetType? LambdaBody
     *
     * LambdaParamList :=
     *    LambdaParamDecl (',' LambdaParamDecl)*
     *
     * LambdaParamDecl :=
     *    VariableModifiers? Identifier (':' OperandSimple(0))?
     *
     * LambdaRetType :=
     *    '->' OperandSimple(0)
     *    
     * LambdaBody :=
     *       '=>' OperandSimple(0)
     *     | '{' Declaration* BlockInstrOrExprList '}'
     * ```
     * */
    fn readLambda (self, dmut context: &SyntaxVisitor, loc: &Word)-> &Expression
        throws ErrorMsg
    {
        let mut hasClose = EOF_WORD;
        if loc == Tokens::DPIPE { // || is a token, so we need to check if we have ||, or | | for empty param list
            hasClose = loc;
        } else {
            hasClose = context:.readIf (Tokens::PIPE)._0; 
        }

        let mut params: [&VarDeclExpr] = [];
        if hasClose.isEof loop { // read the parameter list,  | ParamDecl (',' ParamDecl)* |
            let (isLazyOrRef, isMutOrDmut) = context:.readVariableModifiers ();
            let (ident, _) = context:.readIdentifier (); // identifier is mandatory

            // ':' type is optional
            let mut type: &Expression = EMPTY_EXPR;
            let (hasType, _) = context:.readIf (Tokens::COLON);
            if !hasType.isEof {
                type = self.readOperandSimple0 (alias context);
            }

            params ~= [copy VarDeclExpr (ident, ident,
                                         isLazyOrRef-> isLazyOrRef,
                                         isMutOrDmut-> isMutOrDmut,
                                         type-> type,
                                         value-> EMPTY_EXPR)];

            let (hasNext, _) = context:.readTokens (Tokens::COMA, Tokens::PIPE); // (',' ParamDecl)*, or closing |
            if hasNext == Tokens::PIPE
                break;
        }

        let mut retType: &Expression = EMPTY_EXPR;
        let (hasRet, _) = context:.readIf (Tokens::ARROW); // || -> T
        if !hasRet.isEof {
            retType = self.readOperandSimple0 (alias context);
        }
        
        let mut body: &Expression = EMPTY_EXPR;
        let (simpleBody, _) = context:.readTokens (Tokens::DARROW, Tokens::LACC);
        if simpleBody == Tokens::DARROW { // || -> T => V
            body = self.readOperandSimple0 (alias context);
        } else { // || -> T { ... }
            body = self.readBlock (alias context, simpleBody, withGuards-> false);
        }

        return copy LambdaExpr (loc,
                                proto-> FunctionPrototype (params, retType, isVariadic-> false),
                                body-> body);
    }    
    
    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =====================================          TYPES          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Read a function type expression introduced by the keyword `fn`
     *
     * @params:
     *    - context: the context of the reading
     *    - loc:     the location of the `fn` keyword
     *
     * @grammar
     * ```
     * FptrTypeExpr :=
     *    FptrKw '(' FptrParameters? ')' '->' OperandSimple(0)
     *
     *
     * FptrParameters :=
     *    FptrParameter (',' FptrParameter)?
     *
     * FptrParameter :=
     *       VariableModifier Identifier ':' OperandSimple(0)
     *     | VariableModifier OperandSimple(0)
     *     
     * ```
     * */
    fn readFunctionType (self, dmut context: &SyntaxVisitor, loc: &Word)-> &Expression
        throws ErrorMsg
    {
        context:.readTokens (Tokens::LPAR);
        let mut params: [&VarDeclExpr] = [];
        let (hasParams, _) = context:.readIf (Tokens::RPAR); 
        if hasParams.isEof loop {
            // decorators are always first, even if there is no identifier
            let (isLazyOrRef, isMutOrDmut) = context:.readVariableModifiers ();

            // Register the location to rewind if identifier reading fails
            let seek = context.getSeek ();
                    
            let (mut id, _) = context:.readIfIdentifier ();
            if !id.isEof {
                let (hasColon, _) = context:.readIf (Tokens::COLON);                

                if hasColon.isEof { // identifier but no ':' following
                    id = loc.locate (Keys::UNDER);
                    context:.rewindToSeek (seek); // we rewind to start of the reading
                } // else, Identifier ':' are read                     
            } else { // no identifier 
                id = loc.locate (Keys::UNDER); // we create a fake one
            }

            // Either we read Id ':', or not, it doesn't matter we now read the type
            let type = self.readOperandSimple0 (alias context);
            params ~= [copy VarDeclExpr (loc-> id,
                                         name-> id,
                                         isLazyOrRef-> isLazyOrRef,
                                         isMutOrDmut-> isMutOrDmut,
                                         type-> type,
                                         value-> EMPTY_EXPR)];        
        }


        context:.readTokens (Tokens::ARROW);
        let type = self.readOperandSimple0 (alias context);


        let isDelegate = (loc.str == Keys::DELEGATE);
        return copy FunctionPtrTypeExpr (loc,
                                         isDelegate-> isDelegate,
                                         params-> params,
                                         retType-> type);
    }

    /**
     * Read a future type expression introduced by the keyword `future`
     *
     * @params:
     *    - context: the context of the reading
     *    - loc:     the location of the `future` keyword
     *
     * @grammar
     * ```
     * FutureTypeExpr :=
     *    `future` '->' OperandSimple(0)
     * ```
     * */
    fn readFutureType (self, dmut context: &SyntaxVisitor, loc: &Word)-> &Expression
        throws ErrorMsg
    {
        context:.readTokens (Tokens::ARROW);
        let type = self.readOperandSimple0 (alias context);
        
        return copy FutureTypeExpr (loc,                                                                        
                                    retType-> type);
    }

    /**
     * Read a await type expression introduced by the keyword `async`
     *
     * @params:
     *    - context: the context of the reading
     *    - loc:     the location of the `async` keyword
     *
     * @grammar
     * ```
     * AsyncTypeExpr :=
     *    `async` '->' OperandSimple(0)
     * ```
     * */
    fn readAsyncType (self, dmut context: &SyntaxVisitor, loc: &Word)-> &Expression
        throws ErrorMsg
    {
        context:.readTokens (Tokens::ARROW);
        let type = self.readOperandSimple0 (alias context);
        
        return copy AsyncTypeExpr (loc,                                                                        
                                   retType-> type);
    }

    /**
     * Read a await type expression introduced by the keyword `yield`
     *
     * @params:
     *    - context: the context of the reading
     *    - loc:     the location of the `yield` keyword
     *
     * @grammar
     * ```
     * YieldTypeExpr :=
     *    `yield` '->' OperandSimple(0)
     * ```
     * */
    fn readYieldType (self, dmut context: &SyntaxVisitor, loc: &Word)-> &Expression
        throws ErrorMsg
    {
        context:.readTokens (Tokens::ARROW);
        let type = self.readOperandSimple0 (alias context);
        
        return copy YieldTypeExpr (loc,                                                                        
                                   retType-> type);
    }
    
    
    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          CONTROL          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Read an `if/else` control flow expression
     *
     * @params:
     *   - context: the context of the reading
     *   - loc:     the location of the `if` keyword
     *   - isCte:   the location of the `cte` keyword if read
     *
     * @grammar:
     * ```
     * Conditional :=
     *    ('cte')? 'if' ExpressionSimple (BOOL_LOGIC) BlockOrSingleExpr ConditionalFollow?
     *    | CondLet
     *
     * ConditionalFollow :=
     *       'else' BlockOrSingleExpr
     *     | 'else' Conditional
     *     
     * ```
     * */
    fn readCond (self, dmut context: &SyntaxVisitor, loc: &Word, isCte: &Word = EOF_WORD)-> &Expression
        throws ErrorMsg
    {
        let (isLet, _) = context:.readIf (Keys::LET);
        if !isLet.isEof {
            if !isCte.isEof throw copy ErrorMsg::fatal (isLet, format (SyntaxErrorMessage::UNEXPECTED, isLet.str),
                                                        notes-> copy [copy ErrorMsg::note (isCte, "")]);
            
            return self.readCondLet (alias context, loc, isLet);
        }
        
        let test = self.readExpressionSimple (alias context, BinaryOperatorsLevelNames::BOOL_LOGIC);
        let body = self.readBlockOrSingleExpr (alias context);
                
        let mut else_: &Expression = EMPTY_EXPR;
        let (hasNext, _) = context:.readIf (Keys::ELSE);
        if !hasNext.isEof {
            let (hasSecondIf, _) = context:.readIf (Keys::IF);
            if hasSecondIf.isEof {
                else_ = self.readBlockOrSingleExpr (alias context);                                
            } else {
                else_ = self.readCond (alias context, hasSecondIf, isCte-> isCte);
            }
        }
        
        return copy ConditionalExpr (loc, test, body, else_-> else_, isCte-> isCte);        
    }


    /**
     * Read a `if let/else` control flow expression
     *
     * @params:
     *    - context: the context of the reading
     *    - loc:     the location of the `if` keyword
     *    - letLoc:  the location of the `let` keyword
     *
     * @grammar
     * ```
     * CondLet :=
     *     'if' 'let' LetDecl(true) guard? ExpressionComplex(AFFECT) ConditionalFollow?
     *
     * Guard :=
     *    '&&' ExpressionSimple(COMPARE)
     * ```
     * */
    fn readCondLet (self, dmut context: &SyntaxVisitor, loc: &Word, letLoc: &Word)-> &Expression
        throws ErrorMsg
    {
        let var = self.readLet (alias context, letLoc, inControl-> true);

        let mut guard: &Expression = EMPTY_EXPR;
        let (hasGuard, _) = context:.readIf (Tokens::DAND);
        if !hasGuard.isEof {
            guard = self.readExpressionSimple (alias context, BinaryOperatorsLevelNames::COMPARE);
        }

        let body = self.readBlockOrSingleExpr (alias context);        

        let mut else_: &Expression = EMPTY_EXPR;
        let (hasNext, _) = context:.readIf (Keys::ELSE);
        if !hasNext.isEof {
            let (hasSecondIf, _) = context:.readIf (Keys::IF);
            if hasSecondIf.isEof {
                else_ = self.readBlockOrSingleExpr (alias context);                
            } else {
                else_ = self.readCond (alias context, hasSecondIf, isCte-> EOF_WORD);
            }
        }
        
        return copy ConditionalLetExpr (loc-> loc,
                                        test-> var,
                                        guard-> guard,
                                        body, else_-> else_);
    }



    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ================================          VAR DECLARATIONS          ================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Read a var declaration inside a `let` instruction.
     *
     * @params:
     *    - context: the context of the reading
     *    - loc:     the location of the `let` keyword
     *    - onlyOne: true if only one variable is allowed (for IfLet and WhileLet for example).
     *
     * @grammar
     * 
     * ```
     * LetDecl(inControl = true) :=     
     *     'let' PatterMatchExpr LetValue(true)
     *   | 'let' LetDeclOne 
     
     * LetDecl(false) :=     
     *     'let' PatterMatchExpr LetValue(false)
     *   | 'let' LetDeclOne(false) (',' LetDeclOne(false))* 
     *
     *
     * LetDeclOne(inControl) :=     
     *    Decorators Identifier LetType? LetValue(inControl)
     *     
     * LetValue(inControl = true)  := '=' ExpressionComplex(COMPARE)
     * LetValue(inControl = false) := '=' ExpressionComplex(BOOL_LOGIC) 
     * LetType  := ':' OperandSimple(0)
     * ```
     *
     *
     * @info
     *   ExpressionComplex(3) is right after '&&', because it's used inside
     *   guards of IfLet, WhileLet. and we also don't want to be able to do
     *   affectation in there. That's why ExpressionComplex(1), and not 0 if not in
     *   control (indeed 0 means affectation operators).
     * 
     * */
    fn readLet (self, dmut context: &SyntaxVisitor, loc: &Word, inControl: bool)-> &Expression
        throws ErrorMsg
    {
        let level = if inControl {
            BinaryOperatorsLevelNames::COMPARE // we don't accept '&&' because it's used by the control guard
        } else {
            BinaryOperatorsLevelNames::BOOL_LOGIC
        };
        
        let trySingle = context.getSeek ();
        let mut singleErr: (&ErrorMsg)? = none;
        let mut patternErr: (&ErrorMsg)? = none;
        
        // store true if a least one SingleVarDecl was read in the first try group
        // Because we don't want to try pattern in that case
        // 
        let mut succeed = false; 

        { // Try with a list of LetDeclOne
            let mut decls: [&Expression] = [];
            loop {
                let var = self.readSingleVarDecl (alias context, loc, level-> level);
                decls ~= [var];
                succeed = true;
                if inControl 
                    break;

                let (hasNext, _) = context:.readIf (Tokens::COMA);
                if hasNext.isEof
                    break;                
            }

            if decls.len == 0
                return decls [0];

            return copy SetExpr (loc, decls);
        } catch {
            err => {
                if succeed throw err;
                singleErr = (err)?;
            }
        }

        context:.rewindToSeek (trySingle);
        { // Try a pattern matcher
            let pattern = self.readPatternExpr (alias context);
            context:.readTokens (Tokens::EQUAL);        
            let value = self.readExpressionComplex (alias context, level);

            // No follow on pattern var match
            return copy PatternVarDeclExpr (loc, pattern, value);
        } catch {
            err => {
                patternErr = (err)?;
            }
        }

        if let (Ok (ne), Ok (pe)) = (singleErr, patternErr) {
            throw copy ErrorMsg::list (copy [ne, pe]);
        }

        eprintln ("internal expression syntax error: error is empty");
        panic;
    }

    /**
     * Read a single variable declaration inside a LetDecl
     *
     * @params:
     *    - context: the context of the reading
     *    - loc:     the location of the `let` keyword
     *    - level:   the level of the expression to read
     *
     * @grammar: cf. `self.readLet`     
     * */
    fn readSingleVarDecl (self, dmut context: &SyntaxVisitor, loc: &Word, level: u32)-> &Expression
        throws ErrorMsg
    {
        // 'mut' 'lazy', etc.
        let (isLazyOrRef, isMutOrDmut) = context:.readVariableModifiers ();
        let (ident, _) = context:.readIdentifier ();

        // ':' type is optional
        let mut type: &Expression = EMPTY_EXPR;        
        let (hasType, _) = context:.readIf (Tokens::COLON);
        if !hasType.isEof {
            type = self.readOperandSimple0 (alias context);
        }

        // '=' value is mandatory        
        context:.readTokens (Tokens::EQUAL);        
        let value = self.readExpressionComplex (alias context, level-> level);        

        return copy VarDeclExpr (loc-> loc, // location of the 'let'
                                 name-> ident,
                                 isLazyOrRef-> isLazyOrRef,
                                 isMutOrDmut-> isMutOrDmut,
                                 type-> type,
                                 value-> value);
    }    

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ================================          PATTERN MATCHING          ================================
     * ====================================================================================================
     * ====================================================================================================
     */


    /**
     * Read an expression introduced by the keyword `match`
     *
     * @params:
     *    - context: the context of the reading
     *    - loc:     the location of the `match` keyword
     *
     * @grammar
     * ```
     * MatchExpr :=
     *    'match' ExpressionSimple(0) '{' MatchExpr (MatchExpr)* '}'
     *
     *
     * MatchExpr :=
     *   PatternExpr Guard? '=>' BlockOrSingleExpr
     * ```
     * */
    fn readMatch (self, dmut context: &SyntaxVisitor, loc: &Word)-> &Expression
        throws ErrorMsg
    {
        let value = self.readExpressionSimple (alias context, BinaryOperatorsLevelNames::BOOL_LOGIC);
        let mut matchers: [MatchLine] = [];
        context:.readTokens (Tokens::LACC);
        loop {
            let pattern = self.readPatternExpr (alias context);

            let mut guard: &Expression = EMPTY_EXPR;
            let (hasTest, _) = context:.readIf (Keys::IF);
            if !hasTest.isEof {
                guard = self.readExpressionSimple (alias context, BinaryOperatorsLevelNames::BOOL_LOGIC);
            }

            context:.readTokens (Tokens::DARROW);
            let blk = self.readBlockOrSingleExpr (alias context);

            matchers ~= [MatchLine (pattern, guard, blk)];

            let (end, _) = context:.readIf (Tokens::RACC);
            if !end.isEof
                break;
        }

        return copy MatcherExpr (loc, value, matchers, isCatcher-> false);
    }


    /**
     * Read an expression introduced by the keyword `catch`
     *
     * @params:
     *    - context: the context of the reading
     *    - loc:     the location of the `catch` keyword
     *
     * @grammar
     * ```
     * CatchExpr :=
     *    'catch' '{' MatchExpr (MatchExpr)* '}'     
     * ```
     * */
    fn readCatch (self, dmut context: &SyntaxVisitor, loc: &Word)-> &Expression
        throws ErrorMsg
    {        
        let mut matchers: [MatchLine] = [];
        context:.readTokens (Tokens::LACC);
        loop {
            let pattern = self.readPatternExpr (alias context);

            let mut guard: &Expression = EMPTY_EXPR;
            let (hasTest, _) = context:.readIf (Keys::IF);
            if !hasTest.isEof {
                guard = self.readExpressionSimple (alias context, BinaryOperatorsLevelNames::BOOL_LOGIC);
            }

            context:.readTokens (Tokens::DARROW);
            let blk = self.readBlockOrSingleExpr (alias context);

            matchers ~= [MatchLine (pattern, guard, blk)];

            let (end, _) = context:.readIf (Tokens::RACC);
            if !end.isEof
                break;
        }

        return copy MatcherExpr (loc, EMPTY_EXPR, matchers, isCatcher-> true);
    }
    
    /**
     * Read a pattern matcher expression (inside pattern match, or a LetDecl)
     *
     * @params:
     *    - context: the context of the reading
     *
     * @grammar
     * ```
     * MatchExpr :=
     *      '(' PatternParPatternExpr ')'
     *    | '[' PatternParPatternExpr ']'
     *    | SingleVarPatternDecl     
     * ```
     * */
    fn readPatternExpr (self, dmut context: &SyntaxVisitor)-> &Expression
        throws ErrorMsg
    {
        let (hasPar, _) = context:.readIf (Tokens::LPAR, Tokens::LCRO);
        if !hasPar.isEof {
            return self.readParPatternExpr (alias context, hasPar);
        }

        return self.readSingleVarPatternDecl (alias context);
    }


    /**
     * Read a single var declaration for a pattern match expression
     *
     * @params:
     *   - context: the context of the reading
     *
     * @grammar
     * ```
     * LetMatchDecl :=
     *     Decorators? Identifier LetPatternType? LetPatternValue?     
     *     | ExpressionSimple(RANGE)
     *     | OptionPatternExpr
     *     | CallingPatternExpr 
     *     
     * OptionPatternExpr :=
     *    OptionName (' OptionPatternExpr ')'
     *
     * CallingPatternExpr :=
     *    OperandSimple(3) '(' CallingPatternNamedVars? ')'
     *     
     *
     * CallingPatternNamedVars := 
     *    CallingPatternNamedVar (',' CallingPatternNamedVar)*
     *
     * CallingPatternNamedVar :=
     *     Identifier '->' PatternExpr
     *   
     * OptionName := 'Ok' | 'Err'
     * 
     * LetPatternType :=
     *        ':' '_'
     *      | ':' OperandSimple(0)
     *
     * LetPatternValue :=
     *    '=' PatternExpr
     * ```     
     * */
    fn readSingleVarPatternDecl (self, dmut context: &SyntaxVisitor)-> &Expression
        throws ErrorMsg
    {
        let (isLazyOrRef, isMutOrDmut) = context:.readVariableModifiers ();
        if !isLazyOrRef.isEof || !isMutOrDmut.isEof { // Decorators found, so Identifier is mandatory
            let (name, _) = context:.readIdentifier ();
            return self.readDecoratedSingleVarPatternDecl (alias context, name, isLazyOrRef, isMutOrDmut);
        }

        let seek = context.getSeek ();
        let (name, _) = context:.readIfIdentifier ();
        if name.isEof // No identifier, so it's an ExpressionSimple (Ok, and Err are identifiers)
            return self.readExpressionSimple (alias context, BinaryOperatorsLevelNames::RANGE);

        match name.str {
            OptionKeys::MATCH_SOME | OptionKeys::MATCH_NONE => // Option pattern 
                return self.readOptionPatternExpr (alias context, name);    
        }

        let follow = context.peekToken ();
        match follow.str {
            Tokens::LPAR | Tokens::NOT | Tokens::DCOLON => {
                // Identifier '(' | Identifier '!' | Identifier '::' <- are types
                context:.rewindToSeek (seek); // go back before the identifier, calling patter will read everything again
                return self.readCallingPatternExpr (alias context);
            } Tokens::COLON | Tokens::EQUAL => // Identifier ':' | Identifier '=' <- are variables
                return self.readDecoratedSingleVarPatternDecl (alias context, name, EOF_WORD, EOF_WORD);            
        }

        if name == Keys::UNDER {
            return copy VarDeclExpr (loc-> name, 
                                     name-> name, // keys::UNDER with no type, and no value, so just ignore pattern
                                     isMutOrDmut-> EOF_WORD,
                                     isLazyOrRef-> EOF_WORD,
                                     value-> EMPTY_EXPR,
                                     type-> EMPTY_EXPR);
        }
            

        // We go back before the identifier, it may be part of just an expression
        context:.rewindToSeek (seek);
        
        let content = self.readOperandSimple0 (alias context);
        if let v: &VarExpr = content { // Identifier with nothing
            return copy VarDeclExpr (loc-> v.loc,
                                     name-> v.loc,
                                     isMutOrDmut-> EOF_WORD,
                                     isLazyOrRef-> EOF_WORD,
                                     value-> EMPTY_EXPR,
                                     type-> EMPTY_EXPR);
        }

        return content; // or an expression starting with an identifier (e.g. `foo.bar ()`)                    
    }

    /**
     * Read a single var decl expression inside a pattern match starting with decorators and an identifier
     *
     * @params:
     *    - context:     the context of the reading
     *    - name:        the identifier of the variable
     *    - isLazyOrRef: the lazy or ref keyword (can be EOF_WORD)
     *    - isMutOrDmut: the mut or dmut keyword (can be EOF_WORD)
     *
     * @grammar: cf. `self.readSingleVarPatternDecl`
     * */
    fn readDecoratedSingleVarPatternDecl (self, dmut context: &SyntaxVisitor, name: &Word, isLazyOrRef: &Word, isMutOrDmut: &Word)-> &Expression
        throws ErrorMsg
    {
        let mut type: &Expression = EMPTY_EXPR;
        let (hasType, _) = context:.readIf (Tokens::COLON);
        if !hasType.isEof {
            type = self.readOperandSimple0 (alias context);
        }

        let mut value: &Expression = EMPTY_EXPR;
        let (hasValue, _) = context:.readIf (Tokens::EQUAL);
        if !hasValue.isEof {
            value = self.readPatternExpr (alias context);
        }

        return copy VarDeclExpr (loc-> name,
                                 name-> name,
                                 isLazyOrRef-> isLazyOrRef,
                                 isMutOrDmut-> isMutOrDmut,
                                 type-> type,
                                 value-> value);
    }

    /**
     * Read an option pattern match expression
     * 
     * @params:
     *    - context: the context of the reading
     *    - name:    the location of the 'Ok'|'Err' identifier
     *
     * @grammar: cf. `self.readSingleVarPatternDecl`
     * */
    fn readOptionPatternExpr (self, dmut context: &SyntaxVisitor, name: &Word)-> &Expression
        throws ErrorMsg
    {
        let mut inner: &Expression = EMPTY_EXPR;
        context:.readTokens (Tokens::LPAR);
        let (isClosed, _) = context:.readIf (Tokens::RPAR);
        if isClosed.isEof {
            inner = self.readPatternExpr (alias context);
        }

        let filter = keys::toEnum!{MatchOptionFilters} (name.str);
        return copy MatchOptionFilterExpr (name, filter, inner);
    }


    /**
     * Read a pattern match calling expression
     *
     * @params:
     *    - context: the context of the reading     
     *
     * @grammar: cf. `self.readSingleVarPatternDecl`
     * 
     * @assume
     *    The cursor of `context` is positioned at the start of the
     *    expression
     *    
     * */
    fn readCallingPatternExpr (self, dmut context: &SyntaxVisitor)-> &Expression
        throws ErrorMsg
    {
        let seek = context.getSeek ();                         
        let mut callingErr: (&ErrorMsg)? = none;
        let mut exprErr: (&ErrorMsg)? = none;
        
        {
            let type = self.readOperandSimple3 (alias context);
            let (start, _) = context:.readTokens (Tokens::LPAR);
            let mut params: [&Expression] = [];

            let (mut close, _) = context:.readIf (Tokens::RPAR); 
            while close != Tokens::RPAR {
                let (ident, _) = context:.readIdentifier ();
                let (arr, _) = context:.readTokens (Tokens::ARROW);
                let value = self.readPatternExpr (alias context);
                
                params ~= [copy NamedExpr (arr, name-> ident, value->  value)];
                close = context:.readTokens (Tokens::COMA, Tokens::RPAR)._0;
            }


            return copy MultOperatorExpr (start,
                                          close,
                                          op-> toEnum!{MultOperators} (start.str),
                                          left-> type,
                                          rights-> params); 
        } catch {
            err => {
                callingErr = (err)?;
            }
        }

        // Maybe it's not a calling, just started like one
        context:.rewindToSeek (seek);
        {
            return self.readExpressionSimple (alias context, BinaryOperatorsLevelNames::RANGE);
        } catch {
            err => {
                exprErr = (err)?;
            }
        }

        if let (Ok (ce), Ok (ee)) = (callingErr, exprErr) {
            throw copy ErrorMsg::list (copy [ce, ee]);
        }

        eprintln ("internal expr syntax error: empty expressions");
        panic;
    }
    

    /**
     * Read a pattern match starting with the tokens '[' or '('
     *
     * @params:
     *    - context: the context of the reading
     *    - start: the opening token location (i.e. '(' or '[')
     * */
    fn readParPatternExpr (self, dmut context: &SyntaxVisitor, start: &Word)-> &Expression
        throws ErrorMsg
    {
        let (end, isArray) = if start.str == Tokens::LPAR {
            (Tokens::RPAR, false)
        } else {
            (Tokens::RCRO, true)
        };        
        
        let mut params: [&Expression] = [];
        let (mut close, _) = context:.readIf (end);
        
        // isVariadic is set when '...' is found.
        let mut isVariadic = false;

        // isSingleTuple is set when a closing ',)' is found
        let mut isSingleTuple = false; // assert (isSingleTuple => !isArray)
        
        while close != end {
            params ~= [self.readPatternExpr (alias context)];

            close = context:.readTokens (Tokens::COMA, Tokens::TDOT, end)._0;
            match close.str {
                Tokens::TDOT => { // Variadic
                    if !isArray && params.len == 1 {
                        context:.readTokens (Tokens::COMA); // tuple with one value (x...,) 
                        isSingleTuple = true;
                    }
                    
                    close = context:.readTokens (end)._0;
                    isVariadic = true;                    
                    break;
                }
                
                Tokens::COMA if (!isArray && params.len == 1) => {
                    close = context:.readIf (Tokens::RPAR)._0;
                    if !close.isEof {  // tuple with one value (x,)
                        isSingleTuple = true;
                        break;
                    } // else, just a list of expression (x, y)
                }                
            }
        }

        // Read only one parameter, with no coma, then it's just parentheses
        // around an expression, not a tuple
        // 
        if !isSingleTuple && params.len == 1
            return params [0];


        // Multiple params or closing ',)' 
        return copy MatchListFilterExpr (loc-> start,
                                         end-> close,
                                         params-> params,
                                         isVariadic-> isVariadic,
                                         isArray-> isArray);
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =====================================          BLOCKS          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Read a expression block introduced by the token '{'
     *
     * @params:
     *    - context: the context of the reading
     *    - open:    the location of the opening ';'
     *
     * @grammar
     * ```
     * BlockExpr(withGuards = true) :=
     *   '{' Declaration* ExpressionList '}' ScopeGuards?
     *
     * BlockExpr(withGuards = false) :=
     *   '{' Declaration* BlockInstrOrExprList '}' 
     *
     * BlockInstrOrExprList :=
     *    (InstrOrExpr ';')* InstrOrExpr
     *    
     * ```
     *
     * @info
     *   Unable to write the real CFG grammar, some expression needs a
     *   closing semi colon, others don't (cf. `context.needClosingExpr`)
     *   
     * */
    fn readBlock (self, dmut context: &SyntaxVisitor, open: &Word, withGuards: bool)-> &Expression
        throws ErrorMsg
    {                
        let decls = self.readBlockDeclList (alias context);                

        let mut exprs: [&Expression] = [];
        // Set to true, if the last expression ends with a ';'
        let mut closing = true;        
        let mut end: &Word = EOF_WORD;
        
        loop {
            end = context:.readIf (Tokens::SEMI_COLON, Tokens::RACC)._0;
            match end.str {
                Tokens::SEMI_COLON => { 
                    closing = true;
                }
                Tokens::RACC =>
                    break;

                _ => {
                    if !closing && exprs.len != 0 {
                        if context.needClosingExpr (exprs [$ - 1]) {
                            let (n, _) = context:.readToken ();
                            throw copy ErrorMsg::fatal (n, format (SyntaxErrorMessage::UNEXPECTED_BUT_LST, n.str, Tokens::SEMI_COLON));
                        }
                    }

                    exprs ~= [self.readInstrOrExpr (alias context)];
                    closing = false;
                }
            }
        }
        
        let (catcher, scopes) = if withGuards {
            self.readScopeGuards (alias context)
        } else {
            (EMPTY_EXPR, [])
        };
        
        if closing {
            exprs ~= [EMPTY_EXPR];
        }

        let mut decl: &Declaration = EMPTY_BLOCK_DECL;
        if decls.len != 0 {
            decl = copy BlockDecl (loc-> open,
                                   comm-> "",
                                   decls-> decls,
                                   protection-> Protection::PRIVATE,
                                   isSet-> false);
        }

        return copy BlockExpr (loc-> open,
                               end-> end,
                               module-> decl,
                               content-> exprs,
                               catcher-> catcher,
                               guards-> scopes);
    }

    /**
     * Read a list of declaration inside a expression block
     *
     * @params:
     *    - context: the context of the reading
     *
     * @grammar: cf. `self.readBlock`
     * */
    fn readBlockDeclList (self, dmut context: &SyntaxVisitor)-> [&Declaration]
        throws ErrorMsg
    {
        let mut decls: [&Declaration] = [];
        loop {
            if !context.getGlobalVisitor ().isLocalDeclaration (context) 
                break;

            decls ~= [context.getGlobalVisitor ().readLocalDeclaration (alias context)];            
        }

        decls
    }

    /**
     * Read a scope guard part of a block
     *
     * @params:
     *    - context: the context of the reading
     *
     * @grammar:
     * ```     
     * ScopeGuards :=
     *   ScopeGuard*
     * 
     * ScopeGuard :=
     *      ScopeKw BlockExpr(false)
     *    | CatcherGuard
     *
     * CatcherGuard :=
     *    'catch' CatcherBlock
     *
     * ScopeKw := 'exit' | 'success' | 'failure'
     * 
     * ```
     * */
    fn readScopeGuards (self, dmut context: &SyntaxVisitor)-> (&Expression, [&ScopeGuardExpr])
        throws ErrorMsg
    {
        let mut catcher: &Expression = EMPTY_EXPR;
        let mut guards: [&ScopeGuardExpr] = [];
        let mut seen: [[c8] => mut &Word] = copy [];

        loop {
            let (n, _) = context:.readIf (Keys::EXIT, Keys::SUCCESS, Keys::FAILURE, Keys::CATCH);
            if n.isEof
                break;

            if let Ok (val) = seen [n.str] {
                throw copy ErrorMsg::fatal (n, end-> val, format (SyntaxErrorMessage::MULTIPLE_SAME_GUARD, n.str));
            }            
            seen [n.str] = n;

            match n.str {
                Keys::CATCH => {
                    catcher = self.readCatch (alias context, n);
                }
                _ => {
                    let (open, _) = context:.readTokens (Tokens::LACC);
                    let blk = self.readBlock (alias context, open, withGuards-> false);
                    guards ~= [copy ScopeGuardExpr (n, blk, kind-> keys::toEnum!{ScopeGuardType} (n.str))]; 
                }
            }
        }

        return (catcher, guards);
    }

    /**
     * Read a block with no scope guards or a single instruction/expression followed or not with a ';'
     *
     * @params:
     *    - context: the context of the reading
     *
     * @grammar
     * ```
     * BlockOrSingleExpr :=
     *     '{' Declaration* BlockInstrOrExprList '}'
     *   | InstrOrExpr (';')?    
     * ```
     *
     * @info
     *   This function is used inside control flows to read the body when
     *   the '{' '}' are not mandatories (e.g. conditional, for loops, etc.)
     *   
     * */
    fn readBlockOrSingleExpr (self, dmut context: &SyntaxVisitor)-> &Expression
        throws ErrorMsg
    {
        let (open, _) = context:.readIf (Tokens::LACC);        
        if open.str == Tokens::LACC {                
            return self.readBlock (alias context, open, withGuards-> false);        
        }

        let expr = self.readInstrOrExpr (alias context);
        if context.needClosingExpr (expr) {
            let (cl, _) = context:.readIf (Tokens::SEMI_COLON);
            if !cl.isEof {
                return copy BlockExpr (expr.loc, cl, content-> copy [expr, EMPTY_EXPR]);
            } 
        }

        return expr;
    }

    
    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          CONTROLS          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Read an expression introduced by the keyword `for`
     *
     * @params:
     *    - context: the context of the reading
     *    - loc: the location of the `for` keyword
     *    - isCte: the location of the `cte` keyword if any (can be EOF_WORD)
     *
     * @grammar
     * ```
     * ForLoopExpr :=
     *     'for' ForLoopIterVarDecl (',' ForLoopIterVarDecl)* 'in' ExpressionSimple(BOOL_LOGIC) BlockOrSingleExpr
     * ```
     * */
    fn readFor (self, dmut context: &SyntaxVisitor, loc: &Word, isCte: &Word)-> &Expression
        throws ErrorMsg
    {
        let mut vars: [&Expression] = [];
        loop {
            vars ~= [self.readForIterVarDecl (alias context)];
            let (n, _) = context:.readTokens (Tokens::COMA, Keys::IN);
            if n.str == Keys::IN
                break;
        }

        let iter = self.readExpressionSimple (alias context, BinaryOperatorsLevelNames::BOOL_LOGIC);
        let content = self.readBlockOrSingleExpr (alias context);

        return copy ForLoopExpr (loc, isCte-> isCte, vars, iter, content);
    }


    /**
     * Read a variable iterator in a for loop
     *
     * @params:
     *    - context: the context of the reading
     *
     * @grammar
     * ```
     * ForLoopIterVarDecl :=
     *    VariableModifierNoLazy? Identifier (':' OperandSimple(0))?    
     * 
     * ```
     * */
    fn readForIterVarDecl (self, dmut context: &SyntaxVisitor)-> &Expression
        throws ErrorMsg
    {
        let (isRef, isMutOrDmut) = context:.readVariableModifiersNoLazy ();
        let (ident, _) = context:.readIdentifier ();

        
        // ':' type is optional
        let mut type: &Expression = EMPTY_EXPR;        
        let (hasType, _) = context:.readIf (Tokens::COLON);
        if !hasType.isEof {
            type = self.readOperandSimple0 (alias context);
        }
        
        return copy VarDeclExpr (loc-> ident,
                                 name-> ident,
                                 isLazyOrRef-> isRef,
                                 isMutOrDmut-> isMutOrDmut,
                                 type-> type,
                                 value-> EMPTY_EXPR);
    }

    /**
     * Read an expression introduced by the keyword `loop`
     *
     * @params:
     *    - context: the context of the reading
     *    - loc:     the location of the `loop` keyword
     *
     * @grammar
     * ```
     * LoopExpr :=
     *    'loop' '{' Declaration* BlockInstrOrExprList '}'
     * ```
     * */
    fn readLoop (self, dmut context: &SyntaxVisitor, loc: &Word)-> &Expression
        throws ErrorMsg
    {
        let (open, _) = context:.readTokens (Tokens::LACC);                                
        let content = self.readBlock (alias context, open, withGuards-> false);        

        return copy WhileLoopExpr (loc,
                                   test-> EMPTY_EXPR,
                                   block-> content);
    }

    /**
     * Read an expression introduced by the keyword `while`
     *
     * @params:
     *    - context: the context of the reading
     *    - loc:     the location of the `while` keyword
     *
     * @grammar
     * ```
     * WhileExpr :=
     *    'while' ExpressionSimple(BOOL_LOGIC) '{' Declaration* BlockInstrOrExprList '}'
     * ```
     * */
    fn readWhile (self, dmut context: &SyntaxVisitor, loc: &Word)-> &Expression
        throws ErrorMsg
    {
        let test = self.readExpressionSimple (alias context, BinaryOperatorsLevelNames::BOOL_LOGIC);
        
        let (open, _) = context:.readTokens (Tokens::LACC);                                
        let content = self.readBlock (alias context, open, withGuards-> false);        

        return copy WhileLoopExpr (loc,
                                   test-> test,
                                   block-> content);
    }
    
    /**
     * Read a complex control flow introduced by the keyword `spawn`
     *
     * @params:
     *    - context: the context of the reading
     *    - loc:     the location of the `spawn` keyword
     *
     * @grammar
     * ```
     * SpawnExpr := 
     *    'spawn' OperandSimple(0)
     *
     * ```
     * */
    fn readSpawn (self, dmut context: &SyntaxVisitor, loc: &Word)-> &Expression
        throws ErrorMsg
    {
        let operand = self.readOperandSimple0 (alias context);        
        return copy SpawnExpr (loc,
                               value-> operand);   
    }

    /**
     * Read a complex control flow introduced by the keyword `lazy`
     *
     * @params:
     *    - context: the context of the reading
     *    - loc:     the location of the `lazy` keyword
     *
     * @grammar
     * ```
     * LazyExpr := 
     *    'lazy' OperandSimple(0)
     *
     * ```
     * */
    fn readLazy (self, dmut context: &SyntaxVisitor, loc: &Word)-> &Expression
        throws ErrorMsg
    {        
        let operand = self.readOperandSimple0 (alias context);
        return copy LazyExpr (loc,
                              value-> operand);   
    }

    /**
     * Read a complex control flow introduced by the keyword `atomic`
     *
     * @params:
     *    - context: the context of the reading
     *    - loc:     the location of the `atomic` keyword
     *
     * @grammar
     * ```
     * AtomicExpr := 
     *      'atomic' '{' Declaration* BlockInstrOrExprList '}'
     *    | 'atomic' OperandSimple(0) '{' Declaration* BlockInstrOrExprList '}'
     *
     * ```
     * */
    fn readAtomic (self, dmut context: &SyntaxVisitor, loc: &Word)-> &Expression
        throws ErrorMsg
    {
        let mut monitor: &Expression = EMPTY_EXPR;
        let (open, _) = context:.readIf (Tokens::LACC);
        if open.isEof {
            monitor = self.readOperandSimple0 (alias context);
            context:.readTokens (Tokens::LACC);
        }
        
        let content = self.readBlock (alias context, open, withGuards-> false);        

        return copy AtomicExpr (loc,
                                monitor-> monitor,
                                value-> content);   
    }
    
    /**
     * Read a complex control flow introduced by the keyword `unsafe`
     *
     * @params:
     *    - context: the context of the reading
     *    - loc:     the location of the `unsafe` keyword
     *
     * @grammar
     * ```
     * UnsafeExpr := 
     *    'unsafe' OperandSimple(0)
     *
     * ```
     * */
    fn readUnsafe (self, dmut context: &SyntaxVisitor, loc: &Word)-> &Expression
        throws ErrorMsg
    {        
        let operand = self.readOperandSimple0 (alias context);   
        return copy UnsafeExpr (loc,
                                value-> operand);   
    }

    /**
     * Read a complex control flow introduced by the keyword `await`
     *
     * @params:
     *    - context: the context of the reading
     *    - loc:     the location of the `await` keyword
     *
     * @grammar
     * ```
     * AwaitExpr := 
     *    'await' OperandSimple(0)
     *
     * ```
     * */
    fn readAwait (self, dmut context: &SyntaxVisitor, loc: &Word)-> &Expression
        throws ErrorMsg
    {
        let operand = self.readOperandSimple0 (alias context);        
        return copy AwaitExpr (loc,
                               value-> operand);   
    }


}


