in keys;

use ymirc::lexing::word;
use ymirc::lexing::tokens;

/**
 * List of keywords
 */
pub enum
| AKA                = "def"
| ALIAS              = "alias"
| ASSERT             = "assert"
| ATOMIC             = "atomic"
| BREAK              = "break"
| CAST               = "cast"
| CATCH              = "catch"
| CLANG              = "C"
| CLASS              = "class"
| COMPILE            = "compile"
| CONST              = "const"
| COPY               = "copy"
| CPPLANG            = "CXX"
| CTE                = "cte"
| DCOPY              = "dcopy"
| DELEGATE           = "dg"
| DLANG              = "D"
| DMUTABLE           = "dmut"
| DO                 = "do"
| DTOR               = "__dtor"
| ELSE               = "else"
| ENUM               = "enum"
| EXIT               = "exit"
| EXPAND             = "expand"
| EXTERN             = "extern"
| FAILURE            = "failure"
| FALSE              = "false"
| FIELDINFO          = "field_infos"
| FOR                = "for"
| FUNCTION           = "fn"
| FUTURE             = "future"
| IF                 = "if"
| IMPL               = "impl"
| IN                 = "in"
| INLINE             = "inline"
| IS                 = "is"
| LAZY               = "lazy"
| LET                = "let"
| LOOP               = "loop"
| MACRO              = "macro"
| MAIN               = "main"
| MATCH              = "match"
| MEMBERS            = "members"
| MOD                = "mod"
| MOVE               = "move"
| MUTABLE            = "mut"
| NEW                = "new"
| NONE               = "none"
| NOT_IN             = "!in"
| NOT_IS             = "!is"
| NOT_OF             = "!of"
| NULL               = "null"
| OF                 = "of"
| OVER               = "over"
| PANIC              = "panic"
| PRAGMA             = "__pragma"
| PRIVATE            = "prv"
| PROTECTED          = "prot"
| PUBLIC             = "pub"
| RECORD             = "record"
| UNION              = "union"
| REF                = "ref"
| RETURN             = "return"
| SELF               = "self"
| SIZEOF             = "size"
| SKIPS              = "skips"
| SPAWN              = "spawn"
| STATIC             = "static"
| STRUCT             = "entity"
| SUCCESS            = "success"
| SUPER              = "super"
| THROW              = "throw"
| THROWS             = "throws"
| TRAIT              = "trait"
| TRUE               = "true"
| TYPEID             = "typeid"
| TYPEINFO           = "typeinfo"
| TYPEOF             = "typeof"
| UNDER              = "_"
| UNITTEST           = "__test"
| UNSAFE             = "unsafe"
| USE                = "use"
| VERSION            = "__version"
| WHILE              = "while"
| WITH               = "with"
| YLANG              = "YMIR"
| LIB_ROOT           = "__lib__"
| UNIT_TEST_REGISTER = "__unittest__global__"
 -> Keys;

pub enum
| AKA               = Keys::AKA
| ALIAS             = Keys::ALIAS
| ASSERT            = Keys::ASSERT
| ATOMIC            = Keys::ATOMIC
| BREAK             = Keys::BREAK
| CAST              = Keys::CAST
| CATCH             = Keys::CATCH
| CLASS             = Keys::CLASS
| CONST             = Keys::CONST
| COPY              = Keys::COPY
| CTE               = Keys::CTE
| DCOPY             = Keys::DCOPY
| DELEGATE          = Keys::DELEGATE
| DMUTABLE          = Keys::DMUTABLE
| DO                = Keys::DO
| ELSE              = Keys::ELSE
| ENUM              = Keys::ENUM
| EXPAND            = Keys::EXPAND
| EXTERN            = Keys::EXTERN
| FALSE             = Keys::FALSE
| FOR               = Keys::FOR
| FUNCTION          = Keys::FUNCTION
| FUTURE            = Keys::FUTURE
| IF                = Keys::IF
| IMPL              = Keys::IMPL
| IN                = Keys::IN
| IS                = Keys::IS
| LAZY              = Keys::LAZY
| LET               = Keys::LET
| LOOP              = Keys::LOOP
| MACRO             = Keys::MACRO
| MATCH             = Keys::MATCH
| MOD               = Keys::MOD
| MOVE              = Keys::MOVE
| MUTABLE           = Keys::MUTABLE
| NONE              = Keys::NONE
| NULL              = Keys::NULL
| OF                = Keys::OF
| PANIC             = Keys::PANIC
| PRAGMA            = Keys::PRAGMA
| RECORD            = Keys::RECORD
| UNION             = Keys::UNION
| REF               = Keys::REF
| RETURN            = Keys::RETURN
| SPAWN             = Keys::SPAWN
| STATIC            = Keys::STATIC
| STRUCT            = Keys::STRUCT
| THROW             = Keys::THROW
| THROWS            = Keys::THROWS
| TRAIT             = Keys::TRAIT
| TRUE              = Keys::TRUE
| TYPEOF            = Keys::TYPEOF
| UNDER             = Keys::UNDER
| UNITTEST          = Keys::UNITTEST
| UNSAFE            = Keys::UNSAFE
| USE               = Keys::USE
| VERSION           = Keys::VERSION
| WHILE             = Keys::WHILE
| WITH              = Keys::WITH
 -> ForbiddenKeys;


pub enum
| STAR     = Tokens::STAR
| PLUS     = Tokens::PLUS
| INTEG    = Tokens::INTEG
 -> MacroMultTokens;


pub enum
| LEVEL_0 = copy [Tokens::EQUAL, Tokens::DIV_AFF, Tokens::MINUS_AFF, Tokens::PLUS_AFF, Tokens::STAR_AFF, Tokens::PERCENT_AFF, Tokens::TILDE_AFF, Tokens::LEFTD_AFF, Tokens::RIGHTD_AFF]
| LEVEL_1 = copy [Tokens::DPIPE]
| LEVEL_2 = copy [Tokens::DAND]
| LEVEL_3 = copy [Tokens::INF, Tokens::SUP, Tokens::INF_EQUAL, Tokens::SUP_EQUAL, Tokens::NOT_EQUAL, Tokens::DEQUAL, Keys::OF, Keys::IS, Keys::IN, Tokens::CONGRUENT, Tokens::UNCONGRUENT]
| LEVEL_4 = copy [Tokens::TDOT, Tokens::DDOT]
| LEVEL_5 = copy [Tokens::LEFTD, Tokens::RIGHTD]
| LEVEL_6 = copy [Tokens::PIPE, Tokens::XOR, Tokens::AND]
| LEVEL_7 = copy [Tokens::PLUS, Tokens::TILDE, Tokens::MINUS]
| LEVEL_8 = copy [Tokens::STAR, Tokens::PERCENT, Tokens::DIV]
| LEVEL_9 = copy [Tokens::DXOR]
 -> BinaryOperatorsLevels;

pub enum : [c8]
| EQUAL            = Tokens::EQUAL
| DIV_AFF          = Tokens::DIV_AFF
| MINUS_AFF        = Tokens::MINUS_AFF
| PLUS_AFF         = Tokens::PLUS_AFF
| STAR_AFF         = Tokens::STAR_AFF
| PERCENT_AFF      = Tokens::PERCENT_AFF
| TILDE_AFF        = Tokens::TILDE_AFF
| LEFTD_AFF        = Tokens::LEFTD_AFF
| RIGHTD_AFF       = Tokens::RIGHTD_AFF
| DPIPE            = Tokens::DPIPE
| DAND             = Tokens::DAND
| INF              = Tokens::INF
| SUP              = Tokens::SUP
| INF_EQUAL        = Tokens::INF_EQUAL
| SUP_EQUAL        = Tokens::SUP_EQUAL
| NOT_EQUAL        = Tokens::NOT_EQUAL
| DEQUAL           = Tokens::DEQUAL
| CONGRUENT        = Tokens::CONGRUENT
| UNCONGRUENT      = Tokens::UNCONGRUENT
| OF               = Keys::OF
| IS               = Keys::IS
| IN               = Keys::IN
| NOT_OF           = Keys::NOT_OF
| NOT_IS           = Keys::NOT_IS
| NOT_IN           = Keys::NOT_IN
| TDOT             = Tokens::TDOT
| DDOT             = Tokens::DDOT
| LEFTD            = Tokens::LEFTD
| RIGHTD           = Tokens::RIGHTD
| PIPE             = Tokens::PIPE
| XOR              = Tokens::XOR
| AND              = Tokens::AND
| PLUS             = Tokens::PLUS
| TILDE            = Tokens::TILDE
| MINUS            = Tokens::MINUS
| STAR             = Tokens::STAR
| PERCENT          = Tokens::PERCENT
| DIV              = Tokens::DIV
| DXOR             = Tokens::DXOR
| DOT              = Tokens::DOT
| DOT_AND          = Tokens::DOT_AND
| DCOLON           = Tokens::DCOLON
 -> BinaryOperators;


pub enum
| MINUS  = Tokens::MINUS
| AND    = Tokens::AND
| STAR   = Tokens::STAR
| NOT    = Tokens::NOT
 -> UnaryOperators;

/**
 * The list of decorators
 */
pub enum
| MUT     = Keys::MUTABLE
| DMUT    = Keys::DMUTABLE
 -> Decorators;

pub enum
| COPY    = Keys::COPY
| EXPAND  = Keys::EXPAND
| TYPEOF  = Keys::TYPEOF
| ALIAS   = Keys::ALIAS
| DCOPY   = Keys::DCOPY
| CTE     = Keys::CTE
| LAZY    = Keys::LAZY
| SPAWN   = Keys::SPAWN
| REF     = Keys::REF
| MOVE    = Keys::MOVE
 -> IntrinsicKeys;

/**
 * The list of known user defined attributes 
 */
pub enum : [c8]   
| ABSTRACT      = "abstract"
| FINAL         = "final"
| FIELD         = "field"
| THREAD        = "thread"
| UNSAFE        = Keys::UNSAFE
| INLINE        = Keys::INLINE
 -> Attributes;        

pub record AttributeWord {
    pub let loc  : &Word;
    pub let attr : Attributes;

    pub self (loc : &Word, attr : Attributes)
        with loc = loc
        , attr = attr
    {}

    pub fn opEquals (self, o : AttributeWord)-> bool {
        self.attr == o.attr
    }
}

pub enum : [c8]
| EXIT    = Keys::EXIT
| FAILURE = Keys::FAILURE
| SUCCESS = Keys::SUCCESS
 -> ScopeGuardType;


pub enum : [c8]
| UTF32 = "s32"
| UTF16 = "s16"
| UTF8	= "s8"
 -> StringSuffixes;


pub enum : [c8]
| UTF8	= "c8"
| UTF16 = "c16"
| UTF32 = "c32"
 -> CharSuffixes;


pub enum
| U8	= "u8"
| U16	= "u16"
| U32	= "u32"
| U64	= "u64"
| USIZE = "us"
| I8	= "i8"
| I16	= "i16"
| I32	= "i32"
| I64	= "i64"
| ISIZE = "is"
 -> FixedSuffixes;

pub enum
| F32   = "f"
| F64   = "d"
| F80   = "l"
| REAL  = "r"
 -> FloatSuffixes;

pub enum
| LE = "e"
| BE = "E"
| LP = "p"
| BP = "P"
 -> FloatExp;

pub enum
| PTR      = "ptr"
| LEN      = "len"
| BLK_INFO = "blk_info"
 -> SliceKeys;

pub enum
| ID     = "typeid"
| SIZE   = "size"
| INNER  = "inner"
| NAME   = "name"
| OFFSET = "offset"
 -> TypeInfoKeys;

pub enum
| IS_SET = "set"
| VALUE  = "value"
| SIZE   = "size"
| FUNC   = "func"
 -> LazyKeys;

pub enum
| THREAD_ID = "tid"
| CONTENT   = "content"
| VALUE     = "value"
| FINISHED  = "finished"
 -> FutureKeys;

pub enum
| STEP     = "step"
| FST      = "fst"
| SCD      = "scd"
| CONTAINS = "contains"
| STEP_BY  = "stepBy"
| REVERSE  = "reverse"
| LEN      = "len"
 -> RangeKeys;

pub enum
| ANCESTOR      = "super"
| CAST_LAZY     = "pass_lazy"
| COMPILE       = "compile"
| FIELD         = "field"
| FIELD_INFOS   = "field_infos"
| FIELD_TYPE    = "field_type"
| MSG           = "msg"
| OPERATOR      = "operator"
| ROOT_ANCESTOR = "root_super"
| UNPROXIED     = "unproxied"
 -> PragmaKeys;

pub enum
| ANY    = "any"
| CHAR   = "char"
| EXPR   = "expr"
| FLOAT  = "float"
| IDENT  = "ident"
| INT    = "int"
| STRING = "str"
| TOKEN  = "token"
| WORD   = "word"
| INDEX  = "index"
| UID    = "uid"
| SKIPS  = "skips"
| FILEI  = "#__macro"
 -> MacroKeys;

pub enum
| ANY     = "any"
| CHAR    = "char"
| EXPR    = "expr"
| OPERAND = "operand"
| IDENT   = "ident"
| STRING  = "str"
| TOKEN   = "token"
| LITERAL = "literal"
 -> MacroKnownRuleKeys;

pub enum
| FUNC     = "func"
| CLOSURE  = "closure"
 -> DelegateKeys;


pub enum
| ARITY       = "arity"
| DIG         = "dig"
| EPSILON     = "epsilon"
| INF         = "inf"
| INIT        = "init"
| MANT_DIG    = "mant_dig"
| MAX         = "max"
| MAX_10_EXP  = "max_10_exp"
| MAX_EXP     = "max_exp"
| MIN         = "min"
| MIN_10_EXP  = "min_10_exp"
| MIN_EXP     = "min_exp"
| NAN         = "nan"
| SIZE        = "size"
 -> NativeTypeAttribute;


pub enum
| VTABLE  = "#_vtable"
| MONITOR = "#_monitor"
| SET     = "#_set"
 -> ClassKeys;


pub enum
| CONTENT    = "content"
| ERROR      = "error"
| VALUE      = "value"
| SET        = "hasValue"
| HAS_ERROR  = "hasError"
| MATCH_SOME = "Ok"
| MATCH_NONE = "Err"
 -> OptionKeys;


pub enum
| BLK_INFO = "minfo"
| ENTRIES  = "entries"
| CAP      = "cap"
| LOADED   = "loaded"
| DATA     = "data"
| LEN      = "len"
| REMOVE   = "remove"
 -> MapKeys;
