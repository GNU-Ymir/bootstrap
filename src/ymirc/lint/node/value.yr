in value;

pub mod ::access;
pub mod ::addr;
pub mod ::array;
pub mod ::begincatch;
pub mod ::binary;
pub mod ::cast_;
pub mod ::field;
pub mod ::float;
pub mod ::int;
pub mod ::namecall;
pub mod ::ptrcall;
pub mod ::string;
pub mod ::tuple;
pub mod ::unary;
pub mod ::unit;
pub mod ::unref;
pub mod ::var;

use ymirc::lint::node::type;
use ymirc::lexing::word;
use std::stream;
use ymirc::utils::packet;

use ymirc::lint::node::value::_;

/**
 * A Ymir Intermediate Language Value
 * */
@abstract
pub class YILValue over YILNode {

    let _type : &YILType;

    pub self (loc : &Word, type : &YILType)
        with super (loc)
        , _type = type
    {}

    @final
    pub fn getType (self)-> &YILType {
        self._type
    }

    impl Packable {
        pub over packName (self, ref dmut out : [u8]) {
            let code = match self {
                YILArrayAccessValue () => { "v1" }
                YILAddrValue ()        => { "v2" }
                YILArrayValue ()       => { "v3" }
                YILBeginCatch ()       => { "v4" }
                YILBinaryValue ()      => { "v5" }
                YILCastValue ()        => { "v6" }
                YILFieldValue ()       => { "v7" }
                YILFloatValue ()       => { "v8" }
                YILIntValue ()         => { "v9" }
                YILNameCallValue ()    => { "v10" }
                YILPtrCallValue ()     => { "v11" }
                YILStringValue ()      => { "v12" }
                YILTupleValue ()       => { "v13" }
                YILUnaryValue ()       => { "v14" }
                YILUnit ()             => { "v15" }
                YILUnrefValue ()       => { "v16" }
                YILVar ()              => { "v17" }
                _                      => { "v0" }
            };

            packet::pack (code, ref out);
        }
    }

}
