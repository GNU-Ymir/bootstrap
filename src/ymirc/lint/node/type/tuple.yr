in tuple;

use ymirc::lexing::word;
use ymirc::utils::format;
use std::{io, conv, stream};

lazy dmut __TUPLE_CHECKER__ : [usize => ()] = copy [];

/**
 * A Ymir Intermediate Language pointer reference
 * */
@final
pub class YILTuple over YILType {

    // The type inside the pointer
    let mut _inners : [&YILType];

    // The name of the fiels (@warning: .len <= _inners.len)
    let mut _fieldNames : [[c8]];

    // When the tuple is created from empty (so its uid overrides every other checks)
    let _prepared : bool = false;

    // True if the type is an union type
    let _isUnion : bool;

    // True if the type is packed
    let _isPacked : bool;

    pub self (inners : [&YILType], fieldNames : [[c8]] = [], isUnion : bool = false, isPacked : bool = false, uid : usize, prepared : bool = false)
        with super (uid-> uid)
        , _inners = inners
        , _fieldNames = fieldNames
        , _isUnion = isUnion
        , _isPacked = isPacked
        , _prepared = prepared
    {}

    pub self empty (isUnion : bool = false, isPacked : bool = false, uid : usize)
        with super (uid-> uid)
        , _inners = []
        , _fieldNames = []
        , _isUnion = isUnion
        , _isPacked = isPacked
        , _prepared = true
    {}

    /*!
     * ================================================================================
     * ================================================================================
     * =========================           GETTERS            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * @returns: the inner types of the tuple
     * */
    pub fn getInners (self)-> [&YILType] {
        self._inners
    }

    /**
     * @returns: the name of the fields
     * @warning: .len <= self.getInners ().len
     * */
    pub fn getFieldNames (self)-> [[c8]] {
        self._fieldNames
    }

    /**
     * @returns: the size in bytes of the type
     * */
    pub over getSize (self)-> u32 {
        if (self._isUnion) return self.getSizeUnion ();
        if (self._isPacked) return self.getSizePacked ();

        let mut current = 0u32;
        let mut glob = 0u32;
        let mut globAlign = 1u32;

        for inner in self._inners {
            let innerSize = inner.getSize ();
            let align = inner.getAlign ();

            if (align > globAlign) { globAlign = align; }

            let padding = (align - (current % align)) % align;
            let aligned = (current + padding);

            current = aligned + innerSize;
            glob += padding + innerSize;
        }

        if (glob % globAlign != 0u32) {
            glob = glob + (globAlign - (glob % globAlign));
        }

        glob
    }

    pub over getAlign (self)-> u32 {
        if (self._isPacked) { return 1u32 };

        let mut max = 1u32;
        for i in self._inners {
            let align = i.getAlign ();
            if (align > max) { max = align; }
        }

        max
    }

    pub fn isUnion (self)-> bool {
        self._isUnion
    }

    pub fn isPacked (self)-> bool {
        self._isPacked
    }


    fn getSizeUnion (self)-> u32 {
        let mut max = 1u32;
        for i in self._inners {
            let size = i.getSize ();
            if (size > max) { max = size; }
        }

        max
    }

    fn getSizePacked (self)-> u32 {
        let mut all = 0u32;
        for i in self._inners {
            all += i.getSize ();
        }

        if (all == 0u32) { 1u32 }
        else {
            all
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          SETTERS          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Set the inner field and field names of the tuple
     * */
    pub fn setInners (mut self, inners : [&YILType], fieldNames : [[c8]]) {
        self._inners = inners;
        self._fieldNames = fieldNames;
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================          COMPARISON          =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Compare two nodes
     * @returns: true, iif the two nodes are strictly identical
     */
    pub over opEquals (self, o : &YILNode)-> bool {
        match o {
            v : &YILTuple => {
                if self._prepared { return self._uid == v._uid; }

                let selfIn = (self._uid in __TUPLE_CHECKER__);
                let oIn = (v._uid in __TUPLE_CHECKER__);

                if selfIn && oIn { return true; }
                if !selfIn && !oIn {
                    __TUPLE_CHECKER__ [self._uid] = ();
                    __TUPLE_CHECKER__ [v._uid] = ();

                    {
                        if self._fieldNames != v._fieldNames { return false; }
                        if self._inners != v._inners { return false; }
                    } exit {
                        __TUPLE_CHECKER__:.remove (self._uid);
                        __TUPLE_CHECKER__:.remove (v._uid);
                    }
                }

                true
            }
            _ => { false }
        }
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================        MISCELLANEOUS         =========================
     * ================================================================================
     * ================================================================================
     */

    impl Hashable {
        pub over toHash (self)-> u64 {
            if self._prepared { return cast!u64 (self._uid); }

            if self._uid !in __TUPLE_CHECKER__ {
                __TUPLE_CHECKER__ [self._uid] = ();
                let result = core::types::hash::__hash ((self._inners, self._fieldNames, self._isPacked, self._isUnion));
                __TUPLE_CHECKER__:.remove (self._uid);

                result
            } else {
                core::types::hash::__hash ((self._fieldNames, self._isPacked, self._isUnion))
            }
        }
    }


    impl Streamable;
    impl Formattable {
        pub over format (self, dmut stream : &Formatter) {
            if stream.tags.withParams {
                stream:.write ("tuple T_", self._uid);
                if self._uid !in __TUPLE_CHECKER__ {
                    __TUPLE_CHECKER__ [self._uid] = ();
                    {
                        stream:.write (" (");
                        if (self._isUnion) stream:.write ("@union");
                        else if (self._isPacked) stream:.write ("@packed");

                        for i, ti in self._inners {
                            if (i != 0us || self._isUnion || self._isPacked) stream:.write (", ");
                            if (self._fieldNames.len > i) {
                                stream:.write (self._fieldNames [i], "-> ");
                            }
                            stream:.write (format ("%", ti)); // do not print parameters of inner types
                        }

                        stream:.write (')');
                    } exit {
                        __TUPLE_CHECKER__:.remove (self._uid);
                    }
                } else stream:.write ("...");
            }  else {
                stream:.write ("T_", self._uid);
            }
        }
    }

}
