in int;

use ymirc::lexing::word;
use ymirc::utils::format;
use std::{io, conv, stream};

use ymirc::global::state;

pub lazy YIL_SINT_8  = copy YILInt (true, 8u32);
pub lazy YIL_SINT_16 = copy YILInt (true, 16u32);
pub lazy YIL_SINT_32 = copy YILInt (true, 32u32);
pub lazy YIL_SINT_64 = copy YILInt (true, 64u32);

pub lazy YIL_UINT_8  = copy YILInt (false, 8u32);
pub lazy YIL_UINT_16 = copy YILInt (false, 16u32);
pub lazy YIL_UINT_32 = copy YILInt (false, 32u32);
pub lazy YIL_UINT_64 = copy YILInt (false, 64u32);

pub lazy YIL_UINT_MAX = copy YILInt (false, 0u32);
pub lazy YIL_SINT_MAX = copy YILInt (true, 0u32);

/**
 * A Ymir Intermediate Language int reference
 * */
@final
pub class YILInt over YILType {

    // The size of the int in bit
    let _size : u32;

    // True if the type is signed
    let _signed : bool;

    pub self (signed : bool, size : u32)
        with _size = size
        , _signed = signed
    {}

    /*!
     * ================================================================================
     * ================================================================================
     * =========================           GETTERS            =========================
     * ================================================================================
     * ================================================================================
     */

    pub over getSize (self)-> u32 {
        if (self._size == 0u32) {
            state::instance ().getSizeTypeSize () / 8u32
        } else {
            self._size / 8u32
        }
    }

    pub over getAlign (self)-> u32 {
        if self._size == 0u32 {
            state::instance ().getSizeTypeSize () / 8u32
        } else {
            self._size / 8u32
        }
    }


    /**
     * @returns: the code size of the int (before conversion to arch size)
     * */
    pub fn getCodeSize (self)-> u32 {
        self._size
    }

    pub fn isSigned (self)-> bool {
        self._signed
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================          COMPARISON          =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Compare two nodes
     * @returns: true, iif the two nodes are strictly identical
     */
    pub over opEquals (self, o : &YILNode)-> bool {
        match o {
            i : &YILInt => {
                self._size == i._size && self._signed == i._signed
            }
            _ => { false }
        }
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================        MISCELLANEOUS         =========================
     * ================================================================================
     * ================================================================================
     */

    impl Hashable;
    impl Streamable;
    impl Formattable {
        pub over format (self, dmut stream : &Formatter) {
            if (self._signed) {
                stream:.write ("i", self.getSize () * 8u32);
            } else {
                stream:.write ("u", self.getSize () * 8u32);
            }

        }
    }

}
