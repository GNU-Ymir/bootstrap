in stmtlist;


use ymirc::lint::node::instr;
use ymirc::lint::node::instr::vardecl;

use ymirc::utils::format;



/**
 * A statement list is a vector of instruction
 * It sorts the instruction per types, putting the var declaration at the beginning
 * And obviously conserving the order of al the other instructions
 * */
pub record StmtList {

    let mut _list : [mut &YILInstr] = [];

    let mut _decls : [mut &YILInstr] = [];

    let mut _setToDestroy : [usize => mut &YILInstr] = copy [];

    let mut _toDestroy : [usize => mut (&YILInstr, bool)] = copy [];

    /**
     * Empty statement list
     * */
    pub self () {}

    /**
     * Append all the instruction in a list of statement to the current list
     * */
    pub fn append (mut self, v : StmtList) {
        for il in v[] {
            self:.append (il);
        }
    }

    /**
     * Append an instruction to the list of statement
     * */
    pub fn append (mut self, v : &YILInstr) {
        match v {
            var : &YILVarDecl => {
                self._decls ~= [var];
            }
            _ => {
                self._list ~= [v];
            }
        }
    }

    /**
     * Append a list of instruction to the list
     * */
    pub fn append (mut self, v : [&YILInstr]) {
        for il in v {
            self:.append (il);
        }
    }

    /**
     * Insert a variable containing an entity value that needs to be destroyed at the end of the block
     * */
    pub fn registerDestroy (mut self, id : usize, v : &YILInstr, setting : (&YILInstr)?, implicit : bool) {
        self._toDestroy [id] = (v, implicit);

        if let Ok (s) = setting {
            self._setToDestroy [id] = s;
        }
    }

    /**
     * Remove a var that was inserted to be destroyed
     * */
    pub fn removeDestroyNotImplicit (mut self, id : usize) {
        if let Ok ((_, _ = true)) = self._toDestroy [id]  {
            self._toDestroy:.remove (id);
            self._setToDestroy:.remove (id);
        }
    }

    /**
     * @returns: true if the list is already destroying the value uid
     * */
    pub fn hasToDestroy (self, uid : usize)-> bool {
        uid in self._toDestroy
    }

    /**
     * @returns: true if values need to be destroyed
     * */
    pub fn hasDestroy (self)-> bool {
        self._toDestroy.len != 0us
    }

    /**
     * @returns: the list of instruction to destroy variable
     * */
    pub fn getToDestroy (self)-> [&YILInstr] {
        return copy [v.0 for _, v in self._toDestroy];
    }

    /**
     * @returns: the list of ids of the variables to destroy
     * */
    pub fn getToDestroyVars (self)-> [usize] {
        return copy [i for i, _ in self._toDestroy];
    }

    /**
     * @returns: the list of instruction setting the default values of destroyable variables
     * */
    pub fn getSetToDestroy (self)-> [&YILInstr] {
        return copy [v for _, v in self._setToDestroy];
    }

    /**
     * @returns: all the instruction in the list (placing vardecls on top)
     * */
    pub fn opIndex (self)-> [&YILInstr] {
        self._decls ~ self.getSetToDestroy () ~ self._list
    }

    /**
     * @returns: the length of the statement list
     * */
    @field
    pub fn len (self)-> usize {
        self._list.len  + self._decls.len
    }

}
