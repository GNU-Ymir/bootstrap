in visitor;

use ymirc::lint::expander::{value, type, stmtlist};
use ymirc::lint::node::{_, instr::_, global::_, type::_, value::_};

use std::{io, fs::path, algorithm::sorting};

use ymirc::utils::{format, list};
use ymirc::semantic::{symbol::path, generator::_};
use ymirc::semantic::generator::type::{_,
                                       custom::_,
                                       native::{_, scalar::_, compound::_},
                                       temporary::_};

use ymirc::semantic::generator::value::{_,
                                        construct::{_, delegate::_},
                                        literal::_,
                                        memory::_,
                                        operator::{_, binary::_, call::_, fields::_, map::_, slice::_, unary::_},
                                        prototypes::_,
                                        scope::_,
                                        syntax::_,
                                        template::_};

use ymirc::global::{core_, state};
use ymirc::syntax::keys;

use ymirc::lexing::word;

class Touching {
    pub let mut content : [[c8] => mut Path] = copy [];
    pub self () {}
}

class DeclaredVars {
    pub let mut content : [usize => mut &YILValue] = copy [];
    pub self () {}
}

class LazyRefs {
    pub let mut content : [usize => mut &YILVar] = copy [];
    pub self () {}
}


/**
 * The expander class simplifies previously validated symbols
 */
pub class Expander {

    /*!
     * =====================================================================================
     * =====================================================================================
     * =========================         GLOBAL GENERATORS         =========================
     * =====================================================================================
     * =====================================================================================
     */

    // The list of generators provided by the previous pass (validation)
    let mut _generators : [&Generator] = [];

    // The list of symbols created during finalization
    let mut _symbols : [[c8] => mut &YILSymbol] = copy [];

    // The list of weak symbols created during finalization
    let mut _weakSymbols : [[c8] => mut &YILSymbol] = copy [];

    // The stmt list to execute in main function to register unit tests, when the -funittest is activated
    let mut _expUnitTest : [mut (&Word, [c8], [c8])] = [];

    /*!
     * =====================================================================================
     * =====================================================================================
     * ====================         FINALIZER AND MISC VISITORS         ====================
     * =====================================================================================
     * =====================================================================================
     */

    // The mangler used to mangle symbol names
    let _mangler = Mangler ();

    // The expander responsible for value expansions
    let mut _valueExpander : ValueExpander; // = ValueExpander ();

    // The expander responsible for value expansions
    let dmut _typeExpander : &TypeExpander; // = TypeExpander ();

    /*!
     * =====================================================================================
     * =====================================================================================
     * =======================         CONTEXT FINALIZATION         ========================
     * =====================================================================================
     * =====================================================================================
     */

    // The name of the frame being validated
    let dmut _frameName = copy List!{[c8]} ();

    // The list of symbols touched by the current symbol
    let dmut _touchings = copy List!{dmut &Touching} ();

    // The current scope variable declarations
    let dmut _variables = copy List!{dmut &DeclaredVars} ();

    // The current scope lazy references declarations
    let dmut _lazyRefs = copy List!{dmut &LazyRefs} ();

    // The current uniq id for variables in the current frame
    let dmut _varUniqId = copy List!{usize} ();

    // The current uniq id for labels in the current frame
    let dmut _lblUniqId = copy List!{usize} ();

    // The var in which to put the result of loops (when breaking)
    let dmut _loopVar = copy List!{&YILValue} ();

    // The label to exit the loop
    let dmut _loopLabel = copy List!{&YILLabel} ();

    // The list of classes already validated
    let mut _classValidated : [[c8] => mut &YILType] = copy [];

    // The list of class currently in validation
    let mut _inClassValidation : [[c8] => mut ()] = copy [];

    // Global string stored in the text segment
    let mut _strConsts : [[c8] => mut &YILValue] = copy [];


    /*!
     * =====================================================================================
     * =====================================================================================
     * ==============================         CTORS         ================================
     * =====================================================================================
     * =====================================================================================
     */

    /**
     * Create a new empty expander
     * */
    pub self ()
        with _valueExpander = ValueExpander ()
        , _typeExpander = copy TypeExpander ()
    {}

    /**
     * Expande a list of generators
     * */
    pub fn finalize (mut self, generators : [&Generator])-> [&YILSymbol] {
        self._generators = generators;
        for gen in self._generators {
            self:.finalize (gen);
        }

        if (state::instance ().isUnittestActive ()) {
            self:.finalizeUnitTestRegistrationFrame ();
            self:.finalizeUnitTestCall ();
        }

        self:.traverseSymbolGraph ()
    }

    /**
     * @returns: the list of tuples defined during expansion
     * */
    pub fn getTuples (self)-> [&YILTuple] {
        self._typeExpander.getTuples ()
    }

    /**
     * Expande a generator
     * */
    pub fn finalize (mut self, gen : &Generator) {
        match gen {
            frame : &FrameGenerator => {
                self:.finalizeFrame (frame);
            }
            cl : &ClassRefType => {
                self:.finalizeClass (cl);
            }
            m : &MapInfoGenerator => {
                self:.finalizeMapInfo (m);
            }
            u : &UnitTestGenerator => {
                self:.finalizeUnitTest (u);
            }
            g : &GlobalVarGenerator => {
                self:.finalizeGlobalVar (g);
            }
            _ => {
                panic;
            }
        }
    }


    /**
     * Traverse the list of finalized symbols and returned the symbols that are either non weak or touched by a non weak symbol
     * */
    pub fn traverseSymbolGraph (mut self) -> [&YILSymbol] {
        let mut consts : [mut &YILSymbol] = [];
        let mut vars : [mut &YILSymbol] = [];
        let mut frames : [mut &YILSymbol] = [];

        while self._symbols.len > 0us {
            let mut syms : [mut &YILSymbol] = [];
            for _, j in self._symbols { syms ~= [j]; }
            self._symbols = copy [];

            for i in syms {
                for t in i.getReferences () if let Ok (n : &YILSymbol) = self._weakSymbols [t] {
                    self._symbols [t] = n;
                    self._weakSymbols:.remove (t);
                }

                match i {
                    YILFrame () => { frames ~= [i]; }
                    YILConstant () => { consts ~= [i]; }
                    YILGlobalVar () => { vars ~= [i]; }
                    _ => panic;
                }
            }
        }

        let csts = sort (alias consts, |a, b| => {
            a.getName () < b.getName ()
        });

        let frs = sort (alias frames, |a, b| => {
            a.getName () < b.getName ()
        });

        let vrs = sort (alias vars, |a, b| => {
            a.getName () < b.getName ()
        });

        csts ~ vrs ~ frs
    }


    /*!
     * =====================================================================================
     * =====================================================================================
     * =========================          FRAME EXPANSION          =========================
     * =====================================================================================
     * =====================================================================================
     */

    /**
     * Expande a frame generator
     * @params:
     *    - frame: the frame to expande
     * */
    pub fn finalizeFrame (mut self, frame : &FrameGenerator) {
        let mut list = StmtList ();

        self:.enterSymbol ();
        self:.enterFrame (frame.getName ().toStr ());
        self:.enterBlock ();

        let mut parameters : [&YILVarDecl] = [];
        for p in frame.getParameters () {
            let varId = self:.generateVarId ();
            let mut type = self:.finalizeType (p.getType ());
            if (p.isLazy ()) {
                let lazyType = self._typeExpander:.finalizeLazy ();

                let decl = copy YILVarDecl (p.getLoc (), p.getLoc ().str, lazyType, varId);
                let varref = copy YILVar (p.getLoc (), p.getLoc ().str, lazyType, varId);
                parameters ~= [decl];

                let addr = copy YILAddrValue (p.getLoc (), copy YILPointer (lazyType), varref);
                self:.registerLazyRef (p.getUniqId (), varref);
                self:.registerVariable (p.getUniqId (),
                                        copy YILNameCallValue (p.getLoc (),
                                                               copy YILPointer (type),
                                                               YRuntimeFuncs::CALL_LAZY, copy [addr]));
            } else {
                let vref = copy YILVar (p.getLoc (), p.getLoc ().str, type, varId);
                let (finVref, finType) = if (p.isReference ()) {
                    (copy YILUnrefValue (p.getLoc (), type, vref),
                     copy YILPointer (type))
                } else if (p.getType ().isMovable ()) {
                    self._valueExpander.registerDestroy (alias self, vref, p.getType (), ref list, implicit-> false);
                    (vref, type)
                } else {
                    (vref, type)
                };

                parameters ~= [copy YILVarDecl (p.getLoc (), p.getLoc ().str, finType, varId)];
                self:.registerVariable (p.getUniqId (), finVref);
            }
        }


        let _ = self:.finalizeValue (frame.getBody (), ref list);

        let body = if (list.hasDestroy ()) {
            let b = frame.getBody ();
            if (b.isReturner () || b.isBreaker () || b.getThrowers ().len != 0us) {
                copy YILTryFinally (b.getLoc (), list[], list.getToDestroy ())
            } else {
                list:.append (list.getToDestroy ());
                copy YILBlock (frame.getLoc (), list[])
            }
        } else {
            copy YILBlock (frame.getLoc (), list[])
        };

        self:.exitBlock ();
        self:.exitFrame ();
        let touching = self:.exitSymbol ();

        let name = self._mangler.mangle (frame);
        let final = copy YILFrame (frame.getLoc (),
                                   name,
                                   parameters,
                                   self:.finalizeType (frame.getReturnType ()),
                                   body-> body,
                                   isWeak-> frame.isWeak (),
                                   refs-> touching);

        if (frame.isWeak ()) {
            self._weakSymbols [name] = final;
        } else {
            self._symbols [name] = final;
        }

        if (!frame.isWeak () && !state::instance ().isUnittestActive () && frame.getName ().asStdPath ().file () == Keys::MAIN) {
            self:.finalizeMainCall (frame.getLoc (), name, (frame.getReturnType () of VoidType));
        }
    }

    /**
     * Generate the frame of the "main" function that calls the actual program main func
     * */
    fn finalizeMainCall (mut self, loc : &Word, name : [c8], isVoid : bool) {
        let mut list = StmtList ();

        self:.enterSymbol ();
        self:.enterFrame (name);
        self:.enterBlock ();

        let argsT = copy [YIL_UINT_32, YIL_PTR_VOID];
        let argIds = copy [self:.generateVarId (), self:.generateVarId ()];

        let argcDecl = copy YILVarDecl (EOF_WORD, "argc", argsT [0], argIds [0]);
        let argvDecl = copy YILVarDecl (EOF_WORD, "argv", argsT [1], argIds [1]);

        let argcRef = copy YILVar (EOF_WORD, "argc", argsT [0], argIds [0]);
        let argvRef = copy YILVar (EOF_WORD, "argc", argsT [1], argIds [1]);

        let moduleFuncMain = copy YILAddrValue (EOF_WORD, YIL_PTR_VOID, copy YILVar (EOF_WORD, name, YIL_VOID, 0us));
        let runMain = if (state::instance ().isDebugActive ()) {
            YRuntimeFuncs::RUN_MAIN_DEBUG
        } else {
            YRuntimeFuncs::RUN_MAIN_RELEASE
        };

        let call = copy YILNameCallValue (EOF_WORD,
                                          YIL_SINT_32,
                                          runMain, copy [argcRef, argvRef, moduleFuncMain]);

        if (isVoid) {
            list:.append (copy YILCall (EOF_WORD, call));
            list:.append (copy YILReturn (EOF_WORD, copy YILIntValue (EOF_WORD, YIL_SINT_32, 0us)));
        } else {
            list:.append (copy YILReturn (EOF_WORD, call));
        }

        self:.registerTouchSym (name, loc);
        self:.exitBlock ();
        self:.exitFrame ();
        let touching = self:.exitSymbol ();

        let final = copy YILFrame (loc,
                                   Keys::MAIN,
                                   copy [argcDecl, argvDecl],
                                   YIL_SINT_32,
                                   body-> copy YILBlock (EOF_WORD, list[]),
                                   isWeak-> false,
                                   refs-> touching);

        self._symbols [Keys::MAIN] = final;
    }

    /*!
     * =====================================================================================
     * =====================================================================================
     * ========================          UNIT TEST EXPANSION          ======================
     * =====================================================================================
     * =====================================================================================
     */

    /**
     * Finalize a unit test
     * */
    fn finalizeUnitTest (mut self, u : &UnitTestGenerator) {
        if (state::instance ().isUnittestActive ()) {
            self:.enterSymbol ();
            self:.enterFrame (u.getName ().toStr ());
            self:.enterBlock ();

            let mut list = StmtList ();
            let _ = self:.finalizeValue (u.getValue (), ref list);

            self:.exitBlock ();
            self:.exitFrame ();
            let touchings = self:.exitSymbol ();

            let name = self._mangler.mangle (u);
            let final = copy YILFrame (u.getLoc (),
                                       name,
                                       [],
                                       YIL_VOID,
                                       body-> copy YILBlock (u.getLoc (), list[]),
                                       isWeak-> false,
                                       refs-> touchings);

            self._symbols [name] = final;
            self._expUnitTest ~= [(u.getLoc (), u.getName ().toStr (), name)];
        }
    }

    /**
     * Finalize the package ctor that registers the unittests
     * */
    fn finalizeUnitTestRegistrationFrame (mut self) {
        self:.enterSymbol ();
        self:.enterFrame ("");
        self:.enterBlock ();

        let mut list = StmtList ();
        for i in 0us .. self._expUnitTest.len {
            let (loc, name, mangledName) = self._expUnitTest [i];
            self._valueExpander.finalizeRegisterUnitTest (alias self, name, mangledName, loc, ref list);
        }

        self:.exitBlock ();
        self:.exitFrame ();
        let touchings = self:.exitSymbol ();

        let final = copy YILFrame (EOF_WORD,
                                   Keys::UNIT_TEST_REGISTER,
                                   [],
                                   YIL_VOID,
                                   body-> copy YILBlock (EOF_WORD, list[]),
                                   isGlobalCtor-> true,
                                   refs-> touchings);

        self._symbols [Keys::UNIT_TEST_REGISTER] = final;
    }

    /**
     * Finalize the main function that calls the unittests
     * */
    fn finalizeUnitTestCall (mut self) {
        self:.enterSymbol ();
        self:.enterFrame ("");
        self:.enterBlock ();

        let argsT = copy [YIL_UINT_32, YIL_PTR_VOID];
        let argIds = copy [self:.generateVarId (), self:.generateVarId ()];

        let argcDecl = copy YILVarDecl (EOF_WORD, "argc", argsT [0], argIds [0]);
        let argvDecl = copy YILVarDecl (EOF_WORD, "argv", argsT [1], argIds [1]);

        let argcRef = copy YILVar (EOF_WORD, "argc", argsT [0], argIds [0]);
        let argvRef = copy YILVar (EOF_WORD, "argc", argsT [1], argIds [1]);

        let mut list = StmtList ();
        let call = copy YILNameCallValue (EOF_WORD,
                                          YIL_SINT_32,
                                          YRuntimeFuncs::RUN_UNITTESTS, copy [argcRef, argvRef]);

        list:.append (copy YILReturn (EOF_WORD, call));
        self:.exitBlock ();
        self:.exitFrame ();
        let touchings = self:.exitSymbol ();

        let final = copy YILFrame (EOF_WORD,
                                   Keys::MAIN,
                                   copy [argcDecl, argvDecl],
                                   YIL_SINT_32,
                                   body-> copy YILBlock (EOF_WORD, list[]),
                                   isWeak-> true,
                                   refs-> touchings);

        self._symbols [Keys::MAIN] = final;
    }

    /*!
     * =====================================================================================
     * =====================================================================================
     * =========================          CLASS EXPANSION          =========================
     * =====================================================================================
     * =====================================================================================
     */

    /**
     * Finalize a class reference type (vtable, and typeinfo)
     * */
    pub fn finalizeClass (mut self, cl : &ClassRefType) {
        if (!cl.getSymbol ().isStruct () && !cl.getSymbol ().isAbstract ()) {
            // abstract classes and structures don't have vtable
            // abstract because some of their methods are empty
            // and structures because their methods are not virtual
            //

            self:.enterSymbol ();
            let vtableValue = self:.finalizeClassVtable (cl);
            let vtableName = self._mangler.mangleVtable (cl);
            let touchings = self:.exitSymbol ();

            // Const VTABLE
            let cst = copy YILConstant (cl.getLoc (),
                                        vtableName,
                                        vtableValue,
                                        isWeak-> cl.getSymbol ().isWeak (),
                                        refs-> touchings);

            if (cl.getSymbol ().isWeak ()) {
                self._weakSymbols [vtableName] = cst;
            } else {
                self._symbols [vtableName] = cst;
            }
        }

        self:.enterSymbol ();
        let typeinfoValue = self:.finalizeClassTypeInfo (cl);
        let tiName = self._mangler.mangleTypeInfo (cl);
        let touchings = self:.exitSymbol ();

        // Const TYPEINFO
        let cst = copy YILConstant (cl.getLoc (),
                                    tiName,
                                    typeinfoValue,
                                    isWeak-> cl.getSymbol ().isWeak (),
                                    refs-> touchings);

        if (cl.getSymbol ().isWeak ()) {
            self._weakSymbols [tiName] = cst;
        } else {
            self._symbols [tiName] = cst;
        }
    }

    /**
     * Finalize the typeinfo value of a class type, to write it in the text as a global variable
     * */
    pub fn finalizeClassTypeInfo (mut self, cl : &ClassRefType)-> &YILValue {
        let mut list = StmtList ();

        let slcType = {
            self:.finalizeType (copy SliceType (cl.getLoc (), VOID_TYPE))
        } catch {
            _ => panic;
        };

        let ancestorSlice = match cl.getAncestor () {
            anc : &ClassRefType => {
                let ancTIN = self._mangler.mangleTypeInfo (anc);
                self:.registerTouchSym (ancTIN, anc.getLoc ());

                let ancTIV = copy YILAddrValue (cl.getLoc (), YIL_PTR_VOID,
                                                copy YILVar (cl.getLoc (), ancTIN, YIL_PTR_VOID, 0us));

                let len = copy YILIntValue (cl.getLoc (), YIL_UINT_MAX, 1us);
                copy YILTupleValue (cl.getLoc (), slcType, copy [len, ancTIV, YIL_NULL_VALUE],
                                    fieldNames-> copy [SliceKeys::LEN, SliceKeys::PTR, SliceKeys::BLK_INFO])
            }
            _ => {
                copy YILTupleValue (cl.getLoc (), slcType,
                                    copy [copy YILIntValue (cl.getLoc (), YIL_UINT_MAX, 0us), YIL_NULL_VALUE, YIL_NULL_VALUE],
                                    fieldNames-> copy [SliceKeys::LEN, SliceKeys::PTR, SliceKeys::BLK_INFO])
            }
        };

        let ti = cl.getTypeInfo ().asOf!{&TypeInfoValue} ();
        let id = self:.finalizeValue (ti.getId (), ref list);
        let size = self:.finalizeValue (ti.getSize (), ref list);
        let name = self:.finalizeValue (ti.getName (), ref list);
        let type = self:.finalizeType (ti.getType ());
        let fields = if let t : &YILTuple = type {
            t.getFieldNames ()
        } else panic;

        // Dynamic objects in the typeinfo
        if (list.len != 0us) panic;

        copy YILTupleValue (cl.getLoc (), type,
                            copy [id, size, ancestorSlice, name],
                            fieldNames-> fields)
    }

    /**
     * Finalize the vtable value of a class to write it in the text as a global variable
     * */
    pub fn finalizeClassVtable (mut self, cl : &ClassRefType)-> &YILValue {
        let len = cl.getVtable ().len + 2us; // TI, Dtor, vtable

        let resultType = copy YILArray (YIL_PTR_VOID, len);
        let mut params : [&YILValue] = [];

        let TIN = self._mangler.mangleTypeInfo (cl);
        self:.registerTouchSym (TIN, cl.getLoc ());

        let TIV = copy YILAddrValue (cl.getLoc (), YIL_PTR_VOID, copy YILVar (cl.getLoc (), TIN, YIL_PTR_VOID, 0us));
        params ~= [TIV];


        match cl.getDestructor () {
            UnitValue () => {
                params ~= [YIL_NULL_VALUE];
            }
            p : &PrototypeValue => {
                let name = self._mangler.mangle (p);
                self:.registerTouchSym (name, cl.getLoc ());

                let addr = copy YILAddrValue (p.getLoc (), YIL_PTR_VOID, copy YILVar (p.getLoc (), name, YIL_VOID, 0us));
                params ~= [addr];
            }
            _ => panic;
        };

        for mt in cl.getVtable () {
            let name = self._mangler.mangle (mt);
            self:.registerTouchSym (name, mt.getLoc ());

            let addr = copy YILAddrValue (mt.getLoc (), YIL_PTR_VOID, copy YILVar (mt.getLoc (), name, YIL_VOID, 0us));
            params ~= [addr];
        }

        copy YILArrayValue (cl.getLoc (), resultType, params)
    }


    /*!
     * =====================================================================================
     * =====================================================================================
     * =======================          GLOBAL VAR EXPANSION          ======================
     * =====================================================================================
     * =====================================================================================
     */

    /**
     * Finalize a global variable
     * */
    pub fn finalizeGlobalVar (mut self, gv : &GlobalVarGenerator) {
        let mut list = StmtList ();
        self:.enterSymbol ();
        let value = self._valueExpander.finalizeLazy (alias self, gv.getValue ().asOf!{&LazyValue} (), ref list);
        let touchings = self:.exitSymbol ();

        let name = self._mangler.mangleGlobalVar (gv);
        let glb = copy YILGlobalVar (gv.getLoc (), name, value,
                                     isWeak-> gv.isWeak (),
                                     isThreadLocal-> gv.isThreadLocal (),
                                     touchings);

        if (gv.isWeak ()) {
            self._weakSymbols [name] = glb;
        } else {
            self._symbols [name] = glb;
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===============================          MAP INFO EXPANSION          ===============================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Finalize a map information
     * @params:
     *    - m: the map info to finalize
     * */
    pub fn finalizeMapInfo (mut self, m : &MapInfoGenerator) {
        self:.enterSymbol ();

        let cmpName = self._mangler.mangle (m.getCmpFunc ());
        let hashName = self._mangler.mangle (m.getHashFunc ());
        self:.registerTouchSym (cmpName, m.getLoc ());
        self:.registerTouchSym (hashName, m.getLoc ());

        let name = self._mangler.mangleMapInfo (m.getMapType ());
        let cmpFunc = copy YILAddrValue (m.getLoc (), YIL_PTR_VOID, copy YILVar (m.getLoc (), cmpName, YIL_VOID, 0us));
        let hashFunc = copy YILAddrValue (m.getLoc (), YIL_PTR_VOID, copy YILVar (m.getLoc (), hashName, YIL_VOID, 0us));
        let keyT = self:.finalizeType (m.getMapType ().getInners ()[0]);
        let valT = self:.finalizeType (m.getMapType ().getInners ()[1]);
        let keySize = copy YILIntValue (m.getLoc (), YIL_UINT_MAX, keyT.getSize ());
        let valSize = copy YILIntValue (m.getLoc (), YIL_UINT_MAX, valT.getSize ());

        let tuType = copy YILTuple (copy [YIL_PTR_VOID, YIL_PTR_VOID, YIL_UINT_MAX, YIL_UINT_MAX]);
        let tuValue = copy YILTupleValue (m.getLoc (), tuType, copy [cmpFunc, hashFunc, keySize, valSize]);

        let touchings = self:.exitSymbol ();

        let cst = copy YILConstant (m.getLoc (),
                                    name,
                                    tuValue,
                                    isWeak-> true,
                                    refs-> touchings);

        self._weakSymbols [name] = cst;
    }

    /*!
     * =====================================================================================
     * =====================================================================================
     * ======================          TYPE/VALUE EXPANSION          =======================
     * =====================================================================================
     * =====================================================================================
     */

    /**
     * Finalize a value
     * @params:
     *    - value: the value to finalize
     * */
    pub fn finalizeValue (mut self, val : &Value, ref mut list : StmtList)-> &YILValue {
        self._valueExpander.finalize (alias self, val, ref list)
    }

    /**
     * Finalize a type
     * @params:
     *    - ty: the type to finalize
     * */
    pub fn finalizeType (mut self, ty : &Type)-> &YILType {
        self._typeExpander:.finalize (alias self, ty)
    }

    /*!
     * =====================================================================================
     * =====================================================================================
     * =========================              GETTERS              =========================
     * =====================================================================================
     * =====================================================================================
     */

    /**
     * @returns: the mangler used to mangle symbol names
     * */
    pub fn getMangler (self)-> Mangler {
        self._mangler
    }

    /**
     * @returns: the expander used to finalize types
     * */
    pub fn getTypeExpander (mut self)-> dmut &TypeExpander {
        alias self._typeExpander
    }

    /*!
     * =====================================================================================
     * =====================================================================================
     * =========================              CONTEXT              =========================
     * =====================================================================================
     * =====================================================================================
     */

    /**
     * @returns: the declaration of the variable containing the value of the current loop
     * */
    pub fn getLoopVarRef (self)-> &YILValue {
        self._loopVar.back ()
    }

    /**
     * @returns: the label exiting the current loop
     * */
    pub fn getLoopExitLabel (self)-> &YILLabel {
        self._loopLabel.back ()
    }

    /**
     * Enter a loop where varref is the value of the loop
     * */
    pub fn enterLoop (mut self, varref : &YILValue, lbl : &YILLabel) {
        self._loopVar:.push (varref);
        self._loopLabel:.push (lbl);
    }

    /**
     * Exit a loop context
     * */
    pub fn exitLoop (mut self) {
        self._loopVar:.pop ();
        self._loopLabel:.pop ();
    }

    /**
     * Enter a symbol definition
     * */
    fn enterSymbol (mut self) {
        self._touchings:.push (copy Touching ());
    }

    /**
     * Exit a symbol definitions
     * @returns: all the foreign symbols touched by it
     * */
    fn exitSymbol (mut self)-> [[c8] => Path] {
        let touchs = self._touchings.back ();
        self._touchings:.pop ();

        touchs.content
    }

    /**
     * Register the touch of a foreign symbol
     * */
    pub fn registerTouchSym (mut self, name : [c8], loc : &Word) {
        self._touchings:.back ().content [name] = Path (loc.filename).stripExtension ();
    }

    /**
     * Enter a new frame
     * @params:
     *     - name: the name of the frame (not mangled)
     * */
    fn enterFrame (mut self, name : [c8]) {
        self._frameName:.push (name);
        self._varUniqId:.push (1us); // first ID id 1, 0 means no ref
        self._lblUniqId:.push (1us);
    }

    /**
     * Exit the current frame
     * */
    fn exitFrame (mut self) {
        self._frameName:.pop ();
        self._varUniqId:.pop ();
        self._lblUniqId:.pop ();
    }

    /**
     * @returns: true if we are currently inside a frame
     * */
    pub fn isInAFrame (self)-> bool {
        self._varUniqId.len != 0us
    }

    /**
     * @returns: the name of the frame being validated
     * */
    pub fn getCurrentFrameName (self)-> [c8] {
        self._frameName.back ()
    }

    /**
     * Set the uniq ids of the current frame
     * */
    pub fn setUniqIds (mut self, varIds : usize, lblIds : usize) {
        self._varUniqId:.setBack (varIds);
        self._lblUniqId:.setBack (lblIds);
    }

    /**
     * Get the uniq ids of the current frame
     * */
    pub fn getUniqIds (mut self) -> (usize, usize) {
        (self._varUniqId.back (), self._lblUniqId.back ())
    }

    /**
     * @returns: the next uniq id for a variable in the current frame
     * */
    pub fn generateVarId (mut self)-> usize {
        let id = self._varUniqId.back ();
        self._varUniqId:.setBack (id + 1);
        id
    }

    /**
     * @returns: the next uniq id for a variable in the current frame
     * */
    pub fn generateLblId (mut self)-> usize {
        let id = self._lblUniqId.back ();
        self._lblUniqId:.setBack (id + 1);
        id
    }

    /**
     * Enter a new scope of variables
     * */
    pub fn enterBlock (mut self) {
        self._variables:.push (copy DeclaredVars ());
        self._lazyRefs:.push (copy LazyRefs ());
    }

    /**
     * Exit a scope of variables
     * */
    pub fn exitBlock (mut self) {
        self._variables:.pop ();
        self._lazyRefs:.pop ();
    }

    /**
     * Register a variable declaration in the scope
     * @params:
     *    - old: the uniq id of the previous declaration
     *    - new: the uniq id of the new declaration
     * */
    pub fn registerVariable (mut self, old : usize, vref : &YILValue) {
        self._variables:.back ().content [old] = vref;
    }

    /**
     * Search the id of a variable declared in the current frame
     * @returns: the id, or None if the variable is not in the frame
     * */
    pub fn getVariable (self, old : usize)-> (&YILValue)? {
        for i in self._variables[] {
            if old in i.content {
                if let Ok (n : &YILValue) = i.content [old] {
                    return n?;
                } else panic;
            }
        }

        none
    }

    /**
     * Register a lazy variable reference by its id
     * */
    pub fn registerLazyRef (mut self, old : usize, vref : &YILVar) {
        self._lazyRefs:.back ().content [old] = vref;
    }

    /**
     * Search a lazy variable reference by its id
     * */
    pub fn getLazyRef (self, old : usize)-> (&YILVar)? {
        for i in self._lazyRefs[] {
            if old in i.content {
                if let Ok (n : &YILVar) = i.content [old] {
                    return n?;
                } else panic;
            }
        }

        none
    }

    /*!
     * =====================================================================================
     * =====================================================================================
     * =======================              TYPE CONTEXT              ======================
     * =====================================================================================
     * =====================================================================================
     */

    /**
     * Find the type of the class if already validated
     * */
    pub fn findClassValidation (self, cr : &ClassRefType)-> (&YILType)? {
        self._classValidated [cr.getSymbol ().getPath ().toStr ()]
    }

    /**
     * @returns: true if the class is being validated
     * */
    pub fn isInClassValidation (self, cr : &ClassRefType)-> bool {
        cr.getSymbol ().getPath ().toStr () in self._inClassValidation
    }

    /**
     * Start a finalization of a class type
     * */
    pub fn enterClassValidation (mut self, cr : &ClassRefType) {
        self._inClassValidation [cr.getSymbol ().getPath ().toStr ()] = ();
    }

    /**
     * Class finalized
     * */
    pub fn exitClassValidation (mut self, cr : &ClassRefType, res : &YILType) {
        self._inClassValidation:.remove (cr.getSymbol ().getPath ().toStr ());
        self._classValidated [cr.getSymbol ().getPath ().toStr ()] = res;
    }

}
