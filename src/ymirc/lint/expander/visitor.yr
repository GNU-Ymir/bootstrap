in visitor;

use ymirc::lint::expander::{value, type, stmtlist};
use ymirc::lint::node::{_, instr::_, global::_, type::_, value::_};

use std::{io, fs::path, algorithm::sorting};

use ymirc::utils::format;
use ymirc::semantic::{symbol::path, generator::_};
use ymirc::semantic::generator::type::{_,
                                       custom::_,
                                       native::{_, scalar::_, compound::_},
                                       temporary::_};

use ymirc::semantic::generator::value::{_,
                                        construct::{_, delegate::_},
                                        literal::_,
                                        memory::_,
                                        operator::{_, binary::_, call::_, fields::_, map::_, slice::_, unary::_},
                                        prototypes::_,
                                        scope::_,
                                        syntax::_,
                                        template::_};

use ymirc::global::{core_, state};
use ymirc::syntax::keys;

use ymirc::lexing::word;


/**
 * The expander class simplifies previously validated symbols
 */
pub class Expander {

    /*!
     * =====================================================================================
     * =====================================================================================
     * =========================         GLOBAL GENERATORS         =========================
     * =====================================================================================
     * =====================================================================================
     */

    // The list of generators provided by the previous pass (validation)
    let mut _generators : [mut &Generator] = [];

    // The list of symbols created during finalization
    let mut _symbols : [[c8] => mut &YILSymbol] = ();

    // The list of weak symbols created during finalization
    let mut _weakSymbols : [[c8] => mut &YILSymbol] = [];

    // The stmt list to execute in main function to register unit tests, when the -funittest is activated
    let mut _expUnitTest : [mut (&Word, [c8], [c8])] = [];

    /*!
     * =====================================================================================
     * =====================================================================================
     * ====================         FINALIZER AND MISC VISITORS         ====================
     * =====================================================================================
     * =====================================================================================
     */

    // The mangler used to mangle symbol names
    let _mangler = Mangler ();

    // // Compile time interpret used to simplify values
    // let dmut _cteInterpret = CompileTimeInterpreter::new (reduced-> HashMap!{usize, &Value}::new ());

    // // The expander responsible for value expansions
    let mut _valueExpander = ValueExpander ();

    // The expander responsible for value expansions
    let mut _typeExpander = TypeExpander ();

    /*!
     * =====================================================================================
     * =====================================================================================
     * =======================         CONTEXT FINALIZATION         ========================
     * =====================================================================================
     * =====================================================================================
     */

    // The name of the frame being validated
    let mut _frameName : [mut [c8]] = [];

    // The list of symbols touched by the current symbol
    let mut _touchings : [mut [[c8] => ()]] = [];

    // The current scope variable declarations
    let mut _variables : [mut [usize => &YILValue]] = [];

    // The current scope lazy references declarations
    let mut _lazyRefs : [mut [usize => &YILVar]] = [];

    // The current uniq id for variables in the current frame
    let mut _varUniqId : [mut usize] = [];

    // The current uniq id for labels in the current frame
    let mut _lblUniqId : [mut usize] = [];

    // The var in which to put the result of loops (when breaking)
    let mut _loopVar : [mut &YILValue] = [];

    // The label to exit the loop
    let mut _loopLabel : [mut &YILLabel] = [];

    // The list of classes already validated
    let mut _classValidated : [[c8] => mut &YILType] = [];

    // The list of class currently in validation
    let mut _inClassValidation : [[c8] => ()];

    // Global string stored in the text segment
    let mut _strConsts : [[c8] => mut &YILValue] = [];


    /*!
     * =====================================================================================
     * =====================================================================================
     * ==============================         CTORS         ================================
     * =====================================================================================
     * =====================================================================================
     */

    /**
     * Create a new empty expander
     * */
    pub self () {}

    /**
     * Expande a list of generators
     * */
    pub fn finalize (mut self, generators : [&Generator])-> [&YILSymbol] {
        self._generators = generators;
        for gen in self._generators {
            self:.finalize (gen);
        }

        if (state::instance ().isUnittestActive ()) {
            self:.finalizeUnitTestRegistrationFrame ();
            self:.finalizeUnitTestCall ();
        }

        self:.traverseSymbolGraph ()
    }

    /**
     * Expande a generator
     * */
    pub fn finalize (mut self, gen : &Generator) {
        match gen {
            frame : &FrameGenerator => {
                self:.finalizeFrame (frame);
            }
            cl : &ClassRefType => {
                self:.finalizeClass (cl);
            }
            m : &MapInfoGenerator => {
                self:.finalizeMapInfo (m);
            }
            u : &UnitTestGenerator => {
                self:.finalizeUnitTest (u);
            }
            g : &GlobalVarGenerator => {
                self:.finalizeGlobalVar (g);
            }
            _ => {
                panic;
            }
        }
    }


    /**
     * Traverse the list of finalized symbols and returned the symbols that are either non weak or touched by a non weak symbol
     * */
    pub fn traverseSymbolGraph (mut self) -> [&YILSymbol] {
        let mut consts : [mut &YILSymbol] = [];
        let mut vars : [mut &YILSymbol] = [];
        let mut frames : [mut &YILSymbol] = [];

        while self._symbols.len () > 0us {
            let mut syms : [mut &YILSymbol] = [];
            for _, j in self._symbols { syms ~= [j]; }
            self._symbols = [];

            for i in syms {
                for t in i.getReferences () if let Ok (n : &YILSymbol) = self._weakSymbols [t]? {
                    self._symbols [t] = n;
                    self._weakSymbols:.remove (t);
                }

                match i {
                    YILFrame () => { frames ~= [i]; }
                    YILConstant () => { consts ~= [i]; }
                    YILGlobalVar () => { vars ~= [i]; }
                    _ => panic;
                }
            }
        }

        let csts = sort!{|a, b| => {
            a.getName () < b.getName ()
        }} (consts);

        let frs = sort!{|a, b| => {
            a.getName () < b.getName ()
        }} (frames);

        let vrs = sort!{|a, b| => {
            a.getName () < b.getName ()
        }} (vars);

        csts ~ vrs ~ frs
    }


    /*!
     * =====================================================================================
     * =====================================================================================
     * =========================          FRAME EXPANSION          =========================
     * =====================================================================================
     * =====================================================================================
     */

    /**
     * Expande a frame generator
     * @params:
     *    - frame: the frame to expande
     * */
    pub fn finalizeFrame (mut self, frame : &FrameGenerator) {
        let mut list = StmtList ();

        self:.enterSymbol ();
        self:.enterFrame (frame.getName ().toStr ());
        self:.enterBlock ();

        let mut parameters : [&YILVarDecl] = [];
        for pi in frame.getParameters () if let p : &ProtoVarValue = pi {
            let varId = self:.generateVarId ();
            let mut type = self:.finalizeType (p.getType ());
            if (p.isLazy ()) {
                let lazyType = self.getTypeExpander ().finalizeLazy ();

                let decl = copy YILVarDecl (p.getLoc (), p.getLoc ().str (), lazyType, varId);
                let varref = copy YILVar (p.getLoc (), p.getLoc ().str (), lazyType, varId);
                parameters:.push (decl);

                let addr = copy YILAddrValue (p.getLoc (), copy YILPointer (lazyType), varref);
                self:.registerLazyRef (p.getUniqId (), varref);
                self:.registerVariable (p.getUniqId (),
                                        copy YILNameCallValue (p.getLoc (),
                                                               copy YILPointer (type),
                                                               YRuntimeFuncs::CALL_LAZY, copy [addr]));
            } else {
                let vref = copy YILVar (p.getLoc (), p.getLoc ().str (), type, varId);
                let (finVref, finType) = if (p.isReference ()) {
                    (copy YILUnrefValue (p.getLoc (), type, vref),
                     copy YILPointer (type))
                } else if (p.getType ().isMovable ()) {
                    (self._valueExpander.registerDestroy (alias self, vref, p.getType (), alias list, implicit-> false),
                     type)
                } else {
                    (vref, type)
                };

                parameters:.push (YILVarDecl (p.getLoc (), p.getLoc ().str (), finType, varId));
                self:.registerVariable (p.getUniqId (), finVref);
            }
        } else panic;


        let _ = self:.finalizeValue (frame.getBody (), alias list);

        let body = if (list.hasDestroy ()) {
            let b = frame.getBody ();
            if (b.isReturner () || b.isBreaker () || b.getThrowers ().len != 0us) {
                copy YILTryFinally (b.getLoc (), list[], list.getToDestroy ())
            } else {
                list:.append (list.getToDestroy ());
                copy YILBlock (frame.getLoc (), list[])
            }
        } else {
            copy YILBlock (frame.getLoc (), list[])
        };

        self:.exitBlock ();
        self:.exitFrame ();
        let touching = self:.exitSymbol ();

        let name = self._mangler.mangle (frame);
        let final = copy YILFrame (frame.getLoc (),
                                   name,
                                   parameters,
                                   self:.finalizeType (frame.getReturnType ()),
                                   body-> body,
                                   isWeak-> frame.isWeak (),
                                   refs-> touching);

        if (frame.isWeak ()) {
            self._weakSymbols [name] = final;
        } else {
            self._symbols [name] = final;
        }

        if (!frame.isWeak () && !state::instance ().isUnittestActive () && frame.getName ().asStdPath ().file () == Keys::MAIN) {
            self:.finalizeMainCall (name, (frame.getReturnType () of VoidType));
        }
    }

    /**
     * Generate the frame of the "main" function that calls the actual program main func
     * */
    fn finalizeMainCall (mut self, name : [c8], isVoid : bool) {
        let mut list = StmtList ();

        self:.enterSymbol ();
        self:.enterFrame (name);
        self:.enterBlock ();

        let argsT = copy [YIL_UINT_32, YIL_PTR_VOID];
        let argIds = copy [self:.generateVarId (), self:.generateVarId ()];

        let argcDecl = copy YILVarDecl (EOF_WORD, "argc", argsT [0], argIds [0]);
        let argvDecl = copy YILVarDecl (EOF_WORD, "argv", argsT [1], argIds [1]);

        let argcRef = copy YILVar (EOF_WORD, "argc", argsT [0], argIds [0]);
        let argvRef = copy YILVar (EOF_WORD, "argc", argsT [1], argIds [1]);

        let moduleFuncMain = copy YILAddrValue (EOF_WORD, YIL_PTR_VOID, copy YILVar (EOF_WORD, name, YIL_VOID, 0us));
        let runMain = if (state::instance ().isDebugActive ()) {
            YRuntimeFuncs::RUN_MAIN_DEBUG
        } else {
            YRuntimeFuncs::RUN_MAIN_RELEASE
        };

        let call = copy YILNameCallValue (EOF_WORD,
                                          YIL_SINT_32,
                                          runMain, copy [argcRef, argvRef, moduleFuncMain]);

        if (isVoid) {
            list:.append (copy YILCall (EOF_WORD, call));
            list:.append (copy YILReturn (EOF_WORD, copy YILIntValue (EOF_WORD, YIL_SINT_32, 0us)));
        } else {
            list:.append (copy YILReturn (EOF_WORD, call));
        }

        self:.registerTouchSym (name);
        self:.exitBlock ();
        self:.exitFrame ();
        let touching = self:.exitSymbol ();

        let final = copy YILFrame (EOF_WORD,
                                   Keys::MAIN,
                                   copy [argcDecl, argvDecl],
                                   YIL_SINT_32,
                                   body-> copy YILBlock (EOF_WORD, list[]),
                                   isWeak-> false,
                                   refs-> touching);

        self._symbols:.insert (Keys::MAIN, final);
    }

    /*!
     * =====================================================================================
     * =====================================================================================
     * ========================          UNIT TEST EXPANSION          ======================
     * =====================================================================================
     * =====================================================================================
     */

    /**
     * Finalize a unit test
     * */
    fn finalizeUnitTest (mut self, u : &UnitTestGenerator) {
        if (state::instance ().isUnittestActive ()) {
            self:.enterSymbol ();
            self:.enterFrame (u.getName ().toStr ());
            self:.enterBlock ();

            let mut list = StmtList ();
            let _ = self:.finalizeValue (u.getValue (), alias list);

            self:.exitBlock ();
            self:.exitFrame ();
            let touchings = self:.exitSymbol ();

            let name = self._mangler.mangle (u);
            let final = copy YILFrame (u.getLoc (),
                                       name,
                                       [],
                                       YIL_VOID,
                                       body-> copy YILBlock (u.getLoc (), list[]),
                                       isWeak-> false,
                                       refs-> touchings);

            self._symbols [name] = final;
            self._expUnitTest ~= [(u.getLoc (), u.getName ().toStr (), name)];
        }
    }

    /**
     * Finalize the package ctor that registers the unittests
     * */
    fn finalizeUnitTestRegistrationFrame (mut self) {
        self:.enterSymbol ();
        self:.enterFrame ("");
        self:.enterBlock ();

        let mut list = StmtList ();
        for i in 0us .. self._expUnitTest.len () {
            let (loc, name, mangledName) = self._expUnitTest [i];
            self._valueExpander.finalizeRegisterUnitTest (alias self, name, mangledName, loc, alias list);
        }

        self:.exitBlock ();
        self:.exitFrame ();
        let touchings = self:.exitSymbol ();

        let final = copy YILFrame (EOF_WORD,
                                   Keys::UNIT_TEST_REGISTER,
                                   [],
                                   YIL_VOID,
                                   body-> copy YILBlock (EOF_WORD, list[]),
                                   isGlobalCtor-> true,
                                   refs-> touchings);

        self._symbols [Keys::UNIT_TEST_REGISTER] = final;
    }

    /**
     * Finalize the main function that calls the unittests
     * */
    fn finalizeUnitTestCall (mut self) {
        self:.enterSymbol ();
        self:.enterFrame ("");
        self:.enterBlock ();

        let argsT = copy [YIL_UINT_32, YIL_PTR_VOID];
        let argIds = copy [self:.generateVarId (), self:.generateVarId ()];

        let argcDecl = copy YILVarDecl (EOF_WORD, "argc", argsT [0], argIds [0]);
        let argvDecl = copy YILVarDecl (EOF_WORD, "argv", argsT [1], argIds [1]);

        let argcRef = copy YILVar (EOF_WORD, "argc", argsT [0], argIds [0]);
        let argvRef = copy YILVar (EOF_WORD, "argc", argsT [1], argIds [1]);

        let mut list = StmtList ();
        let call = copy YILNameCallValue (EOF_WORD,
                                          YIL_SINT_32,
                                          YRuntimeFuncs::RUN_UNITTESTS, copy [argcRef, argvRef]);

        list:.append (copy YILReturn (EOF_WORD, call));
        self:.exitBlock ();
        self:.exitFrame ();
        let touchings = self:.exitSymbol ();

        let final = copy YILFrame (EOF_WORD,
                                   Keys::MAIN,
                                   copy [argcDecl, argvDecl],
                                   YIL_SINT_32,
                                   body-> copy YILBlock (EOF_WORD, list[]),
                                   isWeak-> true,
                                   refs-> touchings);

        self._symbols [Keys::MAIN] = final;
    }

    /*!
     * =====================================================================================
     * =====================================================================================
     * =========================          CLASS EXPANSION          =========================
     * =====================================================================================
     * =====================================================================================
     */

    /**
     * Finalize a class reference type (vtable, and typeinfo)
     * */
    pub fn finalizeClass (mut self, cl : &ClassRefType) {
        if (!cl.getSymbol ().isStruct () && !cl.getSymbol ().isAbstract ()) {
            // abstract classes and structures don't have vtable
            // abstract because some of their methods are empty
            // and structures because their methods are not virtual
            //

            self:.enterSymbol ();
            let vtableValue = self:.finalizeClassVtable (cl);
            let vtableName = self._mangler.mangleVtable (cl);
            let touchings = self:.exitSymbol ();

            // Const VTABLE
            let cst = copy YILConstant (cl.getLoc (),
                                        vtableName,
                                        vtableValue,
                                        isWeak-> cl.getSymbol ().isWeak (),
                                        refs-> touchings);

            if (cl.getSymbol ().isWeak ()) {
                self._weakSymbols [vtableName] = cst;
            } else {
                self._symbols [vtableName] = cst;
            }
        }

        self:.enterSymbol ();
        let typeinfoValue = self:.finalizeClassTypeInfo (cl);
        let tiName = self._mangler.mangleTypeInfo (cl);
        let touchings = self:.exitSymbol ();

        // Const TYPEINFO
        let cst = copy YILConstant (cl.getLoc (),
                                    tiName,
                                    typeinfoValue,
                                    isWeak-> cl.getSymbol ().isWeak (),
                                    refs-> touchings);

        if (cl.getSymbol ().isWeak ()) {
            self._weakSymbols [tiName] = cst;
        } else {
            self._symbols [tiName] = cst;
        }
    }

    /**
     * Finalize the typeinfo value of a class type, to write it in the text as a global variable
     * */
    pub fn finalizeClassTypeInfo (mut self, cl : &ClassRefType)-> &YILValue {
        let mut list = StmtList ();

        let slcType = {
            self:.finalizeType (copy SliceType (cl.getLoc (), VOID_TYPE))
        } catch {
            _ => panic;
        };

        let ancestorSlice = match cl.getAncestor () {
            anc : &ClassRefType => {
                let ancTIN = self._mangler.mangleTypeInfo (anc);
                self:.registerTouchSym (ancTIN);

                let ancTIV = copy YILAddrValue (cl.getLoc (), YIL_PTR_VOID,
                                                copy YILVar (cl.getLoc (), ancTIN, YIL_PTR_VOID, 0us));

                let len = copy YILIntValue (cl.getLoc (), YIL_UINT_MAX, 1us);
                copy YILTupleValue (cl.getLoc (), slcType, copy [len, ancTIV, YIL_NULL_VALUE],
                                    fieldNames-> copy [SliceKeys::LEN, SliceKeys::PTR, SliceKeys::BLK_INFO])
            }
            _ => {
                copy YILTupleValue (cl.getLoc (), slcType,
                                    copy [YILIntValue::new (cl.getLoc (), YIL_UINT_MAX, 0us), YIL_NULL_VALUE, YIL_NULL_VALUE],
                                    fieldNames-> copy [SliceKeys::LEN, SliceKeys::PTR, SliceKeys::BLK_INFO])
            }
        };

        let ti = cl.getTypeInfo ().asOf!{&TypeInfoValue} ();
        let id = self:.finalizeValue (ti.getId (), alias list);
        let size = self:.finalizeValue (ti.getSize (), alias list);
        let name = self:.finalizeValue (ti.getName (), alias list);
        let type = self:.finalizeType (ti.getType ());
        let fields = if let t : &YILTuple = type {
            t.getFieldNames ()
        } else panic;

        // Dynamic objects in the typeinfo
        if (list.len () != 0us) panic;

        copy YILTupleValue (cl.getLoc (), type,
                            copy [id, size, ancestorSlice, name],
                            fieldNames-> fields)
    }

    /**
     * Finalize the vtable value of a class to write it in the text as a global variable
     * */
    pub fn finalizeClassVtable (mut self, cl : &ClassRefType)-> &YILValue {
        let len = cl.getVtable ().len + 2us; // TI, Dtor, vtable

        let resultType = copy YILArray (YIL_PTR_VOID, len);
        let mut params : [&YILValue] = [];

        let TIN = self._mangler.mangleTypeInfo (cl);
        self:.registerTouchSym (TIN);

        let TIV = copy YILAddrValue (cl.getLoc (), YIL_PTR_VOID, copy YILVar (cl.getLoc (), TIN, YIL_PTR_VOID, 0us));
        params ~= [TIV];


        match cl.getDestructor () {
            UnitValue () => {
                params ~= [YIL_NULL_VALUE];
            }
            p : &PrototypeValue => {
                let name = self._mangler.mangle (p);
                self:.registerTouchSym (name);

                let addr = copy YILAddrValue (p.getLoc (), YIL_PTR_VOID, copy YILVar (p.getLoc (), name, YIL_VOID, 0us));
                params ~= [addr];
            }
            _ => panic;
        };

        for mt in cl.getVtable () {
            let name = self._mangler.mangle (mt);
            self:.registerTouchSym (name);

            let addr = copy YILAddrValue (mt.getLoc (), YIL_PTR_VOID, copy YILVar (mt.getLoc (), name, YIL_VOID, 0us));
            params ~= [addr];
        }

        copy YILArrayValue (cl.getLoc (), resultType, params)
    }


    /*!
     * =====================================================================================
     * =====================================================================================
     * =======================          GLOBAL VAR EXPANSION          ======================
     * =====================================================================================
     * =====================================================================================
     */

    /**
     * Finalize a global variable
     * */
    pub fn finalizeGlobalVar (mut self, gv : &GlobalVarGenerator) {
        let mut list = StmtList ();
        self:.enterSymbol ();
        let value = self._valueExpander.finalizeLazy (alias self, gv.getValue ().asOf!{&LazyValue} (), ref list);
        let touchings = self:.exitSymbol ();

        let name = self._mangler.mangleGlobalVar (gv);
        let glb = copy YILGlobalVar (gv.getLoc (), name, value,
                                     isWeak-> gv.isWeak (),
                                     isThreadLocal-> gv.isThreadLocal (),
                                     touchings);

        if (gv.isWeak ()) {
            self._weakSymbols [name] = glb;
        } else {
            self._symbols [name] = glb;
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===============================          MAP INFO EXPANSION          ===============================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Finalize a map information
     * @params:
     *    - m: the map info to finalize
     * */
    pub fn finalizeMapInfo (mut self, m : &MapInfoGenerator) {
        self:.enterSymbol ();

        let cmpName = self._mangler.mangle (m.getCmpFunc ());
        let hashName = self._mangler.mangle (m.getHashFunc ());
        self:.registerTouchSym (cmpName);
        self:.registerTouchSym (hashName);

        let name = self._mangler.mangleMapInfo (m.getMapType ());
        let cmpFunc = copy YILAddrValue (m.getLoc (), YIL_PTR_VOID, copy YILVar (m.getLoc (), cmpName, YIL_VOID, 0us));
        let hashFunc = copy YILAddrValue (m.getLoc (), YIL_PTR_VOID, copy YILVar (m.getLoc (), hashName, YIL_VOID, 0us));
        let keyT = self:.finalizeType (m.getMapType ().getInners ()[0]);
        let valT = self:.finalizeType (m.getMapType ().getInners ()[1]);
        let keySize = copy YILIntValue (m.getLoc (), YIL_UINT_MAX, keyT.getSize ());
        let valSize = copy YILIntValue (m.getLoc (), YIL_UINT_MAX, valT.getSize ());

        let tuType = copy YILTuple (copy [YIL_PTR_VOID, YIL_PTR_VOID, YIL_UINT_MAX, YIL_UINT_MAX]);
        let tuValue = copy YILTupleValue (m.getLoc (), tuType, copy [cmpFunc, hashFunc, keySize, valSize]);

        let touchings = self:.exitSymbol ();

        let cst = copy YILConstant (m.getLoc (),
                                    name,
                                    tuValue,
                                    isWeak-> true,
                                    refs-> touchings);

        self._weakSymbols [name] = cst;
    }

    /*!
     * =====================================================================================
     * =====================================================================================
     * ======================          TYPE/VALUE EXPANSION          =======================
     * =====================================================================================
     * =====================================================================================
     */

    /**
     * Finalize a value
     * @params:
     *    - value: the value to finalize
     * */
    pub fn finalizeValue (mut self, val : &Value, ref mut list : StmtList)-> &YILValue {
        self._valueExpander.finalize (alias self, val, ref list)
    }

    /**
     * Finalize a type
     * @params:
     *    - ty: the type to finalize
     * */
    pub fn finalizeType (mut self, ty : &Type)-> &YILType {
        self._typeExpander.finalize (alias self, ty)
    }

    /*!
     * =====================================================================================
     * =====================================================================================
     * =========================              GETTERS              =========================
     * =====================================================================================
     * =====================================================================================
     */

    /**
     * @returns: the mangler used to mangle symbol names
     * */
    pub fn getMangler (self)-> Mangler {
        self._mangler
    }

    /**
     * @returns: the expander used to finalize types
     * */
    pub fn getTypeExpander (self)-> TypeExpander {
        self._typeExpander
    }

    /*!
     * =====================================================================================
     * =====================================================================================
     * =========================              CONTEXT              =========================
     * =====================================================================================
     * =====================================================================================
     */

    /**
     * @returns: the declaration of the variable containing the value of the current loop
     * */
    pub fn getLoopVarRef (self)-> &YILValue {
        self._loopVar [$ - 1us]
    }

    /**
     * @returns: the label exiting the current loop
     * */
    pub fn getLoopExitLabel (self)-> &YILLabel {
        self._loopLabel [$ - 1us]
    }

    /**
     * Enter a loop where varref is the value of the loop
     * */
    pub fn enterLoop (mut self, varref : &YILValue, lbl : &YILLabel) {
        self._loopVar ~= [varref];
        self._loopLabel ~= [lbl];
    }

    /**
     * Exit a loop context
     * */
    pub fn exitLoop (mut self) {
        self._loopVar = self._loopVar [0 .. $ - 1];
        self._loopLabel = self._loopLabel [0 .. $ - 1];
    }

    /**
     * Enter a symbol definition
     * */
    fn enterSymbol (mut self) {
        self._touchings ~= [[]];
    }

    /**
     * Exit a symbol definitions
     * @returns: all the foreign symbols touched by it
     * */
    fn exitSymbol (mut self)-> [[c8] => ()] {
        let touchs = self._touchings [$ - 1];
        self._touchings = self._touchings [0 .. $ - 1];

        touchs
    }

    /**
     * Register the touch of a foreign symbol
     * */
    pub fn registerTouchSym (mut self, name : [c8]) {
        self._touchings [$ - 1][name] = ();
    }

    /**
     * Enter a new frame
     * @params:
     *     - name: the name of the frame (not mangled)
     * */
    pub fn enterFrame (mut self, name : [c8]) {
        self._frameName ~= [name];
        self._varUniqId ~= [1us]; // first ID id 1, 0 means no ref
        self._lblUniqId ~= [1us];
    }

    /**
     * Exit the current frame
     * */
    pub fn exitFrame (mut self) {
        self._frameName = self._frameName [0 .. $ - 1];
        self._varUniqId = self._varUniqId [0 .. $ - 1];
        self._lblUniqId = self._lblUniqId [0 .. $ - 1];
    }

    /**
     * @returns: true if we are currently inside a frame
     * */
    pub fn isInAFrame (self)-> bool {
        self._varUniqId.len != 0us
    }

    /**
     * @returns: the name of the frame being validated
     * */
    pub fn getCurrentFrameName (self)-> [c8] {
        self._frameName [$ - 1]
    }

    /**
     * Set the uniq ids of the current frame
     * */
    pub fn setUniqIds (mut self, varIds : usize, lblIds : usize) {
        self._varUniqId [$ - 1] = varIds;
        self._lblUniqId [$ - 1] = lblIds;
    }

    /**
     * Get the uniq ids of the current frame
     * */
    pub fn getUniqIds (mut self) -> (usize, usize) {
        (self._varUniqId [$ - 1], self._lblUniqId [$ - 1])
    }

    /**
     * @returns: the next uniq id for a variable in the current frame
     * */
    pub fn generateVarId (mut self)-> usize {
        let id = self._varUniqId [$ - 1];
        self._varUniqId [$ - 1] = id + 1;
        id
    }

    /**
     * @returns: the next uniq id for a variable in the current frame
     * */
    pub fn generateLblId (mut self)-> usize {
        let id = self._lblUniqId [$ - 1];
        self._lblUniqId [$ - 1] = id + 1;
        id
    }

    /**
     * Enter a new scope of variables
     * */
    pub fn enterBlock (mut self) {
        self._variables ~= [[]];
        self._lazyRefs ~= [[]];
    }

    /**
     * Exit a scope of variables
     * */
    pub fn exitBlock (mut self) {
        self._variables = self._variables [0 .. $ - 1];
        self._lazyRefs = self._lazyRefs [0 .. $ - 1];
    }

    /**
     * Register a variable declaration in the scope
     * @params:
     *    - old: the uniq id of the previous declaration
     *    - new: the uniq id of the new declaration
     * */
    pub fn registerVariable (mut self, old : usize, vref : &YILValue) {
        self._variables [$ - 1][old] = vref;
    }

    /**
     * Search the id of a variable declared in the current frame
     * @returns: the id, or None if the variable is not in the frame
     * */
    pub fn getVariable (self, old : usize)-> (&YILValue)? {
        for i in self._variables {
            if let Ok (n : &YILValue) = i [old]? {
                return n?;
            }
        }

        none
    }

    /**
     * Register a lazy variable reference by its id
     * */
    pub fn registerLazyRef (mut self, old : usize, vref : &YILVar) {
        self._lazyRefs [$ - 1][old] = vref;
    }

    /**
     * Search a lazy variable reference by its id
     * */
    pub fn getLazyRef (self, old : usize)-> (&YILVar)? {
        for i in self._lazyRefs {
            if let Ok (n : &YILVar) = i [old]? {
                return n?;
            }
        }

        none
    }

    /*!
     * =====================================================================================
     * =====================================================================================
     * =======================              TYPE CONTEXT              ======================
     * =====================================================================================
     * =====================================================================================
     */

    /**
     * Find the type of the class if already validated
     * */
    pub fn findClassValidation (self, cr : &ClassRefType)-> (&YILType)? {
        self._classValidated [cr.getSymbol ().getPath ().toStr ()]?
    }

    /**
     * @returns: true if the class is being validated
     * */
    pub fn isInClassValidation (self, cr : &ClassRefType)-> bool {
        cr.getSymbol ().getPath ().toStr () in self._inClassValidation
    }

    /**
     * Start a finalization of a class type
     * */
    pub fn enterClassValidation (mut self, cr : &ClassRefType) {
        self._inClassValidation [cr.getSymbol ().getPath ().toStr ()] = ();
    }

    /**
     * Class finalized
     * */
    pub fn exitClassValidation (mut self, cr : &ClassRefType, res : &YILType) {
        self._inClassValidation:.remove (cr.getSymbol ().getPath ().toStr ());
        self._classValidated [cr.getSymbol ().getPath ().toStr ()] = res;
    }

}
