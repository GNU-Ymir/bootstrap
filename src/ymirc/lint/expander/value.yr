in value;

use ymirc::lint::expander::{visitor, type, stmtlist};
use ymirc::lint::node::{_, global::_, instr::_, type::_, value::_};

use std::{io, fs::path};

use ymirc::utils::format;
use ymirc::utils::{bigint, bigfloat};

use ymirc::semantic::generator::_;
use ymirc::global::{core_, state};
use ymirc::syntax::keys;

use ymirc::lexing::word;

use ymirc::semantic::{symbol::path, generator::_};
use ymirc::semantic::generator::type::{_,
                                       custom::_,
                                       native::{_, scalar::_, compound::_},
                                       temporary::_};

use ymirc::semantic::generator::value::{_,
                                        construct::{_, delegate::_},
                                        literal::_,
                                        memory::_,
                                        operator::{_, binary::_, call::_, fields::_, map::_, slice::_, unary::_},
                                        operator::binary::{bool_::_, char_::_, float_::_, int_::_, pointer_::_},
                                        operator::map::iteration::_,
                                        prototypes::_,
                                        scope::_,
                                        syntax::_,
                                        template::_};

/**
 * The value expander is used to expand values into a list of statements
 */
pub record ValueExpander {

    /**
     * Create an empty value expander
     * */
    pub self () {}

    /**
     * Finalize a value
     * @params:
     *    - context: the context of the expansion
     *    - val: the value to expand
     *    - list: the list of statement to fill
     * @returns: the final value
     * */
    pub fn finalize (self, dmut context : &Expander, val : &Value, ref mut list : StmtList, asLeft : bool)-> &YILValue {
        match val {
            b : &BreakValue        => { self.finalizeBreak (alias context, b, ref list) }
            n : &NamedValue        => { self.finalize (alias context, n.getValue (), ref list, asLeft-> asLeft) }
            r : &ReturnValue       => { self.finalizeReturn (alias context, r, ref list) }
            t : &ThrowValue        => { self.finalizeThrow (alias context, t, ref list) }
            p : &PanicValue        => { self.finalizePanic (alias context, p, ref list) }
            v : &VarDeclValue      => { self.finalizeVarDecl (alias context, v, ref list) }
            v : &VarRefValue       => { self.finalizeVarRef (alias context, v, ref list) }
            g : &GlobalVarRefValue => { self.finalizeGlobalVarRef (alias context, g, ref list) }
            s : &ScopeValue        => { self.finalizeScope (alias context, s, ref list, asLeft-> asLeft) }
            l : &LiteralValue      => { self.finalizeLiteral (alias context, l, ref list, asLeft-> asLeft) }
            o : &OperatorValue     => { self.finalizeOperator (alias context, o, ref list, asLeft-> asLeft) }
            m : &MemoryValue       => { self.finalizeMemory (alias context, m, ref list, asLeft-> asLeft) }
            c : &ConstructValue    => { self.finalizeConstruct (alias context, c, ref list, asLeft-> asLeft) }
            c : _ => {
                eprintln (c.__typeinfo__.name);
                panic;
            }
        }
    }

    /**
     * Finalize a break statement
     * @params:
     *    - context: the context of the finalization
     *    -  b: the break statement to finalize
     * @returns: UNIT_VALUE, break values are never right operands
     * */
    fn finalizeBreak (self, dmut context : &Expander, b : &BreakValue, ref mut list : StmtList)-> &YILValue {
        let endLabel = context.getLoopExitLabel ();
        let decl = context.getLoopVarRef ();
        if (decl !of YILUnit) {
            let inner = self.finalize (alias context, b.getValue (), ref list, asLeft-> false);
            self.finalizeAffect (alias context, b.getLoc (), decl, inner, ref list);
        }

        list:.append (copy YILGoto (b.getLoc (), endLabel));
        YIL_UNIT_VALUE
    }

    /**
     * Finalize a return statement
     * @params:
     *    - context: the context of the finalization
     *    - t: the return stmt to finalize
     * @returns: UNIT_VALUE, return values are never right operands
     * */
    fn finalizeReturn (self, dmut context : &Expander, r : &ReturnValue, ref mut list : StmtList)-> &YILValue {
        let inner = self.finalize (alias context, r.getValue (), ref list, asLeft-> false);
        self.removeDestroy (inner, ref list);
        list:.append (copy YILReturn (r.getLoc (), inner));

        YIL_UNIT_VALUE
    }

    /**
     * Finalize a throw statement
     * @params:
     *    - t: the throw stmt to finalize
     * @returns: UNIT_VALUE, throw values are never right operands
     * */
    fn finalizeThrow (self, dmut context : &Expander, t : &ThrowValue, ref mut list : StmtList)-> &YILValue {
        let inner = self.finalize (alias context, t.getValue (), ref list, asLeft-> false);
        let line = copy YILIntValue (t.getLoc (), YIL_UINT_32, cast!usize (t.getLoc ().line));
        let filename = state::relativePath (t.getLoc ().filename);

        let fileStr = self.finalize (alias context, makeStringSliceValue (t.getLoc (), filename), ref list, asLeft-> false);
        let funcStr = self.finalize (alias context, makeStringSliceValue (t.getLoc (), context.getCurrentFrameName ()), ref list, asLeft-> false);

        let fileStrType = if let t_ : &YILTuple = fileStr.getType () {
            t_.getInners ()[1]
        } else panic;

        let fileStrPtr = if let t_ : &YILTupleValue = fileStr {
            t_.getValue ()[1]
        } else panic;

        let funcStrType = if let t_ : &YILTuple = funcStr.getType () {
            t_.getInners ()[1]
        } else panic;

        let funcStrPtr = if let t_ : &YILTupleValue = funcStr {
            t_.getValue ()[1]
        } else panic;

        let (fileStrPtrU, _) = self.createVarForBlock (alias context, t.getLoc (), NONE_TYPE, fileStrType, ref list, withValue-> fileStrPtr);
        let (funcStrPtrU, _) = self.createVarForBlock (alias context, t.getLoc (), NONE_TYPE, funcStrType, ref list, withValue-> funcStrPtr);

        let call = copy YILNameCallValue (t.getLoc (),
                                          YIL_VOID,
                                          YRuntimeFuncs::THROW_EXCEPT,
                                          copy [fileStrPtrU, funcStrPtrU, line, inner]);

        list:.append (copy YILCall (t.getLoc (), call));

        YIL_UNIT_VALUE
    }

    /**
     * Finalize a panice statement
     * @params :
     *    - p: the panic stmt to finalize
     * @returns: UNIT_VALUE
     * */
    fn finalizePanic (self, dmut context : &Expander, p : &PanicValue, ref mut list : StmtList)-> &YILValue {
        let line = copy YILIntValue (p.getLoc (), YIL_UINT_32, cast!usize (p.getLoc ().line));
        let filename = state::relativePath (p.getLoc ().filename);

        let fileStr = self.finalize (alias context, makeStringSliceValue (p.getLoc (), filename), ref list, asLeft-> false);
        let funcStr = self.finalize (alias context, makeStringSliceValue (p.getLoc (), context.getCurrentFrameName ()), ref list, asLeft-> false);

        let fileStrType = if let t : &YILTuple = fileStr.getType () { t.getInners ()[1] } else panic;
        let fileStrPtr = if let t : &YILTupleValue = fileStr { t.getValue ()[1] } else panic;

        let funcStrType = if let t : &YILTuple = funcStr.getType () { t.getInners ()[1] } else panic;
        let funcStrPtr = if let t : &YILTupleValue = funcStr { t.getValue ()[1] } else panic;

        let (fileStrPtrU, _) = self.createVarForBlock (alias context, p.getLoc (), NONE_TYPE, fileStrType, ref list, withValue-> fileStrPtr);
        let (funcStrPtrU, _) = self.createVarForBlock (alias context, p.getLoc (), NONE_TYPE, funcStrType, ref list, withValue-> funcStrPtr);

        let call = copy YILNameCallValue (p.getLoc (),
                                          YIL_VOID,
                                          YRuntimeFuncs::PANIC,
                                          copy [fileStrPtrU, funcStrPtrU, line]);

        list:.append (copy YILCall (p.getLoc (), call));

        YIL_UNIT_VALUE
    }

    /**
     * Finalize the registration of a unit test
     * @params:
     *    - context: the context of the expansion
     *    - name: the name of the unit test function to register
     *    - loc: the location of the unittest
     *    - list: the list to fill
     * */
    pub fn finalizeRegisterUnitTest (self, dmut context : &Expander, name : [c8], mangledName : [c8], loc : &Word, ref mut list : StmtList) {
        let funcAddr = copy YILAddrValue (EOF_WORD, YIL_PTR_VOID, copy YILVar (EOF_WORD, mangledName, YIL_VOID, 0us));

        let funcStr = self.finalize (alias context, makeStringSliceValue (loc, name), ref list, asLeft-> false);
        let funcStrPtr = if let t : &YILTupleValue = funcStr { t.getValue ()[1] } else panic;
        let funcStrType = if let t : &YILTuple = funcStr.getType () { t.getInners ()[1] } else panic;

        let (funcStrPtrU, _) = self.createVarForBlock (alias context, loc, NONE_TYPE, funcStrType, ref list, withValue-> funcStrPtr);

        let call = copy YILNameCallValue (loc,
                                          YIL_VOID,
                                          YRuntimeFuncs::REGISTER_UNIT_TEST,
                                          copy [funcStrPtrU, funcAddr]);

        list:.append (copy YILCall (EOF_WORD, call));
    }
    
    /**
     * Finalize a variable declaration statement
     * @params:
     *    - v: the variable declaration to finalize
     * @returns: UNIT_VALUE, variable decl are never right operands
     * */
    fn finalizeVarDecl (self, dmut context : &Expander, v : &VarDeclValue, ref mut list : StmtList)-> &YILValue {
        // Lambda definition, is not generated
        if (v.getVarType () of LambdaType) return YIL_UNIT_VALUE;

        let inner = self.finalize (alias context, v.getValue (), ref list, asLeft-> false);
        let mut type = context:.finalizeType (v.getVarType ());

        if (v.isLazy ()) {
            let lazyType = context:.getTypeExpander ():.finalizeLazy ();
            let varId = context:.generateVarId ();
            let decl = copy YILVarDecl (v.getLoc (), v.getLoc ().str, lazyType, varId);
            let varref = copy YILVar (v.getLoc (), v.getLoc ().str, lazyType, varId);

            list:.append (decl);
            if (inner !of YILUnit) {
                self.finalizeAffect (alias context, v.getLoc (), varref, inner, ref list);
            }

            let addr = copy YILAddrValue (v.getLoc (), context:.getTypeExpander ():.finalizePointer (lazyType), varref);
            context:.registerLazyRef (v.getUniqId (), varref);
            context:.registerVariable (v.getUniqId (), copy YILNameCallValue (v.getLoc (),
                                                                              context:.getTypeExpander ():.finalizePointer (type),
                                                                              YRuntimeFuncs::CALL_LAZY,
                                                                              copy [addr]));
        } else {
            if (v.isReference ()) {
                type = context:.getTypeExpander ():.finalizePointer (type);
            }

            let varId = context:.generateVarId ();
            let decl = copy YILVarDecl (v.getLoc (), v.getLoc ().str, type, varId);
            let mut varref = copy YILVar (v.getLoc (), v.getLoc ().str, type, varId);

            list:.append (decl);
            if (inner !of YILUnit) {
                self.finalizeAffect (alias context, v.getLoc (), varref, inner, ref list);
            }

            if (v.getVarType ().isMovable () && !v.isReference ()) {
                self.registerDestroy (alias context, varref, v.getVarType (), ref list, implicit-> false);
            }

            if (v.isReference ()) {
                if let pt : &YILPointer = type {
                    context:.registerVariable (v.getUniqId (),
                                               copy YILUnrefValue (v.getLoc (), pt.getInner (), varref));
                } else panic;
            } else {
                context:.registerVariable (v.getUniqId (), varref);
            }
        }

        YIL_UNIT_VALUE
    }

    /**
     * Finalize a variable reference value
     * @params:
     *   - v: the variable to finalize
     * @returns: a variable reference
     * */
    fn finalizeVarRef (self, dmut context : &Expander, v : &VarRefValue, ref mut list : StmtList)-> &YILValue {
        if (v.isLazy ()) {
            let type = context:.finalizeType (v.getType ());
            match context.getVariable (v.getUniqId ()) {
                Ok (u : &YILValue) => { return copy YILUnrefValue (v.getLoc (), type, u); }
            }

            match context.getVariable (v.getRefId ()) {
                Ok (u : &YILValue) => {
                    return copy YILUnrefValue (v.getLoc (), type,
                                               self.registerUniqValue (alias context, v, type-> u.getType (), u, ref list));
                }
            }
        } else {
            match context.getVariable (v.getRefId ()) {
                Ok (vref : &YILValue) => { return vref; }
            };
        }

        let type = context:.finalizeType (v.getType ());
        copy YILVar (v.getLoc (), v.getDeclLoc ().str, type, 0us)
    }

    /**
     * Finalize a global variable reference value
     * @params:
     *   - v: the value to finalize
     * @returns: a variable reference
     * */
    fn finalizeGlobalVarRef (self, dmut context : &Expander, v : &GlobalVarRefValue, ref mut list : StmtList)-> &YILValue {
        let type = context:.finalizeType (v.getType ());
        if (v.isLazy ()) {
            match context.getVariable (v.getUniqId ()) {
                Ok (u : &YILValue) => return copy YILUnrefValue (v.getLoc (), type, u);
            }
        }

        let vname = context.getMangler ().mangleGlobalVar (v.getRefGenerator ());
        context:.registerTouchSym (vname, v.getRefGenerator ().getLoc ());

        if (v.isLazy ()) {
            let lazyType = context:.getTypeExpander ():.finalizeLazy ();
            let mut vref = copy YILVar (v.getLoc (), vname, lazyType, 0us, isThreadLocal-> v.getRefSymbol ().isThreadLocal ());

            let addr = copy YILAddrValue (v.getLoc (), context:.getTypeExpander ():.finalizePointer (lazyType), vref);
            let ret = copy YILNameCallValue (v.getLoc (),
                                             context:.getTypeExpander ():.finalizePointer (type),
                                             YRuntimeFuncs::CALL_LAZY,
                                             copy [addr]);

            return copy YILUnrefValue (v.getLoc (), type,
                                       self.registerUniqValue (alias context, v, type-> ret.getType (), ret, ref list));
        } else {
            return copy YILVar (v.getLoc (), vname, type, 0us);
        }
    }

    /*!
     * =====================================================================================
     * =====================================================================================
     * =========================          SCOPE EXPANSION          =========================
     * =====================================================================================
     * =====================================================================================
     */

    /**
     * Finalize a scope value
     * @params:
     *    - sc: the scope value to finalize
     *    - list: the statement list to fill
     * @returns: the final value of the scope
     * */
    fn finalizeScope (self, dmut context : &Expander, sc : &ScopeValue, ref mut list : StmtList, asLeft : bool)-> &YILValue {
        match context.getVariable (sc.getUniqId ()) {
            Ok (u : &YILValue) => { // The call was already seen and validated
                return u;
            }
        };

        let retVal = match sc {
            b : &BlockValue => {
                if (b.isSet ()) {
                    return self.finalizeBlockSet (alias context, b, ref list, asLeft);
                }

                self.finalizeBlock (alias context, b, ref list)
            }
            c : &ConditionalValue => { self.finalizeCond (alias context, c, ref list) }
            l : &LoopValue => { self.finalizeLoop (alias context, l, ref list) }
            t : &TryFinallyValue => { self.finalizeTryFinally (alias context, t, ref list) }
            t : &TryCatchValue => { self.finalizeTryCatch (alias context, t, ref list) }
            l : &ListComprValue => { self.finalizeBlock (alias context, l.getContent (), ref list) }
            _ => {
                eprintln (sc.__typeinfo__.name);
                panic;
            }
        }

        retVal
    }

    /**
     * Finalize a set
     * @params:
     *     - context: the context of the expansion
     *     - b: the set to finalize
     *     - list: the list of values to fill
     *     - asLeft: true if used as lvalue
     * */
    fn finalizeBlockSet (self, dmut context : &Expander, b : &BlockValue, ref mut list : StmtList, asLeft : bool)-> &YILValue {
        let retVal = self.finalizeSet (alias context, b, ref list);
        if (!asLeft) {
            self.registerUniqValue (alias context, b, retVal.getType (), retVal, ref list)
        } else {
            retVal
        }
    }

    /**
     * Finalize a block of values
     * @params:
     *    - b: the block of values to finalize
     *    - list: the list of statement to fill
     * @returns: the final value of the block if any
     * */
    fn finalizeBlock (self, dmut context : &Expander, b : &BlockValue, ref mut list : StmtList)-> &YILValue {
        let mut innerList = StmtList ();

        let retType = context:.finalizeType (b.getType ());
        let (resultVar, _) = self.createVarForBlock (alias context, b.getLoc (), b.getType (), retType, ref list);
        context:.enterBlock ();

        let retVal = self.finalizeSet (alias context, b, ref innerList);
        self.finalizeAffect (alias context, b.getLoc (), resultVar, retVal, ref innerList);

        context:.exitBlock ();

        if (innerList.hasDestroy ()) {
            list:.append (copy YILTryFinally (b.getLoc (), innerList[], innerList.getToDestroy ()));
        } else {
            // Block without scope guards can be flattened, there is no variable shadowing anymore
            list:.append (innerList); // copy BlockValue (b.getLoc (), VOID_TYPE, innerList, noValue-> true));
        }

        if (resultVar !of YILUnit) {
            context:.registerVariable (b.getUniqId (), resultVar);
        }

        resultVar
    }

    /**
     * Finalize a try finally value
     * */
    fn finalizeTryFinally (self, dmut context : &Expander, t : &TryFinallyValue, ref mut list : StmtList)-> &YILValue {
        let mut tryP = StmtList ();

        let vdecl = t.getFailVar ();
        if (vdecl !of UnitValue) { // let #_failed = true;
            self.finalize (alias context, vdecl, ref list, asLeft-> false);
        }

        context:.enterBlock ();
        let (tryVal, isCatch) = match t.getTryPart () {
            c : &TryCatchValue => {
                let aff = if (vdecl of UnitValue) {
                    vdecl
                } else {
                    if let v : &VarDeclValue = vdecl {
                        let vref = copy VarRefValue (v.getLoc (), v.getLoc (), v.getVarType (), v.getUniqId (), isSelf-> false, canCte-> false);
                        copy AffectValue (t.getLoc (), v.getVarType (), vref, copy BoolValue (t.getLoc (), false))
                    } else panic;
                }

                (self.finalizeTryCatch (alias context, c, ref tryP, aff-> aff), true)
            }
            _ => {
                (self.finalize (alias context, t.getTryPart (), ref tryP, asLeft-> false), false)
            }
        };

        let type = context:.finalizeType (t.getTryPart ().getType ());
        let (varTry, _) = self.createVarForBlock (alias context, t.getTryPart ().getLoc (), t.getTryPart ().getType (), type, ref list);
        if (varTry !of YILUnit) {
            context:.registerVariable (t.getTryPart ().getUniqId (), varTry);
            self.finalizeAffect (alias context, t.getTryPart ().getLoc (), varTry, tryVal, ref tryP);
        }

        if (!isCatch && vdecl !of UnitValue) { // #_failed = false;
            if let v : &VarDeclValue = vdecl {
                let vref = copy VarRefValue (v.getLoc (), v.getLoc (), v.getVarType (), v.getUniqId (), isSelf-> false, canCte-> false);
                let aff = copy AffectValue (t.getLoc (), v.getVarType (), vref, copy BoolValue (t.getLoc (), false));

                self.finalize (alias context, aff, ref tryP, asLeft-> false);
            } else panic;
        }

        context:.exitBlock ();
        context:.enterBlock ();

        //if (t.canTryThrow () || t.getTryPart ().isReturner () || t.getTryPart ().isBreaker ()) {
        // Need a try finally

        let mut finP = StmtList ();
        self.finalize (alias context, t.getFinallyPart (), ref finP, asLeft-> false);

        if (finP[].len != 0) {
            let tryF = copy YILTryFinally (t.getLoc (), tryP[], finP[]);
            list:.append (tryF);
        } else {
            list:.append (tryP[]);
        }

        context:.exitBlock ();
        if (varTry !of YILUnit) {
            context:.registerVariable (t.getUniqId (), varTry);
        }

        varTry // return the value generated by the try part
    }

    /**
     * Finalize a try catch value
     * */
    fn finalizeTryCatch (self, dmut context : &Expander, t : &TryCatchValue, ref mut list : StmtList, aff : &Value = UNIT_VALUE)-> &YILValue {
        let mut tryP = StmtList ();

        context:.enterBlock ();
        let tryVal = self.finalize (alias context, t.getTryPart (), ref tryP, asLeft-> false);

        let type = context:.finalizeType (t.getTryPart ().getType ());
        let (varTry, _) = self.createVarForBlock (alias context, t.getTryPart ().getLoc (), t.getTryPart ().getType (), type, ref list);
        if (varTry !of YILUnit) {
            context:.registerVariable (t.getTryPart ().getUniqId (), varTry);
            self.finalizeAffect (alias context, t.getTryPart ().getLoc (), varTry, tryVal, ref tryP);
        }

        if (aff !of UnitValue) {
            self.finalize (alias context, aff, ref tryP, asLeft-> false);
        }
        context:.exitBlock ();

        let mut catchP = StmtList ();
        context:.enterBlock ();

        self.finalize (alias context, t.getCatchVar (), ref catchP, asLeft-> false);
        if let ctVarValue : &VarDeclValue = t.getCatchVar () {
            let varref = self.finalize (alias context, copy VarRefValue (ctVarValue.getLoc (), ctVarValue.getLoc (), ctVarValue.getVarType (), ctVarValue.getUniqId (), isSelf-> false, canCte-> false), ref catchP, asLeft-> false);
            catchP:.append (copy YILAffect (t.getCatchVar ().getLoc (), varref, copy YILBeginCatch (t.getLoc (), YRuntimeFuncs::BEGIN_CATCH)));

            let catchVal = self.finalize (alias context, t.getCatchPart (), ref catchP, asLeft-> false);
            self.finalizeAffect (alias context, t.getCatchPart ().getLoc (), varTry, catchVal, ref catchP);

            context:.exitBlock ();

            let ctVarType = context:.finalizeType (ctVarValue.getVarType ());
            let tryCatch = copy YILTryCatch (t.getLoc (), ctVarType, tryP[], catchP[]);
            list:.append (tryCatch);

            if (varTry !of YILUnit) {
                context:.registerVariable (t.getUniqId (), varTry);
            }

            return varTry;
        }

        panic;
    }

    /**
     * Finalize a set of value
     * @params:
     *    - s: the set of values to finalize
     *    - list: the list of statement to fill
     * @returns: the final value of the set if any
     * */
    fn finalizeSet (self, dmut context : &Expander, s : &BlockValue, ref mut list : StmtList)-> &YILValue {
        let mut finVal : &YILValue = YIL_UNIT_VALUE;
        for i in 0us .. s.getValues ().len {
            let inner = s.getValues ()[i];
            finVal = self.finalize (alias context, inner, ref list, asLeft-> false);
        }

        finVal
    }

    /**
     * Finalize a branch statement
     * @params:
     *    - c: the conditional statement to finalize
     *    - list: the list of statement to fill
     * @returns: the final value of the condition if any
     * */
    fn finalizeCond (self, dmut context : &Expander, c : &ConditionalValue, ref mut list : StmtList)-> &YILValue {
        let type = context:.finalizeType (c.getType ());
        let (var, _) = self.createVarForBlock (alias context, c.getLoc (), c.getType (), type, ref list);

        let mut ifList = StmtList ();
        let mut elseList = StmtList ();

        // Maybe calls from this test are evaluated in the else cond
        // If there are calls in there, we need to validate them first
        let test = self.finalize (alias context, c.getTest (), ref list, asLeft-> false);
        let testVar = if (test !of YILVar && test !of YILIntValue) {
            let (testVar, _) = self.createVarForBlock (alias context,
                                                       c.getTest ().getLoc (),
                                                       c.getTest ().getType (),
                                                       test.getType (),
                                                       ref list,
                                                       withValue-> test);
            testVar
        } else {
            test
        };

        context:.enterBlock ();
        let ifVal = self.finalize (alias context, c.getValue (), ref ifList, asLeft-> false);
        context:.exitBlock ();

        context:.enterBlock ();
        let elseVal = self.finalize (alias context, c.getElse (), ref elseList, asLeft-> false);
        context:.exitBlock ();

        if (var !of YILUnit) {
            if (ifVal !of YILUnit) { // can happen if the if val is returner/breaker
                self.finalizeAffect (alias context, c.getLoc (), var, ifVal, ref ifList);
            }
            if (elseVal !of YILUnit) { // if the else val is a returner/breaker or just does not have a value
                self.finalizeAffect (alias context, c.getLoc (), var, elseVal, ref elseList);
            }
        }

        self.finalizeCond (c.getLoc (), alias context,  ref list, testVar, ifList, elseList);
        if (var !of YILUnit) {
            context:.registerVariable (c.getUniqId (), var);
        }

        var
    }

    /**
     * Create conditional jump structure using the list of instruction of each blocks
     * @params:
     *    - loc: the location of the condition
     *    - list: the list of statement to fill
     *    - test: the test of the conditional
     *    - thenList: the list of statement to execute if the condition is met
     *    - elseList: the list of statement to execute if the condition is not met
     * */
    fn finalizeCond (self, loc : &Word, dmut context : &Expander, ref mut list : StmtList, test : &YILValue, thenList : StmtList, elseList : StmtList) {
        let thenLabel = copy YILLabel (loc, "then"s8, context:.generateLblId ());
        let endLabel = copy YILLabel (loc, "end"s8, context:.generateLblId ());
        let elseLabel = if (elseList.len != 0us) {
            copy YILLabel (loc, "else"s8, context:.generateLblId ())
        } else {
            endLabel
        };

        list:.append (copy YILCondJmp (loc, test, thenLabel, elseLabel));
        list:.append (thenLabel);
        list:.append (thenList);

        if (elseList.len != 0us) {
            list:.append (copy YILGoto (loc, endLabel));
            list:.append (elseLabel);
            list:.append (elseList);
        }

        list:.append (endLabel);
    }

    /**
     * Finalize a loop statement
     * @params:
     *    - l: the loop statement to finalize
     *    - list: the list of statement to fill
     * @returns: the final value of the loop if any
     * */
    fn finalizeLoop (self, dmut context : &Expander, l : &LoopValue, ref mut list : StmtList)-> &YILValue {
        if (l.isCteFor ()) {
            self.finalizeCteForLoop (alias context, l, ref list)
        } else {
            self.finalizeClassicLoop (alias context, l, ref list)
        }
    }

    /**
     * Finalize a cte for loop statement
     * @params:
     *    - l: the for loop statement to finalize
     *    - list: the list of statement to fill
     * */
    fn finalizeCteForLoop (self, dmut context : &Expander, l : &LoopValue, ref mut list : StmtList)-> &YILValue {
        let type = context:.finalizeType (l.getType ());
        let (var, _) = self.createVarForBlock (alias context, l.getLoc (), l.getType (), type, ref list);

        context:.enterBlock ();
        let endLabel = copy YILLabel (l.getLoc (), "end"s8, context:.generateLblId ());
        context:.enterLoop (var, endLabel);

        let mut innerList = StmtList ();
        let innerValue = self.finalize (alias context, l.getValue (), ref innerList, asLeft-> false);
        if (var !of YILUnit && !l.getValue ().isBreaker ()) {
            self.finalizeAffect (alias context, l.getLoc (), var, innerValue, ref innerList);
        }

        context:.exitLoop ();
        context:.exitBlock ();

        list:.append (innerList);
        list:.append (endLabel);
        var
    }

    /**
     * Finalize a loop with (or without) a test, that is execute at runtime
     * @params:
     *    - l: the loop to finalize
     *    - list: the statement list to fill
     * @returns: the value of the loop if any
     * */
    fn finalizeClassicLoop (self, dmut context : &Expander, l : &LoopValue, ref mut list : StmtList)-> &YILValue {
        let type = context:.finalizeType (l.getType ());
        let (varref, _) = self.createVarForBlock (alias context, l.getLoc (), l.getType (), type, ref list);

        let mut testList = StmtList ();
        // test is in its own list, because we need to validate it right away
        // But it has to be placed after the test label
        let test = self.finalize (alias context, l.getTest (), ref testList, asLeft-> false);

        context:.enterBlock ();
        let mut loopList = StmtList ();
        let endLabel = copy YILLabel (l.getLoc (), "end"s8, context:.generateLblId ());
        context:.enterLoop (varref, endLabel);

        let contentVal = self.finalize (alias context, l.getValue (), ref loopList, asLeft-> false);
        if (varref !of YILUnit && !l.getValue ().isBreaker () && test !of YILUnit) {
            self.finalizeAffect (alias context, l.getLoc (), varref, contentVal, ref loopList);
        }

        context:.exitLoop ();
        context:.exitBlock ();

        let begLabel = copy YILLabel (l.getLoc (), "beg"s8, context:.generateLblId ());
        let testLabel = copy YILLabel (l.getLoc (), "test"s8, context:.generateLblId ());

        if (!l.isDo () && test !of YILUnit) {
            list:.append (copy YILGoto (l.getLoc (), testLabel));
        }

        list:.append (begLabel);
        list:.append (loopList);

        if (test !of YILUnit) {
            list:.append (testLabel);
            list:.append (testList);
            list:.append (copy YILCondJmp (l.getLoc (), test, begLabel, endLabel));
        } else {
            list:.append (copy YILGoto (l.getLoc (), begLabel));
        }

        list:.append (endLabel);
        if (varref !of YILUnit) {
            context:.registerVariable (l.getUniqId (), varref);
        }

        varref
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ==============================          TEMPORARY VARIABLES          ===============================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Create a variable to store a block value
     * @params:
     *    - loc: the location of the creation
     *    - type: the type of the block
     *    - list: the list of stmt to fill
     *    - name: the name of the variable (with a possible formatter, its uniq Id)
     * @returns:
     *    - a varref or unit value, if the type is empty
     *    - the address of the var ref (if requested)
     * */
    fn createVarForBlock (self, dmut context : &Expander, loc : &Word, genType : &Type, type : &YILType, ref mut list : StmtList, name : [c8] = "YI_%"s8, withValue : &YILValue = YIL_UNIT_VALUE, getAddr : bool = false)-> (&YILValue, &YILValue) {
        match type {
            YILVoid () => { return (YIL_UNIT_VALUE, YIL_UNIT_VALUE); }
            _ => {
                let varId = context:.generateVarId ();
                let fullName = format (name, varId);
                let blckVar = copy YILVarDecl (loc, fullName, type, varId, isTemp-> (name == "YI_%"s8));
                list:.append (blckVar);

                let var = copy YILVar (loc, fullName, type, varId, isTemp-> (name == "YI_%"s8));
                if (withValue !of YILUnit) self.finalizeAffect (alias context, loc, var, withValue, ref list);

                if genType.isMovable () {
                    self.registerDestroy (alias context, var, genType, ref list, implicit-> true);
                }

                return if (getAddr) {
                    let addr = self.createAddress (alias context, var, type-> context:.getTypeExpander ():.finalizePointer (type), ref list);
                    (var, addr)
                } else {
                    (var, YIL_UNIT_VALUE)
                };
            }
        };
    }

    /**
     * Register a uniq value in a variable
     * @returns: the uniq var ref, or YIL_UNIT_VALUE depending on the type
     * * */
    fn registerUniqValue (self, dmut context : &Expander, gen : &Value, value : &YILValue, ref mut list : StmtList, name : [c8] = "YI_%"s8) -> &YILValue {
        if (!context.isInAFrame ()) return value;

        let type = context:.finalizeType (gen.getType ());
        let (varref, _) = self.createVarForBlock (alias context, gen.getLoc (), gen.getType (), type, ref list, name-> name);
        if (varref !of YILUnit) {
            context:.registerVariable (gen.getUniqId (), varref);
            self.finalizeAffect (alias context, gen.getLoc (), varref, value, ref list);
        }

        varref
    }

    /**
     * Register a uniq value in a variable
     * @returns: the uniq var ref, or YIL_UNIT_VALUE depending on the type
     * * */
    fn registerUniqValue (self, dmut context : &Expander, gen : &Value, type : &YILType, value : &YILValue, ref mut list : StmtList, name : [c8] = "YI_%"s8) -> &YILValue {
        if (!context.isInAFrame ()) return value;

        let (varref, _) = self.createVarForBlock (alias context, gen.getLoc (), gen.getType (), type, ref list, name-> name);
        if (varref !of YILUnit) {
            context:.registerVariable (gen.getUniqId (), varref);
            self.finalizeAffect (alias context, gen.getLoc (), varref, value, ref list);
        }

        varref
    }

    /**
     * Register a variable to destroy in the current block list
     * */
    pub fn registerDestroy (self, dmut context : &Expander, gen : &YILVar, type : &Type, ref mut list : StmtList, implicit : bool, param : bool = false) {
        {
            if let c : &ClassPtrType = type {
                if (!c.getSymbol ().isEntity ()) return;
                else if let p : &PrototypeValue = c.getInner ().getDestructor () {
                    if (!list.hasToDestroy (gen.getVarId ())) {
                        let thenLabel = copy YILLabel (gen.getLoc (), "then"s8, context:.generateLblId ());
                        let endLabel = copy YILLabel (gen.getLoc (), "end"s8, context:.generateLblId ());
                        let test = copy YILFieldValue (gen.getLoc (), YIL_UINT_8, gen, name-> ClassKeys::SET);

                        let name = context.getMangler ().mangle (p);
                        context:.registerTouchSym (name, p.getLoc ());

                        let call = copy YILNameCallValue (gen.getLoc (), YIL_VOID, name, copy [copy YILAddrValue (gen.getLoc (), YIL_PTR_VOID, gen)]);
                        let instr = copy YILCall (gen.getLoc (), call);
                        let mut condList = StmtList ();

                        condList:.append (copy YILCondJmp (gen.getLoc (), test, thenLabel, endLabel));
                        condList:.append (thenLabel);
                        condList:.append (instr);
                        condList:.append (copy YILAffect (gen.getLoc (), test, copy YILIntValue (gen.getLoc (), YIL_UINT_8, 0us)));
                        condList:.append (endLabel);

                        let set = if (!param) {
                            let field = copy YILFieldValue (gen.getLoc (), YIL_UINT_8, gen, name-> ClassKeys::SET);
                            (copy YILAffect (gen.getLoc (), field, copy YILIntValue (gen.getLoc (), YIL_UINT_8, 0us)))?
                        } else {
                            none
                        };

                        list:.registerDestroy (gen.getVarId (), copy YILBlock (gen.getLoc (), condList[]), set, implicit);
                    }
                }
            }
        } catch {
            _ => {}
        }
    }

    /**
     * Remove a destroyer (if it was implicit - ctor, or function call)
     * */
    pub fn removeDestroy (self, p : &YILValue, ref mut list : StmtList) {
        match p {
            v : &YILVar => {
                list:.removeDestroyNotImplicit (v.getVarId ());
            }
        }
    }

    /*!
     * =====================================================================================
     * =====================================================================================
     * ========================          LITERAL EXPANSION          ========================
     * =====================================================================================
     * =====================================================================================
     */

    /**
     * Finalize a literal value
     * @params:
     *    - l: the literal value to finalize
     *    - list: the scope list of statement to fill
     * @returns: the finalized value
     * */
    fn finalizeLiteral (self, dmut context : &Expander, l : &LiteralValue, ref mut list : StmtList, asLeft : bool)-> &YILValue {
        match l { // simple literals
            s : &StringValue => { return self.finalizeStr (alias context, s); }
            b : &BoolValue => { return self.finalizeBool (alias context, b); }
            c : &CharValue => { return self.finalizeChar (alias context, c); }
            f : &FloatValue => { return self.finalizeFloat (alias context, f); }
            i : &IntValue => { return self.finalizeInt (alias context, i); }
            NullValue () => { return YIL_NULL_VALUE; }
            UnitValue () => { return YIL_UNIT_VALUE; }
        }

        match context.getVariable (l.getUniqId ()) {
            Ok (u : &YILValue) => { // The call was already seen and validated
                return u;
            }
        };

        let val = match l {
            a : &ArrayValue => { self.finalizeArray (alias context, a, ref list) }
            a : &ArrayAllocValue => { self.finalizeArrayAlloc (alias context, a, ref list) }
            t : &TupleValue => { self.finalizeTuple (alias context, t, ref list) }
            s : &StructInitValue => { self.finalizeStructInit (alias context, s, ref list) }
            m : &MapValue => { self.finalizeMap (alias context, m, ref list) }
            _ => {
                eprintln (l.__typeinfo__.name);
                panic;
            }
        }

        if (!asLeft) {
            return self.registerUniqValue (alias context, l, val, ref list);
        } else return val;
    }

    /**
     * Finalize a string literal
     * */
    fn finalizeStr (self, dmut context : &Expander, str : &StringValue)-> &YILValue {
        let slc = str.getType ().asOf!{&SliceType} ();
        let type = context:.finalizeType (slc);

        if (str.getLen () == 0us) {
            let len = copy YILIntValue (str.getLoc (), YIL_UINT_MAX, str.getLen ());
            return copy YILTupleValue (str.getLoc (), type, copy [len, YIL_NULL_VALUE, YIL_NULL_VALUE],
                                       fieldNames-> copy [SliceKeys::LEN, SliceKeys::PTR, SliceKeys::BLK_INFO]);
        }

        let dmut res : [u8] = [];
        let content = str.getValue ();
        let innerType = match str.getEncodingSize () {
            8u16 => {
                for i in 0us .. str.getLen () {
                    res ~= [content.utf8 [i]];
                }
                res ~= [0u8];
                YIL_UINT_8
            }
            16u16 => {
                for i in 0us .. str.getLen () {
                    let x : *u8 = cast!{*u8} (cast!{*void} (content.utf16.ptr + (i * u16::size)));
                    unsafe {
                        res ~= [x [0], x [1]];
                    }
                }
                res ~= [0u8];
                YIL_UINT_16
            }
            _ => {
                for i in 0us .. str.getLen () {
                    let x : *u8 = cast!{*u8} (cast!{*void} (content.utf32.ptr + (i * u32::size)));
                    unsafe {
                        res ~= [x [0], x [1], x [2], x [3]];
                    }
                }
                res ~= [0u8];
                YIL_UINT_32
            }
        };

        let array = copy YILStringValue (str.getLoc (), context:.getTypeExpander ():.finalizeArray (innerType, res.len), res);
        let len = copy YILIntValue (str.getLoc (), YIL_UINT_MAX, str.getLen ());
        copy YILTupleValue (str.getLoc (),
                            type,
                            copy [len, array, YIL_NULL_VALUE],
                            fieldNames-> copy [SliceKeys::LEN, SliceKeys::PTR, SliceKeys::BLK_INFO])
    }

    /**
     * Finalize a bool literal
     * */
    fn finalizeBool (self, dmut _ : &Expander, b : &BoolValue)-> &YILValue {
        copy YILIntValue (b.getLoc (), YIL_UINT_8, if b.isTrue () { 1us } else { 0us })
    }

    /**
     * Finalize a char literal
     * */
    fn finalizeChar (self, dmut context : &Expander, c : &CharValue)-> &YILValue {
        let type = context:.finalizeType (c.getType ());
        copy YILIntValue (c.getLoc (), type, c.getValueAsInt ())
    }

    /**
     * Finalize a float literal
     * */
    fn finalizeFloat (self, dmut context : &Expander, f : &FloatValue)-> &YILValue {
        let type = context:.finalizeType (f.getType ());
        copy YILFloatValue (f.getLoc (), type, f.getValue ())
    }

    /**
     * Finalize an int literal value
     * */
    fn finalizeInt (self, dmut context : &Expander, i : &IntValue)-> &YILValue {
        let type = context:.finalizeType (i.getType ());
        copy YILIntValue (i.getLoc (), type, i.getValue ())
    }

    /**
     * Finalize an array value
     * @params:
     *    - a: the array value to finalize
     *    - list: the list of statement to fill
     * @returns: the value
     * */
    fn finalizeArray (self, dmut context : &Expander, a : &ArrayValue, ref mut list : StmtList)-> &YILValue {
        let atype = context:.finalizeType (a.getType ());
        copy YILArrayValue (a.getLoc (), atype,
                            copy [self.finalize (alias context, i, ref list, asLeft-> false) for i in a.getValues ()])
    }

    /**
     * Finalize an array allocation value
     * @params:
     *     - a: the array allocation to finalize
     *     - list: the list of statement to fill
     * @returns: the value
     * */
    fn finalizeArrayAlloc (self, dmut context : &Expander, a : &ArrayAllocValue, ref mut list : StmtList)-> &YILValue {
        let type = context:.finalizeType (a.getType ());

        if (a.isDynamic ()) {
            let len = self.finalize (alias context, a.getLen (), ref list, asLeft-> false);
            let (resultVar, addrResult) = self.createVarForBlock (alias context, a.getLoc (), a.getType (), type, ref list, getAddr-> true);

            let size = if let s : &SliceType = a.getType () {
                let innerType = context:.finalizeType (s.getInners ()[0]);
                let size = copy YILIntValue (a.getLoc (), YIL_UINT_MAX, innerType.getSize ());
                size
            } else panic;

            if (a.getValue () of UnitValue) {
                list:.append (copy YILCall (a.getLoc (),
                                            copy YILNameCallValue (a.getLoc (),
                                                                   YIL_VOID,
                                                                   YRuntimeFuncs::ALLOC_NO_SET_SLICE, copy [addrResult, len, size])));
            } else {
                let valPtr = self.finalizeAddressFromAny (alias context, a.getValue (), ref list);
                list:.append (copy YILCall (a.getLoc (),
                                            copy YILNameCallValue (a.getLoc (),
                                                                   YIL_VOID, YRuntimeFuncs::ALLOC_SET_SLICE,
                                                                   copy [addrResult, valPtr, len, size])));
            }

            resultVar
        } else {
            let inner = if (a.getValue () of UnitValue) {
                YIL_UNIT_VALUE
            } else {
                self.finalize (alias context, a.getValue (), ref list, asLeft-> false)
            };

            if let i : &IntValue = a.getLen () {
                let len = i.getValue ().toT!{usize} ();
                let params = copy [inner for _ in 0 .. len];

                copy YILArrayValue (a.getLoc (), type, params)
            } else panic;
        }
    }

    /**
     * Finalize a tuple value
     * @params:
     *    - t: the tuple value to finalize
     *    - list: the list of statement to fill
     * @returns: the value
     * */
    fn finalizeTuple (self, dmut context : &Expander, t : &TupleValue, ref mut list : StmtList)-> &YILValue {
        let res = copy [self.finalize (alias context, i, ref list, asLeft-> false) for i in t.getValues ()];

        let ttype = context:.finalizeType (t.getType ());
        copy YILTupleValue (t.getLoc (), ttype, res)
    }

    /**
     * Finalize a struct init value
     * @params:
     *   - t: the struct init value to finalize
     *   - list: th elist of statement to fill
     * @returns: the value
     * */
    fn finalizeStructInit (self, dmut context : &Expander, s : &StructInitValue, ref mut list : StmtList)-> &YILValue {
        let res = copy [self.finalize (alias context, i, ref list, asLeft-> false) for i in s.getValues ()];

        let ttype = context:.finalizeType (s.getType ());
        copy YILTupleValue (s.getLoc (), ttype, res, fieldNames-> s.getFieldNames ())
    }

    /**
     * Finalize a map literal value
     * @params:
     *    - m: the map to finalize
     *    - list: the list of stmtlist to fill
     * */
    fn finalizeMap (self, dmut context : &Expander, m : &MapValue, ref mut list : StmtList)-> &YILValue {
        if let mapType : &MapType = m.getType () {
            let (mapInst, mpAddr) = self.finalizeMapInstance (alias context, m.getLoc (), mapType, ref list);

            if (m.getLen () == 0us) return mapInst;

            for i in 0us .. m.getLen () {
                let keyAddr = self.finalizeAddressFromAny (alias context, m.getKeys ()[i], ref list);
                let valueAddr = self.finalizeAddressFromAny (alias context, m.getValues ()[i], ref list);

                list:.append (copy YILCall (m.getLoc (),
                                            copy YILNameCallValue (m.getLoc (),
                                                                   YIL_VOID,
                                                                   YRuntimeFuncs::MAP_INSERT,
                                                                   copy [mpAddr, keyAddr, valueAddr])));
            }

            mapInst
        } else panic;
    }

    /**
     * Finalize the allocation of a new map instance
     * @params:
     *    - loc: the location of the creation
     *    - m: the map instance to allocate
     *    - list: the stmt list to fill
     * @returns:
     *    - .0: the map instance by value
     *    - .1: the address of the created map instance
     * */
    fn finalizeMapInstance (self, dmut context : &Expander, loc : &Word, m : &MapType, ref mut list : StmtList)-> (&YILValue, &YILValue) {
        let mtype = context:.finalizeType (m);
        let vtableName = context.getMangler ().mangleMapInfo (m);
        context:.registerTouchSym (vtableName, m.getLoc ());

        let vtableAddr = copy YILAddrValue (loc, YIL_PTR_2_VOID, copy YILVar (loc, vtableName, YIL_PTR_VOID, 0us));

        let (res, resAddr) = self.createVarForBlock (alias context, loc, NONE_TYPE, mtype, ref list, name-> "__map_%"s8, getAddr-> true);
        list:.append (copy YILCall (loc,
                                    copy YILNameCallValue (loc, YIL_VOID, YRuntimeFuncs::MAP_EMPTY, copy [resAddr, vtableAddr])));

        (res, resAddr)
    }

    /*!
     * =====================================================================================
     * =====================================================================================
     * ======================            OPERATOR EXPANSION           ======================
     * =====================================================================================
     * =====================================================================================
     */

    /**
     * Finalize an operator value
     * @params:
     *    - op: the operator to finalize
     *    - list: the list of stmtlist to fill
     * */
    fn finalizeOperator (self, dmut context : &Expander, op : &OperatorValue, ref mut list : StmtList, asLeft : bool)-> &YILValue {
        match op {
            a : &AffectValue => { self.finalizeAffect (alias context, a, ref list) }
            c : &CallOperatorValue => { self.finalizeCall (alias context, c, ref list) }
            b : &BinaryOperatorValue => { self.finalizeBinary (alias context, b, ref list, asLeft-> asLeft) }
            f : &FieldOperatorValue => { self.finalizeField (alias context, f, ref list, asLeft-> asLeft) }
            s : &SliceOrArrayOperatorValue => { self.finalizeSliceOrArrayOp (alias context, s, ref list, asLeft-> asLeft) }
            m : &MapOperatorValue => { self.finalizeMapOp (alias context, m, ref list) }
            u : &UnaryOperatorValue => { self.finalizeUnary (alias context, u, ref list, asLeft-> asLeft) }
            _ => {
                eprintln (op.__typeinfo__.name);
                panic;
            }
        }
    }

    /**
     * Finalize an affectation operation
     * @params:
     *     - a: the affectation operation to validate
     *     - list: the list of statement to fill
     * @returns: the left operand
     * */
    fn finalizeAffect (self, dmut context : &Expander, a : &AffectValue, ref mut list : StmtList)-> &YILValue {
        let left = self.finalize (alias context, a.getLeft (), ref list, asLeft-> true);
        let right = self.finalize (alias context, a.getRight (), ref list, asLeft-> false);

        self.finalizeAffect (alias context, a.getLoc (), left, right, ref list);

        left
    }

    /**
     * Finalize an affection moving value from left to right
     * */
    fn finalizeAffect (self, dmut context : &Expander, loc : &Word, left : &YILValue, right : &YILValue, ref mut list : StmtList) {
        context;
        if (left !of YILUnit && right !of YILUnit) {
            self.removeDestroy (right, ref list);
            list:.append (copy YILAffect (loc, left, right));
        }
    }

    /**
     * Finalize a binary operator value
     * @params:
     *    - b: the binary operator to finalize
     *    - list: the list of statement to fill
     * @returns: the finalized binary
     * */
    fn finalizeBinary (self, dmut context : &Expander, b : &BinaryOperatorValue, ref mut list : StmtList, asLeft : bool)-> &YILValue {
        match b {
            bl : &LogicalBinBoolOperatorValue => { return self.finalizeLogicalBool (alias context, bl, ref list); }
            r : &RangeContainValue => { return self.finalize (alias context, r.getCall (), ref list, asLeft-> asLeft); }
            s : &SpecialMathIntOperatorValue => { return self.finalize (alias context, s.getCall (), ref list, asLeft-> asLeft); }
            f : &SpecialMathFloatOperatorValue => { return self.finalize (alias context, f.getCall (), ref list, asLeft-> asLeft); }
            a : &SpecialArrayOperatorValue => { return self.finalize (alias context, a.getCall (), ref list, asLeft-> asLeft); }
            c : &CmpClassTypeOperatorValue => { return self.finalizeClassTypeCmp (alias context, c, ref list); }
        }

        match context.getVariable (b.getUniqId ()) {
            Ok (u : &YILValue) => { // The call was already seen and validated
                return u;
            }
        };

        let left = self.finalize (alias context, b.getLeft (), ref list, asLeft-> asLeft);
        let right = self.finalize (alias context, b.getRight (), ref list, asLeft-> false);

        let type = context:.finalizeType (b.getType ());
        let ret = copy YILBinaryValue (b.getLoc (), type, b.getOperator (), left, right);

        if (!asLeft) {
            return self.registerUniqValue (alias context, b, ret, ref list);
        } else return ret;
    }

    /**
     * Fianlize a logical bool operator
     * @params:
     *    - b: the bool operator to finalize
     *    - list: the list of stmt to fill
     * @returns: the value of the expression
     * */
    fn finalizeLogicalBool (self, dmut context : &Expander, b : &LogicalBinBoolOperatorValue, ref mut list : StmtList)-> &YILValue {
        let mut rightList = StmtList ();
        let left = self.finalize (alias context, b.getLeft (), ref list, asLeft-> false);
        let right = self.finalize (alias context, b.getRight (), ref rightList, asLeft-> false);

        let leftVar = if (left !of YILVar && left !of YILIntValue) {
            let (leftVar, _) = self.createVarForBlock (alias context,
                                                       b.getLoc (), NONE_TYPE, left.getType (), ref list, withValue-> left);
            leftVar
        } else {
            left
        };

        let type = context:.finalizeType (b.getType ());
        let (var, _) = self.createVarForBlock (alias context, b.getLoc (), b.getType (), type, ref list);
        let mut ifL = StmtList (), mut ifNL = StmtList ();

        if (b.getOperator () == BinaryOperators::DAND) { // let leftVar = left; if (leftVar) { right } else { leftVar }
            ifL:.append (rightList);
            ifL:.append (copy YILAffect (b.getLoc (), var, right));
            ifNL:.append (copy YILAffect (b.getLoc (), var, leftVar));
        } else { // operator == ||, let leftVar = left; if (leftVar) { leftVar } else { right }
            ifL:.append (copy YILAffect (b.getLoc (), var, leftVar));

            ifNL:.append (rightList);
            ifNL:.append (copy YILAffect (b.getLoc (), var, right));
        };

        self.finalizeCond (b.getLoc (), alias context, ref list, leftVar, ifL, ifNL);
        var
    }

    /**
     * Finalize a class type comparison operator
     * @params:
     *    - c: the class cmp operator to finalize
     *    - list: the list of stmt to fill
     * @returns: the value of the expression
     * */
    fn finalizeClassTypeCmp (self, dmut context : &Expander, c : &CmpClassTypeOperatorValue, ref mut list : StmtList)-> &YILValue {
        let left = if let r : &ReferencerValue = c.getLeft () { // can be a reference value if this test is inside a pattern matching
            // i don't really know if it should be tested there (binary operator validator) or here
            self.finalize (alias context, r.getValue (), ref list, asLeft-> false)
        } else {
            self.finalize (alias context, c.getLeft (), ref list, asLeft-> false)
        };

        let derefInst = if let p : &YILPointer = left.getType () {
            copy YILUnrefValue (c.getLoc (), p.getInner (), left)
        } else panic;

        let rightTypeInfoName = context.getMangler ().mangleTypeInfo (c.getRType ());
        context:.registerTouchSym (rightTypeInfoName, c.getRType ().getLoc ());

        let rTypeInfo = copy YILAddrValue (c.getLoc (), YIL_PTR_2_VOID,
                                           copy YILVar (c.getLoc (), rightTypeInfoName, YIL_PTR_2_VOID, 0us));

        let lvtable = copy YILFieldValue (c.getLoc (), YIL_PTR_2_VOID, derefInst, name-> "#_vtable"s8);
        let (vtableAddrU, _) = self.createVarForBlock (alias context,
                                                       c.getLoc (),
                                                       NONE_TYPE,
                                                       YIL_PTR_2_VOID, ref list, withValue-> lvtable);

        let call = copy YILNameCallValue (c.getLoc (),
                                          YIL_UINT_8,
                                          YRuntimeFuncs::CMP_CLASS_OF_TYPE,
                                          copy [rTypeInfo, vtableAddrU]);

        if (c.getOperator () == BinaryOperators::NOT_OF) {
            let (resCall, _) = self.createVarForBlock (alias context, c.getLoc (), NONE_TYPE, YIL_UINT_8, ref list, withValue-> call);
            copy YILUnaryValue (c.getLoc (), YIL_UINT_8, UnaryOperators::NOT, resCall)
        } else {
            call
        }
    }

    /**
     * Finalize an unary operator
     * @params:
     *    - context: the context of the expansion
     *    - u: the unary operator to finalize
     *    - list: the list of statement to fill
     * */
    fn finalizeUnary (self, dmut context : &Expander, u : &UnaryOperatorValue, ref mut list : StmtList, asLeft : bool)-> &YILValue {
        let value = self.finalize (alias context, u.getOperand (), ref list, asLeft-> asLeft);
        let type = context:.finalizeType (u.getType ());

        copy YILUnaryValue (u.getLoc (), type, u.getOperator (), value)
    }

    /*!
     * =====================================================================================
     * =====================================================================================
     * ========================            FIELD EXPANSION           =======================
     * =====================================================================================
     * =====================================================================================
     */

    /**
     * Finalize a field access value
     * @params:
     *    - f : the field access to finalize
     *    - list: the list of statement to fill
     * @returns: the value of the access
     * */
    fn finalizeField (self, dmut context : &Expander, f : &FieldOperatorValue, ref mut list : StmtList, asLeft : bool)-> &YILValue {
        match f {
            c : &ClassFieldAccessValue => { self.finalizeClassFieldAccess (alias context, c, ref list) }
            c : &ClosureFieldAccessValue => { self.finalizeClosureFieldAccess (alias context, c, ref list) }
            s : &StructFieldAccessValue => { self.finalizeStructFieldAccess (alias context, s, ref list, asLeft-> asLeft) }
            t : &TupleFieldAccessValue => { self.finalizeTupleFieldAccess (alias context, t, ref list, asLeft-> asLeft) }
            o : &OptionFieldAccessValue => { self.finalizeOptionFieldAccess (alias context, o, ref list, asLeft-> asLeft) }
            t : &FutureFieldAccessValue => { self.finalizeFutureFieldAccess (alias context, t, ref list) }
            c : &ClassTypeInfoAccessValue => { self.finalizeClassTypeInfoAccess (alias context, c, ref list) }
            e : &EnumFieldAccessValue => { self.finalize (alias context, e.getContent (), ref list, asLeft-> asLeft) }
            m : &MapLenAccessValue => { self.finalizeMapLenAccess (alias context, m, ref list) }
            _ => {
                eprintln (f.__typeinfo__.name);
                panic;
            }
        }
    }

    /**
     * Finalize the access of a field in a class value
     * @params:
     *    - f: the field access to finalize
     *    - list: the list of statement to fill
     * */
    fn finalizeClassFieldAccess (self, dmut context : &Expander, f : &ClassFieldAccessValue, ref mut list : StmtList)-> &YILValue {
        context:.registerTouchClass (f.getClassInstance ().getType ());

        let cl = self.finalize (alias context, f.getClassInstance (), ref list, asLeft-> false);
        let clType = context:.getTypeExpander ():.finalize (alias context, f.getClassInstance ().getType ());
        let retType = context:.finalizeType (f.getType ());

        let clR = if let p : &YILPointer = clType {
            copy YILUnrefValue (f.getLoc (), p.getInner (), cl)
        } else panic;

        copy YILFieldValue (f.getLoc (), retType, clR, name-> f.getFieldName ())
    }

    /**
     * Finalize the access of a field in a closure value
     * @params:
     *    - f: the field access to finalize
     *    - list: the list of statement to fill
     * */
    fn finalizeClosureFieldAccess (self, dmut context : &Expander, f : &ClosureFieldAccessValue, ref mut list : StmtList)-> &YILValue {
        let cl = self.finalize (alias context, f.getClosure (), ref list, asLeft-> false);
        let retType = context:.finalizeType (f.getType ());
        let clR = if let p : &YILPointer = cl.getType () {
            copy YILUnrefValue (f.getLoc (), p.getInner (), cl)
        } else panic;

        if f.byRef () {
            let ptr = copy YILPointer (retType);
            let val = copy YILFieldValue (f.getLoc (), ptr, clR, index-> f.getFieldIndex ());

            return copy YILUnrefValue (f.getLoc (), retType, val);
        }

        copy YILFieldValue (f.getLoc (), retType, clR, index-> f.getFieldIndex ())
    }

    /**
     * Finalize the access of a field in a struct value
     * @params:
     *    - f: the field access to finalize
     *    - list: the list of statement to fill
     * */
    fn finalizeStructFieldAccess (self, dmut context : &Expander, f : &StructFieldAccessValue, ref mut list : StmtList, asLeft : bool)-> &YILValue {
        context:.registerTouchClass (f.getStruct ().getType ());

        let retType = context:.finalizeType (f.getType ());
        let str = self.finalize (alias context, f.getStruct (), ref list, asLeft-> asLeft);

        copy YILFieldValue (f.getLoc (), retType, str, name-> f.getFieldName ())
    }

    /**
     * Finalize the access of a field in an option value
     * @params:
     *    - o: the field access to finalize
     *    - list: the list of statement to fill
     * */
    fn finalizeOptionFieldAccess (self, dmut context : &Expander, o : &OptionFieldAccessValue, ref mut list : StmtList, asLeft : bool)-> &YILValue {
        let retType = context:.finalizeType (o.getType ());
        let opt = self.finalize (alias context, o.getOption (), ref list, asLeft-> asLeft);

        let optContentType = if let t : &YILTuple = opt.getType () {
            t.getInners ()[1]
        } else panic;

        // a.error => a.content.error, a.value => a.content.value
        let content = copy YILFieldValue (o.getLoc (), optContentType, opt, name-> OptionKeys::CONTENT);
        copy YILFieldValue (o.getLoc (), retType, content, name-> o.getFieldName ())
    }

    /**
     * Finalize the access of a field in a future value
     * @params:
     *    - f: the field access to finalize
     *    - list: the list of statement to fill
     * */
    fn finalizeFutureFieldAccess (self, dmut context : &Expander, f : &FutureFieldAccessValue, ref mut list : StmtList)-> &YILValue {
        match f.getFieldName () {
            FutureKeys::VALUE => {
                self.finalizeFutureWait (alias context, f, ref list)
            }
            FutureKeys::FINISHED => {
                self.finalizeFutureCheck (alias context, f, ref list)
            }
            FutureKeys::THREAD_ID => {
                self.finalizeFutureThreadId (alias context, f, ref list)
            }
            _ => panic;
        }
    }

    /**
     * @returns: the access to the id of the future thread
     * */
    fn finalizeFutureThreadId (self, dmut context : &Expander, f : &FutureFieldAccessValue, ref mut list : StmtList)-> &YILValue {
        let retType = context:.finalizeType (f.getType ());
        let futureValue = self.finalize (alias context, f.getFuture (), ref list, asLeft-> false);

        return copy YILFieldValue (f.getLoc (), retType, futureValue, name-> FutureKeys::THREAD_ID);
    }

    /**
     * Finalize the wait of a future value
     * @params:
     *    - context: the context of the expansion
     *    - f: the field access to finalize
     *    - list: the list of statement to fill
     * */
    fn finalizeFutureWait (self, dmut context : &Expander, f : &FutureFieldAccessValue, ref mut list : StmtList)-> &YILValue {
        let retType = context:.finalizeType (f.getType ());
        match context.getVariable (f.getUniqId ()) {
            Ok (u : &YILValue) => { // The call was already seen and validated
                return copy YILUnrefValue (f.getLoc (), retType, u);
            }
        };


        let futureValue = self.finalize (alias context, f.getFuture (), ref list, asLeft-> false);
        let call = copy YILNameCallValue (f.getLoc (),
                                          context:.getTypeExpander ():.finalizePointer (retType),
                                          YRuntimeFuncs::WAIT_FUTURE,
                                          copy [futureValue]);

        let varRes = self.registerUniqValue (alias context, f, type-> call.getType (), call, ref list);
        return copy YILUnrefValue (f.getLoc (), retType, varRes);
    }

    /**
     * Finalize the checking of a future value
     * @params:
     *    - context: the context of the expansion
     *    - f: the field access to finalize
     *    - list: the list of statement to fill
     * */
    fn finalizeFutureCheck (self, dmut context : &Expander, f : &FutureFieldAccessValue, ref mut list : StmtList)-> &YILValue {
        let retType = context:.finalizeType (f.getType ());
        match context.getVariable (f.getUniqId ()) {
            Ok (u : &YILValue) => { // The call was already seen and validated
                return u;
            }
        };


        let futureValue = self.finalize (alias context, f.getFuture (), ref list, asLeft-> false);
        let call = copy YILNameCallValue (f.getLoc (), retType, YRuntimeFuncs::CHECK_FUTURE, copy [futureValue]);

        self.registerUniqValue (alias context, f, type-> call.getType (), call, ref list)
    }

    /**
     * Finalize the access of a field in a tuple value
     * @params:
     *    - f: the field access to finalize
     *    - list: the list of statement to fill
     * */
    fn finalizeTupleFieldAccess (self, dmut context : &Expander, f : &TupleFieldAccessValue, ref mut list : StmtList, asLeft : bool)-> &YILValue {
        let retType = context:.finalizeType (f.getType ());
        let str = self.finalize (alias context, f.getTuple (), ref list, asLeft-> asLeft);

        copy YILFieldValue (f.getLoc (), retType, str, index-> f.getFieldIndex ())
    }

    /**
     * Finalize the access of the typeinfo of an object instance
     * @params:
     *    - ti:  the access to finalize
     *    - list: the list of stmt to fill
     * */
    fn finalizeClassTypeInfoAccess (self, dmut context : &Expander, ti : &ClassTypeInfoAccessValue, ref mut list : StmtList)-> &YILValue {
        context:.registerTouchClass (ti.getClassInstance ().getType ());

        let loc = ti.getLoc ();
        let inst = self.finalize (alias context, ti.getClassInstance (), ref list, asLeft-> false);

        let (instU, _) = self.createVarForBlock (alias context, loc, NONE_TYPE, inst.getType (), ref list, withValue-> inst);
        let derefInst = if let p : &YILPointer = inst.getType () {
            copy YILUnrefValue (loc, p.getInner (), instU)
        } else panic;

        let vtableAddr = copy YILFieldValue (loc, YIL_PTR_2_VOID, derefInst, name-> "#_vtable"s8);
        let typeInfoT = context:.finalizeType (ti.getType ());
        let (vtableAddrU, _) = self.createVarForBlock (alias context, loc, NONE_TYPE, YIL_PTR_2_VOID, ref list, withValue-> vtableAddr); // vtable => [*typeinfo, *dtor, *method1, ..., *methodN]

        let tiPtr = copy YILCastValue (loc, context:.getTypeExpander ():.finalizePointer (typeInfoT), copy YILUnrefValue (loc, YIL_PTR_VOID, vtableAddrU));
        copy YILUnrefValue (loc, typeInfoT, tiPtr)
    }

    /**
     * Finalize the access of the len of a map value
     * */
    fn finalizeMapLenAccess (self, dmut context : &Expander, f : &MapLenAccessValue, ref mut list : StmtList)-> &YILValue {
        let retType = context:.finalizeType (f.getType ());
        let mp = self.finalize (alias context, f.getObject (), ref list, asLeft-> false);

        if let t : &YILPointer = mp.getType () {
            let contentType = t.getInner ();
            let unref = copy YILUnrefValue (f.getLoc (), contentType, mp);

            copy YILFieldValue (f.getLoc (), retType, unref, name-> MapKeys::LEN)
        } else panic;
    }

    /*!
     * =====================================================================================
     * =====================================================================================
     * ========================            CALL EXPANSION           ========================
     * =====================================================================================
     * =====================================================================================
     */

    /**
     * Finalize a call operator value
     * @params:
     *    - c: the call operator to validate
     *    - list: the list of statement to fill
     * @returns: the value of the call if any
     * */
    fn finalizeCall (self, dmut context : &Expander, c : &CallOperatorValue, ref mut list : StmtList)-> &YILValue {

        // Call of function performs heavy computation with possible side effects
        // Function call must appear only once in the finalized code
        match context.getVariable (c.getUniqId ()) {
            Ok (u : &YILValue) => { // The call was already seen and validated
                return u;
            }
        };

        let call = match c {
            ca : &CallValue => { self.finalizeSimpleCall (alias context, ca, ref list) }
            ctor : &CtorCallValue => { self.finalizeCtorCall (alias context, ctor, ref list) }
            fptr : &FuncPtrCallValue => { self.finalizeFuncPtrCall (alias context, fptr, ref list) }
            meth : &MethodCallValue => { self.finalizeMethodCall (alias context, meth, ref list) }
            _ => {
                eprintln (c.__typeinfo__.name);
                panic;
            }
        };

        let result = self.registerUniqValue (alias context, c, call, ref list);
        if (result of YILUnit) {
            list:.append (copy YILCall (c.getLoc (), call));
        } else if (c.getType ().isMovable ()) {
            if let v : &YILVar = result {
                self.registerDestroy (alias context, v, c.getType (), ref list, implicit-> true);
            } else panic;
        }

        result
    }

    /**
     * Finalize a simple call value
     * @params:
     *   - c: the call value to finalize
     *   - list: the statement list to fill
     * @returns: the value of the call
     * */
    fn finalizeSimpleCall (self, dmut context : &Expander, c : &CallValue, ref mut list : StmtList)-> &YILValue {
        let retType = context:.finalizeType (c.getType ());

        let mut params : [&YILValue] = [];
        for i in c.getParameters () {
            let p = self.finalize (alias context, i, ref list, asLeft-> false);
            self.removeDestroy (p, ref list);
            params ~= [p];
        }

        for i in c.getAddParameters () {
            let p = self.finalize (alias context, i, ref list, asLeft-> false);
            self.removeDestroy (p, ref list);
            params ~= [p];
        }

        let name = context.getMangler ().mangle (c.getPrototype ());
        context:.registerTouchSym (name, c.getPrototype ().getImplLoc ());

        copy YILNameCallValue (c.getLoc (), retType, name, params)
    }

    /**
     * Finalize a class ctor call value
     * @params:
     *     -
     * */
    fn finalizeCtorCall (self, dmut context : &Expander, c : &CtorCallValue, ref mut list : StmtList)-> &YILValue {
        let retType = context:.finalizeType (c.getType ());
        let (inst, value) = self.finalizeCtorSelf (alias context, c.getLoc (), retType, c.getType (), c.getCtor ().getInstance (), ref list);

        let mut params : [&YILValue] = [];
        params ~= [inst];
        for pi in c.getParameters () {
            let p = self.finalize (alias context, pi, ref list, asLeft-> false);
            self.removeDestroy (p, ref list);
            params ~= [p];
        }
        for pi in c.getAddParameters () {
            let p = self.finalize (alias context, pi, ref list, asLeft-> false);
            self.removeDestroy (p, ref list);
            params ~= [p];
        }

        // Class takes a last parameter in ctor calls
        if !c.getCtor ().getPrototype ().getClassRef ().isStruct () {
            let delegate = c.getCtor ();
            if delegate.getNextCtor () !of UnitValue {
                let p = self.finalize (alias context, delegate.getNextCtor (), ref list, asLeft-> false);
                params ~= [p];
            } else {
                let dgYType = context:.getTypeExpander ():.finalizeDelegate ();
                let emptyDG = copy YILTupleValue (c.getLoc (), dgYType,
                                                  copy [YIL_NULL_VALUE, YIL_NULL_VALUE],
                                                  fieldNames-> copy [DelegateKeys::CLOSURE, DelegateKeys::FUNC]);

                params ~= [emptyDG];
            }
        }

        let name = context.getMangler ().mangle (c.getCtor ().getPrototype ());
        context:.registerTouchSym (name, c.getCtor ().getPrototype ().getLoc ());

        list:.append (copy YILCall (c.getLoc (), copy YILNameCallValue (c.getLoc (), YIL_VOID, name, params)));
        value
    }

    /**
     * Finalize the creation of a new class instance, that is not constructed but only allocated
     * @params:
     *     - loc: the location of the ctor construction
     *     - clType: the ClassPtr version of the type of the class to construct
     *     - inst: the instance value generator (if nonevalue, then call class allocation)
     *     - list: the list to fill
     * @returns:
     *    - .0: the value to pass to the ctor
     *    - .1: the instance of the class
     * */
    fn finalizeCtorSelf (self, dmut context : &Expander, loc : &Word, retType : &YILType, clType : &Type, inst : &Value, ref mut list : StmtList)-> (&YILValue, &YILValue) {
        // We gave a value to the ctor
        if (inst !of UnitValue)  {
            let inner = self.finalize (alias context, inst, ref list, asLeft-> true);
            if let cptr : &ClassPtrType = clType && cptr.isStruct () {
                match (inner, inst) {
                    // redirection call from previous generated instance in a ctor of structure
                    (un : &YILUnrefValue, v : &VarRefValue) if (v.isReference () && v.isSelf ()) => {
                        return (un.getValue (), un.getValue ());
                    }
                }
            }

            return (inner, inner);
        }

        let (varref, _) = self.createVarForBlock (alias context, loc, NONE_TYPE, retType, ref list, name-> "__self_%"s8);
        if let cptr : &ClassPtrType = clType {
            if (cptr.isStruct ()) {
                if (cptr.getSymbol ().isEntity ()) {
                    let field = copy YILFieldValue (loc, YIL_UINT_8, varref, name-> ClassKeys::SET);
                    list:.append (copy YILAffect (loc, field, copy YILIntValue (loc, YIL_UINT_8, 1us)));
                }

                return (copy YILAddrValue (varref.getLoc (), context:.getTypeExpander ():.finalizePointer (retType), varref), varref);
            } else {
                let clRef = {
                    cptr.getInner ()
                } catch {
                    _ => panic; // invalid class
                };

                let vtableName = context.getMangler ().mangleVtable (clRef);
                context:.registerTouchSym (vtableName, clRef.getLoc ());

                let vtableAddr = copy YILAddrValue (loc, YIL_PTR_2_VOID,
                                                    copy YILVar (loc, vtableName, YIL_PTR_2_VOID, 0us));

                let callVal = copy YILNameCallValue (loc, retType, YRuntimeFuncs::ALLOC_CLASS, copy [vtableAddr]);
                list:.append (copy YILAffect (loc, varref, callVal));

                return (varref, varref);
            }
        } else panic;
    }

    /**
     * Finalize a call to a function pointer
     * @params:
     *    - f: the function pointer to finalize
     *    - list: the list of statement to fill
     * @returns: the call
     * */
    fn finalizeFuncPtrCall (self, dmut context : &Expander, f : &FuncPtrCallValue, ref mut list : StmtList)-> &YILValue {
        let retType = context:.finalizeType (f.getType ());

        let mut params : [&YILValue] = [];
        for pi in f.getParameters () {
            let p = self.finalize (alias context, pi, ref list, asLeft-> false);
            self.removeDestroy (p, ref list);
            params ~= [p];
        }

        if let n : &ProtoFuncPtrValue = f.getFuncPtr () {
            let proto = context.getMangler ().mangle (n.getPrototype ());
            context:.registerTouchSym (proto, n.getPrototype ().getImplLoc ());

            return copy YILNameCallValue (f.getLoc (), retType, proto, params);
        } else {
            let fptr = self.finalize (alias context, f.getFuncPtr (), ref list, asLeft-> false);
            return copy YILPtrCallValue (f.getLoc (), retType, fptr, params);
        }
    }

    /**
     * Finalize a call to a method value
     * @params:
     *     - f: the method call to finalize
     *     - list: the list of statement to fill
     * @returns: the result of the call
     * */
    fn finalizeMethodCall (self, dmut context : &Expander,  f : &MethodCallValue, ref mut list : StmtList)-> &YILValue {
        let methProto = f.getMethod ();
        context:.registerTouchClass (methProto.getClosure ().getType ());

        let retType = context:.finalizeType (f.getType ());

        let mut params : [&YILValue] = [];
        let mut inst = self.finalize (alias context, methProto.getClosure (), ref list, asLeft-> false);

        let isDirect = {
            if let c : &ClassPtrType = methProto.getClosure ().getType () && c.isStruct () {
                inst = self.createAddress (alias context, inst, context:.getTypeExpander ():.finalizePointer (inst.getType ()), ref list);
                true
            } else {
                methProto.isDirect ()
            }
        };

        params ~= [inst];
        self.removeDestroy (inst, ref list);
        for pi in f.getParameters () {
            let p = self.finalize (alias context, pi, ref list, asLeft-> false);
            self.removeDestroy (p, ref list);
            params ~= [p];
        }

        for pi in f.getAddParameters () {
            let p = self.finalize (alias context, pi, ref list, asLeft-> false);
            self.removeDestroy (p, ref list);
            params ~= [p];
        }

        if (isDirect) {
            let name = context.getMangler ().mangle (methProto.getPrototype ());
            context:.registerTouchSym (name, methProto.getPrototype ().getImplLoc ());

            return copy YILNameCallValue (f.getLoc (), retType, name, params);
        } else {
            let fptr = self.createVtableAccess (alias context, f.getLoc (), inst, methProto.getVtableIndex (), ref list);
            return copy YILPtrCallValue (f.getLoc (), retType, fptr, params);
        }
    }

    /**
     * Access a method from the vtable of a class instance
     * @params:
     *    - loc: the location of the access
     *    - proto: the proto value, defining the type of the final value
     *    - index: the index of the function in the vtable
     * @returns: the address of the method to call
     * */
    fn createVtableAccess (self, dmut context : &Expander, loc : &Word, inst : &YILValue, index : usize, ref mut list : StmtList)-> &YILValue {
        let ptrSize = global::state::instance ().getSizeTypeSize () / 8us;

        let generic = context:.getTypeExpander ():.finalizeGenericClassPtr (alias context);
        let castedInst = copy YILCastValue (loc, generic, inst);

        let derefInst = if let p : &YILPointer = generic {
            copy YILUnrefValue (loc, p.getInner (), castedInst)
        } else panic;

        let vtableAddr = copy YILCastValue (loc, YIL_PTR_VOID, // cast to a ptr of void, because we will do some pointer arithmethics on it
                                            // and '*(*void) + x' is not the same as '*(void) + x'
                                            copy YILFieldValue (loc, YIL_PTR_2_VOID, derefInst, name-> ClassKeys::VTABLE));

        let (vtableAddrU, _) = self.createVarForBlock (alias context, loc, NONE_TYPE, YIL_PTR_VOID, ref list, withValue-> vtableAddr);

        // +1us because 0 is the dtor
        let funcInVtableAddr = copy YILCastValue (loc, YIL_PTR_2_VOID,
                                                  copy YILBinaryValue (loc,
                                                                       YIL_PTR_VOID,
                                                                       BinaryOperators::PLUS,
                                                                       vtableAddrU,
                                                                       copy YILIntValue (loc, YIL_UINT_MAX, (index + 2us) * cast!{usize} (ptrSize))));
        // [TYPEINFO, DTOR, funcs*]

        let (funcInVtableAddrU, _) = self.createVarForBlock (alias context, loc, NONE_TYPE, YIL_PTR_2_VOID, ref list, withValue-> funcInVtableAddr);
        let unref = copy YILUnrefValue (loc, YIL_PTR_2_VOID.getInner (), funcInVtableAddrU); // recast the vtable to the correct array
        let (funcVU, _) = self.createVarForBlock (alias context, loc, NONE_TYPE, YIL_PTR_VOID, ref list, withValue-> unref);

        funcVU
    }

    /*!
     * =====================================================================================
     * =====================================================================================
     * =====================            SLICE/ARRAY EXPANSION           ====================
     * =====================================================================================
     * =====================================================================================
     */

    /**
     * Finalize an operator on slice or array operands
     * @params:
     *    - sl: the operator to finalize
     *    - list: the list of statement to fill
     * */
    fn finalizeSliceOrArrayOp (self, dmut context : &Expander, sl : &SliceOrArrayOperatorValue, ref mut list : StmtList, asLeft : bool)-> &YILValue {
        match sl {
            a : &ArrayAccessValue => { self.finalizeArrayAccess (alias context, a, ref list) }
            a : &SliceAppendValue => { self.finalizeSliceAppend (alias context, a, ref list) }
            c : &SliceConcatValue => { self.finalizeSliceConcat (alias context, c, ref list) }
            s : &SliceAccessValue => { self.finalizeSliceAccess (alias context, s, ref list, asLeft-> asLeft) }
            s : &SliceCompareValue => { self.finalizeSliceCompare (alias context, s, ref list) }
            _ => {
                eprintln (sl.__typeinfo__.name);
                panic;
            }
        }
    }

    /**
     * Finalize an array access value
     * @params:
     *    - context: the context of the finalization
     *    - a: the array access to finalize
     *    - list: the list of statement to fill
     * */
    fn finalizeArrayAccess (self, dmut context : &Expander, a : &ArrayAccessValue, ref mut list : StmtList)-> &YILValue {
        let arr = self.finalize (alias context, a.getArray (), ref list, asLeft-> true);
        let index = self.finalize (alias context, a.getIndex (), ref list, asLeft-> false);
        let type = context:.finalizeType (a.getType ());

        copy YILArrayAccessValue (a.getLoc (), type, arr, index)
    }

    /**
     * Finalize a slice concatenation operation
     * @params:
     *    - context: the context of the finalization
     *    - a: the slice concat to finalize
     *    - list: the list of statement to fill
     * */
    fn finalizeSliceConcat (self, dmut context : &Expander, s : &SliceConcatValue, ref mut list : StmtList)-> &YILValue {
        // Slice concat allocates values, thus must be performed only once
        match context.getVariable (s.getUniqId ()) {
            Ok (u : &YILValue) => { // The call was already seen and validated
                return u;
            }
        };

        if let slc : &SliceType = s.getType () {
            let leftAddr = self.finalizeAddressFromAny (alias context, s.getLeft (), ref list);
            let rightAddr = self.finalizeAddressFromAny (alias context, s.getRight (), ref list);
            let type = context:.finalizeType (slc);
            let inner = context:.finalizeType (slc.getInners ()[0]);
            let size = copy YILIntValue (s.getLoc (), YIL_UINT_MAX, inner.getSize ());

            let (resultVar, addrResult) = self.createVarForBlock (alias context, s.getLoc (), slc, type, ref list, getAddr-> true);
            list:.append (copy YILCall (s.getLoc (),
                                        copy YILNameCallValue (s.getLoc (),
                                                               YIL_VOID,
                                                               YRuntimeFuncs::CONCAT_SLICE,
                                                               copy [addrResult, leftAddr, rightAddr, size])));

            return self.registerUniqValue (alias context, s, resultVar, ref list);
        } else panic;
    }

    /**
     * Finalize a slice append operation
     * @params:
     *    - context: the context of the finalization
     *    - a: the slice append to finalize
     *    - list: the list of statement to fill
     * */
    fn finalizeSliceAppend (self, dmut context : &Expander, a : &SliceAppendValue, ref mut list : StmtList)-> &YILValue {
        let leftAddr = self.finalizeAddressFromAny (alias context, a.getLeft (), ref list);
        let right = self.finalize (alias context, a.getRight (), ref list, asLeft-> false);

        if let slc : &SliceType = a.getLeft ().getType () {
            let inner = context:.finalizeType (slc.getInners ()[0]);
            let innerSize = copy YILIntValue (a.getLoc (), YIL_UINT_MAX, inner.getSize ());

            let (_, ptrU) = self.createVarForBlock (alias context, a.getLoc (), a.getRight ().getType (), right.getType (), ref list, withValue-> right, getAddr-> true);
            list:.append (copy YILCall (a.getLoc (),
                                        copy YILNameCallValue (a.getLoc (),
                                                               YIL_VOID,
                                                               YRuntimeFuncs::APPEND_SLICE,
                                                               copy [leftAddr, ptrU, innerSize])));

            YIL_UNIT_VALUE
        } else panic;
    }

    /**
     * Finalize a slice access value
     * @params:
     *    - context: the context of the finalization
     *    - s: the slice access to finalize
     *    - list: the list of statement to fill
     * */
    fn finalizeSliceAccess (self, dmut context : &Expander, s : &SliceAccessValue, ref mut list : StmtList, asLeft : bool)-> &YILValue {
        let slc = self.finalize (alias context, s.getSlice (), ref list, asLeft-> asLeft);
        let index = self.finalize (alias context, s.getIndex (), ref list, asLeft-> false);

        let resType = context:.finalizeType (s.getType ());
        let size = copy YILIntValue (s.getLoc (), YIL_UINT_MAX, resType.getSize ());

        let indexV = copy YILBinaryValue (s.getLoc (), YIL_UINT_MAX, BinaryOperators::STAR, size, index);
        let (indexVU, _) = self.createVarForBlock (alias context, s.getLoc (), NONE_TYPE, YIL_UINT_MAX, ref list, withValue-> indexV);
        let ptrT = context:.getTypeExpander ():.finalizePointer (resType);

        let dataField = copy YILBinaryValue (s.getLoc (),
                                             YIL_PTR_VOID,
                                             BinaryOperators::PLUS,
                                             copy YILFieldValue (s.getLoc (), YIL_PTR_VOID, slc, name-> SliceKeys::PTR),
                                             indexVU);

        let (dataFieldU, _) = self.createVarForBlock (alias context, s.getLoc (), NONE_TYPE, YIL_UINT_MAX, ref list, withValue-> dataField);
        let finalPtrV = copy YILCastValue (s.getLoc (), ptrT, dataFieldU);
        copy YILUnrefValue (s.getLoc (),
                            resType,
                            self.registerUniqValue (alias context, s, type-> ptrT, finalPtrV, ref list))
    }

    /**
     * Finalize the comparison of two slices
     * @params:
     *    - context: the context of the finalization
     *    - s: the slice compare to finalize
     *    - list: the list of statement to fill
     * */
    fn finalizeSliceCompare (self, dmut context : &Expander, s : &SliceCompareValue, ref mut list : StmtList)-> &YILValue {
        context;
        s;
        list;
        panic;
    }


    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =================================          MAP EXPANSION          ==================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Finalize a map operation
     * @params:
     *    - context: the context of the finalization
     *    - m: the map value to validate
     *    - list: the list of statement to fill
     * */
    fn finalizeMapOp (self, dmut context : &Expander, m : &MapOperatorValue, ref mut list : StmtList)-> &YILValue {
        match m {
            a : &MapAccessValue => { self.finalizeMapAccess (alias context, a, ref list) }
            c : &MapContainValue => { self.finalizeMapContain (alias context, c, ref list) }
            i : &MapInsertValue => { self.finalizeMapInsert (alias context, i, ref list) }
            b : &MapIteratorBeginValue => { self.finalizeMapIterBegin (alias context, b, ref list) }
            e : &MapIteratorEndValue => { self.finalizeMapIterEnd (alias context, e, ref list) }
            d : &MapIteratorDelValue => { self.finalizeMapIterDel (alias context, d, ref list) }
            n : &MapIteratorNextValue => { self.finalizeMapIterNext (alias context, n, ref list) }
            k : &MapIteratorKeyValue => { self.finalizeMapIterKey (alias context, k, ref list) }
            v : &MapIteratorValueValue => { self.finalizeMapIterValue (alias context, v, ref list) }
            _ => {
                eprintln (m.__typeinfo__.name);
                panic;
            }
        }
    }

    /**
     * Finalize a map access value
     * @params:
     *    - context: the context of the finalization
     *    - m: the map access value to finalize
     *    - list: the list of statement to fill
     * */
    fn finalizeMapAccess (self, dmut context : &Expander, m : &MapAccessValue, ref mut list : StmtList)-> &YILValue {
        match context.getVariable (m.getUniqId ()) {
            Ok (u : &YILValue) => {
                return u;
            }
        }

        let valueType = context:.finalizeType (m.getType ());
        let innerType = context:.finalizeType (m.getType ().asOf!{&OptionType} ().getInners ()[0]);
        let mpAddr = self.finalizeAddressFromAny (alias context, m.getMap (), ref list);
        let keyAddr = self.finalizeAddressFromAny (alias context, m.getKey (), ref list);

        let (value, _) = self.createVarForBlock (alias context, m.getLoc (), NONE_TYPE, context:.getTypeExpander ():.finalizePointer (innerType), ref list);
        list:.append (copy YILAffect (m.getLoc (),
                                      value,
                                      copy YILNameCallValue (m.getLoc (),
                                                             value.getType (),
                                                             YRuntimeFuncs::MAP_FIND,
                                                             copy [mpAddr, keyAddr])));

        // let result : V?;
        // {
        //    let _value = _yrt_map_find (&mp, &key);
        //    if (_value == null) result = none
        //    else result = (*_value)?;
        // };
        let (result, _) = self.createVarForBlock (alias context, m.getLoc (), NONE_TYPE, valueType, ref list);
        let mut elseList = StmtList ();
        let mut thenList = StmtList ();

        let noneValue = self.finalizeErrOpt (alias context, copy ErrOptionValue (m.getLoc (), type-> m.getType ().asOf!{&OptionType} ()), ref thenList);
        thenList:.append (copy YILAffect (m.getLoc (), result, noneValue));

        if let t : &YILTuple = valueType {
            // the returned value is a reference to the actual value
            let contentType = t.getInners ()[1];
            let innerOptValue = copy YILUnrefValue (m.getLoc (), innerType, value);
            let content = copy YILTupleValue (m.getLoc (), contentType,
                                              fieldNames-> copy [OptionKeys::VALUE],
                                              copy [innerOptValue]);

            let optValue = copy YILTupleValue (m.getLoc (), valueType,
                                               fieldNames-> copy [OptionKeys::SET, OptionKeys::CONTENT],
                                               copy [copy YILIntValue (m.getLoc (), YIL_UINT_8, 1us), content]);

            elseList:.append (copy YILAffect (m.getLoc (), result, optValue));
        } else panic;

        self.finalizeCond (m.getLoc (), alias context, ref list,
                           copy YILBinaryValue (m.getLoc (), YIL_UINT_8, BinaryOperators::DEQUAL, value, YIL_NULL_VALUE),
                           thenList, elseList);

        context:.registerVariable (m.getUniqId (), result);
        return result;
    }


    /**
     * Finalize a map containing value
     * @params:
     *    - context: the context of the expansion
     *    - m: the the map contain to validate
     *    - list: the list of statement to fil
     * */
    fn finalizeMapContain (self, dmut context : &Expander, m : &MapContainValue, ref mut list : StmtList)-> &YILValue {
        let valueType = context:.finalizeType (m.getType ());
        match context.getVariable (m.getUniqId ()) {
            Ok (u : &YILValue) => {
                if (m.isNot ()) {
                    return copy YILBinaryValue (m.getLoc (), YIL_UINT_8, BinaryOperators::NOT_EQUAL, u, YIL_NULL_VALUE);
                } else {
                    return copy YILBinaryValue (m.getLoc (), YIL_UINT_8, BinaryOperators::DEQUAL, u, YIL_NULL_VALUE);
                }
            }
        }

        let mpAddr = self.finalizeAddressFromAny (alias context, m.getMap (), ref list);
        let keyAddr = self.finalizeAddressFromAny (alias context, m.getKey (), ref list);

        let (value, _) = self.createVarForBlock (alias context, m.getLoc (), NONE_TYPE, context:.getTypeExpander ():.finalizePointer (valueType), ref list);
        list:.append (copy YILAffect (m.getLoc (),
                                      value,
                                      copy YILNameCallValue (m.getLoc (),
                                                             value.getType (),
                                                             YRuntimeFuncs::MAP_FIND,
                                                             copy [mpAddr, keyAddr])));


        context:.registerVariable (m.getUniqId (), value);

        if (m.isNot ()) {
            copy YILBinaryValue (m.getLoc (), YIL_UINT_8, BinaryOperators::DEQUAL, value, YIL_NULL_VALUE)
        } else {
            copy YILBinaryValue (m.getLoc (), YIL_UINT_8, BinaryOperators::NOT_EQUAL, value, YIL_NULL_VALUE)
        }
    }

    /**
     * Finalize an insertion in a map
     * @params:
     *    - context: the context of the finalization
     *    - m: the map insert to validate
     *    - list: the list of statement to fill
     * */
    fn finalizeMapInsert (self, dmut context : &Expander, m : &MapInsertValue, ref mut list : StmtList)-> &YILValue {
        let mpAddr = self.finalizeAddressFromAny (alias context, m.getMap (), ref list);
        let keyAddr = self.finalizeAddressFromAny (alias context, m.getKey (), ref list);
        let valueAddr = self.finalizeAddressFromAny (alias context, m.getValue (), ref list);

        list:.append (copy YILCall (m.getLoc (),
                                    copy YILNameCallValue (m.getLoc (),
                                                           YIL_VOID,
                                                           YRuntimeFuncs::MAP_INSERT,
                                                           copy [mpAddr, keyAddr, valueAddr])));

        YIL_UNIT_VALUE
    }

    /**
     * Finalize the creation of an iterator from a map value
     * @params:
     *    - context: the context of the validation
     *    - b: the iterator creation
     *    - list: the list of statement to fill
     * */
    fn finalizeMapIterBegin (self, dmut context : &Expander, b : &MapIteratorBeginValue, ref mut list : StmtList)-> &YILValue {
        let mpAddr = self.finalizeAddressFromAny (alias context, b.getMap (), ref list);
        let iterType = context:.finalizeType (b.getType ());

        copy YILNameCallValue (b.getLoc (), iterType, YRuntimeFuncs::MAP_ITER_BEGIN, copy [mpAddr])
    }

    /**
     * Finalize the deletion of an iterator of a map
     * @params:
     *    - context: the context of the validation
     *    - d: the iterator deletion
     *    - list: the list of statement to fill
     * */
    fn finalizeMapIterDel (self, dmut context : &Expander, d : &MapIteratorDelValue, ref mut list : StmtList)-> &YILValue {
        let iterValue = self.finalize (alias context, d.getIterator (), ref list, asLeft-> false);
        list:.append (copy YILCall (d.getLoc (),
                                    copy YILNameCallValue (d.getLoc (),
                                                           YIL_VOID,
                                                           YRuntimeFuncs::MAP_ITER_DEL,
                                                           copy [iterValue])));

        YIL_UNIT_VALUE
    }

    /**
     * Finalize the test of end reached of an iterator of a map
     * @params:
     *    - context: the context of the validation
     *    - e: the iterator checker
     *    - list: the list of statement to fill
     * */
    fn finalizeMapIterEnd (self, dmut context : &Expander, e : &MapIteratorEndValue, ref mut list : StmtList)-> &YILValue {
        let iterValue = self.finalize (alias context, e.getIterator (), ref list, asLeft-> false);
        copy YILNameCallValue (e.getLoc (),
                               YIL_UINT_8,
                               YRuntimeFuncs::MAP_ITER_END,
                               copy [iterValue])
    }

    /**
     * Finalize the increment of a map iterator
     * @params:
     *    - context: the context of the validation
     *    - n: the iterator incrementer
     *    - list: the list of statement to fill
     * */
    fn finalizeMapIterNext (self, dmut context : &Expander, n : &MapIteratorNextValue, ref mut list : StmtList)-> &YILValue {
        let iterValue = self.finalize (alias context, n.getIterator (), ref list, asLeft-> false);
        list:.append (copy YILCall (n.getLoc (),
                                    copy YILNameCallValue (n.getLoc (),
                                                           YIL_VOID,
                                                           YRuntimeFuncs::MAP_ITER_NEXT, copy [iterValue])));

        YIL_UNIT_VALUE
    }

    /**
     * Finalize the extraction of the key from a map iterator
     * @params:
     *    - context: the context of the validation
     *    - k: the iterator key extractor
     *    - list: the list of statement to fill
     * */
    fn finalizeMapIterKey (self, dmut context : &Expander, k : &MapIteratorKeyValue, ref mut list : StmtList)-> &YILValue {
        let iterValue = self.finalize (alias context, k.getIterator (), ref list, asLeft-> false);
        let retType = context:.finalizeType (k.getType ());
        copy YILUnrefValue (k.getLoc (),
                            retType,
                            copy YILNameCallValue (k.getLoc (),
                                                   context:.getTypeExpander ():.finalizePointer (retType),
                                                   YRuntimeFuncs::MAP_ITER_KEY, copy [iterValue]))
    }

    /**
     * Finalize the extraction of a value from a map iterator
     * @params:
     *    - context: the context of the validation
     *    - v: the iterator value extractor
     *    - list: the list of statement to fill
     * */
    fn finalizeMapIterValue (self, dmut context : &Expander, v : &MapIteratorValueValue, ref mut list : StmtList)-> &YILValue {
        let iterValue = self.finalize (alias context, v.getIterator (), ref list, asLeft-> false);
        let retType = context:.finalizeType (v.getType ());
        copy YILUnrefValue (v.getLoc (),
                            retType,
                            copy YILNameCallValue (v.getLoc (),
                                                   context:.getTypeExpander ():.finalizePointer (retType),
                                                   YRuntimeFuncs::MAP_ITER_VAL, copy [iterValue]))
    }

    /*!
     * =====================================================================================
     * =====================================================================================
     * ========================            MEMORY EXPANSION           ======================
     * =====================================================================================
     * =====================================================================================
     */

    /**
     * Finalize a memory operation value
     * @params:
     *    - context: the context of the finalization
     *    - mem: the memory value to finalize
     *    - list: the list of statement to fill
     * */
    fn finalizeMemory (self, dmut context : &Expander, mem : &MemoryValue, ref mut list : StmtList, asLeft : bool)-> &YILValue {
        match mem {
            a : &AddressValue => { self.finalizeAddress (alias context, a, ref list) }
            a : &AliaserValue => { self.finalize (alias context, a.getValue (), ref list, asLeft-> asLeft) }
            c : &ClassAliaserValue => { self.finalize (alias context, c.getValue (), ref list, asLeft-> asLeft) }
            c : &CopierValue => { self.finalizeCopier (alias context, c, ref list) }
            d : &DereferencerValue => { self.finalizeDeref (alias context, d, ref list, asLeft-> asLeft) }
            r : &ReferencerValue => { self.finalizeRef (alias context, r, ref list) }
            l : &LazyValue => { self.finalizeLazy (alias context, l, ref list) }
            f : &FutureValue => { self.finalizeFuture (alias context, f, ref list) }
            m : &MoverValue => { self.finalizeMover (alias context, m, ref list) }
            _ => {
                eprintln (mem.__typeinfo__.name);
                panic;
            }
        }
    }

    /**
     * Finalize an address value
     * @params:
     *    - context: the context of the finalization
     *    - add: the address value to finalize
     *    - list: the list of statement to fill
     * */
    fn finalizeAddress (self, dmut context : &Expander, add : &AddressValue, ref mut list : StmtList)-> &YILValue {
        let type = context:.finalizeType (add.getType ());
        let value = self.finalize (alias context, add.getValue (), ref list, asLeft-> true);

        let depthRet = context:.getTypeExpander ().getPointerDepth (type);
        let depthVal = context:.getTypeExpander ().getPointerDepth (value.getType ());

        // sometimes AddressValue are used on already constructed addresses (references, string literals, ...)
        // So if we get a pointer value that has the same depth, meaning pointer of pointer of ...
        // Then we can assume it is already constructed, and can be returned as it is, with a cast though
        if (depthVal == depthRet) {
            copy YILCastValue (add.getLoc (), type, value)
        } else if let p : &YILPointer = type {
            self.createAddress (alias context, value, type-> p, ref list)
        } else panic;
    }

    /**
     * Finalize the creation of an address from a value
     * @params:
     *    - context: the context of the finalization
     *    - val: value whose address we want to create
     *    - list: the list of statement to fill
     * */
    fn finalizeAddressFromAny (self, dmut context : &Expander, val : &Value, ref mut list : StmtList)-> &YILValue {
        let type = context:.getTypeExpander ():.finalizePointer (context:.finalizeType (val.getType ()));
        let value = self.finalize (alias context, val, ref list, asLeft-> true);

        let depthRet = context:.getTypeExpander ().getPointerDepth (type);
        let depthVal = context:.getTypeExpander ().getPointerDepth (value.getType ());

        // sometimes AddressValue are used on already constructed addresses (references, string literals, ...)
        // So if we get a pointer value that has the same depth, meaning pointer of pointer of ...
        // Then we can assume it is already constructed, and can be returned as it is, with a cast though
        if (depthVal == depthRet) {
            copy YILCastValue (val.getLoc (), type, value)
        } else {
            self.createAddress (alias context, value, type-> type, ref list)
        }
    }

    /**
     * Create an address from a value
     * If the value is not addressable, then put it in a variable and return the address of the variable
     * */
    fn createAddress (self, dmut context : &Expander, value : &YILValue, type : &YILPointer, ref mut list : StmtList)-> &YILValue {
        match value {
            v : &YILVar => {
                return copy YILAddrValue (value.getLoc (), type, v);
            }
            u : &YILUnrefValue => {
                return copy YILCastValue (value.getLoc (), type, u.getValue ());
            }
            f : &YILFieldValue => {
                return copy YILAddrValue (value.getLoc (), type, f);
            }
            _ => {
                let (var, _) = self.createVarForBlock (alias context, value.getLoc (), NONE_TYPE, value.getType (), ref list);
                list:.append (copy YILAffect (value.getLoc (), var, value));

                return copy YILAddrValue (var.getLoc (), type, var);
            }
        }
    }

    /**
     * Finalize a copier value
     * @params:
     *    - context: the context of the finalization
     *    - c: the copier value to copy
     *    - list: the list of statement to fill
     * */
    fn finalizeCopier (self, dmut context : &Expander, c : &CopierValue, ref mut list : StmtList)-> &YILValue {
        // If the copy is a done copy, then we only need to validate its inner value
        if (c.isDone ()) {
            // assuming that it is a call, so no need to save the uniqness
            return self.finalize (alias context, c.getValue (), ref list, asLeft-> false);
        }

        // otherwise, we need to call builtin functions
        // Copy performs heavy computation with possible side effects
        // Copy values must appear only once in the finalized code
        match context.getVariable (c.getUniqId ()) {
            Ok (u : &YILValue) => { // The copy was already seen and validated
                return u;
            }
        };

        let call = match c.getType () {
            slc : &SliceType => { self.finalizeCopierSlice (alias context, c, slc, ref list) }
            m : &MapType => { self.finalizeCopierMap (alias context, c, m, ref list) }
            p : &PointerType => {
                match p.getInners ()[0] {
                    t : &TupleType => { self.finalizeCopierTuple (alias context, c, t, ref list) }
                    t : _ => {
                        eprintln (t.__typeinfo__.name);
                        panic;
                    }
                }
            }
            t : _ => {
                eprintln (t.__typeinfo__.name);
                panic;
            }
        };

        return self.registerUniqValue (alias context, c, call, ref list);
    }

    /**
     * Finalize a copier value that returns a slice
     * */
    fn finalizeCopierSlice (self, dmut context : &Expander, c : &CopierValue, slc : &SliceType, ref mut list : StmtList)-> &YILValue {
        let value = self.finalize (alias context, c.getValue (), ref list, asLeft-> false);
        if (slc.getInners ()[0] of VoidType) { return value; } // copy []

        let (_, ptrU) = self.createVarForBlock (alias context, c.getLoc (), c.getValue ().getType (), value.getType (), ref list, withValue-> value, getAddr-> true);

        let retType = context:.finalizeType (c.getType ());
        let innerType = context:.finalizeType (slc.getInners ()[0]);
        let innerSize = copy YILIntValue (c.getLoc (), YIL_UINT_32, innerType.getSize ());

        let (resultVar, addrResult) = self.createVarForBlock (alias context, c.getLoc (), c.getType (), retType, ref list, getAddr-> true);
        list:.append (copy YILCall (c.getLoc (),
                                    copy YILNameCallValue (c.getLoc (),
                                                           YIL_PTR_VOID,
                                                           YRuntimeFuncs::DUPLICATE_SLICE,
                                                           copy [addrResult, ptrU, innerSize])));

        resultVar
    }

    /**
     * Finalize a copier value that copies a map value
     *
     * */
    fn finalizeCopierMap (self, dmut context : &Expander, c : &CopierValue, m : &MapType, ref mut list : StmtList)-> &YILValue {
        let loc = c.getLoc ();
        let mpAddr = self.finalizeAddressFromAny (alias context, c.getValue (), ref list);

        let mtype = context:.finalizeType (m);
        let vtableName = context.getMangler ().mangleMapInfo (m);
        context:.registerTouchSym (vtableName, m.getLoc ());

        let vtableAddr = copy YILAddrValue (loc, YIL_PTR_2_VOID, copy YILVar (loc, vtableName, YIL_PTR_VOID, 0us));
        let (res, resultAddr) = self.createVarForBlock (alias context, loc, NONE_TYPE, mtype, ref list, name-> "__map_%"s8, getAddr-> true);

        list:.append (copy YILCall (loc,
                                    copy YILNameCallValue (loc,
                                                           YIL_VOID,
                                                           YRuntimeFuncs::MAP_COPY,
                                                           copy [resultAddr, vtableAddr, mpAddr])));

        res
    }

    /**
     * Finalize the copy of a tuple value
     * */
    fn finalizeCopierTuple (self, dmut context : &Expander, c : &CopierValue, t : &TupleType, ref mut list : StmtList)-> &YILValue {
        if (t.getInners ().len == 0us) return YIL_NULL_VALUE;

        let value = self.finalize (alias context, c.getValue (), ref list, asLeft-> false);
        let retType = context:.finalizeType (c.getType ());

        let innerType = context:.finalizeType (t);
        let innerSize = copy YILIntValue (c.getLoc (), YIL_UINT_32, innerType.getSize ());

        let tuAddr = copy YILAddrValue (c.getLoc (), retType, value);

        let (resultVar, addrResult) = self.createVarForBlock (alias context, c.getLoc (), c.getType (), retType, ref list, getAddr-> true);

        list:.append (copy YILCall (c.getLoc (),
                                    copy YILNameCallValue (c.getLoc (),
                                                           YIL_VOID,
                                                           YRuntimeFuncs::DUPLICATE_TUPLE,
                                                           copy [addrResult, tuAddr, innerSize]))
            );

        resultVar
    }


    /**
     * Finalize a dereferencer value
     * */
    fn finalizeDeref (self, dmut context : &Expander, d : &DereferencerValue, ref mut list : StmtList, asLeft : bool)-> &YILValue {
        let value = self.finalize (alias context, d.getValue (), ref list, asLeft-> asLeft);
        let type = context:.finalizeType (d.getType ());

        copy YILUnrefValue (d.getLoc (), type, value)
    }

    /**
     * Finalize a referencer value
     * */
    fn finalizeRef (self, dmut context : &Expander, r : &ReferencerValue, ref mut list : StmtList)-> &YILValue {
        // same as an addresser but storing the inner type only
        let type = context:.getTypeExpander ():.finalizePointer (context:.finalizeType (r.getType ()));
        let value = self.finalize (alias context, r.getValue (), ref list, asLeft-> true);

        let depthRet = context:.getTypeExpander ().getPointerDepth (type);
        let depthVal = context:.getTypeExpander ().getPointerDepth (value.getType ());

        // sometimes references are used on already constructed addresses (references, string literals, ...)
        // So if we get a pointer value that has the same depth, meaning pointer of pointer of ...
        // Then we can assume it is already constructed, and can be returned as it is, with a cast though
        if (depthVal == depthRet) {
            copy YILCastValue (r.getLoc (), type, value)
        } else {
            self.createAddress (alias context, value, type-> type, ref list)
        }
    }

    /**
     * Finalize a lazy value construction
     * */
    pub fn finalizeLazy (self, dmut context : &Expander, l : &LazyValue, ref mut list : StmtList)-> &YILValue {
        if let vr : &VarRefValue = l.getValue () && l.isDone (){
            if let Ok (y) = context.getLazyRef (vr.getRefId ()) {
                return y;
            } else panic;
        }

        let type = context:.getTypeExpander ():.finalizeLazy ();
        let delegate = self.finalize (alias context, l.getLambda (), ref list, asLeft-> false);
        let set = copy YILIntValue (l.getLoc (), YIL_UINT_8, 0us);

        let innerType = context:.finalizeType (l.getType ());
        let size = copy YILIntValue (l.getLoc (), YIL_UINT_32, innerType.getSize ());

        copy YILTupleValue (l.getLoc (), type, copy [set, YIL_NULL_VALUE, size, delegate],
                            fieldNames-> copy [LazyKeys::IS_SET, LazyKeys::VALUE, LazyKeys::SIZE, LazyKeys::FUNC])
    }

    /**
     * Finalize a memory movement (where right is reset after affectation)
     * */
    fn finalizeMover (self, dmut context : &Expander, m : &MoverValue, ref mut list : StmtList)-> &YILValue {
        let what = self.finalize (alias context, m.getValue (), ref list, asLeft-> true);
        let field = copy YILFieldValue (m.getLoc (), YIL_UINT_8, what, name-> ClassKeys::SET);

        let result = self.registerUniqValue (alias context, m.getValue (), what, ref list);
        match m.getReset () {
            c : &CtorCallValue => {
                self.finalizeCtorCall (alias context, c, ref list);
            }
            _ => panic;
        }

        list:.append (copy YILAffect (m.getLoc (), field, copy YILIntValue (m.getLoc (), YIL_UINT_8, 0us)));

        if let v : &YILVar = result {
            self.registerDestroy (alias context, v, m.getType (), ref list, implicit-> true);
        } else panic;

        result
    }

    /**
     * Finalize a future value (value created by the spawning of a thread)
     * */
    fn finalizeFuture (self, dmut context : &Expander, f : &FutureValue, ref mut list : StmtList)-> &YILValue {
        match context.getVariable (f.getUniqId ()) {
            Ok (u : &YILValue) => { // The spawn was already seen and validated
                return u;
            }
        };

        if let ft : &FutureType = f.getType () {
            let futureType = context:.finalizeType (ft);
            let delegate = self.finalize (alias context, f.getLambda (), ref list, asLeft-> false);

            let innerType = context:.finalizeType (ft.getInners ()[0]);
            let size = copy YILIntValue (f.getLoc (), YIL_UINT_32, innerType.getSize ());

            let call = copy YILNameCallValue (f.getLoc (),
                                              futureType,
                                              YRuntimeFuncs::SPAWN_FUTURE, copy [delegate, size]);

            // We want to spawn only once, so we register it for other validations
            return self.registerUniqValue (alias context, f, call, ref list);
        } else panic;
    }

    /*!
     * =====================================================================================
     * =====================================================================================
     * =======================          CONSTRUCT EXPANSION          =======================
     * =====================================================================================
     * =====================================================================================
     */

    /**
     * Finalize a construct value
     * @params:
     *    - context: the context of the finalization
     *    - ctor: the construct value to finalize
     *    - list: the list of statement to fill
     * */
    fn finalizeConstruct (self, dmut context : &Expander, ctor : &ConstructValue, ref mut list : StmtList, asLeft : bool)-> &YILValue {
        match context.getVariable (ctor.getUniqId ()) {
            Ok (u : &YILValue) => { // The call was already seen and validated
                return u;
            }
        };

        let val = match ctor {
            c : &CastValue => { self.finalizeCast (alias context, c, ref list, asLeft-> asLeft) }
            c : &CtorDelegateValue => { self.finalizeCtorDG (alias context, c, ref list) }
            d : &NameDelegateValue => { self.finalizeNameDG (alias context, d, ref list) }
            f : &FakeMethodDelegateValue => { self.finalizeFakeMethodDG (alias context, f, ref list) }
            n : &ProtoFuncPtrValue => { self.finalizeNameFptr (alias context, n, ref list) }
            m : &MethodDelegateValue => { self.finalizeMethodDG (alias context, m, ref list) }
            r : &RangeValue => { self.finalizeRange (alias context, r, ref list) }
            s : &SliceCtorValue => { self.finalizeSliceCtor (alias context, s, ref list) }
            t : &TypeInfoValue => { self.finalizeTypeInfo (alias context, t, ref list) }
            n : &ErrOptionValue => { return self.finalizeErrOpt (alias context, n, ref list); }
            o : &OptionValue => { return self.finalizeOption (alias context, o, ref list); }
            d : &FptrCastDelegateValue => { return self.finalizeCastFptrToDel (alias context, d, ref list) }
            _ => {
                eprintln (ctor.__typeinfo__.name);
                panic;
            }
        }

        if (!asLeft && context.isInAFrame ()) {
            return self.registerUniqValue (alias context, ctor, val, ref list);
        } else return val;
    }

    /**
     * Finalize a cast value
     * @params:
     *    - context: the context of the finalization
     *    - ct: the cast value to finalize
     *    - list: the list of statement to fill
     * */
    fn finalizeCast (self, dmut context : &Expander, ct : &CastValue, ref mut list : StmtList, asLeft : bool)-> &YILValue {
        let value = self.finalize (alias context, ct.getValue (), ref list, asLeft-> asLeft);
        let type = context:.finalizeType (ct.getType ());
        match (type, value) {
            (ti : &YILInt, vi : &YILIntValue) => {
                return copy YILIntValue (ct.getLoc (), ti, vi.getValue ());
            } 
        }

        copy YILCastValue (ct.getLoc (), type, value)
    }

    /**
     * Finalize the construction of a delegate from a simple function pointer
     * */
    fn finalizeCastFptrToDel (self, dmut context : &Expander, ct : &FptrCastDelegateValue, ref mut list : StmtList)-> &YILValue {
        let fptr = self.finalize (alias context, ct.getFuncPtrValue (), ref list, asLeft-> false);
        let protoRef = copy YILAddrValue (ct.getLoc (),
                                          YIL_PTR_VOID,
                                          copy YILVar (ct.getLoc (), YRuntimeFuncs::CALL_FPTR_AS_DG, YIL_VOID, 0us));

        let type = context:.finalizeType (ct.getType ());
        copy YILTupleValue (ct.getLoc (), type,
                            copy [fptr, protoRef],
                            fieldNames-> copy [DelegateKeys::CLOSURE, DelegateKeys::FUNC])
    }

    /**
     * Finalize a delegate to a constructor prototype
     * */
    fn finalizeCtorDG (self, dmut context : &Expander, ctor : &CtorDelegateValue, ref mut list : StmtList)-> &YILValue {
        let name = context.getMangler ().mangle (ctor.getPrototype ());
        context:.registerTouchSym (name, ctor.getPrototype ().getImplLoc ());

        let protoRef = copy YILAddrValue (ctor.getLoc (), YIL_PTR_VOID, copy YILVar (ctor.getLoc (), name, YIL_VOID, 0us));
        let instance = self.finalize (alias context, ctor.getInstance (), ref list, asLeft-> false);
        let type = context:.finalizeType (ctor.getType ());

        copy YILTupleValue (ctor.getLoc (), type,
                            copy [instance, protoRef],
                            fieldNames-> copy [DelegateKeys::CLOSURE, DelegateKeys::FUNC])
    }

    /**
     * Finalize a delegate referenced by a function name
     * */
    fn finalizeNameDG (self, dmut context : &Expander, name : &NameDelegateValue, ref mut list : StmtList)-> &YILValue {
        let pname = context.getMangler ().mangle (name.getPrototype ());
        context:.registerTouchSym (pname, name.getPrototype ().getImplLoc ());

        let protoRef = copy YILAddrValue (name.getLoc (),
                                          YIL_PTR_VOID,
                                          copy YILVar (name.getLoc (), pname, YIL_VOID, 0us));

        let instance = self.finalize (alias context, name.getClosure (), ref list, asLeft-> false);
        let type = context:.finalizeType (name.getType ());

        copy YILTupleValue (name.getLoc (), type,
                            copy [instance, protoRef],
                            fieldNames-> copy [DelegateKeys::CLOSURE, DelegateKeys::FUNC])
    }

    /**
     * Finalize a fake method delegate value
     * */
    fn finalizeFakeMethodDG (self, dmut _ : &Expander, _ : &FakeMethodDelegateValue, ref mut _ : StmtList)-> &YILValue {
        YIL_UNIT_VALUE
    }

    /**
     * Finalize a function pointer referencing a function name (i.e. lambdas)
     * */
    fn finalizeNameFptr (self, dmut context : &Expander, name : &ProtoFuncPtrValue, ref mut _ : StmtList)-> &YILValue {
        let pname = context.getMangler ().mangle (name.getPrototype ());
        context:.registerTouchSym (pname, name.getPrototype ().getImplLoc ());

        copy YILAddrValue (name.getLoc (), YIL_PTR_VOID, copy YILVar (name.getLoc (), pname, YIL_VOID, 0us))
    }

    /**
     * Finalize the creation of a method delegate value
     * */
    fn finalizeMethodDG (self, dmut context : &Expander, meth : &MethodDelegateValue, ref mut list : StmtList)-> &YILValue {
        let mut inst = self.finalize (alias context, meth.getClosure (), ref list, asLeft-> false);
        let type = context:.getTypeExpander ():.finalizeTuple (copy [YIL_PTR_VOID, YIL_PTR_VOID],
                                                               fieldNames-> copy [DelegateKeys::CLOSURE, DelegateKeys::FUNC]);

        match meth.getClosure ().getType () {
            c : &ClassPtrType => {
                if (c.isStruct ()) {
                    if (meth.isAddressed ()) { // if addressed we make a copy of the tuple
                        let retType = context:.getTypeExpander ():.finalizePointer (inst.getType ());
                        let instAddr = self.createAddress (alias context, inst, retType, ref list);
                        let innerSize = copy YILIntValue (meth.getLoc (), YIL_UINT_32, inst.getType ().getSize ());

                        let (resultVar, addrResult) = self.createVarForBlock (alias context, c.getLoc (), meth.getClosure ().getType (), retType, ref list, getAddr-> true);
                        list:.append (copy YILCall (c.getLoc (),
                                                    copy YILNameCallValue (c.getLoc (),
                                                                           YIL_VOID,
                                                                           YRuntimeFuncs::DUPLICATE_TUPLE,
                                                                           copy [addrResult, instAddr, innerSize])));

                        inst = resultVar;
                    } else { // otherwise we simply make a
                        let retType = context:.getTypeExpander ():.finalizePointer (inst.getType ());
                        inst = self.createAddress (alias context, inst, retType, ref list);
                    }
                }
            }
        }

        let fptr = if (meth.isDirect ()) {
            let name = context.getMangler ().mangle (meth.getPrototype ());
            context:.registerTouchSym (name, meth.getPrototype ().getImplLoc ());

            copy YILAddrValue (meth.getLoc (), YIL_PTR_VOID, copy YILVar (meth.getLoc (), name, YIL_VOID, 0us))
        } else {
            self.createVtableAccess (alias context, meth.getLoc (), inst, meth.getVtableIndex (), ref list)
        }

        copy YILTupleValue (meth.getLoc (), type,
                            copy [inst, fptr],
                            fieldNames-> copy [DelegateKeys::CLOSURE, DelegateKeys::FUNC])
    }

    /**
     * Finalize the creation of a range value
     * */
    fn finalizeRange (self, dmut context : &Expander, rng : &RangeValue, ref mut list : StmtList)-> &YILValue {
        let left = self.finalize (alias context, rng.getLeft (), ref list, asLeft-> false);
        let right = self.finalize (alias context, rng.getRight (), ref list, asLeft-> false);
        let step = self.finalize (alias context, rng.getStep (), ref list, asLeft-> false);
        let contain = self.finalize (alias context, rng.getIsFull (), ref list, asLeft-> false);
        let type = context:.finalizeType (rng.getType ());

        copy YILTupleValue (rng.getLoc (), type,
                            copy [left, right, step, contain],
                            fieldNames-> copy [RangeKeys::FST, RangeKeys::SCD, RangeKeys::STEP, RangeKeys::CONTAINS])
    }

    /**
     * Finalize a slice ctor value
     * */
    fn finalizeSliceCtor (self, dmut context : &Expander, ctor : &SliceCtorValue, ref mut list : StmtList)-> &YILValue {
        let type = context:.finalizeType (ctor.getType ());
        let len = self.finalize (alias context, ctor.getLen (), ref list, asLeft-> false);
        let ptr = self.finalize (alias context, ctor.getPointer (), ref list, asLeft-> false);
        let blk = self.finalize (alias context, ctor.getBlk (), ref list, asLeft-> false);

        copy YILTupleValue (ctor.getLoc (), type,
                            copy [len, ptr, blk],
                            fieldNames-> copy [SliceKeys::LEN, SliceKeys::PTR, SliceKeys::BLK_INFO])
    }

    /**
     * Finalize the creation of a typeinfo
     * */
    fn finalizeTypeInfo (self, dmut context : &Expander, ti : &TypeInfoValue, ref mut list : StmtList)-> &YILValue {
        let id = self.finalize (alias context, ti.getId (), ref list, asLeft-> false);
        let size = self.finalize (alias context, ti.getSize (), ref list, asLeft-> false);
        let inner = self.finalize (alias context, ti.getInners (), ref list, asLeft-> false);
        let name = self.finalize (alias context, ti.getName (), ref list, asLeft-> false);

        let type = context:.finalizeType (ti.getType ());
        if let t : &YILTuple = type {
            let fields = t.getFieldNames ();
            copy YILTupleValue (ti.getLoc (), type,
                                copy [id, size, inner, name],
                                fieldNames-> fields)
        } else panic;
    }

    /**
     * Finalize a none value literal
     * */
    fn finalizeErrOpt (self, dmut context : &Expander, n : &ErrOptionValue, ref mut list : StmtList)-> &YILValue {
        let type = context:.finalizeType (n.getType ());
        if let t : &YILTuple = type {
            let contentType = t.getInners ()[1]; // {.ok, .content}
            let errValue = self.finalize (alias context, n.getValue (), ref list, asLeft-> false);

            let content = copy YILTupleValue (n.getLoc (), contentType,
                                              fieldNames-> copy [OptionKeys::ERROR],
                                              copy [errValue]);

            copy YILTupleValue (n.getLoc (), type,
                                fieldNames-> copy [OptionKeys::SET, OptionKeys::CONTENT],
                                copy [copy YILIntValue (n.getLoc (), YIL_UINT_8, 0us), content]) // {.set = 0, .content = {.error = null}}

        } else panic;
    }

    /**
     * Finalize an option value construction
     * */
    fn finalizeOption (self, dmut context : &Expander, o : &OptionValue, ref mut list : StmtList)-> &YILValue {
        let innerValue = if let opt : &OptionType = o.getType () {
            let innerType = opt.getInners ()[0];
            if (innerType of VoidType || innerType of NoneType) {
                self.finalize (alias context, o.getValue (), ref list, asLeft-> false);
                copy YILIntValue (o.getLoc (), YIL_UINT_8, 0us)
            } else {
                self.finalize (alias context, o.getValue (), ref list, asLeft-> false)
            }
        } else panic;

        let type = context:.finalizeType (o.getType ());
        if let t : &YILTuple = type {
            let contentType = t.getInners ()[1]; // {.ok, .content}
            let content = copy YILTupleValue (o.getLoc (), contentType,
                                              fieldNames-> copy [OptionKeys::VALUE],
                                              copy [innerValue]);

            // {.set = 1, .content = {.value = value}}
            return copy YILTupleValue (o.getLoc (), type, fieldNames-> copy [OptionKeys::SET, OptionKeys::CONTENT],
                                       copy [copy YILIntValue (o.getLoc (), YIL_UINT_8, 1us), content]);
        } else panic;
    }

}
