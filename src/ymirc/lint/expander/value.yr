mod ymirc::lint::expander::value;

import ymirc::lint::expander::visitor;
import ymirc::lint::expander::type;
import ymirc::lint::expander::stmtlist;

import ymirc::lint::node::_;

import std::collection::map;
import std::collection::vec;
import std::io;

import ymirc::utils::format;
import ymirc::utils::bigint;
import ymirc::utils::bigfloat;

import ymirc::semantic::generator::_;
import ymirc::global::core_;
import ymirc::global::state;
import ymirc::syntax::keys;

import ymirc::lexing::word;
import std::fs::path;

/**
 * The value expander is used to expand values into a list of statements
 */
pub class ValueExpander {

    /**
     * Create an empty value expander
     * */
    pub self () {}

    /**
     * Finalize a value
     * @params:
     *    - context: the context of the expansion
     *    - val: the value to expand
     *    - list: the list of statement to fill
     * @returns: the final value
     * */
    pub fn finalize (self, dmut context : &Expander, val : &Value, dmut list : &StmtList, asLeft : bool = false)-> &YILValue {
        match val {
            b : &BreakValue => { self.finalizeBreak (alias context, b, alias list) }
            n : &NamedValue => { self.finalize (alias context, n.getValue (), alias list, asLeft-> asLeft) }
            r : &ReturnValue => { self.finalizeReturn (alias context, r, alias list) }
            t : &ThrowValue => { self.finalizeThrow (alias context, t, alias list) }
            p : &PanicValue => { self.finalizePanic (alias context, p, alias list) }
            v : &VarDeclValue => { self.finalizeVarDecl (alias context, v, alias list) }
            v : &VarRefValue => { self.finalizeVarRef (alias context, v, alias list) }
            s : &ScopeValue => { self.finalizeScope (alias context, s, alias list, asLeft-> asLeft) }
            l : &LiteralValue => { self.finalizeLiteral (alias context, l, alias list, asLeft-> asLeft) }
            o : &OperatorValue => { self.finalizeOperator (alias context, o, alias list, asLeft-> asLeft) }
            m : &MemoryValue => { self.finalizeMemory (alias context, m, alias list) }
            c : &ConstructValue => { self.finalizeConstruct (alias context, c, alias list, asLeft-> asLeft) }
            c : _ => {
                eprintln (c::typeinfo.name);
                __pragma!panic ();
            }
        }
    }

    /**
     * Finalize a break statement
     * @params:
     *    - context: the context of the finalization
     *    -  b: the break statement to finalize
     * @returns: UNIT_VALUE, break values are never right operands
     * */
    fn finalizeBreak (self, dmut context : &Expander, b : &BreakValue, dmut list : &StmtList)-> &YILValue {
        let endLabel = context.getLoopExitLabel ();
        let decl = context.getLoopVarRef ();
        if (!decl.isOf!{&YILUnit} ()) {
            let inner = self.finalize (alias context, b.getValue (), alias list);
            list:.append (YILAffect::new (b.getLoc (), decl, inner));
        }

        list:.append (YILGoto::new (b.getLoc (), endLabel));
        YIL_UNIT_VALUE
    }

    /**
     * Finalize a return statement
     * @params:
     *    - context: the context of the finalization
     *    - t: the return stmt to finalize
     * @returns: UNIT_VALUE, return values are never right operands
     * */
    fn finalizeReturn (self, dmut context : &Expander, r : &ReturnValue, dmut list : &StmtList)-> &YILValue {
        let inner = self.finalize (alias context, r.getValue (), alias list);
        list:.append (YILReturn::new (r.getLoc (), inner));

        YIL_UNIT_VALUE
    }

    /**
     * Finalize a throw statement
     * @params:
     *    - t: the throw stmt to finalize
     * @returns: UNIT_VALUE, throw values are never right operands
     * */
    fn finalizeThrow (self, dmut context : &Expander, t : &ThrowValue, dmut list : &StmtList)-> &YILValue {
        let inner = self.finalize (alias context, t.getValue (), alias list);
        let line = YILIntValue::new (t.getLoc (), YIL_UINT_32, cast!usize (t.getLoc ().line ()));
        let filename = state::relativePath (t.getLoc ().filename ());

        let fileStr = self.finalize (alias context, makeStringSliceValue (t.getLoc (), filename), alias list);
        let funcStr = self.finalize (alias context, makeStringSliceValue (t.getLoc (), context.getCurrentFrameName ()), alias list);

        let fileStrType = fileStr.getType ().asOf!{&YILTuple} ().getInners ()[1];
        let fileStrPtr = fileStr.asOf!{&YILTupleValue} ().getValue ()[1];

        let funcStrType = funcStr.getType ().asOf!{&YILTuple} ().getInners ()[1];
        let funcStrPtr = funcStr.asOf!{&YILTupleValue} ().getValue ()[1];

        let fileStrPtrU = self.createVarForBlock (alias context, t.getLoc (), fileStrType, alias list, withValue-> fileStrPtr);
        let funcStrPtrU = self.createVarForBlock (alias context, t.getLoc (), funcStrType, alias list, withValue-> funcStrPtr);

        let call = YILNameCallValue::new (t.getLoc (), YIL_VOID, CoreNames::YRT_THROW_EXCEPT, [fileStrPtrU, funcStrPtrU, line, inner]);

        list:.append (YILCall::new (t.getLoc (), call));

        YIL_UNIT_VALUE
    }

    /**
     * Finalize a panice statement
     * @params :
     *    - p: the panic stmt to finalize
     * @returns: UNIT_VALUE
     * */
    fn finalizePanic (self, dmut context : &Expander, p : &PanicValue, dmut list : &StmtList)-> &YILValue {
        let line = YILIntValue::new (p.getLoc (), YIL_UINT_32, cast!usize (p.getLoc ().line ()));
        let filename = state::relativePath (p.getLoc ().filename ());

        let fileStr = self.finalize (alias context, makeStringSliceValue (p.getLoc (), filename), alias list);
        let funcStr = self.finalize (alias context, makeStringSliceValue (p.getLoc (), context.getCurrentFrameName ()), alias list);

        let fileStrType = fileStr.getType ().asOf!{&YILTuple} ().getInners ()[1];
        let fileStrPtr = fileStr.asOf!{&YILTupleValue} ().getValue ()[1];

        let funcStrType = funcStr.getType ().asOf!{&YILTuple} ().getInners ()[1];
        let funcStrPtr = funcStr.asOf!{&YILTupleValue} ().getValue ()[1];

        let fileStrPtrU = self.createVarForBlock (alias context, p.getLoc (), fileStrType, alias list, withValue-> fileStrPtr);
        let funcStrPtrU = self.createVarForBlock (alias context, p.getLoc (), funcStrType, alias list, withValue-> funcStrPtr);

        let call = YILNameCallValue::new (p.getLoc (), YIL_VOID, CoreNames::YRT_PANIC, [fileStrPtrU, funcStrPtrU, line]);
        list:.append (YILCall::new (p.getLoc (), call));

        YIL_UNIT_VALUE
    }

    /**
     * Finalize the registration of a unit test
     * @params:
     *    - context: the context of the expansion
     *    - name: the name of the unit test function to register
     *    - loc: the location of the unittest
     *    - list: the list to fill
     * */
    pub fn finalizeRegisterUnitTest (self, dmut context : &Expander, name : [c8], mangledName : [c8], loc : &Word, dmut list : &StmtList) {
        let funcAddr = YILAddrValue::new (EOF_WORD, YIL_PTR_VOID, YILVar::new (EOF_WORD, mangledName, YIL_VOID, 0us));

        let funcStr = self.finalize (alias context, makeStringSliceValue (loc, name), alias list);
        let funcStrPtr = funcStr.asOf!{&YILTupleValue} ().getValue ()[1];
        let funcStrType = funcStr.getType ().asOf!{&YILTuple} ().getInners ()[1];
        let funcStrPtrU = self.createVarForBlock (alias context, loc, funcStrType, alias list, withValue-> funcStrPtr);

        let call = YILNameCallValue::new (loc, YIL_VOID, CoreNames::YRT_REGISTER_UNIT_TEST, [funcStrPtrU, funcAddr]);
        list:.append (YILCall::new (EOF_WORD, call));
    }
    
    /**
     * Finalize a variable declaration statement
     * @params:
     *    - v: the variable declaration to finalize
     * @returns: UNIT_VALUE, variable decl are never right operands
     * */
    fn finalizeVarDecl (self, dmut context : &Expander, v : &VarDeclValue, dmut list : &StmtList)-> &YILValue {
        // Lambda definition, is not generated
        if (v.getVarType ().isOf!{&LambdaType} ()) return YIL_UNIT_VALUE;

        let inner = self.finalize (alias context, v.getValue (), alias list);
        let mut type = context:.finalizeType (v.getVarType ());

        if (v.isReference ()) {
            type = YILPointer::new (type);
        }

        let varId = context:.generateVarId ();
        let decl = YILVarDecl::new (v.getLoc (), v.getLoc ().str (), type, varId);
        let mut varref = YILVar::new (v.getLoc (), v.getLoc ().str (), type, varId);

        list:.append (decl);

        if (!inner.isOf!{&YILUnit} ()) {
            list:.append (YILAffect::new (v.getLoc (), varref, inner));
        }

        if (v.isReference ()) {
            context:.registerVariable (v.getUniqId (),
                                       YILUnrefValue::new (v.getLoc (), type.asOf!{&YILPointer} ().getInner (), varref));
        } else {
            context:.registerVariable (v.getUniqId (), varref);
        }

        YIL_UNIT_VALUE
    }

    /**
     * Finalize a variable reference value
     * @params:
     *   - v: the variable to finalize
     * @returns: a variable reference
     * */
    fn finalizeVarRef (self, dmut context : &Expander, v : &VarRefValue, dmut _ : &StmtList)-> &YILValue {
        match context.getVariable (v.getRefId ()) {
            Ok (vref : &YILValue) => { return vref; }
        };

        let type = context:.finalizeType (v.getType ());
        YILVar::new (v.getLoc (), v.getDeclLoc ().str (), type, 0us)
    }


    /**
     * =====================================================================================
     * =====================================================================================
     * =========================          SCOPE EXPANSION          =========================
     * =====================================================================================
     * =====================================================================================
     */

    /**
     * Finalize a scope value
     * @params:
     *    - sc: the scope value to finalize
     *    - list: the statement list to fill
     * @returns: the final value of the scope
     * */
    fn finalizeScope (self, dmut context : &Expander, sc : &ScopeValue, dmut list : &StmtList, asLeft : bool)-> &YILValue {
        match context.getVariable (sc.getUniqId ()) {
            Ok (u : &YILValue) => { // The call was already seen and validated
                return u;
            }
        };

        let retVal = match sc {
            b : &BlockValue => { self.finalizeBlock (alias context, b, alias list) }
            c : &ConditionalValue => { self.finalizeCond (alias context, c, alias list) }
            l : &LoopValue => { self.finalizeLoop (alias context, l, alias list) }
            _ => {
                eprintln (sc::typeinfo.name);
                __pragma!panic ();
            }
        }

        if (!asLeft) {
            return self.registerUniqValue (alias context, sc, retVal, alias list);
        } else {
            return retVal;
        }
    }

    /**
     * Finalize a block of values
     * @params:
     *    - b: the block of values to finalize
     *    - list: the list of statement to fill
     * @returns: the final value of the block if any
     * */
    fn finalizeBlock (self, dmut context : &Expander, b : &BlockValue, dmut list : &StmtList)-> &YILValue {
        if (b.isSet ()) return self.finalizeSet (alias context, b, alias list);
        let dmut innerList = StmtList::new ();
        context:.enterBlock ();

        let retVal = self.finalizeSet (alias context, b, alias innerList);

        context:.exitBlock ();
        // Block without scope guards can be flattened, there is no variable shadowing anymore
        list:.append (innerList); // BlockValue::new (b.getLoc (), VOID_TYPE, innerList[], noValue-> true));

        retVal
    }

    /**
     * Finalize a set of value
     * @params:
     *    - s: the set of values to finalize
     *    - list: the list of statement to fill
     * @returns: the final value of the set if any
     * */
    fn finalizeSet (self, dmut context : &Expander, s : &BlockValue, dmut list : &StmtList)-> &YILValue {
        let mut finVal : &YILValue = YIL_UNIT_VALUE;
        for inner in s.getValues () {
            finVal = self.finalize (alias context, inner, alias list);
        }

        finVal
    }

    /**
     * Finalize a branch statement
     * @params:
     *    - c: the conditional statement to finalize
     *    - list: the list of statement to fill
     * @returns: the final value of the condition if any
     * */
    fn finalizeCond (self, dmut context : &Expander, c : &ConditionalValue, dmut list : &StmtList)-> &YILValue {
        let type = context:.finalizeType (c.getType ());
        let var = self.createVarForBlock (alias context, c.getLoc (), type, alias list);


        let dmut ifList = StmtList::new ();
        let dmut elseList = StmtList::new ();

        // Maybe calls from this test are evaluated in the else cond
        // If there are calls in there, we need to validate them first
        let test = self.finalize (alias context, c.getTest (), alias list);

        context:.enterBlock ();
        let ifVal = self.finalize (alias context, c.getValue (), alias ifList);
        context:.exitBlock ();

        context:.enterBlock ();
        let elseVal = self.finalize (alias context, c.getElse (), alias elseList);
        context:.exitBlock ();

        if (!var.isOf!{&YILUnit} ()) {
            if (!ifVal.isOf!{&YILUnit} ()) { // can happen if the if val is returner/breaker
                ifList:.append (YILAffect::new (c.getLoc (), var, ifVal));
            }
            if (!elseVal.isOf!{&YILUnit} ()) { // if the else val is a returner/breaker or just does not have a value
                elseList:.append (YILAffect::new (c.getLoc (), var, elseVal));
            }
        }

        self.finalizeCond (c.getLoc (), alias context,  alias list, test, ifList, elseList);
        var
    }

    /**
     * Create conditional jump structure using the list of instruction of each blocks
     * @params:
     *    - loc: the location of the condition
     *    - list: the list of statement to fill
     *    - test: the test of the conditional
     *    - thenList: the list of statement to execute if the condition is met
     *    - elseList: the list of statement to execute if the condition is not met
     * */
    fn finalizeCond (self, loc : &Word, dmut context : &Expander, dmut list : &StmtList, test : &YILValue, thenList : &StmtList, elseList : &StmtList) {
        let thenLabel = YILLabel::new (loc, "then"s8, context:.generateLblId ());
        let endLabel = YILLabel::new (loc, "end"s8, context:.generateLblId ());
        let elseLabel = if (elseList.len () != 0us) {
            YILLabel::new (loc, "else"s8, context:.generateLblId ())
        } else {
            endLabel
        };

        list:.append (YILCondJmp::new (loc, test, thenLabel, elseLabel));
        list:.append (thenLabel);
        list:.append (thenList);

        if (elseList.len () != 0us) {
            list:.append (YILGoto::new (loc, endLabel));
            list:.append (elseLabel);
            list:.append (elseList);
        }

        list:.append (endLabel);
    }

    /**
     * Finalize a loop statement
     * @params:
     *    - l: the loop statement to finalize
     *    - list: the list of statement to fill
     * @returns: the final value of the loop if any
     * */
    fn finalizeLoop (self, dmut context : &Expander, l : &LoopValue, dmut list : &StmtList)-> &YILValue {
        if (l.isCteFor ()) {
            self.finalizeCteForLoop (alias context, l, alias list)
        } else {
            self.finalizeClassicLoop (alias context, l, alias list)
        }
    }

    /**
     * Finalize a cte for loop statement
     * @params:
     *    - l: the for loop statement to finalize
     *    - list: the list of statement to fill
     * */
    fn finalizeCteForLoop (self, dmut context : &Expander, l : &LoopValue, dmut list : &StmtList)-> &YILValue {
        let type = context:.finalizeType (l.getType ());
        let var = self.createVarForBlock (alias context, l.getLoc (), type, alias list);

        context:.enterBlock ();
        let endLabel = YILLabel::new (l.getLoc (), "end"s8, context:.generateLblId ());
        context:.enterLoop (var, endLabel);

        let dmut innerList = StmtList::new ();
        let innerValue = self.finalize (alias context, l.getValue (), alias innerList);
        if (!var.isOf!{&YILUnit} () && !l.getValue ().isBreaker ()) {
            innerList:.append (YILAffect::new (l.getLoc (), var, innerValue));
        }

        context:.exitLoop ();
        context:.exitBlock ();

        list:.append (innerList);
        list:.append (endLabel);
        var
    }

    /**
     * Finalize a loop with (or without) a test, that is execute at runtime
     * @params:
     *    - l: the loop to finalize
     *    - list: the statement list to fill
     * @returns: the value of the loop if any
     * */
    fn finalizeClassicLoop (self, dmut context : &Expander, l : &LoopValue, dmut list : &StmtList)-> &YILValue {
        let type = context:.finalizeType (l.getType ());
        let varref = self.createVarForBlock (alias context, l.getLoc (), type, alias list);

        let dmut testList = StmtList::new ();
        // test is in its own list, because we need to validate it right away
        // But it has to be placed after the test label
        let test = self.finalize (alias context, l.getTest (), alias testList);

        context:.enterBlock ();
        let dmut loopList = StmtList::new ();
        let endLabel = YILLabel::new (l.getLoc (), "end"s8, context:.generateLblId ());
        context:.enterLoop (varref, endLabel);

        let contentVal = self.finalize (alias context, l.getValue (), alias loopList);
        if (!varref.isOf!{&YILUnit} () && !l.getValue ().isBreaker () && !test.isOf!{&YILUnit} ()) {
            loopList:.append (YILAffect::new (l.getLoc (), varref, contentVal));
        }

        context:.exitLoop ();
        context:.exitBlock ();

        let begLabel = YILLabel::new (l.getLoc (), "beg"s8, context:.generateLblId ());
        let testLabel = YILLabel::new (l.getLoc (), "test"s8, context:.generateLblId ());

        if (!l.isDo () && !test.isOf!{&YILUnit} ()) {
            list:.append (YILGoto::new (l.getLoc (), testLabel));
        }

        list:.append (begLabel);
        list:.append (loopList);

        if (!test.isOf!{&YILUnit} ()) {
            list:.append (testLabel);
            list:.append (testList);
            list:.append (YILCondJmp::new (l.getLoc (), test, begLabel, endLabel));
        } else {
            list:.append (YILGoto::new (l.getLoc (), begLabel));
        }

        list:.append (endLabel);
        varref
    }


    /**
     * Create a variable to store a block value
     * @params:
     *    - loc: the location of the creation
     *    - type: the type of the block
     *    - list: the list of stmt to fill
     *    - name: the name of the variable (with a possible formatter, its uniq Id)
     * @returns: a varref or unit value, if the type is empty
     * */
    fn createVarForBlock (self, dmut context : &Expander, loc : &Word, type : &YILType, dmut list : &StmtList, name : [c8] = "YI_%"s8, withValue : &YILValue = YIL_UNIT_VALUE)-> &YILValue {
        match type {
            YILVoid () => { return YIL_UNIT_VALUE; }
            _ => {
                let varId = context:.generateVarId ();
                let fullName = format (name, varId);
                let blckVar = YILVarDecl::new (loc, fullName, type, varId);
                list:.append (blckVar);

                let var = YILVar::new (loc, fullName, type, varId);;
                if (!withValue.isOf!{&YILUnit} ()) {
                    list:.append (YILAffect::new (loc, var, withValue));
                }

                return var;
            }
        };
    }

    /**
     * Register a uniq value in a variable
     * @returns: the uniq var ref, or YIL_UNIT_VALUE depending on the type
     * * */
    fn registerUniqValue (self, dmut context : &Expander, gen : &Value, value : &YILValue, dmut list : &StmtList, name : [c8] = "YI_%"s8) -> &YILValue {
        let type = context:.finalizeType (gen.getType ());
        let varref = self.createVarForBlock (alias context, gen.getLoc (), type, alias list, name-> name);
        if (!varref.isOf!{&YILUnit} ()) {
            context:.registerVariable (gen.getUniqId (), varref);
            list:.append (YILAffect::new (gen.getLoc (), varref, value));
        }

        varref
    }

    /**
     * Register a uniq value in a variable
     * @returns: the uniq var ref, or YIL_UNIT_VALUE depending on the type
     * * */
    fn registerUniqValue (self, dmut context : &Expander, gen : &Value, type : &YILType, value : &YILValue, dmut list : &StmtList, name : [c8] = "YI_%"s8) -> &YILValue {
        let varref = self.createVarForBlock (alias context, gen.getLoc (), type, alias list, name-> name);
        if (!varref.isOf!{&YILUnit} ()) {
            context:.registerVariable (gen.getUniqId (), varref);
            list:.append (YILAffect::new (gen.getLoc (), varref, value));
        }

        varref
    }


    /**
     * =====================================================================================
     * =====================================================================================
     * ========================          LITERAL EXPANSION          ========================
     * =====================================================================================
     * =====================================================================================
     */

    /**
     * Finalize a literal value
     * @params:
     *    - l: the literal value to finalize
     *    - list: the scope list of statement to fill
     * @returns: the finalized value
     * */
    fn finalizeLiteral (self, dmut context : &Expander, l : &LiteralValue, dmut list : &StmtList, asLeft : bool)-> &YILValue {
        match l { // simple literals
            s : &StringValue => { return self.finalizeStr (alias context, s); }
            b : &BoolValue => { return self.finalizeBool (alias context, b); }
            c : &CharValue => { return self.finalizeChar (alias context, c); }
            f : &FloatValue => { return self.finalizeFloat (alias context, f); }
            i : &IntValue => { return self.finalizeInt (alias context, i); }
            NullValue () => { return YIL_NULL_VALUE; }
            UnitValue () => { return YIL_UNIT_VALUE; }
        }

        match context.getVariable (l.getUniqId ()) {
            Ok (u : &YILValue) => { // The call was already seen and validated
                return u;
            }
        };

        let val = match l {
            a : &ArrayValue => { self.finalizeArray (alias context, a, alias list) }
            a : &ArrayAllocValue => { self.finalizeArrayAlloc (alias context, a, alias list) }
            t : &TupleValue => { self.finalizeTuple (alias context, t, alias list) }
            _ => {
                eprintln (l::typeinfo.name);
                __pragma!panic ();
            }
        }

        if (!asLeft) {
            return self.registerUniqValue (alias context, l, val, alias list);
        } else return val;
    }

    /**
     * Finalize a string literal
     * */
    fn finalizeStr (self, dmut context : &Expander, str : &StringValue)-> &YILValue {
        let slc = str.getType ().asOf!{&SliceType} ();
        let type = context:.finalizeType (slc);

        if (str.getLen () == 0us) {
            let len = YILIntValue::new (str.getLoc (), YIL_UINT_MAX, str.getLen ());
            return YILTupleValue::new (str.getLoc (), type, [len, YIL_NULL_VALUE], fieldNames-> [SliceKeys::LEN, SliceKeys::PTR]);
        }

        let dmut res = Vec!{u8}::new ();
        let content = str.getValue ();
        let innerType = match str.getEncodingSize () {
            8u16 => {
                res:.reserve (str.getLen () + 1us);
                for i in 0us .. str.getLen () {
                    res:.push (content.utf8 [i]);
                }
                res:.push (0u8);
                YIL_UINT_8
            }
            16u16 => {
                res:.reserve (str.getLen () * 2us + 1us);
                for i in 0us .. str.getLen () {
                    let x : &u8 = cast!{&u8} (cast!{&void} (content.utf16.ptr + (i * sizeof (u16))));
                    __pragma!trusted ({
                        res:.push (*x);
                        res:.push (*(x + 1us));
                    });
                }
                res:.push (0u8);
                YIL_UINT_16
            }
            _ => {
                res:.reserve (str.getLen () * 4us + 1us);
                for i in 0us .. str.getLen () {
                    let x : &u8 = cast!{&u8} (cast!{&void} (content.utf32.ptr + (i * sizeof (u32))));
                    __pragma!trusted ({
                        res:.push (*x);
                        res:.push (*(x + 1us));
                        res:.push (*(x + 2us));
                        res:.push (*(x + 3us));
                    });
                }
                res:.push (0u8);
                YIL_UINT_32
            }
        };

        let array = YILStringValue::new (str.getLoc (), YILArray::new (innerType, res.len ()), res[]);
        let len = YILIntValue::new (str.getLoc (), YIL_UINT_MAX, str.getLen ());
        YILTupleValue::new (str.getLoc (), type, [len, array], fieldNames-> [SliceKeys::LEN, SliceKeys::PTR])
    }

    /**
     * Finalize a bool literal
     * */
    fn finalizeBool (self, dmut _ : &Expander, b : &BoolValue)-> &YILValue {
        YILIntValue::new (b.getLoc (), YIL_UINT_8, if b.isTrue () { 1us } else { 0us })
    }

    /**
     * Finalize a char literal
     * */
    fn finalizeChar (self, dmut context : &Expander, c : &CharValue)-> &YILValue {
        let type = context:.finalizeType (c.getType ());
        YILIntValue::new (c.getLoc (), type, c.getValueAsInt ())
    }

    /**
     * Finalize a float literal
     * */
    fn finalizeFloat (self, dmut context : &Expander, f : &FloatValue)-> &YILValue {
        let type = context:.finalizeType (f.getType ());
        YILFloatValue::new (f.getLoc (), type, f.getValue ())
    }

    /**
     * Finalize an int literal value
     * */
    fn finalizeInt (self, dmut context : &Expander, i : &IntValue)-> &YILValue {
        let type = context:.finalizeType (i.getType ());
        YILIntValue::new (i.getLoc (), type, i.getValue ())
    }

    /**
     * Finalize an array value
     * @params:
     *    - a: the array value to finalize
     *    - list: the list of statement to fill
     * @returns: the value
     * */
    fn finalizeArray (self, dmut context : &Expander, a : &ArrayValue, dmut list : &StmtList)-> &YILValue {
        let dmut res = Vec!{&YILValue}::new ();
        for i in a.getValues () {
            res:.push (self.finalize (alias context, i, alias list));
        }

        let atype = context:.finalizeType (a.getType ());
        YILArrayValue::new (a.getLoc (), atype, res[])
    }

    /**
     * Finalize an array allocation value
     * @params:
     *     - a: the array allocation to finalize
     *     - list: the list of statement to fill
     * @returns: the value
     * */
    fn finalizeArrayAlloc (self, dmut context : &Expander, a : &ArrayAllocValue, dmut list : &StmtList)-> &YILValue {
        let inner = if (a.getValue ().isOf!{&UnitValue} ()) {
            YIL_UNIT_VALUE
        } else {
            self.finalize (alias context, a.getValue (), alias list)
        };

        let type = context:.finalizeType (a.getType ());

        if (a.isDynamic ()) {
            let len = self.finalize (alias context, a.getLen (), alias list);
            if (a.getValue ().isOf!{&UnitValue} ()) {
                let innerType = context:.finalizeType (a.getType ().asOf!{&SliceType} ().getInners ()[0]);
                let size = YILIntValue::new (a.getLoc (), YIL_UINT_MAX, innerType.getSize ());

                let finalPtr = YILNameCallValue::new (a.getLoc (), YIL_PTR_VOID, CoreNames::YRT_ALLOC_NO_SET_SLICE, [len, size]);
                let finalPtrU = self.createVarForBlock (alias context, a.getLoc (), finalPtr.getType (), alias list, withValue-> finalPtr);

                YILTupleValue::new (a.getLoc (), type, [len, finalPtrU], fieldNames-> [SliceKeys::LEN, SliceKeys::PTR])
            } else {
                let innerType = inner.getType ();
                let size = YILIntValue::new (a.getLoc (), YIL_UINT_MAX, innerType.getSize ());

                let valPtr = self.createAddress (alias context, inner, type-> YILPointer::new (innerType), alias list);
                let finalPtr = YILNameCallValue::new (a.getLoc (), YIL_PTR_VOID, CoreNames::YRT_ALLOC_SET_SLICE, [valPtr, len, size]);
                let finalPtrU = self.createVarForBlock (alias context, a.getLoc (), finalPtr.getType (), alias list, withValue-> finalPtr);

                YILTupleValue::new (a.getLoc (), type, [len, finalPtrU], fieldNames-> [SliceKeys::LEN, SliceKeys::PTR])
            }
        } else {
            let dmut params = Vec!{&YILValue}::new ();
            let len = a.getLen ().asOf!{&IntValue} ().getValue ().toT!{usize} ();
            for _ in 0us .. len {
                params:.push (inner);
            }

            YILArrayValue::new (a.getLoc (), type, params[])
        }
    }

    /**
     * Finalize a tuple value
     * @params:
     *    - t: the tuple value to finalize
     *    - list: the list of statement to fill
     * @returns: the value
     * */
    fn finalizeTuple (self, dmut context : &Expander, t : &TupleValue, dmut list : &StmtList)-> &YILValue {
        let dmut res = Vec!{&YILValue}::new ();
        for i in t.getValues () {
            res:.push (self.finalize (alias context, i, alias list));
        }

        let ttype = context:.finalizeType (t.getType ());
        YILTupleValue::new (t.getLoc (), ttype, res[])
    }

    /**
     * =====================================================================================
     * =====================================================================================
     * ======================            OPERATOR EXPANSION           ======================
     * =====================================================================================
     * =====================================================================================
     */

    /**
     * Finalize an operator value
     * @params:
     *    - op: the operator to finalize
     *    - list: the list of stmtlist to fill
     * */
    fn finalizeOperator (self, dmut context : &Expander, op : &OperatorValue, dmut list : &StmtList, asLeft : bool)-> &YILValue {
        match op {
            a : &AffectValue => { self.finalizeAffect (alias context, a, alias list) }
            c : &CallOperatorValue => { self.finalizeCall (alias context, c, alias list) }
            b : &BinaryOperatorValue => { self.finalizeBinary (alias context, b, alias list, asLeft-> asLeft) }
            f : &FieldOperatorValue => { self.finalizeField (alias context, f, alias list) }
            s : &SliceOrArrayOperatorValue => { self.finalizeSliceOrArrayOp (alias context, s, alias list) }
            u : &UnaryOperatorValue => { self.finalizeUnary (alias context, u, alias list) }
            _ => {
                eprintln (op::typeinfo.name);
                __pragma!panic ();
            }
        }
    }

    /**
     * Finalize an affectation operation
     * @params:
     *     - a: the affectation operation to validate
     *     - list: the list of statement to fill
     * @returns: the left operand
     * */
    fn finalizeAffect (self, dmut context : &Expander, a : &AffectValue, dmut list : &StmtList)-> &YILValue {
        let left = self.finalize (alias context, a.getLeft (), alias list, asLeft-> true);
        let right = self.finalize (alias context, a.getRight (), alias list);

        list:.append (YILAffect::new (a.getLoc (), left, right));
        left
    }

    /**
     * Finalize a binary operator value
     * @params:
     *    - b: the binary operator to finalize
     *    - list: the list of statement to fill
     * @returns: the finalized binary
     * */
    fn finalizeBinary (self, dmut context : &Expander, b : &BinaryOperatorValue, dmut list : &StmtList, asLeft : bool)-> &YILValue {
        match b {
            bl : &LogicalBinBoolOperatorValue => { return self.finalizeLogicalBool (alias context, bl, alias list); }
            r : &RangeContainValue => { return self.finalize (alias context, r.getCall (), alias list); }
            s : &SpecialMathIntOperatorValue => { return self.finalize (alias context, s.getCall (), alias list); }
            f : &SpecialMathFloatOperatorValue => { return self.finalize (alias context, f.getCall (), alias list); }
            c : &CmpClassTypeOperatorValue => { return self.finalizeClassTypCmp (alias context, c, alias list); }
        }

        match context.getVariable (b.getUniqId ()) {
            Ok (u : &YILValue) => { // The call was already seen and validated
                return u;
            }
        };

        let left = self.finalize (alias context, b.getLeft (), alias list);
        let right = self.finalize (alias context, b.getRight (), alias list);

        let type = context:.finalizeType (b.getType ());
        let ret = YILBinaryValue::new (b.getLoc (), type, b.getOperator (), left, right);

        if (!asLeft) {
            return self.registerUniqValue (alias context, b, ret, alias list);
        } else return ret;
    }

    /**
     * Fianlize a logical bool operator
     * @params:
     *    - b: the bool operator to finalize
     *    - list: the list of stmt to fill
     * @returns: the value of the expression
     * */
    fn finalizeLogicalBool (self, dmut context : &Expander, b : &LogicalBinBoolOperatorValue, dmut list : &StmtList)-> &YILValue {
        let dmut rightList = StmtList::new ();
        let left = self.finalize (alias context, b.getLeft (), alias list);
        let right = self.finalize (alias context, b.getRight (), alias rightList);

        let type = context:.finalizeType (b.getType ());
        let var = self.createVarForBlock (alias context, b.getLoc (), type, alias list);
        let dmut ifL = StmtList::new (), dmut ifNL = StmtList::new ();

        if (b.getOperator () == BinaryOperators::DAND) { // if (left) { right } else { left }
            ifL:.append (rightList);
            ifL:.append (YILAffect::new (b.getLoc (), var, right));

            ifNL:.append (YILAffect::new (b.getLoc (), var, left));
        } else { // operator == ||
            ifL:.append (YILAffect::new (b.getLoc (), var, left));

            ifNL:.append (rightList);
            ifNL:.append (YILAffect::new (b.getLoc (), var, right));
        };

        self.finalizeCond (b.getLoc (), alias context, alias list, left, ifL, ifNL);
        var
    }

    /**
     * Finalize a class type comparison operator
     * @params:
     *    - c: the class cmp operator to finalize
     *    - list: the list of stmt to fill
     * @returns: the value of the expression
     * */
    fn finalizeClassTypCmp (self, dmut context : &Expander, c : &CmpClassTypeOperatorValue, dmut list : &StmtList)-> &YILValue {
        let left = if (c.getLeft ().isOf!{&ReferencerValue} ()) { // can be a reference value if this test is inside a pattern matching
                                                                 // i don't really know if it should be tested there (binary operator validator) or here
            self.finalize (alias context, c.getLeft ().asOf!{&ReferencerValue} ().getValue (), alias list)
        } else {
            self.finalize (alias context, c.getLeft (), alias list)
        };

        let derefInst = YILUnrefValue::new (c.getLoc (), left.getType ().asOf!{&YILPointer} ().getInner (), left);

        let rightVtableName = context:.getMangler ().mangleVtable (c.getRType ());
        let rvtable = YILAddrValue::new (c.getLoc (), YIL_PTR_2_VOID, YILVar::new (c.getLoc (), rightVtableName, YIL_PTR_2_VOID, 0us));

        let lvtable = YILFieldValue::new (c.getLoc (), YIL_PTR_2_VOID, derefInst, name-> "#_vtable"s8);
        let vtableAddrU = self.createVarForBlock (alias context, c.getLoc (), YIL_PTR_2_VOID, alias list, withValue-> lvtable);
        let call = YILNameCallValue::new (c.getLoc (), YIL_UINT_8, CoreNames::YRT_CMP_CLASS_OF_TYPE, [rvtable, vtableAddrU]);

        if (c.getOperator () == BinaryOperators::NOT_OF) {
            let resCall = self.createVarForBlock (alias context, c.getLoc (), YIL_UINT_8, alias list, withValue-> call);
            YILUnaryValue::new (c.getLoc (), YIL_UINT_8, UnaryOperators::NOT, resCall)
        } else {
            call
        }
    }

    /**
     * Finalize an unary operator
     * @params:
     *    - context: the context of the expansion
     *    - u: the unary operator to finalize
     *    - list: the list of statement to fill
     * */
    fn finalizeUnary (self, dmut context : &Expander, u : &UnaryOperatorValue, dmut list : &StmtList)-> &YILValue {
        let value = self.finalize (alias context, u.getOperand (), alias list);
        let type = context:.finalizeType (u.getType ());

        YILUnaryValue::new (u.getLoc (), type, u.getOperator (), value)
    } 

    /**
     * =====================================================================================
     * =====================================================================================
     * ========================            FIELD EXPANSION           =======================
     * =====================================================================================
     * =====================================================================================
     */

    /**
     * Finalize a field access value
     * @params:
     *    - f : the field access to finalize
     *    - list: the list of statement to fill
     * @returns: the value of the access
     * */
    fn finalizeField (self, dmut context : &Expander, f : &FieldOperatorValue, dmut list : &StmtList)-> &YILValue {
        match f {
            c : &ClassFieldAccessValue => { self.finalizeClassFieldAccess (alias context, c, alias list) }
            c : &ClosureFieldAccessValue => { self.finalizeClosureFieldAccess (alias context, c, alias list) }
            s : &StructFieldAccessValue => { self.finalizeStructFieldAccess (alias context, s, alias list) }
            t : &TupleFieldAccessValue => { self.finalizeTupleFieldAccess (alias context, t, alias list) }
            o : &OptionFieldAccessValue => { self.finalizeOptionFieldAccess (alias context, o, alias list) }
            c : &ClassTypeInfoAccessValue => { self.finalizeClassTypeInfoAccess (alias context, c, alias list) }
            _ => {
                eprintln (f::typeinfo.name);
                __pragma!panic ();
            }
        }
    }

    /**
     * Finalize the access of a field in a class value
     * @params:
     *    - f: the field access to finalize
     *    - list: the list of statement to fill
     * */
    fn finalizeClassFieldAccess (self, dmut context : &Expander, f : &ClassFieldAccessValue, dmut list : &StmtList)-> &YILValue {
        let cl = self.finalize (alias context, f.getClassInstance (), alias list);
        let type = cl.getType ();
        let retType = context:.finalizeType (f.getType ());

        let clR = YILUnrefValue::new (f.getLoc (), type.asOf!{&YILPointer} ().getInner (), cl);
        YILFieldValue::new (f.getLoc (), retType, clR, name-> f.getFieldName ())
    }

    /**
     * Finalize the access of a field in a closure value
     * @params:
     *    - f: the field access to finalize
     *    - list: the list of statement to fill
     * */
    fn finalizeClosureFieldAccess (self, dmut context : &Expander, f : &ClosureFieldAccessValue, dmut list : &StmtList)-> &YILValue {
        let cl = self.finalize (alias context, f.getClosure (), alias list);
        let retType = context:.finalizeType (f.getType ());
        let clR = YILUnrefValue::new (f.getLoc (), cl.getType ().asOf!{&YILPointer} ().getInner (), cl);

        YILFieldValue::new (f.getLoc (), retType, clR, index-> f.getFieldIndex ())
    }

    /**
     * Finalize the access of a field in a struct value
     * @params:
     *    - f: the field access to finalize
     *    - list: the list of statement to fill
     * */
    fn finalizeStructFieldAccess (self, dmut context : &Expander, f : &StructFieldAccessValue, dmut list : &StmtList)-> &YILValue {
        let retType = context:.finalizeType (f.getType ());
        let str = self.finalize (alias context, f.getStruct (), alias list);

        YILFieldValue::new (f.getLoc (), retType, str, name-> f.getFieldName ())
    }

    /**
     * Finalize the access of a field in an option value
     * @params:
     *    - o: the field access to finalize
     *    - list: the list of statement to fill
     * */
    fn finalizeOptionFieldAccess (self, dmut context : &Expander, o : &OptionFieldAccessValue, dmut list : &StmtList)-> &YILValue {
        let retType = context:.finalizeType (o.getType ());
        let opt = self.finalize (alias context, o.getOption (), alias list);

        let optContentType = opt.getType ().asOf!{&YILTuple} ().getInners ()[1];

        // a.error => a.content.error, a.value => a.content.value
        let content = YILFieldValue::new (o.getLoc (), optContentType, opt, name-> OptionKeys::CONTENT);
        YILFieldValue::new (o.getLoc (), retType, content, name-> o.getFieldName ())
    }

    /**
     * Finalize the access of a field in a tuple value
     * @params:
     *    - f: the field access to finalize
     *    - list: the list of statement to fill
     * */
    fn finalizeTupleFieldAccess (self, dmut context : &Expander, f : &TupleFieldAccessValue, dmut list : &StmtList)-> &YILValue {
        let retType = context:.finalizeType (f.getType ());
        let str = self.finalize (alias context, f.getTuple (), alias list);

        YILFieldValue::new (f.getLoc (), retType, str, index-> f.getFieldIndex ())
    }

    /**
     * Finalize the access of the typeinfo of an object instance
     * @params:
     *    - ti:  the access to finalize
     *    - list: the list of stmt to fill
     * */
    fn finalizeClassTypeInfoAccess (self, dmut context : &Expander, ti : &ClassTypeInfoAccessValue, dmut list : &StmtList)-> &YILValue {
        let loc = ti.getLoc ();
        let inst = self.finalize (alias context, ti.getClassInstance (), alias list);

        let instU = self.createVarForBlock (alias context, loc, inst.getType (), alias list, withValue-> inst);
        let derefInst = YILUnrefValue::new (loc, inst.getType ().asOf!{&YILPointer} ().getInner (), instU);

        let vtableAddr = YILFieldValue::new (loc, YIL_PTR_2_VOID, derefInst, name-> "#_vtable"s8);
        let typeInfoT = context:.finalizeType (ti.getType ());
        let vtableAddrU = self.createVarForBlock (alias context, loc, YIL_PTR_2_VOID, alias list, withValue-> vtableAddr); // vtable => [*typeinfo, *dtor, *method1, ..., *methodN]

        let tiPtr = YILCastValue::new (loc, YILPointer::new (typeInfoT), YILUnrefValue::new (loc, YIL_PTR_VOID, vtableAddrU));
        YILUnrefValue::new (loc, typeInfoT, tiPtr)
    }

    /**
     * =====================================================================================
     * =====================================================================================
     * ========================            CALL EXPANSION           ========================
     * =====================================================================================
     * =====================================================================================
     */

    /**
     * Finalize a call operator value
     * @params:
     *    - c: the call operator to validate
     *    - list: the list of statement to fill
     * @returns: the value of the call if any
     * */
    fn finalizeCall (self, dmut context : &Expander, c : &CallOperatorValue, dmut list : &StmtList)-> &YILValue {
        // Call of function performs heavy computation with possible side effects
        // Function call must appear only once in the finalized code
        match context.getVariable (c.getUniqId ()) {
            Ok (u : &YILValue) => { // The call was already seen and validated
                return u;
            }
        };

        let call = match c {
            ca : &CallValue => { self.finalizeSimpleCall (alias context, ca, alias list) }
            ctor : &CtorCallValue => { self.finalizeCtorCall (alias context, ctor, alias list) }
            fptr : &FuncPtrCallValue => { self.finalizeFuncPtrCall (alias context, fptr, alias list) }
            meth : &MethodCallValue => { self.finalizeMethodCall (alias context, meth, alias list) }
            _ => {
                eprintln (c::typeinfo.name);
                __pragma!panic ();
            }
        };

        let result = self.registerUniqValue (alias context, c, call, alias list);
        if (result.isOf!{&YILUnit} ()) {
            list:.append (YILCall::new (c.getLoc (), call));
        }

        result
    }

    /**
     * Finalize a simple call value
     * @params:
     *   - c: the call value to finalize
     *   - list: the statement list to fill
     * @returns: the value of the call
     * */
    fn finalizeSimpleCall (self, dmut context : &Expander, c : &CallValue, dmut list : &StmtList)-> &YILValue {
        let retType = context:.finalizeType (c.getType ());

        let dmut params = Vec!{&YILValue}::new ();
        for i in c.getParameters () {
            params:.push (self.finalize (alias context, i, alias list));
        }

        for i in c.getAddParameters () {
            params:.push (self.finalize (alias context, i, alias list));
        }

        let name = context.getMangler ().mangle (c.getPrototype ());
        YILNameCallValue::new (c.getLoc (), retType, name, params[])
    }

    /**
     * Finalize a class ctor call value
     * @params:
     *     -
     * */
    fn finalizeCtorCall (self, dmut context : &Expander, c : &CtorCallValue, dmut list : &StmtList)-> &YILValue {
        let retType = context:.finalizeType (c.getType ());
        let inst = self.finalizeCtorSelf (alias context, c.getLoc (), retType, c.getType (), c.getCtor ().getInstance (), alias list);

        let dmut params = Vec!{&YILValue}::new ();
        params:.push (inst);
        for pi in c.getParameters () {
            params:.push (self.finalize (alias context, pi, alias list));
        }
        for pi in c.getAddParameters () {
            params:.push (self.finalize (alias context, pi, alias list));
        }

        let name = context.getMangler ().mangle (c.getCtor ().getPrototype ());
        list:.append (YILCall::new (c.getLoc (), YILNameCallValue::new (c.getLoc (), retType, name, params[])));
        inst
    }

    /**
     * Finalize the creation of a new class instance, that is not constructed but only allocated
     * @params:
     *     - loc: the location of the ctor construction
     *     - clType: the ClassPtr version of the type of the class to construct
     *     - inst: the instance value generator (if nonevalue, then call class allocation)
     *     - list: the list to fill
     * @returns: the instance of the class
     * */
    fn finalizeCtorSelf (self, dmut context : &Expander, loc : &Word, retType : &YILType, clType : &Type, inst : &Value, dmut list : &StmtList)-> &YILValue {
        // We gave a value to the ctor
        if (!inst.isOf!{&UnitValue} ())  return self.finalize (alias context, inst, alias list);

        let varref = self.createVarForBlock (alias context, loc, retType, alias list, name-> "__self_%"s8);

        let vtableName = context:.getMangler ().mangleVtable (clType.asOf!{&ClassPtrType} ().getInner ());
        let vtableAddr = YILAddrValue::new (loc, YIL_PTR_2_VOID,
                                            YILVar::new (loc, vtableName, YIL_PTR_2_VOID, 0us));


        let callVal = YILNameCallValue::new (loc, retType, CoreNames::YRT_ALLOC_CLASS, [vtableAddr]);
        list:.append (YILAffect::new (loc, varref, callVal));

        varref
    }

    /**
     * Finalize a call to a function pointer
     * @params:
     *    - f: the function pointer to finalize
     *    - list: the list of statement to fill
     * @returns: the call
     * */
    fn finalizeFuncPtrCall (self, dmut context : &Expander, f : &FuncPtrCallValue, dmut list : &StmtList)-> &YILValue {
        let retType = context:.finalizeType (f.getType ());

        let dmut params = Vec!{&YILValue}::new ();
        for pi in f.getParameters () {
            params:.push (self.finalize (alias context, pi, alias list));
        }

        match f.getFuncPtr () {
            n : &NameFuncPtrValue => {
                let proto = context.getMangler ().mangle (n.getPrototype ());
                YILNameCallValue::new (f.getLoc (), retType, proto, params [])
            }
            _ => {
                let fptr = self.finalize (alias context, f.getFuncPtr (), alias list);
                YILPtrCallValue::new (f.getLoc (), retType, fptr, params[])
            }
        }
    }

    /**
     * Finalize a call to a method value
     * @params:
     *     - f: the method call to finalize
     *     - list: the list of statement to fill
     * @returns: the result of the call
     * */
    fn finalizeMethodCall (self, dmut context : &Expander,  f : &MethodCallValue, dmut list : &StmtList)-> &YILValue {
        let retType = context:.finalizeType (f.getType ());

        let dmut params = Vec!{&YILValue}::new ();
        let methProto = f.getMethod ();
        let inst = self.finalize (alias context, methProto.getClosure (), alias list);

        params:.push (inst);
        for pi in f.getParameters () {
            params:.push (self.finalize (alias context, pi, alias list));
        }

        for pi in f.getAddParameters () {
            params:.push (self.finalize (alias context, pi, alias list));
        }

        if (methProto.isDirect ()) {
            let name = context.getMangler ().mangle (methProto.getPrototype ());
            YILNameCallValue::new (f.getLoc (), retType, name, params[])
        } else {
            let fptr = self.createVtableAccess (alias context, f.getLoc (), inst, methProto.getVtableIndex (), alias list);
            YILPtrCallValue::new (f.getLoc (), retType, fptr, params[])
        }
    }

    /**
     * Access a method from the vtable of a class instance
     * @params:
     *    - loc: the location of the access
     *    - proto: the proto value, defining the type of the final value
     *    - index: the index of the function in the vtable
     * @returns: the address of the method to call
     * */
    fn createVtableAccess (self, dmut context : &Expander, loc : &Word, inst : &YILValue, index : usize, dmut list : &StmtList)-> &YILValue {
        let ptrSize = global::state::instance ().getSizeTypeSize () / 8us;

        let instU = self.createVarForBlock (alias context, loc, inst.getType (), alias list, withValue-> inst);
        let derefInst = YILUnrefValue::new (loc, inst.getType ().asOf!{&YILPointer} ().getInner (), instU);


        let vtableAddr = YILFieldValue::new (loc, YIL_PTR_2_VOID, derefInst, name-> "#_vtable"s8);
        let vtableAddrU = self.createVarForBlock (alias context, loc, YIL_PTR_2_VOID, alias list, withValue-> vtableAddr);

        // +1us because 0 is the dtor
        let funcInVtableAddr = YILBinaryValue::new (loc,
                                                    YIL_PTR_2_VOID,
                                                    BinaryOperators::PLUS,
                                                    vtableAddrU,
                                                    YILIntValue::new (loc, YIL_UINT_MAX, (index + 2us) * cast!{usize} (ptrSize))); // [TYPEINFO, DTOR, funcs*]

        let funcInVtableAddrU = self.createVarForBlock (alias context, loc, YIL_PTR_2_VOID, alias list, withValue-> funcInVtableAddr);
        YILUnrefValue::new (loc, YIL_PTR_VOID, funcInVtableAddrU)
    }

    /**
     * =====================================================================================
     * =====================================================================================
     * =====================            SLICE/ARRAY EXPANSION           ====================
     * =====================================================================================
     * =====================================================================================
     */

    /**
     * Finalize an operator on slice or array operands
     * @params:
     *    - sl: the operator to finalize
     *    - list: the list of statement to fill
     * */
    fn finalizeSliceOrArrayOp (self, dmut context : &Expander, sl : &SliceOrArrayOperatorValue, dmut list : &StmtList)-> &YILValue {
        match sl {
            a : &ArrayAccessValue => { self.finalizeArrayAccess (alias context, a, alias list) }
            c : &SliceConcatValue => { self.finalizeSliceConcat (alias context, c, alias list) }
            s : &SliceAccessValue => { self.finalizeSliceAccess (alias context, s, alias list) }
            s : &SliceCompareValue => { self.finalizeSliceCompare (alias context, s, alias list) }
            _ => {
                eprintln (sl::typeinfo.name);
                __pragma!panic ();
            }
        }
    }

    /**
     * Finalize an array access value
     * @params:
     *    - context: the context of the finalization
     *    - a: the array access to finalize
     *    - list: the list of statement to fill
     * */
    fn finalizeArrayAccess (self, dmut context : &Expander, a : &ArrayAccessValue, dmut list : &StmtList)-> &YILValue {
        let arr = self.finalize (alias context, a.getArray (), alias list, asLeft-> true);
        let index = self.finalize (alias context, a.getIndex (), alias list);
        let type = context:.finalizeType (a.getType ());

        YILArrayAccessValue::new (a.getLoc (), type, arr, index)
    }

    /**
     * Finalize a slice concatenation operation
     * @params:
     *    - context: the context of the finalization
     *    - a: the slice concat to finalize
     *    - list: the list of statement to fill
     * */
    fn finalizeSliceConcat (self, dmut context : &Expander, s : &SliceConcatValue, dmut list : &StmtList)-> &YILValue {
        // Slice concat allocates values, thus must be performed only once
        match context.getVariable (s.getUniqId ()) {
            Ok (u : &YILValue) => { // The call was already seen and validated
                return u;
            }
        };

        let left = self.finalize (alias context, s.getLeft (), alias list);
        let right = self.finalize (alias context, s.getRight (), alias list);
        let type = context:.finalizeType (s.getType ());
        let inner = context:.finalizeType (s.getType ().asOf!{&SliceType} ().getInners ()[0]);
        let size = YILIntValue::new (s.getLoc (), YIL_UINT_MAX, inner.getSize ());

        let call = YILNameCallValue::new (s.getLoc (), type, CoreNames::YRT_CONCAT_SLICE, [left, right, size]);

        return self.registerUniqValue (alias context, s, call, alias list);
    }

    /**
     * Finalize a slice access value
     * @params:
     *    - context: the context of the finalization
     *    - s: the slice access to finalize
     *    - list: the list of statement to fill
     * */
    fn finalizeSliceAccess (self, dmut context : &Expander, s : &SliceAccessValue, dmut list : &StmtList)-> &YILValue {
        let slc = self.finalize (alias context, s.getSlice (), alias list);
        let index = self.finalize (alias context, s.getIndex (), alias list);

        let resType = context:.finalizeType (s.getType ());
        let size = YILIntValue::new (s.getLoc (), YIL_UINT_MAX, resType.getSize ());

        let indexV = YILBinaryValue::new (s.getLoc (), YIL_UINT_MAX, BinaryOperators::STAR, size, index);
        let indexVU = self.createVarForBlock (alias context, s.getLoc (), YIL_UINT_MAX, alias list, withValue-> indexV);
        let ptrT = YILPointer::new (resType);

        let dataField = YILBinaryValue::new (s.getLoc (),
                                              YIL_PTR_VOID,
                                              BinaryOperators::PLUS,
                                              YILFieldValue::new (s.getLoc (), YIL_PTR_VOID, slc, name-> SliceKeys::PTR),
                                              indexVU);

        let dataFieldU = self.createVarForBlock (alias context, s.getLoc (), YIL_UINT_MAX, alias list, withValue-> dataField);
        let finalPtrV = YILCastValue::new (s.getLoc (), ptrT, dataFieldU);
        YILUnrefValue::new (s.getLoc (),
                            resType,
                            self.registerUniqValue (alias context, s, type-> ptrT, finalPtrV, alias list))
    }

    /**
     * Finalize the comparison of two slices
     * @params:
     *    - context: the context of the finalization
     *    - s: the slice compare to finalize
     *    - list: the list of statement to fill
     * */
    fn finalizeSliceCompare (self, dmut context : &Expander, s : &SliceCompareValue, dmut list : &StmtList)-> &YILValue {
        context;
        s;
        list;
        __pragma!panic ();
    }

    /**
     * =====================================================================================
     * =====================================================================================
     * ========================            MEMORY EXPANSION           ======================
     * =====================================================================================
     * =====================================================================================
     */

    /**
     * Finalize a memory operation value
     * @params:
     *    - context: the context of the finalization
     *    - mem: the memory value to finalize
     *    - list: the list of statement to fill
     * */
    fn finalizeMemory (self, dmut context : &Expander, mem : &MemoryValue, dmut list : &StmtList)-> &YILValue {
        match mem {
            a : &AddressValue => { self.finalizeAddress (alias context, a, alias list) }
            a : &AliaserValue => { self.finalize (alias context, a.getValue (), alias list) }
            c : &CopierValue => { self.finalizeCopier (alias context, c, alias list) }
            d : &DereferencerValue => { self.finalizeDeref (alias context, d, alias list) }
            r : &ReferencerValue => { self.finalizeRef (alias context, r, alias list) }
            _ => {
                eprintln (mem::typeinfo.name);
                __pragma!panic ();
            }
        }
    }

    /**
     * Finalize an address value
     * @params:
     *    - context: the context of the finalization
     *    - add: the address value to finalize
     *    - list: the list of statement to fill
     * */
    fn finalizeAddress (self, dmut context : &Expander, add : &AddressValue, dmut list : &StmtList)-> &YILValue {
        let type = context:.finalizeType (add.getType ());
        let value = self.finalize (alias context, add.getValue (), alias list, asLeft-> true);

        let depthRet = context.getTypeExpander ().getPointerDepth (type);
        let depthVal = context.getTypeExpander ().getPointerDepth (value.getType ());

        // sometimes AddressValue are used on already constructed addresses (references, string literals, ...)
        // So if we get a pointer value that has the same depth, meaning pointer of pointer of ...
        // Then we can assume it is already constructed, and can be returned as it is, with a cast though
        if (depthVal == depthRet) {
            YILCastValue::new (add.getLoc (), type, value)
        } else {
            self.createAddress (alias context, value, type-> type.asOf!{&YILPointer} (), alias list)
        }
    }

    /**
     * Create an address from a value
     * If the value is not addressable, then put it in a variable and return the address of the variable
     * */
    fn createAddress (self, dmut context : &Expander, value : &YILValue, type : &YILPointer, dmut list : &StmtList)-> &YILValue {
        match value {
            v : &YILVar => {
                return YILAddrValue::new (value.getLoc (), type, v);
            }
            u : &YILUnrefValue => {
                return YILCastValue::new (value.getLoc (), type, u.getValue ());
            }
            f : &YILFieldValue => {
                return YILAddrValue::new (value.getLoc (), type, f);
            }
            _ => {
                let var = self.createVarForBlock (alias context, value.getLoc (), value.getType (), alias list);
                list:.append (YILAffect::new (value.getLoc (), var, value));

                return YILAddrValue::new (var.getLoc (), type, var);
            }
        }
    }

    /**
     * Finalize a copier value
     * @params:
     *    - context: the context of the finalization
     *    - c: the copier value to copy
     *    - list: the list of statement to fill
     * */
    fn finalizeCopier (self, dmut context : &Expander, c : &CopierValue, dmut list : &StmtList)-> &YILValue {
        // If the copy is a done copy, then we only need to validate its inner value
        if (c.isDone ()) {
            // assuming that it is a call, so no need to save the uniqness
            return self.finalize (alias context, c.getValue (), alias list);
        }

        // otherwise, we need to call builtin functions
        // Copy performs heavy computation with possible side effects
        // Copy values must appear only once in the finalized code
        match context.getVariable (c.getUniqId ()) {
            Ok (u : &YILValue) => { // The copy was already seen and validated
                return u;
            }
        };

        let call = match c.getType () {
            slc : &SliceType => { self.finalizeCopierSlice (alias context, c, slc, alias list) }
            p : &PointerType => {
                match p.getInners ()[0] {
                    t : &TupleType => { self.finalizeCopierTuple (alias context, c, t, alias list) }
                    t : _ => {
                        eprintln (t::typeinfo.name);
                        __pragma!panic ();
                    }
                }
            }
            t : _ => {
                eprintln (t::typeinfo.name);
                __pragma!panic ();
            }
        };

        return self.registerUniqValue (alias context, c, call, alias list);
    }

    /**
     * Finalize a copier value that returns a slice
     * */
    fn finalizeCopierSlice (self, dmut context : &Expander, c : &CopierValue, slc : &SliceType, dmut list : &StmtList)-> &YILValue {
        let value = self.finalize (alias context, c.getValue (), alias list);
        if (slc.getInners ()[0].isOf!{&VoidType} ()) { return value; } // copy []

        let valueU = self.createVarForBlock (alias context, c.getLoc (), value.getType (), alias list, withValue-> value);

        let retType = context:.finalizeType (c.getType ());
        let innerType = context:.finalizeType (slc.getInners ()[0]);
        let innerSize = YILIntValue::new (c.getLoc (), YIL_UINT_32, innerType.getSize ());

        let lenU = YILFieldValue::new (c.getLoc (), YIL_UINT_MAX, valueU, name-> SliceKeys::LEN);
        let ptrU = YILFieldValue::new (c.getLoc (), YIL_UINT_MAX, valueU, name-> SliceKeys::PTR);

        let finalPtr = YILNameCallValue::new (c.getLoc (), YIL_PTR_VOID, CoreNames::YRT_DUPLICATE_SLICE, [ptrU, lenU, innerSize]);
        let finalPtrU = self.createVarForBlock (alias context, c.getLoc (), finalPtr.getType (), alias list, withValue-> finalPtr);

        YILTupleValue::new (c.getLoc (), retType, [lenU, finalPtrU], fieldNames-> [SliceKeys::LEN, SliceKeys::PTR])
    }


    /**
     * Finalize the copy of a tuple value
     * */
    fn finalizeCopierTuple (self, dmut context : &Expander, c : &CopierValue, t : &TupleType, dmut list : &StmtList)-> &YILValue {
        if (t.getInners ().len == 0us) return YIL_NULL_VALUE;

        let value = self.finalize (alias context, c.getValue (), alias list);
        let retType = context:.finalizeType (c.getType ());

        let innerType = context:.finalizeType (t);
        let innerSize = YILIntValue::new (c.getLoc (), YIL_UINT_32, innerType.getSize ());

        let tuAddr = YILAddrValue::new (c.getLoc (), retType, value);

        YILNameCallValue::new (c.getLoc (), retType, CoreNames::YRT_DUPLICATE_TUPLE, [tuAddr, innerSize])
    }


    /**
     * Finalize a dereferencer value
     * */
    fn finalizeDeref (self, dmut context : &Expander, d : &DereferencerValue, dmut list : &StmtList)-> &YILValue {
        let value = self.finalize (alias context, d.getValue (), alias list);
        let type = context:.finalizeType (d.getType ());

        YILUnrefValue::new (d.getLoc (), type, value)
    }

    /**
     * Finalize a referencer value
     * */
    fn finalizeRef (self, dmut context : &Expander, r : &ReferencerValue, dmut list : &StmtList)-> &YILValue {
        // same as an addresser but storing the inner type only
        let type = YILPointer::new (context:.finalizeType (r.getType ()));
        let value = self.finalize (alias context, r.getValue (), alias list, asLeft-> true);

        let depthRet = context.getTypeExpander ().getPointerDepth (type);
        let depthVal = context.getTypeExpander ().getPointerDepth (value.getType ());

        // sometimes references are used on already constructed addresses (references, string literals, ...)
        // So if we get a pointer value that has the same depth, meaning pointer of pointer of ...
        // Then we can assume it is already constructed, and can be returned as it is, with a cast though
        if (depthVal == depthRet) {
            YILCastValue::new (r.getLoc (), type, value)
        } else {
            self.createAddress (alias context, value, type-> type.asOf!{&YILPointer} (), alias list)
        }
    }

    /**
     * =====================================================================================
     * =====================================================================================
     * =======================          CONSTRUCT EXPANSION          =======================
     * =====================================================================================
     * =====================================================================================
     */

    /**
     * Finalize a construct value
     * @params:
     *    - context: the context of the finalization
     *    - ctor: the construct value to finalize
     *    - list: the list of statement to fill
     * */
    fn finalizeConstruct (self, dmut context : &Expander, ctor : &ConstructValue, dmut list : &StmtList, asLeft : bool)-> &YILValue {
        match context.getVariable (ctor.getUniqId ()) {
            Ok (u : &YILValue) => { // The call was already seen and validated
                return u;
            }
        };

        let val = match ctor {
            c : &CastValue => { self.finalizeCast (alias context, c, alias list) }
            c : &CtorDelegateValue => { self.finalizeCtorDG (alias context, c, alias list) }
            d : &NameDelegateValue => { self.finalizeNameDG (alias context, d, alias list) }
            n : &NameFuncPtrValue => { self.finalizeNameFptr (alias context, n, alias list) }
            m : &MethodDelegateValue => { self.finalizeMethodDG (alias context, m, alias list) }
            r : &RangeValue => { self.finalizeRange (alias context, r, alias list) }
            s : &SliceCtorValue => { self.finalizeSliceCtor (alias context, s, alias list) }
            t : &TypeInfoValue => { self.finalizeTypeInfo (alias context, t, alias list) }
            n : &ErrOptionValue => { return self.finalizeErrOpt (alias context, n, alias list); }
            o : &OptionValue => { return self.finalizeOption (alias context, o, alias list); }
            _ => {
                eprintln (ctor::typeinfo.name);
                __pragma!panic ();
            }
        }

        if (!asLeft) {
            return self.registerUniqValue (alias context, ctor, val, alias list);
        } else return val;
    }

    /**
     * Finalize a cast value
     * @params:
     *    - context: the context of the finalization
     *    - ct: the cast value to finalize
     *    - list: the list of statement to fill
     * */
    fn finalizeCast (self, dmut context : &Expander, ct : &CastValue, dmut list : &StmtList)-> &YILValue {
        let value = self.finalize (alias context, ct.getValue (), alias list);
        let type = context:.finalizeType (ct.getType ());
        match (type, value) {
            (ti : &YILInt, vi : &YILIntValue) => {
                return YILIntValue::new (ct.getLoc (), ti, vi.getValue ());
            } 
        }

        YILCastValue::new (ct.getLoc (), type, value)
    }

    /**
     * Finalize a delegate to a constructor prototype
     * */
    fn finalizeCtorDG (self, dmut context : &Expander, ctor : &CtorDelegateValue, dmut list : &StmtList)-> &YILValue {
        let name = context.getMangler ().mangle (ctor.getPrototype ());

        let protoRef = YILAddrValue::new (ctor.getLoc (), YIL_PTR_VOID, YILVar::new (ctor.getLoc (), name, YIL_VOID, 0us));
        let instance = self.finalize (alias context, ctor.getInstance (), alias list);
        let type = context:.finalizeType (ctor.getType ());

        YILTupleValue::new (ctor.getLoc (), type, [instance, protoRef], fieldNames-> [DelegateKeys::CLOSURE, DelegateKeys::FUNC])
    }

    /**
     * Finalize a delegate referenced by a function name
     * */
    fn finalizeNameDG (self, dmut context : &Expander, name : &NameDelegateValue, dmut list : &StmtList)-> &YILValue {
        let pname = context.getMangler ().mangle (name.getPrototype ());

        let protoRef = YILAddrValue::new (name.getLoc (), YIL_PTR_VOID, YILVar::new (name.getLoc (), pname, YIL_VOID, 0us));
        let instance = self.finalize (alias context, name.getClosure (), alias list);
        let type = context:.finalizeType (name.getType ());

        YILTupleValue::new (name.getLoc (), type, [instance, protoRef], fieldNames-> [DelegateKeys::CLOSURE, DelegateKeys::FUNC])
    }

    /**
     * Finalize a function pointer referenced by a function name
     * */
    fn finalizeNameFptr (self, dmut context : &Expander, name : &NameFuncPtrValue, dmut _ : &StmtList)-> &YILValue {
        let pname = context.getMangler ().mangle (name.getPrototype ());
        YILAddrValue::new (name.getLoc (), YIL_PTR_VOID, YILVar::new (name.getLoc (), pname, YIL_VOID, 0us))
    }

    /**
     * Finalize the creation of a method delegate value
     * */
    fn finalizeMethodDG (self, dmut context : &Expander, meth : &MethodDelegateValue, dmut list : &StmtList)-> &YILValue {
        let inst = self.finalize (alias context, meth.getClosure (), alias list);

        let fptr = self.createVtableAccess (alias context, meth.getLoc (), inst, meth.getVtableIndex (), alias list);
        let type = YILTuple::new ([YIL_PTR_VOID, YIL_PTR_VOID], fieldNames-> [DelegateKeys::CLOSURE, DelegateKeys::FUNC]);


        YILTupleValue::new (meth.getLoc (), type, [inst, fptr], fieldNames-> [DelegateKeys::CLOSURE, DelegateKeys::FUNC])
    }

    /**
     * Finalize the creation of a range value
     * */
    fn finalizeRange (self, dmut context : &Expander, rng : &RangeValue, dmut list : &StmtList)-> &YILValue {
        let left = self.finalize (alias context, rng.getLeft (), alias list);
        let right = self.finalize (alias context, rng.getRight (), alias list);
        let step = self.finalize (alias context, rng.getStep (), alias list);
        let contain = self.finalize (alias context, rng.getIsFull (), alias list);
        let type = context:.finalizeType (rng.getType ());

        YILTupleValue::new (rng.getLoc (), type, [left, right, step, contain], fieldNames-> [RangeKeys::FST, RangeKeys::SCD, RangeKeys::STEP, RangeKeys::CONTAIN])
    }

    /**
     * Finalize a slice ctor value
     * */
    fn finalizeSliceCtor (self, dmut context : &Expander, ctor : &SliceCtorValue, dmut list : &StmtList)-> &YILValue {
        let type = context:.finalizeType (ctor.getType ());
        let len = self.finalize (alias context, ctor.getLen (), alias list);
        let ptr = self.finalize (alias context, ctor.getPointer (), alias list);

        YILTupleValue::new (ctor.getLoc (), type, [len, ptr], fieldNames-> [SliceKeys::LEN, SliceKeys::PTR])
    }

    /**
     * Finalize the creation of a typeinfo
     * */
    fn finalizeTypeInfo (self, dmut context : &Expander, ti : &TypeInfoValue, dmut list : &StmtList)-> &YILValue {
        let id = self.finalize (alias context, ti.getId (), alias list);
        let size = self.finalize (alias context, ti.getSize (), alias list);
        let inner = self.finalize (alias context, ti.getInners (), alias list);
        let name = self.finalize (alias context, ti.getName (), alias list);

        let type = context:.finalizeType (ti.getType ());
        YILTupleValue::new (ti.getLoc (), type, [id, size, inner, name])
    }

    /**
     * Finalize a none value literal
     * */
    fn finalizeErrOpt (self, dmut context : &Expander, n : &ErrOptionValue, dmut list : &StmtList)-> &YILValue {
        let type = context:.finalizeType (n.getType ());
        let contentType = type.asOf!{&YILTuple} ().getInners ()[1]; // {.ok, .content}
        let errValue = self.finalize (alias context, n.getValue (), alias list);

        let content = YILTupleValue::new (n.getLoc (), contentType, fieldNames-> [OptionKeys::ERROR], [errValue]);

        YILTupleValue::new (n.getLoc (), type, fieldNames-> [OptionKeys::SET, OptionKeys::CONTENT],
                            [YILIntValue::new (n.getLoc (), YIL_UINT_8, 0us), content]) // {.set = 0, .content = {.error = null}}
    }

    /**
     * Finalize an option value construction
     * */
    fn finalizeOption (self, dmut context : &Expander, o : &OptionValue, dmut list : &StmtList)-> &YILValue {
        let innerValue = self.finalize (alias context, o.getValue (), alias list);
        let type = context:.finalizeType (o.getType ());
        let contentType = type.asOf!{&YILTuple} ().getInners ()[1]; // {.ok, .content}

        let content = YILTupleValue::new (o.getLoc (), contentType, fieldNames-> [OptionKeys::VALUE], [innerValue]);

        YILTupleValue::new (o.getLoc (), type, fieldNames-> [OptionKeys::SET, OptionKeys::CONTENT],
                            [YILIntValue::new (o.getLoc (), YIL_UINT_8, 1us), content]) // {.set = 1, .content = {.value = value}}
    }

}
