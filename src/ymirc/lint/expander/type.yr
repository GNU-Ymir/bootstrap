in type;

use ymirc::lint::expander::{visitor, value, stmtlist};
use ymirc::lint::node::{_, global::_, instr::_, type::_, value::_};

use std::io;

use ymirc::utils::format;
use ymirc::semantic::generator::_;
use ymirc::global::core_;
use ymirc::syntax::keys;
use ymirc::lexing::word;

use std::fs::path;

use ymirc::semantic::{symbol::path, generator::_};
use ymirc::semantic::generator::type::{_,
                                       custom::_,
                                       native::{_, scalar::_, compound::_},
                                       temporary::_};

use ymirc::semantic::generator::value::{_,
                                        construct::{_, delegate::_},
                                        literal::_,
                                        memory::_,
                                        operator::{_, binary::_, call::_, fields::_, map::_, slice::_, unary::_},
                                        prototypes::_,
                                        scope::_,
                                        syntax::_,
                                        template::_};


/**
 * The type expander is used to expand types into a list of statements
 */
pub record TypeExpander {

    /**
     * Create an empty type expander
     * */
    pub self () {}

    /**
     * Finalize a type
     * @params:
     *    - context: the context of the expansion
     *    - ty: the type to expand
     * @returns: the final type
     * */
    pub fn finalize (self, dmut context : &Expander, ty : &Type)-> &YILType {
        match ty {
            b : &NativeType => { self.finalizeNative (alias context, b) }
            c : &CustomType => { self.finalizeCustom (alias context, c) }
            t : &TemporaryType => { self.finalizeTemporary (alias context, t) }
            _ => {
                eprintln (ty.__typeinfo__.name);
                panic;
            }
        }
    }

    /**
     * @returns: the depth of a pointer
     * @example:
     * ================
     * *i32 => 1
     * *(*i32) => 2
     * *(*(*i32)) => 3
     * i32 => 0
     * ================
     * */
    pub fn getPointerDepth (self, ty : &YILType)-> usize {
        match ty {
            p : &YILPointer => { 1us + self.getPointerDepth (p.getInner ()) }
            _ => { 0us }
        }
    }

    /*!
     * =====================================================================================
     * =====================================================================================
     * =========================            NATIVE TYPES           =========================
     * =====================================================================================
     * =====================================================================================
     */

    /**
     * Expand a native type
     * @params:
     *    - context: the context of the expansion
     *    - ty: the type to expand
     * */
    fn finalizeNative (self, dmut context : &Expander, ty : &NativeType)-> &YILType {
        match ty {
            BoolType () => { return YIL_UINT_8; }
            c : &CharType => { return self.finalizeChar (c); }
            f : &FloatType => { return self.finalizeFloat (f); }
            i : &IntType => { return self.finalizeInt (i); }
            VoidType () => { return YIL_VOID; }
            NoneType () => { return YIL_VOID; }
            d : &DelegateType => { return self.finalizeDelegate (alias context, d); }
            fptr : &FuncPtrType => { return self.finalizeFuncPtr (alias context, fptr); }
            cmp : &CompoundType => { return self.finalizeCompound (alias context, cmp); }
            _ => {
                eprintln (ty.__typeinfo__.name);
                panic;
            }
        }
    }

    /**
     * Finalize a char type
     * */
    fn finalizeChar (self, c : &CharType)-> &YILType {
        match c.getSize () {
            8u16 => { YIL_UINT_8 }
            16u16 => { YIL_UINT_16 }
            _ => { YIL_UINT_32 }
        }
    }

    /**
     * Finalize an int type
     * */
    fn finalizeInt (self, i : &IntType)-> &YILType {
        match (i.getSize (), i.isSigned ()) {
            (8u16, true) => { YIL_SINT_8 }
            (16u16, true) => { YIL_SINT_16 }
            (32u16, true) => { YIL_SINT_32 }
            (64u16, true) => { YIL_SINT_64 }
            (_, true) => { YIL_SINT_MAX }

            (8u16, false) => { YIL_UINT_8 }
            (16u16, false) => { YIL_UINT_16 }
            (32u16, false) => { YIL_UINT_32 }
            (64u16, false) => { YIL_UINT_64 }
            _  => { YIL_UINT_MAX }
        }
    }

    /**
     * Finalize a float type
     * */
    fn finalizeFloat (self, f : &FloatType)-> &YILType {
        match f.getSize () {
            32u16 => { YIL_FLOAT_32 }
            64u16 => { YIL_FLOAT_64 }
            80u16 => { YIL_FLOAT_80 }
            _ => { YIL_FLOAT_MAX }
        }
    }

    /**
     * Finalize a delegate type
     * @params:
     *    - context: the context of the expansion
     *    - d: the delegate type to expand
     * */
    fn finalizeDelegate (self, dmut _ : &Expander, _ : &DelegateType)-> &YILType {
        copy YILTuple (copy [YIL_PTR_VOID, YIL_PTR_VOID], fieldNames-> copy [DelegateKeys::CLOSURE, DelegateKeys::FUNC])
    }

    /**
     * Finalize a lazy type
     * */
    pub fn finalizeLazy (self)-> &YILType {
        let delegateT = copy YILTuple (copy [YIL_PTR_VOID, YIL_PTR_VOID],
                                       fieldNames-> copy [DelegateKeys::CLOSURE, DelegateKeys::FUNC]);

        let opt = copy YILTuple (copy [YIL_UINT_8, YIL_PTR_VOID, YIL_UINT_32, delegateT],
                                 fieldNames-> copy [LazyKeys::IS_SET, LazyKeys::VALUE, LazyKeys::SIZE, LazyKeys::FUNC]);

        opt
    }

    /**
     * Finalize a function pointer type
     * @params:
     *    - context: the context of the finalization
     *    - fptr: the type to finalize
     * */
    fn finalizeFuncPtr (self, dmut _ : &Expander, _ : &FuncPtrType)-> &YILType {
        YIL_PTR_VOID
    }

    /**
     * Finalize a compound type
     * @params:
     *    - context: the context of the finalization
     *    - ty: the type to finalize
     * */
    fn finalizeCompound (self, dmut context : &Expander, ty : &CompoundType)-> &YILType {
        match ty {
            a : &ArrayType => { return self.finalizeArray (alias context, a); }
            p : &PointerType => { return self.finalizePointer (alias context, p); }
            r : &RangeType => {  return self.finalizeRange (alias context, r); }
            s : &SliceType => { return self.finalizeSlice (alias context, s); }
            t : &TupleType => { return self.finalizeTuple (alias context, t); }
            o : &OptionType => { return self.finalizeOption (alias context, o); }
            f : &FutureType => { return self.finalizeFuture (alias context, f); }
            m : &MapType => { return self.finalizeMap (alias context, m); }
            _ => {
                eprintln (ty.__typeinfo__.name);
                panic;
            }
        }
    }

    /**
     * Finalize an array type
     * */
    fn finalizeArray (self, dmut context : &Expander, ty : &ArrayType)-> &YILType {
        let inner = context:.finalizeType (ty.getInners ()[0]);
        if (inner of YILVoid) return YIL_ARRAY_VOID;

        copy YILArray (inner, ty.getLen ())
    }

    /**
     * Finalize a pointer type
     * */
    fn finalizePointer (self, dmut context : &Expander, ty : &PointerType)-> &YILType {
        if (ty.getInners ()[0] of NoneType) return YIL_PTR_VOID; // null literal type

        let inner = context:.finalizeType (ty.getInners ()[0]);
        if (inner of YILVoid) return YIL_PTR_VOID;

        copy YILPointer (inner)
    }

    /**
     * Finalize a range type
     * */
    fn finalizeRange (self, dmut context : &Expander, rng : &RangeType)-> &YILType {
        let inner = context:.finalizeType (rng.getInners ()[0]);
        let step = context:.finalizeType (rng.getInners ()[1]);

        copy YILTuple (copy [inner, inner, step, YIL_UINT_8],
                       fieldNames-> copy [RangeKeys::FST, RangeKeys::SCD, RangeKeys::STEP, RangeKeys::CONTAINS])
    }

    /**
     * Finalize a slice type
     * */
    fn finalizeSlice (self, dmut context : &Expander, sl : &SliceType)-> &YILType {
        let inner = context:.finalizeType (sl.getInners ()[0]);
        let len = YIL_UINT_MAX;

        copy YILTuple (copy [len, copy YILPointer (inner), copy YILPointer (YIL_VOID)],
                       fieldNames-> copy [SliceKeys::LEN, SliceKeys::PTR, SliceKeys::BLK_INFO])
    }

    /**
     * Finalize a tuple type
     * */
    fn finalizeTuple (self, dmut context : &Expander, tu : &TupleType)-> &YILType {
        copy YILTuple (copy [context:.finalizeType (ti) for ti in tu.getInners ()])
    }

    /**
     * Finalize an option type
     * */
    fn finalizeOption (self, dmut context : &Expander, o : &OptionType)-> &YILType {
        let inner = if (o.getInners ()[0] of VoidType || o.getInners ()[0] of NoneType) {
            YIL_UINT_8
        } else { context:.finalizeType (o.getInners ()[0]) };

        let isSet = YIL_UINT_8;
        let error = self.finalizeGenericClassPtr (alias context);

        let value = copy YILTuple (copy [error, inner],
                                   fieldNames-> copy [OptionKeys::ERROR, OptionKeys::VALUE],
                                   isUnion-> true);

        copy YILTuple (copy [isSet, value], fieldNames-> copy [OptionKeys::SET, OptionKeys::CONTENT])
    }

    /**
     * Finalize a map type
     * */
    fn finalizeMap (self, dmut _ : &Expander, _ : &MapType)-> &YILType {
        let inner = copy YILTuple (copy [YIL_PTR_VOID, YIL_PTR_VOID, YIL_UINT_MAX, YIL_UINT_MAX, YIL_UINT_MAX],
                                   fieldNames-> copy [MapKeys::BLK_INFO, MapKeys::ENTRIES, MapKeys::LEN, MapKeys::CAP, MapKeys::LOADED]);

        copy YILPointer (inner)
    }

    /**
     * Finalize a future type
     * */
    pub fn finalizeFuture (self, dmut _ : &Expander, _ : &FutureType)-> &YILType {
        copy YILTuple (copy [YIL_UINT_MAX, YIL_PTR_VOID],
                       fieldNames-> copy [FutureKeys::THREAD_ID, FutureKeys::CONTENT])
    }

   /*!
     * =====================================================================================
     * =====================================================================================
     * =========================            CUSTOM TYPES           =========================
     * =====================================================================================
     * =====================================================================================
     */

    /**
     * Finalize a custom type
     * */
    fn finalizeCustom (self, dmut context : &Expander, c : &CustomType)-> &YILType {
        match c {
            cl : &ClassPtrType => { self.finalizeClassPtr (alias context, cl) }
            en : &EnumType => { self.finalize (alias context, en.getProxy ()) }
            _ => {
                eprintln (c.__typeinfo__.name);
                panic;
            }
        }
    }

    /**
     * Finalize a class ptr type
     * */
    fn finalizeClassPtr (self, dmut context : &Expander, c : &ClassPtrType)-> &YILType {
        let inner = {
            self.finalizeClassRef (alias context, c.getInner (), c.isStruct ())
        } catch {
            _ => panic; // invalid class
        }

        if (!c.isStruct ()) {
            copy YILPointer (inner)
        } else {
            inner
        }
    }

    /**
     * Create a generic class pointer type
     * */
    fn finalizeGenericClassPtr (self, dmut _ : &Expander)-> &YILType {
        let inner = copy YILTuple (copy [YIL_PTR_2_VOID, YIL_PTR_VOID],
                                   fieldNames-> copy [ClassKeys::VTABLE, ClassKeys::MONITOR]);

        copy YILPointer (inner)
    }


    /*!
     * =====================================================================================
     * =====================================================================================
     * =======================            TEMPORARY TYPES           ========================
     * =====================================================================================
     * =====================================================================================
     */

    /**
     * Finalize a temporary type (a type that cannot be directly associated to a value, but still describe something)
     * */
    fn finalizeTemporary (self, dmut context : &Expander, t : &TemporaryType)-> &YILType {
        match t {
            c : &ClassRefType => { self.finalizeClassRef (alias context, c, c.getSymbol ().isStruct ()) }
            c : &ClosureType => { self.finalizeClosure (alias context, c) }
            m : &MapIteratorType => { self.finalizeMapIterator (alias context, m) }
            _ => {
                eprintln (t.__typeinfo__.name);
                panic;
            }
        }
    }

    /**
     * Validate a class reference type
     * */
    fn finalizeClassRef (self, dmut context : &Expander, cr : &ClassRefType, isStruct : bool)-> &YILType {
        match context.findClassValidation (cr) {
            Ok (c : &YILType) => return c;
        }

        if (context.isInClassValidation (cr)) {
            YIL_VOID
        } else {
            context:.enterClassValidation (cr);

            let mut params : [mut &YILType] = [];
            let mut names : [mut [c8]] = [];

            if (!isStruct) {
                params ~= [YIL_PTR_2_VOID, YIL_PTR_VOID];
                names ~= [ClassKeys::VTABLE, ClassKeys::MONITOR];
            } else if (cr.getSymbol ().isMovable ()) {
                params ~= [YIL_UINT_8];
                names ~= [ClassKeys::SET];
            }

            for v in cr.getFields () {
                params ~= [context:.finalizeType (v.getVarType ())];
                names  ~= [v.getLoc ().str];
            }

            let final = copy YILTuple (params, fieldNames-> names);
            context:.exitClassValidation (cr, final);

            final
        }
    }

    /**
     * Finalize a closure type
     * */
    fn finalizeClosure (self, dmut context : &Expander, cl : &ClosureType)-> &YILType {
        let mut params : [mut &YILType] = [];
        for pi in cl.getInnerTypes () {
            params ~= [context:.finalizeType (pi)];
        }

        let inner = copy YILTuple (params, fieldNames-> cl.getInnerNames ());
        copy YILPointer (inner)
    }

    /**
     * Finalize a map iterator type
     */
    fn finalizeMapIterator (self, dmut _ : &Expander, _ : &MapIteratorType)-> &YILType {
        YIL_PTR_VOID
    }

}
