in type;

use ymirc::lint::expander::{visitor, value, stmtlist};
use ymirc::lint::node::{_, global::_, instr::_, type::_, value::_};

use std::io;

use ymirc::utils::format;
use ymirc::semantic::generator::_;
use ymirc::global::core_;
use ymirc::syntax::keys;
use ymirc::lexing::word;

use std::fs::path;

use ymirc::semantic::{symbol::path, generator::_};
use ymirc::semantic::generator::type::{_,
                                       custom::_,
                                       native::{_, scalar::_, compound::_},
                                       temporary::_};

use ymirc::semantic::generator::value::{_,
                                        construct::{_, delegate::_},
                                        literal::_,
                                        memory::_,
                                        operator::{_, binary::_, call::_, fields::_, map::_, slice::_, unary::_},
                                        prototypes::_,
                                        scope::_,
                                        syntax::_,
                                        template::_};


/**
 * The type expander is used to expand types into a list of statements
 */
pub class TypeExpander {

    // The list of tuple values the expander has generated
    let mut _tuples : [&YILTuple => mut &YILTuple] = copy [];

    // The finalized ranges types
    let mut _ranges : [(&YILInt, &YILInt) => mut &YILTuple] = copy [];

    // The finalized slices
    let mut _slices : [&YILType => mut &YILTuple] = copy [];

    // The uniq id for tuples insertion
    let mut _uid = 0us;

    // The delegate type
    let _dgType : &YILTuple;

    // The lazyOpt type
    let _lazyOpt : &YILTuple;

    // The future tuple type
    let _futureType : &YILTuple;

    // The tuple of a map
    let _mapType : &YILTuple;

    // The generic class tuple
    let _genericClass : &YILTuple;

    /**
     * Create an empty type expander
     * */
    pub self ()
        with _dgType = copy YILTuple (copy [YIL_PTR_VOID, YIL_PTR_VOID], fieldNames-> copy [DelegateKeys::CLOSURE, DelegateKeys::FUNC], uid-> 1us)
        , _lazyOpt = copy YILTuple (copy [YIL_UINT_8, YIL_PTR_VOID, YIL_UINT_32, self._dgType],
                                    fieldNames-> copy [LazyKeys::IS_SET, LazyKeys::VALUE, LazyKeys::SIZE, LazyKeys::FUNC], uid-> 2us)
        , _mapType = copy YILTuple (copy [YIL_PTR_VOID, YIL_PTR_VOID, YIL_UINT_MAX, YIL_UINT_MAX, YIL_UINT_MAX],
                                    fieldNames-> copy [MapKeys::BLK_INFO, MapKeys::ENTRIES, MapKeys::LEN, MapKeys::CAP, MapKeys::LOADED], uid-> 3us)
        , _futureType =  copy YILTuple (copy [YIL_UINT_MAX, YIL_PTR_VOID],
                                        fieldNames-> copy [FutureKeys::THREAD_ID, FutureKeys::CONTENT], uid-> 4us)
        , _genericClass = copy YILTuple (copy [YIL_PTR_2_VOID, YIL_PTR_VOID],
                                         fieldNames-> copy [ClassKeys::VTABLE, ClassKeys::MONITOR], uid-> 5us)
        , _uid = 6us
    {}

    /**
     * Finalize a type
     * @params:
     *    - context: the context of the expansion
     *    - ty: the type to expand
     * @returns: the final type
     * */
    pub fn finalize (mut self, dmut context : &Expander, ty : &Type)-> &YILType {
        match ty {
            b : &NativeType => { self:.finalizeNative (alias context, b) }
            c : &CustomType => { self:.finalizeCustom (alias context, c) }
            t : &TemporaryType => { self:.finalizeTemporary (alias context, t) }
            _ => {
                eprintln (ty.__typeinfo__.name);
                panic;
            }
        }
    }

    /**
     * @returns: the depth of a pointer
     * @example:
     * ================
     * *i32 => 1
     * *(*i32) => 2
     * *(*(*i32)) => 3
     * i32 => 0
     * ================
     * */
    pub fn getPointerDepth (self, ty : &YILType)-> usize {
        match ty {
            p : &YILPointer => { 1us + self.getPointerDepth (p.getInner ()) }
            _ => { 0us }
        }
    }

    /**
     * @returns: the list of tuples defined during expansion
     * */
    pub fn getTuples (self)-> [&YILTuple] {
        copy [v for _, v in self._tuples]
    }

    /*!
     * =====================================================================================
     * =====================================================================================
     * =========================            NATIVE TYPES           =========================
     * =====================================================================================
     * =====================================================================================
     */

    /**
     * Expand a native type
     * @params:
     *    - context: the context of the expansion
     *    - ty: the type to expand
     * */
    fn finalizeNative (mut self, dmut context : &Expander, ty : &NativeType)-> &YILType {
        match ty {
            BoolType () => { return YIL_UINT_8; }
            c : &CharType => { return self:.finalizeChar (c); }
            f : &FloatType => { return self:.finalizeFloat (f); }
            i : &IntType => { return self:.finalizeInt (i); }
            VoidType () => { return YIL_VOID; }
            NoneType () => { return YIL_VOID; }
            d : &DelegateType => { return self:.finalizeDelegate (alias context, d); }
            fptr : &FuncPtrType => { return self:.finalizeFuncPtr (alias context, fptr); }
            cmp : &CompoundType => { return self:.finalizeCompound (alias context, cmp); }
            _ => {
                eprintln (ty.__typeinfo__.name);
                panic;
            }
        }
    }

    /**
     * Finalize a char type
     * */
    fn finalizeChar (mut self, c : &CharType)-> &YILType {
        match c.getSize () {
            8u16 => { YIL_UINT_8 }
            16u16 => { YIL_UINT_16 }
            _ => { YIL_UINT_32 }
        }
    }

    /**
     * Finalize an int type
     * */
    fn finalizeInt (mut self, i : &IntType)-> &YILInt {
        match (i.getSize (), i.isSigned ()) {
            (8u16, true) => { YIL_SINT_8 }
            (16u16, true) => { YIL_SINT_16 }
            (32u16, true) => { YIL_SINT_32 }
            (64u16, true) => { YIL_SINT_64 }
            (_, true) => { YIL_SINT_MAX }

            (8u16, false) => { YIL_UINT_8 }
            (16u16, false) => { YIL_UINT_16 }
            (32u16, false) => { YIL_UINT_32 }
            (64u16, false) => { YIL_UINT_64 }
            _  => { YIL_UINT_MAX }
        }
    }

    /**
     * Finalize a float type
     * */
    fn finalizeFloat (mut self, f : &FloatType)-> &YILType {
        match f.getSize () {
            32u16 => { YIL_FLOAT_32 }
            64u16 => { YIL_FLOAT_64 }
            80u16 => { YIL_FLOAT_80 }
            _ => { YIL_FLOAT_MAX }
        }
    }

    /**
     * Finalize a delegate type
     * @params:
     *    - context: the context of the expansion
     *    - d: the delegate type to expand
     * */
    fn finalizeDelegate (mut self, dmut _ : &Expander, _ : &DelegateType)-> &YILType {
        self._tuples [self._dgType] = self._dgType;
        self._dgType
    }

    /**
     * Finalize a lazy type
     * */
    pub fn finalizeLazy (mut self)-> &YILType {
        self._tuples [self._dgType] = self._dgType;
        self._tuples [self._lazyOpt] = self._lazyOpt;
        self._lazyOpt
    }

    /**
     * Finalize a function pointer type
     * @params:
     *    - context: the context of the finalization
     *    - fptr: the type to finalize
     * */
    fn finalizeFuncPtr (mut self, dmut _ : &Expander, _ : &FuncPtrType)-> &YILType {
        YIL_PTR_VOID
    }

    /**
     * Finalize a compound type
     * @params:
     *    - context: the context of the finalization
     *    - ty: the type to finalize
     * */
    fn finalizeCompound (mut self, dmut context : &Expander, ty : &CompoundType)-> &YILType {
        match ty {
            a : &ArrayType => { return self:.finalizeArray (alias context, a); }
            p : &PointerType => { return self:.finalizePointer (alias context, p); }
            r : &RangeType => {  return self:.finalizeRange (alias context, r); }
            s : &SliceType => { return self:.finalizeSlice (alias context, s); }
            t : &TupleType => { return self:.finalizeTuple (alias context, t); }
            o : &OptionType => { return self:.finalizeOption (alias context, o); }
            f : &FutureType => { return self:.finalizeFuture (alias context, f); }
            m : &MapType => { return self:.finalizeMap (alias context, m); }
            _ => {
                eprintln (ty.__typeinfo__.name);
                panic;
            }
        }
    }

    /**
     * Finalize an array type
     * */
    fn finalizeArray (mut self, dmut context : &Expander, ty : &ArrayType)-> &YILType {
        let inner = context:.finalizeType (ty.getInners ()[0]);
        if (inner of YILVoid) return YIL_ARRAY_VOID;

        copy YILArray (inner, ty.getLen ())
    }

    /**
     * Finalize a pointer type
     * */
    fn finalizePointer (mut self, dmut context : &Expander, ty : &PointerType)-> &YILType {
        if (ty.getInners ()[0] of NoneType) return YIL_PTR_VOID; // null literal type

        let inner = context:.finalizeType (ty.getInners ()[0]);
        if (inner of YILVoid) return YIL_PTR_VOID;

        copy YILPointer (inner)
    }

    /**
     * Finalize a range type
     * */
    fn finalizeRange (mut self, dmut _ : &Expander, rng : &RangeType)-> &YILType {
        let inner = self:.finalizeInt (rng.getInners () [0].asOf!{&IntType} ());
        let step = self:.finalizeInt (rng.getInners ()[1].asOf!{&IntType} ());

        if let Ok (t) = self._ranges [(inner, step)] {
            return t;
        }

        let ret = copy YILTuple (copy [inner, inner, step, YIL_UINT_8],
                                 fieldNames-> copy [RangeKeys::FST, RangeKeys::SCD, RangeKeys::STEP, RangeKeys::CONTAINS],
                                 uid-> self._uid);
        self._uid += 1;
        self._ranges [(inner, step)] = ret;
        self._tuples [ret] = ret;
        ret
    }

    /**
     * Finalize a slice type
     * */
    fn finalizeSlice (mut self, dmut context : &Expander, sl : &SliceType)-> &YILType {
        let inner = context:.finalizeType (sl.getInners ()[0]);

        if let Ok (t) = self._slices [inner] {
            return t;
        }

        let len = YIL_UINT_MAX;
        let slc = copy YILTuple (copy [len, copy YILPointer (inner), copy YILPointer (YIL_VOID)],
                                 fieldNames-> copy [SliceKeys::LEN, SliceKeys::PTR, SliceKeys::BLK_INFO],
                                 uid-> self._uid);

        self._uid += 1;
        self._slices [inner] = slc;
        self._tuples [slc] = slc;

        slc
    }

    /**
     * Finalize a tuple type
     * */
    fn finalizeTuple (mut self, dmut context : &Expander, tu : &TupleType)-> &YILType {
        let ret = copy YILTuple (copy [context:.finalizeType (ti) for ti in tu.getInners ()],
                                 uid-> self._uid);

        if let Ok (t) = self._tuples [ret] {
            return t;
        }

        self._uid += 1;
        self._tuples [ret] = ret;
        ret
    }

    /**
     * Finalize an option type
     * */
    fn finalizeOption (mut self, dmut context : &Expander, o : &OptionType)-> &YILType {
        let inner = if (o.getInners ()[0] of VoidType || o.getInners ()[0] of NoneType) {
            YIL_UINT_8
        } else { context:.finalizeType (o.getInners ()[0]) };

        let isSet = YIL_UINT_8;
        let error = self:.finalizeGenericClassPtr (alias context);

        let mut value = copy YILTuple (copy [error, inner],
                                   fieldNames-> copy [OptionKeys::ERROR, OptionKeys::VALUE],
                                   isUnion-> true,
                                   uid-> self._uid);

        if let Ok (v) = self._tuples [value] {
            value = v;
        } else {
            self._uid += 1;
            self._tuples [value] = value;
        }

        let ret = copy YILTuple (copy [isSet, value],
                                 fieldNames-> copy [OptionKeys::SET, OptionKeys::CONTENT],
                                 uid-> self._uid);

        if let Ok (t) = self._tuples [ret] {
            return t;
        }

        self._uid += 1;
        self._tuples [ret] = ret;
        ret
    }

    /**
     * Finalize a map type
     * */
    fn finalizeMap (mut self, dmut _ : &Expander, _ : &MapType)-> &YILType {
        self._tuples [self._mapType] = self._mapType;
        copy YILPointer (self._mapType)
    }

    /**
     * Finalize a future type
     * */
    pub fn finalizeFuture (mut self, dmut _ : &Expander, _ : &FutureType)-> &YILType {
        self._tuples [self._futureType] = self._futureType;
        self._futureType
    }

   /*!
     * =====================================================================================
     * =====================================================================================
     * =========================            CUSTOM TYPES           =========================
     * =====================================================================================
     * =====================================================================================
     */

    /**
     * Finalize a custom type
     * */
    fn finalizeCustom (mut self, dmut context : &Expander, c : &CustomType)-> &YILType {
        match c {
            cl : &ClassPtrType => { self:.finalizeClassPtr (alias context, cl) }
            en : &EnumType => { self:.finalize (alias context, en.getProxy ()) }
            _ => {
                eprintln (c.__typeinfo__.name);
                panic;
            }
        }
    }

    /**
     * Finalize a class ptr type
     * */
    fn finalizeClassPtr (mut self, dmut context : &Expander, c : &ClassPtrType)-> &YILType {
        let inner = {
            self:.finalizeClassRef (alias context, c.getInner (), c.isStruct ())
        } catch {
            _ => panic; // invalid class
        }

        if (!c.isStruct ()) {
            copy YILPointer (inner)
        } else {
            inner
        }
    }

    /**
     * Create a generic class pointer type
     * */
    fn finalizeGenericClassPtr (mut self, dmut _ : &Expander)-> &YILType {
        if (self._genericClass !in self._tuples) {
            self._tuples [self._genericClass] = self._genericClass;
        }

        copy YILPointer (self._genericClass)
    }


    /*!
     * =====================================================================================
     * =====================================================================================
     * =======================            TEMPORARY TYPES           ========================
     * =====================================================================================
     * =====================================================================================
     */

    /**
     * Finalize a temporary type (a type that cannot be directly associated to a value, but still describe something)
     * */
    fn finalizeTemporary (mut self, dmut context : &Expander, t : &TemporaryType)-> &YILType {
        match t {
            c : &ClassRefType => { self:.finalizeClassRef (alias context, c, c.getSymbol ().isStruct ()) }
            c : &ClosureType => { self:.finalizeClosure (alias context, c) }
            m : &MapIteratorType => { self:.finalizeMapIterator (alias context, m) }
            _ => {
                eprintln (t.__typeinfo__.name);
                panic;
            }
        }
    }

    /**
     * Validate a class reference type
     * */
    fn finalizeClassRef (mut self, dmut context : &Expander, cr : &ClassRefType, isStruct : bool)-> &YILType {
        match context.findClassValidation (cr) {
            Ok (c : &YILType) => return c;
        }

        if (context.isInClassValidation (cr)) {
            YIL_VOID
        } else {
            context:.enterClassValidation (cr);

            let mut params : [mut &YILType] = [];
            let mut names : [mut [c8]] = [];

            if (!isStruct) {
                params ~= [YIL_PTR_2_VOID, YIL_PTR_VOID];
                names ~= [ClassKeys::VTABLE, ClassKeys::MONITOR];
            } else if (cr.getSymbol ().isMovable ()) {
                params ~= [YIL_UINT_8];
                names ~= [ClassKeys::SET];
            }

            for v in cr.getFields () {
                params ~= [context:.finalizeType (v.getVarType ())];
                names  ~= [v.getLoc ().str];
            }

            let final = copy YILTuple (params, fieldNames-> names, uid-> self._uid);
            if let Ok (t) = self._tuples [final] {
                context:.exitClassValidation (cr, t);
                return t;
            }

            self._uid += 1;
            self._tuples [final] = final;
            context:.exitClassValidation (cr, final);

            return final;
        }
    }

    /**
     * Finalize a closure type
     * */
    fn finalizeClosure (mut self, dmut context : &Expander, cl : &ClosureType)-> &YILType {
        let mut params : [mut &YILType] = [];
        for pi in cl.getInnerTypes () {
            params ~= [context:.finalizeType (pi)];
        }

        let inner = copy YILTuple (params, fieldNames-> cl.getInnerNames (), uid-> self._uid);
        if let Ok (t) = self._tuples [inner] {
            return copy YILPointer (t);
        }

        self._uid += 1;
        self._tuples [inner] = inner;
        copy YILPointer (inner)
    }

    /**
     * Finalize a map iterator type
     */
    fn finalizeMapIterator (mut self, dmut _ : &Expander, _ : &MapIteratorType)-> &YILType {
        YIL_PTR_VOID
    }

}
