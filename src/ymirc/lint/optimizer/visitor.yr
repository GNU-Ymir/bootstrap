in visitor;

use std::io;

use ymirc::utils::format;
use ymirc::lint::{node::{_, global::_, instr::_, type::_, value::_},
                  optimizer::bblock};

use ymirc::lexing::word;
use ymirc::syntax::keys;

/**
 * The optimizer class simplifies previously validated symbols
 */
pub class Optimizer {

    // The list of generators provided by the previous pass (validation)
    let mut _nodes : [&YILNode] = [];

    // The list of optimized generators
    let mut _optimized : [mut &YILNode] = [];

    /**
     * Create a new empty optimizer
     * */
    pub self () {}

    /**
     * Optimize a list of generators
     * */
    pub fn optimize (mut self, generators : [&YILNode])-> [&YILNode] {
        self._nodes = generators;
        for gen in self._nodes {
            self:.optimize (gen);
        }

        self._optimized
    }

    /**
     * Optimize a generator
     * */
    pub fn optimize (mut self, gen : &YILNode) {
        match gen {
            frame : &YILFrame => {
                self:.optimizeFrame (frame);
            }
            _ => {
                self._optimized ~= [gen];
            }
        }
    }

    /**
     * Optimize a frame generator
     * @params:
     *    - frame: the frame to optimize
     * */
    pub fn optimizeFrame (mut self, frame : &YILFrame) {
        // let dmut entryBB = copy BasicBlock ();
        // let dmut  exitBB = copy BasicBlock ();

        // match frame.getBody () {
        //     b : &YILBlock => {
        //         let dmut bb = self.createBasicBlockFromBlock (b, parent-> alias entryBB, exit-> alias exitBB);
        //         if (bb.isFalling ()) {
        //             exitBB:.insertFrom (alias bb, copy YILIntValue (EOF_WORD, YIL_UINT_8, 1));
        //         }
        //     }
        //     x : _ => {
        //         eprintln (x.__typeinfo__.name);
        //         panic;
        //     }
        // }

        // let dmut fr = copy Formatter ();
        // fr:.write ("digraph {");
        // fr:.entabing ();
        // entryBB.format (alias fr);
        // fr:.detabing ();
        // fr:.write ("}");

        // println (fr[]);

        self._optimized ~= [frame];
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================        BASIC BLOCKS         ==========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Create a basic block from a block of instruction
     * @params:
     *    - bl: the block
     *    - parent: the block that conducted here
     * @returns:
     * */
    pub fn createBasicBlockFromBlock (self, bl : &YILBlock, dmut parent : &BasicBlock, dmut exit : &BasicBlock)-> dmut &BasicBlock {
        let dmut current = copy BasicBlock ();
        current:.insertFrom (alias parent, copy YILIntValue (EOF_WORD, YIL_UINT_8, 1));

        let mut lst : [usize => dmut &BasicBlock] = [];
        lst [0us] = alias current;

        for instr in bl.getInners () match instr {
            b : &YILBlock => {
                current = alias self.createBasicBlockFromBlock (b, alias current, alias exit);
            }
            l : &YILLabel => {
                if (current.isFalling ()) {
                    current:.push (copy YILGoto (EOF_WORD, l));
                }
                let dmut newBB = copy BasicBlock ();
                lst [l.getLabelId ()] = alias newBB;
                current = alias newBB;
            }
            _ => {
                current:.push (instr);
            }
        }

        for id in lst {
            if let Ok (dmut bb : &BasicBlock) = alias ((alias lst [id])?) {
                match bb.getLast () {
                    Ok (g : &YILGoto) => {
                        if let Ok (dmut aux : &BasicBlock) = alias ((alias lst [g.getLabel ().getLabelId ()])?) {
                            aux:.insertFrom (alias bb, copy YILIntValue (EOF_WORD, YIL_UINT_8, 1));
                        } else panic;
                    }
                    Ok (cnd : &YILCondJmp) => {
                        if let Ok (dmut aux : &BasicBlock) = alias ((alias lst [cnd.getThenLabel ().getLabelId ()])?) {
                            aux:.insertFrom (alias bb, cnd.getCond ());
                        } else panic;

                        if let Ok (dmut aux : &BasicBlock) = alias ((alias lst [cnd.getElseLabel ().getLabelId ()])?) {
                            aux:.insertFrom (alias bb, copy YILUnaryValue (EOF_WORD, YIL_UINT_8, UnaryOperators::NOT, cnd.getCond ()));
                        } else panic;
                    }
                    Ok (_ : &YILReturn) => {
                        exit:.insertFrom (alias bb, copy YILIntValue (EOF_WORD, YIL_UINT_8, 1));
                    }
                }
            }
        }

        alias current
    }







}
