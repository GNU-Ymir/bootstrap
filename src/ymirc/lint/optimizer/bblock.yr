in bblock;

use ymirc::utils::format;
use ymirc::lint::node::{_, instr::_, value::_, type::_, global::_};
use std::{stream, io};

lazy dmut __ID__ = copy [0us];

/**
 * @returns: a uniq identifier
 */
pub fn generateUniqID ()-> usize {
    __ID__ [0] += 1us;
    __ID__ [0]
}


/**
 * A basic block used to represent control flow
 * */
pub class BasicBlock {

    let _uid : usize;

    // BasicBlocks that can enter self, associated with the value conditionning the jump
    let mut _previous : [mut (&BasicBlock, &YILValue)] = [];

    // BasicBlock where self can go to, associated with the value conditionning the jump
    let mut _next : [mut (&BasicBlock, &YILValue)] = [];

    // List of instruction inside the basic block
    let mut _instrs : [mut &YILInstr] = [];

    // List of generation of every instructions in the basic block
    let mut _gens : [mut &YILValue] = [];

    // List of kills of every instructions in the basic block
    let mut _kills : [mut [mut &YILValue]] = [];

    /**
     * Create an empty basic block
     * */
    pub self ()
        with _uid = generateUniqID ()
    {}

    /**
     * Insert an instruction in the block
     * */
    pub fn push (mut self, instr : &YILInstr) {
        self._instrs ~= [instr];
    }

    /**
     * @returns: the last instruction of the block if any
     * */
    pub fn getLast (self)-> (&YILInstr)? {
        if self._instrs.len > 0 {
            return self._instrs [$ - 1]?;
        }

        none
    }

    /**
     * @returns: true iif the last instruction does not exit the block (cond jump, goto, return)
     * */
    pub fn isFalling (self)-> bool {
        match self.getLast () {
            Ok (_ : &YILGoto) => return false;
            Ok (_ : &YILCondJmp) => return false;
            Ok (_ : &YILReturn) => return false;
        }

        true
    }

    /**
     * Insert an ancestor of the basic block
     * */
    pub fn insertFrom (mut self, dmut bb : &BasicBlock, reason : &YILValue) {
        self._previous ~= [(bb, reason)];
        bb._next ~= [(self, reason)];
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================        MISCELLANEOUS         =========================
     * ================================================================================
     * ================================================================================
     */

    impl Streamable;


    pub fn format (self, dmut stream : &Formatter, ref mut done : [usize => mut ()]) {
        if (self._uid !in done) {
            let dmut inner = copy Formatter (tags-> FormatTags (short-> true));
            let isFalling = self.isFalling ();
            for z, instr in self._instrs {
                if (!isFalling && z == self._instrs.len - 1us) break;
                match instr {
                    YILVarDecl () => {}
                    _ => {
                        instr.format (alias inner);
                        inner:.write (";\n");
                    }
                }
            }

            stream:.write ("BB", self._uid, " [label=\"", inner[], "\"]\n");
            done [self._uid] = ();

            for i in self._next {
                i.0.format (alias stream, done-> ref done);
                let reason = format ("%", i.1);
                stream:.write ("BB", self._uid, " -> "s8, "BB", i.0._uid, "[label=\"", reason, "\"]\n");
            }
        }
    }

}
