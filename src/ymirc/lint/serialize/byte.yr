in byte;

use ymirc::lexing::word;
use ymirc::utils::format;
use ymirc::errors::message;
use ymirc::lint::serialize::errors;

/*!
 * ====================================================================================================
 * ====================================================================================================
 * =====================================          WRITE          ======================================
 * ====================================================================================================
 * ====================================================================================================
 */

/**
 * A byte stream is an extendable byte array
 * */
pub class ByteStream {

    // The buffer in which the writting is done
    let dmut _content : [u8] = [];
        
    pub self () {}
        
    /**
     * @returns: the content of the stream
     * */
    pub fn opIndex (mut self)-> dmut [u8] {
        alias self._content
    }

    /**
     * @returns: the content of the stream
     * */
    pub fn opIndex (self)-> [u8] {
        self._content
    }
    
    /**
     * Write an arbitrary scalar value in the stream
     * */
    pub fn write {T, J} (mut self, j : J)-> dmut &ByteStream {
        unsafe {
            let t : T = cast!T (j);
            let v : *u8 = cast!{*u8} (cast!{*void} (&t));                        
            self._content ~= [*(v + i) for i in 0us .. cast!usize (T::size)];            
        }

        alias self
    }

    /**
     * Append a byte buffer at the end of the stream
     * */
    pub fn write {T of [U], U of u8} (mut self, t : T)-> dmut &ByteStream {
        self._content ~= t;
        alias self
    }

    /**
     * Append a string buffer at the end of the stream
     * */
    pub fn write {T of [U], U of c8} (mut self, t : T)-> dmut &ByteStream {
        for c in t {
            self._content ~= [cast!{u8} (c)];
        }

        alias self
    }

    /**
     * Clear the buffer
     * */
    pub fn clear (mut self) {
        self._content = [];
    }
    
}

/*!
 * ====================================================================================================
 * ====================================================================================================
 * ======================================          READ          ======================================
 * ====================================================================================================
 * ====================================================================================================
 */

pub record ByteReader {

    let mut _content : [u8];
    let mut _cursor : usize = 0;

    pub self (content : [u8])
        with _content = content
    {}

    /**
     * @returns: the rest of the content that has not been read yet
     * */
    pub fn opIndex (self)-> [u8] {
        self._content [self._cursor .. $]
    }

    @field
    pub fn len (self)-> usize {
        self._content.len - self._cursor
    }
    
    /**
     * Read an arbitrary scalar value from the buffer
     * */
    pub fn read {T} (mut self)-> T
        throws ErrorMsg
    {
        let rest = self._content [self._cursor .. $];        
        if rest.len < T::size {
            throw copy ErrorMsg::fatal (EOF_WORD, format (SerializeYILErrorMessage::MALFORMED_BYTECODE));            
        } 
        
        unsafe {            
            let v : *T = cast!{*T} (cast!{*void} (rest.ptr));
            self._cursor += T::size;
            
            return *v;            
        }        
    }

    /**
     * Read an arbitrary array value from the buffer
     * */
    pub fn read {T of [U], U} (mut self, n : usize)-> T
        throws ErrorMsg
    {
        let rest = self._content [self._cursor .. $];
        if rest.len < U::size * n {
            throw copy ErrorMsg::fatal (EOF_WORD, format (SerializeYILErrorMessage::MALFORMED_BYTECODE)); 
        }
        
        unsafe {
            let v : *U = cast!{*U} (cast!{*void} (rest.ptr));
            self._cursor += (U::size * n); 
            return copy [v [i] for i in 0 .. n];                        
        }
    }
    
}

