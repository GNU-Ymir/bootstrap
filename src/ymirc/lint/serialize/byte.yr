in byte;

use ymirc::lexing::word;
use ymirc::utils::format;
use ymirc::errors::message;
use ymirc::lint::serialize::errors;

/*!
 * ====================================================================================================
 * ====================================================================================================
 * =====================================          WRITE          ======================================
 * ====================================================================================================
 * ====================================================================================================
 */

/**
 * A byte stream is an extendable byte array
 * */
pub class ByteStream {

    // The buffer in which the writting is done
    let dmut _content : [u8] = [];
        
    pub self () {}
        
    /**
     * @returns: the content of the stream
     * */
    pub fn opIndex (mut self)-> dmut [u8] {
        alias self._content
    }

    /**
     * @returns: the content of the stream
     * */
    pub fn opIndex (self)-> [u8] {
        self._content
    }
    
    /**
     * Write an arbitrary scalar value in the stream
     * */
    pub fn write {T of u8, J} (mut self, j : J)-> dmut &ByteStream {        
        let b_0 = cast!u8 (j);                
        self._content ~= [b_0];                                         

        alias self
    }

    /**
     * Write an arbitrary scalar value in the stream
     * */
    pub fn write {T of bool, J} (mut self, j : J)-> dmut &ByteStream {        
        let b_0 = cast!u8 (j);                
        self._content ~= [b_0];                                         

        alias self
    }

    /**
     * Write an arbitrary scalar value in the stream
     * */
    pub fn write {T of u32, J} (mut self, j : J)-> dmut &ByteStream {        
        let t = cast!u32 (j);
        let b_0 = cast!u8 (t >> 24);
        let b_1 = cast!u8 (t >> 16);
        let b_2 = cast!u8 (t >> 8);
        let b_3 = cast!u8 (t);
        
        self._content ~= [b_3, b_2, b_1, b_0];                                         

        alias self
    }

    /**
     * Write an arbitrary scalar value in the stream
     * */
    pub fn write {T of u64, J} (mut self, j : J)-> dmut &ByteStream {        
        let t = cast!u64 (j);
        let b_0 = cast!u8 (t >> 56);
        let b_1 = cast!u8 (t >> 48);
        let b_2 = cast!u8 (t >> 40);
        let b_3 = cast!u8 (t >> 32);
        
        let b_4 = cast!u8 (t >> 24);
        let b_5 = cast!u8 (t >> 16);
        let b_6 = cast!u8 (t >> 8);
        let b_7 = cast!u8 (t);
        
        self._content ~= [b_7, b_6, b_5, b_4, b_3, b_2, b_1, b_0];                                         

        alias self
    }

    /**
     * Write an arbitrary scalar value in the stream
     * */
    pub fn write {T of i64, J} (mut self, j : J)-> dmut &ByteStream {
        return self:.write!{u64} (cast!i64 (j));        
    }

    
    /**
     * Append a byte buffer at the end of the stream
     * */
    pub fn write {T of [U], U of u8} (mut self, t : T)-> dmut &ByteStream {
        self._content ~= t;
        alias self
    }

    /**
     * Append a string buffer at the end of the stream
     * */
    pub fn write {T of [U], U of c8} (mut self, t : T)-> dmut &ByteStream {
        for c in t {
            self._content ~= [cast!{u8} (c)];
        }

        alias self
    }

    /**
     * Clear the buffer
     * */
    pub fn clear (mut self) {
        self._content = [];
    }
    
}

/*!
 * ====================================================================================================
 * ====================================================================================================
 * ======================================          READ          ======================================
 * ====================================================================================================
 * ====================================================================================================
 */

pub record ByteReader {

    let mut _content : [u8];
    let mut _cursor : usize = 0;

    pub self (content : [u8])
        with _content = content
    {}

    /**
     * @returns: the rest of the content that has not been read yet
     * */
    pub fn opIndex (self)-> [u8] {
        self._content [self._cursor .. $]
    }

    @field
    pub fn len (self)-> usize {
        self._content.len - self._cursor
    }
    
    /**
     * Read a long int from the stream
     * */
    pub fn read {T of u64} (mut self)-> u64
        throws ErrorMsg
    {
        let rest = self._content [self._cursor .. $];        
        if rest.len < 8us {
            throw copy ErrorMsg::fatal (EOF_WORD, format (SerializeYILErrorMessage::MALFORMED_BYTECODE));            
        } 
                           
        self._cursor += u64::size;

        let mut result = 0u64;
        result += cast!u64 (rest [0]);
        result += cast!u64 (rest [1]) << 8;
        result += cast!u64 (rest [2]) << 16;
        result += cast!u64 (rest [3]) << 24;
        
        result += cast!u64 (rest [4]) << 32;
        result += cast!u64 (rest [5]) << 40;
        result += cast!u64 (rest [6]) << 48;
        result += cast!u64 (rest [7]) << 56;
        
        return result;                        
    }

    /**
     * Read a long int from the stream
     * */
    pub fn read {T of i64} (mut self)-> i64
        throws ErrorMsg
    {
        return cast!i64 (self:.read!{u64} ());                        
    }
    
    /**
     * Read a int from the stream
     * */
    pub fn read {T of u32} (mut self)-> u32
        throws ErrorMsg
    {
        let rest = self._content [self._cursor .. $];        
        if rest.len < 4us {
            throw copy ErrorMsg::fatal (EOF_WORD, format (SerializeYILErrorMessage::MALFORMED_BYTECODE));            
        } 
                           
        self._cursor += u32::size;

        let mut result = 0u32;
        result += cast!u32 (rest [0]);
        result += cast!u32 (rest [1]) << 8;
        result += cast!u32 (rest [2]) << 16;
        result += cast!u32 (rest [3]) << 24;
                        
        return result;                        
    }

    /**
     * Read a byte
     * */
    pub fn read {T of u8} (mut self)-> u8
        throws ErrorMsg
    {
        let rest = self._content [self._cursor .. $];        
        if rest.len < 1us {
            throw copy ErrorMsg::fatal (EOF_WORD, format (SerializeYILErrorMessage::MALFORMED_BYTECODE));            
        } 
                           
        self._cursor += u8::size;
        return rest [0];                        
    }

    /**
     * Read a char
     * */
    pub fn read {T of c8} (mut self)-> c8
        throws ErrorMsg
    {
        let rest = self._content [self._cursor .. $];        
        if rest.len < 1us {
            throw copy ErrorMsg::fatal (EOF_WORD, format (SerializeYILErrorMessage::MALFORMED_BYTECODE));            
        } 
                           
        self._cursor += u8::size;
        return cast!c8 (rest [0]);                        
    }

    /**
     * Read a bool
     * */
    pub fn read {T of bool} (mut self)-> bool
        throws ErrorMsg
    {
        let rest = self._content [self._cursor .. $];        
        if rest.len < 1us {
            throw copy ErrorMsg::fatal (EOF_WORD, format (SerializeYILErrorMessage::MALFORMED_BYTECODE));            
        } 
                           
        self._cursor += u8::size;
        return if (rest [0] == 0) { false } else { true };                        
    }

    /**
     * Read an arbitrary array value from the buffer
     * */
    pub fn read {T of [U ; N], U, N : usize} (mut self)-> T
        throws ErrorMsg
    {        
        return [self:.read!{U} () for _ in 0 .. N];                                
    }
    
    /**
     * Read an arbitrary array value from the buffer
     * */
    pub fn read {T of [U ; N], U of c8, N : usize} (mut self)-> T
        throws ErrorMsg
    {
        let rest = self._content [self._cursor .. $];
        if rest.len < N {
            throw copy ErrorMsg::fatal (EOF_WORD, format (SerializeYILErrorMessage::MALFORMED_BYTECODE)); 
        }
                
        self._cursor += N; 
        return [cast! {c8} (rest [i]) for i in 0 .. N];                                
    }
    
    /**
     * Read an arbitrary array value from the buffer
     * */
    pub fn read {T of [U], U of c8} (mut self, n : usize)-> T
        throws ErrorMsg
    {
        let rest = self._content [self._cursor .. $];
        if rest.len < n {
            throw copy ErrorMsg::fatal (EOF_WORD, format (SerializeYILErrorMessage::MALFORMED_BYTECODE)); 
        }
                
        self._cursor += n; 
        return copy [cast! {c8} (rest [i]) for i in 0 .. n];                                
    }

    /**
     * Read an arbitrary array value from the buffer
     * */
    pub fn read {T of [U], U of u8} (mut self, n : usize)-> T
        throws ErrorMsg
    {
        let rest = self._content [self._cursor .. $];
        if rest.len < n {
            throw copy ErrorMsg::fatal (EOF_WORD, format (SerializeYILErrorMessage::MALFORMED_BYTECODE)); 
        }
        
        rest [0 .. n]
    }
    
}

