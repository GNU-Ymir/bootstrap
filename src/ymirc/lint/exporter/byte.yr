in byte;

/**
 * A byte stream is an extendable byte array
 * */
pub class ByteStream {

    // The buffer in which the writting is done
    let dmut _content : [u8] = [];

    pub self () {}

    /**
     * @returns: the content of the stream
     * */
    pub fn opIndex (mut self)-> dmut [u8] {
        alias self._content
    }


    /**
     * @returns: the content of the stream
     * */
    pub fn opIndex (self)-> [u8] {
        self._content
    }
    
    /**
     * Write an arbitrary scalar value in the stream
     * */
    pub fn write {T, J} (mut self, j : J)-> dmut &ByteStream {
        unsafe {
            let t : T = cast!T (j);
            let v : *u8 = cast!{*u8} (cast!{*void} (&t));                        
            self._content ~= [*(v + i) for i in 0us .. cast!usize (T::size)];            
        }

        alias self
    }

    /**
     * Append a byte buffer at the end of the stream
     * */
    pub fn write {T of [U], U of u8} (mut self, t : T)-> dmut &ByteStream {
        self._content ~= t;
        alias self
    }

    /**
     * Append a string buffer at the end of the stream
     * */
    pub fn write {T of [U], U of c8} (mut self, t : T)-> dmut &ByteStream {
        for c in t {
            self._content ~= [cast!{u8} (c)];
        }

        alias self
    }

    /**
     * Clear the buffer
     * */
    pub fn clear (mut self) {
        self._content = [];
    }
    
}
