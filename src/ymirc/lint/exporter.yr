in exporter;

use ymirc::errors::message;
use ymirc::global::{core_, state, common};
use ymirc::lexing::word;

use ymirc::lint::node::{_, instr::_, global::_, type::_, value::_};
use ymirc::utils::format;

use std::{io, fs::{path, file}};

pub enum : u8
| FLOAT   = 1
| INT     = 2
| VOID    = 3
| ARRAY   = 4
| TUPLE   = 5
| POINTER = 6
| OFFSET  = 7
 -> TypeID;


pub enum : u8
| FRAME    = 1
| GLOBAL   = 2
| CONSTANT = 3
 -> SymbolID;

/**
 * This generator export YIL nodes into a object file that can be reloaded as is
 * Can be useful to build objects with different back-ends
 * */
pub record YILExporter {

    // The directory in which the modules come from
    let _packageDir : Path;

    prv {
        
        // The list of types to export
        // name => (bytecode)
        let mut _types : [usize => mut &YILType] = copy [];

        // The bytecode of all symbols
        // name => (weak, bytecode)
        let mut _symbols : [[c8] => mut (bool, &YILSymbol)] = copy [];
        
    }
    
    prv { // headers
                
        // The list of symbols to export in a file
        let dmut _exportSymbols : [Path => [[c8] => ()]] = copy [];

        // The list of files found and to export 
        let dmut _exportFiles : [Path => ()] = copy [];
        
    }


    prv { // context

        // The offest of string in the string table
        let dmut _currentStringTableHead : [[c8] => usize] = copy [];

        // The offset of the type in the type table
        let dmut _currentTypeTableHead : [usize => ()] = copy [];

        // The string table of the file being exported
        let dmut _currentStringTableContent : [u8] = [];

        // The type table of the file being exported
        let dmut _currentTypeTableContent : [u8] = [];

        // The symbol table of the file being exported
        let dmut _currentSymbolTableContent : [u8] = [];
    }
        
    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ======================================          CTOR          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */
    
    pub self (packageDir : Path)
        with _packageDir = packageDir
    {}

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          WRITING          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Write the binary yil files
     * */
    pub fn writeFiles (mut self)
        throws ErrorMsg
    {
        if !fs::sys::isDir (state::instance ().getYILOutput ()) {
            fs::sys::createDir (state::instance ().getYILOutput (), recursive-> true);
        } catch {
            _ => {                
                throw copy ErrorMsg::fatal (EOF_WORD, "Failed to create YIL output directory - permission denied");
            }
        }
        
        for p, _ in self._exportFiles {
            self:.writeFile (p);            
        }
    }

    /**
     * Write a binary yil file
     * */
    fn writeFile (mut self, path : Path)
        throws ErrorMsg
    {
        if let Ok (toExport) = self._exportSymbols [path] {
            let file = path.removePrefix (self._packageDir).stripExtension ();
            let outP = state::instance ().getYILOutput ().push (file.toStr (sep-> "_")).addExtension (common::CommonVars::YIL_EXTENSION);
            
            self._currentStringTableHead = copy [];
            self._currentStringTableContent = [];
            
            self._currentTypeTableHead   = copy [];
            self._currentTypeTableContent = [];
            
            self._currentSymbolTableContent = [];

            
            for symName, _ in toExport if let Ok (sym) = self._symbols [symName] {
                self:.exportSymbol (sym._1);
            }
            
            self.writeFileContent (outP,
                                   self._currentSymbolTableContent,
                                   self._currentTypeTableContent,
                                   self._currentStringTableContent);        
        }
    }
    
    /**
     * Write the YIL bytecode content into the file
     * */
    fn writeFileContent (self, path : Path, symbols : [u8], types : [u8], strings : [u8])
        throws ErrorMsg
    {
        
        let dmut file = File::create (path, write-> true);
        file:.write ("YIL");
        file:.writeBytes (self.write!{u64} (types.len) ~ self.write!{u64} (symbols.len) ~ self.write!{u64} (strings.len));
        file:.writeBytes (types);
        file:.writeBytes (symbols);
        file:.writeBytes (strings);
        file:.close ();
        
    } catch {
        _ => {
            throw copy ErrorMsg::fatal (EOF_WORD, format ("Failed to write YIL byte file %(y), permission denied", path.toStr ()));
        }
    }
    
    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          SYMBOLS          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Register the list of symbol into the exporter table
     * */
    pub fn registerSymbols (mut self, syms : [&YILSymbol]) {
        // We start by registering all symbol names
        for sym in syms {
            self._symbols [sym.getName ()] = (sym.isWeak (), sym);
        }

        // And we compose the headers of the files
        for sym in syms {
            let loc = Path (sym.getLoc ().filename);
            
            if self.checkPassFilter (loc) {
                for rf in sym.getReferences () if let Ok (dep) = self._symbols [rf] && dep._0 {
                    self:.addSymbol (loc, rf);
                }

                self:.addSymbol (loc, sym.getName ());                    
                self._exportFiles [loc] = ();
            }
        }
    }

    /**
     * Register the list of types in the exporter table
     * */
    pub fn registerTypes (mut self, types : [&YILType]) {
        for t in types {
            self._types [t.getUniqId ()] = t;
        }
    }
    
    
    /**
     * Add a symbol into the exportation table of a module path
     * */
    prv fn addSymbol (mut self, loc : Path, name : [c8]) {
        // Symbol
        {
            let dmut syms = if let Ok (dmut table) = alias self._exportSymbols [loc] {
                alias table
            } else {
                copy []
            };

            syms [name] = ();
            self._exportSymbols [loc] = alias syms;
        }        
    }


    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ==================================          EXPORTATION          ===================================
     * ====================================================================================================
     * ====================================================================================================
     */
        
    /**
     * Export a node    
     * */
    prv fn exportSymbol (mut self, node : &YILSymbol) {                    
        match node {
            f : &YILFrame => {
                self:.exportFrame (f)
            }
            c : &YILConstant => {
                self:.exportConstant (c)
            }
            g : &YILGlobalVar => {
                self:.exportGlobal (g)
            }
            _ => {
                eprintln (node.__typeinfo__.name);
                eprintln (format ("%", node));
                panic;
            }
        }                
    }    
    
    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =====================================          FRAMES          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Transform a YIL Frame into bytecode
     * */
    fn exportFrame (mut self, node : &YILFrame) {
        let dmut result : [u8] = self.write!{u8} (SymbolID::FRAME);
        result ~= self:.exportLocation (node.getLoc ());
        result ~= self.write!{u8} (if node.isWeak () { 1u8 } else { 0u8 });            
        result ~= self.write!{u64} (self:.exportString (node.getName ()));        

        self._currentSymbolTableContent ~= result;                
    }    

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          CONSTANT          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */
    
    /**
     * Transform a YIL Constant into bytecode
     * */
    fn exportConstant (mut self, node : &YILConstant) {
        let dmut result : [u8] = self.write!{u8} (SymbolID::CONSTANT);
        result ~= self:.exportLocation (node.getLoc ());
        result ~= self.write!{u8} (if node.isWeak () { 1u8 } else { 0u8 });
        result ~= self.write!{u64} (self:.exportString (node.getName ()));

        self._currentSymbolTableContent ~= result;                        
    }    
    
    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          GLOBAL VAR          ===================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Transform a YIL Global Var into bytecode
     * */
    fn exportGlobal (mut self, node : &YILGlobalVar) {
        let dmut result : [u8] = self.write!{u8} (SymbolID::GLOBAL);
        result ~= self:.exportLocation (node.getLoc ());
        result ~= self.write!{u8} (if node.isWeak () { 1u8 } else { 0u8 });
        result ~= self.write!{u64} (self:.exportString (node.getName ()));

        self._currentSymbolTableContent ~= result;                
    }    
    
    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =====================================          TYPES          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */



    /**
     * Transform a type into YIL bytecode
     * */
    prv fn exportType (mut self, type : &YILType)-> usize {
        // already exported
        if type.getUniqId () in self._currentTypeTableHead  { 
            return type.getUniqId () + TypeID::OFFSET; 
        }

        // Add to the type table, and return the offset
        match type {
            a : &YILArray   => { self:.exportArrayType (a); }                                         
            t : &YILTuple   => { self:.exportTupleType (t); }
            p : &YILPointer => { self:.exportPointerType (p); }

            // Scalars
            YILFloat () => { return TypeID::FLOAT; }
            YILInt ()   => { return TypeID::INT; }
            YILVoid ()  => { return TypeID::VOID; }
            _ => {
                eprintln (type.__typeinfo__.name);
                panic;
            }
        }

        return type.getUniqId () + TypeID::OFFSET;
    }   

    /**
     * Export an array type
     * */
    fn exportArrayType (mut self, type : &YILArray) {        
        let dmut result : [u8] = self.write!{u8} (TypeID::ARRAY);
        result ~= self.write!{u64} (type.getUniqId ());
        result ~= self.write!{u64} (type.getLen ());
        
        match type.getInner () {
            YILFloat () => { result ~= self.write!{u8} (TypeID::FLOAT); }
            YILInt () => { result ~= self.write!{u8} (TypeID::INT); }
            YILVoid () => { result ~= self.write!{u8} (TypeID::VOID); }
            i => {
                result ~= self.write!{u64} (i.getUniqId () + TypeID::OFFSET);
            }                           
        }
        
        self._currentTypeTableHead [type.getUniqId ()] = ();        
        self._currentTypeTableContent ~= result;
        
        self:.exportType (type.getInner ());        
    }

    /**
     * Export an pointer type
     * */
    fn exportPointerType (mut self, type : &YILPointer) {        
        let dmut result : [u8] = self.write!{u8} (TypeID::POINTER);
        result ~= self.write!{u64} (type.getUniqId ());
        
        match type.getInner () {
            YILFloat () => { result ~= self.write!{u8} (TypeID::FLOAT); }
            YILInt () => { result ~= self.write!{u8} (TypeID::INT); }
            YILVoid () => { result ~= self.write!{u8} (TypeID::VOID); }
            i => {
                result ~= self.write!{u64} (i.getUniqId () + TypeID::OFFSET);
            }                                                   
        }
        
        self._currentTypeTableHead [type.getUniqId ()] = ();        
        self._currentTypeTableContent ~= result;
                
        self:.exportType (type.getInner ());
    }

    /**
     * Export an pointer type
     * */
    fn exportTupleType (mut self, type : &YILTuple) {        
        let dmut result : [u8] = self.write!{u8} (TypeID::TUPLE);
        result ~= self.write!{u64} (type.getUniqId ()); 
        result ~= self.write!{u64} (type.getInners ().len);

        for i in 0 .. type.getInners ().len {
            if type.getFieldNames ().len > i {
                result ~= self.write!{bool} (true);
                result ~= self.write!{u64} (self:.exportString (type.getFieldNames () [i]));                                
            } else {
                result ~= self.write!{bool} (false);                
            }

            
            match type.getInners ()[i] {
                YILFloat () => { result ~= self.write!{u8} (TypeID::FLOAT); }
                YILInt () => { result ~= self.write!{u8} (TypeID::INT); }
                YILVoid () => { result ~= self.write!{u8} (TypeID::VOID); }
                inner => {
                    result ~= self.write!{u64} (inner.getUniqId () + TypeID::OFFSET);
                }                                                                   
            }                    
        }
        
        self._currentTypeTableHead [type.getUniqId ()] = ();        
        self._currentTypeTableContent ~= result;
        
        for inner in type.getInners () {
            self:.exportType (inner);
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          STRINGS          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Export a location into the current export tables
     * */
    fn exportLocation (mut self, loc : &Word)-> [u8] {
        let off = self:.exportString (loc.filename);

        let dmut result = self.write!{u64} (off);
        result ~= self.write!{u64} (loc.line);
        result ~= self.write!{u32} (loc.col);

        result
    }
    
    /**
     * Export a string into the string table
     * */
    fn exportString (mut self, str : [c8])-> usize {
        if let Ok (u) = self._currentStringTableHead [str] {
            return u;
        }

        let ret = self._currentStringTableContent.len;
        self._currentStringTableHead [str] = ret;
        self._currentStringTableContent ~= self.write!{u64} (str.len);
        self._currentStringTableContent ~= self.write!{[c8]} (str);

        ret
    }    
    
    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =====================================          UTILS          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */
    
    pub fn write {T, J} (self, j : J)-> dmut [u8] {
        unsafe {
            let t : T = cast!T (j);
            let v : *u8 = cast!{*u8} (cast!{*void} (&t));            
            copy [*(v + i) for i in 0us .. cast!usize (T::size)]
        }
    }

    pub fn write {T of [U], U} (self, t : T)-> dmut [u8] {
        unsafe {
            let v : *u8 = cast!{*u8} (cast!{*void} (t.ptr));            
            copy [*(v + i) for i in 0us .. cast!usize (U::size * t.len)]
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          CHECKINC          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Check wether the module path is to be compiled by the filter
     * */
    prv fn checkPassFilter (self, importPath : Path)-> bool {
        let absLoc = importPath.stripExtension ();
        if (absLoc.isEmpty ()) return false; // empty file path
        if !self._packageDir.isPrefix (absLoc) { // External module are always lazy
            return false;
        }

        // No module filters, thus we export everything
        if (!state::instance ().hasModuleFilters ()) {
            return true;
        }

        // A module from the package being compiled, but is is filtered out?
        let relLoc = absLoc.removePrefix (self._packageDir);
        for p in state::instance ().getModuleFilters () {
            if p == relLoc { // one of the selected file to compile
                return true;
            }
        }

        return false;
    }
   
}
