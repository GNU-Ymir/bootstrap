in format;

use ymirc::utils::colors;
use std::{io, stream};


pub lazy mut __WITH_COLOR__ : [bool ; 1] = [true];

pub fn doNotFormatColor (b : bool) {
    __WITH_COLOR__ [0] = !b;
}

pub trait Formattable {
    pub fn format (self, dmut stream : &Formatter);
}

pub trait ErrorFormattable {
    pub fn format (self, dmut stream : &Formatter, root : bool, depth : u32);
}

/**
 * A formatter is used to write content to a string in a more efficient manner than concatenation
 * It is close to a StringStream, but with special format methods
 * @example: 
 * =============
 * class X {
 *  // ...
 *  impl Formattable;
 * }
 *
 * fn foo () -> i32 {
 *    // ... 
 * }
 *
 * fn bar () -> [c8] {
 *   // ...
 * }
 * 
 * let dmut stream = Formatter::new ();
 * stream:.write ("Foo");
 * stream:.write (X::new ();
 * stream:.writef ("Foo %, Bar %", foo (), bar ()); // Formatting
 * =============
 */
@final
pub class Formatter {

    // The content of the formatter
    let dmut _content : &StringStream = copy StringStream ();

    // The color currently used in the formatter
    let mut _currentColor : ([c8])? = none;

    // The list of error ids that were already formatted by the formatter
    let dmut _errorIds : [usize => ()] = [];

    // The list of value ids that were already formatter by the formatter
    let dmut _valueIds : [usize => ()] = [];

    let dmut _yilIds : [usize => usize] = [];

    let mut _lastYilId = 1us;

    // True if the formatted should print variable ids
    let mut _withVarIds = false;

    // True if the formatter write the ids of the errors
    let mut _withErrorIds = true;

    // True if the formatter is used to format call parameters
    let mut _forParameters = false;

    // True if the formatter format verbose error, no matter the global state
    let mut _forceVerbose = false;

    // The list of custom format info (e.g. "withParams" for prototypes)
    let dmut _customFormatInfo : [[c8] => ()] = [];

    pub self from (dmut other : &Formatter)
        with _errorIds      = alias other._errorIds
        , _valueIds         = alias other._valueIds
        , _withVarIds       = other._withVarIds
        , _withErrorIds     = other._withErrorIds
        , _forParameters    = other._forParameters
        , _forceVerbose     = other._forceVerbose
        , _customFormatInfo = alias other._customFormatInfo
    {}

    /**
     * Create an empty stringstream
     */
    pub self (withTags : [[c8]] = []) {
        for i in withTags match i {
            "withVarIds"   => { self._withVarIds = true; }
            "withErrorIds" => { self._withErrorIds = true; }
            "forParams"    => { self._forParameters = true; }
            "verbose"      => { self._forceVerbose = true; }
            fl : _         => {
                self:.insertCustomFormatTag (fl);
            }
        }
    }


    /*!
     * =============================================================================
     * =============================================================================
     * =========================          ENTABING        ==========================
     * =============================================================================
     * =============================================================================
     */

    
    pub fn entabing (mut self, txt : [c8] = "    ") {
        self._content:.entabing (txt-> txt);
    }

    pub fn detabing (mut self) {
        self._content:.detabing ();
    }

    /*!
     * =============================================================================
     * =============================================================================
     * ===========================          CUSTOM        ==========================
     * =============================================================================
     * =============================================================================
     */

    pub fn insertCustomFormatTag (mut self, name : [c8]) {
        self._customFormatInfo [name] = ();
    }

    pub fn hasCustomFormatTag (self, name : [c8])-> bool {
        name in self._customFormatInfo
    }

    pub fn getYilId (mut self, id : usize)-> usize {
        if let Ok (v) = self._yilIds [id]? {
            return v;
        }

        let res = self._lastYilId ;
        self._lastYilId += 1;
        self._yilIds [id] = res;
        res
    }

    /*!
     * =============================================================================
     * =============================================================================
     * ============================          IDS        ============================
     * =============================================================================
     * =============================================================================
     */

    pub fn hasWrittenError (self, id : usize)-> bool {
        id in self._errorIds 
    }

    pub fn hasWrittenValue (self, id : usize)-> bool {
        id in self._valueIds
    }

    pub fn registerError (mut self, id : usize) {
        self._errorIds [id] = ();
    }

    pub fn registerValue (mut self, id : usize) {
        self._valueIds [id] = ();
    }

    pub fn withErrorIds (self)-> bool {
        self._withErrorIds
    }
    
    pub fn withVarIds (self)-> bool {
        self._withVarIds
    }

    pub fn forParams (mut self, b : bool) {
        self._forParameters = b;
    }

    pub fn forParams (self)-> bool {
        self._forParameters
    }

    pub fn withErrorIds (mut self, b : bool) {
        self._withErrorIds = b;
    }   

    pub fn withVarIds (mut self, b : bool) {
        self._withVarIds = b;
    }

    pub fn forceVerbose (mut self, b : bool) {
        self._forceVerbose = b;
    }

    pub fn forceVerbose (self)-> bool {
        self._forceVerbose
    }
    
    /*!
     * =============================================================================
     * =============================================================================
     * =========================          WRITTING        ==========================
     * =============================================================================
     * =============================================================================
     */
    
    /**
     * Write a c8 into the stream
     */
    pub fn write (mut self, c : c8) -> dmut &Formatter {
        self._content:.write (c);
        alias self
    }

    /**
     * Write a string in utf8 into the stream
     */
    pub fn write (mut self, c : [c8]) -> dmut &Formatter {
        self._content:.write (c);
        alias self
    }

    /**
     * Write a element in the stream
     * @info: the element must be convertible to a [c8]
     */
    pub fn if (!is!{T}{class U}) write {T} (mut self, c : T) -> dmut &Formatter {
        self._content:.write (c);
        alias self
    }

    /**
     * Write an array of element into the stream
     */
    pub fn write {T of [U], U} (mut self, c : T) -> dmut &Formatter {
        let mut j = 0u64;
        if let Ok (x) = self._currentColor && __WITH_COLOR__ [0] {
            self:.write (Colors::RESET, '{'c8, x);
        } else {
            self:.write ('{'c8);
        }

        for i in c {
            if (j != 0u64) {
                if let Ok (x) = self._currentColor && __WITH_COLOR__ [0] {
                    self:.write (Colors::RESET, ", ", x);
                } else {
                    self:.write (", ");
                }
            }

            j += 1u64;
            self:.write (i);            
        }

        if let Ok (x) = self._currentColor && __WITH_COLOR__ [0] {
            self:.write (Colors::RESET, '}'c8, x);
        } else {
            self:.write ('}'c8);
        }

        alias self
    }

    /**
     * Write multiple element into the stream
     */
    pub fn write {F, T...} (mut self, f : F, r : T) -> dmut &Formatter {
        self:.write (f);
        cte if (is!T {Z of (U,), U...}) {
            for i in r
                self:.write (i);
        } else {
            self:.write (r);
        }
        alias self
    }

    /**
     * Write a tuple into the stream
     */
    pub fn write {T of (U,), U...} (mut self, a : T) -> dmut &Formatter {
        self:.write ('('c8);
        let mut j = 0;
        for i in a {
            if j != 0 {
                self:.write (','c8);
            }
            self:.write (i);
            j += 1;
        }        
        if (j == 1) self:.write (','c8);
        self:.write (')'c8);
        alias self
    }

    /**
     * Write an option type into the stream
     */
    pub fn write {T} (mut self, a : T?) -> dmut &Formatter {
        match a {
            Ok  (x:_)   => self:.write ("Ok(", x, ')'c8);
            Err (msg:_) => self:.write ("Err(", msg, ')'c8);
            Err ()      => self:.write ("Err()");
        }
        alias self
    }

    /**
     * Write a struct into the stream
     */
    pub fn if (is!{T}{class C} || is!{T}{record C}) write {C} (mut self, a : T) -> dmut &Formatter {
        cte if (is!{T}{U impl Formattable}) {
            c.format (alias self);
        } else cte if (is!{T}{U impl ErrorFormattable}) {
            c.format (alias self, root-> true, depth-> 0u32);
        } else {
            self._content:.write (c);
        }

        alias self
    }

    /*!
     * ===============================================================================
     * ===============================================================================
     * =========================          FORMATTING        ==========================
     * ===============================================================================
     * ===============================================================================
     */

    /**
     * Write a format into the stream
     * @params: 
     *    - format: the format 
     *    - f: an element that will be written at the proper place according to format
     *    - args: a list of element that will be written at the proper place according to format
     * @example: 
     * =================
     * let dmut stream = Formatter::new ();
     * stream:.writef ("Format (f = %, j = %)", 1, 2);
     * assert (stream.str () == "Format (f = 1, j = 2)");
     * =================
     */   
    pub fn writef {F, T...} (mut self, format : [c8], f : F, args : T) -> dmut &Formatter {
        let mut i = 0us;
        while i < format.len {
            if (format [i] == '\\'c8 && i < format.len - 1us) {
                i += 1us;
            } else if (format [i] == '%'c8) {
                i += 1us;
                if (format.len > 2us && i < format.len - 2us && format [i] == '('c8) {
                    let col = match format [i + 1us] {
                        'r'c8 => { Colors::RED }
                        'b'c8 => { Colors::BLUE }
                        'y'c8 => { Colors::YELLOW }
                        'p'c8 => { Colors::PURPLE }
                        'g'c8 => { Colors::GREEN }
                        'B'c8 => { Colors::BOLD }
                        _ => { Colors::RESET }
                    };
                    if (__WITH_COLOR__) {
                        self._currentColor = (col)?;
                        self:.write (col);
                    }
                    self:.write (f);
                    if (__WITH_COLOR__) {
                        self:.write (Colors::RESET);
                        self._currentColor = ([c8]?)::__err__;
                    }
                    self:.writef (format [i + 3us .. $], expand args);
                } else {
                    self:.write (f);
                    self:.writef (format [i .. $], expand args);
                }
                
                break{}
            } else if (format [i] == '@'c8) {
                i += 1us;
                let col = match format [i + 1us] {
                    'r'c8 => { Colors::RED }
                    'b'c8 => { Colors::BLUE }
                    'y'c8 => { Colors::YELLOW }
                    'p'c8 => { Colors::PURPLE }
                    'g'c8 => { Colors::GREEN }
                    'B'c8 => { Colors::BOLD }
                    _ => { Colors::RESET }
                };

                i += 3us;
                if (__WITH_COLOR__) {
                    self._currentColor = (col)?;
                    self:.write (col);
                }
                while format [i] != ')'c8 {
                    self:.write (format [i]);
                    i += 1us;
                }

                i += 1us;
                if (__WITH_COLOR__) {
                    self:.write (Colors::RESET);
                    self._currentColor = ([c8]?)::__err__;
                }
            } else {
                self:.write (format [i]);
                i += 1us;
            }
        }
        alias self
    } 

    /**
     * Write a format into the stream
     * @params: 
     *    - format: the format 
     *    - f: an element that will be written at the proper place according to format
     * @example: 
     * =================
     * let dmut stream = Formatter::new ();
     * stream:.writef ("Format (f = %)", 1);
     * assert (stream.str () == "Format (f = 1)");
     * =================
     */   
    pub fn writef {F} (mut self, format : [c8], f : F) -> dmut &Formatter {
        let mut i = 0us;
        while i < format.len {
            if (format [i] == '\\'c8 && i < format.len - 1u64) {
                i += 1us;
            } else if (format [i] == '%'c8) {
                i += 1us;
                if (format.len > 2us && i < format.len - 2us && format [i] == '('c8) {
                    let col = match format [i + 1us] {
                        'r'c8 => { Colors::RED }
                        'b'c8 => { Colors::BLUE }
                        'y'c8 => { Colors::YELLOW }
                        'p'c8 => { Colors::PURPLE }
                        'g'c8 => { Colors::GREEN }
                        'B'c8 => { Colors::BOLD }
                        _ => { Colors::RESET }
                    };
                    if (__WITH_COLOR__) {
                        self._currentColor = (col)?;
                        self:.write (col);
                    }
                    self:.write (f);
                    if (__WITH_COLOR__) {
                        self:.write (Colors::RESET);                        
                        self._currentColor = ([c8]?)::__err__;
                    }
                    i += 3us;
                } else {
                    self:.write (f);
                }                
            } else if (format [i] == '@'c8) {
                i += 1us; // skip (
                let col = match format [i + 1us] {
                    'r'c8 => { Colors::RED }
                    'b'c8 => { Colors::BLUE }
                    'y'c8 => { Colors::YELLOW }
                    'p'c8 => { Colors::PURPLE }
                    'g'c8 => { Colors::GREEN }
                    'B'c8 => { Colors::BOLD }
                    _ => { Colors::RESET }
                };

                i += 3us; // skip y=
                if (__WITH_COLOR__) {
                    self._currentColor = (col)?;
                    self:.write (col);
                }
                while format [i] != ')'c8 {
                    self:.write (format [i]);
                    i += 1us;
                }

                i += 1us; // skip )
                if (__WITH_COLOR__) {
                    self:.write (Colors::RESET);
                    self._currentColor = ([c8]?)::__err__;
                }
            } else {
                self:.write (format [i]);
                i += 1us;
            }
        }
        alias self
    }

    /*!
     * ===============================================================================
     * ===============================================================================
     * =========================          GETTERS        =============================
     * ===============================================================================
     * ===============================================================================
     */
    
    /**
     * The content of the stream, in a [c8]
     */
    pub fn opIndex (self) -> [c8] {
        self._content []
    }

    /**
     * @returns: the current writting color 
     */
    pub fn getCurrentColor (self)-> ([c8])? {
        self._currentColor
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================           SETTERS            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Change the current writting color 
     */
    pub fn setCurrentColor (mut self, color : ([c8])?) {
        self._currentColor = color;
    }

    impl Streamable {
        
        /**
         * Print the content of the stream to stdout
         */
        pub over toStream (self, dmut stream : &StringStream) {
            stream:.write (self._content[]);
        }
    }
    
}

/**
 * Simple string formatting
 * @example: 
 * ================
 * assert (format ("Foo %", 12) == "Foo 12");
 * ================
 */
pub fn format {T...} (txt : [c8], withTags : [[c8]] = [], args : T) -> [c8] {
    let dmut buf = copy Formatter ();
    for i in withTags match i {
        "withVarIds"   => { buf:.withVarIds (true); }
        "withErrorIds" => { buf:.withErrorIds (true); }
        "forParams"    => { buf:.forParams (true); }
        "verbose"      => { buf:.forceVerbose (true); }
        fl : _         => {
            buf:.insertCustomFormatTag (fl);
        }
    }

    buf:.writef (txt, expand args);
    buf[]
}


/**
 * Simple string formatting
 * @example:
 * ================
 * format ("Foo @(y=true)");
 * ================
 */
pub fn format (txt : [c8], withTags : [[c8]] = []) -> [c8] {
    let dmut buf = copy Formatter ();
    for i in withTags match i {
        "withVarIds" => { buf:.withVarIds (true); }
        "withErrorIds" => { buf:.withErrorIds (true); }
        "forParams" => { buf:.forParams (true); }
        "verbose" => { buf:.forceVerbose (true); }
        fl : _ => {
            buf:.insertCustomFormatTag (fl);
        }
    }

    buf:.writef (txt, "");
    buf[]
}
