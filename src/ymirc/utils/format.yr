in format;

use ymirc::utils::colors;
use std::{io, stream};


pub lazy dmut __WITH_COLOR__ : [bool] = copy [true];

pub fn doNotFormatColor (b : bool) {
    __WITH_COLOR__ [0] = !b;
}

pub trait Formattable {
    pub fn format (self, dmut stream : &Formatter);
}

pub trait ErrorFormattable {
    pub fn format (self, dmut stream : &Formatter, root : bool);
}

pub record FormatTags {
    pub let withParams : bool;
    pub let withErrorIds : bool;
    pub let withVarIds : bool;
    pub let forParams : bool;
    pub let forDebug : bool;
    pub let verbose : bool;
    pub let short : bool;
    pub let withVars : bool;

    pub self (withParams : bool = false,
              withErrorIds : bool = false,
              withVarIds : bool = false,
              forParams : bool = false,
              forDebug : bool = false,
              verbose : bool = false,
              short : bool = false,
              withVars : bool = false)
        with withParams = withParams
        , withErrorIds = withErrorIds
        , withVarIds = withVarIds
        , forParams = forParams
        , forDebug = forDebug
        , verbose = verbose
        , short = short
        , withVars = withVars
    {}
}

/**
 * A formatter is used to write content to a string in a more efficient manner than concatenation
 * It is close to a StringStream, but with special format methods
 * @example: 
 * =============
 * class X {
 *  // ...
 *  impl Formattable;
 * }
 *
 * fn foo () -> i32 {
 *    // ... 
 * }
 *
 * fn bar () -> [c8] {
 *   // ...
 * }
 * 
 * let dmut stream = copy Formatter ();
 * stream:.write ("Foo");
 * stream:.write (copy X ());
 * stream:.writef ("Foo %, Bar %", foo (), bar ()); // Formatting
 * =============
 */
@final
pub class Formatter {

    // The content of the formatter
    let dmut _content : &StringStream = copy StringStream ();

    // The color currently used in the formatter
    let mut _currentColor : ([c8])? = none;

    // The list of error ids that were already formatted by the formatter
    let dmut _errorIds : [usize => ()] = copy [];

    let mut _wroteErrors : bool = false;

    // The list of value ids that were already formatter by the formatter
    let dmut _valueIds : [usize => ()] = copy [];

    let dmut _yilIds : [usize => usize] = copy [];

    let mut _lastYilId : usize = 1us;

    let _tags : FormatTags;

    pub self from (dmut other : &Formatter)
        with _errorIds      = alias other._errorIds
        , _valueIds         = alias other._valueIds
        , _tags             = other._tags
    {}

    /**
     * Create an empty stringstream
     */
    pub self (tags : FormatTags = FormatTags ())
        with _tags = tags
    {}

    /*!
     * =============================================================================
     * =============================================================================
     * =========================          ENTABING        ==========================
     * =============================================================================
     * =============================================================================
     */

    
    pub fn entabing (mut self, txt : [c8] = "    ") {
        self._content:.entabing (txt-> txt);
    }

    pub fn detabing (mut self) {
        self._content:.detabing ();
    }

    /*!
     * =============================================================================
     * =============================================================================
     * ===========================          CUSTOM        ==========================
     * =============================================================================
     * =============================================================================
     */

    pub fn getYilId (mut self, id : usize)-> usize {
        if let Ok (v) = self._yilIds [id] {
            return v;
        }

        let res = self._lastYilId ;
        self._lastYilId += 1;
        self._yilIds [id] = res;
        return res;
    }

    /*!
     * =============================================================================
     * =============================================================================
     * ============================          IDS        ============================
     * =============================================================================
     * =============================================================================
     */

    pub fn hasWrittenError (self, id : usize)-> bool {
        id in self._errorIds
    }

    pub fn hasWrittenValue (self, id : usize)-> bool {
        id in self._valueIds
    }

    /**
     * @returns: true if wrote a complete error, and not just 'previous error...'
     * */
    pub fn hasWrittenSomeErrors (self)-> bool {
        self._wroteErrors
    }

    pub fn wroteErrors (mut self, set : bool) {
        self._wroteErrors = set;
    }

    pub fn registerError (mut self, id : usize) {
        self._errorIds [id] = ();
    }

    pub fn registerValue (mut self, id : usize) {
        self._valueIds [id] = ();
    }

    @field
    pub fn tags (self)-> FormatTags {
        self._tags
    }

    /*!
     * =============================================================================
     * =============================================================================
     * =========================          WRITTING        ==========================
     * =============================================================================
     * =============================================================================
     */
    
    /**
     * Write a c8 into the stream
     */
    pub fn write (mut self, c : c8) -> dmut &Formatter {
        self._content:.write (c);
        alias self
    }

    /**
     * Write a string in utf8 into the stream
     */
    pub fn write (mut self, c : [c8]) -> dmut &Formatter {
        self._content:.write (c);
        alias self
    }

    /**
     * Write a element in the stream
     * @info: the element must be convertible to a [c8]
     */
    pub fn if (!is!{T}{class U} && !is!{T}{record U}) write {T} (mut self, c : T) -> dmut &Formatter {
        self._content:.write (c);
        alias self
    }

    /**
     * Write an array of element into the stream
     */
    pub fn write {T of [U], U} (mut self, c : T) -> dmut &Formatter {
        let mut j = 0u64;
        if let Ok (x) = self._currentColor && __WITH_COLOR__ [0] {
            self:.write (Colors::RESET, '{'c8, x);
        } else {
            self:.write ('{'c8);
        }

        for i in c {
            if (j != 0u64) {
                if let Ok (x) = self._currentColor && __WITH_COLOR__ [0] {
                    self:.write (Colors::RESET, ", ", x);
                } else {
                    self:.write (", ");
                }
            }

            j += 1u64;
            self:.write (i);            
        }

        if let Ok (x) = self._currentColor && __WITH_COLOR__ [0] {
            self:.write (Colors::RESET, '}'c8, x);
        } else {
            self:.write ('}'c8);
        }

        alias self
    }

    /**
     * Write multiple element into the stream
     */
    pub fn write {F, T...} (mut self, f : F, r : T) -> dmut &Formatter {
        self:.write (f);
        cte if (is!T {Z of (U,), U...}) {
            for i in r
                self:.write (i);
        } else {
            self:.write (r);
        }
        alias self
    }

    /**
     * Write a tuple into the stream
     */
    pub fn write {T of (U,), U...} (mut self, a : T) -> dmut &Formatter {
        self:.write ('('c8);
        let mut j = 0;
        for i in a {
            if j != 0 {
                self:.write (','c8);
            }
            self:.write (i);
            j += 1;
        }        
        if (j == 1) self:.write (','c8);
        self:.write (')'c8);
        alias self
    }

    /**
     * Write an option type into the stream
     */
    pub fn write {T} (mut self, a : T?) -> dmut &Formatter {
        match a {
            Ok  (x:_)   => self:.write ("Ok(", x, ')'c8);
            Err (msg:_) => self:.write ("Err(", msg, ')'c8);
            Err ()      => self:.write ("Err()");
        }
        alias self
    }

    /**
     * Write a struct into the stream
     */
    pub fn if (is!{T}{class C} || is!{T}{record C}) write {T} (mut self, a : T) -> dmut &Formatter {
        cte if (is!{T}{U impl Formattable}) {
            a.format (alias self);
        } else cte if (is!{T}{U impl ErrorFormattable}) {
            a.format (alias self, root-> true);
        } else {
            self._content:.write (a);
        }

        alias self
    }

    /*!
     * ===============================================================================
     * ===============================================================================
     * =========================          FORMATTING        ==========================
     * ===============================================================================
     * ===============================================================================
     */

    /**
     * Write a format into the stream
     * @params: 
     *    - format: the format 
     *    - f: an element that will be written at the proper place according to format
     *    - args: a list of element that will be written at the proper place according to format
     * @example: 
     * =================
     * let dmut stream = copy Formatter ();
     * stream:.writef ("Format (f = %, j = %)", 1, 2);
     * assert (stream[]== "Format (f = 1, j = 2)");
     * =================
     */   
    pub fn writef {F, T...} (mut self, format : [c8], f : F, args : T) -> dmut &Formatter {
        let mut i = 0us;
        while i < format.len {
            if (format [i] == '\\'c8 && i < format.len - 1us) {
                i += 1us;
            } else if (format [i] == '%'c8) {
                i += 1us;
                if (format.len > 2us && i < format.len - 2us && format [i] == '('c8) {
                    let col = match format [i + 1us] {
                        'r'c8 => { Colors::RED }
                        'b'c8 => { Colors::BLUE }
                        'y'c8 => { Colors::YELLOW }
                        'p'c8 => { Colors::PURPLE }
                        'g'c8 => { Colors::GREEN }
                        'B'c8 => { Colors::BOLD }
                        _ => { Colors::RESET }
                    };
                    if (__WITH_COLOR__ [0]) {
                        self._currentColor = (col)?;
                        self:.write (col);
                    }
                    self:.write (f);
                    if (__WITH_COLOR__ [0]) {
                        self:.write (Colors::RESET);
                        self._currentColor = none;
                    }

                    cte if (T,)::arity > 1 {
                        self:.writef (format [i + 3us .. $], expand args);
                    } else {
                        self:.writef (format [i + 3us .. $], args);
                    }
                } else {
                    self:.write (f);
                    cte if (T,)::arity > 1 {
                        self:.writef (format [i .. $], expand args);
                    } else {
                        self:.writef (format [i .. $], args);
                    }
                }
                
                break{}
            } else if (format [i] == '@'c8) {
                i += 1us;
                let col = match format [i + 1us] {
                    'r'c8 => { Colors::RED }
                    'b'c8 => { Colors::BLUE }
                    'y'c8 => { Colors::YELLOW }
                    'p'c8 => { Colors::PURPLE }
                    'g'c8 => { Colors::GREEN }
                    'B'c8 => { Colors::BOLD }
                    _ => { Colors::RESET }
                };

                i += 3us;
                if (__WITH_COLOR__ [0]) {
                    self._currentColor = (col)?;
                    self:.write (col);
                }
                while format [i] != ')'c8 {
                    self:.write (format [i]);
                    i += 1us;
                }

                i += 1us;
                if (__WITH_COLOR__ [0]) {
                    self:.write (Colors::RESET);
                    self._currentColor = none;
                }
            } else {
                self:.write (format [i]);
                i += 1us;
            }
        }
        alias self
    } 

    /**
     * Write a format into the stream
     * @params: 
     *    - format: the format 
     *    - f: an element that will be written at the proper place according to format
     * @example: 
     * =================
     * let dmut stream = copy Formatter ();
     * stream:.writef ("Format (f = %)", 1);
     * assert (stream [] == "Format (f = 1)");
     * =================
     */   
    pub fn writef {F} (mut self, format : [c8], f : F) -> dmut &Formatter {
        let mut i = 0us;
        while i < format.len {
            if (format [i] == '\\'c8 && i < format.len - 1u64) {
                i += 1us;
            } else if (format [i] == '%'c8) {
                i += 1us;
                if (format.len > 2us && i < format.len - 2us && format [i] == '('c8) {
                    let col = match format [i + 1us] {
                        'r'c8 => { Colors::RED }
                        'b'c8 => { Colors::BLUE }
                        'y'c8 => { Colors::YELLOW }
                        'p'c8 => { Colors::PURPLE }
                        'g'c8 => { Colors::GREEN }
                        'B'c8 => { Colors::BOLD }
                        _ => { Colors::RESET }
                    };
                    if (__WITH_COLOR__ [0]) {
                        self._currentColor = (col)?;
                        self:.write (col);
                    }
                    self:.write (f);
                    if (__WITH_COLOR__ [0]) {
                        self:.write (Colors::RESET);                        
                        self._currentColor = none;
                    }
                    i += 3us;
                } else {
                    self:.write (f);
                }                
            } else if (format [i] == '@'c8) {
                i += 1us; // skip (
                let col = match format [i + 1us] {
                    'r'c8 => { Colors::RED }
                    'b'c8 => { Colors::BLUE }
                    'y'c8 => { Colors::YELLOW }
                    'p'c8 => { Colors::PURPLE }
                    'g'c8 => { Colors::GREEN }
                    'B'c8 => { Colors::BOLD }
                    _ => { Colors::RESET }
                };

                i += 3us; // skip y=
                if (__WITH_COLOR__ [0]) {
                    self._currentColor = (col)?;
                    self:.write (col);
                }
                while format [i] != ')'c8 {
                    self:.write (format [i]);
                    i += 1us;
                }

                i += 1us; // skip )
                if (__WITH_COLOR__ [0]) {
                    self:.write (Colors::RESET);
                    self._currentColor = none;
                }
            } else {
                self:.write (format [i]);
                i += 1us;
            }
        }
        alias self
    }

    pub fn writef (mut self, format : [c8])-> dmut &Formatter {
        self:.write (format);
        alias self
    }

    /*!
     * ===============================================================================
     * ===============================================================================
     * =========================          GETTERS        =============================
     * ===============================================================================
     * ===============================================================================
     */
    
    /**
     * The content of the stream, in a [c8]
     */
    pub fn opIndex (self) -> [c8] {
        self._content []
    }

    /**
     * @returns: the current writting color 
     */
    pub fn getCurrentColor (self)-> ([c8])? {
        self._currentColor
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================           SETTERS            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Change the current writting color 
     */
    pub fn setCurrentColor (mut self, color : ([c8])?) {
        self._currentColor = color;
    }

    impl Streamable {
        
        /**
         * Print the content of the stream to stdout
         */
        pub over toStream (self, dmut stream : &StringStream) {
            stream:.write (self._content[]);
        }
    }
    
}

/**
 * Simple string formatting
 * @example:
 * ================
 * assert (format ("Foo %", 12) == "Foo 12");
 * ================
 */
pub fn format {T...} (txt : [c8], tags : FormatTags, args : T) -> [c8] {
    let dmut buf = copy Formatter (tags-> tags);
    cte if (T,)::arity > 1 {
        buf:.writef (txt, expand args);
    } else {
        buf:.writef (txt, args);
    }

    buf[]
}

/**
 * Simple string formatting
 * @example:
 * ================
 * assert (format ("Foo %", 12) == "Foo 12");
 * ================
 */
pub fn format {T...} (txt : [c8], args : T) -> [c8] {
    let dmut buf = copy Formatter (tags-> FormatTags ());
    cte if (T,)::arity > 1 {
        buf:.writef (txt, expand args);
    } else {
        buf:.writef (txt, args);
    }

    buf[]
}

/**
 * Simple string formatting
 * @example:
 * ================
 * format ("Foo @(y=true)");
 * ================
 */
pub fn format (txt : [c8], tags : FormatTags) -> [c8] {
    let dmut buf = copy Formatter (tags-> tags);
    buf:.writef (txt, "");
    buf[]
}

/**
 * Simple string formatting
 * @example:
 * ================
 * format ("Foo @(y=true)");
 * ================
 */
pub fn format (txt : [c8]) -> [c8] {
    let dmut buf = copy Formatter (tags-> FormatTags ());
    buf:.writef (txt, "");
    buf[]
}
