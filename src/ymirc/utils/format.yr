mod ymirc::utils::format;

import std::collection::vec;
import std::collection::set;
import ymirc::utils::colors;
import std::io;


pub trait Formattable {
    pub def format (self, dmut stream : &Formatter);    
}

pub trait ErrorFormattable {
    pub def format (self, dmut stream : &Formatter, root : bool);
}


/**
 * A formatter is used to write content to a string in a more efficient manner than concatenation
 * It is close to a StringStream, but with special format methods
 * @example: 
 * =============
 * class X {
 *  // ...
 *  impl Formattable;
 * }
 *
 * def foo () -> i32 {
 *    // ... 
 * }
 *
 * def bar () -> [c8] {
 *   // ...
 * }
 * 
 * let dmut stream = Formatter::new ();
 * stream:.write ("Foo");
 * stream:.write (X::new ();
 * stream:.writef ("Foo %, Bar %", foo (), bar ()); // Formatting
 * =============
 */
pub class @final Formatter {

    /// The content of the formatter
    let dmut _content = Vec!(c8)::new ();

    /// The color currently used in the formatter
    let mut _currentColor = ([c8]?)::__err__;

    /// The level of entabing
    let dmut _entabing = Vec!([c8])::new ();

    /// If _willEntab, apply entabing
    let mut _willEntab = false;

    // The list of error ids that were already formatted by the formatter
    let dmut _errorIds = HashSet!{usize}::new ();

    // The list of value ids that were already formatter by the formatter
    let dmut _valueIds = HashSet!{usize}::new ();

    // True if the formatted should print variable ids
    let mut _withVarIds = true;
    
    /**
     * Create an empty stringstream
     */
    pub self () {}


    /***
     * =============================================================================
     * =============================================================================
     * =========================          ENTABING        ==========================
     * =============================================================================
     * =============================================================================
     */

    
    pub def entabing (mut self, txt : [c8] = "    "s8) {
        self._entabing:.push (txt);
    }

    pub def detabing (mut self) {
        self._entabing:.pop ()?;
    }
    
    pub def getEntabing (self)-> [[c8]] {
        self._entabing[]
    }

    /***
     * =============================================================================
     * =============================================================================
     * ============================          IDS        ============================
     * =============================================================================
     * =============================================================================
     */

    pub def hasWrittenError (self, id : usize)-> bool {
        id in self._errorIds 
    }

    pub def hasWrittenValue (self, id : usize)-> bool {
        id in self._valueIds
    }

    pub def registerError (mut self, id : usize) {
        self._errorIds:.insert (id);
    }

    pub def registerValue (mut self, id : usize) {
        self._valueIds:.insert (id);
    }

    pub def withVarIds (self)-> bool {
        self._withVarIds
    }

    pub def withVarIds (mut self, b : bool) {
        self._withVarIds = b;
    }
    
    /***
     * =============================================================================
     * =============================================================================
     * =========================          WRITTING        ==========================
     * =============================================================================
     * =============================================================================
     */
    
    /**
     * Write a c8 into the stream
     */
    pub def write (mut self, c : c8) -> dmut &Formatter {                
        if self._willEntab {
            for j in self._entabing {
                for z in j {
                    self._content:.push (z);
                }
            }
            self._willEntab = false;
        }
        
        self._content:.push (c);
        if (c == '\n'c8) {
            self._willEntab = true;
        }
        alias self
    }

    /**
     * Write a string in utf8 into the stream
     */
    pub def write (mut self, c : [c8]) -> dmut &Formatter {
        for i in c {
            if self._willEntab {
                for j in self._entabing {
                    for z in j {
                        self._content:.push (z);
                    }
                }
                self._willEntab = false;
            }
            
            self._content:.push (i);
            if (i == '\n'c8) {
                self._willEntab = true;
            }
        };
        alias self
    }

    /**
     * Write a element in the stream
     * @info: the element must be convertible to a [c8]
     */
    pub def if (!is!{T}{class U}) write {T} (mut self, c : T) -> dmut &Formatter {
        import std::conv;
        self:.write (c.to![c8] ());
        alias self
    }

    /**
     * Write a string into the stream
     */
    pub def write (mut self, c : [c32]) -> dmut &Formatter {
        import std::conv;
        self:.write (c.to![c8] ());
        alias self
    }
    
    /**
     * Write an array of element into the stream
     */
    pub def write {T of [U], U} (mut self, c : T) -> dmut &Formatter {
        let mut j = 0u64;
        match (self._currentColor) {
            Ok (x : _) => {
                self:.write (Colors::RESET, '{'c8, x);
            }
            _ => {
                self:.write ('{'c8);
            }
        }
        for i in c {
            if (j != 0u64) {
                match (self._currentColor) {
                    Ok (x : _) => {
                        self:.write (Colors::RESET, ", "s8, x);
                    }
                    _ => { self:.write (", "s8); }
                }
            }
            j += 1u64;
            self:.write (i);            
        }
        match (self._currentColor) {
            Ok (x : _) => {
                self:.write (Colors::RESET, '}'c8, x);
            }
            _ => {
                self:.write ('}'c8);
            }
        }
        alias self
    }

    /**
     * Write multiple element into the stream
     */
    pub def write {F, T...} (mut self, f : F, r : T) -> dmut &Formatter {
        self:.write (f);
        cte if (is!T {Z of (U,), U...}) {
            for i in r
                self:.write (i);
        } else {
            self:.write (r);
        }
        alias self
    }

    /**
     * Write a tuple into the stream
     */
    pub def write {T of (U,), U...} (mut self, a : T) -> dmut &Formatter {
        self:.write ('('c8);
        let mut j = 0;
        for i in a {
            if j != 0 {
                self:.write (','c8);
            }
            self:.write (i);
            j += 1;
        }        
        if (j == 1) self:.write (','c8);
        self:.write (')'c8);
        alias self
    }

    /**
     * Write an option type into the stream
     */
    pub def write {T} (mut self, a : T?) -> dmut &Formatter {
        match a {
            Ok  (x:_)   => self:.write ("Ok("s8, x, ')'c8);
            Err (msg:_) => self:.write ("Err("s8, msg, ')'c8);
            Err ()      => self:.write ("Err()"s8);
        }
        alias self
    }

    /**
     * Write a struct into the stream
     */
    pub def write {struct T} (mut self, a : T) -> dmut &Formatter {
        self:.write (T::typeid, '('c8);
        cte if (typeof (__pragma!tupleof (a))::arity > 0us) {
            let mut j = 0;
            for i in __pragma!tupleof (a) {
                if (j != 0) self:.write (", "s8);
                self:.write (i);
                j += 1;
            }
        }
        self:.write (')'c8);
        alias self
    }
    
    /**
     * Write an object that implement the trait formattable in the stream
     */
    pub def write {class T} (mut self, c : T) -> dmut &Formatter {
        cte if (is!{T}{U impl Formattable}) {
            c.format (alias self);
        } else cte if (is!{T}{U impl ErrorFormattable}) {
            c.format (alias self, root-> true);
        } else cte if (is!{T}{U impl Streamable}) {
            let dmut stream = StringStream::new ();
            c.toStream (alias stream);
            self:.write (stream[]);
        } else {
            self:.write (T::typeid);
        }
        alias self
    }
    
    /***
     * ===============================================================================
     * ===============================================================================
     * =========================          FORMATTING        ==========================
     * ===============================================================================
     * ===============================================================================
     */

    /**
     * Write a format into the stream
     * @params: 
     *    - format: the format 
     *    - t: a list of elements that will be written at the proper place according to format
     * @example: 
     * =================
     * let dmut stream = Formatter::new ();
     * stream:.writef ("Format (f = %, j = %)", 1, 2);
     * assert (stream.str () == "Format (f = 1, j = 2)"s8);
     * =================
     */   
    pub def writef {T...} (mut self, format : [c32], t : T) -> dmut &Formatter {
        import std::conv;
        self:.writef (format.to![c8](), expand t);
        alias self
    }
    
    /**
     * Write a format into the stream
     * @params: 
     *    - format: the format 
     *    - f: an element that will be written at the proper place according to format
     *    - args: a list of element that will be written at the proper place according to format
     * @example: 
     * =================
     * let dmut stream = Formatter::new ();
     * stream:.writef ("Format (f = %, j = %)"s8, 1, 2);
     * assert (stream.str () == "Format (f = 1, j = 2)"s8);
     * =================
     */   
    pub def writef {F, T...} (mut self, format : [c8], f : F, args : T) -> dmut &Formatter {
        let mut i = 0us;
        while i < format.len {
            if (format [i] == '\\'c8 && i < format.len - 1us) {
                i += 1us;
            } else if (format [i] == '%'c8) {
                i += 1us;
                if (format.len > 2us && i < format.len - 2us && format [i] == '('c8) {
                    let col = match format [i + 1us] {
                        'r'c8 => { Colors::RED }
                        'b'c8 => { Colors::BLUE }
                        'y'c8 => { Colors::YELLOW }
                        'g'c8 => { Colors::GREEN }
                        'B'c8 => { Colors::BOLD }
                        _ => { Colors::RESET }
                    };
                    self._currentColor = (col)?;
                    self:.write (col);
                    self:.write (f);
                    self:.write (Colors::RESET);
                    self._currentColor = ([c8]?)::__err__;
                    self:.writef (format [i + 3us .. $], expand args);
                } else {
                    self:.write (f);
                    self:.writef (format [i .. $], expand args);
                }
                
                break{}
            }

            self:.write (format [i]);
            i += 1us;
        }
        alias self
    } 

    /**
     * Write a format into the stream
     * @params: 
     *    - format: the format 
     *    - f: an element that will be written at the proper place according to format
     * @example: 
     * =================
     * let dmut stream = Formatter::new ();
     * stream:.writef ("Format (f = %)"s8, 1);
     * assert (stream.str () == "Format (f = 1)"s8);
     * =================
     */   
    pub def writef {F} (mut self, format : [c8], f : F) -> dmut &Formatter {
        let mut i = 0us;
        while i < format.len {
            if (format [i] == '\\'c8 && i < format.len - 1u64) {
                i += 1us;
            } else if (format [i] == '%'c8) {
                i += 1us;
                if (format.len > 2us && i < format.len - 2us && format [i] == '('c8) {
                    let col = match format [i + 1us] {
                        'r'c8 => { Colors::RED }
                        'b'c8 => { Colors::BLUE }
                        'y'c8 => { Colors::YELLOW }
                        'g'c8 => { Colors::GREEN }
                        'B'c8 => { Colors::BOLD }
                        _ => { Colors::RESET }
                    };
                    self._currentColor = (col)?;
                    self:.write (col);
                    self:.write (f);
                    self:.write (Colors::RESET);
                    self._currentColor = ([c8]?)::__err__;
                    i += 3us;
                } else {
                    self:.write (f);
                }                
            } else {
                self:.write (format [i]);
                i += 1us;
            }
        }
        alias self
    }

    /***
     * ===============================================================================
     * ===============================================================================
     * =========================          GETTERS        =============================
     * ===============================================================================
     * ===============================================================================
     */
    
    /**
     * The content of the stream, in a [c8]
     */
    pub def opIndex (self) -> [c8] {
        self._content []
    }

    /**
     * @returns: the writting buffer
     */
    pub def getContent (mut self)-> dmut &Vec!{c8} {
        alias self._content
    }

    /**
     * @returns: the current writting color 
     */
    pub def getCurrentColor (self)-> ([c8])? {
        self._currentColor
    }

    /**
     * @returns: the entabing buffer
     */
    pub def getEntabing (mut self)-> dmut &Vec!{[c8]} {
        alias self._entabing
    }

    /**
     * @returns: true if the next write call will be entabed     
     */
    pub def getWillEntab (self)-> bool {
        self._willEntab
    }

     /**
     * ================================================================================
     * ================================================================================
     * =========================           SETTERS            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Change the writting buffer
     */
    pub def setContent (mut self, dmut content : &Vec!{c8}) {
        self._content = alias content;
    }

    /**
     * Change the current writting color 
     */
    pub def setCurrentColor (mut self, color : ([c8])?) {
        self._currentColor = color;
    }

    /**
     * Change the entabing buffer
     */
    pub def setEntabing (mut self, dmut entabing : &Vec!{[c8]}) {
        self._entabing = alias entabing;
    }

    /**
     * @returns: true if the next write call will be entabed     
     */
    pub def setWillEntab (mut self, will : bool) {
        self._willEntab = will;
    }
    
    
    impl Streamable {
        
        /**
         * Print the content of the stream to stdout
         */
        pub over toStream (self, dmut stream : &StringStream) {
            stream:.write (self._content []);
        }
    }
    
}

/**
 * Simple string formatting
 * @example: 
 * ================
 * assert (format ("Foo %"s8, 12) == "Foo 12"s8);
 * ================
 */
pub def format {T...} (txt : [c8], args : T) -> [c8] {
    let dmut buf = Formatter::new ();
    buf:.writef (txt, expand args);
    buf[]
}

/**
 * Simple string formatting
 * @info: converted into a utf8 string
 * @example: 
 * ================
 * assert (format ("Foo %", 12) == "Foo 12"s8);
 * ================
 */
pub def format {T...} (txt : [c32], args : T) -> [c8] {
    let dmut buf = Formatter::new ();
    buf:.writef (txt, expand args);
    buf []
}
