mod ymirc::utils::bigfloat;

import std::io, std::conv;
import std::traits;
import ymirc::utils::gmp;
import ymirc::utils::bigint;


pub class BigFloatError over Exception {

    pub let msg : [c32];

    pub self (msg : [c32]) with msg = msg {}

    impl stream::Streamable {
        pub over toStream (self, dmut stream : &StringStream) {
            self::super.toStream (alias stream);
        }
    }

}

pub class @final BigFloat {

    /// lib gmp content
    let dmut _content = mpf_t ();

    let mut _isNan : bool = false;

    let mut _isInf : bool = false;

    let mut _isPositive : bool = true; // only for inf

    /**
     * Private ctor to construct a big gloat from an already init content
     * */
    prv self (content : mpf_t)
        with _content = content
    {}

    /**
     * Construct a bigfloat from a bigint
     * */
    pub self (b : &BigInt) {
        __gmpf_init2 (alias &self._content, 1024us);

        let z = b.getZ ();
        __gmpf_set_z (alias &self._content, &z);
    }

    /**
     * Create a bigfloat containing the value 0
     * */
    pub self ()
        with self (0.0)
    {}

    /**
     * Create a big float from a float value
     * */
    pub self (x : f32)
        with self (cast!f64 (x))
    {}

    /**
     * Create a big float from a float value
     * */
    pub self (x : f64) {
        if (x != x) {
            self._isNan = true;
        } else if (x == f64::inf) {
            self._isInf = true;
        } else if (x == -f64::inf) {
            self._isInf = true;
            self._isPositive = false;
        } else {
            __gmpf_init2 (alias &self._content, 1024us);
            __gmpf_set_d (alias &self._content, x);
        }
    }

    /**
     * Create a big float from a string
     * */
    pub self (x : [c8], base : u32 = 10u32) {
        __gmpf_init2 (alias &self._content, 1024us);

        __gmpf_set_str (alias &self._content, x.toStringZ (), base);
    }

    /**
     * ================================================================================
     * ================================================================================
     * ========================             GETTERS              ======================
     * ================================================================================
     * ================================================================================
     */

    /**
     * @returns: true iif the value is nan
     * */
    pub def isNan (self)-> bool {
        self._isNan
    }

    /**
     * @returns: true iif the value is +inf
     * */
    pub def isPositiveInf (self)-> bool {
        self._isInf && self._isPositive
    }

    /**
     * @returns: true iif the value is -inf
     * */
    pub def isNegativeInf (self)-> bool {
        self._isInf && !self._isPositive
    }




    /**
     * ================================================================================
     * ================================================================================
     * =========================             ADD              =========================
     * ================================================================================
     * ================================================================================
     */


    /**
     * Add two bigfloats
     * @example:
     * ===========================
     * let a = BigFloat::new (1230.0), b = BigFloat::new (-230489.0);
     * println (a + b);
     * ===========================
     */
    pub def opBinary {"+"} (self, o : &BigFloat)-> &BigFloat {
        if (self._isNan || self._isInf) return self;
        if (o._isNan || o._isInf) return o;

        let dmut res = mpf_t ();
        __gmpf_init2 (alias &res, 1024us);
        __gmpf_add (alias &res, &self._content, &o._content);

        BigFloat::new (alias res)
    }

    /**
     * Add a bigint and a float
     * @example:
     * ===========================
     * let a = BigInt::new (1230.019);
     * println (a + 124.0);
     * ===========================
     */
    pub def opBinary {"+", T} (self, o : T)-> &BigFloat {
        self + BigFloat::new (o)
    }

    /**
     * Add a bigint and a float
     * @example:
     * ===========================
     * let a = BigInt::new (1230.019);
     * println (124.198 + a);
     * ===========================
     */
    pub def opBinaryRight {"+", T} (self, o : T)-> &BigFloat {
        BigFloat::new (o) + self
    }

        /**
     * ================================================================================
     * ================================================================================
     * =========================             SUB              =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Subtract two bigfloat
     * @example:
     * ===========================
     * let a = BigFloat::new (1230.0), b = BigFloat::new (-230489.0);
     * println (a - b);
     * ===========================
     */
    pub def opBinary {"-"} (self, o : &BigFloat)-> &BigFloat {
        if (self._isNan || self._isInf) return self;
        if (o._isNan || o._isInf) return o;

        let dmut res = mpf_t ();
        __gmpf_init2 (alias &res,  1024us);
        __gmpf_sub (alias &res, &self._content, &o._content);

        BigFloat::new (alias res)
    }

    /**
     * Subtract a bigint and an int
     * @example:
     * ===========================
     * let a = BigFloat::new (1230);
     * println (a - 124);
     * ===========================
     */
    pub def opBinary {"-", T} (self, o : T)-> &BigFloat {
        self - BigFloat::new (o)
    }

    /**
     * Subtract a bigint and an int
     * @example:
     * ===========================
     * let a = BigFloat::new (1230);
     * println (124 - a);
     * ===========================
     */
    pub def opBinaryRight {"-", T} (self, o : T)-> &BigFloat {
        BigFloat::new (o) - self
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================             MUL              =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Multiple two bigint
     * @example:
     * ===========================
     * let a = BigFloat::new (1230), b = BigFloat::new (-230489);
     * println (a * b);
     * ===========================
     */
    pub def opBinary {"*"} (self, o : &BigFloat)-> &BigFloat {
        if (self._isNan || self._isInf) return self;
        if (o._isNan || o._isInf) return o;

        let dmut res = mpf_t ();
        __gmpf_init2 (alias &res, 1024us);
        __gmpf_mul (alias &res, &self._content, &o._content);

        BigFloat::new (alias res)
    }

    /**
     * Multiple a bigint and an int
     * @example:
     * ===========================
     * let a = BigFloat::new (1230);
     * println (a * 124);
     * ===========================
     */
    pub def opBinary {"*", T} (self, o : T)-> &BigFloat {
        self * BigFloat::new (o)
    }

    /**
     * Multiple a bigint and an int
     * @example:
     * ===========================
     * let a = BigFloat::new (1230);
     * println (124 * a);
     * ===========================
     */
    pub def opBinaryRight {"*", T} (self, o : T)-> &BigFloat {
        BigFloat::new (o) * self
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================            DIVIDE            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Divide two bigint
     * @example:
     * ===========================
     * let a = BigFloat::new (1230), b = BigFloat::new (-230489);
     * println (a / b);
     * ===========================
     */
    pub def opBinary {"/"} (self, o : &BigFloat)-> &BigFloat
        throws &BigFloatError
    {
        if (self._isNan || self._isInf) return self;
        if (o._isNan || o._isInf) return o;

        if (__gmpf_cmp_ui (&o._content, 0u64) == 0) {
            throw BigFloatError::new ("Dividing by 0");
        }

        let dmut res = mpf_t ();
        __gmpf_init2 (alias &res, 1024us);
        __gmpf_div (alias &res, &self._content, &o._content);

        BigFloat::new (alias res)
    }

    /**
     * Multiple a bigint and an int
     * @example:
     * ===========================
     * let a = BigFloat::new (1230);
     * println (a / 124);
     * ===========================
     */
    pub def opBinary {"/", T} (self, o : T)-> &BigFloat
        throws &BigFloatError
    {
        self / BigFloat::new (o)
    }

    /**
     * Multiple a bigint and an int
     * @example:
     * ===========================
     * let a = BigFloat::new (1230);
     * println (124 / a);
     * ===========================
     */
    pub def opBinaryRight {"/", T} (self, o : T)-> &BigFloat
        throws &BigFloatError
    {
        BigFloat::new (o) / self
    }

    /**
     * Modulo two bigint
     * @example:
     * ===========================
     * let a = BigFloat::new (1230), b = BigFloat::new (-230489);
     * println (a % b);
     * ===========================
     * @throws:
     *    - &BigFloatError: if b is equal to 0
     */
    pub def opBinary {"%"} (self, o : &BigFloat)-> &BigFloat
        throws &BigFloatError
    {
        if (self._isNan || self._isInf) return self;
        if (o._isNan || o._isInf) return o;

        if (__gmpf_cmp_ui (&o._content, 0u64) == 0) {
            throw BigFloatError::new ("Dividing by 0");
        }

        let dmut res = mpf_t ();
        __gmpf_init2 (alias &res, 1024us);
        __gmpf_mod (alias &res, &self._content, &o._content);

        BigFloat::new (alias res)
    }

    /**
     * Multiple a bigint and an int
     * @example:
     * ===========================
     * let a = BigFloat::new (1230);
     * println (a % 124);
     * ===========================
     * @throws:
     *    - &BigFloatError: if b is equal to 0
     */
    pub def opBinary {"%", T} (self, o : T)-> &BigFloat
        throws &BigFloatError
    {
        self % BigFloat::new (o)
    }

    /**
     * Multiple a bigint and an int
     * @example:
     * ===========================
     * let a = BigFloat::new (1230);
     * println (124 % a);
     * ===========================
     * @throws:
     *    - &BigFloatError: if b is equal to 0
     */
    pub def opBinaryRight {"%", T} (self, o : T)-> &BigFloat
        throws &BigFloatError
    {
        BigFloat::new (o) % self
    }


    /**
     * Power a bigint and an int
     * @example:
     * ===========================
     * let a = BigFloat::new (1230);
     * println (124 ^^ a);
     * ===========================
     * @throws:
     *    - &BigFloatError: if o does not fit in a u64
     */
    pub def opBinary {"^^"} (self, exp : i64)-> &BigFloat
        throws &BigFloatError
    {
        if (self._isNan || self._isInf) return self;

        let mut v = BigFloat::new (1.0);
        let mut expV = exp;
        let mut pow = if (exp < 0) { 1.0 / self } else { self } ;

        if (exp < 0) expV = -expV;

        while (expV > 0i64) {

            if (expV & 1i64 != 0i64) v *= pow;
            pow *= pow;
            expV = expV >> 1i64;
        }

        v
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================          COMPARISON          =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Compare two big ints
     */
    pub def opCmp (self, o : &BigFloat)-> i32 {
        if (self._isNan) { if (o._isNan) return 0; else return 1; }
        else if (o._isNan) { return 1; }

        else if (self._isInf && o._isInf) {
            if (self._isPositive && !o._isPositive) return 1;
            else if (!self._isPositive && o._isPositive) return -1;
            else return 0;
        }

        else if (o._isInf) { if (o._isPositive) return -1; else return 1; }
        else if (self._isInf) { if (self._isPositive) return 1; else return -1; }

        __gmpf_cmp (&self._content, &o._content)
    }

    /**
     * Compare a big int and an integer
     */
    pub def opCmp {T} (self, o : T)-> i32 {
        self.opCmp (BigFloat::new (o))
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================          CONVERTION          =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Convert a big int into a simple int
     * @example :
     * ============================
     * let a = BigFloat::new (u32::max) + 198;
     * let b = a.to!u64 ();
     * ============================
     * @throws:
     *     - &BigFloatError: if the int does not fit in the result var (< T::min, or > T::max)
     */
    pub def to {T} (self)-> T {
        if (self._isNan) return T::nan;
        if (self._isInf) { if (self._isPositive) return T::inf else { return -T::inf; }}

        cte if (is!{T}{F of f32}) {
            let d = __gmpf_get_d (&self._content);
            cast!T (d)
        } else {
            let d = __gmpf_get_d (&self._content);
            d
        }
    }

    /**
     * Transform the big float into a hexadecimal string
     * */
    pub def toHexString (self)-> [c8] {
        let len = __gmp_snprintf (null, 0u32, "%Fa"s8.ptr, &self._content);

        let dmut res = ['\u{0}'c8 ; new len + 1us];
        __gmp_snprintf (alias res.ptr, len + 1u32, "%Fa"s8.ptr, &self._content);

        return res[0us .. $ - 1us];
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================             DTOR              ========================
     * ================================================================================
     * ================================================================================
     */

    __dtor (mut self) {
        __gmpf_clear (alias &self._content);
    }


    impl Streamable {

        pub over toStream (self, dmut stream : &StringStream) {
            if (self._isNan) {
                stream:.write ("nan"s8);
            }
            else if (self._isInf) {
                if (self._isPositive) {
                    stream:.write ("inf");
                } else { stream:.write ("-inf"); }
            }
            else {
                let len = __gmp_snprintf (null, 0u32, "%Ff"s8.ptr, &self._content);
                let dmut res = ['\u{0}'c8 ; new len + 1us];

                __gmp_snprintf (alias res.ptr, len + 1u32, "%Ff"s8.ptr, &self._content);
                stream:.write (res [0us .. $ - 1us]);
            }
        }

    }

}
