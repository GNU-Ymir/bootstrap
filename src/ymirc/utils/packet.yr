in packet;

use std::fs::path;

lazy mut __SERIALIZE_SET__ : [*void => mut ()] = copy [];

pub trait Packable {
    pub fn packName (self, ref dmut out : [u8]);

    pub fn __ymirc__packContent (self, ref dmut out : [u8]) {
        self.packName (ref out);
        cte if (__pragma!compile ({self::super.__ymirc__packContent (ref out);})) {
            self::super.__ymirc__packContent (ref out);
        }

        cte for i in 0 .. typeof (self)::field_infos.len {
            let name = cte {typeof (self)::field_infos [i].name};
            cte if (__pragma!compile ({ packet::pack (__pragma!field (self, name), ref out); })) {
                packet::pack (__pragma!field (self, name), ref out);
            }
        }
    }

    pub fn pack (self)-> [u8] {
        let dmut out : [u8] = [];
        cte if is!{typeof (self)}{class C} {
            let vd = etc::runtime::memory::Runtime!{typeof (self), *void}::_yrt_unsafe_cast (self);
            if vd !in __SERIALIZE_SET__ {
                __SERIALIZE_SET__ [vd] = ();
                self.__ymirc__packContent (ref out);
                __SERIALIZE_SET__:.remove (vd);
            }
        } else {
            self.__ymirc__packContent (ref out);
        }

        out
    }
}


pub fn pack {T of [U], U} (data : T, ref dmut out : [u8]) {
    packet::pack!{usize} (data.len, ref out);
    for i in data {
        packet::pack (i, ref out);
    }
}

pub fn pack {T impl Packable} (data : T, ref dmut out : [u8]) {
    data.__ymirc__packContent (ref out);
}

pub fn pack {T of (U,), U...} (data : T, ref dmut out : [u8]) {
    for i in data {
        packet::pack (i, ref out);
    }
}

pub fn pack {T} (data : T, ref dmut out : [u8]) {
    cte if is!{T}{class C} || is!{T}{record C} {
        cte assert (false, "Can't pack type " ~ cte {T::typeid} ~ " that does not implemement Packable");
    }

    let void_ptr = cast!{*void} (&data);
    let u8_ptr = cast!{*u8} (void_ptr);
    for i in 0 .. T::size {
        unsafe {
            out ~= [u8_ptr [i]];
        }
    }
}
