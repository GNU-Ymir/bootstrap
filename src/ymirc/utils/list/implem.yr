in implem;

use std::stream;

pub class IList {T, mutable : bool} {

    let mut _len = 0us;
    cte if mutable {
        let dmut _data : [T] = [];
    } else {
        let mut _data : [mut T] = [];
    }

    pub self () {}

    cte if mutable {
        pub fn push (mut self, dmut val : T) {
            if self._data.len == self._len {
                self:.grow ();
            }

            self._data [self._len] = alias val;
            self._len += 1;
        }

        pub fn opIndex (mut self)-> dmut [T] {
            alias self._data [0 .. self._len]
        }

        pub fn opIndex (mut self, index : usize)-> dmut T {
            alias self._data [index]
        }

        pub fn setBack (mut self, dmut v : T) {
            if self._len > 0 {
                self._data [self._len - 1] = alias v;
            }
        }

        pub fn back (mut self)-> dmut T {
            if self._len > 0 {
                return alias self._data [self._len - 1];
            }

            panic;
        }

        pub fn front (mut self)-> dmut T {
            if self._len > 0 {
                return alias self._data [0];
            }

            panic;
        }
    } else {
        pub fn push (mut self, val : T) {
            if self._data.len == self._len {
                self:.grow ();
            }

            self._data [self._len] = val;
            self._len += 1;
        }

        pub fn setBack (mut self, v : T) {
            if self._len > 0 {
                self._data [self._len - 1] = v;
            }
        }

        pub fn opIndex (mut self)-> mut [mut T] {
            alias self._data [0 .. self._len]
        }

    }

    pub fn opIndex (self, index : usize)-> T {
        self._data [index]
    }

    pub fn opIndex (self)-> [T] {
        self._data [0 .. self._len]
    }

    pub fn back (self)-> T {
        if self._len > 0 {
            return self._data [self._len - 1]
        }

        panic;
    }

    pub fn front (self)-> T {
        if self._len > 0 {
            return self._data [0]
        }

        panic;
    }

    pub fn clear (mut self) {
        self._len = 0;
    }

    pub fn isEmpty (self)-> bool {
        self._len == 0
    }

    @field
    pub fn len (self)-> usize {
        self._len
    }

    pub fn pop (mut self) {
        if self._len == 0 { return; }
        self._len -= 1;
    }

    /**
     * Change the size of the capacity to write other elements
     * @complexity: O (n), with n = self._len
     */
    prv fn grow (mut self) {
        if (self._data.len == 0us) { // empty
            self._data = alias core::types::array::allocArray!T (2);
        }  else {
            let n_len = self._data.len * 2;
            cte if mutable {
                let dmut aux : [T] = core::types::array::allocArray!T (n_len);
                core::types::array::memCopy!T (self._data, alias aux);
                self._data = alias aux;
            } else {
                let mut aux : [mut T] = core::types::array::allocArray!T (n_len);
                core::types::array::memCopy!T (self._data, alias aux);
                self._data = alias aux;
            }
        }
    }

    
}
