in log;

use std::{io, conv, stream, traits};
use ymirc::utils::{format, colors};
use ymirc::global::state;

pub mod logging {

    lazy dmut __start__ : [u64] = copy [0u64];

    extern (C) fn clock ()-> u64;
    def CLOCKS_PER_SEC = 1_000_000.0;

    fn getInstant ()-> f64 {
        if __start__ [0] == 0 {
            __start__ [0] = clock ();
        }

        cast!f64 ((clock () - __start__ [0])) / CLOCKS_PER_SEC
    }

    enum : [c8]
    | SUCCESS = "Success"
    | FAILURE = "Failure"
    | INFO    = "Info"
    | WARN    = "Warn"
     -> LoggingMods; 

    pub fn init () {
        if (__start__ [0] == 0)
            __start__ [0] = clock ();
    }

    pub fn info (msg : [c8]) {
        if state::instance ().isVerboseActive () {
            println (format ("[%(b)] : %(B)s => % ", LoggingMods::INFO, getInstant (), msg));
        }
    }

    pub fn info {T...} (msg : [c8], params : T) {
        if state::instance ().isVerboseActive () {
            let dmut stream = copy StringStream ();
            cte if isTuple!{typeof (params)} {
                stream:.write (format (msg, expand params));
            } else {
                stream:.write (format (msg, params));
            }
            println (format ("[%(b)] : %(B)s => % ", LoggingMods::INFO, getInstant (), stream []));
        }
    }

    pub fn warn (msg : [c8]) {
        if state::instance ().isVerboseActive () {
            println (format ("[%(y)] : %(B)s => % ", LoggingMods::WARN, getInstant (), msg));
        }
    }

    pub fn warn {T...} (msg : [c8], params : T) {
        if state::instance ().isVerboseActive () {
            let dmut stream = copy StringStream ();
            cte if isTuple!{typeof (params)} {
                stream:.write (format (msg, expand params));
            } else {
                stream:.write (format (msg, params));
            }

            println (format ("[%(y)] : %(B)s => % ", LoggingMods::WARN, getInstant (), stream[]));
        }
    }


    pub fn success (msg : [c8]) {
        if state::instance ().isVerboseActive () {
            println (format ("[%(g)] : %(B)s => % ", LoggingMods::SUCCESS, getInstant (), msg));
        }
    }


    pub fn success {T...} (msg : [c8], params : T) {
        if state::instance ().isVerboseActive () {
            let dmut stream = copy StringStream ();
            cte if isTuple!{typeof (params)} {
                stream:.write (format (msg, expand params));
            } else {
                stream:.write (format (msg, params));
            }

            println (format ("[%(g)] : %(B)s => % ", LoggingMods::SUCCESS, getInstant (), stream[]));
        }
    }

    pub fn failure (msg : [c8]) {
        if state::instance ().isVerboseActive () {
            println (format ("[%(r)] : %(B)s => % ", LoggingMods::FAILURE, getInstant (), msg));
        }
    }

    pub fn failure {T...} (msg : [c8], params : T) {
        if state::instance ().isVerboseActive () {
            let dmut stream = copy StringStream ();
            cte if isTuple!{typeof (params)} {
                stream:.write (format (msg, expand params));
            } else {
                stream:.write (format (msg, params));
            }

            println (format ("[%(r)] : %(B)s => % ", LoggingMods::FAILURE, getInstant (), stream[]));
        }
    }

    pub fn setRelativeTime () {
        __start__ [0] = clock ();
    }
    
}
