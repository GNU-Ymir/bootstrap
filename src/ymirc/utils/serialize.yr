mod ymirc::utils::serialize;

import std::conv;
import std::io;
import std::any;
import std::reflect;
import etc::runtime::reflect;
import std::collection::vec;

import std::stream;

/**
 * Exception thrown when deserializeing an invalid serializeet
 */
pub class DeserializeError over Exception {
    pub self () {}

    impl std::stream::Streamable;
}

/**
 * Trait used to transform a class instance into a slice of bytes.
 */
pub trait Serializable {

    /**
     * Create a serializeet from the values contained in the object
     * This will create a full copy of the data, even if the object does not exits anymore the content of the serializeet is still valid
     * Basically this function create a flattened version of the class that can be send over a socket
     * This serializeet contains all the necessary information to recreate a perfect copy of the object
     */
    pub fn serialize (self)-> [u8] {
        cte if (__pragma!compile ({self::super;})) {
        }

        let name = (__pragma!mangle (typeof (self))).to![c8] ();
        let dmut array = Vec!(u8)::new ();
        serialize (alias array, name);
        cte if (__pragma!compile ({self::super;})) {
            cte if (is!(typeof (self::super)) {U impl Serializable}) {
                self::super.serializeContent (alias array);
            }
        }

        self.serializeContent (alias array);
        array:.fit ();
        return array[];
    }

    /**
     * Create a serializeet from the values contained in the class
     * This will create a full copy of the data, even if the object does not exits anymore the content of the serializeet is still valid
     * All the serializeet data are append at the end of the vector
     * @params:
     *     - serializeet: the vector to fill with object data
     */
    pub fn serialize (self, dmut serializeet : &Vec!u8) {
        serializeet;
        // let name = (__pragma!mangle (typeof (self))).to![c8] ();
        // serialize![c8] (alias serializeet, name);

        // cte if (__pragma!compile ({self::super;})) {
        //     cte if (is!(typeof (self::super)){U impl Serializable}) {
        //         self::super.serializeContent (alias serializeet);
        //     }
        // }

        // self.serializeContent (alias serializeet);
    }

    /**
     * Initiates the content of the class from a serializeet
     * Internal function for serializeet, that is called when we try to deserialize an object
     * @params:
     *    - serializeet: the content of the serializeet
     * @info: the type of the serializeet is assumed already read
     * @returns:
     *    - the number of bytes read inside the serializeet
     */
    pub fn deserializeContent (mut self, serializeet : [u8]) -> usize
        throws &DeserializeError
    {
        cte if (typeof (__pragma!local_tupleof (self))::arity != 0u32) {
            {
                let mut serializeOffset = 0us;
                cte if (__pragma!compile ({self::super;})) {
                    cte if (is!(typeof (self::super)){U impl Serializable}) {
                        serializeOffset = cast!(usize) (self::super:.deserializeContent (serializeet));
                    } else {
                        cte assert (false, "ancestor " ~ typeof (self::super)::typeid ~ " is not serializeable");
                    }
                }

                let dmut t = Runtime!{typeof (self), &u8}::_yrt_unsafe_cast (self);
                cte for i in 0us .. (__pragma!local_field_offsets (typeof (self))).len {
                    let offset = (__pragma!local_field_offsets (typeof (self))) [i];
                    let dmut z : &(mut u8) = alias (t + offset);
                    let (_, serialize_len) = deserialize!(typeof ((__pragma!local_tupleof (self)).i)) (alias z, serializeet [serializeOffset .. $]);

                    serializeOffset += serialize_len;
                }

                return cast!(usize) (serializeOffset);
            }
        } else cte if (__pragma!compile ({self::super;})) {
            cte if (is!(typeof (self::super)){U impl Serializable}) {
                self::super:.deserializeContent (serializeet)
            } else {
                cte assert (false, "ancestor " ~ typeof (self::super)::typeid ~ " is not serializeable");
            }
        } else {
            // some dummy stuff to make the compiler beleive it can throw something
            serializeet;
            __pragma!fake_throw (&DeserializeError);
            0us
        }
    }

    /**
     * Serialize the content of the class inside the serializeet vector
     * Internal function used by the serializeing system
     * @params:
     *    - serializeet: the vector to fill with the content of the object
     */
    prot fn serializeContent (self, dmut serializeet : &Vec!u8)  {
        cte if (typeof (__pragma!local_tupleof (self))::arity == 0u32) {
            serializeet;
        } else {
            for i in __pragma!local_tupleof (self) {
                serialize!{typeof (i)} (alias serializeet, i);
            }
        }
    }
}


/**
 * Deserialize a serializeet and allocates the class it containes
 * @params:
 *    - serializeet: the serializeet to read
 * @returns:
 *    - serializeet: the content read by the function is removed from the serializeet
 *    - The instantiated object
 * @throws:
 *    - DeserializeError: if an error occured when deserializeing
 *      + the serializeet is no valid (some data are missing)
 *      + the serializeet refers to a type that does not exist in the current process (cf. std::reflect)
 */
pub fn deserialize (mut serializeet : [u8])-> dmut &Object
    throws &DeserializeError
{
    let dmut name : [c8] = [];
    {
        let (_, offset) = deserialize!{[c8]} (alias cast!(&u8) (cast!(&void) (&name)), serializeet);
        let dmut obj = internal_reflect::totallyUnsafeFactoryDontDoThat (name);
        internal_reflect::callImplMutable!(usize) (alias obj, s_name-> name, "std::net::serializeet::Serializable::deserializeContent"s8, serializeet[offset .. $]);

        return alias obj;
    } catch {
        x : &DeserializeError => {
            throw x;
        }
        z : &RuntimeError => {
            println (z);
            throw DeserializeError::new ();
        }
    }
}

/**
 * ============================================================================
 * ============================================================================
 * ===========================       SERIALIZE      ===========================
 * ============================================================================
 * ============================================================================
 * */


pub fn serialize {T of [U], U} (dmut serializeet : &Vec!u8, data : T) {
    serialize!usize (alias serializeet, data.len);
    for i in data {
        serialize!U (alias serializeet, i);
    }
}

pub fn serialize {T impl Serializable} (dmut serializeet : &Vec!u8, data : T) {
    data.serialize (alias serializeet);
}

pub fn serialize {struct T} (dmut packet : &Vec!u8, data : T) {
    for i in __pragma!tupleof (data) {
        serialize!{typeof (i)} (alias packet, i);
    }
}

pub fn serialize {T of (U,), U...} (dmut packet : &Vec!u8, data : T) {
    for i in data {
        serialize!{typeof (i)} (alias packet, i);
    }
}

pub fn serialize {T} (dmut serializeet : &Vec!u8, data : T) {
    cte if (is!(T) {class U}) {
        cte assert (false, "Can't serialize type " ~ T ~ " that does not implement Serializable");
    }

    let void_ptr = cast!(&void) (&data);
    let u8_ptr = cast!(&u8) (void_ptr);
    for i in 0us .. sizeof (T) {
        __pragma!trusted ({ serializeet:.push (*(u8_ptr + i)) });
    }
}

/**
 * ============================================================================
 * ============================================================================
 * ===========================      DESERIALIZE     ===========================
 * ============================================================================
 * ============================================================================
 * */

pub fn deserialize {T} (dmut u8_ptr : &u8, serializeet : [u8]) -> (usize, usize)
    throws &DeserializeError
{
    for i in 0us .. sizeof (T) {
        *(u8_ptr + i) = serializeet [i];
    }

    (sizeof (T), sizeof (T))
} catch {
    _ => {
        throw DeserializeError::new ();
    }
}

pub fn deserialize {T of [U], U} (dmut c_ptr : &(u8), serializeet : [u8])-> (usize, usize)
    throws &DeserializeError
{
    let mut len : usize = 0us;
    let dmut p_len : &u8 = alias cast!(&u8) (cast!(&void) (&len));

    let (_, _offset) = deserialize!{usize} (alias p_len, serializeet);
    let dmut res = core::duplication::allocArray!U (len);
    let mut offset = _offset;
    {
        for i in 0us .. len {
            let dmut ptr : &void = alias cast!(&void) (&res [i]);
            let (_, inner_offset) = deserialize!(U) (alias (cast!(&u8) (ptr)), serializeet [offset .. $]);
            offset += inner_offset;
        }

        let mut arr_ptr : &(mut T) = alias cast!(&T) (cast!(&void) (c_ptr));
        *arr_ptr = res;

        return (16us, cast!(usize) (offset));
    } catch {
        _ => {
            throw DeserializeError::new ();
        }
    };
}

pub fn deserialize {T impl Serializable} (dmut c_ptr : &u8, serializeet : [u8])-> (usize, usize)
    throws &DeserializeError
{
    let dmut name : [c8] = [];
    {
        let (_, mut offset) = deserialize![c8] (alias cast!(&u8) (cast!(&void) (&name)), serializeet);
        let dmut obj = internal_reflect::totallyUnsafeFactoryDontDoThat (name);

        match ref obj {
            dmut x : T => {
                offset += x:.deserializeContent (serializeet [cast!usize (offset) .. $]);
                let dmut arr_ptr : &T = alias Runtime!{&u8, &T}::_yrt_unsafe_cast (c_ptr);
                *arr_ptr = alias x;
            }
        }
        return (8us, offset);
    } catch {
        ur : &DeserializeError => {
            throw ur;
        }
        _ => {
            throw DeserializeError::new ();
        }
    }
}

pub fn deserialize {struct T} (dmut c_ptr : &u8, serializeet : [u8]) -> (usize, usize)
    throws &DeserializeError
{
    let mut serializeOffset = 0us;
    cte for i in 0us .. (__pragma!field_offsets (T)).len {
        let offset = (__pragma!field_offsets (T)) [i];
        let dmut z : &(mut u8) = alias (c_ptr + offset);
        let (_, serialize_len) = deserialize!(__pragma!field_type (T, (__pragma!field_names (T))[i])) (alias z, serializeet [serializeOffset .. $]);
        serializeOffset += serialize_len;
    }

    return (sizeof (T), cast!(usize) (serializeOffset));
} catch {
    ur : &DeserializeError => {
        throw ur;
    }
}

pub fn deserialize {T of (U,), U...} (dmut c_ptr : &u8, serializeet : [u8]) -> (usize, usize)
    throws &DeserializeError
{
    let mut serializeOffset = 0us;
    cte for i in 0us .. (__pragma!field_offsets (T)).len {
        let offset = (__pragma!field_offsets (T)) [i];
        let dmut z : &(mut u8) = alias (c_ptr + offset);
        let (_, serialize_len) = deserialize!(__pragma!field_type (T, i)) (alias z, serializeet [serializeOffset .. $]);
        serializeOffset += serialize_len;
    }

    return (sizeof (T), cast!(usize) (serializeOffset));
} catch {
    ur : &DeserializeError => {
        throw ur;
    }
}


mod internal_reflect {
    /**
     * Additional reflection function for easying serializeaging
     * This function is totally unsafe to use outside serializeage, because it will create a class without calling its constructor
     */
    pub fn totallyUnsafeFactoryDontDoThat (name : [c32]) -> dmut &Object
        throws &RuntimeError
    {
        let dmut ret = _yrt_reflect_create_class_from_name_no_construct_utf32 (name);
        alias ret
    }

    /**
     * Additional reflection function for easying serializeaging
     * This function is totally unsafe to use outside serializeage, because it will create a class without calling its constructor
     */
    pub fn totallyUnsafeFactoryDontDoThat (name : [c8]) -> dmut &Object
        throws &RuntimeError
    {
        let dmut ret = _yrt_reflect_create_class_from_name_no_construct (name);
        alias ret
    }

    pub fn callImplMutable {T, class S, F...} (dmut s : S, s_name : [c8], name : [c8], params : F) -> T
        throws &RuntimeError
    {
        {
            import std::conv;

            let dmut names = Vec!([c8])::new ();
            cte if (is!F {U of (J,), J...}) {
                for i in params {
                    names:.push ((__pragma!mangle (typeof (i))).to![c8] ());
                }
            } else {
                names:.push ((__pragma!mangle (typeof (params))).to![c8] ());
            }

            let ret = Reflect!{fn (dmut S, F)-> T}::_yrt_reflect_get_impl_method_mutable (s_name, name, (__pragma!mangle (T)).to![c8] (), names[]);
            ret (alias s, expand params)
        }
    }
}

mod Runtime {F, T} {

    /**
     * Runtime unsafe cast of a pointer to another
     * This is used to initialized the fields even when they are not mutable
     * This is unsafe but we can argue that if a class has successfuly produced a serializeet
     * Then the serializeet contains a valid class that can be copied as it is
     */
    pub extern (C) fn _yrt_unsafe_cast (x : F)-> dmut T;

    /**
     * Runtime unsafe cast of a pointer to another
     * This is used to initialized the fields even when they are not mutable
     * This is unsafe but we can argue that if a class has successfuly produced a serializeet
     * Then the serializeet contains a valid class that can be copied as it is
     */
    pub extern (C) fn _yrt_unsafe_cast (ref x : F)-> dmut T;

}
