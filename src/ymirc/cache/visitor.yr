in visitor;

use std::{io, stream, fs::_};
use ymirc::semantic::symbol::{_, macro_::_};
use ymirc::lint::node::{_, instr::_, global::_, type::_, value::_};

/**
 * The cache manager loads and store cache files to avoid rebuilding unchanged modules
 * */
pub class CacheManager {

    // The root path of the package being validated
    let _packageDir : Path;

    // The list of modules being cached
    let mut _list : [mut Path] = [];

    // The list of
    let mut _dependencies : [Path => mut [Path => mut ()]] = copy [];

    /**
     * @params:
     *   - package: the path of the package being cached
     * */
    pub self (package : Path)
        with _packageDir = package
    {}

    /**
     * Load the dependency files, and resolve the list of files that are cached
     * */
    pub fn loadDependencies (mut self) {}

    /**
     * Load the yil nodes that are stored in the cache and are not invalided by dependency updates
     * */
    pub fn loadCachedYILs (mut self)-> [&YILSymbol] {
        []
    }

    /**
     * Produce the cache using the list of node that are generated by the current compilation
     * */
    pub fn produceCache (mut self, nodes : [&YILSymbol]) {
        nodes;
        // self._dependencies = [];
        // for n in nodes if self._packageDir.isPrefix (n.getPath ()) {
        //     let nP = n.getPath ().removePrefix (self._packageDir);
        //     if !nP.isEmpty () {
        //         if nP !in self._dependencies {
        //             self._dependencies [nP] = [];
        //         }

        //         for _, p in n.getReferences () if self._packageDir.isPrefix (p) {
        //             if let Ok (ref dmut lst) = ref self._dependencies [nP] {
        //                 lst [p.removePrefix (self._packageDir)] = ();
        //                 // self._dependencies [nP] = alias lst;
        //             } else panic;
        //         }
        //     }
        // }

    }


}
