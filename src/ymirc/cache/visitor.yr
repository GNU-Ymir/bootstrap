in visitor;

use std::{io, stream, fs::_, config, config::_};
use ymirc::semantic::symbol::{_, macro_::_};
use ymirc::lint::node::{_, instr::_, global::_, type::_, value::_};
use ymirc::utils::log;


/**
 * The cache manager loads and store cache files to avoid rebuilding unchanged modules
 * */
pub class CacheManager {

    // The root path of the package being validated
    let _packageDir : Path;

    // The list of files that have been cached in the previous iteration
    let mut _cached : [Path => mut ()] = copy [];

    /**
     * @params:
     *   - package: the path of the package being cached
     * */
    pub self (package : Path)
        with _packageDir = package
    {}

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===============================          DEPENDENCY LOADING          ===============================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Load the dependency files, and resolve the list of files that are cached
     * */
    pub fn loadDependencies (mut self) {
        if (!fs::sys::isFile (Path (".ymirc/deps.json"))) {
            logging::warn ("No cache dependency file found (.ymirc/deps.json), compiling from scratch without cache");
            return;
        }

        let mut deps : [Path => mut (u64, [Path])] = copy [];
        {
            let dmut f = File::open (Path (".ymirc/deps.json"));
            if let js : &Dict = json::parse (f:.readAll ()) {
                for k, v in js[] {
                    if let Ok ((date : &Int, list : &Array)) = (v ["date"], v ["deps"])? {
                        let dmut innerDeps : [Path] = [];
                        for i in list[] if let Str (value-> z) = i {
                            innerDeps ~= [Path (z)];
                        } else { assert (false); }

                        deps [Path (k)] = (cast!u64 (date.value), innerDeps);
                    } else { assert (false); }
                }
            } else { assert (false); }
        } catch {
            _ => {
                logging::warn ("Error when loading cache dependency file (.ymirc/deps.json), compiling from scratch without cache");
                return;
            }
        }

        self:.resolveDependencyUpdates (deps);
    }


    /**
     * Traverse the dependency graph, and keep only the files that have not changed and whose dependency also didn't changed
     * Also check wether the cache file of the module is present or not
     * */
    fn resolveDependencyUpdates (mut self, deps : [Path => (u64, [Path])]) {
        let dmut touched : [Path => bool] = copy [];
        let dmut keeps : [Path => ()] = copy [];
        for d in deps {
            if !self.traverseDependencies (d, deps, alias touched) {
                keeps [d] = ();
            }
        }

        self._cached = alias keeps;
    }

    /**
     * Traverse the dependency graph
     * @returns: true if the file must be recompiled
     * */
    fn traverseDependencies (self, current : Path, dependencies : [Path => (u64, [Path])], dmut touched : [Path => bool])-> bool {
        if let Ok (b) = touched [current] {
            return b;
        }

        if let Ok ((date, deps)) = dependencies [current] {
            let modified = {
                fs::sys::fileDate (self._packageDir.push (current).addExtension ("yr")).sec > date
            } catch {
                _ => {
                    true
                }
            };

            let hasBeenCached = fs::sys::isFile (Path (".ymirc/").push (current.toStr (sep-> "_")).addExtension ("yil"));

            // File has been modified or cache file not found, no need to check dependencies
            if (modified || !hasBeenCached) {
                touched [current] = true;
                return true;
            }

            // Marked to the file as touched to avoid infinite recursions
            touched [current] = false;
            for d in deps {
                if self.traverseDependencies (d, dependencies, alias touched) { // a dependency has changed
                    touched [current] = true;
                    return true;
                }
            }

            // File not modified and dependencies also keeped as they were
            return false;
        }

        // file not in dependencies, means it is a new file
        touched [current] = true;
        return true;
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =================================          CACHE CHECKING          =================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * @params:
     *     - path: the file path containing the module being validated
     * @returns: true if the module is cached and does not need to be revalidated
     * */
    pub fn isCached (self, path : Path)-> bool {
        if (!self._packageDir.isPrefix (path)) {
            return false;
        }

        let modPath = path.removePrefix (self._packageDir).stripExtension ();
        modPath in self._cached
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =============================          CACHED MODULE LOADING          ==============================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Load the yil nodes that are stored in the cache and are not invalided by dependency updates
     * */
    pub fn loadCachedYILs (mut self)-> [&YILSymbol] {
        []
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =================================          CACHE DUMPING          ==================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Produce the cache using the list of node that are generated by the current compilation
     * */
    pub fn produceCache (mut self, nodes : [&YILSymbol]) {
        logging::info ("Export package cache");
        let dmut dependencies : [Path => [Path => ()]] = copy [];
        let mut symbols : [Path => mut [&YILSymbol]] = copy [];
        for n in nodes {
            let path = if self._packageDir.isPrefix (n.getPath ()) {
                let nP = n.getPath ().removePrefix (self._packageDir);
                if nP !in dependencies {
                    dependencies [nP] = copy [];
                }

                for _, p in n.getReferences () if self._packageDir.isPrefix (p) && p != n.getPath () {
                    if let Ok (dmut lst) = alias dependencies [nP] {
                        lst [p.removePrefix (self._packageDir)] = ();
                    } else panic;
                }

                nP
            } else { Path ("#_external") };


            if let Ok (lst) = symbols [path] {
                let rest = lst ~ [n];
                symbols [path] = rest;
            } else {
                symbols [path] = copy [n];
            }
        }

        self:.produceDependencyTree (dependencies);
        self:.writeCacheSymbols (symbols);
    }

    /**
     * Produce the dependency tree file listing dependencies between source files
     * */
    fn produceDependencyTree (mut self, graph : [Path => [Path => ()]]) {
        let dmut touched = copy Dict ();
        for v, neigh in graph {
            let date = {
                fileDate (self._packageDir.push (v).addExtension ("yr")).sec
            } catch {
                _ => { 0 }
            };

            let dmut pair = copy Dict ();
            pair:["date"] = copy Int (cast!i64 (date));
            pair:["deps"] = copy Array (copy [copy Str (n.toStr ()) for n, _ in neigh]);
            touched:[v.toStr ()] = pair;
        }

        {
            if (fs::sys::isDir (Path ("./.ymirc/"))) {
                fs::sys::removeDir (Path ("./.ymirc/"), recursive-> true);
            }

            fs::sys::createDir (Path ("./.ymirc"));
            let dmut f = File::create (Path (".ymirc/deps.json"), write-> true);
            f:.write (json::dump (touched));
        } catch {
            err => {
                logging::failure ("Failed to write cache dependency file\n\t=>", err);
                return;
            }
        }

        logging::info ("Emitted dependency file : .ymirc/deps.json");
    }

    /**
     * Write the symbol to write in cache
     * */
    fn writeCacheSymbols (mut self, symbols : [Path => [&YILSymbol]]) {
        for p, syms in symbols {
            let dmut f = File::create (Path (".ymirc/").push (Path (p.toStr (sep-> "_")).addExtension ("yil")), write-> true);
            for s in syms {
                f:.writeBytes (s.pack ());
            }
        }
    } catch {
        _ => {
            logging::failure ("Failed to write cache files");
        }
    }

}
