mod ymirc::parser;
import ymirc::args::_;

import std::fs::path;
import std::io, std::conv;
import ymirc::syntax::_;
import ymirc::errors::_;
import ymirc::utils::_;
import ymirc::lexing::lexer;

import ymirc::syntax::visitor;
import ymirc::semantic::declarator::visitor;
import ymirc::semantic::declarator::errors;
import ymirc::semantic::validator::visitor;
import std::time::_;

/**
 * The main class of the ymirc compiler
 * This class perform the different parsing step of the compilation, and gives the result to the backend
 */
pub class Parser {

    /// The configuration of the parser
    let _args : YmirArguments;

    /**
     * @params: 
     *  - args: the arguments passed to the compiler
     */
    pub self (args : YmirArguments)
        with _args = args
    {
        for i in args.fversion {
            global::state::instance ():.addVersion (i.(std::conv::to)![c8] ());
        }
        
        for d in args.includes {
            global::state::instance ():.addIncludeDir (d.(std::conv::to)![c8] ());
        }
        
        for i in args.files {
            self:.parseFile (Path::new (i));
        }        
    }


    /***
     * ============================================================================
     * ============================================================================
     * =========================          PARSING        ==========================
     * ============================================================================
     * ============================================================================
     */
    
    /**
     * Parse a given file
     * @params: 
     *  - file: the path of the file
     */
    prv def parseFile (mut self, file : &Path) {
        {            
            let modSynt = SyntaxVisitor::new (file):.read ();
            let dmut modSym = Declarator::new ():.declare (modSynt);
            let dmut valid = Validator::new ();
            valid:.validate (alias modSym);

            for i in valid.getGenerators () {
                println (format ("%", i));
            }            
        } catch {
            err : &ErrorMsg => {
                println (format ("%", err));
                __version DEBUG {
                    for j in err.getRecursiveTrace () {                        
                        println (j);
                    }
                }
                println (format ("ymirc: %(r)\ncompilation terminated", "fatal error"s8));
            }
            _ : _ => {
                println (format ("%(r) : ", "Error"s8), format (DeclareErrorMessage::NO_SUCH_FILE, file.toStr ()));
                println (format ("ymirc: %(r)\ncompilation terminated", "fatal error"s8));
            }
        }
    }


    /***
     * ============================================================================
     * ============================================================================
     * =========================          GETTERS        ==========================
     * ============================================================================
     * ============================================================================
     */

    
    
    
}
