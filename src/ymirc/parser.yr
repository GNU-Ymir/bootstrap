mod ymirc::parser;
import ymirc::args::_;

import std::io, std::conv;
import ymirc::syntax::_;
import ymirc::errors::_;
import ymirc::utils::_;
import ymirc::lexing::lexer;
import ymirc::lexing::word;

import ymirc::syntax::visitor;
import ymirc::semantic::declarator::visitor;
import ymirc::semantic::declarator::errors;
import ymirc::semantic::validator::visitor;
import ymirc::semantic::generator::base;
import ymirc::semantic::symbol::base;

import std::time::_;
import std::fs::_;
import std::collection::vec;



/**
 * The main class of the ymirc compiler
 * This class perform the different parsing step of the compilation, and gives the result to the backend
 */
pub class Parser {

    let _args : YmirArguments;
    
    /**
     * Create an empty file parser
     */
    pub self (args : YmirArguments)
        with _args = args
    {
        for i in args.fversion {
            global::state::instance ():.addVersion (i.(std::conv::to)![c8] ());
        }
        
        for d in args.includes {
            global::state::instance ():.addIncludeDir (d.(std::conv::to)![c8] ());
        }

        if (args.debug) {
            global::state::instance ():.activateDebug ();
        }
    }    

    /***
     * ============================================================================
     * ============================================================================
     * =========================          PARSING        ==========================
     * ============================================================================
     * ============================================================================
     */

    /**
     * Parse the files requested by the arguments given to the parser
     * @returns:
     *    - the generators created by validation process
     */
    pub fn parseAll (mut self)-> [&Generator]
        throws &ErrorMsg
    {
        self:.parseFile (Path::new (self._args.file))
    }
        
    
    /**
     * Parse a given file
     * @params: 
     *  - file: the path of the file
     */
    prv fn parseFile (mut self, file : &Path)-> [&Generator]
        throws &ErrorMsg
    {
        let modSynt = SyntaxVisitor::new (file):.read ();
        let dmut declarator = Declarator::new (packageDir-> file.parent ());

        let dmut modSym = declarator:.declareGlobal (modSynt);

        if (global::state::instance ().isSymTreeDumping ()) {
            self.dumpSymTree (modSym, file.addExtension ("syms"s8));
        }

        let dmut valid = Validator::new (alias declarator);
        valid:.validate (alias modSym);
        
        let gens = modSym.getGenerators ();
        if (global::state::instance ().isYmirDumping ()) {
            self.dumpGenerators (gens, file.addExtension ("sem"s8));
        }
        gens
    } catch {
        err : &ErrorMsg => throw err;
        _ : &FsError => {
            throw ErrorMsg::fatal (EOF_WORD, format (DeclareErrorMessage::NO_SUCH_FILE, file.toStr ()), oneLine-> true);
        }
    }

    prv fn dumpSymTree (self, sym : &Symbol, path : &Path) {
        let dmut stream = Formatter::new ();
        sym.formatSymTree (alias stream);
        with dmut f = File::create (path, write-> true) {
            f:.write (stream[]);
        } catch {
            _ => {}
        }
    }

    /**
     * Dump the semantic generators to an output file
     * @params:
     *    - gens: the generators to dump
     *    - output: the path to the file in which result is outputted
     * */
    prv fn dumpGenerators (self, gens : [&Generator], output : &Path) {
        let dmut stream = Formatter::new ();
        stream:.withVarIds (false);
        for i in gens {
            stream:.write (i, '\n'c8);
        }
        {
            with dmut f = File::create (output, write-> true) {
                f:.write (stream[]);
            }
        } catch {
            _ => {}
        }
    }

    /***
     * ============================================================================
     * ============================================================================
     * =========================          GETTERS        ==========================
     * ============================================================================
     * ============================================================================
     */

    
    
    
}
