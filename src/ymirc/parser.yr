mod ymirc::parser;
import ymirc::args::_;

import std::io, std::conv;
import ymirc::syntax::_;
import ymirc::errors::_;
import ymirc::utils::_;
import ymirc::lexing::lexer;
import ymirc::lexing::word;

import ymirc::syntax::visitor;
import ymirc::semantic::declarator::visitor;
import ymirc::semantic::declarator::errors;
import ymirc::semantic::validator::visitor;
import ymirc::semantic::generator::base;
import std::time::_;
import std::fs::_;
import std::collection::vec;

/**
 * The main class of the ymirc compiler
 * This class perform the different parsing step of the compilation, and gives the result to the backend
 */
pub class Parser {

    let _args : YmirArguments;
    
    /**
     * Create an empty file parser
     */
    pub self (args : YmirArguments)
        with _args = args
    {
        for i in args.fversion {
            global::state::instance ():.addVersion (i.(std::conv::to)![c8] ());
        }
        
        for d in args.includes {
            global::state::instance ():.addIncludeDir (d.(std::conv::to)![c8] ());
        }

        if (args.debug) {
            global::state::instance ():.activateDebug ();
        }
    }    

    /***
     * ============================================================================
     * ============================================================================
     * =========================          PARSING        ==========================
     * ============================================================================
     * ============================================================================
     */

    /**
     * Parse the files requested by the arguments given to the parser
     * @returns:
     *    - the generators created by validation process
     */
    pub def parseAll (mut self)-> [&Generator]
        throws &ErrorMsg
    {
        let dmut rets = Vec!{&Generator}::new ();
        for f in self._args.files {
            let gens = self:.parseFile (Path::new (f));
            for g in gens {
                rets:.push (g);
            }
        }

        rets[]
    }
        
    
    /**
     * Parse a given file
     * @params: 
     *  - file: the path of the file
     */
    prv def parseFile (mut self, file : &Path)-> [&Generator]
        throws &ErrorMsg
    {
        let modSynt = SyntaxVisitor::new (file):.read ();
        let dmut declarator = Declarator::new ();
        let dmut modSym = declarator:.declare (modSynt);
        let dmut valid = Validator::new (alias declarator);
        valid:.validate (alias modSym);
        
        valid.getGenerators ()        
    } catch {
        err : &ErrorMsg => throw err;
        _ : &FsError => {
            throw ErrorMsg::fatal (EOF_WORD, format (DeclareErrorMessage::NO_SUCH_FILE, file.toStr ()), oneLine-> true);
        }
    }


    /***
     * ============================================================================
     * ============================================================================
     * =========================          GETTERS        ==========================
     * ============================================================================
     * ============================================================================
     */

    
    
    
}
