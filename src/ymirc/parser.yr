mod ymirc::parser;
import ymirc::args::_;

import std::io, std::conv;
import ymirc::syntax::_;
import ymirc::errors::_;
import ymirc::utils::_;
import ymirc::lexing::lexer;
import ymirc::lexing::word;

import ymirc::syntax::visitor;
import ymirc::semantic::declarator::visitor;
import ymirc::semantic::cache::visitor;
import ymirc::semantic::validator::visitor;

import ymirc::semantic::declarator::errors;
import ymirc::semantic::generator::base;
import ymirc::semantic::symbol::base;

import std::time::_;
import std::fs::_;
import std::env;
import std::collection::vec;



/**
 * The main class of the ymirc compiler
 * This class perform the different parsing step of the compilation, and gives the result to the backend
 */
pub class Parser {

    let _args : YmirArguments;
    
    /**
     * Create an empty file parser
     */
    pub self (args : YmirArguments)
        with _args = args
    {
        for i in args.fversion {
            global::state::instance ():.addVersion (i.(std::conv::to)![c8] ());
        }
        
        for d in args.includes {
            global::state::instance ():.addIncludeDir (d.(std::conv::to)![c8] ());
        }

        if (args.debug) {
            global::state::instance ():.activateDebug ();
        }
    }    

    /***
     * ============================================================================
     * ============================================================================
     * =========================          PARSING        ==========================
     * ============================================================================
     * ============================================================================
     */

    /**
     * Parse the files requested by the arguments given to the parser
     * @returns:
     *    - the generators created by validation process
     */
    pub fn parseAll (mut self)-> [&Generator]
        throws &ErrorMsg
    {
        let mut path = Path::new (self._args.file);
        if (!path.isAbsolute ()) {
            path = env::currentDir ().push (path);
        }

        self:.parsePackage (path)
    }
        
    
    /**
     * Parse a given file
     * @params: 
     *  - file: the path of the file
     */
    prv fn parsePackage (mut self, file : &Path)-> [&Generator]
        throws &ErrorMsg
    {
        let modSynt = SyntaxVisitor::new (file):.read ();
        let dmut declarator = Declarator::new (packageDir-> file.parent ());
        let dmut modSym = declarator:.declareGlobal (modSynt);

        let dmut cache = Cache::new (packageDir-> file.parent (), alias modSym);
        cache:.load ();

        let dmut valid = Validator::new (alias declarator, alias cache);
        valid:.validate (alias modSym);


        let dmut formatter = Formatter::new ();
        modSym.formatSymTree (alias formatter);
        println (formatter[]);


        cache:.dump ();
        []
    } catch {
        err : &ErrorMsg => throw err;
        _ : &FsError => {
            throw ErrorMsg::fatal (EOF_WORD, format (DeclareErrorMessage::NO_SUCH_FILE, file.toStr ()), oneLine-> true);
        }
    }

    /***
     * ============================================================================
     * ============================================================================
     * =========================          GETTERS        ==========================
     * ============================================================================
     * ============================================================================
     */

    
    
    
}
