mod ymirc::parser;
import ymirc::args::_;

import std::io, std::conv;
import ymirc::syntax::_;
import ymirc::errors::_;
import ymirc::utils::_;
import ymirc::lexing::lexer;
import ymirc::lexing::word;

import ymirc::syntax::visitor;
import ymirc::semantic::declarator::visitor;
import ymirc::semantic::declarator::errors;
import ymirc::semantic::validator::visitor;
import ymirc::semantic::generator::base;
import ymirc::semantic::symbol::base;

import std::time::_;
import std::fs::_;
import std::collection::vec;

/**
 * The main class of the ymirc compiler
 * This class perform the different parsing step of the compilation, and gives the result to the backend
 */
pub class Parser {

    let _args : YmirArguments;
    
    /**
     * Create an empty file parser
     */
    pub self (args : YmirArguments)
        with _args = args
    {
        for i in args.fversion {
            global::state::instance ():.addVersion (i.(std::conv::to)![c8] ());
        }
        
        for d in args.includes {
            global::state::instance ():.addIncludeDir (d.(std::conv::to)![c8] ());
        }

        if (args.debug) {
            global::state::instance ():.activateDebug ();
        }
    }    

    /***
     * ============================================================================
     * ============================================================================
     * =========================          PARSING        ==========================
     * ============================================================================
     * ============================================================================
     */

    /**
     * Parse the files requested by the arguments given to the parser
     * @returns:
     *    - the generators created by validation process
     */
    pub fn parseAll (mut self)-> [&Generator]
        throws &ErrorMsg
    {
        let dmut rets = Vec!{&Generator}::new ();
        for f in self._args.files {
            let gens = self:.parseFile (Path::new (f));
            for g in gens {
                rets:.push (g);
            }
        }

        rets[]
    }
        
    
    /**
     * Parse a given file
     * @params: 
     *  - file: the path of the file
     */
    prv fn parseFile (mut self, file : &Path)-> [&Generator]
        throws &ErrorMsg
    {
        let modSynt = SyntaxVisitor::new (file):.read ();
        let dmut declarator = Declarator::new (file.parent ());
        let dmut modSym = declarator:.declareGlobal (modSynt);

        if (global::state::instance ().isImportDumping ()) {
            self.dumpSymbolTree (modSym, file.addExtension ("syms"s8));
        }

        let dmut valid = Validator::new (alias declarator);
        valid:.validate (alias modSym);
        
        let gens = valid.getGenerators ();
        if (global::state::instance ().isYmirDumping ()) {
            self.dumpGenerators (gens, file.addExtension ("sem"s8));
        }
        gens
    } catch {
        err : &ErrorMsg => throw err;
        _ : &FsError => {
            throw ErrorMsg::fatal (EOF_WORD, format (DeclareErrorMessage::NO_SUCH_FILE, file.toStr ()), oneLine-> true);
        }
    }

    /**
     * Dump the semantic generators to an output file
     * @params:
     *    - gens: the generators to dump
     *    - output: the path to the file in which result is outputted
     * */
    prv fn dumpGenerators (self, gens : [&Generator], output : &Path) {
        let dmut stream = Formatter::new ();
        stream:.withVarIds (false);
        for i in gens {
            stream:.write (i, '\n'c8);
        }
        {
            with dmut f = File::create (output, write-> true) {
                f:.write (stream[]);
            }
        } catch {
            _ => {}
        }
    }

    /**
     * Dump the imported modules from the current module into 'output' file
     * @params:
     *    - sym: the module being compiled
     *    - output: the path of the file in which import tree is dumped
     * */
    prv fn dumpSymbolTree (self, sym : &Symbol, output : &Path) {
        let dmut stream = Formatter::new ();
        stream:.withVarIds (false);
        sym.formatSymbolTree (alias stream);
        with dmut f = File::create (output, write-> true) {
            f:.write (stream[]);
        } catch {
            _ => {}
        }
    }

    /***
     * ============================================================================
     * ============================================================================
     * =========================          GETTERS        ==========================
     * ============================================================================
     * ============================================================================
     */

    
    
    
}
