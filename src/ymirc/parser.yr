in parser;

use ymirc::syntax::{_, declaration::_, expression::_};
use ymirc::errors::_;
use ymirc::args;
use ymirc::utils::_;

use ymirc::lexing::{lexer, word};
use ymirc::lint::{expander::visitor,
                  optimizer::visitor,
                  serialize::export,
                  node::_};

use ymirc::semantic::{doc::visitor,
                      declarator::errors,
                      declarator::visitor,
                      validator::visitor,
                      generator,
                      symbol};

use std::{fs::_, env, io, conv};


/**
 * The main class of the ymirc compiler
 * This class perform the different parsing step of the compilation, and gives the result to the backend
 */
@final
pub class Parser {

    // Options passed to the parser
    let _args : YmirArguments;

    // The syntaxic node read during syntax step
    let mut _syntNode : &Declaration = EMPTY_BLOCK_DECL;

    // The list of generators created during validation
    let mut _semGenerators : [&Generator] = [];

    // The list of generator created after expansion / finalization
    let mut _expNodes : [&YILNode] = [];

    // The list of complex types created during expansion
    let mut _expTypes : [&YILType] = [];

    /**
     * Create an empty file parser
     */
    pub self (args : YmirArguments)
        with _args = args
    {
        if (args.fdump) {
            global::state::instance ():.activateYmirDumping ();
        }

        for i in args.fversion {
            global::state::instance ():.addVersion (i.(std::conv::to)![c8] ());
        }
        
        for d in args.includes {
            global::state::instance ():.addIncludeDir (d.(std::conv::to)![c8] ());
        }

        if (args.debug) {
            global::state::instance ():.activateDebug ();
        }
    }    

    /*!
     * ============================================================================
     * ============================================================================
     * =========================          GETTERS        ==========================
     * ============================================================================
     * ============================================================================
     */

    /**
     * @returns: the syntaxic node read during parsing
     * */
    pub fn getSyntaxModule (self)-> &Declaration {
        self._syntNode
    }

    /**
     * @returns: the list of generators after validation before optimization
     * */
    pub fn getSemGenerators (self)-> [&Generator] {
        self._semGenerators
    }

    /**
     * @returns: the list of generators nodes after expansion
     * */
    pub fn getExpYILNodes (self)-> [&YILNode] {
        self._expNodes
    }

    /**
     * @returns: the list of types generated after expansion
     * */
    pub fn getExpYILTypes (self)-> [&YILType] {
        self._expTypes
    }

    /*!
     * ============================================================================
     * ============================================================================
     * =========================          PARSING        ==========================
     * ============================================================================
     * ============================================================================
     */

    /**
     * Parse the files requested by the arguments given to the parser
     * @returns:
     *    - the generators created by validation process
     */
    pub fn parseAll (mut self)
        throws ErrorMsg
    {
        let mut path = Path (self._args.file);
        let mut package = path.parent ();
        if (!path.isAbsolute ()) {
            path = env::currentDir ().push (path);
            package = path.parent ();
        }

        global::state::instance ():.setPackage (package);
        global::state::instance ():.setRootModule (path);
        self:.parsePackage (path);
    }

    /**
     * Parse a given file
     * @params: 
     *  - file: the path of the file
     */
    fn parsePackage (mut self, file : Path)
        throws ErrorMsg
    {
        logging::info ("Compile package %", file.toStr ());
        let s1 = self:.syntaxStep (file);
        self._syntNode = s1;

        let (modules, s2) = self:.validationStep (file, s1);
        self._semGenerators = s2;

        let (s3, s4) = self:.expansionStep (file, modules, s2);
        self._expNodes = s3;
        self._expTypes = s4;
    }

    /*!
     * ============================================================================
     * ============================================================================
     * =========================          SYNTAX        ===========================
     * ============================================================================
     * ============================================================================
     */


    /**
     * Syntax read of the module root file
     * @params:
     *    - file: the file to read
     * @returns: the module declaration contained in the file
     * @throws:
     *    - &ErrorMsg: if there are syntaxic errors
     * */
    fn syntaxStep (mut self, file : Path)-> &ModuleDecl
        throws ErrorMsg
    {
        (copy SyntaxVisitor (file)):.read ()
    } catch {
        err : &ErrorMsg => throw err;
        _ : &FsError => {
            throw copy ErrorMsg::fatal (EOF_WORD, format (DeclareErrorMessage::NO_SUCH_FILE, file.toStr ()), oneLine-> true);
        }
    }

    /*!
     * ============================================================================
     * ============================================================================
     * =======================          VALIDATION        =========================
     * ============================================================================
     * ============================================================================
     */

    /**
     * Validate a module (declaration of symbols, and type validation)
     * @params:
     *     - file: the path of the file in which the module was read
     *     - modSynt: the module to declare and validate
     * @returns:
     *     - .0: the list of validated files
     *     - .1: the list of generators created by the module
     * @throws:
     *     - &ErrorMsg: if there are error during the validation
     * */
    fn validationStep (mut self, file : Path, modSynt : &ModuleDecl)-> ([Path], [&Generator])
        throws ErrorMsg
    {
        if (self._args.noSem) return ([], []);

        let dmut declarator = copy Declarator (packageDir-> file.parent ());
        self:.importExternPackages (alias declarator);

        let dmut modSym = declarator:.declareGlobal (modSynt, global::state::instance ().getPackage ());
        if (global::state::instance ().isYmirDumping ()) {
            {
                let dmut f = File::create (file.addExtension ("ydump-decls.1"), write-> true);
                let dmut formatter = copy Formatter ();
                modSym.formatSymTree (alias formatter);
                f:.write (formatter[]);
            } catch {
                err : &FsError => println( err );
            }
        }

        let dmut valid = copy Validator (alias declarator);
        valid:.validate (alias modSym);

        if (global::state::instance ().isYmirDumping ()) {
            {
                {
                    let dmut f = File::create (file.addExtension ("ydump-decls.2"), write-> true);
                    let dmut formatter = copy Formatter ();
                    modSym.formatSymTree (alias formatter);
                    f:.write (formatter[]);
                }
                {
                    let dmut f = File::create (file.addExtension ("ydump-sem"), write-> true);
                    for i in valid.getGenerators () {
                        f:.write (format ("%\n", i, tags-> FormatTags (withVarIds-> true)));
                    }
                }
            } catch {
                err : &FsError => println( err );
            }
        }

        // Validation succeeded to generate symbols, but some were failing for aside reasons
        if (valid.getMissingGenerators ().len != 0us) {
            throw copy ErrorMsg::list (valid.getMissingGenerators ());
        }

        if (global::state::instance ().isDocDumping ()) {
            {
                let dmut f = File::create (global::state::instance ().getDocDumpFile (), write-> true);
                let dmut docVisitor = DocVisitor (packageDir-> file.parent ());
                let js = docVisitor.dump (modSym);
                f:.write (std::config::json::dump (js));
            } catch {
                err : &FsError => { println (err); }
            }
        }

        return (valid.getCompiledModules (), valid.getGenerators ());
    }

    /**
     * Import a external package imported using the -I option
     * */
    fn importExternPackages (mut self, dmut declarator : &Declarator)
        throws ErrorMsg
    {
        let mut errors : [&ErrorMsg] = [];
        if (!global::state::instance ().isStandalone ()) {
            self:.importExternPackage (alias declarator, global::state::instance ().getCorePath ());
            declarator:.computeCoreUseDecls ();
        } catch {
            err : &ErrorMsg => { errors ~= [err]; }
        }

        for dir in global::state::instance ().getIncludeDirs () {
            {
                self:.importExternPackage (alias declarator, dir);
            } catch {
                err : &ErrorMsg => { errors ~= [err]; }
            }
        }

        {
            declarator:.finalizeExternDeclaration ();
        } catch {
            err : &ErrorMsg => { errors ~= [err]; }
        }

        if (errors.len != 0us) {
            throw copy ErrorMsg::list (errors);
        }
    }

    /**
     * Import the external package at path 'path'
     * */
    fn importExternPackage (mut self, dmut declarator : &Declarator, path : Path)
        throws ErrorMsg
    {
        let (file, pack) = if (fs::sys::isDir (path)) {
            (path.push ("__lib__.yr"), path)
        } else {
            (path, path.parent ())
        };

        logging::info ("Loading external package %", file.toStr ());
        {
            let modSynt = (copy SyntaxVisitor (file)):.read ();
            declarator:.declareExtern (modSynt, pack);
        } catch {
            err : &ErrorMsg => {
                throw copy ErrorMsg::fatal (EOF_WORD, format (DeclareErrorMessage::IMPORT_EXTERN_PACKAGE, path.toStr ()), oneLine-> true, notes-> copy [err]);
            }
            _ : &FsError => {
                throw copy ErrorMsg::fatal (EOF_WORD, format (DeclareErrorMessage::IMPORT_EXTERN_PACKAGE, path.toStr ()), oneLine-> true,
                                            notes-> copy [copy ErrorMsg::fatal (EOF_WORD, format (DeclareErrorMessage::NO_SUCH_FILE, file.toStr ()), oneLine-> true)]);
            }
        }
    }

    /*!
     * ============================================================================
     * ============================================================================
     * =======================          GENERATION        =========================
     * ============================================================================
     * ============================================================================
     */

    /**
     * Expand the generators, by transforming complex values, and instructions into a list of single line instructions
     * It also transforms all the complex operators (Copier, Aliaser, etc.) into simple ones, such that backend does not need to worry about implementations
     * This step is the last before sending the generators to the backend
     * @params:
     *     - file : Path,
     *     - gens: the list of generators to transform
     * @returns: the list of  nodes to send to the backend
     * */
    fn expansionStep (mut self, file : Path, compiled : [Path], gens : [&Generator])-> ([&YILNode], [&YILType])
        throws ErrorMsg        
    {
        if (self._args.noLint) return ([], []);

        let dmut exp = copy Expander ();
        let finals = exp:.finalize (gens);
        let types = exp.getTypes ();

        if (global::state::instance ().isYmirDumping ()) {
            {
                use std::algorithm::sorting;
                let dmut f = File::create (file.addExtension ("ydump-yil"), write-> true);
                for t in sort (copy types, |a, b| => { a.getUniqId () < b.getUniqId () }) {
                    f:.write (format ("%;\n", t, tags-> FormatTags (withParams-> true)));
                }

                for fi in finals {
                    f:.write (format ("%\n", fi, tags-> FormatTags (withVarIds-> true)));
                }
            } catch {
                err : &FsError => println (err);
            }
        }

        if (global::state::instance ().isExportYIL ()) {            
            let mut yilExp = YILExporter (packageDir-> file.parent ());            
            yilExp:.registerTypes (types);                        
            yilExp:.registerSymbols (finals);            
            yilExp:.writeFiles (compiled);
        }
        
        if (global::state::instance ().isDumpDependencies ()) {
            self.writeModuleDependencies (file, compiled, finals);
        }

        (finals, types)
    }

    /**
     * Write the dependencies of the modules in files, and the list of symbol names generated within the module
     * */
    pub fn writeModuleDependencies (self, file : Path, modules : [Path], nodes : [&YILSymbol]) {
        logging::info ("Export module dependencies");
    
        let mut symbols : [[c8] => mut (bool, &YILSymbol)] = copy [];
        let dmut exportSymbols : [Path => [[c8] => ()]] = copy [];
        let dmut exportDeps : [Path => [Path => ()]] = copy [];
        
        let packageDir = file.parent ();

        for sym in nodes {
            symbols [sym.getName ()] = (sym.isWeak (), sym);
        }

        for sym in nodes {
            let loc = sym.getPath ();
            let where = loc.removePrefix (packageDir).stripExtension ();
            let dmut symTable = if let Ok (dmut table) = alias exportSymbols [where] {
                alias table
            } else {
                copy []
            };

            let dmut depTable = if let Ok (dmut table) = alias exportDeps [where] {
                alias table
            } else {
                copy []
            };

            self.addSymbol (sym, packageDir, symbols, alias symTable, alias depTable);
            exportSymbols [where] = alias symTable;
            exportDeps [where] = alias depTable;
        }

        let root = global::state::instance ().getDependencyDumpDir ();        
        if (!fs::sys::isDir (root)) {
            fs::sys::createDir (root);        
        } catch {
            err => {
                logging::failure ("Failed to write dependency file\n\t=>", err);
                return;
            }
        }

        for m in modules {
            if let (Ok (symTable), Ok (depTable)) = (exportSymbols [m], exportDeps [m]) {
                self.produceDependencyFile (root, m, symTable, depTable);
            }
        }
    }

    /**
     * Add a symbol to the dependency graph
     * @params:
     *    - sym: the symbol to add
     *    - allSyms: the list of symbol generated by this compilation
     *    - syms: the symbol table to fill
     *    - deps: the dependency table to fill
     * */
    fn addSymbol (self, sym : &YILSymbol, packageDir : Path, allSyms : [[c8] => (bool, &YILSymbol)], dmut syms : [[c8] => ()], dmut deps : [Path => ()]) {
        if sym.getName () in syms {
            return;
        }
        
        syms [sym.getName ()] = ();
        for s, loc in sym.getReferences () {            
            deps [loc] = ();            
            
            if let Ok (touch) = allSyms [s] {
                if touch._0 {
                    self.addSymbol (touch._1, packageDir, allSyms, alias syms, alias deps);
                }
            }
        }        
    }
    
    /**
     * Produce the dependency tree file listing dependencies between source files
     * */
    fn produceDependencyFile (self, root : Path, module : Path, symTable : [[c8] => ()], depTable : [Path => ()]) {
        {
            {
                let p = root.push (module.toStr (sep-> "_")).addExtension ("deps");
                if (fs::sys::isFile (p)) {
                    fs::sys::removeFile (p);
                }

                let dmut f = File::create (p, write-> true);
                for z in depTable {
                    f:.write (z.addExtension ("yr").toStr ());
                    f:.write ("\n");
                }
            }

            {
                let p = root.push (module.toStr (sep-> "_")).addExtension ("syms");
                if (fs::sys::isFile (p)) {
                    fs::sys::removeFile (p);
                }

                let dmut f = File::create (p, write-> true);            
                for z in symTable {
                    f:.write (z);
                    f:.write ("\n");            
                }
            }
        } catch {
            err => {
                logging::failure ("Failed to write dependency file\n\t=>", err);
                return;
            }
        }
    }

}
