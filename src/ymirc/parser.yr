mod ymirc::parser;
import ymirc::args::_;

import std::io, std::conv;
import ymirc::syntax::_;
import ymirc::errors::_;
import ymirc::utils::_;
import ymirc::lexing::lexer;
import ymirc::lexing::word;

import ymirc::syntax::visitor;
import ymirc::semantic::declarator::visitor;
import ymirc::semantic::validator::visitor;
import ymirc::semantic::optimizer::visitor;

import ymirc::semantic::declarator::errors;
import ymirc::semantic::generator::base;
import ymirc::semantic::symbol::base;

import std::time::_;
import std::fs::_;
import std::env;
import std::collection::vec;



/**
 * The main class of the ymirc compiler
 * This class perform the different parsing step of the compilation, and gives the result to the backend
 */
pub class Parser {

    let _args : YmirArguments;
    
    /**
     * Create an empty file parser
     */
    pub self (args : YmirArguments)
        with _args = args
    {
        for i in args.fversion {
            global::state::instance ():.addVersion (i.(std::conv::to)![c8] ());
        }
        
        for d in args.includes {
            global::state::instance ():.addIncludeDir (d.(std::conv::to)![c8] ());
        }

        if (args.debug) {
            global::state::instance ():.activateDebug ();
        }
    }    

    /***
     * ============================================================================
     * ============================================================================
     * =========================          PARSING        ==========================
     * ============================================================================
     * ============================================================================
     */

    /**
     * Parse the files requested by the arguments given to the parser
     * @returns:
     *    - the generators created by validation process
     */
    pub fn parseAll (mut self)-> [&Generator]
        throws &ErrorMsg
    {
        let mut path = Path::new (self._args.file);
        if (!path.isAbsolute ()) {
            path = env::currentDir ().push (path);
        }

        self:.parsePackage (path)
    }
        
    
    /**
     * Parse a given file
     * @params: 
     *  - file: the path of the file
     */
    prv fn parsePackage (mut self, file : &Path)-> [&Generator]
        throws &ErrorMsg
    {
        let modSynt = SyntaxVisitor::new (file):.read ();
        let dmut declarator = Declarator::new (packageDir-> file.parent ());
        self:.importExternPackages (alias declarator);

        let dmut modSym = declarator:.declareGlobal (modSynt);

        let dmut valid = Validator::new (alias declarator);
        valid:.validate (alias modSym);

        if (global::state::instance ().isYmirDumping ()) {
            {
                with dmut f = File::create (file.addExtension ("ydump"s8), write-> true) {
                    for i in valid.getGenerators () {
                        f:.write (format ("%\n", i));
                    }
                }
            } catch {
                err : &FsError => println( err );
            }
        }

        let dmut optim = Optimizer::new ();
        let finals = optim:.optimize (valid.getGenerators ());

        if (global::state::instance ().isYmirDumping ()) {
            {
                with dmut f = File::create (file.addExtension ("ydump-opt"s8), write-> true) {
                    for i in finals {
                        f:.write (format ("%\n", i));
                    }
                }
            } catch {
                err : &FsError => println( err );
            }
        }

        finals
    } catch {
        err : &ErrorMsg => throw err;
        _ : &FsError => {
            throw ErrorMsg::fatal (EOF_WORD, format (DeclareErrorMessage::NO_SUCH_FILE, file.toStr ()), oneLine-> true);
        }
    }

    /**
     * Import a external package imported using the -I option
     * */
    prv fn importExternPackages (mut self, dmut declarator : &Declarator)
        throws &ErrorMsg
    {
        let dmut errors = Vec!{&ErrorMsg}::new ();
        if (!global::state::instance ().isStandalone ()) {
            self:.importExternPackage (alias declarator, global::state::instance ().getCorePath ());
            declarator:.computeCoreUseDecls ();
        } catch {
            err : &ErrorMsg => errors:.push (err);
        }

        for dir in global::state::instance ().getIncludeDirs () {
            {
                self:.importExternPackage (alias declarator, dir);
            } catch {
                err : &ErrorMsg => errors:.push (err);
            }
        }

        if (errors.len () != 0us) {
            throw ErrorMsg::list (errors[]);
        }
    }

    /**
     * Import the external package at path 'path'
     * */
    prv fn importExternPackage (mut self, dmut declarator : &Declarator, path : &Path)
        throws &ErrorMsg
    {
        let file = if (fs::sys::isDir (path)) {
            path.push ("__lib__.yr"s8)
        } else {
            path
        };

        let modSynt = SyntaxVisitor::new (file):.read ();
        declarator:.declareExtern (modSynt);
    } catch {
        err : &ErrorMsg => {
            throw ErrorMsg::fatal (EOF_WORD, format (DeclareErrorMessage::IMPORT_EXTERN_PACKAGE, path), oneLine-> true, notes-> [err]);
        }
        _ : &FsError => {
            throw ErrorMsg::fatal (EOF_WORD, format (DeclareErrorMessage::IMPORT_EXTERN_PACKAGE, path), oneLine-> true,
                                   notes-> [ErrorMsg::fatal (EOF_WORD, format (DeclareErrorMessage::NO_SUCH_FILE, path.toStr ()), oneLine-> true)]);
        }
    }

}
