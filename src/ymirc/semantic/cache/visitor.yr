mod ymirc::semantic::cache::visitor;

import ymirc::syntax::declaration::_;
import ymirc::syntax::expression::_;

import ymirc::semantic::generator::_;
import ymirc::semantic::symbol::_;
import ymirc::semantic::validator::template::mapper;

import ymirc::lexing::word;
import ymirc::errors::_;
import ymirc::utils::_;
import ymirc::semantic::cache::errors;

import std::fs::_;
import std::env;
import std::io;
import std::hash;
import std::config::_;

/**
 * Cache class that read and dump cache, to allow diff validation
 * and avoid recompiling every symbols at each ne compilation
 * */
pub class @final Cache {

    /// The path to the package being compiled
    let _packageDir : &Path;

    /// The path to the target directory containing the cache
    let _targetDir : &Path;

    /// The root symbol of the package
    let dmut _package : &Symbol;

    /**
     * @params:
     *    - packageDir: the path to the package being compiled
     *    - package: the root symbol of the package
     * */
    pub self (packageDir : &Path, dmut package : &Symbol)
        with
        _packageDir = packageDir,
        _package = alias package,
        _targetDir = if (packageDir.isAbsolute ()) {
            packageDir.push (".target"s8)
        } else {
            env::currentDir ().push (packageDir).push (".target"s8)
        }
    {}

    /**
     * ================================================================================
     * ================================================================================
     * =========================             DIFF             =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Load the current cache, and update the list of symbols that have to be validated
     * Also adds the generators to the symbols that are not different from last validation
     * And insert weak symbols, that are dependencies from syntax symbols, that are not yet validated (i.e. templates)
     * @params:
     *    - package: the root symbol of the package
     * */
    pub fn load (mut self) {
    }

    /**
     * =================================================================================
     * =================================================================================
     * =========================          DUMP SYMBOLS         =========================
     * =================================================================================
     * =================================================================================
     */

    /**
     * Dump a new cache directory with updated generators and list of symbols
     * */
    pub fn dump (mut self)
        throws &ErrorMsg
    {
        {
            if (fs::sys::isDir (self._targetDir)) {
                fs::sys::removeDir (self._targetDir, recursive-> true);
            }
            fs::sys::createDir (self._targetDir);
        } catch {
            err : &FsError => {
                throw ErrorMsg::warn (EOF_WORD, format (CacheErrorMessage::DIR_CREATION, self._targetDir.toStr ()), oneLine-> true,
                    notes-> [ErrorMsg::note (EOF_WORD, format ("%", err), oneLine-> true)]);
            }
        }

        self:.dump (self._package);
    }

    /**
     * Dump the symbol into cache
     * @params:
     *    - sym: the symbol to dump
     * */
    fn dump (mut self, sym : &Symbol) {
        match sym {
            aka :  &AkaSymbol              => self:.dumpAka (aka);
            ctor : &ConstructorSymbol      => self:.dumpCtor (ctor);
            c :    &ClassSymbol            => self:.dumpClass (c);
            dtor : &DestructorSymbol       => self:.dumpDtor (dtor);
            en :   &EnumSymbol             => self:.dumpEnum (en);
            f :    &FunctionSymbol         => self:.dumpFunc (f);
            g :    &GlobalSymbol           => self:.dumpGlb (g);
            m :    &ModuleSymbol           => self:.dumpMod (m);
            st :   &StructSymbol           => self:.dumpStruct (st);
            tr :   &TraitSymbol            => self:.dumpTrait (tr);
            EmptySymbol ()            => {}
            _ => {
                println ("TODO : ", sym::typeinfo.name);
                __pragma!panic ();
            }
        }
    }

    /**
     * Dump an aka symbol cache
     * @params:
     *    - aka: the aka symbol to dump
     * */
    fn dumpAka (mut self, aka : &AkaSymbol) {
        aka;
    }

    /**
     * Dump a constructor symbol cache
     * @params:
     *    - ctor: the constructor symbol to dump
     * */
    fn dumpCtor (mut self, ctor : &ConstructorSymbol) {
        ctor;
    }

    /**
     * Dump a destructor symbol cache
     * @params:
     *    - dtor: the destructor symbol to dump
     * */
    fn dumpDtor (mut self, dtor : &DestructorSymbol) {
        dtor;
    }

    /**
     * Dump a class symbol cache
     * @params:
     *    - cl: the class symbol to dump
     * */
    fn dumpClass (mut self, cl : &ClassSymbol) {
        cl;
    }

    /**
     * Dump an enum symbol cache
     * @params:
     *    - en: the enum symbol to dump
     * */
    fn dumpEnum (mut self, en : &EnumSymbol) {
        en;
    }

    /**
     * Dump a function symbol cache
     * @params:
     *    - f: the function symbol to dump
     * */
    fn dumpFunc (mut self, f : &FunctionSymbol) {
        let syntProto = f.getContent ().getFunctionProto ();
        let hStr = format ("%", format ("%", syntProto).hash ());

        let name = self._targetDir.push (f.getPath ().addExtension (hStr));
        sys::createDir (name, recursive-> true);

        {
            let synt = f.getContent ().serialize ();
            with dmut file = File::create (name.push ("synt.bin"), write-> true) {
                file:.writeBytes (synt);
            }
        }
        {
            let gens = f.getLocalGenerators ();
            for i in 0us .. gens.len {
                let conf = gens [i].serialize ();
                with dmut file = File::create (name.push (format ("%.gen.bin", i)), write-> true) {
                    file:.writeBytes (conf);
                }
            }
        }
    } catch {
        FsError () => {}
    }

    /**
     * Dump a global symbol cache
     * @params:
     *     - gl: the global symbol to dump
     * */
    fn dumpGlb (mut self, gl : &GlobalSymbol) {
        gl;

    }

    /**
     * Dump a module symbol cache
     * @params:
     *    - m: the module symbol to dump
     * */
    fn dumpMod (mut self, m : &ModuleSymbol) {
        if (m.getPath ().toStr () != ""s8) {
            let name = self._targetDir.push (m.getPath ());
            sys::createDir (name, recursive-> true);
        } catch {
            _ : &FsError => {}
        }

        for sym in m.getAllLocalSymbols (protection-> Protection::PRIVATE) {
            self:.dump (sym);
        }
    } 

    /**
     * Dump a structure symbol into cache
     * @params:
     *    - s: the struct symbol to dump
     * */
    fn dumpStruct (mut self, s : &StructSymbol) {
        s;

    }

    /**
     * Dump a trait symbol into cache
     * @params:
     *    - tr: the symbol to dump
     * */
    fn dumpTrait (mut self, tr : &TraitSymbol) {
        tr;
    }


}
