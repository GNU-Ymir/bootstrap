mod ymirc::semantic::cache::visitor;

import ymirc::syntax::declaration::_;
import ymirc::syntax::expression::_;

import ymirc::semantic::generator::_;
import ymirc::semantic::symbol::_;

import ymirc::lexing::word;
import ymirc::errors::_;
import ymirc::utils::_;
import ymirc::semantic::cache::errors;

import std::fs::_;
import std::io;

/**
 * Cache class that read and dump cache, to allow diff validation
 * and avoid recompiling every symbols at each ne compilation
 * */
pub class @final Cache {

    /// The path to the package being compiled
    let _packageDir : &Path;

    /// The root symbol of the package
    let dmut _package : &Symbol;

    /**
     * @params:
     *    - packageDir: the path to the package being compiled
     *    - package: the root symbol of the package
     * */
    pub self (packageDir : &Path, dmut package : &Symbol)
        with _packageDir = packageDir, _package = alias package
    {}

    /**
     * ================================================================================
     * ================================================================================
     * =========================             DIFF             =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Load the current cache, and update the list of symbols that have to be validated
     * Also adds the generators to the symbols that are not different from last validation
     * And insert weak symbols, that are dependencies from syntax symbols, that are not yet validated (i.e. templates)
     * @params:
     *    - package: the root symbol of the package
     * */
    pub fn load (mut self) {
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================             DUMP             =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Dump a new cache directory with updated generators and list of symbols
     * */
    pub fn dump (mut self)
        throws &ErrorMsg
    {
        let dirPath = self._packageDir.push (".target");
        if (!fs::sys::isDir (dirPath)) {
            fs::sys::createDir (dirPath);
        } catch {
            err : &FsError => {
                throw ErrorMsg::warn (EOF_WORD, format (CacheErrorMessage::DIR_CREATION, dirPath.toStr ()), oneLine-> true,
                    notes-> [ErrorMsg::note (EOF_WORD, format ("%", err), oneLine-> true)]);
            }
        }

        match ref self._package {
            dmut aka : &AkaSymbol => {
                self:.dump (alias aka);
            }
            dmut ctor : &ConstructorSymbol => {
                self:.dump (alias ctor);
            }
            dmut c : &ClassSymbol => {
                self:.dump (alias c);
            }
            dmut dtor : &DestructorSymbol => {
                self:.dump (alias dtor);
            }
            dmut en : &EnumSymbol => {
                self:.dump (alias en);
            }
            dmut f : &FunctionSymbol => {
                self:.dump (alias f);
            }
            dmut g : &GlobalSymbol => {
                self:.dump (alias g);
            }
            dmut m : &ModuleSymbol => {
                self:.dump (alias m);
            }
            dmut st : &StructSymbol => {
                self:.dump (alias st);
            }
            dmut tr : &TraitSymbol => {
                self:.dump (alias tr);
            }
            EmptySymbol () => {}
            sym : _ => {
                println ("TODO : ", sym::typeinfo.name);
                __pragma!panic ();
            }
        }
    }

    /**
     * Dump an aka symbol cache
     * @params:
     *    - aka: the aka symbol to dump
     * */
    fn dump (mut self, dmut aka : &AkaSymbol) {
        aka;
        __pragma!panic ();
    }

    /**
     * Dump a constructor symbol cache
     * @params:
     *    - ctor: the constructor symbol to dump
     * */
    fn dump (mut self, dmut ctor : &ConstructorSymbol) {
        ctor;
        __pragma!panic ();
    }

    /**
     * Dump a destructor symbol cache
     * @params:
     *    - dtor: the destructor symbol to dump
     * */
    fn dump (mut self, dmut dtor : &DestructorSymbol) {
        dtor;
        __pragma!panic ();
    }

    /**
     * Dump a class symbol cache
     * @params:
     *    - cl: the class symbol to dump
     * */
    fn dump (mut self, dmut cl : &ClassSymbol) {
        cl;
        __pragma!panic ();
    }

    /**
     * Dump an enum symbol cache
     * @params:
     *    - en: the enum symbol to dump
     * */
    fn dump (mut self, dmut en : &EnumSymbol) {
        en;
        __pragma!panic ();
    }

    /**
     * Dump a function symbol cache
     * @params:
     *    - f: the function symbol to dump
     * */
    fn dump (mut self, dmut f : &FunctionSymbol) {
        f;
        __pragma!panic ();
    }

    /**
     * Dump a global symbol cache
     * @params:
     *     - gl: the global symbol to dump
     * */
    fn dump (mut self, gl : &GlobalSymbol) {
        gl;
        __pragma!panic ();
    }

    /**
     * Dump a module symbol cache
     * @params:
     *    - m: the module symbol to dump
     * */
    fn dump (mut self, m : &ModuleSymbol) {
        m;
        __pragma!panic ();
    }

    /**
     * Dump a structure symbol into cache
     * @params:
     *    - s: the struct symbol to dump
     * */
    fn dump (mut self, s : &StructSymbol) {
        s;
        __pragma!panic ();
    }

    /**
     * Dump a trait symbol into cache
     * @params:
     *    - tr: the symbol to dump
     * */
    fn dump (mut self, tr : &TraitSymbol) {
        tr;
        __pragma!panic ();
    }

}
