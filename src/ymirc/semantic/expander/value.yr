mod ymirc::semantic::expander::value;

import ymirc::semantic::expander::visitor;
import ymirc::semantic::expander::type;

import std::collection::map;
import std::collection::vec;
import std::io;

import ymirc::utils::format;
import ymirc::semantic::generator::_;
import ymirc::global::core_;
import ymirc::semantic::expander::stmtlist;
import ymirc::syntax::keys;

import ymirc::lexing::word;
import std::fs::path;

/**
 * The value expander is used to expand values into a list of statements
 */
pub class ValueExpander {

    /**
     * Create an empty value expander
     * */
    pub self () {}

    /**
     * Finalize a value
     * @params:
     *    - context: the context of the expansion
     *    - val: the value to expand
     *    - list: the list of statement to fill
     * @returns: the final value
     * */
    pub fn finalize (self, dmut context : &Expander, val : &Value, dmut list : &StmtList)-> &Value {
        match val {
            b : &BreakValue => { self.finalizeBreak (alias context, b, alias list) }
            n : &NamedValue => { context:.finalizeValue (n.getContent (), alias list) }
            r : &ReturnValue => { self.finalizeReturn (alias context, r, alias list) }
            t : &ThrowValue => { self.finalizeThrow (alias context, t, alias list) }
            v : &VarDeclValue => { self.finalizeVarDecl (alias context, v, alias list) }
            v : &VarRefValue => { self.finalizeVarRef (alias context, v, alias list) }
            s : &ScopeValue => { self.finalizeScope (alias context, s, alias list) }
            l : &LiteralValue => { self.finalizeLiteral (alias context, l, alias list) }
            o : &OperatorValue => { self.finalizeOperator (alias context, o, alias list) }
            c : _ => {
                eprintln (c::typeinfo.name);
                __pragma!panic ();
            }
        }
    }

    /**
     * Finalize a break statement
     * @params:
     *    - context: the context of the finalization
     *    -  b: the break statement to finalize
     * @returns: UNIT_VALUE, break values are never right operands
     * */
    fn finalizeBreak (self, dmut context : &Expander, b : &BreakValue, dmut list : &StmtList)-> &Value {
        let endLabel = context.getLoopExitLabel ();
        let decl = context.getLoopVarRef ();
        if (!decl.isOf!{&UnitValue} ()) {
            let inner = context:.finalizeValue (b.getValue (), alias list);
            list:.append (AffectValue::new (b.getLoc (), decl.getType (), decl, inner));
        }

        list:.append (GotoValue::new (b.getLoc (), endLabel.getUniqId (), endLabel.getName ()));
        UNIT_VALUE
    }

    /**
     * Finalize a return statement
     * @params:
     *    - context: the context of the finalization
     *    - t: the return stmt to finalize
     * @returns: UNIT_VALUE, return values are never right operands
     * */
    fn finalizeReturn (self, dmut context : &Expander, r : &ReturnValue, dmut list : &StmtList)-> &Value {
        match r.getValue () {
            UnitValue () => { return r; }
        }

        let inner = context:.finalizeValue (r.getValue (), alias list);
        list:.append (ReturnValue::new (r.getLoc (), inner));

        UNIT_VALUE
    }

    /**
     * Finalize a throw statement
     * @params:
     *    - t: the throw stmt to finalize
     * @returns: UNIT_VALUE, throw values are never right operands
     * */
    fn finalizeThrow (self, dmut context : &Expander, t : &ThrowValue, dmut list : &StmtList)-> &Value {
        let inner = context:.finalizeValue (t.getValue (), alias list);
        let ti = context:.finalizeValue (t.getTypeInfo (), alias list);
        list:.append (ThrowValue::new (t.getLoc (), inner, ti));

        UNIT_VALUE
    }

    /**
     * Finalize a variable declaration statement
     * @params:
     *    - v: the variable declaration to finalize
     * @returns: UNIT_VALUE, variable decl are never right operands
     * */
    fn finalizeVarDecl (self, dmut context : &Expander, v : &VarDeclValue, dmut list : &StmtList)-> &Value {
        let inner = context:.finalizeValue (v.getValue (), alias list);
        let type = context:.finalizeType (v.getVarType ());

        let ret = VarDeclValue::new (v.getLoc (), type, NONE_VALUE, v.isMutable (), v.isPure (), isCte-> v.isCte ());
        let varref = VarRefValue::new (v.getLoc (), v.getLoc (), type, refId-> ret.getUniqId ());
        list:.append (ret);

        if (!inner.isOf!{&UnitValue} ()) {
            list:.append (AffectValue::new (v.getLoc (), type, varref, inner));
        }

        context:.registerVariable (v.getUniqId (), varref);

        UNIT_VALUE
    }

    /**
     * Finalize a variable reference value
     * @params:
     *   - v: the variable to finalize
     * @returns: a variable reference
     * */
    fn finalizeVarRef (self, dmut context : &Expander, v : &VarRefValue, dmut _ : &StmtList)-> &Value {
        match context.getVariable (v.getUniqId ()) {
            Ok (vref : &Value) => { return vref; }
        };

        let type = context:.finalizeType (v.getType ());
        VarRefValue::new (v.getLoc (),
                          v.getDeclLoc (),
                          type,
                          refId-> v.getRefId ())
    }


    /**
     * =====================================================================================
     * =====================================================================================
     * =========================          SCOPE EXPANSION          =========================
     * =====================================================================================
     * =====================================================================================
     */

    /**
     * Finalize a scope value
     * @params:
     *    - sc: the scope value to finalize
     *    - list: the statement list to fill
     * @returns: the final value of the scope
     * */
    fn finalizeScope (self, dmut context : &Expander, sc : &ScopeValue, dmut list : &StmtList)-> &Value {
        match sc {
            b : &BlockValue => { self.finalizeBlock (alias context, b, alias list) }
            c : &ConditionalValue => { self.finalizeCond (alias context, c, alias list) }
            l : &LoopValue => { self.finalizeLoop (alias context, l, alias list) }
            _ => {
                eprintln (sc::typeinfo.name);
                __pragma!panic ();
            }
        }
    }

    /**
     * Finalize a block of values
     * @params:
     *    - b: the block of values to finalize
     *    - list: the list of statement to fill
     * @returns: the final value of the block if any
     * */
    fn finalizeBlock (self, dmut context : &Expander, b : &BlockValue, dmut list : &StmtList)-> &Value {
        if (b.isSet ()) return self.finalizeSet (alias context, b, alias list);
        let dmut innerList = StmtList::new ();
        context:.enterBlock ();

        let type = context:.finalizeType (b.getType ());
        let var = self.createVarForBlock (b.getLoc (), type, alias list);
        let retVal = self.finalizeSet (alias context, b, alias innerList);

        if (!var.isOf!{&UnitValue} ()) {
            innerList:.append (AffectValue::new (retVal.getLoc (), type, var, retVal));
        }

        context:.exitBlock ();
        list:.append (BlockValue::new (b.getLoc (), VOID_TYPE, innerList[], noValue-> true));

        var
    }

    /**
     * Finalize a set of value
     * @params:
     *    - s: the set of values to finalize
     *    - list: the list of statement to fill
     * @returns: the final value of the set if any
     * */
    fn finalizeSet (self, dmut context : &Expander, s : &BlockValue, dmut list : &StmtList)-> &Value {
        let mut finVal : &Value = UNIT_VALUE;
        for inner in s.getValues () {
            finVal = context:.finalizeValue (inner, alias list);
        }

        finVal
    }

    /**
     * Finalize a branch statement
     * @params:
     *    - c: the conditional statement to finalize
     *    - list: the list of statement to fill
     * @returns: the final value of the condition if any
     * */
    fn finalizeCond (self, dmut context : &Expander, c : &ConditionalValue, dmut list : &StmtList)-> &Value {
        let type = context:.finalizeType (c.getType ());
        let var = self.createVarForBlock (c.getLoc (), type, alias list);

        let test = context:.finalizeValue (c.getTest (), alias list);
        let dmut ifList = StmtList::new ();
        let dmut elseList = StmtList::new ();

        context:.enterBlock ();
        let ifVal = context:.finalizeValue (c.getContent (), alias ifList);
        context:.exitBlock ();

        let mut elseVal : &Value = UNIT_VALUE;
        if (!c.getElse ().isOf!{&UnitValue} ()) {
            context:.enterBlock ();
            elseVal = context:.finalizeValue (c.getElse (), alias elseList);
            context:.exitBlock ();
        }

        if (!var.isOf!{&UnitValue} ()) {
            ifList:.append (AffectValue::new (c.getLoc (), type, var, ifVal));
            if (!elseVal.isOf!{&UnitValue} ()) {
                elseList:.append (AffectValue::new (c.getLoc (), type, var, elseVal));
            }
        }

        self.finalizeCond (c.getLoc (), alias list, test, ifList, elseList);
        var
    }

    /**
     * Create conditional jump structure using the list of instruction of each blocks
     * @params:
     *    - loc: the location of the condition
     *    - list: the list of statement to fill
     *    - test: the test of the conditional
     *    - thenList: the list of statement to execute if the condition is met
     *    - elseList: the list of statement to execute if the condition is not met
     * */
    fn finalizeCond (self, loc : &Word, dmut list : &StmtList, test : &Value, thenList : &StmtList, elseList : &StmtList) {
        let thenLabel = LabelValue::new (loc, format ("then_%", loc.line ()));
        let endLabel = LabelValue::new (loc, format ("end_%", loc.line ()));
        let elseLabel = if (elseList.len () != 0us) {
            LabelValue::new (loc, format ("else_%", loc.line ()))
        } else {
            endLabel
        };

        list:.append (CondJmpValue::new (loc, test,
                                         thenLabel.getUniqId (), thenLabel.getName (),
                                         elseLabel.getUniqId (), elseLabel.getName ()));

        list:.append (thenLabel);
        list:.append (thenList);

        if (elseList.len () != 0us) {
            list:.append (GotoValue::new (loc, endLabel.getUniqId (), endLabel.getName ()));
            list:.append (elseLabel);
            list:.append (elseList);
        }

        list:.append (endLabel);
    }

    /**
     * Finalize a loop statement
     * @params:
     *    - l: the loop statement to finalize
     *    - list: the list of statement to fill
     * @returns: the final value of the loop if any
     * */
    fn finalizeLoop (self, dmut context : &Expander, l : &LoopValue, dmut list : &StmtList)-> &Value {
        if (l.isCteFor ()) {
            self.finalizeCteForLoop (alias context, l, alias list)
        } else {
            self.finalizeClassicLoop (alias context, l, alias list)
        }
    }

    /**
     * Finalize a cte for loop statement
     * @params:
     *    - l: the for loop statement to finalize
     *    - list: the list of statement to fill
     * */
    fn finalizeCteForLoop (self, dmut context : &Expander, l : &LoopValue, dmut list : &StmtList)-> &Value {
        let type = context:.finalizeType (l.getType ());
        let var = self.createVarForBlock (l.getLoc (), type, alias list);

        context:.enterBlock ();
        let endLabel = LabelValue::new (l.getLoc (), format ("end_%", l.getLoc ().line ()));
        context:.enterLoop (var, endLabel);

        let dmut innerList = StmtList::new ();
        let innerValue = context:.finalizeValue (l.getContent (), alias innerList);
        if (!var.isOf!{&UnitValue} () && !l.getContent ().isBreaker ()) {
            innerList:.append (AffectValue::new (l.getLoc (), type, var, innerValue));
        }

        context:.exitLoop ();
        context:.exitBlock ();

        list:.append (innerList);
        list:.append (endLabel);
        var
    }

    /**
     * Finalize a loop with (or without) a test, that is execute at runtime
     * @params:
     *    - l: the loop to finalize
     *    - list: the statement list to fill
     * @returns: the value of the loop if any
     * */
    fn finalizeClassicLoop (self, dmut context : &Expander, l : &LoopValue, dmut list : &StmtList)-> &Value {
        let type = context:.finalizeType (l.getType ());
        let varref = self.createVarForBlock (l.getLoc (), type, alias list);
        let test = context:.finalizeValue (l.getTest (), alias list);

        context:.enterBlock ();
        let dmut loopList = StmtList::new ();
        let endLabel = LabelValue::new (l.getLoc (), format ("end_%", l.getLoc ().line ()));
        context:.enterLoop (varref, endLabel);

        let contentVal = context:.finalizeValue (l.getContent (), alias loopList);
        if (!varref.isOf!{&UnitValue} () && !l.getContent ().isBreaker () && !test.isOf!{&UnitValue} ()) {
            loopList:.append (AffectValue::new (l.getLoc (), type, varref, contentVal));
        }

        context:.exitLoop ();
        context:.exitBlock ();

        let begLabel = LabelValue::new (l.getLoc (), format ("beg_%", l.getLoc ().line ()));
        let testLabel = LabelValue::new (l.getLoc (), format ("test_%", l.getLoc ().line ()));

        if (!l.isDo () && !test.isOf!{&UnitValue} ()) {
            list:.append (GotoValue::new (l.getLoc (), testLabel.getUniqId (), testLabel.getName ()));
        }

        list:.append (begLabel);
        list:.append (loopList);

        if (!test.isOf!{&UnitValue} ()) {
            list:.append (testLabel);
            list:.append (CondJmpValue::new (l.getLoc (), test,
                                             begLabel.getUniqId (), begLabel.getName (),
                                             endLabel.getUniqId (), endLabel.getName ()));
        }

        list:.append (endLabel);
        varref
    }


    /**
     * Create a variable to store a block value
     * @params:
     *    - loc: the location of the creation
     *    - type: the type of the block
     *    - list: the list of stmt to fill
     *    - name: the name of the variable (with two possible formatter, line and column)
     * @returns: a varref or unit value, if the type is empty
     * */
    fn createVarForBlock (self, loc : &Word, type : &Type, dmut list : &StmtList, name : [c8] = "blck_%_%"s8)-> &Value {
        match type {
            VoidType () => { return UNIT_VALUE; }
            NoneType () => { return UNIT_VALUE; }
            _ => {
                let fullName = Word::new (format (name, loc.line (), loc.col ()), loc);
                let blckVar = VarDeclValue::new (fullName, type, NONE_VALUE, false, false);
                list:.append (blckVar);

                return VarRefValue::new (fullName, fullName, type, refId-> blckVar.getUniqId ());
            }
        };
    }

    /**
     * =====================================================================================
     * =====================================================================================
     * ========================          LITERAL EXPANSION          ========================
     * =====================================================================================
     * =====================================================================================
     */

    /**
     * Finalize a literal value
     * @params:
     *    - l: the literal value to finalize
     *    - list: the scope list of statement to fill
     * @returns: the finalized value
     * */
    fn finalizeLiteral (self, dmut context : &Expander, l : &LiteralValue, dmut list : &StmtList)-> &Value {
        match l {
            a : &ArrayValue => { return self.finalizeArray (alias context, a, alias list); }
            a : &ArrayAllocValue => { return self.finalizeArrayAlloc (alias context, a, alias list); }
            t : &TupleValue => { return self.finalizeTuple (alias context, t, alias list); }
            StringValue () => { return l; }
            BoolValue () => { return l; }
            CharValue () => { return l; }
            FakeValue () => { return l; }
            FloatValue () => { return l; }
            IntValue () => { return l; }
            NoneValue () => { return l; }
            NullValue () => { return l; }
            UnitValue () => { return l; }
            _ => {
                eprintln (l::typeinfo.name);
                __pragma!panic ();
            }
        }
    }

    /**
     * Finalize an array value
     * @params:
     *    - a: the array value to finalize
     *    - list: the list of statement to fill
     * @returns: the value
     * */
    fn finalizeArray (self, dmut context : &Expander, a : &ArrayValue, dmut list : &StmtList)-> &Value {
        let dmut res = Vec!{&Value}::new ();
        for i in a.getInners () {
            res:.push (context:.finalizeValue (i, alias list));
        }

        let type = context:.finalizeType (a.getType ());
        ArrayValue::new (a.getLoc (), type, res[])
    }

    /**
     * Finalize an array allocation value
     * @params:
     *     - a: the array allocation to finalize
     *     - list: the list of statement to fill
     * @returns: the value
     * */
    fn finalizeArrayAlloc (self, dmut context : &Expander, a : &ArrayAllocValue, dmut list : &StmtList)-> &Value {
        let inner = context:.finalizeValue (a.getValue (), alias list);
        let len = context:.finalizeValue (a.getLen (), alias list);

        let type = context:.finalizeType (a.getType ());
        ArrayAllocValue::new (a.getLoc (), type, inner, len, dyn-> a.isDynamic ())
    }

    /**
     * Finalize a tuple value
     * @params:
     *    - t: the tuple value to finalize
     *    - list: the list of statement to fill
     * @returns: the value
     * */
    fn finalizeTuple (self, dmut context : &Expander, t : &TupleValue, dmut list : &StmtList)-> &Value {
        let dmut res = Vec!{&Value}::new ();
        for i in t.getInners () {
            res:.push (context:.finalizeValue (i, alias list));
        }

        let type = context:.finalizeType (t.getType ());
        TupleValue::new (t.getLoc (), type, res[])
    }

    /**
     * =====================================================================================
     * =====================================================================================
     * ======================            OPERATOR EXPANSION           ======================
     * =====================================================================================
     * =====================================================================================
     */

    /**
     * Finalize an operator value
     * @params:
     *    - op: the operator to finalize
     *    - list: the list of stmtlist to fill
     * */
    fn finalizeOperator (self, dmut context : &Expander, op : &OperatorValue, dmut list : &StmtList)-> &Value {
        match op {
            a : &AffectValue => { self.finalizeAffect (alias context, a, alias list) }
            c : &CallOperatorValue => { self.finalizeCall (alias context, c, alias list) }
            b : &BinaryOperatorValue => { self.finalizeBinary (alias context, b, alias list) }
            f : &FieldOperatorValue => { self.finalizeField (alias context, f, alias list) }
            s : &SliceOrArrayOperatorValue => { self.finalizeSliceOrArrayOp (alias context, s, alias list) }
            _ => {
                eprintln (op::typeinfo.name);
                __pragma!panic ();
            }
        }
    }

    /**
     * Finalize an affectation operation
     * @params:
     *     - a: the affectation operation to validate
     *     - list: the list of statement to fill
     * @returns: the left operand
     * */
    fn finalizeAffect (self, dmut context : &Expander, a : &AffectValue, dmut list : &StmtList)-> &Value {
        let left = context:.finalizeValue (a.getLeft (), alias list);
        let right = context:.finalizeValue (a.getRight (), alias list);

        let type = context:.finalizeType (left.getType ());
        list:.append (AffectValue::new (a.getLoc (), type, left, right));
        left
    }

    /**
     * Finalize a binary operator value
     * @params:
     *    - b: the binary operator to finalize
     *    - list: the list of statement to fill
     * @returns: the finalized binary
     * */
    fn finalizeBinary (self, dmut context : &Expander, b : &BinaryOperatorValue, dmut list : &StmtList)-> &Value {
        match b {
            bl : &LogicalBinBoolOperatorValue => { return self.finalizeLogicalBool (alias context, bl, alias list); }
            r : &RangeContainValue => { return context:.finalizeValue (r.getCall (), alias list); }
            s : &SpecialMathIntOperatorValue => { return context:.finalizeValue (s.getRealValue (), alias list); }
            f : &SpecialMathFloatOperatorValue => { return context:.finalizeValue (f.getRealValue (), alias list); }
        }

        let left = context:.finalizeValue (b.getLeft (), alias list);
        let right = context:.finalizeValue (b.getRight (), alias list);

        let type = context:.finalizeType (b.getType ());
        BinaryOperatorValue::new (b.getLoc (), type, b.getOperator (), left, right)
    }

    /**
     * Fianlize a logical bool operator
     * @params:
     *    - b: the bool operator to finalize
     *    - list: the list of stmt to fill
     * @returns: the value of the expression
     * */
    fn finalizeLogicalBool (self, dmut context : &Expander, b : &LogicalBinBoolOperatorValue, dmut list : &StmtList)-> &Value {
        let dmut rightList = StmtList::new ();
        let left = context:.finalizeValue (b.getLeft (), alias list);
        let right = context:.finalizeValue (b.getRight (), alias rightList);

        let type = context:.finalizeType (b.getType ());
        let var = self.createVarForBlock (b.getLoc (), type, alias list);
        let dmut ifL = StmtList::new (), dmut ifNL = StmtList::new ();

        if (b.getOperator () == BinaryOperators::DAND) { // if (left) { right } else { left }
            ifL:.append (rightList);
            ifL:.append (AffectValue::new (b.getLoc (), type, var, right));

            ifNL:.append (AffectValue::new (b.getLoc (), type, var, left));
        } else { // operator == ||
            ifL:.append (AffectValue::new (b.getLoc (), type, var, left));

            ifNL:.append (rightList);
            ifNL:.append (AffectValue::new (b.getLoc (), type, var, right));
        };

        self.finalizeCond (b.getLoc (), alias list, left, ifL, ifNL);
        var
    }

    /**
     * =====================================================================================
     * =====================================================================================
     * ========================            FIELD EXPANSION           =======================
     * =====================================================================================
     * =====================================================================================
     */

    /**
     * Finalize a field access value
     * @params:
     *    - f : the field access to finalize
     *    - list: the list of statement to fill
     * @returns: the value of the access
     * */
    fn finalizeField (self, dmut context : &Expander, f : &FieldOperatorValue, dmut list : &StmtList)-> &Value {
        match f {
            c : &ClassFieldAccessValue => { self.finalizeClassFieldAccess (alias context, c, alias list) }
            c : &ClosureFieldAccessValue => { self.finalizeClosureFieldAccess (alias context, c, alias list) }
            s : &StructFieldAccessValue => { self.finalizeStructFieldAccess (alias context, s, alias list) }
            t : &TupleFieldAccessValue => { self.finalizeTupleFieldAccess (alias context, t, alias list) }
            _ => {
                eprintln (f::typeinfo.name);
                __pragma!panic ();
            }
        }
    }

    /**
     * Finalize the access of a field in a class value
     * @params:
     *    - f: the field access to finalize
     *    - list: the list of statement to fill
     * */
    fn finalizeClassFieldAccess (self, dmut context : &Expander, f : &ClassFieldAccessValue, dmut list : &StmtList)-> &Value {
        let cl = context:.finalizeValue (f.getClassInstance (), alias list);
        let type = cl.getType ();
        let retType = context:.finalizeType (f.getType ());

        let clR = DereferencerValue::new (f.getLoc (), type.asOf!{&PointerType} ().getInners ()[0], cl);
        StructFieldAccessValue::new (f.getLoc (), retType, clR, f.getFieldName ())
    }

    /**
     * Finalize the access of a field in a closure value
     * @params:
     *    - f: the field access to finalize
     *    - list: the list of statement to fill
     * */
    fn finalizeClosureFieldAccess (self, dmut context : &Expander, f : &ClosureFieldAccessValue, dmut list : &StmtList)-> &Value {
        let cl = context:.finalizeValue (f.getClosure (), alias list);
        let retType = context:.finalizeType (f.getType ());
        let clR = DereferencerValue::new (f.getLoc (), cl.getType ().asOf!{&PointerType} ().getInners ()[0], cl);

        TupleFieldAccessValue::new (f.getLoc (), retType, clR, f.getFieldIndex ())
    }

    /**
     * Finalize the access of a field in a struct value
     * @params:
     *    - f: the field access to finalize
     *    - list: the list of statement to fill
     * */
    fn finalizeStructFieldAccess (self, dmut context : &Expander, f : &StructFieldAccessValue, dmut list : &StmtList)-> &Value {
        let retType = context:.finalizeType (f.getType ());
        let str = context:.finalizeValue (f.getStruct (), alias list);

        StructFieldAccessValue::new (f.getLoc (), retType, str, f.getFieldName ())
    }

    /**
     * Finalize the access of a field in a tuple value
     * @params:
     *    - f: the field access to finalize
     *    - list: the list of statement to fill
     * */
    fn finalizeTupleFieldAccess (self, dmut context : &Expander, f : &TupleFieldAccessValue, dmut list : &StmtList)-> &Value {
        let retType = context:.finalizeType (f.getType ());
        let str = context:.finalizeValue (f.getTuple (), alias list);

        TupleFieldAccessValue::new (f.getLoc (), retType, str, f.getFieldIndex ())
    }

    /**
     * =====================================================================================
     * =====================================================================================
     * ========================            CALL EXPANSION           ========================
     * =====================================================================================
     * =====================================================================================
     */

    /**
     * Finalize a call operator value
     * @params:
     *    - c: the call operator to validate
     *    - list: the list of statement to fill
     * @returns: the value of the call if any
     * */
    fn finalizeCall (self, dmut context : &Expander, c : &CallOperatorValue, dmut list : &StmtList)-> &Value {
        match context.getVariable (c.getUniqId ()) {
            Ok (u : &Value) => { // The call was already seen and validated
                return u;
            }
        };

        let ctype = context:.finalizeType (c.getType ());
        let varref = self.createVarForBlock (c.getLoc (), ctype, alias list);
        if (!varref.isOf!{&UnitValue} ()) {
            context:.registerVariable (c.getUniqId (), varref);
        }

        let call = match c {
            ca : &CallValue => { self.finalizeSimpleCall (alias context, ctype, ca, alias list) }
            ctor : &CtorCallValue => { self.finalizeCtorCall (alias context, ctype, ctor, alias list) }
            fptr : &FuncPtrCallValue => { self.finalizeFuncPtrCall (alias context, ctype, fptr, alias list) }
            meth : &MethodCallValue => { self.finalizeMethodCall (alias context, ctype, meth, alias list) }
            name : &NameCallValue => { self.finalizeNameCall (alias context, ctype, name, alias list) }
            _ => {
                eprintln (c::typeinfo.name);
                __pragma!panic ();
            }
        };

        if (!varref.isOf!{&UnitValue} ()) {
            list:.append (AffectValue::new (c.getLoc (), varref.getType (), varref, call));
        } else {
            list:.append (call);
        }

        varref
    }

    /**
     * Finalize a simple call value
     * @params:
     *   - c: the call value to finalize
     *   - list: the statement list to fill
     * @returns: the value of the call
     * */
    fn finalizeSimpleCall (self, dmut context : &Expander, retType : &Type, c : &CallValue, dmut list : &StmtList)-> &Value {
        let dmut params = Vec!{&Value}::new ();
        let dmut addParams = Vec!{&Value}::new ();
        for i in c.getParameters () {
            params:.push (context:.finalizeValue (i, alias list));
        }

        for i in c.getAddParameters () {
            addParams:.push (context:.finalizeValue (i, alias list));
        }

        let proto = self.finalizePrototype (alias context, c.getPrototype ());
        CallValue::new (c.getLoc (), retType, proto, params[], addParams-> addParams[])
    }

    /**
     * Finalize a class ctor call value
     * @params:
     *     -
     * */
    fn finalizeCtorCall (self, dmut context : &Expander, retType : &Type, c : &CtorCallValue, dmut list : &StmtList)-> &Value {
        let inst = self.finalizeCtorSelf (alias context, c.getLoc (), retType, c.getType (), c.getCtor ().getInstance (), alias list);

        let dmut params = Vec!{&Value}::new ();
        params:.push (inst);
        for pi in c.getParameters () {
            params:.push (context:.finalizeValue (pi, alias list));
        }
        for pi in c.getAddParameters () {
            params:.push (context:.finalizeValue (pi, alias list));
        }

        let proto = self.finalizePrototype (alias context, c.getCtor ().getPrototype ());
        list:.append (CallValue::new (c.getLoc (), VOID_TYPE, proto, params[]));
        inst
    }

    /**
     * Finalize the creation of a new class instance, that is not constructed but only allocated
     * @params:
     *     - loc: the location of the ctor construction
     *     - retType: the finalize version of the class type
     *     - clType: the ClassPtr version of the type of the class to construct
     *     - inst: the instance value generator (if nonevalue, then call class allocation)
     *     - list: the list to fill
     * @returns: the instance of the class
     * */
    fn finalizeCtorSelf (self, dmut context : &Expander, loc : &Word, retType : &Type, clType : &Type, inst : &Value, dmut list : &StmtList)-> &Value {
        // We gave a value to the ctor
        if (!inst.isOf!{&NoneValue} ())  return context:.finalizeValue (inst, alias list);

        let varref = self.createVarForBlock (loc, retType, alias list, name-> "__self_%"s8);

        let vtableName = Word::new (context:.getMangler ().mangleVtable (clType.asOf!{&ClassPtrType} ().getInner ()), loc);
        let vtableAddr = AddressValue::new (loc, PointerType::new (loc, PointerType::new (loc, VOID_TYPE)),
                                            VarRefValue::new (vtableName, vtableName, PointerType::new (loc, VOID_TYPE), isGlobal-> true, refId-> 0us));


        let callVal = NameCallValue::new (loc, retType, Path::new (CoreNames::YRT_ALLOC_CLASS), [vtableAddr]);
        list:.append (AffectValue::new (loc, retType, varref, callVal));

        varref
    }

    /**
     * Finalize a call to a function pointer
     * @params:
     *    - f: the function pointer to finalize
     *    - list: the list of statement to fill
     * @returns: the call
     * */
    fn finalizeFuncPtrCall (self, dmut context : &Expander, retType : &Type, f : &FuncPtrCallValue, dmut list : &StmtList)-> &Value {
        let fptr = context:.finalizeValue (f.getFuncPtr (), alias list);
        let dmut params = Vec!{&Value}::new ();
        for pi in f.getParameters () {
            params:.push (context:.finalizeValue (pi, alias list));
        }

        FuncPtrCallValue::new (f.getLoc (), retType, fptr, params[])
    }

    /**
     * Finalize a call to a method value
     * @params:
     *     - f: the method call to finalize
     *     - list: the list of statement to fill
     * @returns: the result of the call
     * */
    fn finalizeMethodCall (self, dmut context : &Expander, retType : &Type, f : &MethodCallValue, dmut list : &StmtList)-> &Value {
        let dmut params = Vec!{&Value}::new ();
        let methProto = f.getMethod ();
        let inst = context:.finalizeValue (methProto.getClosure (), alias list);

        params:.push (inst);
        for pi in f.getParameters () {
            params:.push (context:.finalizeValue (pi, alias list));
        }

        for pi in f.getAddParameters () {
            params:.push (context:.finalizeValue (pi, alias list));
        }

        let proto = self.finalizePrototype (alias context, methProto.getPrototype ());
        if (methProto.isDirect ()) {
            CallValue::new (f.getLoc (), retType, proto, params[])
        } else {
            let fptr = self.createVtableAccess (f.getLoc (), inst, proto.getType (), methProto.getVtableIndex ());
            FuncPtrCallValue::new (f.getLoc (), retType, fptr, params[])
        }
    }

    /**
     * Access a method from the vtable of a class instance
     * @params:
     *    - loc: the location of the access
     *    - proto: the proto value, defining the type of the final value
     *    - index: the index of the function in the vtable
     * @returns: the address of the method to call
     * */
    fn createVtableAccess (self, loc : &Word, inst : &Value, type : &Type, index : usize)-> &Value {
        let ptrSize = global::state::instance ().getSizeTypeSize () / 8us;
        let ptrVoid = PointerType::new (loc, VOID_TYPE);

        let derefInst = DereferencerValue::new (loc, inst.getType ().asOf!{&PointerType} ().getInners ()[0], inst);
        let vtableAddr = StructFieldAccessValue::new (loc, ptrVoid, derefInst, "#_vtable"s8);

        // +1us because 0 is the dtor
        let funcInVtableAddr = BinaryOperatorValue::new (loc, ptrVoid, BinaryOperators::PLUS, vtableAddr, int::usize (loc, (index + 1us) * cast!{usize} (ptrSize)));

        DereferencerValue::new (loc, type, funcInVtableAddr)
    }

    /**
     * Finalize a function call where the prototype is just a symbol name
     * @params:
     *    - name: the name call to finalize
     *    - list: the list of statement to fill
     * @returns: the value of the call
     * */
    fn finalizeNameCall (self, dmut context : &Expander, retType : &Type, name : &NameCallValue, dmut list : &StmtList)-> &Value {
        let dmut params = Vec!{&Value}::new ();
        for pi in name.getParameters () {
            params:.push (context:.finalizeValue (pi, alias list));
        }

        NameCallValue::new (name.getLoc (), retType, name.getFunctionName (), params[])
    }

    /**
     * =====================================================================================
     * =====================================================================================
     * ===================            PROTOTYPE VALUE EXPANSION           ==================
     * =====================================================================================
     * =====================================================================================
     */

    /**
     * Finalize a prototype value
     * @params:
     *    - context: the context of the finalization
     *    - proto: the prototype to finalize
     * @returns: the finalized version of the prototype
     * */
    fn finalizePrototype (self, dmut context : &Expander, proto : &PrototypeValue)-> &PrototypeValue {
        context;
        proto;
        __pragma!panic ();
    }

    /**
     * =====================================================================================
     * =====================================================================================
     * =====================            SLICE/ARRAY EXPANSION           ====================
     * =====================================================================================
     * =====================================================================================
     */

    /**
     * Finalize an operator on slice or array operands
     * @params:
     *    - sl: the operator to finalize
     *    - list: the list of statement to fill
     * */
    fn finalizeSliceOrArrayOp (self, dmut context : &Expander, sl : &SliceOrArrayOperatorValue, dmut list : &StmtList)-> &Value {
        context;
        sl;
        list;
        __pragma!panic ();
    }


}
