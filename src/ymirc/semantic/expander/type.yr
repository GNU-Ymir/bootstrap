mod ymirc::semantic::expander::type;

import ymirc::semantic::expander::visitor;
import ymirc::semantic::expander::value;

import std::collection::map;
import std::collection::vec;
import std::io;

import ymirc::utils::format;
import ymirc::semantic::generator::_;
import ymirc::global::core_;
import ymirc::semantic::expander::stmtlist;
import ymirc::syntax::keys;

import ymirc::lexing::word;
import std::fs::path;

/**
 * The type expander is used to expand types into a list of statements
 */
pub class TypeExpander {

    /**
     * Create an empty type expander
     * */
    pub self () {}

    /**
     * Finalize a type
     * @params:
     *    - context: the context of the expansion
     *    - ty: the type to expand
     * @returns: the final type
     * */
    pub fn finalize (self, dmut context : &Expander, ty : &Type)-> &Type {
        match ty {
            b : &NativeType => { self.finalizeNative (alias context, b) }
            c : &CustomType => { self.finalizeCustom (alias context, c) }
            _ => {
                eprintln (ty::typeinfo.name);
                __pragma!panic ();
            }
        }
    }

    /**
     * @returns: the depth of a pointer
     * @example:
     * ================
     * *i32 => 1
     * *(*i32) => 2
     * *(*(*i32)) => 3
     * i32 => 0
     * ================
     * */
    pub fn getPointerDepth (self, ty : &Type)-> usize {
        match ty {
            p : &PointerType => { 1us + self.getPointerDepth (p.getInners ()[0]) }
            _ => { 0us }
        }
    }

    /**
     * =====================================================================================
     * =====================================================================================
     * =========================            NATIVE TYPES           =========================
     * =====================================================================================
     * =====================================================================================
     */

    /**
     * Expand a native type
     * @params:
     *    - context: the context of the expansion
     *    - ty: the type to expand
     * */
    fn finalizeNative (self, dmut context : &Expander, ty : &NativeType)-> &Type {
        match ty {
            BoolType () => { return ty; }
            CharType () => { return ty; }
            FloatType () => { return ty; }
            IntType () => { return ty; }
            VoidType () => { return ty; }
            NoneType () => { return ty; }
            d : &DelegateType => { return self.finalizeDelegate (alias context, d); }
            fptr : &FuncPtrType => { return self.finalizeFuncPtr (alias context, fptr); }
            cmp : &CompoundType => { return self.finalizeCompound (alias context, cmp); }
            _ => {
                eprintln (ty::typeinfo.name);
                __pragma!panic ();
            }
        }
    }

    /**
     * Finalize a delegate type
     * @params:
     *    - context: the context of the expansion
     *    - d: the delegate type to expand
     * */
    fn finalizeDelegate (self, dmut context : &Expander, d : &DelegateType)-> &Type {
        let dmut params = Vec!{&Type}::new ();
        for pi in d.getParameters () {
            params:.push (context:.finalizeType (pi));
        }

        let retType = context:.finalizeType (d.getRetType ());

        let fptr = FuncPtrType::new (d.getLoc (), d.getReferences (), params[], retType);
        let closure = PointerType::new (d.getLoc (), VOID_TYPE);

        TupleType::new (d.getLoc (), [closure, fptr], fieldNames-> [DelegateKeys::CLOSURE, DelegateKeys::FUNC])
    }

    /**
     * Finalize a function pointer type
     * @params:
     *    - context: the context of the finalization
     *    - fptr: the type to finalize
     * */
    fn finalizeFuncPtr (self, dmut context : &Expander, fptr : &FuncPtrType)-> &Type {
        let dmut params = Vec!{&Type}::new ();
        for pi in fptr.getParameters () {
            params:.push (context:.finalizeType (pi));
        }

        let retType = context:.finalizeType (fptr.getRetType ());
        FuncPtrType::new (fptr.getLoc (), fptr.getReferences (), params[], retType)
    }

    /**
     * Finalize a compound type
     * @params:
     *    - context: the context of the finalization
     *    - ty: the type to finalize
     * */
    fn finalizeCompound (self, dmut context : &Expander, ty : &CompoundType)-> &Type {
        match ty {
            a : &ArrayType => { return self.finalizeArray (alias context, a); }
            p : &PointerType => { return self.finalizePointer (alias context, p); }
            r : &RangeType => {  return self.finalizeRange (alias context, r); }
            s : &SliceType => { return self.finalizeSlice (alias context, s); }
            t : &TupleType => { return self.finalizeTuple (alias context, t); }
            _ => {
                eprintln (ty::typeinfo.name);
                __pragma!panic ();
            }
        }
    }

    /**
     * Finalize an array type
     * */
    fn finalizeArray (self, dmut context : &Expander, ty : &ArrayType)-> &Type {
        let inner = context:.finalizeType (ty.getInners ()[0]);
        if (inner is ty.getInners ()[0]) return ty;

        ArrayType::new (ty.getLoc (), inner, ty.getSize ())
    }

    /**
     * Finalize a pointer type
     * */
    fn finalizePointer (self, dmut context : &Expander, ty : &PointerType)-> &Type {
        let inner = context:.finalizeType (ty.getInners ()[0]);
        if (inner is ty.getInners ()[0]) return ty;

        PointerType::new (ty.getLoc (), inner)
    }

    /**
     * Finalize a range type
     * */
    fn finalizeRange (self, dmut context : &Expander, rng : &RangeType)-> &Type {
        let inner = context:.finalizeType (rng.getInners ()[0]);
        let step = context:.finalizeType (rng.getInners ()[1]);
        let contain = BoolType::new (rng.getLoc ());

        TupleType::new (rng.getLoc (), [inner, inner, step, contain],
                        fieldNames-> [RangeKeys::FST, RangeKeys::SCD, RangeKeys::STEP, RangeKeys::CONTAIN])
    }

    /**
     * Finalize a slice type
     * */
    fn finalizeSlice (self, dmut context : &Expander, sl : &SliceType)-> &Type {
        let inner = context:.finalizeType (sl.getInners ()[0]);
        let len = IntType::new (sl.getLoc (), size-> 0u16, signed-> false);

        TupleType::new (sl.getLoc (), [len, PointerType::new (sl.getLoc (), inner)],
                        fieldNames-> [SliceKeys::LEN, SliceKeys::PTR])
    }

    /**
     * Finalize a tuple type
     * */
    fn finalizeTuple (self, dmut context : &Expander, tu : &TupleType)-> &Type {
        let dmut params = Vec!{&Type}::new ();
        for ti in tu.getInners () {
            params:.push (context:.finalizeType (ti));
        }

        TupleType::new (tu.getLoc (), params[], fieldNames-> tu.getFieldNames ())
    }

   /**
     * =====================================================================================
     * =====================================================================================
     * =========================            CUSTOM TYPES           =========================
     * =====================================================================================
     * =====================================================================================
     */

    /**
     * Finalize a custom type
     * */
    fn finalizeCustom (self, dmut context : &Expander, c : &CustomType)-> &Type {
        match c {
            cl : &ClassPtrType => { self.finalizeClassPtr (alias context, cl) }
            en : &EnumType => { self.finalize (alias context, en.getProxy ()) }
            s : &StructType => { self.finalizeStruct (alias context, s) }
            _ => {
                eprintln (c::typeinfo.name);
                __pragma!panic ();
            }
        }
    }

    /**
     * Finalize a class ptr type
     * */
    fn finalizeClassPtr (self, dmut context : &Expander, c : &ClassPtrType)-> &Type {
        let inner = self.finalizeClassRef (alias context, c.getInner ());
        PointerType::new (c.getLoc (), inner)
    }

    /**
     * Finalize a struct type
     * */
    fn finalizeStruct (self, dmut context : &Expander, s : &StructType)-> &Type {
        let dmut params = Vec!{&Type}::new ();
        let dmut names = Vec!{[c8]}::new ();

        for i in s.getFields () match i {
            v : &VarDeclValue => {
                params:.push (context:.finalizeType (v.getVarType ()));
                names:.push (v.getLoc ().str ());
            }
            _ => __pragma!panic ();
        }

        TupleType::new (s.getLoc (), params[], fieldNames-> names[])
    }

    /**
     * =====================================================================================
     * =====================================================================================
     * =======================            TEMPORARY TYPES           ========================
     * =====================================================================================
     * =====================================================================================
     */

    /**
     * Finalize a temporary type (a type that cannot be directly associated to a value, but still describe something)
     * */
    fn finalizeTemporary (self, dmut context : &Expander, t : &TemporaryType)-> &Type {
        match t {
            c : &ClassRefType => { self.finalizeClassRef (alias context, c) }
            _ => {
                eprintln (t::typeinfo.name);
                __pragma!panic ();
            }
        }
    }

    /**
     * Validate a class reference type
     * */
    fn finalizeClassRef (self, dmut context : &Expander, cr : &ClassRefType)-> &Type {
        match context.findClassValidation (cr) {
            Ok (c : &Type) => return c;
        }

        if (context.isInClassValidation (cr)) {
            cast!{&Type} (VOID_TYPE)
        } else {
            context:.enterClassValidation (cr);

            let dmut params = Vec!{&Type}::new ();
            let dmut names = Vec!{[c8]}::new ();

            let ptrVoid = PointerType::new (cr.getLoc (), VOID_TYPE);
            params:.push (ptrVoid);
            names:.push (ClassKeys::VTABLE);
            params:.push (ptrVoid);
            names:.push (ClassKeys::MONITOR);

            for i in cr.getFields () match i {
                v : &VarDeclValue => {
                    params:.push (context:.finalizeType (v.getVarType ()));
                    names:.push (v.getLoc ().str ());
                }
                _ => __pragma!panic ();
            }

            let final : &Type = TupleType::new (cr.getLoc (), params[], fieldNames-> names[]);
            context:.exitClassValidation (cr, final);

            final
        }
    }


}
