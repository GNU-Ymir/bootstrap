mod ymirc::semantic::expander::visitor;


import ymirc::semantic::expander::value;
import ymirc::semantic::expander::type;

import std::collection::map;
import std::collection::vec;
import std::collection::set;
import std::io;

import ymirc::utils::format;
import ymirc::semantic::validator::sizeof_;
import ymirc::semantic::generator::_;

import ymirc::global::core_;
import ymirc::semantic::expander::stmtlist;
import ymirc::syntax::keys;

import ymirc::lexing::word;
import std::fs::path;

/**
 * The expander class simplifies previously validated symbols
 */
pub class Expander {

    /**
     * =====================================================================================
     * =====================================================================================
     * =========================         GLOBAL GENERATORS         =========================
     * =====================================================================================
     * =====================================================================================
     */

    // The list of generators provided by the previous pass (validation)
    let mut _generators : [&Generator] = [];

    // The list of expanded frames (for inlining)
    let dmut _frames : &HashMap!{[c8], &Generator} = HashMap!{[c8], &Generator}::new ();

    // The list of expanded generators
    let dmut _expanded = Vec!{&Generator}::new ();

    // The mangler used to mangle symbol names
    let _mangler = Mangler::new ();

    let dmut _sizeOf = SizeofValidator::new ();

    // The expander responsible for value expansions
    let dmut _valueExpander = ValueExpander::new ();

    // The expander responsible for value expansions
    let dmut _typeExpander = TypeExpander::new ();

    /**
     * =====================================================================================
     * =====================================================================================
     * =========================         FRAME GENERATION         ==========================
     * =====================================================================================
     * =====================================================================================
     */

    // The current scope variable declarations
    let dmut _variables = Vec!{dmut &HashMap!{usize, &Value}}::new ();

    // The current uniq id for the current frame
    let dmut _uniqId = Vec!{usize}::new ();

    // The var in which to put the result of loops (when breaking)
    let dmut _loopVar = Vec!{&Value}::new ();

    // The label to exit the loop
    let dmut _loopLabel = Vec!{&LabelValue}::new ();

    // The list of classes already validated
    let dmut _classValidated = HashMap!{&Path, &Type}::new ();

    // The list of class currently in validation
    let dmut _inClassValidation = HashSet!{&Path}::new ();

    /**
     * =====================================================================================
     * =====================================================================================
     * ==============================         CTORS         ================================
     * =====================================================================================
     * =====================================================================================
     */

    /**
     * Create a new empty expander
     * */
    pub self () {}

    /**
     * Expande a list of generators
     * */
    pub fn finalize (mut self, generators : [&Generator])-> [&Generator] {
        self._generators = generators;
        for gen in self._generators {
            self:.finalize (gen);
        }

        self._expanded[]
    }

    /**
     * Expande a generator
     * */
    pub fn finalize (mut self, gen : &Generator) {
        match gen {
            frame : &FrameGenerator => {
                self:.finalizeFrame (frame);
            }
            cl : &ClassRefType => {
                self:.finalizeClass (cl);
            }
            _ => {
                __pragma!panic ();
            }
        }
    }

    /**
     * =====================================================================================
     * =====================================================================================
     * =========================          FRAME EXPANSION          =========================
     * =====================================================================================
     * =====================================================================================
     */

    /**
     * Expande a frame generator
     * @params:
     *    - frame: the frame to expande
     * */
    pub fn finalizeFrame (mut self, frame : &FrameGenerator) {
        let dmut list = StmtList::new ();
        self:.enterFrame ();
        let _ = self:.finalizeValue (frame.getBody (), alias list);
        self:.exitFrame ();

        let body = if (list.len () == 1us && list[][0].isOf!{&BlockValue} ()) {
            list [][0]
        } else {
            cast!{&Value} (BlockValue::new (frame.getBody ().getLoc (), NONE_TYPE, list[], noValue-> true))
        };

        let name = self._mangler.mangle (frame);
        let final = FrameGenerator::new (frame.getLoc (),
                                         Path::new (name),
                                         frame.getParameters (),
                                         self:.finalizeType (frame.getReturnType ()),
                                         body-> body,
                                         externLang-> frame.getExternalLang (),
                                         isWeak-> frame.isWeak (),
                                         templateMapper-> frame.getTemplateMapper ());

        self._expanded:.push (final);
    }

    /**
     * =====================================================================================
     * =====================================================================================
     * =========================          CLASS EXPANSION          =========================
     * =====================================================================================
     * =====================================================================================
     */

    /**
     * Finalize a class reference type (vtable, and typeinfo)
     * */
    pub fn finalizeClass (mut self, cl : &ClassRefType) {
        let typeinfoValue = self:.finalizeClassTypeInfo (cl);
        let vtableValue = self:.finalizeClassVtable (cl);


        let vtableName = self._mangler.mangleVtable (cl);
        let tiName = self._mangler.mangleTypeInfo (cl);

        // Const VTABLE
        self._expanded:.push (ConstGenerator::new (cl.getLoc (),
                                                   Path::new (vtableName),
                                                   vtableValue,
                                                   isWeak-> cl.getSymbol ().isWeak ()));

        // Const TYPEINFO
        self._expanded:.push (ConstGenerator::new (cl.getLoc (),
                                                   Path::new (tiName),
                                                   typeinfoValue,
                                                   isWeak-> cl.getSymbol ().isWeak ()));
    }

    /**
     * Finalize the typeinfo value of a class type, to write it in the text as a global variable
     * */
    pub fn finalizeClassTypeInfo (mut self, cl : &ClassRefType)-> &Value {
        let dmut list = StmtList::new ();

        let slcType = self:.finalizeType (SliceType::new (cl.getLoc (), VOID_TYPE));
        let ancestorSlice = match cl.getAncestor () {
            anc : &ClassRefType => {
                let ancTIN = Word::new (self._mangler.mangleTypeInfo (anc), cl.getLoc ());
                let ancTIV = AddressValue::new (cl.getLoc (), PointerType::new (cl.getLoc (), VOID_TYPE),
                                                VarRefValue::new (ancTIN, ancTIN, PointerType::new (cl.getLoc (), VOID_TYPE), isGlobal-> true, refId-> 0us));

                let len = int::usize (cl.getLoc (), 1us);
                TupleValue::new (cl.getLoc (), slcType, [len, ancTIV], fieldNames-> [SliceKeys::LEN, SliceKeys::PTR])
            }
            _ => {
                let ancTIV = NullValue::new (cl.getLoc ());
                let len = int::usize (cl.getLoc (), 0us);
                TupleValue::new (cl.getLoc (), slcType, [len, ancTIV], fieldNames-> [SliceKeys::LEN, SliceKeys::PTR])
            }
        };

        let ti = cl.getTypeInfo ().asOf!{&TypeInfoValue} ();
        let id = self:.finalizeValue (ti.getId (), alias list);
        let size = self:.finalizeValue (ti.getSize (), alias list);
        let name = self:.finalizeValue (ti.getName (), alias list);
        let type = self:.finalizeType (ti.getType ());

        // Dynamic objects in the typeinfo
        if (list.len () != 0us) __pragma!panic ();

        TupleValue::new (cl.getLoc (), type, [id, size, ancestorSlice, name])
    }

    /**
     * Finalize the vtable value of a class to write it in the text as a global variable
     * */
    pub fn finalizeClassVtable (mut self, cl : &ClassRefType)-> &Value {
        let len = cl.getVtable ().len + 2us; // TI, Dtor, vtable

        let resultType = ArrayType::new (cl.getLoc (), PointerType::new (cl.getLoc (), VOID_TYPE), int::usize (cl.getLoc (), len));
        let dmut params = Vec!{&Value}::new ();

        let TIN = Word::new (self._mangler.mangleTypeInfo (cl), cl.getLoc ());
        let TIV = AddressValue::new (cl.getLoc (), PointerType::new (cl.getLoc (), VOID_TYPE),
                                     VarRefValue::new (TIN, TIN, PointerType::new (cl.getLoc (), VOID_TYPE), isGlobal-> true, refId-> 0us));
        params:.push (TIV);
        match cl.getDestructor () {
            NoneValue () => {
                params:.push (NullValue::new (cl.getLoc ()));
            }
            p : &PrototypeValue => {
                params:.push (self._valueExpander.finalizePrototype (alias self, p));
            }
            _ => __pragma!panic ();
        };

        for mt in cl.getVtable () {
            params:.push (self._valueExpander.finalizePrototype (alias self, mt));
        }

        ArrayValue::new (cl.getLoc (), resultType, params[])
    }

    /**
     * =====================================================================================
     * =====================================================================================
     * ======================          TYPE/VALUE EXPANSION          =======================
     * =====================================================================================
     * =====================================================================================
     */

    /**
     * Finalize a value
     * @params:
     *    - value: the value to finalize
     * */
    pub fn finalizeValue (mut self, val : &Value, dmut list : &StmtList)-> &Value {
        self._valueExpander:.finalize (alias self, val, alias list)
    }

    /**
     * Finalize a type
     * @params:
     *    - ty: the type to finalize
     * */
    pub fn finalizeType (mut self, ty : &Type)-> &Type {
        self._typeExpander.finalize (alias self, ty)
    }

    /**
     * Compute the size of a type
     * @params:
     *    - ty: the type whose size to compute
     * */
    pub fn computeSize (mut self, ty : &Type)-> usize {
        self._sizeOf:.validateType (EOF_WORD, ty)
    } catch {
        // Here, all types should have size, as they are only expanded types?
        _ => __pragma!panic ();
    }

    /**
     * =====================================================================================
     * =====================================================================================
     * =========================              GETTERS              =========================
     * =====================================================================================
     * =====================================================================================
     */

    /**
     * @returns: the mangler used to mangle symbol names
     * */
    pub fn getMangler (self)-> &Mangler {
        self._mangler
    }

    /**
     * @returns: the expander used to finalize types
     * */
    pub fn getTypeExpander (self)-> &TypeExpander {
        self._typeExpander
    }

    /**
     * =====================================================================================
     * =====================================================================================
     * =========================              CONTEXT              =========================
     * =====================================================================================
     * =====================================================================================
     */

    /**
     * @returns: the declaration of the variable containing the value of the current loop
     * */
    pub fn getLoopVarRef (self)-> &Value {
        self._loopVar [$ - 1us]
    }

    /**
     * @returns: the label exiting the current loop
     * */
    pub fn getLoopExitLabel (self)-> &LabelValue {
        self._loopLabel [$ - 1us]
    }

    /**
     * Enter a loop where varref is the value of the loop
     * */
    pub fn enterLoop (mut self, varref : &Value, lbl : &LabelValue) {
        self._loopVar:.push (varref);
        self._loopLabel:.push (lbl);
    }

    /**
     * Exit a loop context
     * */
    pub fn exitLoop (mut self) {
        self._loopVar:.pop ();
        self._loopLabel:.pop ();
    }  catch {
        _ => __pragma!panic ();
    }

    /**
     * Enter a new frame
     * */
    pub fn enterFrame (mut self) {
        self._uniqId:.push (0us);
    }

    /**
     * Exit the current frame
     * */
    pub fn exitFrame (mut self) {
        self._uniqId:.pop (1u64);
    }

    /**
     * @returns: the next uniq id for a variable in the current frame
     * */
    pub fn generateVarId (mut self)-> usize {
        let id = self._uniqId [$ - 1us];
        (alias self._uniqId) [self._uniqId.len () - 1us] += 1us;
        id
    }

    /**
     * Enter a new scope of variables
     * */
    pub fn enterBlock (mut self) {
        self._variables:.push (HashMap!{usize, &Value}::new ());
    }

    /**
     * Exit a scope of variables
     * */
    pub fn exitBlock (mut self) {
        self._variables:.pop (1u64);
    }

    /**
     * Register a variable declaration in the scope
     * @params:
     *    - old: the uniq id of the previous declaration
     *    - new: the uniq id of the new declaration
     * */
    pub fn registerVariable (mut self, old : usize, vref : &Value) {
        (alias self._variables)[$ - 1us]:.insert (old, vref);
    }

    /**
     * Search the id of a variable declared in the current frame
     * @returns: the id, or None if the variable is not in the frame
     * */
    pub fn getVariable (self, old : usize)-> (&Value)? {
        for i in self._variables {
            match i.find (old) {
                Ok (n : &Value) => { return n?; }
            }
        }

        ((&Value)?)::__err__
    }

    /**
     * =====================================================================================
     * =====================================================================================
     * =========================              TYPE CONTEXT              =========================
     * =====================================================================================
     * =====================================================================================
     */

    /**
     * Find the type of the class if already validated
     * */
    pub fn findClassValidation (self, cr : &ClassRefType)-> (&Type)? {
        self._classValidated.find (cr.getSymbol ().getPath ())
    }

    /**
     * @returns: true if the class is being validated
     * */
    pub fn isInClassValidation (self, cr : &ClassRefType)-> bool {
        cr.getSymbol ().getPath () in self._inClassValidation
    }

    /**
     * Start a finalization of a class type
     * */
    pub fn enterClassValidation (mut self, cr : &ClassRefType) {
        self._inClassValidation:.insert (cr.getSymbol ().getPath ());
    }

    /**
     * Class finalized
     * */
    pub fn exitClassValidation (mut self, cr : &ClassRefType, res : &Type) {
        self._inClassValidation:.remove (cr.getSymbol ().getPath ());
        self._classValidated:.insert (cr.getSymbol ().getPath (), res);
    }

}
