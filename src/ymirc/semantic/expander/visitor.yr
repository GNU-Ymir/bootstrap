mod ymirc::semantic::expander::visitor;


import ymirc::semantic::expander::value;
import ymirc::semantic::expander::type;

import std::collection::map;
import std::collection::vec;
import std::collection::set;
import std::io;

import ymirc::utils::format;
import ymirc::semantic::generator::_;
import ymirc::global::core_;
import ymirc::semantic::expander::stmtlist;
import ymirc::syntax::keys;

import ymirc::lexing::word;
import std::fs::path;

/**
 * The expander class simplifies previously validated symbols
 */
pub class Expander {

    /**
     * =====================================================================================
     * =====================================================================================
     * =========================         GLOBAL GENERATORS         =========================
     * =====================================================================================
     * =====================================================================================
     */

    // The list of generators provided by the previous pass (validation)
    let mut _generators : [&Generator] = [];

    // The list of expanded frames (for inlining)
    let dmut _frames : &HashMap!{[c8], &Generator} = HashMap!{[c8], &Generator}::new ();

    // The list of expanded generators
    let dmut _expanded = Vec!{&Generator}::new ();

    // The mangler used to mangle symbol names
    let _mangler = Mangler::new ();

    // The expander responsible for value expansions
    let dmut _valueExpander = ValueExpander::new ();

    // The expander responsible for value expansions
    let dmut _typeExpander = TypeExpander::new ();

    /**
     * =====================================================================================
     * =====================================================================================
     * =========================         FRAME GENERATION         ==========================
     * =====================================================================================
     * =====================================================================================
     */

    // The current scope variable declarations
    let dmut _variables = Vec!{dmut &HashMap!{usize, &Value}}::new ();

    // The var in which to put the result of loops (when breaking)
    let dmut _loopVar = Vec!{&Value}::new ();

    // The label to exit the loop
    let dmut _loopLabel = Vec!{&LabelValue}::new ();

    // The list of classes already validated
    let dmut _classValidated = HashMap!{&Path, &Type}::new ();

    // The list of class currently in validation
    let dmut _inClassValidation = HashSet!{&Path}::new ();

    /**
     * =====================================================================================
     * =====================================================================================
     * ==============================         CTORS         ================================
     * =====================================================================================
     * =====================================================================================
     */

    /**
     * Create a new empty expander
     * */
    pub self () {}

    /**
     * Expande a list of generators
     * */
    pub fn finalize (mut self, generators : [&Generator])-> [&Generator] {
        self._generators = generators;
        for gen in self._generators {
            self:.finalize (gen);
        }

        self._expanded[]
    }

    /**
     * Expande a generator
     * */
    pub fn finalize (mut self, gen : &Generator) {
        match gen {
            frame : &FrameGenerator => {
                self:.finalizeFrame (frame);
            }
            _ => {
                self._expanded:.push (gen);
            }
        }
    }

    /**
     * =====================================================================================
     * =====================================================================================
     * =========================          FRAME EXPANSION          =========================
     * =====================================================================================
     * =====================================================================================
     */

    /**
     * Expande a frame generator
     * @params:
     *    - frame: the frame to expande
     * */
    pub fn finalizeFrame (mut self, frame : &FrameGenerator) {
        let dmut list = StmtList::new ();
        let _ = self:.finalizeValue (frame.getBody (), alias list);

        let body = if (list.len () == 1us) {
            list [][0]
        } else {
            cast!{&Value} (BlockValue::new (frame.getBody ().getLoc (), NONE_TYPE, list[], noValue-> true))
        };

        let final = FrameGenerator::new (frame.getLoc (),
                                         frame.getName (),
                                         frame.getParameters (),
                                         self:.finalizeType (frame.getReturnType ()),
                                         body-> body,
                                         externLang-> frame.getExternalLang (),
                                         isWeak-> frame.isWeak (),
                                         templateMapper-> frame.getTemplateMapper ());

        self._expanded:.push (final);
    }

    /**
     * =====================================================================================
     * =====================================================================================
     * ======================          TYPE/VALUE EXPANSION          =======================
     * =====================================================================================
     * =====================================================================================
     */

    /**
     * Finalize a value
     * @params:
     *    - value: the value to finalize
     * */
    pub fn finalizeValue (mut self, val : &Value, dmut list : &StmtList)-> &Value {
        self._valueExpander:.finalize (alias self, val, alias list)
    }

    /**
     * Finalize a type
     * @params:
     *    - ty: the type to finalize
     * */
    pub fn finalizeType (mut self, ty : &Type)-> &Type {
        self._typeExpander.finalize (alias self, ty)
    }

    /**
     * =====================================================================================
     * =====================================================================================
     * =========================              GETTERS              =========================
     * =====================================================================================
     * =====================================================================================
     */

    /**
     * @returns: the mangler used to mangle symbol names
     * */
    pub fn getMangler (mut self)-> &Mangler {
        self._mangler
    }

    /**
     * =====================================================================================
     * =====================================================================================
     * =========================              CONTEXT              =========================
     * =====================================================================================
     * =====================================================================================
     */

    /**
     * @returns: the declaration of the variable containing the value of the current loop
     * */
    pub fn getLoopVarRef (self)-> &Value {
        self._loopVar [$ - 1us]
    }

    /**
     * @returns: the label exiting the current loop
     * */
    pub fn getLoopExitLabel (self)-> &LabelValue {
        self._loopLabel [$ - 1us]
    }

    /**
     * Enter a loop where varref is the value of the loop
     * */
    pub fn enterLoop (mut self, varref : &Value, lbl : &LabelValue) {
        self._loopVar:.push (varref);
        self._loopLabel:.push (lbl);
    }

    /**
     * Exit a loop context
     * */
    pub fn exitLoop (mut self) {
        self._loopVar:.pop ();
        self._loopLabel:.pop ();
    }  catch {
        _ => __pragma!panic ();
    }

    /**
     * Enter a new scope of variables
     * */
    pub fn enterBlock (mut self) {
        self._variables:.push (HashMap!{usize, &Value}::new ());
    }

    /**
     * Exit a scope of variables
     * */
    pub fn exitBlock (mut self) {
        self._variables:.pop (1u64);
    }

    /**
     * Register a variable declaration in the scope
     * @params:
     *    - old: the uniq id of the previous declaration
     *    - new: the uniq id of the new declaration
     * */
    pub fn registerVariable (mut self, old : usize, vref : &Value) {
        (alias self._variables)[$ - 1us]:.insert (old, vref);
    }

    /**
     * Search the id of a variable declared in the current frame
     * @returns: the id, or None if the variable is not in the frame
     * */
    pub fn getVariable (self, old : usize)-> (&Value)? {
        for i in self._variables {
            match i.find (old) {
                Ok (n : &Value) => { return n?; }
            }
        }

        ((&Value)?)::__err__
    }

    /**
     * =====================================================================================
     * =====================================================================================
     * =========================              TYPE CONTEXT              =========================
     * =====================================================================================
     * =====================================================================================
     */

    /**
     * Find the type of the class if already validated
     * */
    pub fn findClassValidation (self, cr : &ClassRefType)-> (&Type)? {
        self._classValidated.find (cr.getSymbol ().getPath ())
    }

    /**
     * @returns: true if the class is being validated
     * */
    pub fn isInClassValidation (self, cr : &ClassRefType)-> bool {
        cr.getSymbol ().getPath () in self._inClassValidation
    }

    /**
     * Start a finalization of a class type
     * */
    pub fn enterClassValidation (mut self, cr : &ClassRefType) {
        self._inClassValidation:.insert (cr.getSymbol ().getPath ());
    }

    /**
     * Class finalized
     * */
    pub fn exitClassValidation (mut self, cr : &ClassRefType, res : &Type) {
        self._inClassValidation:.remove (cr.getSymbol ().getPath ());
        self._classValidated:.insert (cr.getSymbol ().getPath (), res);
    }

}
