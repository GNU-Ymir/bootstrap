mod ymirc::semantic::declarator::visitor;

import std::collection::map;
import std::collection::set;
import std::collection::vec;
import std::fs::_;
import std::io;

import ymirc::errors::_;
import ymirc::semantic::declarator::errors;

import ymirc::semantic::symbol::_;
import ymirc::syntax::declaration::_;
import ymirc::syntax::expression::_;
import ymirc::syntax::keys;
import ymirc::lexing::word;
import ymirc::lexing::tokens;
import ymirc::global::common;
import ymirc::global::state;

import ymirc::syntax::visitor;
import ymirc::utils::format;

import std::concurrency::future;


/**
 * The declarator transforms a syntaxic decl element into a symbol tree
 * The nodes of the tree are not validated, and have to be passed to a validator
 */
pub class Declarator {
    
    /// The list of imported modules
    let dmut _imported  = HashMap!{&Path, dmut &Symbol}::new ();
    
    /// The root of all declarations
    let dmut _root = ModuleSymbol::new (EOF_WORD, ""s8, isGlobal-> true);

    /// True iif the symbols that are declarated are templates, this is a toggle variable
    let mut _templateDeclaration = false;

    /**
     * Create a new empty declarator
     */
    pub self () {}


    /**
     * Transform a declaration syntax into a symbol tree
     * @params: 
     *    - root: the root to declare
     * @throws: &ErrorMsg
     */
    pub def declare (mut self, root : &Declaration)-> dmut &Symbol
        throws &ErrorMsg
    {
        let dmut ret = alias self:.declare (root, parent-> alias self._root, protection-> Protection::PUBLIC);
        alias ret
    }

    /**
     * Transform a declaration syntax into a symbol tree
     * @params: 
     *    - root: the root to declare
     * @throws: &ErrorMsg
     */
    pub def declare (mut self, root : &Declaration, dmut parent : &Symbol, protection : Protection = Protection::PRIVATE)-> dmut &Symbol
        throws &ErrorMsg
    {
        match root {
            m : &ModuleDecl => {
                return self:.declareModule (m, alias parent, protection-> protection);
            }
            block : &BlockDecl => {
                for i in block.getDeclarations () {
                    self:.declare (i, alias parent, protection-> block.getProtection ());
                }
                return EmptySymbol::new ();
            }
            im : &ImportDecl => {
                return self:.declareImport (im, alias parent, protection-> protection);
            }
            cl : &ClassDecl => {
                return self:.declareClass (cl, alias parent, protection-> protection);
            }
            t : &TemplateDecl => {
                return self.declareTemplate (t, alias parent, protection-> protection);
            }
            ex : &ExternBlockDecl => {
                return self.declareExternBlock (ex, alias parent, protection-> protection);
            }
            f : &FunctionDecl => {
                return self.declareFunction (f, alias parent, protection-> protection);
            }
            m : &MacroDecl => {
                return self.declareMacro (m, alias parent, protection-> protection);
            }
            s : &StructDecl => {
                return self.declareStruct (s, alias parent, protection-> protection);
            }
            en : &EnumDecl => {
                return self.declareEnum (en, alias parent, protection-> protection);
            }
            ak : &AkaDecl => {
                return self.declareAka (ak, alias parent, protection-> protection);
            }
            tr : &TraitDecl => {
                return self:.declareTrait (tr, alias parent, protection-> protection);
            }
            gl : &GlobalDecl => {
                return self.declareGlobal (gl, alias parent, protection-> protection);
            }
            _ => {
                throw ErrorMsg::fatal (root.getLoc (), DeclareErrorMessage::UNEXPECTED_IN_MODULE);  
            }
        }
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================            MODULE            =========================
     * ================================================================================
     * ================================================================================
     */   

    /**
     * Declare a module (global or not)
     * @params: 
     *   - module: the module to declare
     *   - parent: the parent symbol that is declaring the module
     * @info: self._imported is updated if the module is global, as well a self._root
     */
    def declareModule (mut self, module : &ModuleDecl, dmut parent : &Symbol, protection : Protection = Protection::PRIVATE)-> dmut &Symbol
        throws &ErrorMsg
    {
        let p = match module.getPath () {
            UnitExpr ()        => { Path::new (module.getLoc ().filename ()).stripExtension () }
            EmptyExpression () => { Path::new (module.getLoc ().filename ()).stripExtension () }
            _ => {
                self.toPath (module.getPath ())
            }
        }

        let prt = if (module.isGlobal ()) Protection::PUBLIC else { protection };
        let loc = if (module.isGlobal ()) Word::new (p.file (), module.getLoc ()) else { module.getLoc () }
        let dmut ret = ModuleSymbol::new (loc, module.getComments (), isExtern-> false, isGlobal-> module.isGlobal (), protection-> prt);
       
                              
        if (module.isGlobal ()) {
            self._imported:.insert (p, alias ret);
                        
            let fileLoc = Path::new (module.getLoc ().filename ()).stripExtension ();
            if (!self.isRelativeFrom (p, fileLoc)) {
                match module.getPath () {
                    ptExpr : &PathExpr => {
                        throw ErrorMsg::fatal (ptExpr.getFileLoc (), format (DeclareErrorMessage::WRONG_MODULE_NAME, module.getPath (), p.addExtension (CommonVars::YMIR_EXTENSION).toStr ()));
                    }
                    x : _ => {
                        throw ErrorMsg::fatal (x.getLoc (), format (DeclareErrorMessage::WRONG_MODULE_NAME, module.getPath (), p.addExtension (CommonVars::YMIR_EXTENSION).toStr ()));
                    }
                }
            }

            self:.insertByPath (p, alias ret, alias self._root);            
        } else {
            parent:.insert (alias ret, replace-> false, anonymus-> self._templateDeclaration);            
        }

        if (module.isGlobal () && !state::instance ().isStandalone ()) {
            self:.importAllFilesInDir (alias ret, state::instance ().getCorePath ());
        } catch {
            err : &ErrorMsg => throw err;
            fs : &FsError => {
                throw ErrorMsg::fatal (module.getLoc (), format (DeclareErrorMessage::CORE_DIR_NOT_FOUND, fs));
            }
        }

        for i in module.getDeclarations () {
            self:.declare (i, alias ret);
        }
        
        return alias ret;
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================            IMPORT            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Import all the core files in the current module
     * @params: 
     *  - parent: the symbol in which the importation is made
     */
    def importAllFilesInDir (mut self, dmut parent : &Symbol, root : &Path)
        throws &ErrorMsg, &FsError
    {
        for i in fs::sys::readDir (root) {
            match i {
                f : &FileEntry => {
                    if (f.path.extension () == CommonVars::YMIR_EXTENSION) {
                        let mut filePath = f.path.stripExtension ();
                        let dicPath = Path::new ("core").push (filePath.removePrefix (state::instance ().getCorePath ()));
                        
                        let dmut modO = self._imported:.find (dicPath);
                        let dmut modSym : &Symbol = match ref modO {
                            Ok (dmut m : &Symbol) => { alias m }
                            _ => {
                                let (modDecl, path) = self.readModuleFromImport (EOF_WORD, filePath);
                                filePath = path;
                                
                                alias self:.declare (modDecl)
                            }
                        }

                        parent:.use (filePath, alias modSym, protection-> Protection::PRIVATE);
                    }
                }
                d : &DirEntry => {
                    self:.importAllFilesInDir (alias parent, d.path);
                }
            }
        }
    }
    
    /**
     * Declare an importation statement
     * @params: 
     *   - im: the importation to declare
     *   - parent: the parent of the importation (module that is making the import)
     *   - protection: the protection of the importation
     */
    def declareImport (mut self, im : &ImportDecl, dmut parent : &Symbol, protection : Protection)-> dmut &Symbol
        throws &ErrorMsg
    {
        let mut p = self.toPath (im.getModulePath ());

        {
            let dmut modO = self._imported:.find (p);
            let dmut modSym : &Symbol = match ref modO {
                Ok (dmut m : &Symbol) => { alias m }
                _ => {
                    let (modDecl, path) = self.readModuleFromImport (im.getLoc (), p);
                    p = path;
                    
                    alias self:.declare (modDecl)                    
                }
            }

            if (!im.getAs ().isEof ()) {
                parent:.insertAs (im.getAs ().str (), alias modSym);
            } else {
                parent:.use (p, alias modSym, protection-> protection);
            }
        } catch {
            err : &ErrorMsg => {
                throw ErrorMsg::note (im.getLoc (), format (DeclareErrorMessage::IN_IMPORT, im.getModulePath ()), notes-> [err]);
            }
        }
        
        return EmptySymbol::new ();
    }

    /**
     * Read a module from a file path (search in Include directories, until the file is found)
     * @params: 
     *  - loc: the location of the importation
     *   - path: the relative path of the module
     * @returns: 
     *    - .0: the module syntaxically read
     *    - .1: the path of the file that has been read
     * @throws: 
     *   - &ErrorMsg: Or there is no file, or there is a syntax error inside the file
     */
    def readModuleFromImport (self, loc : &Word, path : &Path)-> (&Declaration, &Path)
        throws &ErrorMsg
    {
        let file_path = path.addExtension (CommonVars::YMIR_EXTENSION);
        {
            if (fs::sys::isFile (file_path)) {
                return (SyntaxVisitor::open (file_path):.read (), file_path);
            } else {
                for dir in global::state::instance ().getIncludeDirs () {
                    let d_file_path = dir.push (file_path);
                    if (fs::sys::isFile (d_file_path)) {
                        return (SyntaxVisitor::open (d_file_path):.read (), d_file_path);
                    }
                }
            }
        } catch {
            err : &ErrorMsg => {
                throw err;
            }
            _ => {
                throw ErrorMsg::note (loc, DeclareErrorMessage::IN_IMPORT, notes-> [
                    ErrorMsg::fatal (loc, format (DeclareErrorMessage::NO_SUCH_FILE, file_path.toStr ()))]);
            }
        }
        
        throw ErrorMsg::fatal (loc, format (DeclareErrorMessage::NO_SUCH_FILE, file_path.toStr ()));
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================            CLASS             =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Declare the symbol of a class
     * @params: 
     *   - cl: the class to declare
     *   - parent: the module that is declaring the class
     *   - protection: the protection of the class
     */
    def declareClass (mut self, cl : &ClassDecl, dmut parent : &Symbol, protection : Protection)-> dmut &Symbol
        throws &ErrorMsg
    {
        let syms = parent.getLocalSymbols (cl.getLoc ().str ());
        for s in syms[] {
            match s {
                ModuleSymbol () => {}
                TemplateSymbol () => {}
                _ => {
                    throw ErrorMsg::fatal (cl.getLoc (),
                                       format (DeclareErrorMessage::SHADOWING_DECL, cl.getLoc ().str ()),
                                       notes-> [ErrorMsg::note (s.getLoc (), ""s8)]);
                }
            }
        }
        
        let (isAbstract, isFinal) = self.validateAbstractFinal (cl.getAttributes ());        
        let dmut clSym = ClassSymbol::new (cl.getLoc (), cl.getComments (), ancestor-> cl.getAncestor (), isAbstract-> isAbstract, isFinal-> isFinal, protection-> protection);
        parent:.insert (alias clSym, replace-> false, anonymus-> self._templateDeclaration);

        for d in cl.getDeclarations () {
            self:.declareInnerClass (d, alias clSym, protection-> Protection::PROTECTED);
        }
        
        alias clSym
    }


    /**
     * Validate the custom attributes of a class definition
     * @params: 
     *   - attributes: the list of custom attributes of the class
     * @returns: 
     *   - .0: isAbstract
     *   - .1: isFinal
     * @throws: 
     *   - ErrorMsg: if (isAbstract && isFinal), or if an attributes is not defined for class
     */
    def validateAbstractFinal (self, attributes : [AttributeWord])-> (bool, bool)
        throws &ErrorMsg
    {
        let mut isAbstract = false, mut isFinal = false;
        let mut abstractLoc = EOF_WORD, mut finalLoc = EOF_WORD;
        for a in attributes {
            match a.attr {
                Attributes::ABSTRACT => {
                    isAbstract = true;
                    abstractLoc = a.loc;
                    if (isFinal) throw ErrorMsg::fatal (a.loc, DeclareErrorMessage::ABSTRACT_AND_FINAL, notes-> [ErrorMsg::note (finalLoc, ""s8)]);
                }
                Attributes::FINAL => {
                    isFinal = true;
                    finalLoc = a.loc;
                    if (isAbstract) throw ErrorMsg::fatal (a.loc, DeclareErrorMessage::ABSTRACT_AND_FINAL, notes-> [ErrorMsg::note (abstractLoc, ""s8)]);
                }
                _ => {
                    throw ErrorMsg::fatal (a.loc, format (DeclareErrorMessage::UNDEFINED_ATTRIBUTE_FOR_CLASS, a.attr));
                }
            }
        }
        
        (isAbstract, isFinal)
    }


    /**
     * Declare the content of a class
     * @params: 
     *   - d: the declaration to transform into symbol
     *   - cl: the class symbol that is filled
     *   - protection: the current protection of the symbol to declare
     */
    pub def declareInnerClass (mut self, current : &Declaration, dmut cl : &ClassSymbol, protection : Protection)
        throws &ErrorMsg
    {
        match current {
            dl : &BlockDecl => {
                for i in dl.getDeclarations () {
                    self:.declareInnerClass (i, alias cl, protection-> dl.getProtection ());
                }
            }
            cstr : &ConstructorDecl => {
                self.declareConstructor (cstr, alias cl, protection-> protection);
            }
            dtor : &DestructorDecl => {
                self.declareDestructor (dtor, alias cl);
            }
            im : &ImplDecl => {
                self:.declareImpl (im, alias cl, protection-> protection);
            }
            gl : &GlobalDecl => {
                self.declareFieldClass (gl, alias cl, protection-> protection);
            }
            t : &TemplateDecl => {
                self.declareTemplate (t, alias cl, protection-> protection);
            }
            c : &CondBlockDecl => {
                self.declareCondBlockClass (c, alias cl);
            }
            wrap : &ExpressionWrapperDecl => {
                self.declareAssertClass (wrap, alias cl);
            }
            im : &ImportDecl => {
                self:.declareImport (im, alias cl, protection-> protection);
            }
            f : &FunctionDecl => {
                self.declareFunction (f, alias cl, protection-> protection);
            }
            _ => {
                throw ErrorMsg::fatal (current.getLoc (), DeclareErrorMessage::UNEXPECTED_IN_CLASS);   
            }
        }
    }

    /**
     * Declare a class constructor
     * @params: 
     *   - cstr: the constructor to declare
     *   - cl: the parent class 
     *   - protection: the protection of the constructor
     */
    def declareConstructor (self, cstr : &ConstructorDecl, dmut cl : &ClassSymbol, protection : Protection)
        throws &ErrorMsg
    {
        let isUnsafe = self.validateUnsafeCtor (cstr.getAttributes ());

        let dmut cstrSym = ConstructorSymbol::new (cstr.getLoc (), cstr.getComments (), cstr, alias cl, protection-> protection, isUnsafe-> isUnsafe);
        cl:.insert (alias cstrSym, replace-> false, anonymus-> self._templateDeclaration);
    }

    /**
     * Declare the destructor of the class
     * @params: 
     *   - dtor: the destructor
     *   - cl: the parent class
     * @throws: 
     *    - &ErrorMsg: if there are multiple destructor
     */
    def declareDestructor (self, dtor : &DestructorDecl, dmut cl : &ClassSymbol)
        throws &ErrorMsg
    {
        match cl.getDestructor () {
            EmptySymbol () => {}
            _ => {
                throw ErrorMsg::fatal (dtor.getLoc (), DeclareErrorMessage::MULTIPLE_DESTRUCTOR,
                                       notes-> [ErrorMsg::note (cl.getDestructor ().getLoc (), ""s8)]);
            }
        }

        let dmut dtorSym = DestructorSymbol::new (dtor.getLoc (), dtor.getComments (), dtor, alias cl);
        cl:.setDestructor (alias dtorSym);        
    }

    /**
     * Validate the custom attributes of a ctor definition
     * @params:
     *    - attributes: the list of custom attributes of the ctor
     * @returns: true if the ctor is unsafe
     * @throws: if an attribute is undefined for ctor
     * */
    def validateUnsafeCtor (self, attributes : [AttributeWord])-> bool
        throws &ErrorMsg
    {
        let mut isUnsafe = false;
        for a in attributes {
            match a.attr {
                Attributes::UNSAFE => { isUnsafe = true; }
                _ => {
                    throw ErrorMsg::fatal (a.loc, format (DeclareErrorMessage::UNDEFINED_ATTRIBUTE_FOR_CTOR, a.attr));
                }
            }
        }

        isUnsafe
    }

    /**
     * Declare an implementation 
     * @params: 
     *   - impl: the implementation to declare
     *   - cl: the parent class
     */
    def declareImpl (mut self, im : &ImplDecl, dmut cl : &ClassSymbol, protection : Protection)
        throws &ErrorMsg
    {
        let dmut implSym = ImplSymbol::new (im.getLoc (), im.getComments (), im, protection-> protection);
        for i in im.getDeclarations () {
            self:.declareInnerImpl (i, alias implSym, alias cl, protection-> Protection::PROTECTED);
        }

        cl:.insert (alias implSym, replace-> false, anonymus-> self._templateDeclaration);
    }

    /**
     * Declare the content of an implementation
     * @params: 
     *   - current: the declaration to transform
     *   - im: the implementation that is being declared
     *   - protection: the protection of the implementation
     */
    def declareInnerImpl (mut self, current : &Declaration, dmut im : &ImplSymbol, dmut cl : &ClassSymbol, protection : Protection)
        throws &ErrorMsg
    {
        match current {
            dl : &BlockDecl => {
                for i in dl.getDeclarations () {
                    self:.declareInnerImpl (i, alias im, alias cl, protection-> dl.getProtection ());
                }
            }
            f : &FunctionDecl => {
                self.declareFunction (f, alias im, protection-> protection);
            }
            wrap : &ExpressionWrapperDecl => {
                self.declareAssertClass (wrap, alias cl);
            }
            imp : &ImportDecl => {
                self:.declareImport (imp, alias cl, protection-> protection);
            }
            _ => {
                throw ErrorMsg::fatal (current.getLoc (), DeclareErrorMessage::UNEXPECTED_IN_IMPL);
            }
        }
    }

    /**
     * Declare a field in a class
     * @params: 
     *   - field: the field to declare
     *   - cl: the class symbol 
     *   - protection: the protection of the field
     */
    def declareFieldClass (self, field : &GlobalDecl, dmut cl : &ClassSymbol, protection : Protection)
    {
        cl:.addField (field.getContent (), field.getComments (), protection-> protection)
    }

    /**
     * Declare an assertion in a class
     * @params: 
     *    - wrap: the assertion to declare
     *    - cl: the class symbol
     */
    def declareAssertClass (self, wrap : &ExpressionWrapperDecl, dmut cl : &ClassSymbol) {
        cl:.addAssertion (wrap.getContent (), wrap.getComments ());
    }
    
    /**
     * Declare a conditional block in a class
     * @params: 
     *    - c: the conditional to declare
     *    - cl: the class symbol
     */
    def declareCondBlockClass (self, c : &CondBlockDecl, dmut cl : &ClassSymbol) {
        cl:.addCondBlock (c);
    }
    
    /**
     * ================================================================================
     * ================================================================================
     * =========================          FUNCTIONS           =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Declare a function declaration
     * @params: 
     *   - func: the function to declare
     *   - parent: the parent of the declaration
     *   - protection: the protection of the declaration
     */
    def declareFunction (self, func : &FunctionDecl, dmut parent : &Symbol, protection : Protection, isExtern : bool = false, lang : [c8] = ""s8)-> dmut &Symbol
        throws &ErrorMsg
    {
        self.validateShadowingFunction (func.getLoc (), parent);
        let (isFinal, isUnsafe_) = self.validateFinalUnsafeFunction (func.getAttributes ());
        let isCVariadic = func.getFunctionProto ().isVariadic ();
        if (isCVariadic && (!isExtern || lang != Keys::CLANG)) {
            throw ErrorMsg::fatal (func.getLoc (), DeclareErrorMessage::DECL_VARIADIC_FUNC);
        }

        let isUnsafe = if (isExtern && lang == Keys::CLANG) {
            true
        } else { isUnsafe_ };
        
        let dmut funcSym = FunctionSymbol::new (func.getLoc (), func.getComments (), func, isOver-> func.isOver (), isFinal-> isFinal, isUnsafe-> isUnsafe, isCVariadic-> isCVariadic, isTest-> false, protection-> protection);
        parent:.insert (alias funcSym, replace-> false, anonymus-> self._templateDeclaration);

        alias funcSym
    }

    /**
     * Validate that the function is not shadowing another declaration of a different type
     * @params: 
     *   - loc: the location of the function decl
     *   - parent: the parent symbol in which the function will be declared
     */
    def validateShadowingFunction (self, loc : &Word, parent : &Symbol)
        throws &ErrorMsg
    {
        let syms = parent.getLocalSymbols (loc.str ());
        for s in syms[] {
            match s {
                FunctionSymbol () => {}
                ModuleSymbol () => {}
                TemplateSymbol () => {}
                _ => {
                    
                    throw ErrorMsg::fatal (loc,
                                           format (DeclareErrorMessage::SHADOWING_DECL, loc.str ()),
                                           notes-> [ErrorMsg::note (s.getLoc (), ""s8)]);
                }
            }
        }
    }

    /**
     * Validate the custom attributes of a function definition
     * @params: 
     *   - attributes: the list of custom attributes of the function
     * @returns: (isFinal, isUnsafe)
     * @throws: 
     *   - ErrorMsg:  if an attributes is not defined for function
     */
    def validateFinalUnsafeFunction (self, attributes : [AttributeWord])-> (bool, bool)
        throws &ErrorMsg
    {
        let mut isFinal = false, mut isUnsafe = false;
        for a in attributes {
            match a.attr {
                Attributes::FINAL => {
                    isFinal = true;
                }
                Attributes::UNSAFE => {
                    isUnsafe = true;
                }
                _ => {
                    throw ErrorMsg::fatal (a.loc, format (DeclareErrorMessage::UNDEFINED_ATTRIBUTE_FOR_FUNCTION, a.attr));
                }
            }
        }
        
        (isFinal, isUnsafe)
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================           TEMPLATE           =========================
     * ================================================================================
     * ================================================================================
     */
    

    /**
     * Declare a template declaration
     * @params: 
     *   - tm: the template to declare
     *   - parent: the parent symbol of the declaration
     *   - protection: the protection of the declaration
     */
    def declareTemplate (self, tm : &TemplateDecl, dmut parent : &Symbol, protection : Protection)-> dmut &Symbol
        throws &ErrorMsg
    {
        self.validateShadowingTemplates (tm.getParameters ());
        let dmut templSym = TemplateSymbol::new (tm.getLoc (), tm.getComments (), tm, protection-> protection);

        parent:.insert (alias templSym, replace-> false, anonymus-> self._templateDeclaration);

        alias templSym
    }

    /**
     * Verify that there is no shadowing in the name of the template parameters
     * @params: 
     *   - params: the template parameters
     */
    def validateShadowingTemplates (self, params : [&Expression])
        throws &ErrorMsg
    {
        if (params.len == 0us) return {}
        for i in 0us .. params.len - 1us {
            for j in i + 1us .. params.len {
                let fst = match params [i] {
                    v : &TemplateVariadicVarExpr => { v.getLoc ().str () }
                    v : &TemplateOfVarExpr => { v.getLoc ().str () }
                    v : &TemplateVarExpr => { v.getLoc ().str () }
                    v : &VarDeclExpr => { v.getLoc ().str () }
                    _ => ""s8
                }
                let shadow = match params [j] {
                    v : &TemplateVariadicVarExpr => { v.getLoc ().str () == fst }
                    v : &TemplateOfVarExpr => { v.getLoc ().str () == fst }
                    v : &TemplateVarExpr => { v.getLoc ().str () == fst }
                    v : &VarDeclExpr => { v.getLoc ().str ()  == fst}
                    _ => { false }
                }
                
                if (shadow) {
                    throw ErrorMsg::fatal (params [j].getLoc (),
                                           format (DeclareErrorMessage::SHADOWING_DECL, params [i].getLoc ().str ()),
                                           notes-> [ErrorMsg::note (params [i].getLoc (), ""s8)]);
                }                
            }
        }
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================          EXTERNAL            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Declare an external language block
     * @params: 
     *   - decl: the block to declare
     *   - parent: the parent module of the declaration
     *   - protection: the protection of the declaration
     */
    def declareExternBlock (self, decl : &ExternBlockDecl, dmut parent : &Symbol, protection : Protection)-> dmut &Symbol
        throws &ErrorMsg
    {
        let path = self.validateSpaceLanguage (decl.getLanguage (), decl.getNamespace ());
        self.declareInnerExternal (decl.getDeclaration (), alias parent, protection-> protection, lang-> decl.getLanguage ().str (), path-> path);        

        return EmptySymbol::new ();
    }

    /**
     * Declare the content of an external block
     * @params: 
     *    - decl: the inner declaration to declare
     *    - parent: the parent of the external block
     *    - protection: the protection of the declaration
     *    - lang: the language of the extern block
     *    - path: the path of the extern block
     */
    def declareInnerExternal (self, decl : &Declaration, dmut parent : &Symbol, protection : Protection, lang : [c8], path : &Path)
        throws &ErrorMsg
    {
        match decl {
            f : &FunctionDecl => {
                let dmut sym = self.declareFunction (f, alias parent, protection-> protection, isExtern-> true, lang-> lang);
                sym:.setExternalLanguage (lang, path);
            }
            bl : &BlockDecl => {
                for i in bl.getDeclarations () {
                    self.declareInnerExternal (i, alias parent, protection-> protection, lang, path);
                }
            }
            glb : &GlobalDecl => {
                let dmut sym = self.declareGlobal (glb, alias parent, protection-> protection, isExtern-> true);
                sym:.setExternalLanguage (lang, path);
            }
            _ => {
                throw ErrorMsg::fatal (decl.getLoc (), DeclareErrorMessage::UNEXPECTED_IN_EXTERN);
            }
        }
    }
    
    /**
     * Verify that the path is empty or applicable for the given language
     * @params: 
     *   - lang: the language of the extern
     *   - space: the namespace of the extern
     */
    def validateSpaceLanguage (self, lang : &Word, space : &Expression)-> &Path
        throws &ErrorMsg
    {
        let (empty, path) = match space {
            UnitExpr () => { (true, Path::new (""s8)) }
            EmptyExpression () => { (true, Path::new (""s8)) }
            _ => {
                (false, self.toPath (space))
            }
        }
        
        if (lang != Keys::CPPLANG && lang != Keys::DLANG && !empty) {
            throw ErrorMsg::fatal (lang, format (DeclareErrorMessage::NAMESPACE_EXTERNAL, lang.str ()),
                                   notes-> [ErrorMsg::note (space.getLoc (), ""s8)]);
        }

        path
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================            MACRO             =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Declare a macro
     * @params: 
     *    - m: the macro to declare
     *    - parent: the parent module of the declaration
     *    - protection: the protection of the declaration
     */
    def declareMacro (self, m : &MacroDecl, dmut parent : &Symbol, protection : Protection)-> dmut &Symbol
        throws &ErrorMsg
    {

        let syms = parent.getLocalSymbols (m.getLoc ().str ());
        for s in syms[] {
            match s {
                ModuleSymbol () => {}
                TemplateSymbol () => {}
                _ => {
                    throw ErrorMsg::fatal (m.getLoc (),
                                           format (DeclareErrorMessage::SHADOWING_DECL, m.getLoc ().str ()),
                                           notes-> [ErrorMsg::note (s.getLoc (), ""s8)]);
                }
            }
        }
        
        let dmut macroSym = MacroSymbol::new (m.getLoc (), m.getComments (), protection-> protection);
        for d in m.getDeclarations () {
            self.declareInnerMacro (d, alias macroSym, protection-> Protection::PROTECTED);
        }

        parent:.insert (alias macroSym, replace-> false, anonymus-> self._templateDeclaration);
        
        alias macroSym
    }

    /**
     * Declare the content of a macro definition
     * @params: 
     *   - decl: the declaration to declare
     *   - m: the parent macro symbol
     *   - protection: the protection of the declaration
     */
    def declareInnerMacro (self, decl : &Declaration, dmut m : &MacroSymbol, protection : Protection)
        throws &ErrorMsg
    {
        match decl {
            bl : &BlockDecl => {
                for d in bl.getDeclarations () {
                    self.declareInnerMacro (d, alias m, protection-> bl.getProtection ());
                }
            }
            ctor : &MacroRuleDecl => {
                if (ctor.isConstructor ()) {
                    let dmut sym = MacroConstructorSymbol::new (ctor.getLoc (), ctor.getComments (), ctor, protection);
                    m:.insert (alias sym, replace-> false, anonymus-> self._templateDeclaration);
                } else {
                    let dmut sym = MacroRuleSymbol::new (ctor.getLoc (), ctor.getComments (), ctor, protection);
                    m:.insert (alias sym, replace-> false, anonymus-> self._templateDeclaration);
                }                
            }
            _ => {
                throw ErrorMsg::fatal (decl.getLoc (), DeclareErrorMessage::UNEXPECTED_IN_MACRO);
            }
        }
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================            STRUCT            =========================
     * ================================================================================
     * ================================================================================
     */


    /**
     * Declare the symbol of a struct
     * @params: 
     *   - st: the struct to declare
     *   - parent: the module that is declaring the struct
     *   - protection: the protection of the struct
     */
    def declareStruct (self, st : &StructDecl, dmut parent : &Symbol, protection : Protection)-> dmut &Symbol
        throws &ErrorMsg
    {
        let syms = parent.getLocalSymbols (st.getLoc ().str ());
        for s in syms[] {
            match s {
                ModuleSymbol () => {}
                TemplateSymbol () => {}
                _ => {
                    throw ErrorMsg::fatal (st.getLoc (),
                                           format (DeclareErrorMessage::SHADOWING_DECL, st.getLoc ().str ()),
                                           notes-> [ErrorMsg::note (s.getLoc (), ""s8)]);
                }
            }
        }
        
        let (isUnion, isPacked) = self.validateUnionPacked (st.getAttributes ());        
        let dmut strSym = StructSymbol::new (st.getLoc (), st.getComments (), st, protection, isUnion-> isUnion, isPacked-> isPacked);
        
        parent:.insert (alias strSym, replace-> false, anonymus-> self._templateDeclaration);
        
        alias strSym
    }

    /**
     * Validate the custom attributes of a struct definition
     * @params: 
     *   - attributes: the list of custom attributes of the struct
     * @returns: 
     *   - .0: isUnion
     *   - .1: isPacker
     * @throws: 
     *   - ErrorMsg: if (isUnion && isPacked), or if an attributes is not defined for struct
     */
    def validateUnionPacked (self, attributes : [AttributeWord])-> (bool, bool)
        throws &ErrorMsg
    {
        let mut isUnion = false, mut isPacked = false;
        let mut unionLoc = EOF_WORD, mut packLoc = EOF_WORD;
        for a in attributes {
            match a.attr {
                Attributes::UNION => {
                    isUnion = true;
                    unionLoc = a.loc;
                    if (isPacked) throw ErrorMsg::fatal (a.loc, DeclareErrorMessage::UNION_AND_PACKED, notes-> [ErrorMsg::note (packLoc, ""s8)]);
                }
                Attributes::PACKED => {
                    isPacked = true;
                    packLoc = a.loc;
                    if (isUnion) throw ErrorMsg::fatal (a.loc, DeclareErrorMessage::UNION_AND_PACKED, notes-> [ErrorMsg::note (unionLoc, ""s8)]);
                }
                _ => {
                    throw ErrorMsg::fatal (a.loc, format (DeclareErrorMessage::UNDEFINED_ATTRIBUTE_FOR_STRUCT, a.attr));
                }
            }
        }
        
        (isUnion, isPacked)
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================             ENUM             =========================
     * ================================================================================
     * ================================================================================
     */


    /**
     * Declare the symbol of a enumeration
     * @params: 
     *   - st: the enum to declare
     *   - parent: the module that is declaring the enum
     *   - protection: the protection of the enum
     */
    def declareEnum (self, en : &EnumDecl, dmut parent : &Symbol, protection : Protection)-> dmut &Symbol
        throws &ErrorMsg
    {
        let syms = parent.getLocalSymbols (en.getLoc ().str ());
        for s in syms[] {
            match s {
                ModuleSymbol () => {}
                TemplateSymbol () => {}
                _ => {
                    throw ErrorMsg::fatal (en.getLoc (),
                                           format (DeclareErrorMessage::SHADOWING_DECL, en.getLoc ().str ()),
                                           notes-> [ErrorMsg::note (s.getLoc (), ""s8)]);
                }
            }
        }
               
        let dmut enSym = EnumSymbol::new (en.getLoc (), en.getComments (), en, protection);        
        parent:.insert (alias enSym, replace-> false, anonymus-> self._templateDeclaration);
        
        alias enSym
    }
    

    /**
     * ================================================================================
     * ================================================================================
     * =========================             AKA              =========================
     * ================================================================================
     * ================================================================================
     */


    /**
     * Declare the symbol of an aka
     * @params: 
     *   - st: the aka to declare
     *   - parent: the module that is declaring the aka
     *   - protection: the protection of the aka
     */
    def declareAka (self, en : &AkaDecl, dmut parent : &Symbol, protection : Protection)-> dmut &Symbol
        throws &ErrorMsg
    {
        let syms = parent.getLocalSymbols (en.getLoc ().str ());
        for s in syms[] {
            match s {
                ModuleSymbol () => {}
                TemplateSymbol () => {}
                _ => {
                    throw ErrorMsg::fatal (en.getLoc (),
                                           format (DeclareErrorMessage::SHADOWING_DECL, en.getLoc ().str ()),
                                           notes-> [ErrorMsg::note (s.getLoc (), ""s8)]);
                }
            }
        }
               
        let dmut enSym = AkaSymbol::new (en.getLoc (), en.getComments (), en, protection);        
        parent:.insert (alias enSym, replace-> false, anonymus-> self._templateDeclaration);
        
        alias enSym
    }


    /**
     * ================================================================================
     * ================================================================================
     * =========================            TRAIT             =========================
     * ================================================================================
     * ================================================================================
     */



    /**
     * Declare an implementation 
     * @params: 
     *   - impl: the implementation to declare
     *   - cl: the parent class
     */
    def declareTrait (mut self, tr : &TraitDecl, dmut parent : &Symbol, protection : Protection)-> dmut &Symbol
        throws &ErrorMsg
    {
        let syms = parent.getLocalSymbols (tr.getLoc ().str ());
        for s in syms[] {
            match s {
                ModuleSymbol () => {}
                TemplateSymbol () => {}
                _ => {
                    throw ErrorMsg::fatal (tr.getLoc (),
                                           format (DeclareErrorMessage::SHADOWING_DECL, tr.getLoc ().str ()),
                                           notes-> [ErrorMsg::note (s.getLoc (), ""s8)]);
                }
            }
        }
        
        let dmut traitSym = TraitSymbol::new (tr.getLoc (), tr.getComments (), tr, protection-> protection);      
        for i in tr.getDeclarations () {
            self:.declareInnerTrait (i, alias traitSym, protection-> Protection::PROTECTED);
        }

        parent:.insert (alias traitSym, replace-> false, anonymus-> self._templateDeclaration);

        alias traitSym
    }

    /**
     * Declare the content of a trait
     * @params: 
     *   - current: the declaration to transform
     *   - tr: the trait that is being declared
     *   - protection: the protection of the declaration inside the trait
     */
    def declareInnerTrait (mut self, current : &Declaration, dmut tr : &TraitSymbol, protection : Protection)
        throws &ErrorMsg
    {
        match current {
            dl : &BlockDecl => {
                for i in dl.getDeclarations () {
                    self:.declareInnerTrait (i, alias tr, protection-> dl.getProtection ());
                }
            }
            f : &FunctionDecl => {
                let sym = self.declareFunction (f, alias tr, protection-> protection);
                if (f.isOver ())
                    throw ErrorMsg::fatal (f.getLoc (), format (DeclareErrorMessage::NOT_OVERRIDE, sym.getPath ().toStr (sep-> Tokens::DCOLON)));
            }
            wrap : &ExpressionWrapperDecl => {
                self.declareAssertTrait (wrap, alias tr);
            }
            imp : &ImportDecl => {
                self:.declareImport (imp, alias tr, protection-> protection);
            }
            _ => {
                throw ErrorMsg::fatal (current.getLoc (), DeclareErrorMessage::UNEXPECTED_IN_TRAIT);
            }
        }
    }

        /**
     * Declare an assertion in a class
     */
    def declareAssertTrait (self, wrap : &ExpressionWrapperDecl, dmut tr : &TraitSymbol) {
        tr:.addAssertion (wrap.getContent (), wrap.getComments ());
    }


    /**
     * ================================================================================
     * ================================================================================
     * =========================            GLOBAL            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Declare a global variable
     * @params: 
     *   - gl: the var to declare
     *   - parent: the parent module declaring the variable
     *   - protection: the protection of the declaration
     */
    def declareGlobal (self, gl : &GlobalDecl, dmut parent : &Symbol, protection : Protection, isExtern : bool = false)-> dmut &Symbol
        throws &ErrorMsg
    {
        let syms = parent.getLocalSymbols (gl.getContent ().getLoc ().str ());
        for s in syms[] {
            match s {
                ModuleSymbol () => {}
                TemplateSymbol () => {}
                _ => {
                    throw ErrorMsg::fatal (gl.getContent ().getLoc (),
                                           format (DeclareErrorMessage::SHADOWING_DECL, gl.getContent ().getLoc ().str ()),
                                           notes-> [ErrorMsg::note (s.getLoc (), ""s8)]);
                }
            }
        }

        if (gl.isStatic () && !isExtern) {
            throw ErrorMsg::fatal (gl.getLoc (), DeclareErrorMessage::DECL_GLOB_STATIC_NON_EXTERN);
        } else if (!gl.isStatic () && isExtern) {
            throw ErrorMsg::fatal (gl.getLoc (), DeclareErrorMessage::DECL_GLOB_LAZY_EXTERN);
        }

        let dmut glSym = GlobalSymbol::new (gl.getContent ().getLoc (), gl.getComments (), gl, protection-> protection);
        parent:.insert (alias glSym, replace-> false, anonymus-> self._templateDeclaration);

        alias glSym
    }
    
    /**
     * ================================================================================
     * ================================================================================
     * =========================          INSERTION           =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Insert a symbol into a module within a given path
     * Create sub modules if needed
     * @params: 
     *   - p: the path of the insertion
     *   - sym: the symbol to insert
     *   - current: the module that will accept the insertion
     */
    def insertByPath (mut self, p : &Path, dmut sym : &Symbol, dmut current : &Symbol, replace : bool = false) {
        if (p.parts ().len == 1us) {
            current:.insert (alias sym, replace-> replace, anonymus-> self._templateDeclaration);
        } else {
            let dmut lst = current:.getLocalSymbols (p.parts ()[0us]);
            let dmut subs = lst:.opIndex ();
            for i in 0us .. subs.len {
                match ref subs [i] {
                    dmut m : &ModuleSymbol => {
                        self:.insertByPath (p.removeRoot (), alias sym, alias m, replace-> replace);
                        return {}
                    }
                }
            }

            let dmut sub = ModuleSymbol::new (Word::new (p.parts ()[0us], sym.getLoc ()), ""s8, isGlobal-> true);
            current:.insert (alias sub, replace-> false, anonymus-> self._templateDeclaration);
            
            self:.insertByPath (p.removeRoot (), alias sym, alias sub, replace-> replace);
        }
    }
    
    
   
    /**
     * ================================================================================
     * ================================================================================
     * =========================            UTILS             =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Transform an expression into a path
     * @returns: a path
     * @panic
     */
    def toPath (self, expr : &Expression)-> &Path {
        match expr {
            p : &PathExpr => {
                p.toStdPath ()
            }
            _ => {
                Path::new (expr.getLoc ().str ())
            }
        }
    }

    /**
     * @returns: true iif toTest is a relative path of from
     */
    def isRelativeFrom (self, toTest : &Path, from : &Path) -> bool {
        if (toTest.parts ().len == 0us) return true;
        if (toTest.parts ().len > from.parts ().len) {
            return false;
        }

        let flen = toTest.parts ().len;
        for i in 0us .. flen  {
            if (from.parts ()[$ - (i + 1us)] != toTest.parts ()[$ - (i + 1us)]) return false;
        }

        return true;
    }


    /**
     * @params:
     *    - template: iif true, all future declaration will be anonymus
     */
    pub def setDeclareTemplate (mut self, template : bool) {
        self._templateDeclaration = template;
    }
    
    /**
     * ================================================================================
     * ================================================================================
     * =========================           GETTERS            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * @returns: the mutable version of a symbol from its immutable address
     * @panic: if the symbol was not declared nor registered by this declarator
     */
    pub def getMutableSymbol (mut self, sym : &Symbol)-> dmut &Symbol {
        let dmut r = self._root:.getMutableSymbol (sym);
        match ref r {
            Ok (dmut v : _) => return alias v;
            _ => { __pragma!panic (); }        
        }
    }
    

    /**
     * ================================================================================
     * ================================================================================
     * =========================        MISCELLANEOUS         =========================
     * ================================================================================
     * ================================================================================
     */

    impl Formattable {

        pub over format (self, dmut stream : &Formatter) {
            self._root.format (alias stream);
        }
    }
    
    
}
