mod ymirc::semantic::declarator::visitor;

import std::collection::map;
import std::collection::set;
import std::fs::path;
import std::io;

import ymirc::errors::_;
import ymirc::semantic::declarator::errors;

import ymirc::semantic::symbol::_;
import ymirc::syntax::declaration::_;
import ymirc::syntax::expression::_;
import ymirc::lexing::word;
import ymirc::global::common;

import ymirc::utils::format;



/**
 * The declarator transforms a syntaxic decl element into a symbol tree
 * The nodes of the tree are not validated, and have to be passed to a validator
 */
pub class Declarator {

    /// The list of imported modules
    let dmut _imported  = HashMap!{&Path, dmut &Symbol}::new ();

    /// The root of all declarations
    let dmut _root = ModuleSymbol::new (EOF_WORD, ""s8, isGlobal-> true);
    
    /**
     * Create a new empty declarator
     */
    pub self () {}


    /**
     * Transform a declaration syntax into a symbol tree
     * @params: 
     *    - root: the root to declare
     * @throws: &ErrorMsg
     */
    pub def declare (mut self, root : &Declaration)-> dmut &Symbol
        throws &ErrorMsg
    {
        alias self:.declare (root, parent-> alias self._root, protection-> Protection::PUBLIC)
    }

    /**
     * Transform a declaration syntax into a symbol tree
     * @params: 
     *    - root: the root to declare
     * @throws: &ErrorMsg
     */
    pub def declare (mut self, root : &Declaration, dmut parent : &Symbol, protection : Protection = Protection::PRIVATE)-> dmut &Symbol
        throws &ErrorMsg
    {
        match root {
            m : &ModuleDecl => {
                return alias self:.declareModule (m, alias alias parent, protection-> protection);
            }
            block : &BlockDecl => {
                for i in block.getDeclarations () {
                    self:.declare (i, alias parent, protection-> block.getProtection ());
                }
                return EmptySymbol::new ();
            }
            _ => {
                println (root::typeinfo.name);
                __pragma!panic ();
            }
        }
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================            MODULE            =========================
     * ================================================================================
     * ================================================================================
     */   

    /**
     * Declare a module (global or not)
     * @params: 
     *   - module: the module to declare
     *   - parent: the parent symbol that is declaring the module
     * @info: self._imported is updated if the module is global, as well a self._root
     */
    def declareModule (mut self, module : &ModuleDecl, dmut parent : &Symbol, protection : Protection = Protection::PRIVATE)-> dmut &Symbol
        throws &ErrorMsg
    {
        let p = match module.getPath () {
            UnitExpr () => { Path::new (module.getLoc ().filename ()).stripExtension () }
            _ => {
                self.toPath (module.getPath ())
            }
        }

        let prt = if (module.isGlobal ()) Protection::PUBLIC else { protection };
        let dmut ret = ModuleSymbol::new (Word::new (p.file (), module.getLoc ()), module.getComments (), isExtern-> false, isGlobal-> module.isGlobal (), protection-> prt);
                              
        if (module.isGlobal ()) {
            self._imported:.insert (p, alias ret);
            let fileLoc = Path::new (module.getLoc ().filename ()).stripExtension ();
            if (!self.isRelativeFrom (p, fileLoc)) {
                throw ErrorMsg::fatal (module.getLoc (), format (DeclareErrorMessage::WRONG_MODULE_NAME, module.getPath (), p.addExtension (CommonVars::YMIR_EXTENSION).toStr ()));
            }

            self:.insertByPath (p, alias ret, alias self._root);
        } else {
            parent:.insert (alias ret, replace-> false);    
        }

        for i in module.getDeclarations () {
            self:.declare (i, alias ret);
        }
        
        return alias ret;
    }


    /**
     * ================================================================================
     * ================================================================================
     * =========================          INSERTION           =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Insert a symbol into a module within a given path
     * Create sub modules if needed
     * @params: 
     *   - p: the path of the insertion
     *   - sym: the symbol to insert
     *   - current: the module that will accept the insertion
     */
    def insertByPath (mut self, p : &Path, dmut sym : &Symbol, dmut current : &Symbol, replace : bool = false) {
        if (p.parts ().len == 1us) {
            current:.insert (alias sym, replace-> replace);
        } else {
            let dmut hash : &mutable::set::HashSet!{dmut &Symbol} = current:.getLocalSymbols (p.parts ()[0us]);
            let dmut subs = hash:.opIndex ();
            for i in 0us .. subs.len {
                match ref subs [i] {
                    dmut m : &ModuleSymbol => {
                        self:.insertByPath (p.removeRoot (), alias sym, alias m, replace-> replace);
                        return {}
                    }
                }
            }

            let dmut sub = ModuleSymbol::new (Word::new (p.parts ()[0us], sym.getLoc ()), ""s8, isGlobal-> true);
            current:.insert (alias sub, replace-> false);
            
            self:.insertByPath (p.removeRoot (), alias sym, alias sub, replace-> replace);
        }
    }
    
    
   
    /**
     * ================================================================================
     * ================================================================================
     * =========================            UTILS             =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Transform an expression into a path
     * @returns: a path
     * @panic
     */
    def toPath (self, expr : &Expression)-> &Path {
        match expr {
            p : &PathExpr => {
                p.toStdPath ()
            }
            _ => {
                Path::new (expr.getLoc ().str ())
            }
        }
    }

    /**
     * @returns: true iif toTest is a relative path of from
     */
    def isRelativeFrom (self, toTest : &Path, from : &Path) -> bool {
        if (toTest.parts ().len == 0us) return true;
        if (toTest.parts ().len > from.parts ().len) {
            return false;
        }

        let flen = toTest.parts ().len;
        for i in 1us .. flen {
            if (from.parts ()[$ - i] != toTest.parts ()[$ - i]) return false;
        }

        return true;
    }
    
    
    
}
