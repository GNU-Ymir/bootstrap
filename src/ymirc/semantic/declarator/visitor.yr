mod ymirc::semantic::declarator::visitor;

import std::collection::map;
import std::collection::set;
import std::collection::vec;
import std::fs::_;
import std::io;

import ymirc::errors::_;
import ymirc::semantic::declarator::errors;

import ymirc::semantic::symbol::_;
import ymirc::syntax::declaration::_;
import ymirc::syntax::expression::_;
import ymirc::syntax::keys;
import ymirc::lexing::word;
import ymirc::lexing::tokens;
import ymirc::global::common;
import ymirc::global::state;
import ymirc::global::core_;

import ymirc::syntax::visitor;
import ymirc::utils::format;

import std::concurrency::future;


/**
 * The declarator transforms a syntaxic decl element into a symbol tree
 * The nodes of the tree are not validated, and have to be passed to a validator
 */
pub class Declarator {

    /// Path to the root directory of the package
    let  _packageDir : &Path;

    /// The root of all declarations
    let dmut _root = ModuleSymbol::new (EOF_WORD, EOF_WORD, ""s8, isGlobal-> true);

    /// The root of all foreign declaration (imported packages)
    let dmut _foreignRoot = ModuleSymbol::new (EOF_WORD, EOF_WORD, ""s8, isGlobal-> true);

    /// The list of core use declaration, to insert in module symbols
    let dmut _coreModules = Vec!{dmut &Symbol}::new ();

    /// The package being declared (root directory)
    let dmut _currentPackDir = Vec!{&Path}::new ();

    /**
     * Create a new empty declarator
     */
    pub self (packageDir : &Path) with
        _packageDir = packageDir
    {}

    /**
     * Transform a declaration syntax into a symbol tree
     * @params: 
     *    - root: the root to declare
     * @throws: &ErrorMsg
     */
    pub fn declareGlobal (mut self, root : &Declaration, packageDir : &Path)-> dmut &Symbol
        throws &ErrorMsg
    {
        self._currentPackDir:.push (packageDir);
        self:.declare (root, parent-> alias self._root, protection-> Protection::PUBLIC);
        self:.finalizeDeclaration (alias self._root);
        alias self._root
    } exit {
        self._currentPackDir:.pop (1u64);
    }

    /**
     * Transform a declaration syntax into a symbol tree, that won't be validated but is accessible during validation
     * @params:
     *    - root: the root to declare
     * @throws: &ErrorMsg
     * */
    pub fn declareExtern (mut self, root : &Declaration, packageDir : &Path)-> dmut &Symbol
        throws &ErrorMsg
    {
        self._currentPackDir:.push (packageDir);
        self:.declare (root, parent-> alias self._foreignRoot, protection-> Protection::PUBLIC);

        alias self._foreignRoot
    } exit {
        self._currentPackDir:.pop (1u64);
    }

    /**
     * Compute the list of use decl to implicitely insert during module declaration
     * This list is the list of core modules computed from the core module tree
     * */
    pub fn computeCoreUseDecls (mut self) {
        let dmut coreMod = (alias (self._foreignRoot:.getLocalSymbols (CoreNames::CORE_MODULE, protection-> Protection::PUBLIC)))[];
        for c in 0us .. coreMod.len {
            match ref coreMod[c] {
                dmut m : &ModuleSymbol => {
                    self:.computeCoreUseDecls (alias self._coreModules, root-> alias m);
                }
            }
        }
    }

    /**
     * Finalize the symbols declared within the extern foreign module
     * */
    pub fn finalizeExternDeclaration (mut self)
        throws &ErrorMsg
    {
        self:.finalizeDeclaration (alias self._foreignRoot);
    }

    /**
     * Transform a declaration syntax into a symbol tree
     * @params: 
     *    - root: the root to declare
     * @throws: &ErrorMsg
     */
    pub fn declare (mut self, root : &Declaration, dmut parent : &Symbol, protection : Protection = Protection::PRIVATE)-> dmut &Symbol
        throws &ErrorMsg
    {
        match root {
            m : &ModuleDecl => {
                return self:.declareModule (m, alias parent, protection-> protection);
            }
            block : &BlockDecl => {
                for i in block.getDeclarations () {
                    // If block is just a set, then protection has no meaning
                    let inProt = if (block.isSet ()) { protection } else { block.getProtection () };
                    self:.declare (i, alias parent, protection-> inProt);
                }
                return EmptySymbol::new ();
            }
            im : &ImportDecl => {
                return self:.declareImport (im, alias parent, protection-> protection);
            }
            cl : &ClassDecl => {
                return self:.declareClass (cl, alias parent, protection-> protection);
            }
            t : &TemplateDecl => {
                return self.declareTemplate (t, alias parent, protection-> protection);
            }
            ex : &ExternBlockDecl => {
                return self.declareExternBlock (ex, alias parent, protection-> protection);
            }
            f : &FunctionDecl => {
                return self.declareFunction (f, alias parent, protection-> protection);
            }
            m : &MacroDecl => {
                return self.declareMacro (m, alias parent, protection-> protection);
            }
            en : &EnumDecl => {
                return self.declareEnum (en, alias parent, protection-> protection);
            }
            ak : &AkaDecl => {
                return self.declareAka (ak, alias parent, protection-> protection);
            }
            tr : &TraitDecl => {
                return self:.declareTrait (tr, alias parent, protection-> protection);
            }
            gl : &GlobalDecl => {
                return self.declareGlobal (gl, alias parent, protection-> protection);
            }
            u : &UseDecl => {
                return self:.declareUse (u, alias parent);
            }
            u : &UnitTestDecl => {
                return self:.declareUnitTest (u, alias parent);
            }
            _ => {
                throw ErrorMsg::fatal (root.getLoc (), DeclareErrorMessage::UNEXPECTED_IN_MODULE);
            }
        }
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================            MODULE            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Declare a module (global or not)
     * @params: 
     *   - module: the module to declare
     *   - parent: the parent symbol that is declaring the module
     * @info: self._imported is updated if the module is global, as well a self._root
     */
    fn declareModule (mut self, module : &ModuleDecl, dmut parent : &Symbol, protection : Protection = Protection::PRIVATE, importLoc : &Word = EOF_WORD)-> dmut &Symbol
        throws &ErrorMsg
    {
        let name = if (module.isGlobal ()) {
            if (module.getPath ().isEof ()) {
                Path::new (module.getLoc ().filename ()).stripExtension ().file ()
            } else {
                module.getPath ().str ()
            }
        } else {
            module.getLoc ().str ()
        };

        let dmut ret = ModuleSymbol::new (Word::new (name, module.getLoc ()), importLoc-> importLoc, module.getComments (), isExtern-> false, isGlobal-> module.isGlobal (), protection-> protection);
        if (module.isGlobal ()) {
            let fileLoc = Path::new (module.getLoc ().filename ()).stripExtension ().file ();
            if (fileLoc != name) {
                throw ErrorMsg::fatal (module.getPath (), format (DeclareErrorMessage::WRONG_MODULE_NAME, module.getPath (), Path::new (name).addExtension (CommonVars::YMIR_EXTENSION).toStr ()));
            }
        }

        // Check wether the module is already imported within the current package
        let already = parent.getLocalSymbols (name, protection-> Protection::PRIVATE);
        for a in already[] {
            match a {
                m : &ModuleSymbol => { // a module with the same name is already present in the referent
                    let dmut notes = Vec!{&ErrorMsg}::new ();
                    if (!importLoc.isEof ()) {
                        notes:.push (ErrorMsg::note (importLoc, format (DeclareErrorMessage::IN_IMPORT, importLoc.str ())));
                    }

                    if (!m.getImportLoc ().isEof ()) {
                        notes:.push (ErrorMsg::note (m.getImportLoc (), format (DeclareErrorMessage::IN_IMPORT, m.getImportLoc ().str ())));
                    } else {
                        notes:.push (ErrorMsg::note (m.getLoc (), DeclareErrorMessage::DECLARED_HERE));
                    }

                    throw ErrorMsg::fatal (ret.getLoc (), format (DeclareErrorMessage::SHADOWING_DECL, ret.getLoc ().str ()), notes-> notes[]);
                }
            }
        }

        parent:.insert (alias ret, replace-> false);

        for i in module.getDeclarations () {
            self:.declare (i, alias ret);
        }
        
        return alias ret;
    }

    /**
     * Declare a use declaration
     * @params:
     *    - use_: the declaration
     *    - parent: the current context
     * */
    fn declareUse (mut self, use_ : &UseDecl, dmut parent : &Symbol)-> dmut &Symbol {
        parent:.insertUse (use_);
        EmptySymbol::new ()
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================            IMPORT            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Declare an importation statement
     * @params: 
     *   - im: the importation to declare
     *   - parent: the parent of the importation (module that is making the import)
     *   - protection: the protection of the importation
     */
    fn declareImport (mut self, im : &ImportDecl, dmut parent : &Symbol, protection : Protection)-> dmut &Symbol
        throws &ErrorMsg
    {
        let packageLoc = self._currentPackDir [$ - 1us];
        let child = packageLoc.push (parent.getPath ().asStdPath ()).push (im.getModuleName ().str ()).addExtension (CommonVars::YMIR_EXTENSION);
        let sibling = packageLoc.push (parent.getPath ().asStdPath ().parent ()).push (im.getModuleName ().str ()).addExtension (CommonVars::YMIR_EXTENSION);

        let dmut referent = alias parent;
        if (fs::sys::isFile (sibling) && fs::sys::isFile (child)) {
            throw ErrorMsg::fatal (im.getModuleName (), format (DeclareErrorMessage::CONFLICT_MODULES, child.toStr (sep-> "/"s8), sibling.toStr (sep-> "/"s8)));
        } else if (!fs::sys::isFile (sibling) && !fs::sys::isFile (child)) {
            throw ErrorMsg::fatal (im.getModuleName (), format (DeclareErrorMessage::NO_SUCH_FILE, child.toStr (sep-> "/"s8), sibling.toStr (sep-> "/"s8)));
        }

        let decl = {
            if (fs::sys::isFile (sibling)) {
                referent = alias parent:.getReferent ();
                SyntaxVisitor::new (sibling):.read ()
            } else {
                SyntaxVisitor::new (child):.read ()
            }
        } catch {
            err : &ErrorMsg => {
                throw err.withNote ([ErrorMsg::note (im.getModuleName (), format (DeclareErrorMessage::IN_IMPORT, im.getModuleName ().str ()))]);
            }
            _ => {
                throw ErrorMsg::fatal (im.getModuleName (), format (DeclareErrorMessage::NO_SUCH_FILE, child.toStr (sep-> "::"s8), sibling.toStr (sep-> "::"s8)),
                                       notes-> [ErrorMsg::note (im.getModuleName (), format (DeclareErrorMessage::IN_IMPORT, im.getModuleName ().str ()))]);
            }
        }

        match decl {
            module : &ModuleDecl => {
                self:.declareModule (module, alias referent, protection-> protection, importLoc-> im.getModuleName ())
            }
            _ => __pragma!panic ();
        }

        return EmptySymbol::new ();
    }

    /**
     * Recursively insert implicit use declaration of the core modules tree
     * */
    fn computeCoreUseDecls (mut self, dmut mods : &Vec!{dmut &Symbol}, dmut root : &Symbol) {
        mods:.push (alias root);
        root:.isCoreModule (true);

        let dmut list = root:.getAllLocalSymbols (protection-> Protection::PRIVATE);
        for i in 0us .. list.len  {
            match ref list [i] {
                dmut m : &ModuleSymbol => {
                    self:.computeCoreUseDecls (alias mods, root-> alias m);
                }
            }
        }
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================            CLASS             =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Declare the symbol of a class
     * @params:
     *   - cl: the class to declare
     *   - parent: the module that is declaring the class
     *   - protection: the protection of the class
     */
    fn declareClass (mut self, cl : &ClassDecl, dmut parent : &Symbol, protection : Protection)-> dmut &Symbol
        throws &ErrorMsg
    {
        let syms = parent.getLocalSymbols (cl.getLoc ().str (), protection-> Protection::PRIVATE);
        for s in syms[] {
            match s {
                ModuleSymbol () => {}
                TemplateSymbol () => {}
                _ => {
                    throw ErrorMsg::fatal (cl.getLoc (),
                                           format (DeclareErrorMessage::SHADOWING_DECL, cl.getLoc ().str ()),
                                           notes-> [ErrorMsg::note (s.getLoc (), ""s8)]);
                }
            }
        }

        let (isAbstract, isFinal) = self.validateAbstractFinal (cl.getLoc (), cl.getAttributes (), cl.isStruct ());
        let dmut clSym = ClassSymbol::new (cl.getLoc (), cl.getComments (), ancestor-> cl.getAncestor (), isAbstract-> isAbstract, isFinal-> isFinal, isMovable-> (cl.isStruct () && !cl.isRecord ()), isStruct-> cl.isStruct (), protection-> protection);
        parent:.insert (alias clSym, replace-> false);

        for d in cl.getDeclarations () {
            self:.declareInnerClass (d, alias clSym, protection-> Protection::PROTECTED);
        }

        alias clSym
    }


    /**
     * Validate the custom attributes of a class definition
     * @params:
     *   - attributes: the list of custom attributes of the class
     * @returns:
     *   - .0: isAbstract
     *   - .1: isFinal
     *   - .2: isMovable
     * @throws:
     *   - ErrorMsg: if (isAbstract && isFinal), or if an attributes is not defined for class
     */
    fn validateAbstractFinal (self, loc : &Word, attributes : [AttributeWord], isStruct : bool)-> (bool, bool)
        throws &ErrorMsg
    {
        let mut isAbstract = false, mut isFinal = false;
        let mut abstractLoc = EOF_WORD, mut finalLoc = EOF_WORD;
        for a in attributes {

            match a.attr {
                Attributes::ABSTRACT => {
                    if (isStruct) throw ErrorMsg::fatal (a.loc, format (DeclareErrorMessage::UNDEFINED_ATTRIBUTE_FOR_STRUCT, a.attr), notes-> [ErrorMsg::note (loc, ""s8)]);

                    isAbstract = true;
                    abstractLoc = a.loc;
                    if (isFinal) throw ErrorMsg::fatal (a.loc, DeclareErrorMessage::ABSTRACT_AND_FINAL, notes-> [ErrorMsg::note (finalLoc, ""s8), ErrorMsg::note (loc, ""s8)]);
                }
                Attributes::FINAL => {
                    if (isStruct) throw ErrorMsg::fatal (a.loc, format (DeclareErrorMessage::UNDEFINED_ATTRIBUTE_FOR_STRUCT, a.attr), notes-> [ErrorMsg::note (loc, ""s8)]);

                    isFinal = true;
                    finalLoc = a.loc;
                    if (isAbstract) throw ErrorMsg::fatal (a.loc, DeclareErrorMessage::ABSTRACT_AND_FINAL, notes-> [ErrorMsg::note (abstractLoc, ""s8), ErrorMsg::note (loc, ""s8)]);
                }
                _ => {
                    throw ErrorMsg::fatal (a.loc, format (DeclareErrorMessage::UNDEFINED_ATTRIBUTE_FOR_CLASS, a.attr), notes-> [ErrorMsg::note (loc, ""s8)]);
                }
            }
        }

        (isAbstract, isFinal)
    }


    /**
     * Declare the content of a class
     * @params:
     *   - d: the declaration to transform into symbol
     *   - cl: the class symbol that is filled
     *   - protection: the current protection of the symbol to declare
     */
    pub fn declareInnerClass (mut self, current : &Declaration, dmut cl : &ClassSymbol, protection : Protection)
        throws &ErrorMsg
    {
        match current {
            dl : &BlockDecl => {
                let inProt = if (dl.isSet ()) { protection } else { dl.getProtection () };
                for i in dl.getDeclarations () {
                    self:.declareInnerClass (i, alias cl, protection-> inProt);
                }
            }
            cstr : &ConstructorDecl => {
                self.declareConstructor (cstr, alias cl, protection-> protection);
            }
            dtor : &DestructorDecl => {
                self.declareDestructor (dtor, alias cl);
            }
            im : &ImplDecl => {
                self:.declareImpl (im, alias cl, protection-> protection);
            }
            gl : &GlobalDecl => {
                self.declareFieldClass (gl, alias cl, protection-> protection);
            }
            t : &TemplateDecl => {
                self.declareTemplate (t, alias cl, protection-> protection);
            }
            c : &CondBlockDecl => {
                self.declareCondBlockClass (c, alias cl);
            }
            wrap : &ExpressionWrapperDecl => {
                self.declareAssertClass (wrap, alias cl);
            }
            im : &ImportDecl => {
                self:.declareImport (im, alias cl, protection-> protection);
            }
            f : &FunctionDecl => {
                self.declareFunction (f, alias cl, protection-> protection);
            }
            _ => {
                throw ErrorMsg::fatal (current.getLoc (), DeclareErrorMessage::UNEXPECTED_IN_CLASS);
            }
        }
    }

    /**
     * Declare a class constructor
     * @params:
     *   - cstr: the constructor to declare
     *   - cl: the parent class
     *   - protection: the protection of the constructor
     */
    pub fn declareConstructor (self, cstr : &ConstructorDecl, dmut cl : &ClassSymbol, protection : Protection)-> dmut &Symbol
        throws &ErrorMsg
    {
        let isUnsafe = self.validateUnsafeCtor (cstr.getAttributes ());

        let dmut cstrSym = ConstructorSymbol::new (cstr.getLoc (), cstr.getComments (), cstr, alias cl, protection-> protection, isUnsafe-> isUnsafe);
        cl:.insert (alias cstrSym, replace-> false);

        alias cstrSym
    }

    /**
     * Declare the destructor of the class
     * @params:
     *   - dtor: the destructor
     *   - cl: the parent class
     * @throws:
     *    - &ErrorMsg: if there are multiple destructor
     */
    fn declareDestructor (self, dtor : &DestructorDecl, dmut cl : &ClassSymbol)
        throws &ErrorMsg
    {
        match cl.getDestructor () {
            EmptySymbol () => {}
            _ => {
                throw ErrorMsg::fatal (dtor.getLoc (), DeclareErrorMessage::MULTIPLE_DESTRUCTOR,
                                       notes-> [ErrorMsg::note (cl.getDestructor ().getLoc (), ""s8)]);
            }
        }

        let dmut dtorSym = DestructorSymbol::new (dtor.getLoc (), dtor.getComments (), dtor, alias cl);
        cl:.setDestructor (alias dtorSym);
    }

    /**
     * Validate the custom attributes of a ctor definition
     * @params:
     *    - attributes: the list of custom attributes of the ctor
     * @returns: true if the ctor is unsafe
     * @throws: if an attribute is undefined for ctor
     * */
    fn validateUnsafeCtor (self, attributes : [AttributeWord])-> bool
        throws &ErrorMsg
    {
        let mut isUnsafe = false;
        for a in attributes {
            match a.attr {
                Attributes::UNSAFE => { isUnsafe = true; }
                _ => {
                    throw ErrorMsg::fatal (a.loc, format (DeclareErrorMessage::UNDEFINED_ATTRIBUTE_FOR_CTOR, a.attr));
                }
            }
        }

        isUnsafe
    }

    /**
     * Declare an implementation
     * @params:
     *   - impl: the implementation to declare
     *   - cl: the parent class
     */
    fn declareImpl (mut self, im : &ImplDecl, dmut cl : &ClassSymbol, protection : Protection)
        throws &ErrorMsg
    {
        let dmut implSym = ImplSymbol::new (im.getLoc (), im.getComments (), im, protection-> protection);
        for i in im.getDeclarations () {
            self:.declareInnerImpl (i, alias implSym, alias cl, protection-> Protection::PROTECTED);
        }

        cl:.insert (alias implSym, replace-> false);
    }

    /**
     * Declare the content of an implementation
     * @params:
     *   - current: the declaration to transform
     *   - im: the implementation that is being declared
     *   - protection: the protection of the implementation
     */
    fn declareInnerImpl (mut self, current : &Declaration, dmut im : &ImplSymbol, dmut cl : &ClassSymbol, protection : Protection)
        throws &ErrorMsg
    {
        match current {
            dl : &BlockDecl => {
                for i in dl.getDeclarations () {
                    self:.declareInnerImpl (i, alias im, alias cl, protection-> dl.getProtection ());
                }
            }
            f : &FunctionDecl => {
                self.declareFunction (f, alias im, protection-> protection);
            }
            wrap : &ExpressionWrapperDecl => {
                self.declareAssertClass (wrap, alias cl);
            }
            imp : &ImportDecl => {
                self:.declareImport (imp, alias cl, protection-> protection);
            }
            _ => {
                throw ErrorMsg::fatal (current.getLoc (), DeclareErrorMessage::UNEXPECTED_IN_IMPL);
            }
        }
    }

    /**
     * Declare a field in a class
     * @params:
     *   - field: the field to declare
     *   - cl: the class symbol
     *   - protection: the protection of the field
     */
    fn declareFieldClass (self, field : &GlobalDecl, dmut cl : &ClassSymbol, protection : Protection)
    {
        cl:.addField (field.getContent (), field.getComments (), protection-> protection)
    }

    /**
     * Declare an assertion in a class
     * @params:
     *    - wrap: the assertion to declare
     *    - cl: the class symbol
     */
    fn declareAssertClass (self, wrap : &ExpressionWrapperDecl, dmut cl : &ClassSymbol) {
        cl:.addAssertion (wrap.getContent (), wrap.getComments ());
    }

    /**
     * Declare a conditional block in a class
     * @params:
     *    - c: the conditional to declare
     *    - cl: the class symbol
     */
    fn declareCondBlockClass (self, c : &CondBlockDecl, dmut cl : &ClassSymbol) {
        cl:.addCondBlock (c);
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================          UNITTEST           ==========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Declare a unittest
     * @params:
     *    - u: the unittest to declare
     *    - parent: the parent of the declaration
     * */
    fn declareUnitTest (self, u : &UnitTestDecl, dmut parent : &Symbol)-> dmut &Symbol {
        let dmut unitSym = UnitTestSymbol::new (u.getLoc (), u.getComments (), u);
        parent:.insertUnitTest (alias unitSym);
        unitSym:.setReferent (alias parent);

        alias unitSym
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================          FUNCTIONS           =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Declare a function declaration
     * @params:
     *   - func: the function to declare
     *   - parent: the parent of the declaration
     *   - protection: the protection of the declaration
     */
    fn declareFunction (self, func : &FunctionDecl, dmut parent : &Symbol, protection : Protection, isExtern : bool = false, lang : [c8] = ""s8)-> dmut &Symbol
        throws &ErrorMsg
    {
        self.validateShadowingFunction (func.getLoc (), parent);
        let (isFinal, isUnsafe_) = self.validateFinalUnsafeFunction (func.getAttributes ());
        let isCVariadic = func.getFunctionProto ().isVariadic ();
        if (isCVariadic && (!isExtern || lang != Keys::CLANG)) {
            throw ErrorMsg::fatal (func.getLoc (), DeclareErrorMessage::DECL_VARIADIC_FUNC);
        }

        let isUnsafe = if (isExtern && lang == Keys::CLANG) {
            true
        } else { isUnsafe_ };

        let dmut funcSym = FunctionSymbol::new (func.getLoc (), func.getComments (), func, isOver-> func.isOver (), isFinal-> isFinal, isUnsafe-> isUnsafe, isCVariadic-> isCVariadic, protection-> protection);
        parent:.insert (alias funcSym, replace-> false);

        alias funcSym
    }

    /**
     * Validate that the function is not shadowing another declaration of a different type
     * @params:
     *   - loc: the location of the function decl
     *   - parent: the parent symbol in which the function will be declared
     */
    fn validateShadowingFunction (self, loc : &Word, parent : &Symbol)
        throws &ErrorMsg
    {
        let syms = parent.getLocalSymbols (loc.str (), protection-> Protection::PRIVATE);
        for s in syms[] {
            match s {
                FunctionSymbol () => {}
                ModuleSymbol () => {}
                TemplateSymbol () => {}
                _ => {
                    throw ErrorMsg::fatal (loc,
                                           format (DeclareErrorMessage::SHADOWING_DECL, loc.str ()),
                                           notes-> [ErrorMsg::note (s.getLoc (), ""s8)]);
                }
            }
        }
    }

    /**
     * Validate the custom attributes of a function definition
     * @params:
     *   - attributes: the list of custom attributes of the function
     * @returns: (isFinal, isUnsafe)
     * @throws:
     *   - ErrorMsg:  if an attributes is not defined for function
     */
    fn validateFinalUnsafeFunction (self, attributes : [AttributeWord])-> (bool, bool)
        throws &ErrorMsg
    {
        let mut isFinal = false, mut isUnsafe = false;
        for a in attributes {
            match a.attr {
                Attributes::FINAL => {
                    isFinal = true;
                }
                Attributes::UNSAFE => {
                    isUnsafe = true;
                }
                Attributes::FIELD => {}
                Attributes::INLINE => {}
                _ => {
                    throw ErrorMsg::fatal (a.loc, format (DeclareErrorMessage::UNDEFINED_ATTRIBUTE_FOR_FUNCTION, a.attr));
                }
            }
        }
        
        (isFinal, isUnsafe)
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================           TEMPLATE           =========================
     * ================================================================================
     * ================================================================================
     */
    

    /**
     * Declare a template declaration
     * @params: 
     *   - tm: the template to declare
     *   - parent: the parent symbol of the declaration
     *   - protection: the protection of the declaration
     */
    fn declareTemplate (self, tm : &TemplateDecl, dmut parent : &Symbol, protection : Protection)-> dmut &Symbol
        throws &ErrorMsg
    {
        self.validateShadowingTemplates (tm.getParameters ());
        let dmut templSym = TemplateSymbol::new (tm.getLoc (), tm.getComments (), tm, protection-> protection);

        parent:.insert (alias templSym, replace-> false);

        alias templSym
    }

    /**
     * Verify that there is no shadowing in the name of the template parameters
     * @params: 
     *   - params: the template parameters
     */
    fn validateShadowingTemplates (self, params : [&Expression])
        throws &ErrorMsg
    {
        if (params.len == 0us) return {}
        for i in 0us .. params.len - 1us {
            for j in i + 1us .. params.len {
                let fst = match params [i] {
                    v : &TemplateVariadicVarExpr => { v.getLoc ().str () }
                    v : &TemplateOfVarExpr => { v.getLoc ().str () }
                    v : &TemplateVarExpr => { v.getLoc ().str () }
                    v : &VarDeclExpr => { v.getLoc ().str () }
                    _ => ""s8
                }
                let shadow = match params [j] {
                    v : &TemplateVariadicVarExpr => { v.getLoc ().str () == fst }
                    v : &TemplateOfVarExpr => { v.getLoc ().str () == fst }
                    v : &TemplateVarExpr => { v.getLoc ().str () == fst }
                    v : &VarDeclExpr => { v.getLoc ().str ()  == fst}
                    _ => { false }
                }
                
                if (shadow) {
                    throw ErrorMsg::fatal (params [j].getLoc (),
                                           format (DeclareErrorMessage::SHADOWING_DECL, params [i].getLoc ().str ()),
                                           notes-> [ErrorMsg::note (params [i].getLoc (), ""s8)]);
                }                
            }
        }
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================          EXTERNAL            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Declare an external language block
     * @params: 
     *   - decl: the block to declare
     *   - parent: the parent module of the declaration
     *   - protection: the protection of the declaration
     */
    fn declareExternBlock (self, decl : &ExternBlockDecl, dmut parent : &Symbol, protection : Protection)-> dmut &Symbol
        throws &ErrorMsg
    {
        let path = self.validateSpaceLanguage (decl.getLanguage (), decl.getNamespace ());
        self.declareInnerExternal (decl.getDeclaration (), alias parent, protection-> protection, lang-> decl.getLanguage ().str (), path-> path);        

        return EmptySymbol::new ();
    }

    /**
     * Declare the content of an external block
     * @params: 
     *    - decl: the inner declaration to declare
     *    - parent: the parent of the external block
     *    - protection: the protection of the declaration
     *    - lang: the language of the extern block
     *    - path: the path of the extern block
     */
    fn declareInnerExternal (self, decl : &Declaration, dmut parent : &Symbol, protection : Protection, lang : [c8], path : &Path)
        throws &ErrorMsg
    {
        match decl {
            f : &FunctionDecl => {
                let dmut sym = self.declareFunction (f, alias parent, protection-> protection, isExtern-> true, lang-> lang);
                sym:.setExternalLanguage (lang, path);
            }
            bl : &BlockDecl => {
                for i in bl.getDeclarations () {
                    self.declareInnerExternal (i, alias parent, protection-> protection, lang, path);
                }
            }
            glb : &GlobalDecl => {
                let dmut sym = self.declareGlobal (glb, alias parent, protection-> protection, isExtern-> true);
                sym:.setExternalLanguage (lang, path);
            }
            _ => {
                throw ErrorMsg::fatal (decl.getLoc (), DeclareErrorMessage::UNEXPECTED_IN_EXTERN);
            }
        }
    }
    
    /**
     * Verify that the path is empty or applicable for the given language
     * @params: 
     *   - lang: the language of the extern
     *   - space: the namespace of the extern
     */
    fn validateSpaceLanguage (self, lang : &Word, space : &Expression)-> &Path
        throws &ErrorMsg
    {
        let (empty, path) = match space {
            UnitExpr () => { (true, Path::new (""s8)) }
            EmptyExpression () => { (true, Path::new (""s8)) }
            _ => {
                (false, self.toPath (space))
            }
        }
        
        if (lang != Keys::CPPLANG && lang != Keys::DLANG && !empty) {
            throw ErrorMsg::fatal (lang, format (DeclareErrorMessage::NAMESPACE_EXTERNAL, lang.str ()),
                                   notes-> [ErrorMsg::note (space.getLoc (), ""s8)]);
        }

        path
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================            MACRO             =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Declare a macro
     * @params: 
     *    - m: the macro to declare
     *    - parent: the parent module of the declaration
     *    - protection: the protection of the declaration
     */
    fn declareMacro (self, m : &MacroDecl, dmut parent : &Symbol, protection : Protection)-> dmut &Symbol
        throws &ErrorMsg
    {

        let syms = parent.getLocalSymbols (m.getLoc ().str (), protection-> Protection::PRIVATE);
        for s in syms[] {
            match s {
                ModuleSymbol () => {}
                TemplateSymbol () => {}
                _ => {
                    throw ErrorMsg::fatal (m.getLoc (),
                                           format (DeclareErrorMessage::SHADOWING_DECL, m.getLoc ().str ()),
                                           notes-> [ErrorMsg::note (s.getLoc (), ""s8)]);
                }
            }
        }
        
        let dmut macroSym = MacroSymbol::new (m.getLoc (), m.getComments (), protection-> protection);
        for d in m.getDeclarations () {
            self.declareInnerMacro (d, alias macroSym, protection-> Protection::PROTECTED);
        }

        parent:.insert (alias macroSym, replace-> false);
        
        alias macroSym
    }

    /**
     * Declare the content of a macro definition
     * @params: 
     *   - decl: the declaration to declare
     *   - m: the parent macro symbol
     *   - protection: the protection of the declaration
     */
    fn declareInnerMacro (self, decl : &Declaration, dmut m : &MacroSymbol, protection : Protection)
        throws &ErrorMsg
    {
        match decl {
            bl : &BlockDecl => {
                for d in bl.getDeclarations () {
                    self.declareInnerMacro (d, alias m, protection-> bl.getProtection ());
                }
            }
            ctor : &MacroRuleDecl => {
                if (ctor.isConstructor ()) {
                    let dmut sym = MacroConstructorSymbol::new (ctor.getLoc (), ctor.getComments (), ctor, protection);
                    m:.insert (alias sym, replace-> false);
                } else {
                    let dmut sym = MacroRuleSymbol::new (ctor.getLoc (), ctor.getComments (), ctor, protection);
                    m:.insert (alias sym, replace-> false);
                }                
            }
            _ => {
                throw ErrorMsg::fatal (decl.getLoc (), DeclareErrorMessage::UNEXPECTED_IN_MACRO);
            }
        }
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================             ENUM             =========================
     * ================================================================================
     * ================================================================================
     */


    /**
     * Declare the symbol of a enumeration
     * @params: 
     *   - st: the enum to declare
     *   - parent: the module that is declaring the enum
     *   - protection: the protection of the enum
     */
    fn declareEnum (self, en : &EnumDecl, dmut parent : &Symbol, protection : Protection)-> dmut &Symbol
        throws &ErrorMsg
    {
        let syms = parent.getLocalSymbols (en.getLoc ().str (), protection-> Protection::PRIVATE);
        for s in syms[] {
            match s {
                ModuleSymbol () => {}
                TemplateSymbol () => {}
                _ => {
                    throw ErrorMsg::fatal (en.getLoc (),
                                           format (DeclareErrorMessage::SHADOWING_DECL, en.getLoc ().str ()),
                                           notes-> [ErrorMsg::note (s.getLoc (), ""s8)]);
                }
            }
        }

        let dmut enSym = EnumSymbol::new (en.getLoc (), en.getComments (), en, protection);        
        parent:.insert (alias enSym, replace-> false);
        
        alias enSym
    }
    

    /*!
     * ================================================================================
     * ================================================================================
     * =========================             AKA              =========================
     * ================================================================================
     * ================================================================================
     */


    /**
     * Declare the symbol of an aka
     * @params: 
     *   - st: the aka to declare
     *   - parent: the module that is declaring the aka
     *   - protection: the protection of the aka
     */
    fn declareAka (self, en : &AkaDecl, dmut parent : &Symbol, protection : Protection)-> dmut &Symbol
        throws &ErrorMsg
    {
        let syms = parent.getLocalSymbols (en.getLoc ().str (), protection-> Protection::PRIVATE);
        for s in syms[] {
            match s {
                ModuleSymbol () => {}
                TemplateSymbol () => {}
                _ => {
                    throw ErrorMsg::fatal (en.getLoc (),
                                           format (DeclareErrorMessage::SHADOWING_DECL, en.getLoc ().str ()),
                                           notes-> [ErrorMsg::note (s.getLoc (), ""s8)]);
                }
            }
        }

        let dmut enSym = AkaSymbol::new (en.getLoc (), en.getComments (), en, protection);        
        parent:.insert (alias enSym, replace-> false);
        
        alias enSym
    }


    /*!
     * ================================================================================
     * ================================================================================
     * =========================            TRAIT             =========================
     * ================================================================================
     * ================================================================================
     */



    /**
     * Declare an implementation 
     * @params: 
     *   - impl: the implementation to declare
     *   - cl: the parent class
     */
    fn declareTrait (mut self, tr : &TraitDecl, dmut parent : &Symbol, protection : Protection)-> dmut &Symbol
        throws &ErrorMsg
    {
        let syms = parent.getLocalSymbols (tr.getLoc ().str (), protection-> Protection::PRIVATE);
        for s in syms[] {
            match s {
                ModuleSymbol () => {}
                TemplateSymbol () => {}
                _ => {
                    throw ErrorMsg::fatal (tr.getLoc (),
                                           format (DeclareErrorMessage::SHADOWING_DECL, tr.getLoc ().str ()),
                                           notes-> [ErrorMsg::note (s.getLoc (), ""s8)]);
                }
            }
        }
        
        let dmut traitSym = TraitSymbol::new (tr.getLoc (), tr.getComments (), tr, protection-> protection);      
        for i in tr.getDeclarations () {
            self:.declareInnerTrait (i, alias traitSym, protection-> Protection::PROTECTED);
        }

        parent:.insert (alias traitSym, replace-> false);

        alias traitSym
    }

    /**
     * Declare the content of a trait
     * @params: 
     *   - current: the declaration to transform
     *   - tr: the trait that is being declared
     *   - protection: the protection of the declaration inside the trait
     */
    fn declareInnerTrait (mut self, current : &Declaration, dmut tr : &TraitSymbol, protection : Protection)
        throws &ErrorMsg
    {
        match current {
            dl : &BlockDecl => {
                for i in dl.getDeclarations () {
                    self:.declareInnerTrait (i, alias tr, protection-> dl.getProtection ());
                }
            }
            f : &FunctionDecl => {
                let sym = self.declareFunction (f, alias tr, protection-> protection);
                if (f.isOver ())
                throw ErrorMsg::fatal (f.getLoc (), format (DeclareErrorMessage::NOT_OVERRIDE, sym.getPath ().toStr ()));
            }
            wrap : &ExpressionWrapperDecl => {
                self.declareAssertTrait (wrap, alias tr);
            }
            imp : &ImportDecl => {
                self:.declareImport (imp, alias tr, protection-> protection);
            }
            _ => {
                throw ErrorMsg::fatal (current.getLoc (), DeclareErrorMessage::UNEXPECTED_IN_TRAIT);
            }
        }
    }

    /**
     * Declare an assertion in a class
     */
    fn declareAssertTrait (self, wrap : &ExpressionWrapperDecl, dmut tr : &TraitSymbol) {
        tr:.addAssertion (wrap.getContent (), wrap.getComments ());
    }


    /*!
     * ================================================================================
     * ================================================================================
     * =========================            GLOBAL            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Declare a global variable
     * @params: 
     *   - gl: the var to declare
     *   - parent: the parent module declaring the variable
     *   - protection: the protection of the declaration
     */
    fn declareGlobal (self, gl : &GlobalDecl, dmut parent : &Symbol, protection : Protection, isExtern : bool = false)-> dmut &Symbol
        throws &ErrorMsg
    {
        let syms = parent.getLocalSymbols (gl.getContent ().getLoc ().str (), protection-> Protection::PRIVATE);
        for s in syms[] {
            match s {
                ModuleSymbol () => {}
                TemplateSymbol () => {}
                _ => {
                    throw ErrorMsg::fatal (gl.getContent ().getLoc (),
                                           format (DeclareErrorMessage::SHADOWING_DECL, gl.getContent ().getLoc ().str ()),
                                           notes-> [ErrorMsg::note (s.getLoc (), ""s8)]);
                }
            }
        }

        if (gl.isStatic () && !isExtern) {
            throw ErrorMsg::fatal (gl.getLoc (), DeclareErrorMessage::DECL_GLOB_STATIC_NON_EXTERN);
        }

        let dmut glSym = GlobalSymbol::new (gl.getContent ().getLoc (), gl.getComments (), gl, protection-> protection, isExtern-> isExtern, isStatic-> gl.isStatic ());
        parent:.insert (alias glSym, replace-> false);

        alias glSym
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================           FINALIZE           =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Finalize the declaration of the use decl inside the symbols
     * It assumes, that everything is declared, thus use decl are valid
     * @params:
     *    - sym: the root symbol to finalize
     * */
    pub fn finalizeDeclaration (mut self, dmut sym : &Symbol, useCore : bool = true)
        throws &ErrorMsg
    {
        let dmut errors = Vec!{&ErrorMsg}::new ();

        let uses = sym.getAllUseDecls ();
        for i in 0us .. uses.len {
            {
                self:.finalizeUse (alias sym, uses [i]);
            } catch {
                err : &ErrorMsg => { errors:.push (err); }
            }
        }

        // use core only if parent also uses core, not in standalone, and not a core module
        let useCore_ = useCore && (!state::instance ().isStandalone ()) && (!sym.isCoreModule ());
        if (useCore_) {
            sym:.setUsedCore (alias (alias self._coreModules)[]);
        }

        let dmut inner = sym:.getAllLocalSymbols (protection-> Protection::PRIVATE);
        for i in 0us .. inner.len {
            {
                self:.finalizeDeclaration (alias inner [i], useCore-> useCore_); // child of core modules don't use core
            } catch {
                err : &ErrorMsg => { errors:.push (err); }
            }
        }

        if (errors.len () != 0us) throw ErrorMsg::list (errors[]);
    }

    /**
     * Finalize a use declaration
     * @params:
     *    - parent: the parent that declare the use
     *    - use_: the use declaration to validate
     * */
    fn finalizeUse (mut self, dmut parent : &Symbol, use_ : &UseDecl, throwSelf : bool = true)
        throws &ErrorMsg
    {
        let useP = use_.getModulePath ();
        let p = self.toPath (useP);

        let mut root = self:.getGlobal (p.root (), parent); // absolute access to the root of the path

        if (root.len == 0us) { // root of the path does not exist
            // this is an absolute access, thus an absolute error, thus absolute error has to be thrown
            throw self.createGlobalAccessError (self.getPathIndexLoc (useP, 0us), p.root (), parent);
        }

        let mut current = parent, mut all = false;
        let parts = p.parts ();
        for i in 1us .. parts.len {
            let mut found = false;
            if (i == parts.len - 1us && parts [i] == Keys::UNDER) {
                let dmut subMods = Vec!{&Symbol}::new ();
                for r in root match r {
                    m : &ModuleSymbol => {
                        let loc = self.getAllLocalFromContext (parent, m);
                        for s in loc { subMods:.push (s); }
                    }
                }

                root = subMods[];
                all = true;
            } else {
                for r in root match r {
                    m : &ModuleSymbol => { // there can be only one module with a given name in another module, otherwise error would have been thrown during module declaration
                        root = self.getLocalFromContext (parts [i], parent, m); // relative access, while ensuring protection access
                        if (root.len == 0us) { // no module named parts[i] in current module
                            let errLoc = self.getPathIndexLoc (useP, i);
                            throw ErrorMsg::fatal (errLoc, format (DeclareErrorMessage::NO_MODULE_NAMED, parts [i], m.getPath ().toStr ()),
                                                   notes-> self.createLocalAccessError (errLoc, parts[i], m, parent));
                        }

                        found = true;
                        current = m;
                    }
                }

                // A symbol was found, but it was not a module
                if (!found) {
                    throw ErrorMsg::fatal (self.getPathIndexLoc (useP, i - 1us), format (DeclareErrorMessage::NO_MODULE_NAMED, parts[i - 1us], current.getPath ().toStr ()));
                }
            }
        }

        for r in root match r {
            m : &ModuleSymbol => { // use all the module found at the end of the path
                if (parent is m) {
                    if (!all && throwSelf) {
                        throw ErrorMsg::warn (self.getPathIndexLoc (useP, parts.len - 1us), format (DeclareErrorMessage::SELF_USE, m.getPath ().toStr ()));
                    }
                } else {
                    parent:.useModule (m.getPath ().asStdPath (), alias self:.getMutableSymbol (m));
                    all = true; // set all to true, because at least one module was found
                }
            }
        }

        if (!all) { // all is true if at least one module was used, or '_' was found, meaning use all sub modules from this path
            // if not all, then symbol was found in current, but it was not a module
            throw ErrorMsg::fatal (self.getPathIndexLoc (useP, parts.len - 1us),
                                   format (DeclareErrorMessage::NO_MODULE_NAMED, parts[parts.len - 1us], current.getPath ().toStr ()));
        }
    }
    
    /*!
     * ================================================================================
     * ================================================================================
     * =========================            UTILS             =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Transform an expression into a path
     * @returns: a path
     * @panic
     */
    fn toPath (self, expr : &Expression)-> &Path {
        match expr {
            p : &PathExpr => {
                p.toStdPath ()
            }
            _ => {
                Path::new (expr.getLoc ().str ())
            }
        }
    }

/**
     * @returns: the location of the 'index' path element in the path
     * */
    fn getPathIndexLoc (self, expr : &Expression, index : usize)-> &Word {
        match expr {
            p : &PathExpr => {
                let locs = p.getLocs ();
                if (locs.len < index) { expr.getLoc () }
                else { locs [index] }
            }
            _ => {
                expr.getLoc ()
            }
        }
    }

    /**
     * Transform a path into a path expression
     * */
    fn fromPath (self, loc : &Word, path : &Path)-> &Expression {
        let mut current : &Expression = EmptyExpression::new ();
        for p in path.parts () {
            match current {
                EmptyExpression () => {
                    current = VarExpr::new (Word::new (p, loc));
                }
                _ => {
                    current = PathExpr::new (Word::new (Tokens::DCOLON, loc), current, VarExpr::new (Word::new (p, loc)));
                }
            }
        }

        current
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================           GETTERS            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * @returns: the mutable version of a symbol from its immutable address
     * @panic: if the symbol was not declared nor registered by this declarator
     */
    pub fn getMutableSymbol (mut self, sym : &Symbol)-> dmut &Symbol {
        let dmut r = self._root:.getMutableSymbol (sym);
        match ref r {
            Ok (dmut v : _) => return alias v;
            _ => {

                let dmut forR = self._foreignRoot:.getMutableSymbol (sym);
                match ref forR {
                    Ok (dmut v : _) => { return alias v; }
                    _ => {
                        eprintln ("Symbol not found in sym table : ", sym.getPath ().toStr ());
                        __pragma!panic ();
                    }
                }
            }
        }
    }

    /**
     * @returns: the protection the 'context' has on the symbol 'sym'
     * */
    pub fn getProtectionFromContext (self, context : &Symbol, sym : &Symbol)-> Protection {
        let mut current = context;
        loop {
            match current {
                EmptySymbol () => { break Protection::PUBLIC; }
                c : _ => {
                    if (c is sym) {
                        break Protection::PRIVATE;
                    }
                }
            }
            current = current.getReferent ();
        }
    }

    /**
     * Get a list of symbol from a global access, where current context is 'context'
     * @params:
     *    - name: the name of the symbol to find
     *    - context: the context in which symbols is searched
     * */
    pub fn getGlobal (mut self, name : [c8], context : &Symbol)-> [&Symbol] {
        let mut root = context.getSymbols (name)[];
        if (root.len  == 0us) {
            root = self._foreignRoot.getSymbols (name)[];
        }

        root
    } 

    /**
     * Get a list of symbol declared locally inside 'sym' from the context 'context' that might have no access to private syms
     * @params:
     *    - name: the name of the symbol to access
     *    - context: the context of the access
     *    - sym: the symbol being accessed
     *    - protection: the protection to apply if symbol only have public access
     * */
    pub fn getLocalFromContext (mut self, name : [c8], context : &Symbol, sym : &Symbol, protection : Protection = Protection::PUBLIC)-> dmut [&Symbol] {
        let dmut module = self:.getMutableSymbol (sym);
        let mut contextProt = self.getProtectionFromContext (context, sym);
        if (contextProt == Protection::PUBLIC) { contextProt = protection; }

        let dmut res = alias (alias module:.getLocalSymbols (name, protection-> contextProt))[];
        alias res
    }

    /**
     * Get a list of symbol declared locally inside 'sym' from the context 'context' that might have no access to private syms
     * @params:
     *    - name: the name of the symbol to access
     *    - context: the context of the access
     *    - sym: the symbol being accessed
     *    - protection: the protection to apply if symbol only have public access
     * */
    pub fn getLocalFromContext (self, name : [c8], context : &Symbol, sym : &Symbol, protection : Protection = Protection::PUBLIC)-> [&Symbol] {
        let mut contextProt = self.getProtectionFromContext (context, sym);
        if (contextProt == Protection::PUBLIC) { contextProt = protection; }

        let res = (sym.getLocalSymbols (name, protection-> contextProt))[];
        res
    }

    /**
     * Get the list of symbol declared locally in 'sym' that are reachable from 'context'
     * @params:
     *     - context: the context of the access
     *     - sym: the symbol being accessed
     *     - protection: the protection to apply if symbol only have public access
     * */
    pub fn getAllLocalFromContext (self, context : &Symbol, sym : &Symbol, protection : Protection = Protection::PUBLIC)-> [&Symbol] {
        let mut contextProt = self.getProtectionFromContext (context, sym);
        if (contextProt == Protection::PUBLIC) { contextProt = protection; }

        let res = (sym.getAllLocalSymbols (protection-> contextProt));
        res
    }

    /**
     * Get a list of symbol declared locally inside 'sym' from the context 'context' that might have no access to private syms
     * And whose name are close to 'name' with a distance of 'distance'
     * @params:
     *    - name: the name of the symbol to access
     *    - distance: the distance between the names to seek and the symbols in the module 'sym'
     *    - context: the context of the access
     *    - sym: the symbol being accessed
     *    - protection: the protection to apply if symbol only have public access
     * */
    pub fn getCloseLocalFromContext (self, name : [c8], distance : usize = 2us, context : &Symbol, sym : &Symbol, protection : Protection = Protection::PUBLIC)-> [&Symbol] {
        let mut contextProt = self.getProtectionFromContext (context, sym);
        if (contextProt == Protection::PUBLIC) { contextProt = protection; }

        let res = (sym.getCloseLocalSymbols (name, distance-> distance, protection-> contextProt))[];
        res
    }

    /**
     * Create an error message for a global access that was unsuccessful
     * @params:
     *    - loc: the location of the access
     *    - name: the name of the symbol being accessed
     *    - sym: the context of the access
     * */
    pub fn createGlobalAccessError (self, loc : &Word, name : [c8], sym : &Symbol)-> &ErrorMsg {
        let dmut notes = Vec!{&ErrorMsg}::new ();
        let mut syms = sym.getSymbols (name, protection-> Protection::PRIVATE)[];

        let mut msgFrom = DeclareErrorMessage::PRIVATE_IN_THIS_CONTEXT_FROM_MOD, mut msgNonFrom = DeclareErrorMessage::PRIVATE_IN_THIS_CONTEXT;
        if (syms.len == 0us) { // if no symbol is named 'name', then maybe there is typo in the variable name
            syms = sym.getCloseSymbols (name, distance-> 2us)[]; // Get all the symbols whose names are close to 'name'

            // Change the error messages
            msgFrom = DeclareErrorMessage::MAYBE_WAS_MEANT_FROM_MOD;
            msgNonFrom = DeclareErrorMessage::MAYBE_WAS_MEANT;
        }

        let dmut used = HashSet!{&Path}::new ();
        for s in syms { // add the notes to the error
            let stdPath = s.getPath ().asStdPath ();
            if (stdPath !in used) {
                let p = stdPath.parent ().toStr (sep-> "::"s8);
                if (p.len != 0us) {
                    notes:.push (ErrorMsg::note (s.getLoc (), oneLine-> true, format (msgFrom, stdPath.file (), p)));
                } else
                    notes:.push (ErrorMsg::note (s.getLoc (), oneLine-> true, format (msgNonFrom, stdPath.file ())));

                used:.insert (stdPath);
            }
        }

        // Not thrown, it will be thrown by the caller function
        ErrorMsg::fatal (loc, format (DeclareErrorMessage::UNDEF_VAR, name), notes-> notes[])
    }

    /**
     * Create an error message for a local access that was unsuccessful
     * @params:
     *    - loc: the location of the access
     *    - name: the name of the symbol being accessed
     *    - sym: the context of the access
     * */
    pub fn createLocalAccessError (self, _ : &Word, name : [c8], sym : &Symbol, context : &Symbol)-> [&ErrorMsg] {
        let dmut notes = Vec!{&ErrorMsg}::new ();

        // Search all the local symbols with the same name but that are not accessible
        let mut syms = sym.getLocalSymbols (name, protection-> Protection::PRIVATE)[];
        let mut msgFrom = DeclareErrorMessage::PRIVATE_IN_THIS_CONTEXT_FROM_MOD, mut msgNonFrom = DeclareErrorMessage::PRIVATE_IN_THIS_CONTEXT;
        if (syms.len == 0us) { // if no symbol is named 'name', then maybe there is typo in the variable name
            let contextProt = self.getProtectionFromContext (context, sym);
            syms = sym.getCloseLocalSymbols (name, distance-> 2us, protection-> contextProt)[]; // Get all the local symbols whose names are close to 'name'

            // Change the error messages
            msgFrom = DeclareErrorMessage::MAYBE_WAS_MEANT_FROM_MOD;
            msgNonFrom = DeclareErrorMessage::MAYBE_WAS_MEANT;
        }

        let dmut used = HashSet!{&Path}::new ();
        for s in syms { // add the notes to the error
            let stdPath = s.getPath ().asStdPath ();
            if (stdPath !in used) {
                let p = stdPath.parent ().toStr (sep-> "::"s8);
                if (p.len != 0us) {
                    notes:.push (ErrorMsg::note (s.getLoc (), oneLine-> true, format (msgFrom, stdPath.file (), p)));
                } else
                    notes:.push (ErrorMsg::note (s.getLoc (), oneLine-> true, format (msgNonFrom, stdPath.file ())));

                used:.insert (stdPath);
            }
        }

        notes[]
    }


    /*!
     * ================================================================================
     * ================================================================================
     * =========================        MISCELLANEOUS         =========================
     * ================================================================================
     * ================================================================================
     */

    impl Formattable {

        pub over format (self, dmut stream : &Formatter) {
            stream:.write (" LOCAL : \n");
            self._root.formatSymTree (alias stream);
            stream:.write (" EXTERNAL : \n");
            self._foreignRoot.formatSymTree (alias stream);
        }
    }
    
    
}
