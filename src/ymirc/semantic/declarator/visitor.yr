in visitor;

use std::{io, stream, fs::_};

use ymirc::errors::_;
use ymirc::semantic::declarator::errors;
use ymirc::semantic::symbol::{_, macro_::_};

use ymirc::syntax::{_,
                    declaration::_,
                    expression::{_, literal::_, macro_::_, operator::_, template::_}};

use ymirc::lexing::{word, tokens};
use ymirc::global::{common, state, core_};

use ymirc::syntax::visitor;
use ymirc::utils::{format, memory, list};

/**
 * The declarator transforms a syntaxic decl element into a symbol tree
 * The nodes of the tree are not validated, and have to be passed to a validator
 */
pub class Declarator {

    // Path to the root directory of the package
    let  _packageDir : Path;

    // The root of all declarations
    let dmut _root = copy ModuleSymbol (EOF_WORD, EOF_WORD, "", isGlobal-> true);

    // The root of all foreign declaration (imported packages)
    let dmut _foreignRoot = copy ModuleSymbol (EOF_WORD, EOF_WORD, "", isGlobal-> true);

    // The list of core use declaration, to insert in module symbols
    let mut _coreModules : [dmut &Symbol] = [];

    // The package being declared (root directory)
    let dmut _currentPackDir = copy List!{Path} ();

    /**
     * Create a new empty declarator
     */
    pub self (packageDir : Path) with
        _packageDir = packageDir
    {}

    /**
     * Transform a declaration syntax into a symbol tree
     * @params: 
     *    - root: the root to declare
     * @throws: &ErrorMsg
     */
    pub fn declareGlobal (mut self, root : &Declaration, packageDir : Path)-> dmut &Symbol
        throws ErrorMsg
    {
        self._currentPackDir:.push (packageDir);
        self:.declare (root, parent-> alias self._root, protection-> Protection::PUBLIC);
        self:.finalizeDeclaration (alias self._root);
        alias self._root
    } exit {
        self._currentPackDir:.pop ();
    }

    /**
     * Transform a declaration syntax into a symbol tree, that won't be validated but is accessible during validation
     * @params:
     *    - root: the root to declare
     * @throws: &ErrorMsg
     * */
    pub fn declareExtern (mut self, root : &Declaration, packageDir : Path)-> dmut &Symbol
        throws ErrorMsg
    {
        self._currentPackDir:.push (packageDir);
        self:.declare (root, parent-> alias self._foreignRoot, protection-> Protection::PUBLIC);
        alias self._foreignRoot
    } exit {
        self._currentPackDir:.pop ();
    }

    /**
     * Compute the list of use decl to implicitely insert during module declaration
     * This list is the list of core modules computed from the core module tree
     * */
    pub fn computeCoreUseDecls (mut self)
        throws ErrorMsg
    {
        {
            for p in global::core_::UseCoreModules::members {
                self._coreModules ~= self:.finalizeUse (alias self._foreignRoot, p, EMPTY_EXPR, false);
            }
        } catch {
            err : &ErrorMsg => {
                let mut notes : [mut &ErrorMsg] = copy [err];
                notes ~= copy [copy ErrorMsg::note (EOF_WORD, format (DeclareErrorMessage::EXPECT_CORE_MODULES, p.toStr (sep-> "::")), oneLine-> true)
                               for p in global::core_::UseCoreModules::members];

                throw copy ErrorMsg::fatal (EOF_WORD, format (DeclareErrorMessage::MALFORMED_CORE),
                                            forceVerbose-> true,
                                            notes-> notes);
            }
        }
    }

    /**
     * Finalize the symbols declared within the extern foreign module
     * */
    pub fn finalizeExternDeclaration (mut self)
        throws ErrorMsg
    {
        self:.finalizeDeclaration (alias self._foreignRoot);
    }

    /**
     * Transform a declaration syntax into a symbol tree
     * @params: 
     *    - root: the root to declare
     * @throws: &ErrorMsg
     */
    pub fn declare (mut self, root : &Declaration, dmut parent : &Symbol, protection : Protection = Protection::PRIVATE)-> dmut &Symbol
        throws ErrorMsg
    {
        match root {
            m : &ModuleDecl => {
                return self:.declareModule (m, alias parent, protection-> protection);
            }
            block : &BlockDecl => {
                for i in block.getDeclarations () {
                    // If block is just a set, then protection has no meaning
                    let inProt = if (block.isSet ()) { protection } else { block.getProtection () };
                    self:.declare (i, alias parent, protection-> inProt);
                }
                return alias EMPTY_SYMBOL;
            }
            im : &ImportDecl => {
                return self:.declareImport (im, alias parent, protection-> protection);
            }
            cl : &ClassDecl => {
                return self:.declareClass (cl, alias parent, protection-> protection);
            }
            t : &TemplateDecl => {
                return self.declareTemplate (t, alias parent, protection-> protection);
            }
            ex : &ExternBlockDecl => {
                return self.declareExternBlock (ex, alias parent, protection-> protection);
            }
            f : &FunctionDecl => {
                return self.declareFunction (f, alias parent, protection-> protection, isMethod-> false);
            }
            m : &MacroDecl => {
                return self.declareMacro (m, alias parent, protection-> protection);
            }
            en : &EnumDecl => {
                return self.declareEnum (en, alias parent, protection-> protection);
            }
            ak : &AkaDecl => {
                return self.declareAka (ak, alias parent, protection-> protection);
            }
            tr : &TraitDecl => {
                return self:.declareTrait (tr, alias parent, protection-> protection);
            }
            gl : &GlobalDecl => {
                return self.declareGlobal (gl, alias parent, protection-> protection);
            }
            u : &UseDecl => {
                return self.declareUse (u, alias parent);
            }
            u : &UnitTestDecl => {
                return self.declareUnitTest (u, alias parent);
            }
            _ => {
                throw copy ErrorMsg::fatal (root.getLoc (), DeclareErrorMessage::UNEXPECTED_IN_MODULE);
            }
        }
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================            MODULE            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Declare a module (global or not)
     * @params: 
     *   - module: the module to declare
     *   - parent: the parent symbol that is declaring the module
     * @info: self._imported is updated if the module is global, as well a self._root
     */
    fn declareModule (mut self, module : &ModuleDecl, dmut parent : &Symbol, protection : Protection = Protection::PRIVATE, importLoc : &Word = EOF_WORD, withInner : bool = true)-> dmut &ModuleSymbol
        throws ErrorMsg
    {
        let name = if (module.isGlobal ()) {
            if (module.getPath ().isEof ()) {
                Path (module.getLoc ().filename).stripExtension ().file ()
            } else {
                module.getPath ().str
            }
        } else {
            module.getLoc ().str
        };

        let dmut ret = copy ModuleSymbol (copy Word (name, module.getLoc ()), importLoc-> importLoc, module.getComments (), isExtern-> false, isGlobal-> module.isGlobal (), protection-> protection);
        if (module.isGlobal ()) {
            let fileLoc = Path (module.getLoc ().filename).stripExtension ().file ();
            if (fileLoc != name) {
                throw copy ErrorMsg::fatal (module.getPath (), format (DeclareErrorMessage::WRONG_MODULE_NAME, module.getPath (), Path (name).addExtension (CommonVars::YMIR_EXTENSION).toStr ()));
            }
        }

        let mut replaced = false;

        // Check wether the module is already imported within the current package
        let already = parent.getLocalSymbols (name, protection-> Protection::PRIVATE);
        for a in already[] {
            match a {
                m : &ModuleSymbol => { // a module with the same name is already present in the referent
                    if (name != Keys::LIB_ROOT) {
                        let mut notes : [mut &ErrorMsg] = [];
                        if (!importLoc.isEof ()) {
                            notes ~= [copy ErrorMsg::note (importLoc, format (DeclareErrorMessage::IN_IMPORT, importLoc.str))];
                        }

                        if (!m.getImportLoc ().isEof ()) {
                            notes ~= [copy ErrorMsg::note (m.getImportLoc (), format (DeclareErrorMessage::IN_IMPORT, m.getImportLoc ().str))];
                        } else {
                            notes ~= [copy ErrorMsg::note (m.getLoc (), DeclareErrorMessage::DECLARED_HERE)];
                        }

                        throw copy ErrorMsg::fatal (ret.getLoc (), format (DeclareErrorMessage::SHADOWING_DECL, ret.getLoc ().str), notes-> notes);
                    } else {
                        if let dmut z : &ModuleSymbol = self:.getMutableSymbol (m) {
                            ret = alias z;
                        } else panic;

                        replaced = true;
                    }
                }
            }
        }

        if !replaced {
            parent:.insert (alias ret, replace-> false);
        }

        if (withInner) {
            for i in module.getDeclarations () {
                self:.declare (i, alias ret);
            }
        }

        return alias ret;
    }

    /**
     * Declare a use declaration
     * @params:
     *    - use_: the declaration
     *    - parent: the current context
     * */
    fn declareUse (self, use_ : &UseDecl, dmut parent : &Symbol)-> dmut &Symbol {
        parent:.insertUse (use_);
        alias EMPTY_SYMBOL
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================            IMPORT            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Declare an importation statement
     * @params: 
     *   - im: the importation to declare
     *   - parent: the parent of the importation (module that is making the import)
     *   - protection: the protection of the importation
     */
    fn declareImport (mut self, im : &ImportDecl, dmut parent : &Symbol, protection : Protection)-> dmut &Symbol
        throws ErrorMsg
    {
        let name = im.getModuleName ().str;
        let (importPath, isSibling) = self.selectImportFile (im, parent);

        // Check wether the module is already imported within the current package
        let already = parent.getLocalSymbols (name, protection-> Protection::PRIVATE);
        let importLoc = im.getModuleName ();
        for a in already[] {
            match a {
                m : &ModuleSymbol => { // a module with the same name is already present in the referent
                    let mut notes : [mut &ErrorMsg] = [];
                    if (!importLoc.isEof ()) {
                        notes ~= [copy ErrorMsg::note (importLoc, format (DeclareErrorMessage::IN_IMPORT, importLoc.str))];
                    }

                    if (!m.getImportLoc ().isEof ()) {
                        notes ~= [copy ErrorMsg::note (m.getImportLoc (), format (DeclareErrorMessage::IN_IMPORT, m.getImportLoc ().str))];
                    } else {
                        notes ~= [copy ErrorMsg::note (m.getLoc (), DeclareErrorMessage::DECLARED_HERE)];
                    }

                    throw copy ErrorMsg::fatal (importLoc, format (DeclareErrorMessage::SHADOWING_DECL, importLoc.str), notes-> notes);
                }
                m : &LazyModuleSymbol => {
                    let mut notes : [mut &ErrorMsg] = [];
                    if (!importLoc.isEof ()) {
                        notes ~= [copy ErrorMsg::note (importLoc, format (DeclareErrorMessage::IN_IMPORT, importLoc.str))];
                    }

                    if (!m.getImportLoc ().isEof ()) {
                        notes ~= [copy ErrorMsg::note (m.getImportLoc (), format (DeclareErrorMessage::IN_IMPORT, m.getImportLoc ().str))];
                    } else {
                        notes ~= [copy ErrorMsg::note (m.getLoc (), DeclareErrorMessage::DECLARED_HERE)];
                    }

                    throw copy ErrorMsg::fatal (importLoc, format (DeclareErrorMessage::SHADOWING_DECL, importLoc.str), notes-> notes);
                }
            }
        }

        let packageLoc = self._currentPackDir.back ();
        let dmut lazyMod = copy LazyModuleSymbol (name, importLoc, importPath, protection-> protection, packageDir-> packageLoc);
        if isSibling {
            parent:.getReferent ():.insert (alias lazyMod, replace-> false);
        } else {
            parent:.insert (alias lazyMod, replace-> false);
        }

        return alias EMPTY_SYMBOL;
    }

    /**
     * Select the path of the module to import
     * @params:
     *    - im: the importation decl
     *    - parent: the parent of the import
     * @returns:
     *    - .0: the path of the imported module
     *    - .1: true if the declared module is a sibling
     * */
    fn selectImportFile (self, im : &ImportDecl, parent : &Symbol)-> (Path, bool)
        throws ErrorMsg
    {
        let packageLoc = self._currentPackDir.back ();
        if (im.isChild ()) {
            let child = packageLoc.push (parent.getPath ().asStdPath ()).push (im.getModuleName ().str).addExtension (CommonVars::YMIR_EXTENSION);
            if (!fs::sys::isFile (child)) {
                throw copy ErrorMsg::fatal (im.getModuleName (),
                                            end-> im.getSubLoc (), format (DeclareErrorMessage::NO_SUCH_FILE_ONE, child.toStr (sep-> "/")));
            }

            return (child, false);
        } else if (im.isSibling ()) {
            let sibling = packageLoc.push (parent.getPath ().asStdPath ().parent ()).push (im.getModuleName ().str).addExtension (CommonVars::YMIR_EXTENSION);
            if (!fs::sys::isFile (sibling)) {
                throw copy ErrorMsg::fatal (im.getModuleName (),
                                       end-> im.getSubLoc (), format (DeclareErrorMessage::NO_SUCH_FILE_ONE, sibling.toStr (sep-> "/")));
            }

            return (sibling, true);
        } else {
            let child = packageLoc.push (parent.getPath ().asStdPath ()).push (im.getModuleName ().str).addExtension (CommonVars::YMIR_EXTENSION);
            let sibling = packageLoc.push (parent.getPath ().asStdPath ().parent ()).push (im.getModuleName ().str).addExtension (CommonVars::YMIR_EXTENSION);

            if (fs::sys::isFile (sibling) && fs::sys::isFile (child)) {
                throw copy ErrorMsg::fatal (im.getModuleName (), format (DeclareErrorMessage::CONFLICT_MODULES, child.toStr (sep-> "/"), sibling.toStr (sep-> "/")));
            } else if (!fs::sys::isFile (sibling) && !fs::sys::isFile (child)) {
                throw copy ErrorMsg::fatal (im.getModuleName (), format (DeclareErrorMessage::NO_SUCH_FILE, child.toStr (sep-> "/"), sibling.toStr (sep-> "/")));
            }

            return if fs::sys::isFile (sibling) {
                (sibling, true)
            } else { (child, false) };
        }
    }


    /**
     * Finalize the declaration of a lazy module
     * @params:
     *    - parent: the parent module containing the import
     *    - lazyMod: the module being imported (and addressed)
     * @returns: an empty symbol
     * */
    pub fn finalizeImportDecl (mut self, lazyMod : &LazyModuleSymbol)-> dmut &ModuleSymbol
        throws ErrorMsg
    {
        match lazyMod.getFinalized () { // already finalized
            m : &ModuleSymbol => {
                if let dmut ret : &ModuleSymbol = self:.getMutableSymbol (m) {
                    return alias ret;
                }

                panic;
            }
        }

        if let dmut lM : &LazyModuleSymbol = self:.getMutableSymbol (lazyMod) {
            return alias self:.finalizeImportDecl (alias lM);
        }

        panic;
    }

    /**
     * Finalize the declaration of a lazy module
     * @params:
     *    - parent: the parent module containing the import
     *    - lazyMod: the module being imported (and addressed)
     * @returns: an empty symbol
     * */
    fn finalizeImportDecl (mut self, dmut lazyMod : &LazyModuleSymbol)-> dmut &ModuleSymbol
        throws ErrorMsg
    {
        let dmut referent = alias lazyMod:.getReferent ();
        let module = {
            (copy SyntaxVisitor (lazyMod.getImportPath ())):.read ()
        } catch {
            err : &ErrorMsg => {
                throw err.withNote (copy [copy ErrorMsg::note (lazyMod.getImportLoc (), format (DeclareErrorMessage::IN_IMPORT, lazyMod.getModuleName ()))]);
            }
            _ => {
                throw copy ErrorMsg::fatal (lazyMod.getImportLoc (), format (DeclareErrorMessage::NO_SUCH_FILE_ONE, lazyMod.getImportPath ().toStr (sep-> "::")),
                                            notes-> copy [copy ErrorMsg::note (lazyMod.getImportLoc (), format (DeclareErrorMessage::IN_IMPORT, lazyMod.getModuleName ()))]);
            }
        }

        lazyMod:.getReferent ():.remove (alias lazyMod);
        {
            self._currentPackDir:.push (lazyMod.getPackageDir ());
            let dmut ret = self:.declareModule (module, alias referent, protection-> lazyMod.getProtection (), importLoc-> lazyMod.getImportLoc (), withInner-> false);
            lazyMod:.setFinalized (ret);

            // we need to set finalized before declaring the inside of the module to avoid loop, or undefined inner references
            for i in module.getDeclarations () {
                self:.declare (i, alias ret);
            }

            self:.finalizeDeclaration (alias ret);
            return alias ret;
        } exit {
            self._currentPackDir:.pop ();
        }
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================            CLASS             =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Declare the symbol of a class
     * @params:
     *   - cl: the class to declare
     *   - parent: the module that is declaring the class
     *   - protection: the protection of the class
     */
    fn declareClass (mut self, cl : &ClassDecl, dmut parent : &Symbol, protection : Protection)-> dmut &Symbol
        throws ErrorMsg
    {
        let syms = parent.getLocalSymbols (cl.getLoc ().str, protection-> Protection::PRIVATE);
        for s in syms[] match s {
            ModuleSymbol () => {}
            TemplateSymbol () => {}
            _ => {
                throw copy ErrorMsg::fatal (cl.getLoc (),
                                            format (DeclareErrorMessage::SHADOWING_DECL, cl.getLoc ().str),
                                            notes-> copy [copy ErrorMsg::note (s.getLoc (), "")]);
            }
        }

        let (isAbstract, isFinal) = self.validateAbstractFinal (cl.getLoc (), cl.getAttributes (), cl.isStruct ());
        let dmut clSym = copy ClassSymbol (cl.getLoc (), cl.getComments (), ancestor-> cl.getAncestor (), isAbstract-> isAbstract, isFinal-> isFinal, isMovable-> (cl.isStruct () && !cl.isRecord ()), isStruct-> cl.isStruct (), protection-> protection);
        parent:.insert (alias clSym, replace-> false);

        for d in cl.getDeclarations () {
            self:.declareInnerClass (d, alias clSym, protection-> Protection::PROTECTED);
        }

        alias clSym
    }


    /**
     * Validate the custom attributes of a class definition
     * @params:
     *   - attributes: the list of custom attributes of the class
     * @returns:
     *   - .0: isAbstract
     *   - .1: isFinal
     *   - .2: isMovable
     * @throws:
     *   - ErrorMsg: if (isAbstract && isFinal), or if an attributes is not defined for class
     */
    fn validateAbstractFinal (self, loc : &Word, attributes : [AttributeWord], isStruct : bool)-> (bool, bool)
        throws ErrorMsg
    {
        let mut isAbstract = false, mut isFinal = false;
        let mut abstractLoc = EOF_WORD, mut finalLoc = EOF_WORD;
        for a in attributes {

            match a.attr {
                Attributes::ABSTRACT => {
                    if (isStruct) throw copy ErrorMsg::fatal (a.loc, format (DeclareErrorMessage::UNDEFINED_ATTRIBUTE_FOR_STRUCT, a.attr),
                                                              notes-> copy [copy ErrorMsg::note (loc, "")]);

                    isAbstract = true;
                    abstractLoc = a.loc;
                    if (isFinal) throw copy ErrorMsg::fatal (a.loc, DeclareErrorMessage::ABSTRACT_AND_FINAL,
                                                             notes-> copy [copy ErrorMsg::note (finalLoc, ""), copy ErrorMsg::note (loc, "")]);
                }
                Attributes::FINAL => {
                    if (isStruct) throw copy ErrorMsg::fatal (a.loc, format (DeclareErrorMessage::UNDEFINED_ATTRIBUTE_FOR_STRUCT, a.attr),
                                                              notes-> copy [copy ErrorMsg::note (loc, "")]);

                    isFinal = true;
                    finalLoc = a.loc;
                    if (isAbstract) throw copy ErrorMsg::fatal (a.loc, DeclareErrorMessage::ABSTRACT_AND_FINAL,
                                                                notes-> copy [copy ErrorMsg::note (abstractLoc, ""), copy ErrorMsg::note (loc, "")]);
                }
                _ => {
                    throw copy ErrorMsg::fatal (a.loc, format (DeclareErrorMessage::UNDEFINED_ATTRIBUTE_FOR_CLASS, a.attr),
                                                notes-> copy [copy ErrorMsg::note (loc, "")]);
                }
            }
        }

        (isAbstract, isFinal)
    }


    /**
     * Declare the content of a class
     * @params:
     *   - d: the declaration to transform into symbol
     *   - cl: the class symbol that is filled
     *   - protection: the current protection of the symbol to declare
     */
    pub fn declareInnerClass (mut self, current : &Declaration, dmut cl : &ClassSymbol, protection : Protection)
        throws ErrorMsg
    {
        match current {
            dl : &BlockDecl => {
                let inProt = if (dl.isSet ()) { protection } else { dl.getProtection () };
                for i in dl.getDeclarations () {
                    self:.declareInnerClass (i, alias cl, protection-> inProt);
                }
            }
            cstr : &ConstructorDecl => {
                self.declareConstructor (cstr, alias cl, protection-> protection);
            }
            dtor : &DestructorDecl => {
                self.declareDestructor (dtor, alias cl);
            }
            im : &ImplDecl => {
                self:.declareImpl (im, alias cl, protection-> protection);
            }
            gl : &GlobalDecl => {
                self.declareFieldClass (gl, alias cl, protection-> protection);
            }
            t : &TemplateDecl => {
                self.declareTemplate (t, alias cl, protection-> protection);
            }
            c : &CondBlockDecl => {
                self.declareCondBlockClass (c, alias cl);
            }
            wrap : &ExpressionWrapperDecl => {
                self.declareAssertClass (wrap, alias cl);
            }
            im : &ImportDecl => {
                self:.declareImport (im, alias cl, protection-> protection);
            }
            f : &FunctionDecl => {
                self.declareFunction (f, alias cl, protection-> protection, isMethod-> true);
            }
            u : &UseDecl => {
                self.declareUse (u, alias cl);
            }
            _ => {
                throw copy ErrorMsg::fatal (current.getLoc (), DeclareErrorMessage::UNEXPECTED_IN_CLASS);
            }
        }
    }

    /**
     * Declare a class constructor
     * @params:
     *   - cstr: the constructor to declare
     *   - cl: the parent class
     *   - protection: the protection of the constructor
     */
    pub fn declareConstructor (self, cstr : &ConstructorDecl, dmut cl : &ClassSymbol, protection : Protection)-> dmut &ConstructorSymbol
        throws ErrorMsg
    {
        let isUnsafe = self.validateUnsafeCtor (cstr.getAttributes ());

        let dmut cstrSym = copy ConstructorSymbol (cstr.getLoc (), cstr.getComments (), cstr, alias cl, protection-> protection, isUnsafe-> isUnsafe);
        cl:.insert (alias cstrSym, replace-> false);

        alias cstrSym
    }

    /**
     * Declare the destructor of the class
     * @params:
     *   - dtor: the destructor
     *   - cl: the parent class
     * @throws:
     *    - &ErrorMsg: if there are multiple destructor
     */
    pub fn declareDestructor (self, dtor : &DestructorDecl, dmut cl : &ClassSymbol)-> dmut &DestructorSymbol
        throws ErrorMsg
    {
        match cl.getDestructor () {
            EmptySymbol () => {}
            _ => {
                throw copy ErrorMsg::fatal (dtor.getLoc (), DeclareErrorMessage::MULTIPLE_DESTRUCTOR,
                                            notes-> copy [copy ErrorMsg::note (cl.getDestructor ().getLoc (), "")]);
            }
        }

        if (cl.isStruct () && !cl.isMovable ()) {
            throw copy ErrorMsg::fatal (cl.getLoc (), end-> dtor.getLoc (), DeclareErrorMessage::DTOR_IN_RECORD);
        }

        let dmut dtorSym = copy DestructorSymbol (dtor.getLoc (), dtor.getComments (), dtor, alias cl);
        cl:.setDestructor (alias dtorSym);

        alias dtorSym
    }

    /**
     * Validate the custom attributes of a ctor definition
     * @params:
     *    - attributes: the list of custom attributes of the ctor
     * @returns: true if the ctor is unsafe
     * @throws: if an attribute is undefined for ctor
     * */
    fn validateUnsafeCtor (self, attributes : [AttributeWord])-> bool
        throws ErrorMsg
    {
        let mut isUnsafe = false;
        for a in attributes {
            match a.attr {
                Attributes::UNSAFE => { isUnsafe = true; }
                _ => {
                    throw copy ErrorMsg::fatal (a.loc, format (DeclareErrorMessage::UNDEFINED_ATTRIBUTE_FOR_CTOR, a.attr));
                }
            }
        }

        isUnsafe
    }

    /**
     * Declare an implementation
     * @params:
     *   - impl: the implementation to declare
     *   - cl: the parent class
     */
    fn declareImpl (mut self, im : &ImplDecl, dmut cl : &ClassSymbol, protection : Protection)
        throws ErrorMsg
    {
        let dmut implSym = copy ImplSymbol (im.getLoc (), im.getComments (), im, protection-> protection);
        for i in im.getDeclarations () {
            self:.declareInnerImpl (i, alias implSym, alias cl, protection-> Protection::PROTECTED);
        }

        cl:.insert (alias implSym, replace-> false);
    }

    /**
     * Declare the content of an implementation
     * @params:
     *   - current: the declaration to transform
     *   - im: the implementation that is being declared
     *   - protection: the protection of the implementation
     */
    fn declareInnerImpl (mut self, current : &Declaration, dmut im : &ImplSymbol, dmut cl : &ClassSymbol, protection : Protection)
        throws ErrorMsg
    {
        match current {
            dl : &BlockDecl => {
                for i in dl.getDeclarations () {
                    self:.declareInnerImpl (i, alias im, alias cl, protection-> dl.getProtection ());
                }
            }
            f : &FunctionDecl => {
                self.declareFunction (f, alias im, protection-> protection, isMethod-> true);
            }
            wrap : &ExpressionWrapperDecl => {
                self.declareAssertClass (wrap, alias cl);
            }
            imp : &ImportDecl => {
                self:.declareImport (imp, alias cl, protection-> protection);
            }
            _ => {
                throw copy ErrorMsg::fatal (current.getLoc (), DeclareErrorMessage::UNEXPECTED_IN_IMPL);
            }
        }
    }

    /**
     * Declare a field in a class
     * @params:
     *   - field: the field to declare
     *   - cl: the class symbol
     *   - protection: the protection of the field
     */
    fn declareFieldClass (self, field : &GlobalDecl, dmut cl : &ClassSymbol, protection : Protection)
    {
        cl:.addField (field.getContent (), field.getComments (), protection-> protection)
    }

    /**
     * Declare an assertion in a class
     * @params:
     *    - wrap: the assertion to declare
     *    - cl: the class symbol
     */
    fn declareAssertClass (self, wrap : &ExpressionWrapperDecl, dmut cl : &ClassSymbol) {
        cl:.addAssertion (wrap.getContent (), wrap.getComments ());
    }

    /**
     * Declare a conditional block in a class
     * @params:
     *    - c: the conditional to declare
     *    - cl: the class symbol
     */
    fn declareCondBlockClass (self, c : &CondBlockDecl, dmut cl : &ClassSymbol) {
        cl:.addCondBlock (c);
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================          UNITTEST           ==========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Declare a unittest
     * @params:
     *    - u: the unittest to declare
     *    - parent: the parent of the declaration
     * */
    fn declareUnitTest (self, u : &UnitTestDecl, dmut parent : &Symbol)-> dmut &Symbol {
        let dmut unitSym = copy UnitTestSymbol (u.getLoc (), u.getComments (), u);
        parent:.insertUnitTest (alias unitSym);
        unitSym:.setReferent (alias parent);

        alias unitSym
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================          FUNCTIONS           =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Declare a function declaration
     * @params:
     *   - func: the function to declare
     *   - parent: the parent of the declaration
     *   - protection: the protection of the declaration
     */
    fn declareFunction (self, func : &FunctionDecl, dmut parent : &Symbol, protection : Protection, isMethod : bool, isExtern : bool = false, lang : [c8] = "")-> dmut &Symbol
        throws ErrorMsg
    {
        self.validateShadowingFunction (func.getLoc (), parent);
        let (isFinal, isUnsafe_) = self.validateFinalUnsafeFunction (func.getAttributes ());
        let isCVariadic = func.getFunctionProto ().isVariadic ();
        if (isCVariadic && (!isExtern || lang != Keys::CLANG)) {
            throw copy ErrorMsg::fatal (func.getLoc (), DeclareErrorMessage::DECL_VARIADIC_FUNC);
        }

        let isUnsafe = if (isExtern && lang == Keys::CLANG) {
            true
        } else { isUnsafe_ };

        let dmut funcSym = copy FunctionSymbol (func.getLoc (), func.getComments (), func, isMethod, isOver-> func.isOver (), isFinal-> isFinal, isUnsafe-> isUnsafe, isCVariadic-> isCVariadic, protection-> protection);
        parent:.insert (alias funcSym, replace-> false);

        alias funcSym
    }

    /**
     * Validate that the function is not shadowing another declaration of a different type
     * @params:
     *   - loc: the location of the function decl
     *   - parent: the parent symbol in which the function will be declared
     */
    fn validateShadowingFunction (self, loc : &Word, parent : &Symbol)
        throws ErrorMsg
    {
        let syms = parent.getLocalSymbols (loc.str, protection-> Protection::PRIVATE);
        for s in syms[] match s {
            FunctionSymbol () => {}
            ModuleSymbol () => {}
            TemplateSymbol () => {}
            _ => {
                throw copy ErrorMsg::fatal (loc,
                                            format (DeclareErrorMessage::SHADOWING_DECL, loc.str),
                                            notes-> copy [copy ErrorMsg::note (s.getLoc (), "")]);
            }
        }
    }

    /**
     * Validate the custom attributes of a function definition
     * @params:
     *   - attributes: the list of custom attributes of the function
     * @returns: (isFinal, isUnsafe)
     * @throws:
     *   - ErrorMsg:  if an attributes is not defined for function
     */
    fn validateFinalUnsafeFunction (self, attributes : [AttributeWord])-> (bool, bool)
        throws ErrorMsg
    {
        let mut isFinal = false, mut isUnsafe = false;
        for a in attributes {
            match a.attr {
                Attributes::FINAL => {
                    isFinal = true;
                }
                Attributes::UNSAFE => {
                    isUnsafe = true;
                }
                Attributes::FIELD => {}
                Attributes::INLINE => {}
                _ => {
                    throw copy ErrorMsg::fatal (a.loc, format (DeclareErrorMessage::UNDEFINED_ATTRIBUTE_FOR_FUNCTION, a.attr));
                }
            }
        }
        
        (isFinal, isUnsafe)
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================           TEMPLATE           =========================
     * ================================================================================
     * ================================================================================
     */
    

    /**
     * Declare a template declaration
     * @params: 
     *   - tm: the template to declare
     *   - parent: the parent symbol of the declaration
     *   - protection: the protection of the declaration
     */
    fn declareTemplate (self, tm : &TemplateDecl, dmut parent : &Symbol, protection : Protection)-> dmut &Symbol
        throws ErrorMsg
    {
        self.validateShadowingTemplates (tm.getParameters ());
        let dmut templSym = copy TemplateSymbol (tm.getLoc (), tm.getComments (), tm, protection-> protection);

        parent:.insert (alias templSym, replace-> false);

        alias templSym
    }

    /**
     * Verify that there is no shadowing in the name of the template parameters
     * @params: 
     *   - params: the template parameters
     */
    fn validateShadowingTemplates (self, params : [&Expression])
        throws ErrorMsg
    {
        if (params.len == 0us) return;
        for i in 0us .. params.len - 1us {
            for j in i + 1us .. params.len {
                let fst = match params [i] {
                    v : &TemplateVariadicVarExpr => { v.getLoc ().str }
                    v : &TemplateOfVarExpr       => { v.getLoc ().str }
                    v : &TemplateVarExpr         => { v.getLoc ().str }
                    v : &VarDeclExpr             => { v.getLoc ().str }
                    v : &VarExpr                 => { v.getLoc ().str }
                    _                            => ""
                };

                let shadow = match params [j] {
                    v : &TemplateVariadicVarExpr => { v.getLoc ().str == fst }
                    v : &TemplateOfVarExpr       => { v.getLoc ().str == fst }
                    v : &TemplateVarExpr         => { v.getLoc ().str == fst }
                    v : &VarDeclExpr             => { v.getLoc ().str == fst }
                    v : &VarExpr                 => { v.getLoc ().str == fst }
                    _                            => { false }
                }
                
                if (shadow) {
                    throw copy ErrorMsg::fatal (params [j].getLoc (),
                                                format (DeclareErrorMessage::SHADOWING_DECL, params [i].getLoc ().str),
                                                notes-> copy [copy ErrorMsg::note (params [i].getLoc (), "")]);
                }                
            }
        }
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================          EXTERNAL            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Declare an external language block
     * @params: 
     *   - decl: the block to declare
     *   - parent: the parent module of the declaration
     *   - protection: the protection of the declaration
     */
    fn declareExternBlock (self, decl : &ExternBlockDecl, dmut parent : &Symbol, protection : Protection)-> dmut &Symbol
        throws ErrorMsg
    {
        let path = self.validateSpaceLanguage (decl.getLanguage (), decl.getNamespace ());
        self.declareInnerExternal (decl.getDeclaration (), alias parent, protection-> protection, lang-> decl.getLanguage ().str, path-> path);

        return alias EMPTY_SYMBOL;
    }

    /**
     * Declare the content of an external block
     * @params: 
     *    - decl: the inner declaration to declare
     *    - parent: the parent of the external block
     *    - protection: the protection of the declaration
     *    - lang: the language of the extern block
     *    - path: the path of the extern block
     */
    fn declareInnerExternal (self, decl : &Declaration, dmut parent : &Symbol, protection : Protection, lang : [c8], path : Path)
        throws ErrorMsg
    {
        match decl {
            f : &FunctionDecl => {
                let dmut sym = self.declareFunction (f, alias parent, protection-> protection, isMethod-> false, isExtern-> true, lang-> lang);
                sym:.setExternalLanguage (lang, path);
            }
            bl : &BlockDecl => {
                for i in bl.getDeclarations () {
                    self.declareInnerExternal (i, alias parent, protection-> protection, lang, path);
                }
            }
            glb : &GlobalDecl => {
                let dmut sym = self.declareGlobal (glb, alias parent, protection-> protection, isExtern-> true);
                sym:.setExternalLanguage (lang, path);
            }
            _ => {
                throw copy ErrorMsg::fatal (decl.getLoc (), DeclareErrorMessage::UNEXPECTED_IN_EXTERN);
            }
        }
    }
    
    /**
     * Verify that the path is empty or applicable for the given language
     * @params: 
     *   - lang: the language of the extern
     *   - space: the namespace of the extern
     */
    fn validateSpaceLanguage (self, lang : &Word, space : &Expression)-> Path
        throws ErrorMsg
    {
        let (empty, path) = match space {
            EmptyExpression () => { (true, Path ("")) }
            _ => {
                (false, self.toPath (space))
            }
        }
        
        if (lang != Keys::CPPLANG && lang != Keys::DLANG && !empty) {
            throw copy ErrorMsg::fatal (lang, format (DeclareErrorMessage::NAMESPACE_EXTERNAL, lang.str),
                                        notes-> copy [copy ErrorMsg::note (space.getLoc (), "")]);
        }

        path
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================            MACRO             =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Declare a macro
     * @params: 
     *    - m: the macro to declare
     *    - parent: the parent module of the declaration
     *    - protection: the protection of the declaration
     */
    fn declareMacro (self, m : &MacroDecl, dmut parent : &Symbol, protection : Protection)-> dmut &Symbol
        throws ErrorMsg
    {
        let syms = parent.getLocalSymbols (m.getLoc ().str, protection-> Protection::PRIVATE);
        for s in syms[] {
            match s {
                ModuleSymbol () => {}
                TemplateSymbol () => {}
                _ => {
                    throw copy ErrorMsg::fatal (m.getLoc (),
                                                format (DeclareErrorMessage::SHADOWING_DECL, m.getLoc ().str),
                                                notes-> copy [copy ErrorMsg::note (s.getLoc (), "")]);
                }
            }
        }
        
        let dmut macroSym = copy MacroSymbol (m.getLoc (), m.getComments (), protection-> protection);
        for d in m.getDeclarations () {
            self.declareInnerMacro (d, alias macroSym, protection-> Protection::PUBLIC);
        }

        parent:.insert (alias macroSym, replace-> false);
        alias macroSym
    }

    /**
     * Declare the content of a macro definition
     * @params: 
     *   - decl: the declaration to declare
     *   - m: the parent macro symbol
     *   - protection: the protection of the declaration
     */
    fn declareInnerMacro (self, decl : &Declaration, dmut m : &MacroSymbol, protection : Protection)
        throws ErrorMsg
    {
        match decl {
            bl : &BlockDecl => {
                for d in bl.getDeclarations () {
                    self.declareInnerMacro (d, alias m, protection-> bl.getProtection ());
                }
            }
            ctor : &MacroRuleDecl => {
                if (ctor.isConstructor ()) {
                    let dmut sym = copy MacroConstructorSymbol (ctor.getLoc (), ctor.getComments (), ctor, protection);
                    m:.insert (alias sym, replace-> false);
                } else {
                    let dmut sym = copy MacroRuleSymbol (ctor.getLoc (), ctor.getComments (), ctor, protection);
                    m:.insert (alias sym, replace-> false);
                }                
            }
            u : &UseDecl => {
                self.declareUse (u, alias m);
            }
            _ => {
                throw copy ErrorMsg::fatal (decl.getLoc (), DeclareErrorMessage::UNEXPECTED_IN_MACRO);
            }
        }
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================             ENUM             =========================
     * ================================================================================
     * ================================================================================
     */


    /**
     * Declare the symbol of a enumeration
     * @params: 
     *   - st: the enum to declare
     *   - parent: the module that is declaring the enum
     *   - protection: the protection of the enum
     */
    fn declareEnum (self, en : &EnumDecl, dmut parent : &Symbol, protection : Protection)-> dmut &Symbol
        throws ErrorMsg
    {
        let syms = parent.getLocalSymbols (en.getLoc ().str, protection-> Protection::PRIVATE);
        for s in syms[] match s {
            ModuleSymbol () => {}
            TemplateSymbol () => {}
            _ => {
                throw copy ErrorMsg::fatal (en.getLoc (),
                                            format (DeclareErrorMessage::SHADOWING_DECL, en.getLoc ().str),
                                            notes-> copy [copy ErrorMsg::note (s.getLoc (), "")]);
            }
        }


        let dmut enSym = copy EnumSymbol (en.getLoc (), en.getComments (), en, protection);
        parent:.insert (alias enSym, replace-> false);
        
        alias enSym
    }
    

    /*!
     * ================================================================================
     * ================================================================================
     * =========================             AKA              =========================
     * ================================================================================
     * ================================================================================
     */


    /**
     * Declare the symbol of an aka
     * @params: 
     *   - st: the aka to declare
     *   - parent: the module that is declaring the aka
     *   - protection: the protection of the aka
     */
    fn declareAka (self, en : &AkaDecl, dmut parent : &Symbol, protection : Protection)-> dmut &Symbol
        throws ErrorMsg
    {
        let syms = parent.getLocalSymbols (en.getLoc ().str, protection-> Protection::PRIVATE);
        for s in syms[] match s {
            ModuleSymbol () => {}
            TemplateSymbol () => {}
            _ => {
                throw copy ErrorMsg::fatal (en.getLoc (),
                                            format (DeclareErrorMessage::SHADOWING_DECL, en.getLoc ().str),
                                            notes-> copy [copy ErrorMsg::note (s.getLoc (), "")]);
            }
        }

        let dmut enSym = copy AkaSymbol (en.getLoc (), en.getComments (), en, protection);
        parent:.insert (alias enSym, replace-> false);
        
        alias enSym
    }


    /*!
     * ================================================================================
     * ================================================================================
     * =========================            TRAIT             =========================
     * ================================================================================
     * ================================================================================
     */



    /**
     * Declare an implementation 
     * @params: 
     *   - impl: the implementation to declare
     *   - cl: the parent class
     */
    fn declareTrait (mut self, tr : &TraitDecl, dmut parent : &Symbol, protection : Protection)-> dmut &Symbol
        throws ErrorMsg
    {
        let syms = parent.getLocalSymbols (tr.getLoc ().str, protection-> Protection::PRIVATE);
        for s in syms[] match s {
            ModuleSymbol () => {}
            TemplateSymbol () => {}
            _ => {
                throw copy ErrorMsg::fatal (tr.getLoc (),
                                       format (DeclareErrorMessage::SHADOWING_DECL, tr.getLoc ().str),
                                       notes-> copy [copy ErrorMsg::note (s.getLoc (), "")]);
            }
        }
        
        let dmut traitSym = copy TraitSymbol (tr.getLoc (), tr.getComments (), tr, protection-> protection);
        for i in tr.getDeclarations () {
            self:.declareInnerTrait (i, alias traitSym, protection-> Protection::PROTECTED);
        }

        parent:.insert (alias traitSym, replace-> false);
        alias traitSym
    }

    /**
     * Declare the content of a trait
     * @params: 
     *   - current: the declaration to transform
     *   - tr: the trait that is being declared
     *   - protection: the protection of the declaration inside the trait
     */
    fn declareInnerTrait (mut self, current : &Declaration, dmut tr : &TraitSymbol, protection : Protection)
        throws ErrorMsg
    {
        match current {
            dl : &BlockDecl => {
                for i in dl.getDeclarations () {
                    self:.declareInnerTrait (i, alias tr, protection-> dl.getProtection ());
                }
            }
            f : &FunctionDecl => {
                let sym = self.declareFunction (f, alias tr, protection-> protection, isMethod-> true);
                if (f.isOver ()) {
                    throw copy ErrorMsg::fatal (f.getLoc (), format (DeclareErrorMessage::NOT_OVERRIDE, sym.getPath ().toStr ()));
                }
            }
            wrap : &ExpressionWrapperDecl => {
                self.declareAssertTrait (wrap, alias tr);
            }
            imp : &ImportDecl => {
                self:.declareImport (imp, alias tr, protection-> protection);
            }
            _ => {
                throw copy ErrorMsg::fatal (current.getLoc (), DeclareErrorMessage::UNEXPECTED_IN_TRAIT);
            }
        }
    }

    /**
     * Declare an assertion in a class
     */
    fn declareAssertTrait (self, wrap : &ExpressionWrapperDecl, dmut tr : &TraitSymbol) {
        tr:.addAssertion (wrap.getContent (), wrap.getComments ());
    }


    /*!
     * ================================================================================
     * ================================================================================
     * =========================            GLOBAL            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Declare a global variable
     * @params: 
     *   - gl: the var to declare
     *   - parent: the parent module declaring the variable
     *   - protection: the protection of the declaration
     */
    fn declareGlobal (self, gl : &GlobalDecl, dmut parent : &Symbol, protection : Protection, isExtern : bool = false)-> dmut &Symbol
        throws ErrorMsg
    {
        let syms = parent.getLocalSymbols (gl.getContent ().getLoc ().str, protection-> Protection::PRIVATE);
        for s in syms[] match s {
            ModuleSymbol () => {}
            TemplateSymbol () => {}
            _ => {
                throw copy ErrorMsg::fatal (gl.getContent ().getLoc (),
                                       format (DeclareErrorMessage::SHADOWING_DECL, gl.getContent ().getLoc ().str),
                                       notes-> copy [copy ErrorMsg::note (s.getLoc (), "")]);
            }
        }

        if (gl.isStatic () && !isExtern) {
            throw copy ErrorMsg::fatal (gl.getLoc (), DeclareErrorMessage::DECL_GLOB_STATIC_NON_EXTERN);
        }

        let isThLocal = self.validateIsThreadLocal (gl.getLoc (), gl.getAttributes (), isExtern);
        let dmut glSym = copy GlobalSymbol (gl.getContent ().getLoc (),
                                            gl.getComments (),
                                            gl,
                                            protection-> protection,
                                            isExtern-> isExtern,
                                            isStatic-> gl.isStatic (),
                                            isThreadLocal-> isThLocal);

        parent:.insert (alias glSym, replace-> false);

        alias glSym
    }

    /**
     * @returns: true if the global variable is a thread local
     * @throws:
     *    - &ErrorMsg: if the attributes are malformed or not applicable
     *
     * */
    fn validateIsThreadLocal (self, loc : &Word, attrs : [AttributeWord], isExtern : bool)-> bool
        throws ErrorMsg
    {
        let mut isThread = false;
        for a in attrs {
            match a.attr {
                Attributes::THREAD => {
                    isThread = true;
                    if (isExtern) throw copy ErrorMsg::fatal (a.loc, format (DeclareErrorMessage::DECL_GLOB_THREAD_EXTERN),
                                                              notes-> copy [copy ErrorMsg::note (loc, "")]);
                }
                _ => {
                    throw copy ErrorMsg::fatal (a.loc, format (DeclareErrorMessage::UNDEFINED_ATTRIBUTE_FOR_GLOBAL, a.attr),
                                                notes-> copy [copy ErrorMsg::note (loc, "")]);
                }
            }
        }

        isThread
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================           FINALIZE           =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Finalize the declaration of the use decl inside the symbols
     * It assumes, that everything is declared, thus use decl are valid
     * @params:
     *    - sym: the root symbol to finalize
     * */
    pub fn finalizeDeclaration (mut self, dmut sym : &Symbol, useCore : bool = true)
        throws ErrorMsg
    {
        let mut errors : [mut &ErrorMsg] = [];

        let uses = sym.getAllUseDecls ();
        for i in 0us .. uses.len {
            {
                self:.finalizeUse (alias sym, uses [i]);
            } catch {
                err : &ErrorMsg => { errors ~= [err]; }
            }
        }

        // use core only if parent also uses core, not in standalone, and not a core module
        let useCore_ = useCore && (!state::instance ().isStandalone ()) && (!sym.isCoreModule ());
        if (useCore_) {
            sym:.setUsedCore (alias self._coreModules);
        }

        let dmut inner = sym:.getAllLocalSymbols (protection-> Protection::PRIVATE);
        for i in 0us .. inner.len {
            {
                self:.finalizeDeclaration (alias inner [i], useCore-> useCore_); // child of core modules don't use core
            } catch {
                err : &ErrorMsg => { errors ~= [err]; }
            }
        }

        if (errors.len != 0us) throw copy ErrorMsg::list (errors);
    }

    /**
     * Finalize a use declaration
     * @params:
     *    - parent: the parent that declare the use
     *    - use_: the use declaration to validate
     * */
    fn finalizeUse (mut self, dmut parent : &Symbol, use_ : &UseDecl, throwSelf : bool = true)
        throws ErrorMsg
    {
        let useP = use_.getModulePath ();
        let p = self.toPath (useP);
        let dmut modules = self:.finalizeUse (alias parent, p, useP, throwSelf);

        for i in 0us .. modules.len {
            let dmut m = alias modules [i];
            parent:.useModule (m.getPath ().asStdPath (), alias m);
        }
    }

    /**
     * Find the list of modules referenced by the path of a use declaration
     * @params:
     *    - parent: the module in which a use declaration was made
     *    - path: the path of the use decl
     *    - throwSelf: true if an exception has to be thrown if using self
     * */
    fn finalizeUse (mut self, dmut parent : &Symbol, p : Path, useP : &Expression, throwSelf : bool)-> dmut [&ModuleSymbol]
        throws ErrorMsg
    {
        let mut root = self:.getGlobal (p.root (), parent); // absolute access to the root of the path

        if (root.len == 0us) { // root of the path does not exist
            // this is an absolute access, thus an absolute error, thus absolute error has to be thrown
            throw self.createGlobalAccessError (self.getPathIndexLoc (useP, 0us), p.root (), parent);
        }

        let mut current = parent, mut all = false;
        let parts = p.parts ();
        for i in 1us .. parts.len {
            let mut found = false;
            if (i == parts.len - 1us && parts [i] == Keys::UNDER) {
                let mut subMods : [mut &Symbol] = [];
                for r in root {
                    let module = match r {
                        l : &LazyModuleSymbol => { self:.finalizeImportDecl (l) }
                        m : _ => { m }
                    };

                    match module {
                        m : &ModuleSymbol => {
                            subMods ~= self.getAllLocalFromContext (parent, m);
                        }
                    }
                }

                root = subMods;
                all = true;
            } else {
                for r in root {
                    let module = match r {
                        l : &LazyModuleSymbol => { self:.finalizeImportDecl (l) }
                        m : _ => { m }
                    };

                    match module {
                        m : &ModuleSymbol => { // there can be only one module with a given name in another module, otherwise error would have been thrown during module declaration
                            root = self.getLocalFromContext (parts [i], parent, m); // relative access, while ensuring protection access
                            if (root.len == 0us) { // no module named parts[i] in current module
                                let errLoc = self.getPathIndexLoc (useP, i);
                                throw copy ErrorMsg::fatal (errLoc, format (DeclareErrorMessage::NO_MODULE_NAMED, parts [i], m.getPath ().toStr ()),
                                                            notes-> self.createLocalAccessError (errLoc, parts[i], m, parent));
                            }

                            found = true;
                            current = m;
                        }
                    }
                }

                // A symbol was found, but it was not a module
                if (!found) {
                    throw copy ErrorMsg::fatal (self.getPathIndexLoc (useP, i - 1us), format (DeclareErrorMessage::NO_MODULE_NAMED, parts[i - 1us], current.getPath ().toStr ()));
                }
            }
        }

        let mut modules : [dmut &ModuleSymbol] = [];
        for r in root {
            let module = match r {
                l : &LazyModuleSymbol => { self:.finalizeImportDecl (l) }
                m : _ => { m }
            };

            match module {
                m : &ModuleSymbol => { // use all the module found at the end of the path
                    if (parent is m) {
                        if (!all && throwSelf) { // does not throw if using self by referencing {self.parent}::_;
                                                 // only throws if directly referencing {self.parent}::self;
                            throw copy ErrorMsg::warn (self.getPathIndexLoc (useP, parts.len - 1us), format (DeclareErrorMessage::SELF_USE, m.getPath ().toStr ()));
                        }
                    } else {
                        if let dmut mm : &ModuleSymbol = alias self:.getMutableSymbol (m) {
                            modules ~= [alias mm];
                        } else panic;

                        all = true; // set all to true, because at least one module was found
                    }
                }
            }
        }

        if (!all) { // all is true if at least one module was used, or '_' was found, meaning use all sub modules from this path
            // if not all, then symbol was found in current, but it was not a module
            throw copy ErrorMsg::fatal (self.getPathIndexLoc (useP, parts.len - 1us),
                                        format (DeclareErrorMessage::NO_MODULE_NAMED, parts[parts.len - 1us], current.getPath ().toStr ()));
        }

        return alias modules;
    }
    
    /*!
     * ================================================================================
     * ================================================================================
     * =========================            UTILS             =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Transform an expression into a path
     * @returns: a path
     * @panic
     */
    fn toPath (self, expr : &Expression)-> Path {
        match expr {
            p : &PathExpr => {
                p.toStdPath ()
            }
            _ => {
                Path (expr.getLoc ().str)
            }
        }
    }

/**
     * @returns: the location of the 'index' path element in the path
     * */
    fn getPathIndexLoc (self, expr : &Expression, index : usize)-> &Word {
        match expr {
            p : &PathExpr => {
                let locs = p.getLocs ();
                if (locs.len < index) { expr.getLoc () }
                else { locs [index] }
            }
            _ => {
                expr.getLoc ()
            }
        }
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================           GETTERS            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * @returns: the mutable version of a symbol from its immutable address
     * @panic: if the symbol was not declared nor registered by this declarator
     */
    pub fn getMutableSymbol (mut self, sym : &Symbol)-> dmut &Symbol {
        // Since we have access to the declarator, we have access to the symbol table
        // Thus we can find mutable access to the symbol,
        // We do some cheating to go faster, but the result is the same
        return memory::Runtime!{&Symbol, &Symbol}::_yrt_unsafe_cast (sym);

        // let dmut r = self._root:.getMutableSymbol (sym);
        // match alias r {
        //     Ok (dmut v : _) => return alias v;
        //     _ => {

        //         let dmut forR = self._foreignRoot:.getMutableSymbol (sym);
        //         match alias forR {
        //             Ok (dmut v : _) => { return alias v; }
        //             _ => {
        //                 eprintln ("Symbol not found in sym table : ", sym.getPath ().toStr ());
        //                 panic;
        //             }
        //         }
        //     }
        // }
    }

    /**
     * @returns: the protection the 'context' has on the symbol 'sym'
     * */
    pub fn getProtectionFromContext (self, context : &Symbol, sym : &Symbol)-> Protection {
        let mut current = context;
        loop {
            match current {
                EmptySymbol () => { break Protection::PUBLIC; }
                c : _ => {
                    if (c is sym) {
                        break Protection::PRIVATE;
                    }
                }
            }
            current = current.getReferent ();
        }
    }

    /**
     * Get a list of symbol from a global access, where current context is 'context'
     * @params:
     *    - name: the name of the symbol to find
     *    - context: the context in which symbols is searched
     * */
    pub fn getGlobal (mut self, name : [c8], context : &Symbol)-> [&Symbol] {
        let mut root = context.getSymbols (name)[];
        if (root.len  == 0us) {
            root = self._foreignRoot.getSymbols (name)[];
        }

        root
    } 

    /**
     * Get a list of symbol declared locally inside 'sym' from the context 'context' that might have no access to private syms
     * @params:
     *    - name: the name of the symbol to access
     *    - context: the context of the access
     *    - sym: the symbol being accessed
     *    - protection: the protection to apply if symbol only have public access
     * */
    pub fn getLocalFromContext (mut self, name : [c8], context : &Symbol, sym : &Symbol, protection : Protection = Protection::PUBLIC)-> dmut [&Symbol] {
        let dmut module = self:.getMutableSymbol (sym);
        let mut contextProt = self.getProtectionFromContext (context, sym);
        if (contextProt == Protection::PUBLIC) { contextProt = protection; }

        let dmut res = (module:.getLocalSymbols (name, protection-> contextProt)):[];
        alias res
    }

    /**
     * Get a list of symbol declared locally inside 'sym' from the context 'context' that might have no access to private syms
     * @params:
     *    - name: the name of the symbol to access
     *    - context: the context of the access
     *    - sym: the symbol being accessed
     *    - protection: the protection to apply if symbol only have public access
     * */
    pub fn getLocalFromContext (self, name : [c8], context : &Symbol, sym : &Symbol, protection : Protection = Protection::PUBLIC)-> [&Symbol] {
        let mut contextProt = self.getProtectionFromContext (context, sym);
        if (contextProt == Protection::PUBLIC) { contextProt = protection; }

        let res = (sym.getLocalSymbols (name, protection-> contextProt))[];
        res
    }

    /**
     * Get the list of symbol declared locally in 'sym' that are reachable from 'context'
     * @params:
     *     - context: the context of the access
     *     - sym: the symbol being accessed
     *     - protection: the protection to apply if symbol only have public access
     * */
    pub fn getAllLocalFromContext (self, context : &Symbol, sym : &Symbol, protection : Protection = Protection::PUBLIC)-> [&Symbol] {
        let mut contextProt = self.getProtectionFromContext (context, sym);
        if (contextProt == Protection::PUBLIC) { contextProt = protection; }

        let res = (sym.getAllLocalSymbols (protection-> contextProt));
        res
    }

    /**
     * Get a list of symbol declared locally inside 'sym' from the context 'context' that might have no access to private syms
     * And whose name are close to 'name' with a distance of 'distance'
     * @params:
     *    - name: the name of the symbol to access
     *    - distance: the distance between the names to seek and the symbols in the module 'sym'
     *    - context: the context of the access
     *    - sym: the symbol being accessed
     *    - protection: the protection to apply if symbol only have public access
     * */
    pub fn getCloseLocalFromContext (self, name : [c8], distance : usize = 2us, context : &Symbol, sym : &Symbol, protection : Protection = Protection::PUBLIC)-> [&Symbol] {
        let mut contextProt = self.getProtectionFromContext (context, sym);
        if (contextProt == Protection::PUBLIC) { contextProt = protection; }

        let res = (sym.getCloseLocalSymbols (name, distance-> distance, protection-> contextProt))[];
        res
    }

    /**
     * Create an error message for a global access that was unsuccessful
     * @params:
     *    - loc: the location of the access
     *    - name: the name of the symbol being accessed
     *    - sym: the context of the access
     * */
    pub fn createGlobalAccessError (self, loc : &Word, name : [c8], sym : &Symbol)-> &ErrorMsg {
        let mut notes : [mut &ErrorMsg] = [];
        let mut syms = sym.getSymbols (name, protection-> Protection::PRIVATE)[];

        let mut msgFrom = DeclareErrorMessage::PRIVATE_IN_THIS_CONTEXT_FROM_MOD, mut msgNonFrom = DeclareErrorMessage::PRIVATE_IN_THIS_CONTEXT;
        if (syms.len == 0us) { // if no symbol is named 'name', then maybe there is typo in the variable name
            syms = sym.getCloseSymbols (name, distance-> 2us)[]; // Get all the symbols whose names are close to 'name'

            // Change the error messages
            msgFrom = DeclareErrorMessage::MAYBE_WAS_MEANT_FROM_MOD;
            msgNonFrom = DeclareErrorMessage::MAYBE_WAS_MEANT;
        }

        let dmut used : [Path => ()] = [];
        for s in syms { // add the notes to the error
            let stdPath = s.getPath ().asStdPath ();
            if (stdPath !in used) {
                let p = stdPath.parent ().toStr (sep-> "::");
                if (p.len != 0us) {
                    notes ~= [copy ErrorMsg::note (s.getLoc (), oneLine-> true, format (msgFrom, stdPath.file (), p))];
                } else
                    notes ~= [copy ErrorMsg::note (s.getLoc (), oneLine-> true, format (msgNonFrom, stdPath.file ()))];

                used [stdPath] = ();
            }
        }

        // Not thrown, it will be thrown by the caller function
        copy ErrorMsg::fatal (loc, format (DeclareErrorMessage::UNDEF_VAR, name), notes-> notes)
    }

    /**
     * Create an error message for a local access that was unsuccessful
     * @params:
     *    - loc: the location of the access
     *    - name: the name of the symbol being accessed
     *    - sym: the context of the access
     * */
    pub fn createLocalAccessError (self, _ : &Word, name : [c8], sym : &Symbol, context : &Symbol)-> [&ErrorMsg] {
        let mut notes : [mut &ErrorMsg] = [];

        // Search all the local symbols with the same name but that are not accessible
        let mut syms = sym.getLocalSymbols (name, protection-> Protection::PRIVATE)[];
        let mut msgFrom = DeclareErrorMessage::PRIVATE_IN_THIS_CONTEXT_FROM_MOD, mut msgNonFrom = DeclareErrorMessage::PRIVATE_IN_THIS_CONTEXT;
        if (syms.len == 0us) { // if no symbol is named 'name', then maybe there is typo in the variable name
            let contextProt = self.getProtectionFromContext (context, sym);
            syms = sym.getCloseLocalSymbols (name, distance-> 2us, protection-> contextProt)[]; // Get all the local symbols whose names are close to 'name'

            // Change the error messages
            msgFrom = DeclareErrorMessage::MAYBE_WAS_MEANT_FROM_MOD;
            msgNonFrom = DeclareErrorMessage::MAYBE_WAS_MEANT;
        }

        let dmut used : [Path => ()] = [];
        for s in syms { // add the notes to the error
            let stdPath = s.getPath ().asStdPath ();
            if (stdPath !in used) {
                let p = stdPath.parent ().toStr (sep-> "::");
                if (p.len != 0us) {
                    notes ~= [copy ErrorMsg::note (s.getLoc (), oneLine-> true, format (msgFrom, stdPath.file (), p))];
                } else
                    notes ~= [copy ErrorMsg::note (s.getLoc (), oneLine-> true, format (msgNonFrom, stdPath.file ()))];

                used [stdPath] = ();
            }
        }

        notes
    }


    /*!
     * ================================================================================
     * ================================================================================
     * =========================        MISCELLANEOUS         =========================
     * ================================================================================
     * ================================================================================
     */

    impl Formattable {

        pub over format (self, dmut stream : &Formatter) {
            stream:.write (" LOCAL : \n");
            self._root.formatSymTree (alias stream);
            stream:.write (" EXTERNAL : \n");
            self._foreignRoot.formatSymTree (alias stream);
        }
    }
    
    
}
