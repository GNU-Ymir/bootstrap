in none_;

use ymirc::lexing::word;
use ymirc::syntax::keys;
use ymirc::utils::format;
use std::stream;

use ymirc::semantic::generator::value::literal::null_;

use ymirc::semantic::generator::type;
use ymirc::semantic::generator::type::native::{compound::option,
                                               scalar::none_};


/**
 * A none value is an empty value reprensenting an unset option value
 */
@final
pub class ErrOptionValue over ConstructValue {

    // The error value (for try catch, NullValue for none)
    let _err : &Value;

    pub self (loc : &Word, type : &OptionType = NONE_OPTION_TYPE, errValue : &Value = NULL_VALUE, isReduced : bool = false)
        with super (loc, type, isReduced-> isReduced)
        , _err = errValue
    {}

    /*!
     * ================================================================================
     * ================================================================================
     * ===========================          GETTERS          ==========================
     * ================================================================================
     * ================================================================================
     */

    pub fn getValue (self)-> &Value {
        self._err
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================          COMPARISON          =========================
     * ================================================================================
     * ================================================================================
     */

    pub over opEquals (self, o : &Generator)-> bool {
        if (!self.super.opEquals (o)) return false;

        match o {
            p : &ErrOptionValue => {
                if (self._err != p._err) return false;

                return true;
            }
            _ => { false }
        }
    }

    pub over isFullLiteral (self)-> bool {
        self._err.isFullLiteral ()
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          CLONING          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    pub over clone (self)-> &Value {
        if let o : &OptionType = self._type {
            copy ErrOptionValue (self._loc,
                                 type-> o,
                                 errValue-> self._err.clone (),
                                 isReduced-> self._isReduced)
        } else panic;
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================        MISCELLANEOUS         =========================
     * ================================================================================
     * ================================================================================
     */

    impl Streamable;
    impl Formattable {
        pub over format (self, dmut stream : &Formatter) {
            if (self._err of NullValue) {
                stream:.write (Keys::NONE);
            } else {
                stream:.write (format ("{.ok = false, .error = %}", self._err, tags-> stream.tags));
            }
        }
    }
}
