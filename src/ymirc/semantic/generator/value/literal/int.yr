mod ymirc::semantic::generator::value::literal::int;

import ymirc::lexing::word;
import ymirc::syntax::keys;
import ymirc::utils::format;

import std::io;

import ymirc::semantic::generator::value::literal::base;
import ymirc::semantic::generator::type::native::compound::pointer;
import ymirc::semantic::generator::type::native::int;
import ymirc::semantic::generator::base;
import ymirc::semantic::generator::type::base;

/**
 * A unit value is an empty value that does nothing
 */
pub class IntValue over LiteralValue {

    /// The value
    let _value : usize;
    
    /**
     * Create a new value
     */
    pub self (loc : &Word, type : &Type, val : usize) with super (loc, type), _value = val {}


    /**
     * ================================================================================
     * ================================================================================
     * =========================           GETTERS            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * @returns: the content of the value
     */
    pub def getValue (self)-> usize {
        self._value
    }
        
    /**
     * ================================================================================
     * ================================================================================
     * =========================          COMPARISON          =========================
     * ================================================================================
     * ================================================================================
     */

    pub over opEquals (self, o : &Generator)-> bool {
        match o {
            s : &IntValue => { s._type == self._type && self._value == s._value }
            _ => { false }
        }
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================        MISCELLANEOUS         =========================
     * ================================================================================
     * ================================================================================
     */

    impl Streamable;
    impl Formattable {

        pub over format (self, dmut stream : &Formatter) {
            match self._type {
                f : &IntType => {
                    match (f.isSigned (), f.getSize ()) {
                        (true, 8u16) => { stream:.write (cast!i8 (self._value), "i8"s8); }
                        (true, 16u16) => { stream:.write (cast!i16 (self._value), "i16"s8); }
                        (true, 64u16) => { stream:.write (cast!i64 (self._value), "i64"s8); }
                        (true, 0u16) => { stream:.write (cast!isize (self._value), "isize"s8); }
                        (false, 8u16) => { stream:.write (cast!u8 (self._value), "u8"s8); }
                        (false, 16u16) => { stream:.write (cast!u16 (self._value), "u16"s8); }
                        (false, 32u16) => { stream:.write (cast!i8 (self._value), "u32"s8); }
                        (false, 64u16) => { stream:.write (cast!u64 (self._value), "u64"s8); }
                        (false, 0u16) => { stream:.write (self._value, "us"s8); }
                        _ => { stream:.write (cast!i32 (self._value)); }
                    }
                }
            }
        }        
    }        
}
