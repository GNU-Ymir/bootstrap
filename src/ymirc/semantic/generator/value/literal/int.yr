mod ymirc::semantic::generator::value::literal::int;

import ymirc::lexing::word;
import ymirc::syntax::keys;
import ymirc::utils::format;

import std::io;

import ymirc::semantic::generator::value::literal::base;
import ymirc::semantic::generator::type::native::compound::pointer;
import ymirc::semantic::generator::type::native::int;
import ymirc::semantic::generator::base;
import ymirc::semantic::generator::type::base;

import ymirc::utils::bigint;

/**
 */
pub class IntValue over LiteralValue {

    /// The value
    let _value : &BigInt;
    
    /**
     * Create a new value
     */
    pub self (loc : &Word, type : &Type, val : usize) with super (loc, type), _value = BigInt::new (val) {}


    pub self (loc : &Word, type : &Type, val : &BigInt) with super (loc, type), _value = val {} 

    /**
     * ================================================================================
     * ================================================================================
     * =========================           GETTERS            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * @returns: the content of the value
     */
    pub fn getValue (self)-> &BigInt {
        self._value
    }
    
    /**
     * ================================================================================
     * ================================================================================
     * =========================          COMPARISON          =========================
     * ================================================================================
     * ================================================================================
     */

    pub over opEquals (self, o : &Generator)-> bool {
        match o {
            s : &IntValue => { s._type == self._type && self._value == s._value }
            _ => { false }
        }
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================        MISCELLANEOUS         =========================
     * ================================================================================
     * ================================================================================
     */

    impl Streamable;
    impl Formattable {

        pub over format (self, dmut stream : &Formatter) {
            match self._type {
                f : &IntType => {
                    match (f.isSigned (), f.getSize ()) {
                        (true, 8u16) => { stream:.write (self._value, "i8"s8); }
                        (true, 16u16) => { stream:.write (self._value, "i16"s8); }
                        (true, 64u16) => { stream:.write (self._value, "i64"s8); }
                        (true, 0u16) => { stream:.write (self._value, "is"s8); }
                        (false, 8u16) => { stream:.write (self._value, "u8"s8); }
                        (false, 16u16) => { stream:.write (self._value, "u16"s8); }
                        (false, 32u16) => { stream:.write (self._value, "u32"s8); }
                        (false, 64u16) => { stream:.write (self._value, "u64"s8); }
                        (false, 0u16) => { stream:.write (self._value, "us"s8); }
                        _ => { stream:.write (self._value); }
                    }
                }
            }
        }        
    }        
}


/**
 * Create a IntValue from a usize
 * @info: the type of the value is IntType as a usize
 * @returns: a IntValue
 */
pub fn usize (loc : &Word, value : usize)-> &IntValue {
    IntValue::new (loc, IntType::new (loc, size-> 0u16, signed-> false), value)
}

/**
 * Create a IntValue from a usize
 */
pub fn intValue (loc : &Word, value : usize, size : u16, signed : bool)-> &IntValue {
    IntValue::new (loc, IntType::new (loc, size-> size, signed-> signed), value)
}
