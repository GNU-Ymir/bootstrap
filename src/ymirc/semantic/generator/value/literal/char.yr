mod ymirc::semantic::generator::value::literal::char;

import ymirc::lexing::word;
import ymirc::lexing::tokens;
import ymirc::syntax::keys;
import ymirc::utils::format;

import std::io;

import ymirc::semantic::generator::value::literal::base;
import ymirc::semantic::generator::type::native::compound::pointer;
import ymirc::semantic::generator::type::native::char;
import ymirc::semantic::generator::base;
import ymirc::semantic::generator::type::base;
import ymirc::semantic::validator::utf;

/**
 */
pub class CharValue over LiteralValue {

    /// The value encoded in utf8
    let _utf8 : c8;

    /// The value encoded in utf32
    let _utf32 : c32;
    
    /**
     * Create a new value
     * 
     */
    pub self (loc : &Word, type : &Type, c8Val : c8 = '\u{0}'c8, c32Val : c32 = '\u{0}')
        with super (loc, type), _utf8 = c8Val, _utf32 = c32Val
    {}


    /**
     * ================================================================================
     * ================================================================================
     * =========================           GETTERS            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * @returns: the content of the char, if the char is utf8 encoded
     */
    pub def getUtf8 (self)-> c8 {
        self._utf8
    }

    /**
     * @returns: the content of the char, if the char is utf32 encoded
     */
    pub def getUtf32 (self)-> c32 {
        self._utf32
    }

    
    /**
     * ================================================================================
     * ================================================================================
     * =========================          COMPARISON          =========================
     * ================================================================================
     * ================================================================================
     */

    pub over opEquals (self, o : &Generator)-> bool {
        match o {
            s : &CharValue => {
                s._type == self._type && self._utf32 == s._utf32 && self._utf8 == s._utf8
            }
            _ => { false }
        }
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================        MISCELLANEOUS         =========================
     * ================================================================================
     * ================================================================================
     */

    
    impl Streamable;
    impl Formattable {

        pub over format (self, dmut stream : &Formatter) {
            let utf = UtfVisitor::new ();
            match self._type {
                c : &CharType => {
                    if (c.getSize () == 8u16) {                        
                        stream:.write (Tokens::SQUOTE, utf.unescape (self._utf8), Tokens::SQUOTE, CharSuffixes::UTF8);
                        return {}
                    }
                }
            }            
            
            stream:.write (Tokens::SQUOTE, utf.unescape (self._utf32), Tokens::SQUOTE, CharSuffixes::UTF32);
        }
    }        
}
