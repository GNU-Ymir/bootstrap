mod ymirc::semantic::generator::value::literal::string;

import ymirc::lexing::word;
import ymirc::lexing::tokens;
import ymirc::syntax::keys;
import ymirc::utils::format;

import std::io;

import ymirc::semantic::generator::value::literal::base;
import ymirc::semantic::generator::value::literal::int;
import ymirc::semantic::generator::value::memory::slice;

import ymirc::semantic::generator::type::native::compound::pointer;
import ymirc::semantic::generator::type::native::char;
import ymirc::semantic::generator::type::native::int;
import ymirc::semantic::generator::type::native::compound::array;
import ymirc::semantic::generator::type::native::compound::slice;

import ymirc::semantic::generator::base;
import ymirc::semantic::generator::type::base;
import ymirc::semantic::validator::utf;


pub struct @union
| utf8 : [u8]
| utf16 : [u16]
| utf32 : [u32]
 -> StringValueContent;

/**
 */
pub class StringValue over LiteralValue {

    // The content of the string
    let _content : StringValueContent;

    pub self (loc : &Word, type : &Type, utf8 : [u8])
        with super (loc, type), _content = StringValueContent (utf8-> utf8)
    {
        __pragma!trusted (assert (type.isOf!{&ArrayType} ()));
    }

    pub self (loc : &Word, type : &Type, utf16 : [u16])
        with super (loc, type), _content = StringValueContent (utf16-> utf16)
    {
        __pragma!trusted (assert (type.isOf!{&ArrayType} ()));
    }

    pub self (loc : &Word, type : &Type, utf32 : [u32])
        with super (loc, type), _content = StringValueContent (utf32-> utf32)
    {
        __pragma!trusted (assert (type.isOf!{&ArrayType} ()));
    }

    pub self (loc : &Word, type : &Type, value : StringValueContent)
        with super (loc, type), _content = value
    {
        __pragma!trusted (assert (type.isOf!{&ArrayType} ()));
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================           GETTERS            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * @returns: the content of the string, if the string is utf8 encoded
     */
    pub fn getValue (self)-> StringValueContent {
        self._content
    }


    /**
     * @returns: the size of the encoding used by the string value
     * */
    pub fn getEncodingSize (self)-> u16 {
        self._type.asOf!{&ArrayType} ().getInners ()[0].asOf!{&CharType}().getSize ()
    }

    /**
     * @returns: the lenght of the string value
     * */
    pub fn getLen (self)-> usize {
        match self.getEncodingSize () {
            8u16 => { self._content.utf8.len }
            16u16 => { self._content.utf16.len }
            _ => { self._content.utf32.len }
        }
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================          COMPARISON          =========================
     * ================================================================================
     * ================================================================================
     */

    pub over opEquals (self, o : &Generator)-> bool {
        match o {
            s : &StringValue => {                
                if (s._type != self._type || self.getEncodingSize () != s.getEncodingSize ())
                    return false;
                match self.getEncodingSize () {
                    8u16 => {
                        self._content.utf8 == s._content.utf8
                    }
                    16u16 => {
                        self._content.utf16 == s._content.utf16
                    }
                    _ => {
                        self._content.utf32 == s._content.utf32
                    }
                }

            }
            _ => { false }
        }
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================        MISCELLANEOUS         =========================
     * ================================================================================
     * ================================================================================
     */

    impl Streamable;
    impl Formattable {

        pub over format (self, dmut stream : &Formatter) {
            let utfV = utf::instance ();
            match self.getEncodingSize () {
                8u16 => {
                    stream:.write (Tokens::DQUOTE, utfV.unescape (utfV.decode (self._content.utf8), squote-> false), Tokens::DQUOTE, StringSuffixes::UTF8);
                }
                16u16 => {
                    stream:.write (Tokens::DQUOTE, utfV.unescape (utfV.decode (self._content.utf16), squote-> false), Tokens::DQUOTE, StringSuffixes::UTF16);
                }
                _ => {
                    stream:.write (Tokens::DQUOTE, utfV.unescape (utfV.decode (self._content.utf32), squote-> false), Tokens::DQUOTE, StringSuffixes::UTF32);
                }
            }
        }
    }        
}


/**
 * Construct a string value from a str text
 * */
pub fn strValue (loc : &Word, value : [c8]) -> &StringValue {
    let dmut res = [0u8 ; new value.len];
    for i in 0us .. value.len {
        res [i] = cast!u8 (value [i]);
    }

    StringValue::new (loc, ArrayType::new (loc, CharType::new (loc), usize (loc, res.len)), utf8-> res)
}

/**
 * Construct a string value from and store it in a slice
 * */
pub fn strSliceValue (loc : &Word, value : [c8]) -> &SliceValue {
    let dmut res = [0u8 ; new value.len];
    for i in 0us .. value.len {
        res [i] = cast!u8 (value [i]);
    }

    let ret = StringValue::new (loc, ArrayType::new (loc, CharType::new (loc), usize (loc, res.len)), utf8-> res);
    let slcType = SliceType::new (loc, CharType::new (loc));

    SliceValue::new (loc, slcType, ret, implicitAlias-> true)
}

/**
 * Convert a string value to another encoding size
 * @params:
 *   - loc: the location of the new value
 *   - value: the old value to recode
 *   - resultSize: the size of the new encoding
 * @returns: a slice value containing the coded string
 * */
pub fn convertStringSliceValue (loc : &Word, value : &StringValue, resultSize : u16 = 8u16)-> &SliceValue {
    let decoded : [c8] = match value.getEncodingSize () {
        8u16 => { utf::instance ().decode (value.getValue ().utf8) }
        16u16 => { utf::instance ().decode (value.getValue ().utf16) }
        _ => { utf::instance ().decode (value.getValue ().utf32) }
    }

    let slcType = SliceType::new (loc, CharType::new (loc, size-> resultSize));
    let result = match resultSize {
        8u16 => {
            let res = utf::instance ().encodeUtf8 (decoded);
            StringValue::new (loc, ArrayType::new (loc, CharType::new (loc, size-> resultSize), usize (loc, res.len)), utf8-> res)
        }
        16u16 => {
            let res = utf::instance ().encodeUtf16 (decoded);
            StringValue::new (loc, ArrayType::new (loc, CharType::new (loc, size-> resultSize), usize (loc, res.len)), utf16-> res)
        }
        _ => {
            let res = utf::instance ().encodeUtf32 (decoded);
            StringValue::new (loc, ArrayType::new (loc, CharType::new (loc, size-> resultSize), usize (loc, res.len)), utf32-> res)
        }
    }

    SliceValue::new (loc, slcType, result, implicitAlias-> true)
}
