mod ymirc::semantic::generator::value::literal::string;

import ymirc::lexing::word;
import ymirc::lexing::tokens;
import ymirc::syntax::keys;
import ymirc::utils::format;

import std::io;

import ymirc::semantic::generator::value::literal::base;
import ymirc::semantic::generator::type::native::compound::pointer;
import ymirc::semantic::generator::type::native::char;
import ymirc::semantic::generator::type::native::compound::array;
import ymirc::semantic::generator::base;
import ymirc::semantic::generator::type::base;

/**
 */
pub class StringValue over LiteralValue {

    /// The value encoded in utf8
    let _utf8 : [c8];

    /// The value encoded in utf32
    let _utf32 : [c32];

    /// The length of the content string
    let _len : usize;
    
    /**
     * Create a new value
     * 
     */
    pub self (loc : &Word, type : &Type, c8Val : [c8] = ""s8, c32Val : [c32] = "", len : usize)
        with super (loc, type), _utf8 = c8Val, _utf32 = c32Val, _len = len
    {}


    /**
     * ================================================================================
     * ================================================================================
     * =========================           GETTERS            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * @returns: the content of the string, if the string is utf8 encoded
     */
    pub def getUtf8 (self)-> [c8] {
        self._utf8
    }

    /**
     * @returns: the content of the string, if the string is utf32 encoded
     */
    pub def getUtf32 (self)-> [c32] {
        self._utf32
    }

    /**
     * @returns: the length of the string
     */
    pub def getLen (self)-> usize {
        self._len
    }
    
    /**
     * ================================================================================
     * ================================================================================
     * =========================          COMPARISON          =========================
     * ================================================================================
     * ================================================================================
     */

    pub over opEquals (self, o : &Generator)-> bool {
        match o {
            s : &StringValue => {                
                if (!(s._type == self._type && self._len == s._len)) return false;
                if (self._utf32.len >= 0us && s._utf32.len >= 0us) {
                    self._utf32 [0us .. self._len] == s._utf32 [0us .. s._len]
                } else {
                    self._utf8 [0us .. self._len] == s._utf8 [0us .. s._len]
                }
            }
            _ => { false }
        }
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================        MISCELLANEOUS         =========================
     * ================================================================================
     * ================================================================================
     */

    impl Streamable;
    impl Formattable {

        pub over format (self, dmut stream : &Formatter) {
            match self._type {
                a : &ArrayType =>
                    match a.getInners ()[0] {
                        c : &CharType => {
                            if (c.getSize () == 8u16) {
                                stream:.write (Tokens::DQUOTE, self._utf8, Tokens::DQUOTE, StringSuffixes::UTF8);
                                return {}
                            }
                        }
                    }
            }
            
            stream:.write (Tokens::DQUOTE, self._utf32, Tokens::DQUOTE, StringSuffixes::UTF32);
        }
    }        
}
