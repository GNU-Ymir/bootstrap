in string;

use ymirc::lexing::{word, tokens};
use ymirc::syntax::keys;
use ymirc::utils::format;
use std::stream;

use ymirc::semantic::validator::utf;

use ymirc::semantic::generator::value::literal::{int, char, array};
use ymirc::semantic::generator::type::native::{compound::{pointer, array, slice},
                                               scalar::{char, int}};

pub record StringValueContent {
    pub let utf8 : [u8] = [];
    pub let utf16 : [u16] = [];
    pub let utf32 : [u32] = [];

    pub self (utf8 : [u8]) with utf8 = utf8 {}
    pub self (utf16 : [u16]) with utf16 = utf16 {}
    pub self (utf32 : [u32]) with utf32 = utf32 {}
}

@final
pub class StringValue over LiteralValue {

    // The content of the string
    let _content : StringValueContent;

    pub self (loc : &Word, type : &SliceType, utf8 : [u8])
        with super (loc, type)
        , _content = StringValueContent (utf8-> utf8)
    {}

    pub self (loc : &Word, type : &SliceType, utf16 : [u16])
        with super (loc, type)
        , _content = StringValueContent (utf16-> utf16)
    {}

    pub self (loc : &Word, type : &SliceType, utf32 : [u32])
        with super (loc, type)
        , _content = StringValueContent (utf32-> utf32)
    {}

    pub self (loc : &Word, type : &SliceType, value : StringValueContent)
        with super (loc, type)
        , _content = value
    {}

    /*!
     * ================================================================================
     * ================================================================================
     * =========================           GETTERS            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * @returns: the content of the string, if the string is utf8 encoded
     */
    pub fn getValue (self)-> StringValueContent {
        self._content
    }


    /**
     * @returns: the size of the encoding used by the string value
     * */
    pub fn getEncodingSize (self)-> u16 {
        if let slc : &SliceType = self._type {
            if let c : &CharType = slc.getInners ()[0] {
                return c.getSize ();
            }
        }

        panic;
    }

    /**
     * @returns: the lenght of the string value
     * */
    pub fn getLen (self)-> usize {
        match self.getEncodingSize () {
            8u16  => { self._content.utf8.len }
            16u16 => { self._content.utf16.len }
            _     => { self._content.utf32.len }
        }
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================          COMPARISON          =========================
     * ================================================================================
     * ================================================================================
     */

    pub over opEquals (self, o : &Generator)-> bool {
        if (!self.super.opEquals (o)) return false;

        match o {
            s : &StringValue => {                
                if (self.getEncodingSize () != s.getEncodingSize ()) return false;
                match self.getEncodingSize () {
                    8u16 => {
                        self._content.utf8 == s._content.utf8
                    }
                    16u16 => {
                        self._content.utf16 == s._content.utf16
                    }
                    _ => {
                        self._content.utf32 == s._content.utf32
                    }
                }

            }
            _ => { false }
        }
    }


    pub over isFullLiteral (self)-> bool {
        true
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          CLONING          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    pub over clone (self)-> &Value {
        self
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================        MISCELLANEOUS         =========================
     * ================================================================================
     * ================================================================================
     */

    impl Streamable;
    impl Formattable {

        pub over format (self, dmut stream : &Formatter) {
            let utfV = ymirc::semantic::validator::utf::instance ();
            match self.getEncodingSize () {
                8u16 => {
                    stream:.write (Tokens::DQUOTE, utfV.unescape (utfV.decode (self._content.utf8), squote-> false), Tokens::DQUOTE, StringSuffixes::UTF8);
                }
                16u16 => {
                    stream:.write (Tokens::DQUOTE, utfV.unescape (utfV.decode (self._content.utf16), squote-> false), Tokens::DQUOTE, StringSuffixes::UTF16);
                }
                _ => {
                    stream:.write (Tokens::DQUOTE, utfV.unescape (utfV.decode (self._content.utf32), squote-> false), Tokens::DQUOTE, StringSuffixes::UTF32);
                }
            }
        }
    }        
}


/**
 * Construct a string value from and store it in a slice
 * */
pub fn makeStringSliceValue (loc : &Word, value : [c8]) -> &StringValue {
    let mut res = copy [cast!u8 (i) for i in value];

    {
        copy StringValue (loc, copy SliceType (loc, copy CharType (loc)), utf8-> res)
    } catch {
        _ => panic;
    }
}

/**
 * Convert a string value to another encoding size
 * @params:
 *   - loc: the location of the new value
 *   - value: the old value to recode
 *   - resultSize: the size of the new encoding
 * @returns: a slice value containing the coded string
 * */
pub fn convertStringSliceValue (loc : &Word, value : &StringValue, resultSize : u16 = 8u16)-> &StringValue {
    let utfV = ymirc::semantic::validator::utf::instance ();
    let decoded : [c8] = match value.getEncodingSize () {
        8u16  => { utfV.decode (value.getValue ().utf8) }
        16u16 => { utfV.decode (value.getValue ().utf16) }
        _     => { utfV.decode (value.getValue ().utf32) }
    };

    {
        match resultSize {
            8u16  => {
                let res = utfV.encodeUtf8 (decoded);
                let slc = copy SliceType (loc, copy CharType (loc, size-> resultSize), withSize-> makeIntValue (loc, res.len));
                copy StringValue (loc, slc, utf8-> res)
            }
            16u16 => {
                let res = utfV.encodeUtf16 (decoded);
                let slc = copy SliceType (loc, copy CharType (loc, size-> resultSize), withSize-> makeIntValue (loc, res.len));
                copy StringValue (loc, slc, utf16-> res)
            }
            _     => {
                let res = utfV.encodeUtf32 (decoded);
                let slc = copy SliceType (loc, copy CharType (loc, size-> resultSize), withSize-> makeIntValue (loc, res.len));
                copy StringValue (loc, slc, utf32-> res)
            }
        }
    } catch { // slice type ctor can throw if it contains movable types
        _ => panic;
    }
}


/**
 * Convert a string value to another encoding size and return an arrayvalue instead of a string
 * @params:
 *   - loc: the location of the new value
 *   - value: the old value to recode
 *   - resultSize: the size of the new encoding
 * @returns: a slice value containing the coded string
 * */
pub fn convertStringArrayValue (loc : &Word, value : &StringValue, resultSize : u16 = 8u16)-> &ArrayValue  {
    let utfV = ymirc::semantic::validator::utf::instance ();
    let decoded : [c8] = match value.getEncodingSize () {
        8u16  => { utfV.decode (value.getValue ().utf8) }
        16u16 => { utfV.decode (value.getValue ().utf16) }
        _     => { utfV.decode (value.getValue ().utf32) }
    };

    let mut res : [mut &Value] = [];
    match resultSize {
        8u16  => {
            let encode = utfV.encodeUtf8 (decoded);
            res = copy [makeCharValue (loc, cast!u32 (i), size-> 8u16) for i in encode];
        }
        16u16 => {
            let encode = utfV.encodeUtf16 (decoded);
            res = copy [makeCharValue (loc, cast!u32 (i), size-> 16u16) for i in encode];
        }
        _     => {
            let encode = utfV.encodeUtf32 (decoded);
            res = copy [makeCharValue (loc, cast!u32 (i), size-> 32u16) for i in encode];
        }
    }

    {
        let type = copy ArrayType (loc, copy CharType (loc, size-> resultSize), res.len);
        copy ArrayValue (loc, type, res)
    } catch { // array type can throw if it contains movable types
        _ => panic;
    }
}
