mod ymirc::semantic::generator::value::base;

import ymirc::lexing::word;
import ymirc::utils::format;

import std::io;
import std::collection::vec;

import ymirc::semantic::generator::_;
import ymirc::semantic::generator::type::base;

/**
 * Ancestor of all kind of values
 */
pub class @abstract Value over Generator {

    /// The type of the value
    let mut _type : &Type;

    /// The list of types that can be thrown by the value
    let mut _throwers : [(&Word, &Type)] = [];

    /// The location of the return statement in the value
    let mut _returnLoc : &Word = EOF_WORD;

    /// The location of the break statement in the value
    let mut _breakLoc : &Word = EOF_WORD;

    /// true iif the value can be used as a lvalue (without considering type checking)
    let mut _isLvalue : bool = false;
    
    /**
     * @params: 
     *    - loc: the location of the value
     */
    pub self (loc : &Word, type : &Type) with super (loc), _type = type {}

    /**
     * ================================================================================
     * ================================================================================
     * =========================           GETTERS            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * @returns: the type of the value
     */
    pub fn getType (self)-> &Type {
        self._type
    }

    /**
     * @returns: the list of types that can be thrown by the value
     */
    pub fn getThrowers (self)-> [(&Word, &Type)] {
        self._throwers
    }

    /**
     * Clear the list of throwers
     */
    pub fn clearThrowers (mut self) {
        self._throwers = [];
    }

    /**
     * @returns: true iif the value call a return in every branch
     */
    pub fn isReturner (self)-> bool {
        !self._returnLoc.isEof ()
    }

    /**
     * @returns: true iif the value call a break in every branch
     */
    pub fn isBreaker (self)-> bool {
        !self._breakLoc.isEof ()
    }

    /**
     * @returns: the location of the break inside the value
     */
    pub fn getBreakerLoc (self)-> &Word {
        self._breakLoc
    }

    /**
     * @returns: the location of the return inside the value
     */
    pub fn getReturnerLoc (self)-> &Word {
        self._returnLoc
    }

    /**
     * @returns: true if the type can be used as a left value
     * @warning: does not consider type checking only the kind of value we are dealing with
     */
    pub fn @final isLvalue (self)-> bool {
        self._isLvalue
    }

    /**
     * @returns: true if the value has to be uniq, and present only one time in the code to avoid making multiple times the same thing
     * */
    pub fn needUniqness (self)-> bool;

}
