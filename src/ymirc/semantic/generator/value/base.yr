mod ymirc::semantic::generator::value::base;

import ymirc::lexing::word;
import ymirc::utils::format;

import std::io;
import std::collection::vec;

import ymirc::semantic::generator::_;
import ymirc::semantic::generator::type::base;

/**
 * Ancestor of all kind of values
 */
pub class @abstract Value over Generator {

    /// The type of the value
    let mut _type : &Type;

    /// The list of types that can be thrown by the value
    let mut _throwers : [(&Word, &Type)] = [];

    /// The location of the return statement in the value
    let mut _returnLoc : &Word = EOF_WORD;

    /// The location of the break statement in the value
    let mut _breakLoc : &Word = EOF_WORD;

    /// true iif the value can be used as a lvalue (without considering type checking)
    let mut _isLvalue : bool = false;

    /// True if the value was generated by a reduction
    let _isReduced = false;
    
    /**
     * @params:
     *    - loc: the location of the value
     */
    pub self (loc : &Word, type : &Type, isReduced : bool = false)
        with super (loc)
        , _type = type
        , _isReduced = isReduced
    {}

    /**
     * @params:
     *    - loc: the location of the value
     *    - refId: the override of the uniq Id
     */
    pub self (loc : &Word, type : &Type, refId : usize, isReduced : bool = false)
        with super (loc, refId-> refId)
        , _type = type
        , _isReduced = isReduced
    {}

    /*!
     * ================================================================================
     * ================================================================================
     * =========================           GETTERS            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * @returns: the type of the value
     */
    pub fn getType (self)-> &Type {
        self._type
    }

    /**
     * @returns: the list of types that can be thrown by the value
     */
    pub fn getThrowers (self)-> [(&Word, &Type)] {
        self._throwers
    }

    /**
     * Clear the list of throwers
     */
    pub fn clearThrowers (mut self) {
        self._throwers = [];
    }

    /**
     * @returns: true iif the value call a return in every branch
     */
    pub fn isReturner (self)-> bool {
        !self._returnLoc.isEof ()
    }

    /**
     * @returns: true iif the value call a break in every branch
     */
    pub fn isBreaker (self)-> bool {
        !self._breakLoc.isEof ()
    }

    /**
     * @returns: the location of the break inside the value
     */
    pub fn getBreakerLoc (self)-> &Word {
        self._breakLoc
    }

    /**
     * @returns: the location of the return inside the value
     */
    pub fn getReturnerLoc (self)-> &Word {
        self._returnLoc
    }

    /**
     * @returns: true if the type can be used as a left value
     * @warning: does not consider type checking only the kind of value we are dealing with
     */
    pub fn @final isLvalue (self)-> bool {
        self._isLvalue
    }

    /**
     * @returns: true if the value has to be uniq, and present only one time in the code to avoid making multiple times the same thing
     * */
    pub fn needUniqness (self)-> bool;

    /**
     * @returns: true if the value is reduced (optimized by the cte interpreter)
     * */
    pub fn @final isReduced (self)-> bool {
        self._isReduced
    }

    /*!
     * ================================================================================
     * ================================================================================
     * ==========================           CLONE            ==========================
     * ================================================================================
     * ================================================================================
     */

    pub fn clone (self)-> &Value;


}
