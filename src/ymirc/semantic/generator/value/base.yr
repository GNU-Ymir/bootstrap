mod ymirc::semantic::generator::value::base;

import ymirc::lexing::word;
import ymirc::utils::format;

import std::io;
import std::collection::vec;

import ymirc::semantic::generator::_;
import ymirc::semantic::generator::type::base;

/**
 * Ancestor of all kind of values
 */
pub class @abstract Value over Generator {

    /// The type of the value
    let _type : &Type;

    /// The list of types that can be thrown by the value
    let mut _throwers : [(&Word, &Type)] = [];

    /// The location of the return statement in the value
    let mut _returnLoc : &Word = EOF_WORD;

    /// The location of the break statement in the value
    let mut _breakLoc : &Word = EOF_WORD;

    /// true iif the value can be used as a lvalue (without considering type checking)
    let mut _isLvalue : bool = false;
    
    /**
     * @params: 
     *    - loc: the location of the value
     */
    pub self (loc : &Word, type : &Type) with super (loc), _type = type {}

    /**
     * ================================================================================
     * ================================================================================
     * =========================           GETTERS            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * @returns: the type of the value
     */
    pub def getType (self)-> &Type {
        self._type
    }

    /**
     * @returns: the list of types that can be thrown by the value
     */
    pub def getThrowers (self)-> [(&Word, &Type)] {
        self._throwers
    }

    /**
     * Clear the list of throwers
     */
    pub def clearThrowers (mut self) {
        self._throwers = [];
    }

    /**
     * @returns: true iif the value call a return in every branch
     */
    pub def isReturner (self)-> bool {
        !self._returnLoc.isEof ()
    }

    /**
     * @returns: true iif the value call a break in every branch
     */
    pub def isBreaker (self)-> bool {
        !self._breakLoc.isEof ()
    }

    /**
     * @returns: the location of the break inside the value
     */
    pub def getBreakerLoc (self)-> &Word {
        self._breakLoc
    }

    /**
     * @returns: the location of the return inside the value
     */
    pub def getReturnerLoc (self)-> &Word {
        self._returnLoc
    }

    /**
     * @returns: true if the type can be used as a left value
     * @warning: does not consider type checking only the kind of value we are dealing with
     */
    pub def @final isLvalue (self)-> bool {
        self._isLvalue
    }
    
}

