mod ymirc::semantic::generator::type::base;

import ymirc::lexing::word;
import ymirc::utils::format;

import std::io;
import std::collection::vec;

import ymirc::semantic::generator::base;

/**
 * Ancestor of all kind of types
 */
pub class @abstract Type over Generator {

    /// True iif the type is mutable
    let _isMutable : bool;

    /// True if it is a reference
    let _isRef : bool = false;

    /// True if the type is completely immutable, and marked pure
    let _isPure : bool = false;

    /// True iif the type needs an explicit alias
    let mut _needExplicitAlias : bool = false;

    /// The mutability level refers to the level of the deepest mutable type
    let mut _mutabilityLevel : u32 = 0u32;
    
    /**
     * @params: 
     *    - loc: the location of the type
     *    - isMutable: true iif the type is mutable
     */
    pub self (loc : &Word, isMutable : bool = false)
        with super (loc), _isMutable = isMutable
    {
        self._mutabilityLevel = if (isMutable) { 1u32 } else { 0u32 }
    }

    
    /**
     * ================================================================================
     * ================================================================================
     * =========================           GETTERS            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * @returns: true iif the type if mutable
     */
    pub def @final isMutable (self)-> bool {
        self._isMutable
    }

    /**
     * @returns: true iif the type is a ref type
     */
    pub def @final isRef (self)-> bool {
        self._isRef
    }

    /**
     * @returns: True if the type is completely immutable, and marked pure
     */
    pub def @final isPure (self)-> bool {
        self._isPure
    }
    
    /**
     * @returns: true iif the type needs an implicit alias for memory borrowing
     */
    pub def @final needExplicitAlias (self)-> bool {
        self._needExplicitAlias
    }

    /**
     * @returns: the level of mutability of the type
     */
    pub def @final mutabilityLevel (self)-> u32 {
        self._mutabilityLevel
    }
    
    /**
     * ================================================================================
     * ================================================================================
     * =========================           CLONING            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Clone the type
     * @params: 
     *   - isMutable: true if the copy returns a mutable type
     */
    pub def clone (self, isMutable : bool)-> &Type;

    
    impl Streamable;
    impl Formattable;
    
}
