mod ymirc::semantic::generator::type::base;

import ymirc::lexing::word;
import ymirc::utils::format;

import std::io;
import std::collection::vec;

import ymirc::semantic::generator::base;

/**
 * Ancestor of all kind of types
 */
pub class @abstract Type over Generator {

    /// True iif the type is mutable
    let _isMutable : bool;

    /// True if the type is completely immutable, and marked pure
    let _isPure : bool = false;

    /// True iif the type needs an explicit alias
    let mut _needExplicitAlias : bool = false;

    /// The mutability level refers to the level of the deepest mutable type
    let mut _mutabilityLevel : u32 = 0u32;
    
    /**
     * @params: 
     *    - loc: the location of the type
     *    - isMutable: true iif the type is mutable
     */
    pub self (loc : &Word, isMutable : bool = false)
        with super (loc), _isMutable = isMutable
    {
        self._mutabilityLevel = if (isMutable) { 1u32 } else { 0u32 }
    }

    
    /**
     * ================================================================================
     * ================================================================================
     * =========================           GETTERS            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * @returns: true iif the type if mutable
     */
    pub fn @final isMutable (self)-> bool {
        self._isMutable
    }

    /**
     * @returns: True if the type is completely immutable, and marked pure
     */
    pub fn @final isPure (self)-> bool {
        self._isPure
    }
    
    /**
     * @returns: true iif the type needs an implicit alias for memory borrowing
     */
    pub fn @final needExplicitAlias (self)-> bool {
        self._needExplicitAlias
    }

    /**
     * @returns: the level of mutability of the type
     */
    pub fn @final mutabilityLevel (self)-> u32 {
        self._mutabilityLevel
    }

    /**
     * @returns: true iif the type borrows datas
     * */
    pub fn borrowDatas (self)-> bool;

    /**
     * ================================================================================
     * ================================================================================
     * =========================           CLONING            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Clone the type
     * @params: 
     *   - mutLevel: the mutabilityLevel of the clone
     */
    pub fn clone (self, mutLevel : u32)-> &Type;

    /**
     * Clone the type, applying the mutability pattern of 'pattern'
     * @example:
     * =====
     * // with a = mut [mut [mut i32]]
     * // with b = [f32]
     * b.clone (pattern-> a); // mut [mut f32]
     * =====
     * */
    pub fn clone (self, pattern : &Type)-> &Type {
        self.clone (mutLevel-> pattern.mutabilityLevel ())
    }

    /**
     * Clone the type into a deeply mutable version
     */
    pub fn toDeeplyMutable (self)-> &Type;

    /**
     * ================================================================================
     * ================================================================================
     * =========================           COMPARISON            ======================
     * ================================================================================
     * ================================================================================
     */

    /**
     * @returns: true if other is compatible to self
     * @warning: 
     * not necessarily commutative (e.g. slice => ([i32].isCompatible ([void]) && ![void].isCompatible ([i32])))
     * To have something commutative, use opEquals. Every types that are equals are compatible, but not the contrary
     */
    pub fn isCompatible (self, other : &Type)-> bool;

    
    impl Streamable;
    impl Formattable;
    
}
