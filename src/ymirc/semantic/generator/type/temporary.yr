in temporary;

pub mod ::classref;
pub mod ::closure;
pub mod ::lambda;
pub mod ::mapiterator;
pub mod ::templateref;
pub mod ::traitref;

use ymirc::lexing::word;

/**
 * A temportary type is a type that is not fully validated and cannot be used as is.
 */
@abstract
pub class TemporaryType over Type {

    pub self (loc : &Word, isMutable : bool = false)
        with super (loc, isMutable-> isMutable)
    {}

    /*!
     * ================================================================================
     * ================================================================================
     * =========================           GETTERS            =========================
     * ================================================================================
     * ================================================================================
     */

    pub over isDeeplyMutable (self)-> bool {
        self._isMutable
    }

    pub over needExplicitAlias (self)-> bool {
        false
    }

    pub over borrowDatas (self)-> bool {
        false
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================           COMPARISON            ======================
     * ================================================================================
     * ================================================================================
     */

    pub over mutabilityFit (self, o : &Type, borrowed : bool)-> bool {
        if (borrowed) {
            if (!self._isMutable && o._isMutable) return false;
        }

        true
    }

    pub over mutabilityDistance (self, o : &Type, borrowed : bool)-> u32 {
        if (borrowed) {
            if (self._isMutable && !o._isMutable) return 1u32;
        }

        0u32
    }

    pub over maxMutabilityDistance (self, borrowed : bool)-> u32 {
        if (borrowed) {
            return 1u32;
        }

        0u32
    }

    pub over sameMutability (self, o : &Type)-> bool {
        return (self._isMutable == o._isMutable);
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================           CLONING            =========================
     * ================================================================================
     * ================================================================================
     */

    pub over clone (self, o : &Type)-> &Type {
        if (o._isMutable && !self._isMutable) {
            self.clone (1u32)
        } else if (!o._isMutable && self._isMutable) {
            self.clone (0u32)
        } else {
            self
        }
    }

    pub over toDeeplyMutable (self)-> &Type {
        if (self._isMutable) { self }
        else {
            self.clone (1u32)
        }
    }

    pub over cloneMutableTilBorrow (self)-> &Type {
        self.clone (1u32)
    }

    pub over isAddressable (self)-> bool {
        false
    }

}
