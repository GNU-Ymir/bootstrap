mod ymirc::semantic::generator::type::native::compound::base;

import ymirc::semantic::generator::type::native::_;
import ymirc::semantic::generator::type::_;
import ymirc::lexing::word;
import ymirc::syntax::keys;
import ymirc::utils::format;

import std::collection::vec;
import std::io;

/**
 * A native type is a type that is defined by the language itself
 */
pub class @abstract CompoundType over NativeType {

    /// The sub types of the type
    let _inners : [&Type];
    
    pub self (loc : &Word, inners : [&Type], isMutable : bool = false)
        with super (loc, isMutable-> isMutable), _inners = inners 
    {}

    /**
     * ================================================================================
     * ================================================================================
     * =========================           GETTERS            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * @returns: the inner type of the compound type
     */
    pub fn getInners (self)-> [&Type] {
        self._inners
    }

    /**
     * @returns: the location of the field that generate implicit alias
     */
    pub fn getExplicitAliasFieldLoc (self)-> (&Type, &Word) {
        (self, self._loc)
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================           CLONING            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Clone the type, with the inner types already cloned
     * */
    prot fn clone (self, isMutable : bool, inners : [&Type])-> &Type;

    pub over clone (self, pattern : &Type)-> &Type {
        let dmut res = Vec!{&Type}::new ();

        match pattern {
            c : &CompoundType => {
                for i in 0us .. self._inners.len {
                    if (i < c._inners.len) {
                        res:.push (self._inners [i].clone (pattern-> c._inners [i]));
                    } else {
                        res:.push (self._inners [i].clone (mutLevel-> 0u32));
                    }
                }
            }
            _ => {
                for i in self._inners {
                    res:.push (i.clone (mutLevel-> 0u32));
                }
            }
        }

        self.clone (pattern.isMutable (), res[])
    }

    impl Streamable;
    impl Formattable;
    
}
