in value;

pub mod ::construct;
pub mod ::expandvalue;
pub mod ::globvarref;
pub mod ::literal;
pub mod ::macro_;
pub mod ::memory;
pub mod ::moduleref;
pub mod ::multsym;
pub mod ::namedvalue;
pub mod ::operator;
pub mod ::prototypes;
pub mod ::scope;
pub mod ::syntax;
pub mod ::template;
pub mod ::vardecl;
pub mod ::varref;


use ymirc::lexing::word;
use ymirc::utils::format;
use std::stream;
use ymirc::semantic::generator::type;

/**
 * Ancestor of all kind of values
 */
@abstract
pub class Value over Generator {

    // The type of the value
    let mut _type : &Type;

    // The list of types that can be thrown by the value
    let mut _throwers : [(&Word, &Type)] = [];

    // The location of the return statement in the value
    let mut _returnLoc : &Word = EOF_WORD;

    // The location of the break statement in the value
    let mut _breakLoc : &Word = EOF_WORD;

    // true iif the value can be used as a lvalue (without considering type checking)
    let mut _isLvalue : bool = false;

    // True if the value was generated by a reduction
    let _isReduced : bool = false;

    /**
     * @params:
     *    - loc: the location of the value
     */
    pub self (loc : &Word, type : &Type, isReduced : bool = false)
        with super (loc)
        , _type = type
        , _isReduced = isReduced
    {}

    /**
     * @params:
     *    - loc: the location of the value
     *    - refId: the override of the uniq Id
     */
    pub self (loc : &Word, type : &Type, refId : usize, isReduced : bool = false)
        with super (loc, refId-> refId)
        , _type = type
        , _isReduced = isReduced
    {}

    /*!
     * ================================================================================
     * ================================================================================
     * =========================           GETTERS            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * @returns: the type of the value
     */
    pub fn getType (self)-> &Type {
        self._type
    }

    /**
     * @returns: the list of types that can be thrown by the value
     */
    pub fn getThrowers (self)-> [(&Word, &Type)] {
        self._throwers
    }

    /**
     * Clear the list of throwers
     */
    pub fn clearThrowers (mut self) {
        self._throwers = [];
    }

    /**
     * @returns: true iif the value call a return in every branch
     */
    pub fn isReturner (self)-> bool {
        !self._returnLoc.isEof ()
    }

    /**
     * @returns: true iif the value call a break in every branch
     */
    pub fn isBreaker (self)-> bool {
        !self._breakLoc.isEof ()
    }

    /**
     * @returns: the location of the break inside the value
     */
    pub fn getBreakerLoc (self)-> &Word {
        self._breakLoc
    }

    /**
     * @returns: the location of the return inside the value
     */
    pub fn getReturnerLoc (self)-> &Word {
        self._returnLoc
    }

    /**
     * @returns: true if the type can be used as a left value
     * @warning: does not consider type checking only the kind of value we are dealing with
     */
    @final
    pub fn isLvalue (self)-> bool {
        self._isLvalue
    }

    /**
     * @returns: true if the value is reduced (optimized by the cte interpreter)
     * */
    @final
    pub fn isReduced (self)-> bool {
        self._isReduced
    }

    /**
     * @returns: true if the value can be created without calling function or allocating
     * */
    pub fn isFullLiteral (self)-> bool {
        false
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          COMPARISON          ===================================
     * ====================================================================================================
     * ====================================================================================================
     */

    pub over opEquals (self, o : &Generator)-> bool {
        match o {
            v : &Value => {
                if (self._type != v._type) return false;
                return true;
            }
        }

        return false;
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          CLONING          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Create an exact copy of the value with a different uniqId
     * */
    pub fn clone (self)-> &Value;

}
