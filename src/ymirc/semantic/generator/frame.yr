in frame;

use ymirc::semantic::generator::{type, value, value::prototypes::protovar};
use ymirc::semantic::validator::template::mapper;
use ymirc::semantic::symbol::path;

use ymirc::utils::format;
use ymirc::lexing::word;
use std::stream;

pub enum
| FUNC   = 1
| METHOD = 2
| CTOR   = 3
| DTOR   = 4
| LMBD   = 5
 -> FrameKind;

/**
 * A frame is a function that can be sent to the back end for final transformation and final code generation
 */
@final
pub class FrameGenerator over Generator {

    // The name of the frame
    let _name : &SymbolPath;

    // The list of parameters
    let _parameters : [&ProtoVarValue];

    // The return type of the frame
    let _retType : &Type;

    // The body of the frame
    let _body : &Value;

    // The external language of the frame (empty if not relevant)
    let _externLang : [c8];

    // The frame is weak (can be removed at the symbol linkage)
    let _isWeak : bool;

    // The template mapper used to generate the frame if generated by template specialization
    let _templateMapper : (TemplateMapper)?;

    let _kind : FrameKind;

    pub self (loc : &Word, name : &SymbolPath, parameters : [&ProtoVarValue], retType : &Type, body : &Value, kind : FrameKind, externLang : [c8] = "", isWeak : bool = false, templateMapper : TemplateMapper? = none)
        with super (loc)
        , _name = name
        , _parameters = parameters
        , _retType = retType
        , _body = body
        , _kind = kind
        , _externLang = externLang
        , _isWeak = isWeak
        , _templateMapper = templateMapper
    {}

    /*!
     * ================================================================================
     * ================================================================================
     * =========================          COMPARISON          =========================
     * ================================================================================
     * ================================================================================
     */

    pub over opEquals (self, o : &Generator)-> bool {
        match o {
            f : &FrameGenerator => {
                if (self._isWeak != f._isWeak) return false;
                if (self._externLang != f._externLang) return false;
                if (self._parameters.len != f._parameters.len) return false;

                for i in 0us .. self._parameters.len {
                    if (self._parameters [i] != f._parameters [i]) return false;
                }

                if (self._name.toStr () != f._name.toStr ()) return false;
                if (self._body != f._body) return false;
                if (self._retType != f._retType) return false;
                    
                true
            }
            _ => { false }
        }
    }    

    /*!
     * ================================================================================
     * ================================================================================
     * =============================        GETTERS         ===========================
     * ================================================================================
     * ================================================================================
     */

    pub fn getParameters (self)-> [&ProtoVarValue] {
        self._parameters
    }

    pub fn getReturnType (self)-> &Type {
        self._retType
    }

    pub fn getBody (self)-> &Value {
        self._body
    }

    pub fn getName (self)-> &SymbolPath {
        self._name
    }

    pub fn getKind (self)-> FrameKind {
        self._kind
    }

    pub fn isWeak (self)-> bool {
        self._isWeak
    }

    pub fn getExternalLang (self)-> [c8] {
        self._externLang
    }

    pub fn getTemplateMapper (self)-> TemplateMapper? {
        self._templateMapper
    }

    pub fn isTemplate (self)-> bool {
        match self._templateMapper {
            Ok () => { true }
            _ => { false }
        }
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================        MISCELLANEOUS         =========================
     * ================================================================================
     * ================================================================================
     */

    impl Streamable;
    impl Formattable {
        pub over format (self, dmut stream : &Formatter) {
            stream:.write ("frame :");
            if (self._isWeak) { stream:.write (" [weak]"); }
            if (self._externLang != "") { stream:.write (" from [", self._externLang, "]");}
            stream:.write (' ', self._name.toStr (), ' ');
            stream:.write ('(');
            stream:.entabing ();
            for i in 0us .. self._parameters.len {
                if (i != 0us) stream:.write (", ");
                self._parameters [i].format (alias stream);
            }
            stream:.write (")-> ");
            self._retType.format (alias stream);
            stream:.write (' ');
            stream:.detabing ();
            
            self._body.format (alias stream);
        }
    }
}
