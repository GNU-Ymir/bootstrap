mod ymirc::semantic::generator::frame;

import ymirc::semantic::generator::base;
import ymirc::semantic::generator::type::base;
import ymirc::semantic::generator::value::base;

import ymirc::utils::format;
import ymirc::lexing::word;
import std::fs::path;
import std::io;


/**
 * A frame is a function that can be sent to the back end for final transformation and final code generation
 */
pub class @final FrameGenerator over Generator {

    /// The name of the frame
    let _name : &Path;

    /// The list of parameters
    let _parameters : [&Value];

    /// The return type of the frame
    let _retType : &Type;

    /// The body of the frame
    let _body : &Value;

    /// The frame body is not a returner and thus we must add a return at the end
    let _needFinalReturn : bool;

    /// The external language of the frame (empty if not relevant)
    let _externLang : [c8];

    /// The frame is weak (can be removed at the symbol linkage)
    let _isWeak : bool;

    
    pub self (loc : &Word, name : &Path, parameters : [&Value], retType : &Type, body : &Value, needFinalReturn : bool = false, externLang : [c8] = ""s8, isWeak : bool = false)
        with super (loc), _name = name, _parameters = parameters, _retType = retType, _body = body, _needFinalReturn = needFinalReturn, _externLang = externLang, _isWeak = isWeak
    {}


    /**
     * ================================================================================
     * ================================================================================
     * =========================          COMPARISON          =========================
     * ================================================================================
     * ================================================================================
     */

    pub over opEquals (self, o : &Generator)-> bool {
        match o {
            f : &FrameGenerator => {
                if (self._isWeak != f._isWeak ||
                    self._needFinalReturn != f._needFinalReturn) return false;
                if (self._externLang != f._externLang) return false;
                if (self._parameters.len != f._parameters.len) return false;

                for i in 0us .. self._parameters.len {
                    if (self._parameters [i] != f._parameters [i]) return false;
                }

                if (self._name.toStr () != f._name.toStr ()) return false;
                if (self._body != f._body) return false;
                if (self._retType != f._retType) return false;
                    
                true
            }
            _ => { false }
        }
    }    
    
    /**
     * ================================================================================
     * ================================================================================
     * =========================        MISCELLANEOUS         =========================
     * ================================================================================
     * ================================================================================
     */

    impl Streamable;
    impl Formattable {

        pub over format (self, dmut stream : &Formatter) {
            stream:.write ("frame :"s8);
            if (self._isWeak) { stream:.write (" [weak]"s8); }
            if (self._externLang != ""s8) { stream:.write (" from ["s8, self._externLang, "]"s8);}
            stream:.write (' 'c8, self._name.toStr (sep-> "::"s8), ' 'c8);
            stream:.write ('('c8);
            stream:.entabing ();
            for i in 0us .. self._parameters.len {
                if (i != 0us) stream:.write (", "s8);
                self._parameters [i].format (alias stream);
            }
            stream:.write (")-> "s8);
            self._retType.format (alias stream);
            stream:.write (' 'c8);
            stream:.detabing ();
            
            self._body.format (alias stream);

        }
    }
    

}
