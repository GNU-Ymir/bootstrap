mod ymirc::semantic::generator::frame;

import ymirc::semantic::generator::base;
import ymirc::semantic::generator::type::base;
import ymirc::semantic::generator::value::base;
import ymirc::semantic::generator::value::prototypes::protovar;
import ymirc::semantic::validator::template::mapper;
import ymirc::semantic::symbol::path;

import ymirc::utils::format;
import ymirc::lexing::word;
import std::io;

pub enum
| FUNC = 1
| METHOD = 2
| CTOR = 3
| DTOR = 4
| LMBD = 5
 -> FrameKind;

/**
 * A frame is a function that can be sent to the back end for final transformation and final code generation
 */
pub class @final FrameGenerator over Generator {

    /// The name of the frame
    let _name : &SymbolPath;

    /// The list of parameters
    let _parameters : [&ProtoVarValue];

    /// The return type of the frame
    let _retType : &Type;

    /// The body of the frame
    let _body : &Value;

    /// The external language of the frame (empty if not relevant)
    let _externLang : [c8];

    /// The frame is weak (can be removed at the symbol linkage)
    let _isWeak : bool;

    // The template mapper used to generate the frame if generated by template specialization
    let _templateMapper : (&TemplateMapper)?;

    let _kind : FrameKind;

    pub self (loc : &Word, name : &SymbolPath, parameters : [&ProtoVarValue], retType : &Type, body : &Value, kind : FrameKind, externLang : [c8] = ""s8, isWeak : bool = false, templateMapper : &TemplateMapper? = ((&TemplateMapper)?)::__err__)
        with super (loc)
        , _name = name
        , _parameters = parameters
        , _retType = retType
        , _body = body
        , _kind = kind
        , _externLang = externLang
        , _isWeak = isWeak
        , _templateMapper = templateMapper
    {}

    /*!
     * ================================================================================
     * ================================================================================
     * =========================          COMPARISON          =========================
     * ================================================================================
     * ================================================================================
     */

    pub over opEquals (self, o : &Generator)-> bool {
        match o {
            f : &FrameGenerator => {
                if (self._isWeak != f._isWeak) return false;
                if (self._externLang != f._externLang) return false;
                if (self._parameters.len != f._parameters.len) return false;

                for i in 0us .. self._parameters.len {
                    if (self._parameters [i] != f._parameters [i]) return false;
                }

                if (self._name.toStr () != f._name.toStr ()) return false;
                if (self._body != f._body) return false;
                if (self._retType != f._retType) return false;
                    
                true
            }
            _ => { false }
        }
    }    

    /*!
     * ================================================================================
     * ================================================================================
     * =============================        GETTERS         ===========================
     * ================================================================================
     * ================================================================================
     */

    pub fn getParameters (self)-> [&ProtoVarValue] {
        self._parameters
    }

    pub fn getReturnType (self)-> &Type {
        self._retType
    }

    pub fn getBody (self)-> &Value {
        self._body
    }

    pub fn getName (self)-> &SymbolPath {
        self._name
    }

    pub fn getKind (self)-> FrameKind {
        self._kind
    }

    pub fn isWeak (self)-> bool {
        self._isWeak
    }

    pub fn getExternalLang (self)-> [c8] {
        self._externLang
    }

    pub fn getTemplateMapper (self)-> &TemplateMapper? {
        self._templateMapper
    }

    pub fn isTemplate (self)-> bool {
        match self._templateMapper {
            Ok () => { true }
            _ => { false }
        }
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================        MISCELLANEOUS         =========================
     * ================================================================================
     * ================================================================================
     */

    impl Streamable;
    impl Formattable {

        pub over format (self, dmut stream : &Formatter) {
            stream:.write ("frame :"s8);
            if (self._isWeak) { stream:.write (" [weak]"s8); }
            if (self._externLang != ""s8) { stream:.write (" from ["s8, self._externLang, "]"s8);}
            stream:.write (' 'c8, self._name.toStr (), ' 'c8);
            stream:.write ('('c8);
            stream:.entabing ();
            for i in 0us .. self._parameters.len {
                if (i != 0us) stream:.write (", "s8);
                self._parameters [i].format (alias stream);
            }
            stream:.write (")-> "s8);
            self._retType.format (alias stream);
            stream:.write (' 'c8);
            stream:.detabing ();
            
            self._body.format (alias stream);

        }
    }
    

}
