in visitor;

use std::{config::_, fs::path};
use ymirc::lexing::word;
use ymirc::utils::format;

use ymirc::syntax::{_,
                    declaration::_,
                    expression::{_, literal::_, macro_::_, operator::_, template::_}};

use ymirc::semantic::{generator::_, symbol::{_, macro_::_}};
use ymirc::semantic::validator::utf;
use ymirc::semantic::generator::type::{_,
                                       syntax::_,
                                       custom::_,
                                       native::{_, scalar::_, compound::_},
                                       temporary::_};

use ymirc::semantic::generator::value::{_,
                                        syntax::_,
                                        construct::{_, delegate::_},
                                        literal::_,
                                        memory::_,
                                        operator::{_, binary::_, call::_, fields::_, map::_, slice::_, unary::_},
                                        operator::map::iteration::_,
                                        prototypes::_,
                                        scope::_,
                                        syntax::_,
                                        template::_};


/**
 * Class used to produce the documentation of a module and all its content
 * */
pub record DocVisitor {

    let _packageDir : Path;

    pub self (packageDir : Path)
        with _packageDir = packageDir
    {}

    /**
     * Dump the documentation of a symbol and its childrens
     * @params:
     *    - sym: the symbol whose documentation to dump
     * @returns: the documentation of the symbol
     * */
    pub fn dump (self, sym : &Symbol)-> &Config {
        match sym {
            m : &ModuleSymbol => {
                return self.dumpModule (m);
            }
            f : &FunctionSymbol => {
                return self.dumpFunction (f);
            }
            c : &ClassSymbol => {
                return self.dumpClass (c);
            }
            t : &TraitSymbol => {
                return self.dumpTrait (t);
            }
            e : &EnumSymbol => {
                return self.dumpEnum (e);
            }
            g : &GlobalSymbol => {
                return self.dumpGlobal (g);
            }
            a : &AkaSymbol => {
                return self.dumpAka (a);
            }
            m : &MacroSymbol => {
                return self.dumpMacro (m);
            }
            t : &TemplateSymbol => {
                return self.dumpTemplate (t);
            }
        }

        return copy None ();
    }

    /**
     * Dump the standard documentation information of a symbol (i.e. name, location, protection and comments)
     * @params:
     *    - sym: the symbol
     * */
    fn dumpStandard (self, sym : &Symbol, dmut res : &Dict) {
        res:["name"] = copy Str (sym.getPath ().toStr ());
        res:["loc_file"] = copy Str (Path (sym.getLoc ().filename).removePrefix (self._packageDir).toStr ());
        res:["loc_line"] = copy Int (cast!i64 (sym.getLoc ().line));
        res:["loc_col"] = copy Int (cast!i64 (sym.getLoc ().col));
        res:["doc"] = copy Str (utf::instance ().unescape (sym.getComments ()));

        match sym.getProtection () {
            Protection::PUBLIC => { res:["protect"] = copy Str ("pub"); }
            Protection::PROTECTED => { res:["protect"] = copy Str ("prot"); }
            _ => { res:["protect"] = copy Str ("prv"); }
        }
    }

    /**
     * Dump the standard documentation information of a symbol (i.e. name, location, protection and comments)
     * */
    fn dumpStandard (self, name : [c8], comments : [c8], loc : &Word, protection : Protection, dmut res : &Dict) {
        res:["name"] = copy Str (name);
        res:["loc_file"] = copy Str (Path (loc.filename).removePrefix (self._packageDir).toStr ());
        res:["loc_line"] = copy Int (cast!i64 (loc.line));
        res:["loc_col"] = copy Int (cast!i64 (loc.col));
        res:["doc"] = copy Str (utf::instance ().unescape (comments));

        match protection {
            Protection::PUBLIC => { res:["protect"] = copy Str ("pub"); }
            Protection::PROTECTED => { res:["protect"] = copy Str ("prot"); }
            _ => { res:["protect"] = copy Str ("prv"); }
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =====================================          MODULE          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Dump the documentation of a module
     * */
    fn dumpModule (self, m : &ModuleSymbol)-> &Config {
        if (m.isExtern ()) return copy None ();

        let dmut res = copy Dict ();
        res:["kind"] = copy Str ("module");
        self.dumpStandard (m, alias res);

        let dmut childs = copy Array ();
        let inners = m.getAllLocalSymbols (protection-> Protection::PRIVATE);
        for i in inners match self.dump (i) {
            None () => {}
            c : _ => {
                childs:.push (c);
            }
        }

        res:["childs"] = childs;
        return res;
    }

    /**
     * Dimp the documentation of an unvalidate module
     * */
    fn dumpModuleUnvalidated (self, m : &ModuleDecl, protection : Protection)-> &Config {
        let dmut res = copy Dict ();
        res:["kind"] = copy Str ("module");
        self.dumpStandard (m.getLoc ().str, m.getComments (), m.getLoc (), protection, alias res);

        let dmut childs = copy Array ();
        for i in m.getDeclarations () {
            self.dumpUnvalidated (i, protection-> Protection::PRIVATE, alias childs);
        }
        res:["childs"] = childs;
        res
    }


    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          FUNCTIONS          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Dump the documentation of a function symbol
     * */
    fn dumpFunction (self, f : &FunctionSymbol)-> &Config {
        if let p : &CtorPrototypeValue = f.getFrameProto () {
            return self.dumpCtor (p);
        }

        if let _ : &DtorPrototypeValue = f.getFrameProto () {
            return copy None ();
        }

        if let p : &MethodPrototypeValue = f.getFrameProto () {
            return self.dumpMethod (p);
        }

        if let p : &PrototypeValue = f.getFrameProto () {
            return self.dumpFunction (p);
        }

        self.dumpFunctionUnvalidated (f)
    }

    /**
     * Dump the documentation of a classical function
     * */
    fn dumpFunction (self, proto : &PrototypeValue)-> &Config {
        let dmut res = copy Dict ();
        res:["kind"] = copy Str ("function");
        self.dumpStandard (proto.getSymbol (), alias res);
        self.dumpParams (proto.getParameters (), alias res);
        self.dumpThrowers (proto.getThrowers (), alias res);

        let dmut attrs = copy Array ();
        if (proto.isUnsafe ()) attrs:.push (copy Str ("unsafe"));
        if (proto.isInline ()) attrs:.push (copy Str ("inline"));
        res:["attributes"] = attrs;
        res:["ret_type"] = self.dumpType (proto.getRetType ());

        res
    }

    /**
     * Dump the documentation of a ctor
     * */
    fn dumpCtor (self, ctor : &CtorPrototypeValue)-> &Config {
        let dmut res = copy Dict ();
        res:["kind"] = copy Str ("ctor");
        self.dumpStandard (ctor.getSymbol (), alias res);
        self.dumpParams (ctor.getParameters (), alias res);
        self.dumpThrowers (ctor.getThrowers (), alias res);

        res
    }

    /**
     * Dump the documentation of a method
     * */
    fn dumpMethod (self, meth : &MethodPrototypeValue)-> &Config {
        let dmut res = copy Dict ();
        res:["kind"] = copy Str ("method");

        self.dumpStandard (meth.getSymbol (), alias res);
        self.dumpParams (meth.getParameters (), alias res);
        let dmut attrs = copy Array ();
        if (meth.isFinal ()) attrs:.push (copy Str ("final"));
        if (meth.isVirtual ()) attrs:.push (copy Str ("virtual"));
        if (meth.isEmpty ()) attrs:.push (copy Str ("abstract"));
        if (meth.isField ()) attrs:.push (copy Str ("field"));
        res:["attributes"] = attrs;

        if (meth.isMutable ()) {
            res:["mutable"] = copy Bool (true);
        } else { res:["mutable"] = copy Bool (false); }

        self.dumpThrowers (meth.getThrowers (), alias res);
        res:["ret_type"] = self.dumpType (meth.getRetType ());

        res
    }

    /**
     * Dump the throwers of a function
     * */
    fn dumpThrowers (self, throwers : [(&Word, &Type)], dmut res : &Dict) {
        let dmut thrs = copy Array ();
        for t in throwers {
            thrs:.push (self.dumpType (t._1));
        }

        res:["throwers"] = thrs;
    }

    /**
     * Dump the parameters of a function
     * */
    fn dumpParams (self, funcParams : [&ProtoVarValue], dmut res : &Dict) {
        let dmut parameters = copy Array ();
        for v in funcParams {
            let dmut param = copy Dict ();
            param:["name"] = copy Str (v.getName ());
            param:["type"] = self.dumpType (v.getType ());
            param:["mutability"] = copy Str (if (v.getType ().isDeeplyMutable () && v.getType ().borrowDatas ()) { "dmut" } else if (v.isMutable ()) { "mut" } else { "" });
            param:["ref"] = copy Bool (v.isReference ());
            param:["lazy"] = copy Bool (v.isLazy ());

            if (v.getDefaultValue () !of UnitValue) {
                param:["value"] = copy Str (utf::instance ().unescape (format ("%", v.getDefaultValue ())));
            }

            parameters:.push (param);
        }

        res:["params"] = parameters;
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =============================          UNVALIDATED FUNCTIONS          ==============================
     * ====================================================================================================
     * ====================================================================================================
     */


    /**
     * Dump an unvalidated function symbol
     * */
    fn dumpFunctionUnvalidated (self, f : &FunctionSymbol)-> &Config {
        let dmut res = copy Dict ();
        res:["kind"] = if (f.isMethod ()) { copy Str ("method") } else { copy Str ("function") };
        self.dumpStandard (f, alias res);
        self.dumpFunctionUnvalidated (f.getContent (), alias res, forMethod-> f.isMethod (), noStandard-> true);
        res
    }

    /**
     * Dump a unvalidate constructor
     * */
    fn dumpCtorUnvalidated (self, c : &ConstructorDecl, dmut res : &Dict, noStandard : bool = false, protection : Protection) {
        if (!noStandard) {
            res:["kind"] = copy Str ("ctor");
            let name = if (c.getRename ().isEof ()) { c.getLoc ().str } else { c.getRename ().str };
            self.dumpStandard (name, c.getComments (), c.getLoc (), protection, alias res);
        }

        self.dumpParamsUnvalidated (c.getFunctionProtoDecl ().getParameters (), alias res);
        self.dumpThrowerUnvalidated (c.getThrowers (), alias res);
    }

    /**
     * Dump an unvalidated function content
     * */
    fn dumpFunctionUnvalidated (self, f : &FunctionDecl, dmut res : &Dict, forMethod : bool, protection : Protection = Protection::PRIVATE, noStandard : bool = false) {
        if (!noStandard) {
            res:["kind"] = if (forMethod) { copy Str ("method") } else { copy Str ("function") };
            self.dumpStandard (f.getLoc ().str, f.getComments (), f.getLoc (), protection, alias res);
        }

        self.dumpParamsUnvalidated (f.getFunctionProto ().getParameters (), alias res, forMethod-> forMethod);
        self.dumpThrowerUnvalidated (f.getThrowers (), alias res);
        res:["ret_type"] = self.dumpTypeUnvalidated (f.getFunctionProto ().getRetType ());

        if (forMethod) {
            if (f.getFunctionProto ().getParameters ()[0].isMutable ()) {
                res:["mutable"] = copy Bool (true);
            } else res:["mutable"] = copy Bool (false);
        }

        let dmut attrs = copy Array ();
        for a in f.getAttributes () {
            attrs:.push (copy Str (a.attr));
        }
        res:["attributes"] = attrs;
    }

    /**
     * Dump the parameters of a function that is not validated
     * */
    fn dumpParamsUnvalidated (self, proto : [&VarDeclExpr], dmut res : &Dict, forMethod : bool = false) {
        let dmut parameters = copy Array ();
        for i, v in proto {
            if (!forMethod || i != 0) { // skip self for methods
                let dmut param = copy Dict ();
                param:["name"] = copy Str (v.getName ().str);
                param:["type"] = self.dumpTypeUnvalidated (v.getType ());
                param:["mutability"] = copy Str (if (v.isDeeplyMutable ()) { "dmut" } else if (v.isMutable ()) { "mut" } else { "" });
                param:["ref"] = copy Bool (v.isRef ());
                param:["lazy"] = copy Bool (v.isLazy ());

                if (v.getValue () !of EmptyExpression) {
                    param:["value"] = copy Str (utf::instance ().unescape (format ("%", v.getValue ())));
                }

                parameters:.push (param);
            }
        }

        res:["params"] = parameters;
    }

    /**
     * Dump the documentation of throwers of a function that is not validated
     * */
    fn dumpThrowerUnvalidated (self, throwers : [&Expression], dmut res : &Dict) {
        let dmut thrs = copy Array ();
        for t in throwers {
            thrs:.push (self.dumpTypeUnvalidated (t));
        }

        res:["throwers"] = thrs;
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =====================================          CLASS          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Dump the documentation class
     * */
    fn dumpClass (self, c : &ClassSymbol)-> &Config {
        if let r : &ClassRefType = c.getClassRef () {
            return self.dumpClass (c, r);
        }

        copy None ()
    }

    /**
     * Dump the documentation of a class reference
     * */
    fn dumpClass (self, c : &ClassSymbol, cref : &ClassRefType)-> &Config {
        let dmut res = copy Dict ();

        self.dumpStandard (c, alias res);

        if (cref.isStruct () && !cref.isMovable ()) { res:["kind"] = copy Str ("record"); }
        else if (cref.isStruct ()) { res:["kind"] = copy Str ("entity"); }
        else {
            res:["kind"] = copy Str ("class");

            if (cref.getAncestor () !of NoneType) {
                res:["ancestor"] = self.dumpType (cref.getAncestor ());
            }

            res:["has_dtor"] = copy Bool (cref.getDestructor () !of UnitValue);
            res:["abstract"] = copy Bool (cref.getSymbol ().isAbstract ());
            res:["final"] = copy Bool (cref.getSymbol ().isFinal ());
        }

        self.dumpClassFields (cref, alias res);
        self.dumpAssertions (cref, alias res);
        self.dumpCtors (cref, alias res);
        self.dumpTemplateCtors (cref, alias res);
        self.dumpMethods (cref, alias res);
        self.dumpTemplateMethods (cref, alias res);
        self.dumpImpl (cref, alias res);

        res
    }

    /**
     * Dump the documentation of the fields of a class
     * */
    fn dumpClassFields (self, cref : &ClassRefType, dmut res : &Dict) {
        let dmut fields = copy Array ();
        for i, v in cref.getLocalFields () {
            let dmut fi = copy Dict ();
            fi:["name"] = copy Str (v.getLoc ().str);
            fi:["mutability"] = copy Str (if (v.getVarType ().isDeeplyMutable () && v.getVarType ().borrowDatas ()) { "dmut" } else if (v.isMutable ()) { "mut" } else { "" });
            fi:["ref"] = copy Bool (v.isReference ());
            fi:["lazy"] = copy Bool (v.isLazy ());
            fi:["doc"] = copy Str (utf::instance ().unescape (cref.getSymbol ().getFieldComments ()[i]));
            fi:["protect"] = copy Str (if (cref.getSymbol ().isFieldPrivate (v.getLoc ().str)) { "prv" } else if (cref.getSymbol ().isFieldProtected (v.getLoc ().str)) { "prot" } else { "pub"});
            fi:["type"] = self.dumpType (v.getVarType ());
            fields:.push (fi);
        }

        res:["fields"] = fields;
    }

    /**
     * Dump the assertions of the class
     * */
    fn dumpAssertions (self, cref : &ClassRefType, dmut res : &Dict) {
        let dmut assertions = copy Array ();
        for i, a in cref.getSymbol ().getAssertions () if let exp : &AssertExpr = a {
            let dmut as = copy Dict ();
            as:["test"] = copy Str (utf::instance ().unescape (format ("%", exp.getTest ())));
            as:["msg"] = copy Str (utf::instance ().unescape (format ("%", exp.getMessage ())));
            as:["doc"] = copy Str (utf::instance ().unescape (cref.getSymbol ().getAssertionComments ()[i]));
            assertions:.push (as);
        }

        res:["asserts"] = assertions;
    }

    /**
     * Dump the constructor of a class
     * */
    fn dumpCtors (self, cref : &ClassRefType, dmut res : &Dict) {
        let dmut ctors = copy Array ();
        for c in cref.getCtors () if let ct : &CtorPrototypeValue = c {
            ctors:.push (self.dumpCtor (ct));
        }

        res:["ctors"] = ctors;
    }

    /**
     * Dump the template constructor of a class
     * */
    fn dumpTemplateCtors (self, cref : &ClassRefType, dmut res : &Dict) {
        let dmut ctors = copy Array ();
        for c in cref.getTemplateCtors () {
            let dmut tmp = copy Dict ();
            tmp:["kind"] = copy Str ("template");
            self.dumpTemplateParams (c.getSymbol ().getContent (), alias tmp);
            if let ct : &ConstructorDecl = c.getSymbol ().getContent ().getContent () {
                let name = if (ct.getRename ().isEof ()) { ct.getLoc ().str } else { ct.getRename ().str };
                self.dumpStandard (name, c.getSymbol ().getComments (), c.getLoc (), protection-> c.getSymbol ().getProtection (), alias tmp);

                let dmut inner = copy Dict ();
                self.dumpCtorUnvalidated (ct, alias inner, noStandard-> false, protection-> Protection::PUBLIC);
                let dmut childs = copy Array ();
                childs:.push (inner);
                tmp:["content"] = childs;
            }

            ctors:.push (tmp);
        }

        res:["template_ctors"] = ctors;
    }

    /**
     * Dump the methods of a class
     * */
    fn dumpMethods (self, cref : &ClassRefType, dmut res : &Dict) {
        let dmut meths = copy Array ();
        for m in cref.getVtable () if m.getClassRef () == cref && m.getTrait () of EmptySymbol {
            meths:.push (self.dumpMethod (m));
        }

        res:["methods"] = meths;
    }

    /**
     * Dump the template method of a class
     * */
    fn dumpTemplateMethods (self, cref : &ClassRefType, dmut res : &Dict) {
        let dmut meths = copy Array ();
        for m in cref.getTemplateMethods () if m.getClassSymbol () == cref.getSymbol () {
            let dmut tmp = copy Dict ();
            tmp:["kind"] = copy Str ("template");
            self.dumpStandard (m.getSymbol (), alias tmp);
            self.dumpTemplateParams (m.getSymbol ().getContent (), alias tmp);
            if let f : &FunctionDecl = m.getSymbol ().getContent ().getContent () {
                let dmut inner = copy Dict ();
                self.dumpFunctionUnvalidated (f, alias inner, forMethod-> true, noStandard-> false, protection-> Protection::PUBLIC);
                let dmut childs = copy Array ();
                childs:.push (inner);
                tmp:["content"] = childs;
            }

            meths:.push (tmp);
        }

        res:["template_methods"] = meths;
    }

    /**
     * Dump the list of trait implemented by the class
     * */
    fn dumpImpl (self, cref : &ClassRefType, dmut res : &Dict) {
        let dmut tr = copy Array ();
        for t in cref.getImplTraits () {
            tr:.push (copy Str (t.getSymbol ().getPath ().toStr ()));
        }

        res:["implements"] = tr;
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===============================          UNVALIDATED CLASS          ================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Dump a class symbol that has not been validated
     * */
    fn dumpClassUnvalidated (self, cl : &ClassDecl, protection : Protection)-> &Config {
        let dmut res = copy Dict ();
        self.dumpStandard (cl.getLoc ().str, cl.getComments (), cl.getLoc (), protection, alias res);

        let mut is_class = false;
        if (cl.isStruct () && cl.isRecord ()) { res:["kind"] = copy Str ("record"); }
        else if (cl.isStruct ()) { res:["kind"] = copy Str ("entity"); }
        else {
            res:["kind"] = copy Str ("class");
            if cl.getAncestor () !of EmptyExpression {
                res:["ancestor"] = self.dumpTypeUnvalidated (cl.getAncestor ());
            }
            is_class = true;

            for a in cl.getAttributes () {
                if (a.attr == Attributes::ABSTRACT) { res:["abstract"] = copy Bool (true); }
                if (a.attr == Attributes::FINAL) { res:["final"] = copy Bool (true); }
            }
        }


        let dmut fields = copy Array ();
        let dmut assertions = copy Array ();
        let dmut ctors = copy Array (), dmut temp_ctors = copy Array ();
        let dmut meths = copy Array (), dmut temp_meths = copy Array ();
        let dmut implements = copy Array ();

        let mut has_dtor = false;
        for d in cl.getDeclarations () {
            if (self.dumpClassUnvalidatedInner (d, protection-> Protection::PROTECTED,
                                                alias fields,
                                                alias assertions,
                                                alias ctors, alias temp_ctors,
                                                alias meths, alias temp_meths,
                                                alias implements)) {
                has_dtor = true;
            }
        }

        if (is_class) {
            res:["has_dtor"] = copy Bool (has_dtor);
        }

        res
    }

    /**
     * Dump the documentation of the inner content of a class that has not been validated yet
     * */
    fn dumpClassUnvalidatedInner (self, d : &Declaration, protection : Protection, dmut fields : &Array, dmut assertions : &Array, dmut ctors : &Array, dmut temp_ctors : &Array, dmut meths : &Array, dmut temp_meths : &Array, dmut implements : &Array)-> bool {
        match d {
            dl : &BlockDecl => {
                let mut has_dtor = false;
                let inProt = if dl.isSet () { protection } else { dl.getProtection () };
                for i in dl.getDeclarations () {
                    if (self.dumpClassUnvalidatedInner (i, protection-> inProt,
                                                        alias fields,
                                                        alias assertions,
                                                        alias ctors, alias temp_ctors,
                                                        alias meths, alias temp_meths,
                                                        alias implements)) {
                        has_dtor = true;
                    }
                }

                return has_dtor;
            }
            ct : &ConstructorDecl => {
                let dmut inner = copy Dict ();
                self.dumpCtorUnvalidated (ct, alias inner, noStandard-> false, protection-> Protection::PUBLIC);
                ctors:.push (inner);
            }
            DestructorDecl () => { return true; }
            im : &ImplDecl => {
                implements:.push (self.dumpTypeUnvalidated (im.getTrait ()));
            }
            g : &GlobalDecl => {
                fields:.push (self.dumpClassFieldUnvalidated (g, protection-> protection));
            }
            wrp : &ExpressionWrapperDecl => {
                if let a : &AssertExpr = wrp.getContent () {
                    let dmut as = copy Dict ();
                    as:["test"] = copy Str (utf::instance ().unescape (format ("%", a.getTest ())));
                    as:["msg"] = copy Str (utf::instance ().unescape (format ("%", a.getMessage ())));
                    as:["doc"] = copy Str (utf::instance ().unescape (wrp.getComments ()));
                    assertions:.push (as);
                }
            }
            f : &FunctionDecl => {
                let dmut res = copy Dict ();
                self.dumpFunctionUnvalidated (f, alias res, forMethod-> true, noStandard-> false, protection-> protection);
                meths:.push (res);
            }
            t : &TemplateDecl => {
                let dmut tmp = copy Dict ();
                let dmut childs = copy Array ();
                tmp:["kind"] = copy Str ("template");
                self.dumpTemplateParams (t, alias tmp);

                match t.getContent () {
                    f : &FunctionDecl => {
                        self.dumpStandard (f.getLoc ().str, t.getComments (), t.getLoc (), protection, alias tmp);
                        let dmut inner = copy Dict ();
                        self.dumpFunctionUnvalidated (f, alias inner, forMethod-> true, noStandard-> false, protection-> protection);
                        childs:.push (inner);
                        tmp:["content"] = childs;
                        temp_meths:.push (tmp);
                    }
                    c : &ConstructorDecl => {
                        let name = if (c.getRename ().isEof ()) { c.getLoc ().str } else { c.getRename ().str };
                        self.dumpStandard (name, t.getComments (), t.getLoc (), protection, alias tmp);
                        let dmut inner = copy Dict ();
                        self.dumpCtorUnvalidated (c, alias inner, noStandard-> false, protection-> Protection::PUBLIC);
                        childs:.push (inner);
                        tmp:["content"] = childs;
                        temp_ctors:.push (tmp);
                    }
                }
            }
        }

        false
    }

    /**
     * Dump the documentation of a field of a class that is not validated
     * */
    fn dumpClassFieldUnvalidated (self, field : &GlobalDecl, protection : Protection)-> &Config {
        let v = field.getContent ();
        let dmut fi = copy Dict ();
        fi:["name"] = copy Str (v.getName ().str);
        fi:["type"] = self.dumpTypeUnvalidated (v.getType ());
        fi:["mutability"] = copy Str (if (v.isDeeplyMutable ()) { "dmut" } else if (v.isMutable ()) { "mut" } else { "" });
        fi:["ref"] = copy Bool (v.isRef ());
        fi:["doc"] = copy Str (utf::instance ().unescape (field.getComments ()));
        fi:["lazy"] = copy Bool (v.isLazy ());
        fi:["protect"] = copy Str (if protection == Protection::PRIVATE { "prv" } else if protection == Protection::PROTECTED { "prot" } else { "pub" });

        if (v.getValue () !of EmptyExpression) {
            fi:["value"] = copy Str (utf::instance ().unescape (format ("%", v.getValue ())));
        }

        fi
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =====================================          TRAITS          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Dump the documentation of a trait symbol
     * */
    fn dumpTrait (self, t : &TraitSymbol)-> &Config {
        let dmut res = copy Dict ();
        res:["kind"] = copy Str ("trait");
        self.dumpStandard (t, alias res);

        let dmut childs = copy Array ();
        for i in t.getAllLocalSymbols (protection-> Protection::PRIVATE) match i {
            f : &FunctionSymbol => {
                childs:.push (self.dumpFunctionUnvalidated (f));
            }
        }

        res:["childs"] = childs;
        return res;
    }

    /**
     * Dump the documentation of a trait that has not been validated
     * */
    fn dumpTraitUnvalidated (self, t : &TraitDecl, protection : Protection)-> &Config {
        let dmut res = copy Dict ();
        res:["kind"] = copy Str ("trait");
        self.dumpStandard (t.getLoc ().str, t.getComments (), t.getLoc (), protection, alias res);

        let dmut childs = copy Array ();
        for i in t.getDeclarations () {
            self.dumpTraitUnvalidatedInner (i, alias childs, protection-> Protection::PROTECTED);
        }
        res:["childs"] = childs;
        res
    }

    /**
     * Dump the content of an unvalidated trait
     * */
    fn dumpTraitUnvalidatedInner (self, d : &Declaration, dmut res : &Array, protection : Protection) {
        match d {
            dl : &BlockDecl => {
                for i in dl.getDeclarations () {
                    self.dumpTraitUnvalidatedInner (i, alias res, protection-> dl.getProtection ());
                }
            }
            f : &FunctionDecl => {
                let dmut ch = copy Dict ();
                self.dumpFunctionUnvalidated (f, alias ch, forMethod-> true, protection-> protection, noStandard-> false);
                res:.push (ch);
            }
            _ => {}
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ==================================          ENUMERATION          ===================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Dump the documentation of an enum symbol
     * */
    fn dumpEnum (self, e : &EnumSymbol)-> &Config {
        match e.getGenerator () {
            EmptyGenerator () => {
                return self.dumpEnumUnvalidated (e.getContent (), protection-> e.getProtection ());
            }
        }

        let dmut res = copy Dict ();
        res:["kind"] = copy Str ("enum");
        self.dumpStandard (e, alias res);

        let dmut fields = copy Array ();
        for i, f in e.getAllFields () {
            let doc = e.getContent ().getFieldComms ()[i];
            let dmut fi = copy Dict ();
            fi:["name"] = copy Str (f._0);
            fi:["value"] = copy Str (utf::instance ().unescape (format ("%", f._1)));
            fi:["doc"] = copy Str (utf::instance ().unescape (doc));
            fields:.push (fi);
        }

        res:["fields"] = fields;
        res
    }

    /**
     * Dump the documentation of an enum that has not been validated yet
     * */
    fn dumpEnumUnvalidated (self, e : &EnumDecl, protection : Protection)-> &Config {
        let dmut res = copy Dict ();
        res:["kind"] = copy Str ("enum");
        self.dumpStandard (e.getLoc ().str, e.getComments (), e.getLoc (), protection, alias res);

        let dmut fields = copy Array ();
        for i, f in e.getValues () {
            let doc = e.getFieldComms ()[i];
            let dmut fi = copy Dict ();
            fi:["name"] = copy Str (f.getLoc ().str);
            fi:["value"] = copy Str (utf::instance ().unescape (format ("%", f.getValue ())));
            fi:["doc"] = copy Str (utf::instance ().unescape (doc));
            fields:.push (fi);
        }

        res:["fields"] = fields;
        res
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =====================================          GLOBAL          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Dump the documentation of a global variable declaration
     * */
    fn dumpGlobal (self, g : &GlobalSymbol)-> &Config {
        if let glb : &GlobalVarGenerator = g.getGenerator () {
            let dmut res = copy Dict ();
            res:["kind"] = copy Str ("global");
            self.dumpStandard (g, alias res);
            res:["thread_local"] = copy Bool (g.isThreadLocal ());
            res:["static"] = copy Bool (g.isStatic ());
            res:["extern"] = copy Bool (g.isExternal ());
            res:["type"] = self.dumpType (glb.getType ());
            res:["mutability"] = copy Str (if (glb.getType ().isDeeplyMutable () && glb.getType ().borrowDatas ()) { "dmut" } else if (glb.isMutable ()) { "mut" } else { "" });
            res:["value"] = copy Str (utf::instance ().unescape (format ("%", glb.getValue ())));
            res
        } else {
            self.dumpGlobalUnvalidated (g.getContent (), protection-> g.getProtection ())
        }
    }

    /**
     * Dump the declaration of a global unvalidated global variable
     * */
    fn dumpGlobalUnvalidated (self, g : &GlobalDecl, protection : Protection)-> &Config {
        let dmut res = copy Dict ();
        res:["kind"] = copy Str ("global");
        self.dumpStandard (g.getContent ().getLoc ().str, g.getComments (), g.getContent ().getLoc (), protection, alias res);

        let mut thLocal = false;
        for a in g.getAttributes () {
            if a.attr == Attributes::THREAD { thLocal = true; }
        }
        res:["thread_local"] = copy Bool (thLocal);
        res:["static"] = copy Bool (g.isStatic ());
        if (g.getContent ().getValue () !of EmptyExpression) {
            res:["value"] = copy Str (utf::instance ().unescape (format ("%", g.getContent ().getValue ())));
        }

        res
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ======================================          AKA          =======================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Dump the documentation of an aka symbol
     * */
    fn dumpAka (self, aka : &AkaSymbol)-> &Config {
        if let type : &Type = aka.getGenerator () {
            let dmut res = copy Dict ();
            res:["kind"] = copy Str ("def");
            self.dumpStandard (aka, alias res);
            res:["type"] = self.dumpType (type);
            res
        } else if let value : &Value = aka.getGenerator () {
            let dmut res = copy Dict ();
            res:["kind"] = copy Str ("def");
            self.dumpStandard (aka, alias res);
            res:["value"] = copy Str (utf::instance ().unescape (format ("%", value)));
            res
        } else {
            self.dumpAkaUnvalidated (aka.getContent (), protection-> aka.getProtection ())
        }
    }

    /**
     * Dump the documentation of an unvalidated aka symbol
     * */
    fn dumpAkaUnvalidated (self, aka : &AkaDecl, protection : Protection)-> &Config {
        let dmut res = copy Dict ();
        res:["kind"] = copy Str ("def");
        self.dumpStandard (aka.getLoc ().str, aka.getComments (), aka.getLoc (), protection, alias res);

        if (aka.isValue ()) {
            res:["value"] = copy Str (utf::instance ().unescape (format ("%", aka.getContent ())));
        } else {
            res:["type"] = copy Str (utf::instance ().unescape (format ("%", aka.getContent ())));
        }

        res
    }



    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          TEMPLATE          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Dump the documentation of a template symbol
     * */
    fn dumpTemplate (self, t : &TemplateSymbol)-> &Config {
        self.dumpTemplateUnvalidated (t.getContent (), protection-> t.getProtection ())
    }

    /**
     * Dump the documentation of a template declaration
     * */
    fn dumpTemplateUnvalidated (self, t : &TemplateDecl, protection : Protection)-> &Config {
        let dmut childs = copy Array ();
        self.dumpUnvalidated (t.getContent (), protection-> protection, alias childs);
        if (childs.len != 0) {
            let dmut tmp = copy Dict ();
            tmp:["kind"] = copy Str ("template");

            self.dumpTemplateParams (t, alias tmp);
            self.dumpStandard (t.getLoc ().str, t.getComments (), t.getLoc (), protection, alias tmp);
            tmp:["content"] = childs;
            if (t.getTest () !of EmptyExpression) {
                tmp:["test"] = copy Str (utf::instance ().unescape (format ("%", t.getTest ())));
            }

            return tmp;
        }

        copy None ()
    }

    /**
     * Dump the documentation of an unvalidated declaration
     * */
    fn dumpUnvalidated (self, d : &Declaration, protection : Protection, dmut result : &Array) {
        match d {
            b : &BlockDecl => {
                let inProt = if (b.isSet ()) { protection } else { b.getProtection () };
                for i in b.getDeclarations () {
                    self.dumpUnvalidated (i, protection-> inProt, alias result);
                }
            }
            t : &TemplateDecl => {
                result:.push (self.dumpTemplateUnvalidated (t, protection-> protection));
            }
            m : &ModuleDecl => {
                result:.push (self.dumpModuleUnvalidated (m, protection-> protection));
            }
            c : &ClassDecl => {
                result:.push (self.dumpClassUnvalidated (c, protection-> protection));
            }
            t : &TraitDecl => {
                result:.push (self.dumpTraitUnvalidated (t, protection-> protection));
            }
            e : &EnumDecl => {
                result:.push (self.dumpEnumUnvalidated (e, protection-> protection));
            }
            f : &FunctionDecl => {
                let dmut res = copy Dict ();
                self.dumpFunctionUnvalidated (f, alias res, forMethod-> false, noStandard-> false, protection-> protection);
                result:.push (res);
            }
            m : &MacroDecl => {
                result:.push (self.dumpMacroUnvalidated (m, protection-> protection));
            }
            g : &GlobalDecl => {
                result:.push (self.dumpGlobalUnvalidated (g, protection-> protection));
            }
            a : &AkaDecl => {
                result:.push (self.dumpAkaUnvalidated (a, protection-> protection));
            }
        }
    }

    /**
     * Dump the documentation of template parameters
     * */
    fn dumpTemplateParams (self, tmpl : &TemplateDecl, dmut res : &Dict) {
        let dmut elems = copy Array ();
        for p in tmpl.getParameters () match p {
            a : &TemplateAndExpr => {
                elems:.push (self.dumpTemplateAndParam (a));
            }
            o : &TemplateOfVarExpr => {
                elems:.push (self.dumpTemplateOfParam (o));
            }
            v : &TemplateVarExpr => {
                elems:.push (self.dumpTemplateVar (v));
            }
            v : &TemplateVariadicVarExpr => {
                elems:.push (self.dumpTemplateVariadicVar (v));
            }
            z => {
                let dmut v = copy Dict ();
                v:["kind"] = copy Str ("any");
                v:["content"] = copy Str (utf::instance ().unescape (format ("%", z)));
                elems:.push (v);
            }
        }

        res:["templates"] = elems;
    }

    /**
     * Dump the documentation of a template "and" param
     * */
    fn dumpTemplateAndParam (self, a : &TemplateAndExpr)-> &Config {
        let dmut res = copy Dict ();
        let dmut inner = copy Array ();
        res:["kind"] = copy Str ("and");
        for z in a.getSpecializations () {
            inner:.push (self.dumpTemplateOfParam (z));
        }

        res:["content"] = inner;
        res
    }

    /**
     * Dump the documentation of a template "of" param
     * */
    fn dumpTemplateOfParam (self, o : &TemplateOfVarExpr)-> &Config {
        let dmut res = copy Dict ();
        res:["kind"] = copy Str (o.getKind ());
        res:["name"] = copy Str (o.getLoc ().str);
        res:["content"] = copy Str (utf::instance ().unescape (format ("%", o.getSpecialization ())));
        res
    }

    /**
     * Dump the documentation of a template "var" param
     * */
    fn dumpTemplateVar (self, v : &TemplateVarExpr)-> &Config {
        let dmut res = copy Dict ();
        res:["kind"] = copy Str (v.getKind ());
        res:["name"] = copy Str (v.getLoc ().str);
        res
    }

    /**
     * Dump the documentation of a template variadic param
     * */
    fn dumpTemplateVariadicVar (self, v : &TemplateVariadicVarExpr)-> &Config {
        let dmut res = copy Dict ();
        res:["kind"] = copy Str ("variadic");
        res:["name"] = copy Str (v.getLoc ().str);
        res:["value"] = copy Bool (v.isValue ());
        res
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =====================================          MACROS          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Dump the documentation of a macro
     * */
    fn dumpMacro (self, m : &MacroSymbol)-> &Config {
        self.dumpMacroUnvalidated (m.getDeclaration (), m.getProtection ())
    }

    /**
     * Dump the documentation of a macro
     * */
    fn dumpMacroUnvalidated (self, m : &MacroDecl, protection : Protection)-> &Config {
        let dmut res = copy Dict ();
        res:["kind"] = copy Str ("macro");
        self.dumpStandard (m.getLoc ().str, m.getComments (), m.getLoc (), protection, alias res);

        let dmut rules = copy Array ();
        let dmut ctors = copy Array ();
        for d in m.getDeclarations () {
            self.dumpInnerMacro (d, alias rules, alias ctors, protection-> Protection::PUBLIC);
        }

        res:["ctors"] = ctors;
        res:["rules"] = rules;
        res
    }

    /**
     * Dump the documentation of rules and ctors that can be found in a macro
     * */
    fn dumpInnerMacro (self, d : &Declaration, dmut rules : &Array, dmut ctors : &Array, protection : Protection) {
        match d {
            bl : &BlockDecl => {
                for id in bl.getDeclarations () {
                    self.dumpInnerMacro (id, alias rules, alias ctors, protection-> bl.getProtection ());
                }
            }
            r : &MacroRuleDecl => {
                self.dumpMacroCtorRule (r, alias rules, alias ctors, protection-> protection);
            }
        }
    }

    /**
     * Dump the documentation of a macro ctor or macro rule
     * */
    fn dumpMacroCtorRule (self, rule : &MacroRuleDecl, dmut rules : &Array, dmut ctors : &Array, protection : Protection) {
        let dmut res = copy Dict ();
        res:["kind"] = copy Str (if (rule.isConstructor ()) { "ctor" } else { "rule" });
        self.dumpStandard (rule.getLoc ().str, rule.getComments (), rule.getLoc (), protection, alias res);

        res:["rule"] = copy Str (format ("%", rule.getRule ()));
        let dmut skips = copy Array ();
        for s in rule.getSkips () {
            skips:.push (copy Str (format ("%", s)));
        }

        res:["skips"] = skips;
        if (rule.isConstructor ()) {
            ctors:.push (res);
        } else {
            rules:.push (res);
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =====================================          TYPES          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Dump the documentation of a type
     * */
    fn dumpType (self, ty : &Type)-> &Config {
        let dmut res = copy Dict ();
        res:["mutability"] = copy Str (if (ty.isDeeplyMutable () && ty.borrowDatas ()) { "dmut" } else if ty.isMutable () { "mut" } else { "" });

        match ty {
            f : &FuncPtrType => {
                res:["kind"] = copy Str ("fptr");
                let dmut inners = copy Array ();
                let dmut refs = copy Array ();
                let dmut lazys = copy Array ();
                for i, p in f.getParameters () {
                    inners:.push (self.dumpType (p));
                    refs:.push (copy Bool (f.getReferences ()[i]));
                    lazys:.push (copy Bool (f.getLazys ()[i]));
                }
                res:["params"] = inners;
                res:["refs"] = refs;
                res:["lazys"] = lazys;
                res:["return"] = self.dumpType (f.getRetType ());
            }
            d : &DelegateType => {
                res:["kind"] = copy Str ("delegate");
                let dmut inners = copy Array ();
                let dmut refs = copy Array ();
                let dmut lazys = copy Array ();
                for i, p in d.getParameters () {
                    inners:.push (self.dumpType (p));
                    refs:.push (copy Bool (d.getReferences ()[i]));
                    lazys:.push (copy Bool (d.getLazys ()[i]));
                }
                res:["params"] = inners;
                res:["refs"] = refs;
                res:["lazys"] = lazys;
                res:["return"] = self.dumpType (d.getRetType ());
            }
            n : &ScalarType => {
                res:["kind"] = copy Str ("scalar");
                res:["name"] = copy Str (utf::instance ().unescape (format ("%", n.clone (0u32))));
            }
            c : &ArrayType => {
                res:["kind"] = copy Str ("array");
                res:["inner"] = self.dumpType (c.getInners ()[0]);
                res:["len"] = copy Int (cast!i64 (c.getLen ()));
            }
            f : &FutureType => {
                res:["kind"] = copy Str ("future");
                res:["inner"] = self.dumpType (f.getInners ()[0]);
            }
            o : &OptionType => {
                res:["kind"] = copy Str ("option");
                res:["inner"] = self.dumpType (o.getInners ()[0]);
            }
            p : &PointerType => {
                res:["kind"] = copy Str ("pointer");
                res:["inner"] = self.dumpType (p.getInners ()[0]);
            }
            r : &RangeType => {
                res:["kind"] = copy Str ("range");
                res:["inner"] = self.dumpType (r.getInners ()[0]);
            }
            s : &SliceType => {
                res:["kind"] = copy Str ("slice");
                res:["inner"] = self.dumpType (s.getInners ()[0]);
            }
            m : &MapType => {
                res:["kind"] = copy Str ("map");
                res:["key"] = self.dumpType (m.getInners ()[0]);
                res:["value"] = self.dumpType (m.getInners ()[1]);
            }
            t : &TupleType => {
                res:["kind"] = copy Str ("tuple");
                let dmut inners = copy Array ();
                for i in t.getInners () {
                    inners:.push (self.dumpType (i));
                }
                res:["inners"] = inners;
            }
            c : &ClassPtrType => {
                res:["kind"] = copy Str (if (c.isMovable ()) { "entity" } else if (c.isStruct ()) { "struct" } else { "class" });
                res:["name"] = copy Str (c.getSymbol ().getPath ().toStr ());
            }
            e : &EnumType => {
                res:["kind"] = copy Str ("enum");
                res:["proxy"] = self.dumpType (e.getProxy ());
                res:["name"] = copy Str (e.getSymbol ().getPath ().toStr ());
            }
            t => {
                res:["name"] = copy Str (utf::instance ().unescape (format ("%", t)));
                res:["kind"] = copy Str ("any");
            }
        }

        res
    }

    /**
     * Dump an unvalidated type
     * */
    fn dumpTypeUnvalidated (self, type : &Expression)-> &Config {
        let dmut res = copy Dict ();
        res:["kind"] = copy Str ("any");
        match type {
            d : &DecoratedExpr => {
                let (isMutable_, isDeeplyMutable_) = (d.getDecorator () == Decorators::MUT, d.getDecorator () == Decorators::DMUT);
                res:["mutability"] = copy Str (if isDeeplyMutable_ { "dmut" } else if isMutable_ { "mut" } else { "" });
                res:["name"] = copy Str (utf::instance ().unescape (format ("%", d.getContent ())));
            }
            _ => {
                res:["mutability"] = copy Str ("");
                res:["name"] = copy Str (utf::instance ().unescape (format ("%", type)));
            }
        }

        res
    }

}
