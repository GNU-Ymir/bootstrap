in visitor;

use std::{config::_, fs::path};
use ymirc::lexing::word;
use ymirc::utils::format;

use ymirc::syntax::{_,
                    declaration::_,
                    expression::{_, literal::_, macro_::_, operator::_, template::_}};

use ymirc::semantic::{generator::_, symbol::{_, macro_::_}};
use ymirc::semantic::validator::utf;
use ymirc::semantic::generator::type::{_,
                                       syntax::_,
                                       custom::_,
                                       native::{_, scalar::_, compound::_},
                                       temporary::_};

use ymirc::semantic::generator::value::{_,
                                        syntax::_,
                                        construct::{_, delegate::_},
                                        literal::_,
                                        memory::_,
                                        operator::{_, binary::_, call::_, fields::_, map::_, slice::_, unary::_},
                                        operator::map::iteration::_,
                                        prototypes::_,
                                        scope::_,
                                        syntax::_,
                                        template::_};


/**
 * Class used to produce the documentation of a module and all its content
 * */
pub record DocVisitor {

    let _packageDir : Path;

    pub self (packageDir : Path)
        with _packageDir = packageDir
    {}

    /**
     * Dump the documentation of a symbol and its childrens
     * @params:
     *    - sym: the symbol whose documentation to dump
     * @returns: the documentation of the symbol
     * */
    pub fn dump (self, sym : &Symbol)-> &Config {
        match sym {
            m : &ModuleSymbol => {
                return self.dumpModule (m);
            }
            f : &FunctionSymbol => {
                return self.dumpFunction (f);
            }
            c : &ClassSymbol => {
                return self.dumpClass (c);
            }
            // t : &TraitSymbol => {
            //     return self.dumpTrait (t);
            // }
            // e : &EnumSymbol => {
            //     return self.dumpEnum (e);
            // }
            // g : &GlobalSymbol => {
            //     return self.dumpGlobal (g);
            // }
            // a : &AkaSymbol => {
            //     return self.dumpAka (a);
            // }
            // m : &MacroSymbol => {
            //     return self.dumpMacro (m);
            // }
            // t : &TemplateSymbol => {
            //     return self.dumpTemplate (t);
            // }
        }

        return copy None ();
    }

    /**
     * Dump the standard documentation information of a symbol (i.e. name, location, protection and comments)
     * @params:
     *    - sym: the symbol
     * */
    fn dumpStandard (self, sym : &Symbol, dmut res : &Dict) {
        res:["name"] = copy Str (sym.getPath ().toStr ());
        res:["loc_file"] = copy Str (Path (sym.getLoc ().filename).removePrefix (self._packageDir).toStr ());
        res:["loc_line"] = copy Int (cast!i64 (sym.getLoc ().line));
        res:["loc_col"] = copy Int (cast!i64 (sym.getLoc ().col));
        res:["doc"] = copy Str (utf::instance ().unescape (sym.getComments ()));

        match sym.getProtection () {
            Protection::PUBLIC => { res:["protect"] = copy Str ("pub"); }
            Protection::PROTECTED => { res:["protect"] = copy Str ("prot"); }
            _ => { res:["protect"] = copy Str ("prv"); }
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =====================================          MODULE          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Dump the documentation of a module
     * */
    fn dumpModule (self, m : &ModuleSymbol)-> &Config {
        if (m.isExtern ()) return copy None ();

        let dmut res = copy Dict ();
        res:["type"] = copy Str ("module");
        self.dumpStandard (m, alias res);

        let dmut childs = copy Array ();
        let inners = m.getAllLocalSymbols (protection-> Protection::PRIVATE);
        for i in inners match self.dump (i) {
            None () => {}
            c : _ => {
                childs:.push (c);
            }
        }

        res:["childs"] = childs;
        return res;
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          FUNCTIONS          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Dump the documentation of a function symbol
     * */
    fn dumpFunction (self, f : &FunctionSymbol)-> &Config {
        if let p : &CtorPrototypeValue = f.getFrameProto () {
            return self.dumpCtor (p);
        }

        if let _ : &DtorPrototypeValue = f.getFrameProto () {
            return copy None ();
        }

        if let p : &MethodPrototypeValue = f.getFrameProto () {
            return self.dumpMethod (p);
        }

        if let p : &PrototypeValue = f.getFrameProto () {
            return self.dumpFunction (p);
        }

        copy None () // self.dumpUnvalidatedFunction (f);
    }

    /**
     * Dump the documentation of a classical function
     * */
    fn dumpFunction (self, proto : &PrototypeValue)-> &Config {
        let dmut res = copy Dict ();
        res:["type"] = copy Str ("function");
        self.dumpStandard (proto.getSymbol (), alias res);
        self.dumpParams (proto.getParameters (), alias res);
        self.dumpThrowers (proto.getThrowers (), alias res);

        let dmut attrs = copy Array ();
        if (proto.isUnsafe ()) attrs:.push (copy Str ("unsafe"));
        if (proto.isInline ()) attrs:.push (copy Str ("inline"));
        res:["attributes"] = attrs;
        res:["ret_type"] = self.dumpType (proto.getRetType ());

        res
    }

    /**
     * Dump the documentation of a ctor
     * */
    fn dumpCtor (self, ctor : &CtorPrototypeValue)-> &Config {
        let dmut res = copy Dict ();
        res:["type"] = copy Str ("ctor");
        self.dumpStandard (ctor.getSymbol (), alias res);
        self.dumpParams (ctor.getParameters (), alias res);
        self.dumpThrowers (ctor.getThrowers (), alias res);

        res
    }

    /**
     * Dump the documentation of a method
     * */
    fn dumpMethod (self, meth : &MethodPrototypeValue)-> &Config {
        let dmut res = copy Dict ();
        res:["type"] = copy Str ("method");

        self.dumpStandard (meth.getSymbol (), alias res);
        self.dumpParams (meth.getParameters (), alias res);
        let dmut attrs = copy Array ();
        if (meth.isFinal ()) attrs:.push (copy Str ("final"));
        if (meth.isVirtual ()) attrs:.push (copy Str ("virtual"));
        if (meth.isEmpty ()) attrs:.push (copy Str ("abstract"));
        if (meth.isField ()) attrs:.push (copy Str ("field"));
        res:["attributes"] = attrs;

        if (meth.isMutable ()) {
            res:["mutable"] = copy Bool (true);
        } else { res:["mutable"] = copy Bool (false); }

        self.dumpThrowers (meth.getThrowers (), alias res);
        res:["ret_type"] = self.dumpType (meth.getRetType ());

        res
    }

    /**
     * Dump the throwers of a function
     * */
    fn dumpThrowers (self, throwers : [(&Word, &Type)], dmut res : &Dict) {
        let dmut thrs = copy Array ();
        for t in throwers {
            thrs:.push (self.dumpType (t._1));
        }

        res:["throwers"] = thrs;
    }

    /**
     * Dump the parameters of a function
     * */
    fn dumpParams (self, funcParams : [&ProtoVarValue], dmut res : &Dict) {
        let dmut parameters = copy Array ();
        for v in funcParams {
            let dmut param = copy Dict ();
            param:["name"] = copy Str (v.getName ());
            param:["type"] = self.dumpType (v.getType ());
            param:["mutability"] = copy Str (if (v.getType ().isDeeplyMutable () && v.getType ().borrowDatas ()) { "dmut" } else if (v.isMutable ()) { "mut" } else { "" });
            param:["ref"] = copy Bool (v.isReference ());
            param:["lazy"] = copy Bool (v.isLazy ());

            if (v.getDefaultValue () !of UnitValue) {
                param:["value"] = copy Str (format ("%", v.getDefaultValue ()));
            }

            parameters:.push (param);
        }

        res:["params"] = parameters;
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =====================================          CLASS          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Dump the documentation class
     * */
    fn dumpClass (self, c : &ClassSymbol)-> &Config {
        if let r : &ClassRefType = c.getClassRef () {
            return self.dumpClass (c, r);
        }

        copy None ()
    }

    /**
     * Dump the documentation of a class reference
     * */
    fn dumpClass (self, c : &ClassSymbol, cref : &ClassRefType)-> &Config {
        let dmut res = copy Dict ();

        self.dumpStandard (c, alias res);

        if (cref.isStruct () && !cref.isMovable ()) { res:["type"] = copy Str ("record"); }
        else if (cref.isStruct ()) { res:["type"] = copy Str ("entity"); }
        else {
            res:["type"] = copy Str ("class");

            if (cref.getAncestor () !of NoneType) {
                res:["ancestor"] = self.dumpType (cref.getAncestor ());
            }

            res:["has_dtor"] = copy Bool (cref.getDestructor () !of UnitValue);
            res:["abstract"] = copy Bool (cref.getSymbol ().isAbstract ());
            res:["final"] = copy Bool (cref.getSymbol ().isFinal ());
        }

        self.dumpClassFields (cref, alias res);
        self.dumpAssertions (cref, alias res);
        self.dumpCtors (cref, alias res);
        self.dumpMethods (cref, alias res);
        self.dumpImpl (cref, alias res);

        res
    }

    /**
     * Dump the documentation of the fields of a class
     * */
    fn dumpClassFields (self, cref : &ClassRefType, dmut res : &Dict) {
        let dmut fields = copy Array ();
        for i, v in cref.getLocalFields () {
            let dmut fi = copy Dict ();
            fi:["name"] = copy Str (v.getLoc ().str);
            fi:["mutability"] = copy Str (if (v.getVarType ().isDeeplyMutable () && v.getVarType ().borrowDatas ()) { "dmut" } else if (v.isMutable ()) { "mut" } else { "" });
            fi:["ref"] = copy Bool (v.isReference ());
            fi:["lazy"] = copy Bool (v.isLazy ());
            fi:["doc"] = copy Str (utf::instance ().unescape (cref.getSymbol ().getFieldComments ()[i]));
            fi:["protect"] = copy Str (if (cref.getSymbol ().isFieldPrivate (v.getLoc ().str)) { "prv" } else if (cref.getSymbol ().isFieldProtected (v.getLoc ().str)) { "prot" } else { "pub"});
            fi:["type"] = self.dumpType (v.getVarType ());
            fields:.push (fi);
        }

        res:["fields"] = fields;
    }

    /**
     * Dump the assertions of the class
     * */
    fn dumpAssertions (self, cref : &ClassRefType, dmut res : &Dict) {
        let dmut assertions = copy Array ();
        for i, a in cref.getSymbol ().getAssertions () if let exp : &AssertExpr = a {
            let dmut as = copy Dict ();
            as:["test"] = copy Str (format ("%", exp.getTest ()));
            as:["msg"] = copy Str (format ("%", exp.getMessage ()));
            as:["doc"] = copy Str (utf::instance ().unescape (cref.getSymbol ().getAssertionComments ()[i]));
            assertions:.push (as);
        }

        res:["asserts"] = assertions;
    }

    /**
     * Dump the constructor of a class
     * */
    fn dumpCtors (self, cref : &ClassRefType, dmut res : &Dict) {
        let dmut ctors = copy Array ();
        for c in cref.getCtors () if let ct : &CtorPrototypeValue = c {
            ctors:.push (self.dumpCtor (ct));
        }

        res:["ctors"] = ctors;
    }

    /**
     * Dump the methods of a class
     * */
    fn dumpMethods (self, cref : &ClassRefType, dmut res : &Dict) {
        let dmut meths = copy Array ();
        for m in cref.getVtable () if m.getClassRef () == cref {
            meths:.push (self.dumpMethod (m));
        }

        res:["methods"] = meths;
    }

    /**
     * Dump the list of trait implemented by the class
     * */
    fn dumpImpl (self, cref : &ClassRefType, dmut res : &Dict) {
        let dmut tr = copy Array ();
        for t in cref.getImplTraits () {
            tr:.push (copy Str (t.getSymbol ().getPath ().toStr ()));
        }

        res:["implements"] = tr;
    }



    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =====================================          TYPES          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Dump the documentation of a type
     * */
    fn dumpType (self, ty : &Type)-> &Config {
        let dmut res = copy Dict ();
        res:["mutability"] = copy Str (if (ty.isDeeplyMutable () && ty.borrowDatas ()) { "dmut" } else if ty.isMutable () { "mut" } else { "" });

        match ty {
            n : &ScalarType => {
                res:["type"] = copy Str ("scalar");
                res:["name"] = copy Str (format ("%", n.clone (0u32)));
            }
            c : &ArrayType => {
                res:["type"] = copy Str ("array");
                res:["inner"] = self.dumpType (c.getInners ()[0]);
            }
            f : &FutureType => {
                res:["type"] = copy Str ("future");
                res:["inner"] = self.dumpType (f.getInners ()[0]);
            }
            o : &OptionType => {
                res:["type"] = copy Str ("option");
                res:["inner"] = self.dumpType (o.getInners ()[0]);
            }
            p : &PointerType => {
                res:["type"] = copy Str ("pointer");
                res:["inner"] = self.dumpType (p.getInners ()[0]);
            }
            r : &RangeType => {
                res:["type"] = copy Str ("range");
                res:["inner"] = self.dumpType (r.getInners ()[0]);
            }
            s : &SliceType => {
                res:["type"] = copy Str ("slice");
                res:["inner"] = self.dumpType (s.getInners ()[0]);
            }
            m : &MapType => {
                res:["type"] = copy Str ("map");
                res:["key"] = self.dumpType (m.getInners ()[0]);
                res:["value"] = self.dumpType (m.getInners ()[1]);
            }
            t : &TupleType => {
                res:["type"] = copy Str ("slice");
                let dmut inners = copy Array ();
                for i in t.getInners () {
                    inners:.push (self.dumpType (i));
                }
                res:["inners"] = inners;
            }
            c : &ClassPtrType => {
                res:["type"] = copy Str (if (c.isMovable ()) { "entity" } else if (c.isStruct ()) { "struct" } else { "class" });
                res:["name"] = copy Str (c.getSymbol ().getPath ().toStr ());
            }
            e : &EnumType => {
                res:["type"] = copy Str ("enum");
                res:["proxy"] = self.dumpType (e.getProxy ());
                res:["name"] = copy Str (e.getSymbol ().getPath ().toStr ());
            }
        }

        res
    }

}
