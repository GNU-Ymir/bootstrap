in symbol;

pub mod ::macro_;
pub mod ::aka_;
pub mod ::class_;
pub mod ::constructor;
pub mod ::destructor;
pub mod ::empty;
pub mod ::enum_;
pub mod ::error;
pub mod ::format;
pub mod ::function;
pub mod ::global;
pub mod ::impl_;
pub mod ::lazy_module;
pub mod ::module;
pub mod ::path;
pub mod ::sym_list;
pub mod ::table;
pub mod ::template;
pub mod ::trait_;
pub mod ::unittest;


use ymirc::lexing::{word, tokens};
use ymirc::syntax::declaration::{use_, protection};
use ymirc::semantic::symbol::{table, path, sym_list, unittest, empty, format};
use ymirc::semantic::validator::template::mapper;

use ymirc::utils::format;
use std::{fs::path, stream};

use ymirc::semantic::generator;
use ymirc::utils::string;

/**
 * Ancestor of all kind of symbols
 * A symbol is used to contain a symbol table, that is used to manage access and references to symbols
 *
 */
@abstract
pub class Symbol {

    // The location of the symbol
    let _loc : &Word;

    // The comments about the symbol
    let _comments : [c8];

    // The parent of the symbol
    let dmut _referent : (&Symbol)?;

    // This protection of the symbol
    let _protection : Protection;

    // True if this is a weak symbol (can be replaced by another strong/weak symbol, in symbol linking)
    let mut _isWeak : bool;

    // The external language of the symbol
    let mut _externLanguage = ""s8;

    // The path of the external symbol (for C++ and Dlang)
    let mut _externPath = Path (""s8);

    // The full name of the symbol (depends on self._referent)
    let mut _fullName : &SymbolPath;

    // The list of used packets (set during validation)
    let mut _used : [dmut &Symbol] = [];

    // The list of core module used by this symbol
    let mut _coreModules : [dmut &Symbol] = [];

    // The list of unittest declared in the symbol
    let mut _unittest : [mut &UnitTestSymbol] = [];

    // The list of use declaration (set during declaration)
    let mut _useDecls : [mut &UseDecl] = [];

    // The content table of the symbol
    let dmut _table = copy Table ();

    // The template mapper used for the symbol if it was generate by a template specialization
    let mut _templateMapper : (TemplateMapper)? = none;

    // The list of generators associated with the symbol
    let mut _generators : [mut &Generator] = [];

    // True if the symbol is a core module
    let mut _isCoreModule : bool = false;

    /**
     * @params:
     *   - loc: the location of the symbol
     *   - comm: the comments about the symbol
     *   - isWeak: true iif this is a weak symbol
     */
    pub self (loc : &Word, comm : [c8], isWeak : bool = false, protection : Protection = Protection::PRIVATE)
        with _loc = loc
        , _comments = comm
        , _referent = none
        , _fullName = copy SymbolPath (loc.str ())
        , _protection = protection
        , _isWeak = isWeak
    {}

    /*!
     * ================================================================================
     * ================================================================================
     * =========================           GETTERS            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * @returns: the location of the symbol
     */
    pub fn getLoc (self)-> &Word {
        self._loc
    }

    /**
     * @returns: the comments about the symbol
     */
    pub fn getComments (self)-> [c8] {
        self._comments
    }

    /**
     * @returns: the parent of the symbol
     */
    pub fn getReferent (self)-> &Symbol {
        match self._referent {
            Ok (x : _) => { return x; }
            _ => { return EMPTY_SYMBOL; }
        }
    }

    /**
     * @returns: the parent of the symbol
     */
    pub fn getReferent (mut self)-> dmut &Symbol {
        match ref self._referent {
            Ok (dmut x : _) => { return alias x; }
            _ => { return EMPTY_SYMBOL; }
        }
    }

    /**
     * @returns: the protection of the symbol
     */
    pub fn getProtection (self)-> Protection {
        self._protection
    }

    /**
     * @returns: true iif the symbol is weak
     */
    pub fn isWeak (self)-> bool {
        self._isWeak
    }

    /**
     * @returns: the path of the symbol (depends on referent)
     */
    pub fn getPath (self)-> &SymbolPath {
        self._fullName
    }

    /**
     * @returns: the template mapper used to generate the symbol (if it was generated by a template specialization)
     * */
    pub fn getTemplateMapper (self)-> (TemplateMapper)? {
        self._templateMapper
    }

    /**
     * @returns: true if the symbol was generated by a template specialization
     * */
    pub fn isTemplate (self)-> bool {
        match self._templateMapper {
            Ok () => { true }
            _ => { false }
        }
    }

    /**
     * @returns: the external language of the function
     */
    pub fn getExternalLanguage (self)-> [c8] {
        self._externLanguage
    }

    /**
     * @returns: the path of the symbol in the external language (applicable iif self.getExternalLanguage () == C++ or Dlang)
     */
    pub fn getExternalLanguagePath (self)-> Path {
        self._externPath
    }

    /**
     * @returns: true if the symbol is module declared within ymir core package
     * */
    pub fn isCoreModule (self)-> bool {
        self._isCoreModule
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================         TABLE INSERT         =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Allows the use of an externally declared symbol for searching (in get (string) function)
     * This function is called during validation (after all symbols are declared)
     * @params:
     *   - name: the name of the symbol (not the path, but the name in the current module (e.g. 'as'))
     *   - sym: the symbol to use
     *   - protection: the protection of the use
     */
    @final
    pub fn useModule (mut self, _ : Path, dmut sym : &Symbol) {
        self._used ~= [alias sym];
    }

    /**
     * Set the list of core modules used by this symbol (same as use but only for the core module list)
     * */
    @final
    pub fn setUsedCore (mut self, dmut cores : [&Symbol]) {
        self._coreModules = alias cores;
    }

    /**
     * Insert an unittest
     * */
    @final
    pub fn insertUnitTest (mut self, dmut sym : &UnitTestSymbol) {
        self._unittest ~= [alias sym];
    }

    /**
     * Insert a child symbol in the table
     * @params:
     *   - sym: the symbol to insert
     *   - replace: if true, remove old symbol with the same name first
     */
    @final
    pub fn insert (mut self, dmut sym : &Symbol, replace : bool = false) {
        match sym._templateMapper {
            Ok () => {
                self:.insertTemplate (alias sym);
            }
            _ => {
                sym:.setReferent (alias self);
                self._table:.insert (sym.getLoc ().str (), alias sym, replace-> replace);
            }
        }
    }

    /**
     * Remove a symbol from the symbol table
     * @params:
     *    - sym: the symbol to remove
     * @info: do nothing if the symbol is not found
     */
    @final
    pub fn remove (mut self, dmut sym : &Symbol) {
        self._table:.remove (sym.getLoc ().str (), alias sym);
    }

    /**
     * Insert a reference symbol in the table
     * @info: does not change the referent of sym
     * @params:
     *   - name: the alias name
     *   - sym: the symbol to insert
     *   - replace: if true, remove old symbol with the same name first
     */
    @final
    pub fn insertAs (mut self, name : [c8], dmut sym : &Symbol, replace : bool = false) {
        self._table:.insert (name, alias sym, replace-> replace);
    }

    /**
     * Insert a template resolution symbol in the table
     * @info: not the same table, as it must be accessed differently
     * @params:
     *   - sym: the symbol to insert
     */
    @final
    pub fn insertTemplate (mut self, dmut sym : &Symbol) {
        sym:.setReferent (alias self);
        self._table:.insertTemplate (alias sym);
    }

    /**
     * Insert a use declaration (by the declaration visitor)
     * */
    @final
    pub fn insertUse (mut self, sym : &UseDecl) {
        self._useDecls ~= [sym];
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================        TABLE RETREIVE        =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Find the templates symbols in the table
     * @returns: all the inserted template symbols
     */
    @final
    pub fn getTemplates (self)-> [&Symbol] {
        self._table.getTemplates ()
    }

    /**
     * @returns: the list of unittest in the symbol
     * */
    @final
    pub fn getUnitTests (mut self)-> dmut [&UnitTestSymbol] {
        return alias self._unittest;
    }

    /**
     * Find all the symbols whose name are name
     * @info: ask parents
     * @params:
     *  - name: the name of the symbol to find
     *  - protection: the protection access (e.g. public-> access only public symbols, private-> access all, etc.)
     * @returns: a list of symbols
     */
    pub fn getSymbols (self, name : [c8], protection : Protection = Protection::PUBLIC, fromUsed : bool = false, dmut res : &ImutSymbolList = copy ImutSymbolList ())-> dmut &ImutSymbolList {
        match self._referent {
            Ok (x : &Symbol) => {
                // We don't use the use statement of parent module, if it is another file than self
                x.getSymbols (name, protection-> protection, fromUsed-> (fromUsed || !x.inSameFile (self)), res-> alias res);
            }

        }

        if (fromUsed)
            self.getSymbolsInTable (name, protection-> protection, syms-> alias res);
        else {
            self.getSymbolsInTable (name, protection-> Protection::PRIVATE, syms-> alias res);
            for module in self._used {
                module.getSymbols (name, protection-> protection, fromUsed-> true, res-> alias res);
            }
            for module in self._coreModules {
                module.getSymbols (name, protection-> protection, fromUsed-> true, res-> alias res);
            }
        }

        alias res
    }

    /**
     * Find all the symbols whose name are name
     * @info: ask parents
     * @params:
     *  - name: the name of the symbol to find
     *  - protection: the protection access (e.g. public-> access only public symbols, private-> access all, etc.)
     * @returns: a list of symbols
     */
    pub fn getSymbols (mut self, name : [c8], protection : Protection = Protection::PUBLIC, fromUsed : bool = false, dmut res : &SymbolList = copy SymbolList ())-> dmut &SymbolList {
        match ref self._referent {
            Ok (dmut x : &Symbol) => {
                // We don't use the use statement of parent module, if it is another file than self
                x:.getSymbols (name, protection-> protection, fromUsed-> (fromUsed || !x.inSameFile (self)), res-> alias res);
            }
        }

        if (fromUsed)
            self:.getSymbolsInTable (name, protection-> protection, syms-> alias res);
        else {
            self:.getSymbolsInTable (name, protection-> Protection::PRIVATE, syms-> alias res);
            for i in 0us .. self._used.len () {
                let dmut module = (alias self._used)[i];
                module:.getSymbols (name, protection-> protection, fromUsed-> true, res-> alias res);
            }

            for i in 0us .. self._coreModules.len  {
                let dmut module = alias (self._coreModules [i]);
                module:.getSymbols (name, protection-> protection, fromUsed-> true, res-> alias res);
            }
        }

        alias res
    }

    /**
     * Find all the symbols whose name are almost `name`
     * @info: ask parents
     * @params:
     *  - name: the name of the symbol to find
     *  - distance: the distance between the name and `name`
     *  - protection: the protection access (e.g. public-> access only public symbols, private-> access all, etc.)
     * @returns: a list of symbols
     */
    pub fn getCloseSymbols (self, name : [c8], distance : usize, protection : Protection = Protection::PUBLIC, fromUsed : bool = false, dmut res : &ImutSymbolList = copy ImutSymbolList ())-> dmut &ImutSymbolList {
        match self._referent {
            Ok (x : &Symbol) => {
                // We don't use the use statement of parent module, if it is another file than self
                x.getCloseSymbols (name, distance, protection-> protection, fromUsed-> (fromUsed || !x.inSameFile (self)), res-> alias res);
            }
        }

        if (fromUsed)
            self.getCloseSymbolsInTable (name, distance, protection-> protection, syms-> alias res);
        else {
            self.getCloseSymbolsInTable (name, distance, protection-> Protection::PRIVATE, syms-> alias res);
            for module in self._used {
                module.getCloseSymbols (name, distance, protection-> protection, fromUsed-> true, res-> alias res);
            }

            for module in self._coreModules {
                module.getCloseSymbols (name, distance, protection-> protection, fromUsed-> true, res-> alias res);
            }
        }

        alias res
    }

    /**
     * Find all the symbols whose name are name
     * @info: don't ask parents or imports
     * @params:
     *  - name: the name of the symbol to find
     *  - protection: the protection access (e.g. public-> access only public symbols, private-> access all, etc.)
     * @returns: a list of symbols
     */
    pub fn getLocalSymbols (self, name : [c8], protection : Protection = Protection::PUBLIC)-> dmut &ImutSymbolList {
        let dmut res = copy ImutSymbolList ();
        self.getSymbolsInTable (name, protection, alias res, callParent-> false);
        alias res
    }

    /**
     * Find all the symbols whose name are close to name
     * @info: don't ask parents or imports
     * @params:
     *  - name: the name of the symbol to find
     *  - distance: the distance between the name and `name`
     *  - protection: the protection access (e.g. public-> access only public symbols, private-> access all, etc.)
     * @returns: a list of symbols
     * */
    pub fn getCloseLocalSymbols (self, name : [c8], distance : usize, protection : Protection = Protection::PUBLIC)-> dmut &ImutSymbolList {
        let dmut res = copy ImutSymbolList ();
        self.getCloseSymbolsInTable (name, distance, protection-> protection, syms-> alias res, callParent-> false);
        alias res
    }

    /**
     * Find all the symbols whose name are name
     * @info: don't ask parents
     * @params:
     *  - name: the name of the symbol to find
     *  - protection: the protection access (e.g. public-> access only public symbols, private-> access all, etc.)
     * @returns: a list of symbols
     */
    pub fn getLocalSymbols (mut self, name : [c8], protection : Protection = Protection::PUBLIC)-> dmut &SymbolList {
        let dmut res = copy SymbolList ();
        self:.getSymbolsInTable (name, protection, alias res, callParent-> false);
        alias res
    }

    /**
     * Get all local symbols
     * @info: don't ask parents
     * @params:
     *  - protection: the protection access (e.g. public-> access only public symbols, private-> access all)
     * @returns: a list of symbols
     */
    pub fn getAllLocalSymbols (self, protection : Protection = Protection::PUBLIC)-> [&Symbol] {
        if (protection == Protection::PRIVATE) {
            let local = self._table.getContent ();
            let mut res : [mut &Symbol] = [];
            for i, _ in local if let Ok (v) = local [i]? {
                res ~= v;
            }

            return res;
        } else {
            let local = self._table.getPublicContent ();
            let mut res : [mut &Symbol] = [];
            for i, _ in local if let Ok (v) = local [i]? {
                res ~= v;
            }

            return res;
        }
    }


    /**
     * Get all local symbols
     * @info: don't ask parents
     * @params:
     *  - protection: the protection access (e.g. public-> access only public symbols, private-> access all)
     * @returns: a list of symbols
     */
    pub fn getAllLocalSymbols (mut self, protection : Protection = Protection::PUBLIC)-> dmut [&Symbol] {
        if (protection == Protection::PRIVATE) {
            let dmut local = self._table:.getContent ();
            let dmut res : [&Symbol] = [];
            for i, _ in local if let Ok (dmut v) = alias (alias local [i])? {
                res ~= alias v;
            }

            return alias res;
        } else {
            let dmut local = self._table:.getPublicContent ();
            let dmut res : [&Symbol] = [];
            for i, _ in local if let Ok (dmut v) = alias (alias local [i])? {
                res ~= alias v;
            }

            return alias res;
        }
    }

    /**
     * Search in the symbol table the mutable symbol whose address is the same as sym
     * @info: this function is used to get mutable access to an immutable symbol
     * @returns: the mutable version of the symbol, or error if it is not found
     */
    pub fn getMutableSymbol (mut self, sym : &Symbol)-> dmut (&Symbol)? {
        let dmut localTemp = self._table:.getTemplates ();
        for i in 0us .. localTemp.len {
            if (localTemp [i] is sym) { return (alias localTemp[i])?; }

            if let Ok (dmut r) = localTemp [i]:.getMutableSymbol (sym) {
                return alias r;
            }
        }

        let dmut local = self._table:.getContent ();
        for i, _ in local if let Ok (dmut v) = alias (alias local [i])? {
            for s in 0us .. v.len () {
                if (v [s] is sym) {
                    return (alias v [s])?;
                }

                if let Ok (dmut r) = v [s]:.getMutableSymbol (sym) {
                    return alias r;
                }
            }
        }

        none
    }


    /**
     * @returns: the list of used symbols
     */
    pub fn getUsed (mut self)-> dmut [&Symbol] {
        alias self._used
    }

    /**
     * @returns: the use declaration found in the module
     * */
    pub fn getAllUseDecls (self)-> [&UseDecl] {
        self._useDecls
    }

    /**!
     * ================================================================================
     * ================================================================================
     * =========================          COMPARISON          =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Compare two symbols, to check if they contains the same thing (not only address or type)
     */
    pub fn opEquals (self, o : &Symbol) -> bool {
        self is o
    }

    /**
     * @returns: true if both symbol were declared in the same file
     * @info: if the location of self, or o is iseof return true
     * */
    pub fn inSameFile (self, o : &Symbol)-> bool {
        if (self._loc.filename () == o._loc.filename ()) return true;
        if (self._loc.filename () == "") return true;
        if (o._loc.filename () == "") return true;

        false
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================           SETTERS            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Change the referent of the symbol
     */
    pub fn setReferent (mut self, dmut parent : &Symbol) {
        self._referent = (alias parent)?;
        self._fullName = self.computeFullName ();
    }

    /**
     * Set the external language and path of the symbol
     * @params:
     *    - lang: the language that declares the external symbol
     *    - path: the path of the symbol in the external language (applicable for C++ and Dlang)
     */
    pub fn setExternalLanguage (mut self, lang : [c8], path : Path) {
        self._externLanguage = lang;
        self._externPath = path;
    }

    /**
     * Set the template name of the symbol that was declared from template declarations
     * @info: also set isWeak to true
     * @params:
     *    - template: the list of template (in text)
     */
    pub fn setFromTemplate (mut self, mapper : TemplateMapper) {
        self._isWeak = true;

        self._templateMapper = mapper?;
        self._fullName = self.computeFullName ();

        let dmut local = self._table:.getContent (); // need to change the name of the inner symbols, and set them to weak
        for i, _ in local if let Ok (dmut v) = alias (alias local [i])? {
            for s in 0us .. v.len () {
                v [s]:.setParentIsTemplate ();
            }
        }

        if let Ok (dmut sym) = alias self._referent {
            sym:.remove (alias self); // template symbols are not accessible from the symbol table
            sym:.insertTemplate (alias self); // Don't forget to insert a template so the symbol can be still found but differently
        }
    }

    /**
     * Set the symbol as a weak symbol, as one of the ancestor of this symbol is a template symbol
     */
    prv fn setParentIsTemplate (mut self) {
        self._isWeak = true;
        self._fullName = self.computeFullName ();

        let dmut local = self._table:.getContent ();
        for i, _ in local if let Ok (dmut v) = alias (alias local [i])? {
            for s in 0us .. v.len () {
                v [s]:.setParentIsTemplate ();
            }
        }
    }

    /**
     * @params:
     *    - isCore: true iif the symbol is a module declared in the ymir core package
     * */
    pub fn isCoreModule (mut self, isCore : bool) {
        self._isCoreModule = isCore;
    }

    /*!
     * ================================================================================
     * ================================================================================
     * ===========================        GENERATION         ==========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Insert a generator associated to the symbol
     * @params:
     *    - gen: the generator to insert
     * */
    pub fn insertGenerator (mut self, gen : &Generator) {
        self._generators ~= [gen];
    }

    /**
     * Get all the generators associated to the symbol, and to its childrens
     * */
    pub fn getGenerators (self)-> [&Generator] {
        let mut res : [mut &Generator] = [];
        self.getGenerators (ref res);

        res
    }

    /**
     * Get all the generators associated to the symbol, and to its childrens
     * @params:
     *    - res: the vector to fill
     * */
    prv fn getGenerators (self, ref mut res : [mut &Generator]) {
        for i in self._generators {
            res ~= [i];
        }

        for _, v in self._table.getContent () {
            for s in v {
                s.getGenerators (ref res);
            }
        }

        for _, v in self._table.getTemplates () {
            v.getGenerators (ref res);
        }
    }

    /**
     * @returns: the list of generators associated to the symbols, but not to the childrens
     * */
    pub fn getLocalGenerators (self)-> [&Generator] {
        self._generators
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================        MISCELLANEOUS         =========================
     * ================================================================================
     * ================================================================================
     */

    impl AdvanceSymFormatting;
    impl Streamable;

    impl Formattable {
        pub over format (self, dmut stream : &Formatter) {
            stream:.write (self._fullName.toStr ());
        }
    }

    impl Hashable {

        /**
         * Two symbols have the same hash if they have the same path
         */
        pub over toHash (self)-> u64 {
            core::types::hash::__hash (self._fullName.toStr ())
        }
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================           PRIVATE            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Get all the symbols in the table, and the table of the parent
     * @params:
     *   - name: the name of the symbols to find
     *   - protection: the protection of the symbols to get
     *   - syms: the result set
     *   - callParent: true iif recursevily call parent symbols
     * @returns: in params syms
     */
    prv fn getSymbolsInTable (self, name : [c8], protection : Protection, dmut syms : &ImutSymbolList, callParent : bool = true) {
        let x = self._table.find (name, protection-> protection);
        for i in x { syms:.insert (i); }

        if (callParent) {
            if (name == self._loc.str ()) {
                match self._templateMapper {
                    Err () => { syms:.insert (self); }
                }
            }

            if let Ok (r) = self._referent {
                r.getSymbolsInTable (name, protection-> protection, alias syms);
            }
        }
    }

    /**
     * Get all the symbols in the table, and the table of the parent
     * @params:
     *   - name: the name of the symbols to find
     *   - protection: the protection of the symbols to get
     *   - syms: the result set
     *   - callParent: true iif recursevily call parent symbols
     * @returns: in params syms
     */
    prv fn getSymbolsInTable (mut self, name : [c8], protection : Protection, dmut syms : &SymbolList, callParent : bool = true) {
        let dmut x = self._table:.find (name, protection-> protection);
        for i in 0us .. x.len { syms:.insert (alias x[i]); }

        if (callParent) {
            if (name == self._loc.str ()) {
                match self._templateMapper {
                    Err () => { syms:.insert (alias self); }
                }
            }

            if let Ok (dmut r) = alias self._referent {
                r:.getSymbolsInTable (name, protection-> protection, alias syms);
            }
        }
    }

    /**
     * Get all the symbols in the table, and the table of the parent
     * @params:
     *   - name: the name of the symbols to find
     *   - protection: the protection of the symbols to get
     *   - syms: the result set
     *   - callParent: true iif recursevily call parent symbols
     * @returns: in params syms
     */
    prv fn getCloseSymbolsInTable (self, name : [c8], distance : usize, protection : Protection, dmut syms : &ImutSymbolList, callParent : bool = true) {
        if (name.len <= distance) return {};

        let x = self._table.findClose (name, distance, protection-> protection);
        for i in 0us .. x.len { syms:.insert (x [i]); }

        if (callParent) {
            let n = self._loc.str ();
            if (n.len > distance + 1us && string::levenshteinDistance (n, name) <= distance) {
                syms:.insert (self);
            }

            if let Ok (r) = self._referent {
                r.getCloseSymbolsInTable (name, distance, protection-> protection, alias syms);
            }
        }
    }

    /**
     * Compute the full name of the symbol
     */
    prot fn computeFullName (self) -> &SymbolPath {
        let p = match self._referent {
            Ok (x : _) => {
                x.getPath ()
            }
            _ => { copy SymbolPath ("") }
        }

        p.push (self._loc.str (), tmpls-> self._templateMapper)
    }

}
