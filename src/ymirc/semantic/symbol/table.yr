in table;

use ymirc::semantic::symbol::_;
use ymirc::syntax::declaration::protection;
use ymirc::utils::string;
use std::stream;

/**
 * A table is used to store the symbols
 */
@final
pub class Table {

    // The content of the table
    let mut _content : [[c8] => dmut [&Symbol]] = copy [];

    // The list of symbols that are public (subset of self._content)
    let mut _publicSyms : [[c8] => dmut [&Symbol]] = copy [];
    
    // All the templates (solution) contained in the table
    let dmut _templates : [&Symbol] = [];

    // The number of symbols declared in the table
    let mut _len : usize = 0;

    /**
     * Create an empty table containing nothing   
     */
    pub self () {}

    /*!
     * ================================================================================
     * ================================================================================
     * =========================           GETTERS            =========================
     * ================================================================================
     * ================================================================================
     */
    
    /**
     * @returns: all the inserted template symbols
     */
    pub fn getTemplates (self)-> [&Symbol] {
        self._templates
    }

    /**
     * @returns: all the inserted template symbols
     */
    pub fn getTemplates (mut self)-> dmut [&Symbol] {
        return alias self._templates;
    }

    /**
     * @returns: all the symbols
     */
    pub fn getContent (self)-> [[c8] => [&Symbol]] {
        self._content
    }

    /**
     * @returns: all the symbols that are public (subset of self.getContent ()
     */
    pub fn getPublicContent (self)-> [[c8] => [&Symbol]] {
        self._publicSyms
    }

    /**
     * @returns: all the symbols
     */
    pub fn getContent (mut self)-> dmut [[c8] => [&Symbol]] {
        alias self._content
    }

    /**
     * @returns: all the symbols that are public (subset of self.getContent ()
     */
    pub fn getPublicContent (mut self)-> dmut [[c8] => [&Symbol]] {
        alias self._publicSyms
    }

    /**
     * @returns: true if the symbol is declared public in the table
     * */
    pub fn isPublic (self, name : [c8], sym : &Symbol)-> bool {        
        if let Ok (v) = self._publicSyms [name] {
            for s in v {
                if (s is sym) return true;
            }
        }        

        false
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================          INSERTION           =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Insert a new symbol in the table
     * @params: 
     *   - sym: the symbol
     */
    pub fn insert (mut self, name : [c8], dmut sym : &Symbol, replace : bool = false) {
        if (replace) {
            self._content [name] = copy [alias sym];
        } else if let Ok (dmut v) = alias self._content [name] {
            v ~= [alias sym];
            self._content [name] = alias v;        
        } else {
            self._content [name] = copy [alias sym];
        }

        match sym.getProtection () {
            Protection::PUBLIC => {
                if (replace) {
                    self._publicSyms [name] = copy [alias sym];
                } else if let Ok (dmut v) = alias self._publicSyms [name] {
                    v ~= [alias sym];
                    self._publicSyms [name] = alias v;                
                } else {
                    self._publicSyms [name] = copy [alias sym];
                }
            }
        }
    }

    /**
     * Insert a template symbol
     * @params: 
     *   - sym: the template solution to insert
     */
    pub fn insertTemplate (mut self, dmut sym : &Symbol) {
        self._templates ~= [alias sym];
    }


    /**
     * Remove a symbol from the symbol table (keep the other symbols with the same name)
     * @params: 
     *    - name: the name of the symbol to remove
     *    - sym: the symbol to remove (addr equality)
     * @info: do nothing if the symbol was not in the table
     */
    pub fn remove (mut self, name : [c8], dmut sym : &Symbol) {        
        if let Ok (dmut v) = alias self._content [name] {
            for x in 0 .. v.len {
                if v [x] is sym {
                    v = v [0 .. x] ~ v [x + 1 .. $];
                    break;
                }
            }

            if v.len == 0 { self._content:.remove (name); }
            else {
                self._content [name] = alias v;
            }            
        }
        
        if let Ok (dmut v) = alias self._publicSyms [name] {
            for x in 0 .. v.len {
                if v [x] is sym {
                    v = v [0 .. x] ~ v [x + 1 .. $];
                    break;
                }
            }
            
            if v.len == 0 { self._publicSyms:.remove (name); }
            else {
                self._publicSyms [name] = alias v;
            }            
        }
    }
    
    /**
     * Remove everything from the table
     */
    pub fn clear (mut self) {
        self._content = copy [];
        self._publicSyms = copy [];
        self._templates = [];
    }
    
    /*!
     * ================================================================================
     * ================================================================================
     * =========================          SEARCHING           =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Search all the symbols whose name is name
     * @params: 
     *   - name: the name of the symbols to find
     *   - protection: the protection of the symbols (filtering)
     * @returns: A list of symbols
     */
    pub fn find (mut self, name : [c8], protection : Protection = Protection::PRIVATE)-> dmut [&Symbol] {
        if protection == Protection::PUBLIC {            
            if let Ok (dmut v) = alias self._publicSyms [name] {
                return alias v;            
            }
        }
        
        else if let Ok (dmut x) = alias self._content [name] {
            return alias x;        
        }

        return [];
    }

    /**
     * Search all the symbols whose name is name
     * @params: 
     *   - name: the name of the symbols to find
     *   - protection: the protection of the symbols (filtering)
     * @returns: A list of symbols
     */
    pub fn find (self, name : [c8], protection : Protection = Protection::PRIVATE)-> [&Symbol] {
        if protection == Protection::PUBLIC {            
            if let Ok (v) = self._publicSyms [name] {
                return v;            
            }
        }
        
        else if let Ok (x) = self._content [name] {
            return x;        
        }

        return [];
    }


    /**
     * Search all the symbols whose name are close to `name`
     * @params: 
     *   - name: the name of the symbols to find
     *   - distance: the distance between `name` and the name of symbol
     *   - protection: the protection of the symbols (filtering)
     * @returns: A list of symbols
     */
    pub fn findClose (self, name : [c8], distance : usize, protection : Protection = Protection::PRIVATE)-> [&Symbol] {
        if (name.len <= distance) return [];

        let mut res : [mut &Symbol] = [];
        match protection {
            Protection::PUBLIC => {
                for n, s in self._publicSyms if n.len > distance + 1us {
                    let levDist = string::levenshteinDistance (n, name);
                    if (levDist <= distance) {
                        for j in s {
                            match j {
                                EmptySymbol () => {}
                                _ => {
                                    res ~= [j];
                                }
                            }                            
                        }
                    }
                }
            }
            _ => {
                for n, s in self._content if n.len > distance + 1us {
                    let levDist = string::levenshteinDistance (n, name);
                    if (levDist <= distance) {
                        for j in s {
                            match j {
                                EmptySymbol () => {}
                                _ => {
                                    res ~= [j];
                                }
                            }
                        }
                    }
                }
            }
        }
        
        res
    }
}
