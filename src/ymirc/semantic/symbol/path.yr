in path;

use ymirc::semantic::validator::template::mapper;
use std::{stream, io, fs::path};
use ymirc::utils::format;

@final
pub class SymbolPath {

    // The content of the path
    let mut _parts : [mut [c8]] = [];

    // The templates of the path
    let mut _tmpls : [mut (&TemplateMapper)?] = [];

    pub self (path : [c8], tmpls : (&TemplateMapper)? = none) {
        let sep = "::"s8;
        let mut last = 0us;
        for i in 0us .. path.len {
            if (path[i .. $].len >= sep.len) {
                if (path[i .. i + sep.len] == sep) {
                    self._parts ~= [path [last .. i]];
                    self._tmpls ~= [none];
                    last = i + sep.len;
                }
            }
        }

        if (last != path.len) {
            self._parts ~= [path [last .. $]];
            self._tmpls ~= [tmpls];
        }
    }

    /**
     * Inner construction to avoid unnecessary parsing.
     * @complexity: O(n)
     * @params:
     *    - path: the parts of the path
     */
    prv self (path : [[c8]], tmpls : [(&TemplateMapper)?]) {
        self._parts ~= path;
        self._tmpls ~= tmpls;
    }

    /**
     * Transform the path into a string.
     * */
    pub fn toStr (self, withTemplates : bool = true)-> [c8] {
        let sep = "::"s8;
        let dmut stream = copy StringStream ();
        for i, j in self._parts {
            if j != 0us {
                stream:.write (sep);
            }

            stream:.write (i);
            if (withTemplates) {
                if let Ok (x) = self._tmpls [j] {
                    stream:.write (format("!%::%", x.simpleFormat (), i));
                }
            }
        }

        return stream[];
    }


    pub fn asStdPath (self, withTemplates : bool = false)-> &Path {
        Path (self.toStr (withTemplates-> withTemplates), sep-> "::"s8)
    }

    /**
     * Compare two paths.
     * @params:
     *   - o: another path
     */
    pub fn opEquals (self, o : &SymbolPath)-> bool {
        if (self._parts.len != o._parts.len) return false;
        if (self._parts != o._parts) return false;
        for i, z in self._tmpls match (z, o._tmpls [i]) {
            (Ok (a : _), Ok (b : _)) => if (a != b) return false;
            (_, Ok ()) => return false;
            (Ok (), _) => return false;
        }

        true
    }

    pub fn withFile (self, f : [c8])-> &SymbolPath {
        let mut res = SymbolPath (self._parts, self._tmpls);
        if (res._parts.len != 0us) {
            res._parts = res._parts [0 .. $ - 1];
        }

        res._parts ~= [f];
        res
    }

    pub fn file (self)-> [c8] {
        if (self._parts.len > 0) {
            return self._parts [$ - 1]
        }

        ""
    }

    /**
     * Append a path to the current path, from a string. The string is splitted according the to the separator of given as parameter.
     * @params:
     *    - path: the path to split and append to the path
     *    - sep: the token used to split the path
     */
    pub fn push (self, path : [c8], tmpls : (&TemplateMapper)? = none) -> SymbolPath {
        let sep = "::"s8;
        let mut aux = SymbolPath (self._parts, self._tmpls);
        {
            let mut last = 0us;
            for i in 0us .. path.len {
                if (path[i .. $].len >= sep.len) {
                    if (path[i .. i + sep.len] == sep) {
                        aux._parts ~= [path[last .. i]];
                        aux._tmpls ~= [none];
                        last = i + sep.len;
                    }
                }
            }

            if (last != path.len) {
                aux._parts ~= [path [last .. $]];
                aux._tmpls ~= [tmpls];
            }
        }

        aux
    }

    /**
     * Append a path to the current path.
     * @params:
     *    - path: the path to append at the end of the current path.
     */
    pub fn push (self, path : SymbolPath) -> &SymbolPath {
        let mut aux = SymbolPath (self._parts, self._tmpls);
        aux._parts ~= path._parts;
        aux._tmpls ~= path._tmpls;

        aux
    }

    pub fn withTemplates (self, tmpls : (&TemplateMapper)?)-> &SymbolPath {
        let dmut aux = SymbolPath (self._parts, self._tmpls);
        if (self._tmpls.len != 0us) {
            aux._tmpls [$ - 1] = tmpls;
        }

        aux
    }

    /**
     * @returns: the parts composing the path.
     */
    pub fn parts (self)-> [[c8]] {
        self._parts
    }

    /**
     * @returns: the list of template of the symbol
     * */
    pub fn templates (self)-> [(&TemplateMapper)?] {
        self._tmpls
    }

    impl std::stream::Streamable {
        pub over toStream (self, dmut stream : &StringStream) {
            stream:.write (self.toStr ());
        }
    }

    impl std::hash::Hashable;
}
