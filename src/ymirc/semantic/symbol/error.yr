in error;

use ymirc::utils::format;
use ymirc::lexing::{word, tokens};
use ymirc::semantic::symbol::_;
use ymirc::semantic::generator::_;
use ymirc::errors::_;
use ymirc::syntax::declaration::_;

@final
pub class ErrorSymbol over Symbol {

    let _error : &ErrorMsg;

    /**
     * @params:
     *   - loc: the location of the error
     *   - comm: the comments about the error
     */
    pub self (error : &ErrorMsg)
        with super (EOF_WORD, ""s8, isWeak-> false, protection-> Protection::PRIVATE)
        , _error = error
    {}

    /*!
     * ================================================================================
     * ================================================================================
     * =========================           GETTERS            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * @returns: the syntax declaration
     */
    pub fn getMessage (self)-> &ErrorMsg {
        self._error
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ======================================          MISC          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */

    impl Formattable {
        pub over format (self, dmut stream : &Formatter) {
            stream:.write (self._error);
        }

    }

}
