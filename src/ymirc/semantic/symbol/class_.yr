mod ymirc::semantic::symbol::class_;

import ymirc::utils::format;
import ymirc::lexing::word;
import ymirc::lexing::tokens;
import ymirc::semantic::symbol::_;
import ymirc::semantic::generator::_;

import ymirc::syntax::declaration::class_;
import ymirc::syntax::expression::_;
import ymirc::syntax::declaration::protection;

import std::collection::set;
import std::collection::vec;
import std::io;

pub class ClassSymbol over Symbol {

    /**
     * ================================================================================
     * ================================================================================
     * =========================         DECLARATION          =========================
     * ================================================================================
     * ================================================================================
     */
    
    /// The ancestor of the class
    let _ancestor : &Expression;

    /// The fields of the class
    let _fields : [&Expression];

    /// The comments about the fields
    let _fieldComments : [[c8]];

    /// The name of the fields that are marked private
    let _privateFields : &HashSet!{[c8]};

    /// The name of the fields that are marked protected
    let _protectedFields : &HashSet!{[c8]};
    
    /// The list of assertion of the class
    let _assertions : [&Expression];

    /// The comments about the assertions
    let _assertComments : [[c8]];
    
    /// True iif the class is abstract
    let _isAbstract : bool;

    /// True iif the class is final
    let _isFinal : bool;

    /**
     * ================================================================================
     * ================================================================================
     * =========================          VALIDATION          =========================
     * ================================================================================
     * ================================================================================
     */
    
    /// The destructor of the class
    let dmut _dtor : &Symbol = EmptySymbol::new ();

    /// The generator set at validation time, to avoid multiple validation of the same symbol
    let dmut _typeInfo : &Generator = EmptyGenerator::new ();
    
    /**
     * The list of function that were declared in a traits, but
     * not overriden by the class 
     * They were put directly in the class as they were, and will be validate likewise
     * This vector is filled at validation time
     */
    let dmut _addMethods = Vec!{dmut &Symbol}::new ();


    /**
     * ================================================================================
     * ================================================================================
     * =========================         CONSTURCTION         =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * @params: 
     *   - loc: the location of the declaration
     *   - comm: the comments about the declaration
     *   - ancestor: the expression defining the ancestor class
     *   - fields: the list of fields
     *   - fieldComments: the comments about the fields
     *   - privateFields: the name of the fields declared privates
     *   - protectedFields: the name of the fields declared public
     *   - assertions: the list of assertions
     *   - assertComments: the list of comments about the assertions    
     *   - isAbstract: true iif the class is abstract
     *   - isFinal: true iif the class if final
     */
    pub self (loc : &Word, comm : [c8], ancestor : &Expression, fields : [&Expression], fieldComments : [[c8]] = [], privateFields : &HashSet!{[c8]}, protectedFields : &HashSet!{[c8]}, assertions : [&Expression] = [], assertComments : [[c8]] = [], isAbstract : bool = false, isFinal : bool = false)
        with super (loc, comm),
    _ancestor = ancestor, _fields = fields, _fieldComments = fieldComments,
    _privateFields = privateFields, _protectedFields = protectedFields,
    _assertions = assertions, _assertComments = assertComments, _isAbstract = isAbstract, _isFinal = isFinal
    {}

    /**
     * ================================================================================
     * ================================================================================
     * =========================           GETTERS            =========================
     * ================================================================================
     * ================================================================================
     */
    
    /**
     * @returns: the expression defining the ancestor of the class 
     */
    pub def getAncestor (self)-> &Expression {
        self._ancestor
    }

    /**
     * @returns: the list of expression that defines the fields of the class
     */
    pub def getFields (self)-> [&Expression] {
        self._fields
    }

    /**
     * @returns: the list of comments about the fields
     */
    pub def getFieldComments (self)-> [[c8]] {
        self._fieldComments
    }
    
    /**
     * @returns: true iif the field exists in the class and is declared private (false otherwise)
     */
    pub def isFieldPrivate (self, name : [c8])-> bool {
        name in self._privateFields
    }

    /**
     * @returns: true iif the field exists in the class and is declared protected (false otherwise)
     */
    pub def isFieldProtected (self, name : [c8])-> bool {
        name in self._protectedFields
    }

    /**
     * @returns: the list of assertions (things to check before validating the class)
     */
    pub def getAssertions (self)-> [&Expression] {
        self._assertions
    }

    /**
     * @returns: the list of comments on assertion inside the class
     */
    pub def getAssertionComments (self)-> [[c8]] {
        self._assertComments
    }

    /**
     * @returns: true iif the class is abstract
     */
    pub def isAbstract (self)-> bool {
        self._isAbstract
    }
    
    /**
     * @returns: true iif the class is final
     */
    pub def isFinal (self)-> bool {
        self._isFinal
    }

    /**
     * @returns: the type info of the class if validated (EmptyGenerator if not)
     */
    pub def getTypeInfo (self)-> &Generator {
        self._typeInfo
    }

    /**
     * @returns: the type info of the class if validated (EmptyGenerator if not)
     */
    pub def getTypeInfo (mut self)-> dmut &Generator {
        alias self._typeInfo
    }

    /**
     * @returns: the list of methods added to the class
     */
    pub def getAddMethods (mut self)-> dmut [&Symbol] {
        return alias (alias self._addMethods)[];
    }

    /**
     * @returns: the list of methods added to the class
     */
    pub def getAddMethods (self)-> [&Symbol] {
        return self._addMethods[];
    }

    /**
     * @returns: the destructor of the class
     */
    pub def getDestructor (mut self)-> dmut &Symbol {
        alias self._dtor
    }

    /**
     * @returns: the destructor of the class
     */
    pub def getDestructor (self)-> &Symbol {
        self._dtor
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================           SETTERS            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Add an addMethod in the class
     * AddMethods are methods that are implemented from a Trait and are not present in the vtable of the ancestor
     * @params: 
     *    - meth: the symbol of the method to add (at declaration time)
     */
    pub def insertAddMethod (mut self, dmut meth : &Symbol) {
        self._addMethods:.push (alias meth);
    }

    /**
     * Set the typeinfo of the class (validated)
     * @params: 
     *    - info: a type generator created at validation time 
     */
    pub def setTypeInfo (mut self, dmut info : &Generator) {
        self._typeInfo = alias info;
    }

    /**
     * Set the destructor of the class
     * @params: 
     *    - dtor: the symbol of the destructor of the class (at declaration time)
     */
    pub def setDestructor (mut self, dmut dtor : &Symbol) {
        self._dtor = alias dtor;
    }
    
    
    /**
     * ================================================================================
     * ================================================================================
     * =========================        MISCELLANEOUS         =========================
     * ================================================================================
     * ================================================================================
     */

    impl Streamable;
    impl Formattable {


        pub over format (self, dmut stream : &Formatter) {
            import std::conv;
            stream:.write (self.to![c8]());
        }        
    }
    
}
