in class_;

use ymirc::utils::format;
use ymirc::lexing::{word, tokens};
use ymirc::semantic::{symbol, symbol::empty};

use ymirc::semantic::{generator, generator::{empty, type, error}};
use ymirc::semantic::generator::type::temporary::classref;

use ymirc::semantic::generator::{value, value::{template::method, template::ctor}};

use ymirc::syntax::declaration::{class_, condblock, protection};
use ymirc::syntax::{expression, expression::{vardecl}};
use std::stream;

@final
pub class ClassSymbol over Symbol {

    /*!
     * ================================================================================
     * ================================================================================
     * =========================         DECLARATION          =========================
     * ================================================================================
     * ================================================================================
     */
    
    // The ancestor of the class
    let _ancestor : &Expression;

    // The fields of the class
    let mut _fields : [mut &VarDeclExpr] = [];

    // The comments about the fields
    let mut _fieldComments : [mut [c8]] = [];

    // The name of the fields that are marked private
    let dmut _privateFields : [[c8] => ()] = copy [];

    // The name of the fields that are marked protected
    let dmut _protectedFields : [[c8] => ()] = copy [];

    // The name of the fields that are marked protected
    let dmut _publicFields : [[c8] => ()] = copy [];
    
    // The list of assertion of the class
    let mut _assertions : [mut &Expression] = [];

    // The list of cond blocks of the class
    let mut _condBlock : [mut &CondBlockDecl] = [];

    // The comments about the assertions
    let mut _assertComments : [mut [c8]] = [];
    
    // True iif the class is abstract
    let _isAbstract : bool;

    // True iif the class is final
    let _isFinal : bool;

    // True if the class is a structure (final, no ancestor, and on the stack)
    let _isRecord : bool;

    // True if the struct is movable
    let _isEntity : bool;

    // True if the struct is an union
    let _isUnion : bool;


    /*!
     * ================================================================================
     * ================================================================================
     * =========================          VALIDATION          =========================
     * ================================================================================
     * ================================================================================
     */
    
    // The destructor of the class
    let dmut _dtor : &Symbol = alias EMPTY_SYMBOL;

    // The generator set at validation time, to avoid multiple validation of the same symbol
    let dmut _classRef : (&ClassRefType)? = none;

    // The generator set to keep error if the validation of the class failed
    let mut _error : (&ErrorGenerator)? = none;

    /**
     * The list of function that were declared in a traits, but
     * not overriden by the class 
     * They were put directly in the class as they were, and will be validate likewise
     * This vector is filled at validation time
     */
    let dmut _addMethods : [&Symbol] = [];


    /*!
     * ================================================================================
     * ================================================================================
     * =========================         CONSTURCTION         =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * @params: 
     *   - loc: the location of the declaration
     *   - comm: the comments about the declaration
     *   - ancestor: the expression defining the ancestor class
     *   - isAbstract: true iif the class is abstract
     *   - isFinal: true iif the class if final
     */
    pub self (loc : &Word, comm : [c8], ancestor : &Expression, isEntity : bool, isRecord : bool, isUnion : bool, isAbstract : bool = false, isFinal : bool = false, protection : Protection = Protection::PRIVATE)
        with super (loc, comm, protection-> protection)
        , _ancestor = ancestor
        , _isAbstract = isAbstract
        , _isFinal = isFinal
        , _isRecord = isRecord
        , _isEntity = isEntity
        , _isUnion = isUnion
    {}

    /*!
     * ================================================================================
     * ================================================================================
     * =========================           GETTERS            =========================
     * ================================================================================
     * ================================================================================
     */
    
    /**
     * @returns: the expression defining the ancestor of the class 
     */
    pub fn getAncestor (self)-> &Expression {
        self._ancestor
    }

    /**
     * @returns: the list of expression that defines the fields of the class
     */
    pub fn getFields (self)-> [&VarDeclExpr] {
        self._fields
    }

    /**
     * @returns: the list of comments about the fields
     */
    pub fn getFieldComments (self)-> [[c8]] {
        self._fieldComments
    }
    
    /**
     * @returns: true iif the field exists in the class and is declared private (false otherwise)
     */
    pub fn isFieldPrivate (self, name : [c8])-> bool {
        name in self._privateFields
    }

    /**
     * @returns: true iif the field exists in the class and is declared protected (false otherwise)
     */
    pub fn isFieldProtected (self, name : [c8])-> bool {
        name in self._protectedFields
    }

    /**
     * @returns: true iif the field exists in the class and is declared public (false otherwise)
     */
    pub fn isFieldPublic (self, name : [c8])-> bool {
        name in self._publicFields
    }

    /**
     * @returns: the list of assertions (things to check before validating the class)
     */
    pub fn getAssertions (self)-> [&Expression] {
        self._assertions
    }

    /**
     * @returns: the list of conditional blocks in the class
     * */
    pub fn getCondBlocks (self)-> [&CondBlockDecl] {
        self._condBlock
    }

    /**
     * @returns: the list of comments on assertion inside the class
     */
    pub fn getAssertionComments (self)-> [[c8]] {
        self._assertComments
    }

    /**
     * @returns: true iif the class is abstract (only applies on classes)
     */
    pub fn isAbstract (self)-> bool {
        self._isAbstract
    }
    
    /**
     * @returns: true iif the class is final (only applies on classes)
     */
    pub fn isFinal (self)-> bool {
        self._isFinal
    }

    /**
     * @returns: true iif the class is a struct class
     * */
    pub fn isStruct (self)-> bool {
        self._isRecord || self._isEntity || self._isUnion
    }

    /**
     * @returns: true iif the class is a record
     * */
    pub fn isRecord (self)-> bool {
        self._isRecord
    }

    /**
     * @returns: true iif the class is a record
     * */
    pub fn isUnion (self)-> bool {
        self._isUnion
    }

    /**
     * @returns: true iif the struct is movable (only applicable on structs)
     * */
    pub fn isEntity (self)-> bool {
        self._isEntity
    }

    /**
     * @returns: the class ref of the class if validated (none if not)
     */
    pub fn getClassRef (mut self)-> dmut (&ClassRefType)? {
        alias self._classRef
    }

    /**
     * @returns: the class ref of the class if validated (none if not)
     */
    pub fn getClassRef (self)-> (&ClassRefType)? {
        self._classRef
    }

    /**
     * @returns: the error generator (if the validation of the class previously failed)
     * */
    pub fn getErrorGenerator (self)-> (&ErrorGenerator)? {
        self._error
    }

    /**
     * @returns: the list of methods added to the class
     */
    pub fn getAddMethods (mut self)-> dmut [&Symbol] {
        return alias self._addMethods;
    }

    /**
     * @returns: the list of methods added to the class
     */
    pub fn getAddMethods (self)-> [&Symbol] {
        return self._addMethods;
    }

    /**
     * @returns: the destructor of the class
     */
    pub fn getDestructor (mut self)-> dmut &Symbol {
        alias self._dtor
    }
    
    /**
     * @returns: the destructor of the class
     */
    pub fn getDestructor (self)-> &Symbol {
        self._dtor
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================           SETTERS            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Add an addMethod in the class
     * AddMethods are methods that are implemented from a Trait and are not present in the vtable of the ancestor
     * @params: 
     *    - meth: the symbol of the method to add (at declaration time)
     */
    pub fn insertAddMethod (mut self, dmut meth : &Symbol) {
        self._addMethods ~= [alias meth];
    }

    /**
     * Set the class reference of the class (validated)
     * @params: 
     *    - info: a type generator created at validation time 
     */
    pub fn setClassRef (mut self, dmut info : &ClassRefType) {
        self._classRef = (alias info)?;
    }

    /**
     * Set the error generator if the class validation failed
     * */
    pub fn setErrorGenerator (mut self, error : &ErrorGenerator) {
        self._classRef = none;
        self._error = (error)?;
    }

    /**
     * Set the destructor of the class
     * @params: 
     *    - dtor: the symbol of the destructor of the class (at declaration time)
     */
    pub fn setDestructor (mut self, dmut dtor : &Symbol) {
        self._dtor = alias dtor;
        self._dtor:.setReferent (alias self);
    }
    
    /**
     * Add a field declaration to the class
     * @params: 
     *   - field: the field
     *   - comm: the comments about the field
     *   - protection: the protection of the field
     */
    pub fn addField (mut self, field : &VarDeclExpr, comm : [c8], protection : Protection) {
        self._fields ~= [field];
        self._fieldComments ~= [comm];
        match protection {
            Protection::PUBLIC => {
                self._publicFields [field.getLoc ().str] = ();
            }
            Protection::PROTECTED => {
                self._protectedFields [field.getLoc ().str] = ();
            }
            _ => {
                self._privateFields [field.getLoc ().str] = ();
            }
        }
    }

    /**
     * Add a new assertion in the class
     * @params: 
     *   - assertion: the assertion
     *   - comm: the comments about the assertion
     */
    pub fn addAssertion (mut self, assertion : &Expression, comm : [c8]) {
        self._assertions ~= [assertion];
        self._assertComments ~= [comm];
    }

    /**
     * Add a new conditional block in the class
     * @params:
     *    - c: the conditional block
     */
    pub fn addCondBlock (mut self, c : &CondBlockDecl) {
        self._condBlock ~= [c];
    }
    
    /*!
     * ================================================================================
     * ================================================================================
     * =========================        MISCELLANEOUS         =========================
     * ================================================================================
     * ================================================================================
     */

    impl Streamable;

}
