mod ymirc::semantic::symbol::base;

import ymirc::utils::format;
import ymirc::lexing::word;
import ymirc::syntax::declaration::protection;
import ymirc::syntax::declaration::use_;
import ymirc::lexing::tokens;
import ymirc::semantic::symbol::table;
import ymirc::semantic::symbol::path;
import ymirc::utils::format;

import ymirc::semantic::validator::template::mapper;


import std::hash;
import std::fs::path;
import std::collection::map;
import std::collection::set;
import std::collection::vec;
import std::io;

import ymirc::semantic::symbol::sym_list;
import ymirc::semantic::symbol::unittest;
import ymirc::semantic::symbol::empty;
import ymirc::semantic::symbol::format;

import ymirc::semantic::generator::base;
import ymirc::utils::string;

/**
 * Ancestor of all kind of symbols
 * A symbol is used to contain a symbol table, that is used to manage access and references to symbols
 *
 */
pub class @abstract Symbol {

    /// The location of the symbol
    let _loc : &Word;

    /// The comments about the symbol
    let _comments : [c8];

    /// The parent of the symbol
    let dmut _referent : (&Symbol)?;

    /// This protection of the symbol
    let _protection : Protection;

    /// True if this is a weak symbol (can be replaced by another strong/weak symbol, in symbol linking)
    let mut _isWeak : bool;

    /// The external language of the symbol
    let mut _externLanguage = ""s8;

    /// The path of the external symbol (for C++ and Dlang)
    let mut _externPath = Path::new (""s8);
    
    /// The full name of the symbol (depends on self._referent)
    let mut _fullName : &SymbolPath;

    /// The list of used packets (set during validation)
    let dmut _used = HashMap!{&Path, dmut &Symbol}::new ();

    /// The list of unittest declared in the symbol
    let dmut _unittest = Vec!{dmut &UnitTestSymbol}::new ();

    /// The list of use declaration (set during declaration)
    let dmut _useDecls = Vec!{&UseDecl}::new ();

    /// The content table of the symbol
    let dmut _table = Table::new ();

    /// The template mapper used for the symbol if it was generate by a template specialization
    let mut _templateMapper : (&TemplateMapper)? = ((&TemplateMapper)?)::__err__;

    /// The list of generators associated with the symbol
    let dmut _generators : &Vec!{&Generator} = Vec!{&Generator}::new ();

    /**
     * @params:
     *   - loc: the location of the symbol
     *   - comm: the comments about the symbol
     *   - isWeak: true iif this is a weak symbol
     */
    pub self (loc : &Word, comm : [c8], isWeak : bool = false, protection : Protection = Protection::PRIVATE)
        with _loc = loc
        , _comments = comm
        , _referent = (dmut (&Symbol)?)::__err__
        , _fullName = SymbolPath::new (loc.str ())
        , _protection = protection
        , _isWeak = isWeak
    {}

    /*!
     * ================================================================================
     * ================================================================================
     * =========================           GETTERS            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * @returns: the location of the symbol
     */
    pub fn getLoc (self)-> &Word {
        self._loc
    }

    /**
     * @returns: the comments about the symbol
     */
    pub fn getComments (self)-> [c8] {
        self._comments
    }

    /**
     * @returns: the parent of the symbol
     */
    pub fn getReferent (self)-> &Symbol {
        match self._referent {
            Ok (x : _) => { return x; }
            _ => { return EmptySymbol::new (); }
        }
    }

    /**
     * @returns: the parent of the symbol
     */
    pub fn getReferent (mut self)-> dmut &Symbol {
        match ref self._referent {
            Ok (dmut x : _) => { return alias x; }
            _ => { return EmptySymbol::new (); }
        }
    }

    /**
     * @returns: the protection of the symbol
     */
    pub fn getProtection (self)-> Protection {
        self._protection
    }

    /**
     * @returns: true iif the symbol is weak
     */
    pub fn isWeak (self)-> bool {
        self._isWeak
    }

    /**
     * @returns: the path of the symbol (depends on referent)
     */
    pub fn getPath (self)-> &SymbolPath {
        self._fullName
    }

    /**
     * @returns: the template mapper used to generate the symbol (if it was generated by a template specialization)
     * */
    pub fn getTemplateMapper (self)-> (&TemplateMapper)? {
        self._templateMapper
    }

    /**
     * @returns: true if the symbol was generated by a template specialization
     * */
    pub fn isTemplate (self)-> bool {
        match self._templateMapper {
            Ok () => { true }
            _ => { false }
        }
    }

    /**
     * @returns: the external language of the function
     */
    pub fn getExternalLanguage (self)-> [c8] {
        self._externLanguage
    }

    /**
     * @returns: the path of the symbol in the external language (applicable iif self.getExternalLanguage () == C++ or Dlang)
     */
    pub fn getExternalLanguagePath (self)-> &Path {
        self._externPath
    }
    
    /*!
     * ================================================================================
     * ================================================================================
     * =========================         TABLE INSERT         =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Allows the use of an externally declared symbol for searching (in get (string) function)
     * This function is called during validation (after all symbols are declared)
     * @params: 
     *   - name: the name of the symbol (not the path, but the name in the current module (e.g. 'as'))
     *   - sym: the symbol to use
     *   - protection: the protection of the use    
     */
    pub fn @final useModule (mut self, name : &Path, dmut sym : &Symbol) {
        self._used:.insert (name, alias sym);
    }

    /**
     * Insert an unittest
     * */
    pub fn @final insertUnitTest (mut self, dmut sym : &UnitTestSymbol) {
        self._unittest:.push (alias sym);
    }

    /**
     * Insert a child symbol in the table
     * @params: 
     *   - sym: the symbol to insert
     *   - replace: if true, remove old symbol with the same name first
     */
    pub fn @final insert (mut self, dmut sym : &Symbol, replace : bool = false) {
        match sym._templateMapper {
            Ok () => {
                self:.insertTemplate (alias sym);
            }
            _ => {
                sym:.setReferent (alias self);
                self._table:.insert (sym.getLoc ().str (), alias sym, replace-> replace);
            }
        }
    }

    /**
     * Remove a symbol from the symbol table 
     * @params: 
     *    - sym: the symbol to remove 
     * @info: do nothing if the symbol is not found
     */
    pub fn @final remove (mut self, dmut sym : &Symbol) {
        self._table:.remove (sym.getLoc ().str (), alias sym);
    }

    /**
     * Insert a reference symbol in the table
     * @info: does not change the referent of sym
     * @params: 
     *   - name: the alias name
     *   - sym: the symbol to insert
     *   - replace: if true, remove old symbol with the same name first
     */
    pub fn @final insertAs (mut self, name : [c8], dmut sym : &Symbol, replace : bool = false) {
        self._table:.insert (name, alias sym, replace-> replace);
    }
    
    /**
     * Insert a template resolution symbol in the table
     * @info: not the same table, as it must be accessed differently
     * @params: 
     *   - sym: the symbol to insert
     */
    pub fn @final insertTemplate (mut self, dmut sym : &Symbol) {
        sym:.setReferent (alias self);
        self._table:.insertTemplate (alias sym);
    }

    /**
     * Insert a use declaration (by the declaration visitor)
     * */
    pub fn @final insertUse (mut self, sym : &UseDecl) {
        self._useDecls:.push (sym);
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================        TABLE RETREIVE        =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Find the templates symbols in the table
     * @returns: all the inserted template symbols
     */
    pub fn @final getTemplates (self)-> [&Symbol] {
        self._table.getTemplates ()
    }

    /**
     * @returns: the list of unittest in the symbol
     * */
    pub fn @final getUnitTests (mut self)-> dmut [&UnitTestSymbol] {
        return alias (alias self._unittest)[];
    }

    /**
     * Find all the symbols whose name are name
     * @info: ask parents
     * @params:
     *  - name: the name of the symbol to find
     *  - protection: the protection access (e.g. public-> access only public symbols, private-> access all, etc.)
     * @returns: a list of symbols
     */
    pub fn getSymbols (self, name : [c8], protection : Protection = Protection::PUBLIC, fromUsed : bool = false, dmut res : &ImutSymbolList = ImutSymbolList::new ())-> dmut &ImutSymbolList {
        match self._referent {
            Ok (x : &Symbol) => {
                // We don't use the use statement of parent module, if it is another file than self
                x.getSymbols (name, protection-> protection, fromUsed-> (fromUsed || !x.inSameFile (self)), res-> alias res);
            }

        }

        if (fromUsed)
            self.getSymbolsInTable (name, protection-> protection, syms-> alias res);
        else {
            self.getSymbolsInTable (name, protection-> Protection::PRIVATE, syms-> alias res);
            for _, module in self._used {
                module.getSymbols (name, protection-> protection, fromUsed-> true, res-> alias res);
            }
        }

        alias res
    }

    /**
     * Find all the symbols whose name are name
     * @info: ask parents
     * @params:
     *  - name: the name of the symbol to find
     *  - protection: the protection access (e.g. public-> access only public symbols, private-> access all, etc.)
     * @returns: a list of symbols
     */
    pub fn getSymbols (mut self, name : [c8], protection : Protection = Protection::PUBLIC, fromUsed : bool = false, dmut res : &SymbolList = SymbolList::new ())-> dmut &SymbolList {
        match ref self._referent {
            Ok (dmut x : &Symbol) => {
                // We don't use the use statement of parent module, if it is another file than self
                x:.getSymbols (name, protection-> protection, fromUsed-> (fromUsed || !x.inSameFile (self)), res-> alias res);
            }
        }

        if (fromUsed)
            self:.getSymbolsInTable (name, protection-> protection, syms-> alias res);
        else {
            self:.getSymbolsInTable (name, protection-> Protection::PRIVATE, syms-> alias res);
            for path, _ in self._used {
                let dmut moduleo = self._used:.find (path);
                match ref moduleo {
                    Ok (dmut module : _) => {
                        module:.getSymbols (name, protection-> protection, fromUsed-> true, res-> alias res);
                    }
                }
            }

        }
        
        alias res
    }

    /**
     * Find all the symbols whose name are almost `name`
     * @info: ask parents
     * @params:
     *  - name: the name of the symbol to find
     *  - distance: the distance between the name and `name`
     *  - protection: the protection access (e.g. public-> access only public symbols, private-> access all, etc.)
     * @returns: a list of symbols
     */
    pub fn getCloseSymbols (self, name : [c8], distance : usize, protection : Protection = Protection::PUBLIC, fromUsed : bool = false, dmut res : &ImutSymbolList = ImutSymbolList::new ())-> dmut &ImutSymbolList {
        match self._referent {
            Ok (x : &Symbol) => {
                // We don't use the use statement of parent module, if it is another file than self
                x.getCloseSymbols (name, distance, protection-> protection, fromUsed-> (fromUsed || !x.inSameFile (self)), res-> alias res);
            }
        }

        if (fromUsed)
            self.getCloseSymbolsInTable (name, distance, protection-> protection, syms-> alias res);
        else {
            self.getCloseSymbolsInTable (name, distance, protection-> Protection::PRIVATE, syms-> alias res);
            for _, module in self._used {
                module.getCloseSymbols (name, distance, protection-> protection, fromUsed-> true, res-> alias res);
            }
        }
        
        alias res
    }
    
    /**
     * Find all the symbols whose name are name
     * @info: don't ask parents or imports
     * @params:
     *  - name: the name of the symbol to find
     *  - protection: the protection access (e.g. public-> access only public symbols, private-> access all, etc.)
     * @returns: a list of symbols
     */
    pub fn getLocalSymbols (self, name : [c8], protection : Protection = Protection::PUBLIC)-> dmut &ImutSymbolList {
        let dmut res = ImutSymbolList::new ();
        self.getSymbolsInTable (name, protection, alias res, callParent-> false);
        alias res
    }

    /**
     * Find all the symbols whose name are close to name
     * @info: don't ask parents or imports
     * @params:
     *  - name: the name of the symbol to find
     *  - distance: the distance between the name and `name`
     *  - protection: the protection access (e.g. public-> access only public symbols, private-> access all, etc.)
     * @returns: a list of symbols
     * */
    pub fn getCloseLocalSymbols (self, name : [c8], distance : usize, protection : Protection = Protection::PUBLIC)-> dmut &ImutSymbolList {
        let dmut res = ImutSymbolList::new ();
        self.getCloseSymbolsInTable (name, distance, protection-> protection, syms-> alias res, callParent-> false);
        alias res
    }

    /**
     * Find all the symbols whose name are name
     * @info: don't ask parents
     * @params:
     *  - name: the name of the symbol to find
     *  - protection: the protection access (e.g. public-> access only public symbols, private-> access all, etc.)
     * @returns: a list of symbols
     */
    pub fn getLocalSymbols (mut self, name : [c8], protection : Protection = Protection::PUBLIC)-> dmut &SymbolList {
        let dmut res = SymbolList::new ();
        self:.getSymbolsInTable (name, protection, alias res, callParent-> false);
        alias res
    }
    
    /**
     * Get all local symbols
     * @info: don't ask parents
     * @params:
     *  - protection: the protection access (e.g. public-> access only public symbols, private-> access all)
     * @returns: a list of symbols
     */
    pub fn getAllLocalSymbols (self, protection : Protection = Protection::PUBLIC)-> [&Symbol] {
        if (protection == Protection::PRIVATE) {
            let local = self._table.getContent ();
            let dmut res = Vec!{&Symbol}::new ();
            for i, _ in local {
                let fnd = local.find (i);
                match fnd {
                    Ok (v : _) => {
                        for s in v {
                            res:.push (s);
                        }
                    }
                }
            }

            return (alias res)[];
        } else {
            let local = self._table.getPublicContent ();
            let dmut res = Vec!{&Symbol}::new ();
            for i, _ in local {
                let fnd = local.find (i);
                match fnd {
                    Ok (v : _) => {
                        for s in v {
                            res:.push (s);
                        }
                    }
                }
            }
            return res[];
        }        
    }


    /**
     * Get all local symbols
     * @info: don't ask parents
     * @params:
     *  - protection: the protection access (e.g. public-> access only public symbols, private-> access all)
     * @returns: a list of symbols
     */
    pub fn getAllLocalSymbols (mut self, protection : Protection = Protection::PUBLIC)-> dmut [&Symbol] {
        if (protection == Protection::PRIVATE) {
            let dmut local = self._table:.getContent ();
            let dmut res = Vec!{dmut &Symbol}::new ();
            for i, _ in local {
                let dmut fnd = local:.find (i);
                match ref fnd {
                    Ok (dmut v : _) => {
                        for s in 0us .. v.len () {
                            res:.push ((alias v)[s]);
                        }
                    }
                }
            }

            return (alias res)[];
        } else {
            let dmut local = self._table:.getPublicContent ();
            let dmut res = Vec!{dmut &Symbol}::new ();
            for i, _ in local {
                let dmut fnd = local:.find (i);
                match ref fnd {
                    Ok (dmut v : _) => {
                        for s in 0us .. v.len () {
                            res:.push ((alias v)[s]);
                        }
                    }
                }
            }
            return (alias res)[];
        }        
    }

    /**
     * Search in the symbol table the mutable symbol whose address is the same as sym
     * @info: this function is used to get mutable access to an immutable symbol
     * @returns: the mutable version of the symbol, or error if it is not found
     */
    pub fn getMutableSymbol (mut self, sym : &Symbol)-> dmut (&Symbol)? {
        let dmut localTemp = self._table:.getTemplates ();
        for i in 0us .. localTemp.len {
            if (localTemp[i] is sym) { return alias (alias localTemp[i])?; }
            
            let dmut r = (alias localTemp)[i]:.getMutableSymbol (sym);
            match ref r {
                Ok (_) => return alias r;                        
            }
        }
        
        let dmut local = self._table:.getContent ();
        for i, _ in local {
            let dmut fnd = local:.find (i);
            match ref fnd {
                Ok (dmut v : _) => {
                    for s in 0us .. v.len () {
                        if (v[s] is sym) {
                            return alias (alias (alias v)[s])?;
                        }
                        
                        let dmut r = (alias v)[s]:.getMutableSymbol (sym);
                        match ref r {
                            Ok (_) => return alias r;
                        }
                    }                    
                }
            }
        }

        (dmut (&Symbol)?)::__err__
    }


    /**
     * @returns: the list of used symbols
     *   - K => the name of the symbol
     *   - V => The symbol
     */
    pub fn getUse (mut self)-> &HashMap!{&Path, dmut &Symbol} {
        self._used
    }

    /**
     * @returns: the use declaration found in the module
     * */
    pub fn getAllUseDecls (self)-> [&UseDecl] {
        self._useDecls[]
    }

    // /**
    //  * ================================================================================
    //  * ================================================================================
    //  * =========================          COMPARISON          =========================
    //  * ================================================================================
    //  * ================================================================================
    //  */

    /**
     * Compare two symbols, to check if they contains the same thing (not only address or type)
     */
    pub fn opEquals (self, o : &Symbol) -> bool {
        self._loc.isSame (o._loc) && self._fullName == o._fullName
    }

    /**
     * @returns: true if both symbol were declared in the same file
     * @info: if the location of self, or o is iseof return true
     * */
    pub fn inSameFile (self, o : &Symbol)-> bool {
        if (self._loc.filename () == o._loc.filename ()) return true;
        if (self._loc.filename () == ""s8) return true;
        if (o._loc.filename () == ""s8) return true;

        false
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================           SETTERS            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Change the referent of the symbol
     */
    pub fn setReferent (mut self, dmut parent : &Symbol) {
        self._referent = (alias parent)?;
        self._fullName = self.computeFullName ();
    }

    /**
     * Set the external language and path of the symbol 
     * @params: 
     *    - lang: the language that declares the external symbol
     *    - path: the path of the symbol in the external language (applicable for C++ and Dlang)
     */
    pub fn setExternalLanguage (mut self, lang : [c8], path : &Path) {
        self._externLanguage = lang;
        self._externPath = path;
    }

    /**
     * Set the template name of the symbol that was declared from template declarations
     * @info: also set isWeak to true
     * @params: 
     *    - template: the list of template (in text)
     */
    pub fn setFromTemplate (mut self, mapper : &TemplateMapper) {
        self._isWeak = true;        

        self._templateMapper = mapper?;
        self._fullName = self.computeFullName ();

        let dmut local = self._table:.getContent (); // need to change the name of the inner symbols, and set them to weak
        for i, _ in local {
            let dmut fnd = local:.find (i);
            match ref fnd {
                Ok (dmut v : _) => {
                    for s in 0us .. v.len () {
                        (alias v)[s]:.setParentIsTemplate ();
                    }                    
                }
            }
        }

        match ref self._referent {
            Ok (dmut sym : _) => {
                sym:.remove (alias self); // template symbols are not accessible from the symbol table
                sym:.insertTemplate (alias self); // Don't forget to insert a template so the symbol can be still found but differently
            }
        }

    }

    /**
     * Set the symbol as a weak symbol, as one of the ancestor of this symbol is a template symbol
     */
    prv fn setParentIsTemplate (mut self) {
        self._isWeak = true;
        self._fullName = self.computeFullName ();
        
        let dmut local = self._table:.getContent ();
        for i, _ in local {
            let dmut fnd = local:.find (i);
            match ref fnd {
                Ok (dmut v : _) => {
                    for s in 0us .. v.len () {
                        (alias v)[s]:.setParentIsTemplate ();
                    }                    
                }
            }
        }
    }

    /*!
     * ================================================================================
     * ================================================================================
     * ===========================        GENERATION         ==========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Insert a generator associated to the symbol
     * @params:
     *    - gen: the generator to insert
     * */
    pub fn insertGenerator (mut self, gen : &Generator) {
        self._generators:.push (gen);
    }

    /**
     * Get all the generators associated to the symbol, and to its childrens
     * */
    pub fn getGenerators (self)-> [&Generator] {
        let dmut res = Vec!{&Generator}::new ();
        self.getGenerators (alias res);

        res[]
    }

    /**
     * Get all the generators associated to the symbol, and to its childrens
     * @params:
     *    - res: the vector to fill
     * */
    prv fn getGenerators (self, dmut res : &Vec!{&Generator}) {
        for i in self._generators {
            res:.push (i);
        }

        for _, v in self._table.getContent () {
            for s in v[] {
                s.getGenerators (alias res);
            }
        }

        for _, v in self._table.getTemplates () {
            v.getGenerators (alias res);
        }
    }

    /**
     * @returns: the list of generators associated to the symbols, but not to the childrens
     * */
    pub fn getLocalGenerators (self)-> [&Generator] {
        self._generators[]
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================        MISCELLANEOUS         =========================
     * ================================================================================
     * ================================================================================
     */

    impl AdvanceSymFormatting;

    impl Streamable;
    impl Formattable;
    impl Hashable {

        /**
         * Two symbols have the same hash if they have the same path
         */
        pub over hash (self)-> u64 {
            hash (self._loc)
        }
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================           PRIVATE            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Get all the symbols in the table, and the table of the parent
     * @params:
     *   - name: the name of the symbols to find
     *   - protection: the protection of the symbols to get
     *   - syms: the result set
     *   - callParent: true iif recursevily call parent symbols
     * @returns: in params syms
     */
    prv fn getSymbolsInTable (self, name : [c8], protection : Protection, dmut syms : &ImutSymbolList, callParent : bool = true) {
        let x = self._table.find (name, protection-> protection);
        for i in x { syms:.insert (i); }
        
        if (callParent) {
            if (name == self._loc.str ()) {
                match self._templateMapper {
                    Err () => { syms:.insert (self); }
                }
            }

            match self._referent {
                Ok (r : _) => r.getSymbolsInTable (name, protection-> protection, alias syms);
            }
        }
    }

    /**
     * Get all the symbols in the table, and the table of the parent
     * @params:
     *   - name: the name of the symbols to find
     *   - protection: the protection of the symbols to get
     *   - syms: the result set
     *   - callParent: true iif recursevily call parent symbols
     * @returns: in params syms
     */
    prv fn getSymbolsInTable (mut self, name : [c8], protection : Protection, dmut syms : &SymbolList, callParent : bool = true) {
        let dmut x = self._table:.find (name, protection-> protection);
        for i in 0us .. x.len { syms:.insert (alias x[i]); }
        
        if (callParent) {
            if (name == self._loc.str ()) {
                match self._templateMapper {
                    Err () => { syms:.insert (alias self); }
                }
            }

            match ref self._referent {
                Ok (dmut r : _) => r:.getSymbolsInTable (name, protection-> protection, alias syms);
            }
        }
    }

    /**
     * Get all the symbols in the table, and the table of the parent
     * @params:
     *   - name: the name of the symbols to find
     *   - protection: the protection of the symbols to get
     *   - syms: the result set
     *   - callParent: true iif recursevily call parent symbols
     * @returns: in params syms
     */
    prv fn getCloseSymbolsInTable (self, name : [c8], distance : usize, protection : Protection, dmut syms : &ImutSymbolList, callParent : bool = true) {
        let x = self._table.findClose (name, distance, protection-> protection);
        for i in 0us .. x.len { syms:.insert (x [i]); }
        
        if (callParent) {
            let n = self._loc.str ();
            if (string::levenshteinDistance (n, name) <= distance && n.len > distance && name.len > distance) {
                syms:.insert (self);
            }

            match self._referent {
                Ok (r : _) => r.getCloseSymbolsInTable (name, distance, protection-> protection, alias syms);
            }
        }
    }
    
    /**
     * Compute the full name of the symbol
     */
    prot fn computeFullName (self) -> &SymbolPath {
        let p = match self._referent {
            Ok (x : _) => {
                x.getPath ()
            }
            _ => { SymbolPath::new (""s8) }
        }
        
        p.push (self._loc.str (), tmpls-> self._templateMapper)
    }    
    
}
