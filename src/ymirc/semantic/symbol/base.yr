mod ymirc::semantic::symbol::base;

import ymirc::utils::format;
import ymirc::lexing::word;
import ymirc::syntax::declaration::protection;
import ymirc::lexing::tokens;
import ymirc::semantic::symbol::table;
import ymirc::utils::format;

import ymirc::semantic::validator::template::mapper;


import std::hash;
import std::fs::path;
import std::collection::map;
import std::collection::set;
import std::collection::vec;
import std::io;

import ymirc::semantic::symbol::sym_list;
import ymirc::semantic::symbol::empty;

/**
 * Ancestor of all kind of symbols
 * A symbol is used to contain a symbol table, that is used to manage access and references to symbols
 *
 */
pub class @abstract Symbol {

    /// The location of the symbol
    let _loc : &Word;

    /// The comments about the symbol
    let _comments : [c8];

    /// The parent of the symbol
    let dmut _referent : (&Symbol)?;

    /// This protection of the symbol
    let _protection : Protection;

    /// True if this is a weak symbol (can be replaced by another strong/weak symbol, in symbol linking)
    let mut _isWeak : bool;

    /// The external language of the symbol
    let mut _externLanguage = ""s8;

    /// The path of the external symbol (for C++ and Dlang)
    let mut _externPath = Path::new (""s8);
    
    /// The full name of the symbol (depends on self._referent)
    let mut _fullName : &Path;

    /// The list of used packets
    let dmut _used = HashMap!{&Path, dmut &Symbol}::new ();

    /// The protection of the used symbols
    let dmut _usedProtection = HashMap!{&Path, Protection}::new ();

    /// The content table of the symbol
    let dmut _table = Table::new ();

    /// The template mapper used for the symbol if it was generate by a template specialization
    let mut _templateMapper : (&TemplateMapper)? = ((&TemplateMapper)?)::__err__;

    /**
     * @params:
     *   - loc: the location of the symbol
     *   - comm: the comments about the symbol
     *   - isWeak: true iif this is a weak symbol
     */
    pub self (loc : &Word, comm : [c8], isWeak : bool = false, protection : Protection = Protection::PRIVATE)
        with
        _loc = loc,
    _comments = comm,
    _referent = (dmut (&Symbol)?)::__err__,
    _fullName = Path::new (loc.str ()),
    _protection = protection,
    _isWeak = isWeak
    {}

    /**
     * ================================================================================
     * ================================================================================
     * =========================           GETTERS            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * @returns: the location of the symbol
     */
    pub def getLoc (self)-> &Word {
        self._loc
    }

    /**
     * @returns: the comments about the symbol
     */
    pub def getComments (self)-> [c8] {
        self._comments
    }

    /**
     * @returns: the parent of the symbol
     */
    pub def getReferent (self)-> &Symbol {
        match self._referent {
            Ok (x : _) => { return x; }
            _ => { return EmptySymbol::new (); }
        }
    }

    /**
     * @returns: the parent of the symbol
     */
    pub def getReferent (mut self)-> dmut &Symbol {
        match ref self._referent {
            Ok (dmut x : _) => { return alias x; }
            _ => { return EmptySymbol::new (); }
        }
    }

    /**
     * @returns: the protection of the symbol
     */
    pub def getProtection (self)-> Protection {
        self._protection
    }

    /**
     * @returns: true iif the symbol is weak
     */
    pub def isWeak (self)-> bool {
        self._isWeak
    }

    /**
     * @returns: the path of the symbol (depends on referent)
     */
    pub def getPath (self)-> &Path {
        self._fullName
    }

    /**
     * @returns: the template mapper used to generate the symbol (if it was generated by a template specialization)
     * */
    pub def getTemplateMapper (self)-> (&TemplateMapper)? {
        self._templateMapper
    }

    /**
     * @returns: true if the symbol was generated by a template specialization
     * */
    pub def isTemplate (self)-> bool {
        match self._templateMapper {
            Ok () => { true }
            _ => { false }
        }
    }

    /**
     * @returns: the external language of the function
     */
    pub def getExternalLanguage (self)-> [c8] {
        self._externLanguage
    }

    /**
     * @returns: the path of the symbol in the external language (applicable iif self.getExternalLanguage () == C++ or Dlang)
     */
    pub def getExternalLanguagePath (self)-> &Path {
        self._externPath
    }
    
    /**
     * ================================================================================
     * ================================================================================
     * =========================         TABLE INSERT         =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Allows the use of an externally declared symbol for searching (in get (string) function)
     * Basically this method is called when importing a module, or with use_stmt
     * @params: 
     *   - name: the name of the symbol (not the path, but the name in the current module (e.g. 'as'))
     *   - sym: the symbol to use
     *   - protection: the protection of the use    
     */
    pub def @final use (mut self, name : &Path, dmut sym : &Symbol, protection : Protection = Protection::PRIVATE) {
        self._used:.insert (name, alias sym);
        self._usedProtection:.insert (name, protection);
    }

    /**
     * Insert a child symbol in the table
     * @params: 
     *   - sym: the symbol to insert
     *   - replace: if true, remove old symbol with the same name first
     */
    pub def @final insert (mut self, dmut sym : &Symbol, replace : bool = false, anonymus : bool = false) {
        if (anonymus) {
            self:.insertTemplate (alias sym);
        } else {
            sym:.setReferent (alias self);
            self._table:.insert (sym.getLoc ().str (), alias sym, replace-> replace);
        }
    }

    /**
     * Remove a symbol from the symbol table 
     * @params: 
     *    - sym: the symbol to remove 
     * @info: do nothing if the symbol is not found
     */
    pub def @final remove (mut self, dmut sym : &Symbol) {
        self._table:.remove (sym.getLoc ().str (), alias sym);
    }

    /**
     * Insert a reference symbol in the table
     * @info: does not change the referent of sym
     * @params: 
     *   - name: the alias name
     *   - sym: the symbol to insert
     *   - replace: if true, remove old symbol with the same name first
     */
    pub def @final insertAs (mut self, name : [c8], dmut sym : &Symbol, replace : bool = false) {
        self._table:.insert (name, alias sym, replace-> replace);
    }
    
    /**
     * Insert a template resolution symbol in the table
     * @info: not the same table, as it must be accessed differently
     * @params: 
     *   - sym: the symbol to insert
     */
    pub def @final insertTemplate (mut self, dmut sym : &Symbol) {
        sym:.setReferent (alias self);
        self._table:.insertTemplate (alias sym);
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================        TABLE RETREIVE        =========================
     * ================================================================================
     * ================================================================================
     */
   
    /**
     * Find the templates symbols in the table
     * @returns: all the inserted template symbols
     */
    pub def @final getTemplates (self)-> [&Symbol] {
        self._table.getTemplates ()
    }

    /**
     * Find all the symbols whose name are name
     * @info: ask parents
     * @params:
     *  - name: the name of the symbol to find
     *  - protection: the protection access (e.g. public-> access only public symbols, private-> access all, etc.)
     * @returns: a list of symbols
     */
    pub def getSymbols (self, name : [c8], protection : Protection = Protection::PUBLIC, dmut used : &HashSet!{&Path} = HashSet!{&Path}::new (), second : bool = false, dmut res : &ImutSymbolList = ImutSymbolList::new ())-> dmut &ImutSymbolList {
        if (self._fullName !in used) {
            match self._referent {
                Ok (x : &Symbol) => {
                    x.getSymbols (name, protection-> protection, used-> alias used, second-> second, res-> alias res);
                }                
            }

            if (second)
                self.getSymbolsInTable (name, protection-> protection, syms-> alias res);
            else
                self.getSymbolsInTable (name, protection-> Protection::PRIVATE, syms-> alias res);
            
            for path, subProt in self._usedProtection {
                let moduleo = self._used.find (path);
                match moduleo {
                    Ok (module : _) => {
                        match module {
                            _ => {
                                if module.getPath () !in used {
                                    if (!second || subProt == Protection::PUBLIC) {
                                        module.getSymbols (name, protection-> protection, used-> alias used, second-> true, res-> alias res);
                                    }                    
                                }            
                            }
                        }                        
                    }
                }                
            }
        }
        
        alias res
    }

    /**
     * Find all the symbols whose name are name
     * @info: ask parents
     * @params:
     *  - name: the name of the symbol to find
     *  - protection: the protection access (e.g. public-> access only public symbols, private-> access all, etc.)
     * @returns: a list of symbols
     */
    pub def getSymbols (mut self, name : [c8], protection : Protection = Protection::PUBLIC, dmut used : &HashSet!{&Path} = HashSet!{&Path}::new (), second : bool = false, dmut res : &SymbolList = SymbolList::new ())-> dmut &SymbolList {
        if (self._fullName !in used) {
            match ref self._referent {
                Ok (dmut x : &Symbol) => {
                    x:.getSymbols (name, protection-> protection, used-> alias used, second-> second, res-> alias res);
                }                
            }

            if (second)
                self:.getSymbolsInTable (name, protection-> protection, syms-> alias res);
            else
                self:.getSymbolsInTable (name, protection-> Protection::PRIVATE, syms-> alias res);

            for path, subProt in self._usedProtection {
                let dmut moduleo = self._used:.find (path);
                match ref moduleo {
                    Ok (dmut module : _) => {
                        match module {
                            _ => {
                                if module.getPath () !in used {
                                    if (!second || subProt == Protection::PUBLIC) {
                                        module:.getSymbols (name, protection-> protection, used-> alias used, second-> true, res-> alias res);
                                    }                    
                                }            
                            }
                        }                        
                    }
                }                
            }
        }
        
        alias res
    }

    /**
     * Find all the symbols whose name are almost `name`
     * @info: ask parents
     * @params:
     *  - name: the name of the symbol to find
     *  - distance: the distance between the name and `name`
     *  - protection: the protection access (e.g. public-> access only public symbols, private-> access all, etc.)
     * @returns: a list of symbols
     */
    pub def getCloseSymbols (self, name : [c8], distance : usize, protection : Protection = Protection::PUBLIC, dmut used : &HashSet!{&Path} = HashSet!{&Path}::new (), second : bool = false, dmut res : &ImutSymbolList = ImutSymbolList::new ())-> dmut &ImutSymbolList {
        if (self._fullName !in used) {
            match self._referent {
                Ok (x : &Symbol) => {
                    x.getCloseSymbols (name, distance, protection-> protection, used-> alias used, second-> second, res-> alias res);
                }
            }

            if (second)
                self.getCloseSymbolsInTable (name, distance, protection-> protection, syms-> alias res);
            else
                self.getCloseSymbolsInTable (name, distance, protection-> Protection::PRIVATE, syms-> alias res);
            
            for path, subProt in self._usedProtection {
                let moduleo = self._used.find (path);
                match moduleo {
                    Ok (module : _) => {
                        match module {
                            _ => {
                                if module.getPath () !in used {
                                    if (!second || subProt == Protection::PUBLIC) {
                                        module.getCloseSymbols (name, distance, protection-> protection, used-> alias used, second-> true, res-> alias res);
                                    }                    
                                }            
                            }
                        }                        
                    }
                }                
            }
        }
        
        alias res
    }
    
    /**
     * Find all the symbols whose name are name
     * @info: don't ask parents
     * @params:
     *  - name: the name of the symbol to find
     *  - protection: the protection access (e.g. public-> access only public symbols, private-> access all, etc.)
     * @returns: a list of symbols
     */
    pub def getLocalSymbols (self, name : [c8], protection : Protection = Protection::PUBLIC)-> dmut &ImutSymbolList {
        let dmut res = ImutSymbolList::new ();
        self.getSymbolsInTable (name, protection, alias res);
        alias res
    }

    /**
     * Find all the symbols whose name are name
     * @info: don't ask parents
     * @params:
     *  - name: the name of the symbol to find
     *  - protection: the protection access (e.g. public-> access only public symbols, private-> access all, etc.)
     * @returns: a list of symbols
     */
    pub def getLocalSymbols (mut self, name : [c8], protection : Protection = Protection::PUBLIC)-> dmut &SymbolList {
        let dmut res = SymbolList::new ();
        self:.getSymbolsInTable (name, protection, alias res);
        alias res
    }

    
    /**
     * Get all local symbols
     * @info: don't ask parents
     * @params:
     *  - protection: the protection access (e.g. public-> access only public symbols, private-> access all)
     * @returns: a list of symbols
     */
    pub def getAllLocalSymbols (self, protection : Protection = Protection::PUBLIC)-> [&Symbol] {
        if (protection == Protection::PRIVATE) {
            let local = self._table.getContent ();
            let dmut res = Vec!{&Symbol}::new ();
            for i, _ in local {
                let fnd = local.find (i);
                match fnd {
                    Ok (v : _) => {
                        for s in v {
                            res:.push (s);
                        }
                    }
                }
            }

            return (alias res)[];
        } else {
            let local = self._table.getPublicContent ();
            let dmut res = Vec!{&Symbol}::new ();
            for i, _ in local {
                let fnd = local.find (i);
                match fnd {
                    Ok (v : _) => {
                        for s in v {
                            res:.push (s);
                        }
                    }
                }
            }
            return res[];
        }        
    }


    /**
     * Get all local symbols
     * @info: don't ask parents
     * @params:
     *  - protection: the protection access (e.g. public-> access only public symbols, private-> access all)
     * @returns: a list of symbols
     */
    pub def getAllLocalSymbols (mut self, protection : Protection = Protection::PUBLIC)-> dmut [&Symbol] {
        if (protection == Protection::PRIVATE) {
            let dmut local = self._table:.getContent ();
            let dmut res = Vec!{dmut &Symbol}::new ();
            for i, _ in local {
                let dmut fnd = local:.find (i);
                match ref fnd {
                    Ok (dmut v : _) => {
                        for s in 0us .. v.len () {
                            res:.push ((alias v)[s]);
                        }
                    }
                }
            }

            return (alias res)[];
        } else {
            let dmut local = self._table:.getPublicContent ();
            let dmut res = Vec!{dmut &Symbol}::new ();
            for i, _ in local {
                let dmut fnd = local:.find (i);
                match ref fnd {
                    Ok (dmut v : _) => {
                        for s in 0us .. v.len () {
                            res:.push ((alias v)[s]);
                        }
                    }
                }
            }
            return (alias res)[];
        }        
    } catch {
        _ => __pragma!panic ();
    }

    /**
     * Search in the symbol table the mutable symbol whose address is the same as sym
     * @info: this function is used to get mutable access to an immutable symbol
     * @returns: the mutable version of the symbol, or error if it is not found
     */
    pub def getMutableSymbol (mut self, sym : &Symbol)-> dmut (&Symbol)? {
        let dmut localTemp = self._table:.getTemplates ();
        for i in 0us .. localTemp.len {
            if (localTemp[i] is sym) { return alias (alias localTemp[i])?; }
            
            let dmut r = (alias localTemp)[i]:.getMutableSymbol (sym);
            match ref r {
                Ok (_) => return alias r;                        
            }
        }
        
        let dmut local = self._table:.getContent ();
        for i, _ in local {
            let dmut fnd = local:.find (i);
            match ref fnd {
                Ok (dmut v : _) => {
                    for s in 0us .. v.len () {
                        {
                            if (v[s] is sym) {
                                return alias (alias (alias v)[s])?;
                            }
                        
                            let dmut r = (alias v)[s]:.getMutableSymbol (sym);
                            match ref r {
                                Ok (_) => return alias r;                        
                            }
                        } catch {
                            _ => __pragma!panic ();
                        }
                    }                    
                }
            }
        }

        (dmut (&Symbol)?)::__err__
    }


    /**
     * @returns: the list of used symbols
     *   - K => the name of the symbol
     *   - V => The symbol
     */
    pub def getUse (mut self)-> &HashMap!{&Path, dmut &Symbol} {
        self._used
    }

    /**
     * @returns: the list of used symbols
     *   - K => the name of the symbol
     *   - V => The protection
     */
    pub def getUseProtection (self)-> &HashMap!{&Path, Protection} {
        self._usedProtection
    }

    
    // /**
    //  * ================================================================================
    //  * ================================================================================
    //  * =========================          COMPARISON          =========================
    //  * ================================================================================
    //  * ================================================================================
    //  */

    /**
     * Compare two symbols, to check if they contains the same thing (not only address or type)
     */
    pub def opEquals (self, o : &Symbol) -> bool {
        self._loc.isSame (o._loc)
    }

    
    /**
     * ================================================================================
     * ================================================================================
     * =========================           SETTERS            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Change the referent of the symbol
     */
    pub def setReferent (mut self, dmut parent : &Symbol) {
        self._referent = (alias parent)?;
        self._fullName = self.computeFullName ();
    }

    /**
     * Set the external language and path of the symbol 
     * @params: 
     *    - lang: the language that declares the external symbol
     *    - path: the path of the symbol in the external language (applicable for C++ and Dlang)
     */
    pub def setExternalLanguage (mut self, lang : [c8], path : &Path) {
        self._externLanguage = lang;
        self._externPath = path;
    }

    /**
     * Set the template name of the symbol that was declared from template declarations
     * @info: also set isWeak to true
     * @params: 
     *    - template: the list of template (in text)
     */
    pub def setFromTemplate (mut self, templates : [c8], mapper : &TemplateMapper) {
        self._isWeak = true;        
        match ref self._referent {
            Ok (dmut sym : _) => {
                sym:.remove (alias self); // template symbols are not accessible from the symbol table
                sym:.insertTemplate (alias self); // Don't forget to insert a template so the symbol can be still found but differently
            }
        }

        self._fullName = self.computeFullName ();
        let filename = ymirc::utils::format::format ("%!%::%"s8, self._fullName.file (), templates, self._fullName.file ());
        
        self._fullName = self._fullName.parent ().push (Path::new (filename, sep-> "::"s8));
        self._templateMapper = mapper?;

        let dmut local = self._table:.getContent (); // need to change the name of the inner symbols, and set them to weak
        for i, _ in local {
            let dmut fnd = local:.find (i);
            match ref fnd {
                Ok (dmut v : _) => {
                    for s in 0us .. v.len () {
                        {
                            (alias v)[s]:.setParentIsTemplate ();                            
                        } catch {
                            _ => __pragma!panic ();
                        }
                    }                    
                }
            }
        }
    }

    /**
     * Set the symbol as a weak symbol, as one of the ancestor of this symbol is a template symbol
     */
    prv def setParentIsTemplate (mut self) {
        self._isWeak = true;
        self._fullName = self.computeFullName ();
        
        let dmut local = self._table:.getContent ();
        for i, _ in local {
            let dmut fnd = local:.find (i);
            match ref fnd {
                Ok (dmut v : _) => {
                    for s in 0us .. v.len () {
                        {
                            (alias v)[s]:.setParentIsTemplate ();                            
                        } catch {
                            _ => __pragma!panic ();
                        }
                    }                    
                }
            }
        }
    }
    
    /**
     * ================================================================================
     * ================================================================================
     * =========================        MISCELLANEOUS         =========================
     * ================================================================================
     * ================================================================================
     */


    impl Streamable;
    impl Formattable;
    impl Hashable {

        /**
         * Two symbols have the same hash if they have the same path
         */
        pub over hash (self)-> u64 {
            hash (self._loc)
        }
    }
        
    /**
     * ================================================================================
     * ================================================================================
     * =========================           PRIVATE            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Get all the symbols in the table, and the table of the parent
     * @params:
     *   - name: the name of the symbols to find
     *   - protection: the protection of the symbols to get
     *   - syms: the result set
     *   - callParent: true iif recursevily call parent symbols
     * @returns: in params syms
     */
    prv def getSymbolsInTable (self, name : [c8], protection : Protection, dmut syms : &ImutSymbolList, callParent : bool = true) {
        let x = self._table.find (name, protection-> protection);
        for i in x { syms:.insert (i); }
        if (name == self._loc.str ()) { syms:.insert (self); }
        
        if (callParent) {
            match self._referent {
                Ok (r : _) => r.getSymbolsInTable (name, protection-> protection, alias syms);
            }
        }
    }

    /**
     * Get all the symbols in the table, and the table of the parent
     * @params:
     *   - name: the name of the symbols to find
     *   - protection: the protection of the symbols to get
     *   - syms: the result set
     *   - callParent: true iif recursevily call parent symbols
     * @returns: in params syms
     */
    prv def getSymbolsInTable (mut self, name : [c8], protection : Protection, dmut syms : &SymbolList, callParent : bool = true) {
        let dmut x = self._table:.find (name, protection-> protection);
        for i in 0us .. x.len { syms:.insert (alias x[i]); }
        if (name == self._loc.str ()) { syms:.insert (alias self); }
        
        if (callParent) {
            match ref self._referent {
                Ok (dmut r : _) => r:.getSymbolsInTable (name, protection-> protection, alias syms);
            }
        }
    }

    /**
     * Get all the symbols in the table, and the table of the parent
     * @params:
     *   - name: the name of the symbols to find
     *   - protection: the protection of the symbols to get
     *   - syms: the result set
     *   - callParent: true iif recursevily call parent symbols
     * @returns: in params syms
     */
    prv def getCloseSymbolsInTable (self, name : [c8], distance : usize, protection : Protection, dmut syms : &ImutSymbolList, callParent : bool = true) {
        let x = self._table.findClose (name, distance, protection-> protection);
        for i in 0us .. x.len { syms:.insert (x [i]); }
        if (name == self._loc.str ()) { syms:.insert (self); }
        
        if (callParent) {
            match self._referent {
                Ok (r : _) => r.getCloseSymbolsInTable (name, distance, protection-> protection, alias syms);
            }
        }
    }
    
    /**
     * Compute the full name of the symbol
     */
    prot def computeFullName (self) -> &Path {
        let p = match self._referent {
            Ok (x : _) => {
                x.getPath ()
            }
            _ => { Path::new (""s8) }
        }
        
        p.push (self._loc.str ())
    }    
    
}
