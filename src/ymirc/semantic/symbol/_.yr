mod ymirc::semantic::symbol::_;

import ymirc::utils::format;
import ymirc::lexing::word;
import ymirc::syntax::declaration::protection;
import ymirc::lexing::tokens;
import ymirc::semantic::symbol::table;


import std::hash;
import std::fs::path;
import std::collection::map;
import std::collection::set;
import std::collection::vec;
import std::io;


/**
 * Ancestor of all kind of symbols
 * A symbol is used to contain a symbol table, that is used to manage access and references to symbols
 *
 */
pub class @abstract Symbol {

    /// The location of the symbol
    let _loc : &Word;

    /// The comments about the symbol
    let _comments : [c8];

    /// The parent of the symbol
    let dmut _referent : (&Symbol)?;

    /// This protection of the symbol
    let _protection : Protection;

    /// True if this is a weak symbol (can be replaced by another strong/weak symbol, in symbol linking)
    let _isWeak : bool;

    /// The full name of the symbol (depends on self._referent)
    let mut _fullName : &Path;

    /// The list of used packets
    let dmut _used = HashMap!{&Path, dmut &Symbol}::new ();

    /// The protection of the used symbols
    let dmut _usedProtection = HashMap!{&Path, Protection}::new ();

    /// The content table of the symbol
    let dmut _table = Table::new ();
    
    /**
     * @params:
     *   - loc: the location of the symbol
     *   - comm: the comments about the symbol
     *   - isWeak: true iif this is a weak symbol
     */
    pub self (loc : &Word, comm : [c8], isWeak : bool = false, protection : Protection = Protection::PRIVATE)
        with
        _loc = loc,
    _comments = comm,
    _referent = (dmut (&Symbol)?)::__err__,
    _fullName = Path::new (loc.str ()),
    _protection = protection,
    _isWeak = isWeak    
    {}

    /**
     * ================================================================================
     * ================================================================================
     * =========================           GETTERS            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * @returns: the location of the symbol
     */
    pub def getLoc (self)-> &Word {
        self._loc
    }

    /**
     * @returns: the comments about the symbol
     */
    pub def getComments (self)-> [c8] {
        self._comments
    }

    /**
     * @returns: the parent of the symbol
     */
    pub def getReferent (self)-> &Symbol {
        match self._referent {
            Ok (x : _) => { return x; }
            _ => { return EmptySymbol::new (); }
        }
    }

    /**
     * @returns: the parent of the symbol
     */
    pub def getReferent (mut self)-> dmut &Symbol {
        match ref self._referent {
            Ok (dmut x : _) => { return alias x; }
            _ => { return EmptySymbol::new (); }
        }
    }

    /**
     * @returns: the protection of the symbol
     */
    pub def getProtection (self)-> Protection {
        self._protection
    }

    /**
     * @returns: true iif the symbol is weak
     */
    pub def isWeak (self)-> bool {
        self._isWeak
    }

    /**
     * @returns: the path of the symbol (depends on referent)
     */
    pub def getPath (self)-> &Path {
        self._fullName
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================         TABLE INSERT         =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Allows the use of an externally declared symbol for searching (in get (string) function)
     * Basically this method is called when importing a module, or with use_stmt
     * @params: 
     *   - name: the name of the symbol (not the path, but the name in the current module (e.g. 'as'))
     *   - sym: the symbol to use
     *   - protection: the protection of the use    
     */
    pub def @final use (mut self, name : &Path, dmut sym : &Symbol, protection : Protection = Protection::PRIVATE) {
        self._used:.insert (name, alias sym);
        self._usedProtection:.insert (name, protection);
    }

    /**
     * Insert a child symbol in the table
     * @params: 
     *   - sym: the symbol to insert
     *   - replace: if true, remove old symbol with the same name first
     */
    pub def @final insert (mut self, dmut sym : &Symbol, replace : bool = false) {
        sym:.setReferent (alias self);
        self._table:.insert (alias sym, replace-> replace);
    }
    
    /**
     * Insert a template resolution symbol in the table
     * @info: not the same table, as it must be accessed differently
     * @params: 
     *   - sym: the symbol to insert
     */
    pub def @final insertTemplate (mut self, dmut sym : &Symbol) {
        self._table:.insertTemplate (alias sym);
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================        TABLE RETREIVE        =========================
     * ================================================================================
     * ================================================================================
     */
   
    /**
     * Find the templates symbols in the table
     * @returns: all the inserted template symbols
     */
    pub def @final getTemplates (self)-> [&Symbol] {
        self._table.getTemplates ()
    }

    /**
     * Find the templates symbols in the table
     * @returns: all the inserted template symbols
     */
    pub def @final getTemplates (mut self)-> dmut [&Symbol] {
        alias self._table:.getTemplates ()
    }


    /**
     * Find all the symbols whose name are name
     * @info: ask parents
     * @params:
     *  - name: the name of the symbol to find
     *  - protection: the protection access (e.g. public-> access only public symbols, private-> access all, etc.)
     * @returns: a list of symbols
     */
    pub def getSymbols (mut self, name : [c8], protection : Protection = Protection::PUBLIC, dmut used : &HashSet!{&Path} = HashSet!{&Path}::new (), second : bool = false, dmut res : &HashSet!{dmut &Symbol} = HashSet!{dmut &Symbol}::new ())-> dmut &HashSet!{dmut &Symbol} {
        if (self._fullName !in used) {
            self:.getSymbolsInTable (name, protection-> protection, syms-> alias res);            
            for path, subProt in self._usedProtection {
                let dmut moduleo = self._used:.find (path);
                match ref moduleo {
                    Ok (dmut module : _) => {
                        match module {
                            //EmptySymbol () => { self:.getModuleByPath (p) }
                            _ => {
                                if module.getPath () !in used {
                                    if (!second || subProt == Protection::PUBLIC) {
                                        module:.getSymbols (name, protection-> protection, used-> alias used, second-> true, res-> alias res);
                                    }                    
                                }            
                            }
                        }                        
                    }
                }                
            }
        }
        
        alias res
    }
    
    /**
     * Find all the symbols whose name are name
     * @info: don't ask parents
     * @params:
     *  - name: the name of the symbol to find
     *  - protection: the protection access (e.g. public-> access only public symbols, private-> access all, etc.)
     * @returns: a list of symbols
     */
    pub def getLocalSymbols (mut self, name : [c8], protection : Protection = Protection::PUBLIC)-> dmut &HashSet!{dmut &Symbol} {
        let dmut res = HashSet!{dmut &Symbol}::new ();
        self:.getSymbolsInTable (name, protection, alias res);
        alias res
    }

    /**
     * Find all the symbols whose name are name
     * @info: don't ask parents
     * @params:
     *  - name: the name of the symbol to find
     *  - protection: the protection access (e.g. public-> access only public symbols, private-> access all, etc.)
     * @returns: a list of symbols
     */
    pub def getLocalSymbols (self, name : [c8], protection : Protection = Protection::PUBLIC)-> &HashSet!{&Symbol} {
        let dmut res = HashSet!{&Symbol}::new ();
        self.getSymbolsInTable (name, protection, alias res);
        alias res
    }        

    /**
     * @returns: the list of used symbols
     *   - K => the name of the symbol
     *   - V => The symbol
     */
    pub def getUse (self)-> &HashMap!{&Path, dmut &Symbol} {
        self._used
    }

    /**
     * @returns: the list of used symbols
     *   - K => the name of the symbol
     *   - V => The protection
     */
    pub def getUseProtection (self)-> &HashMap!{&Path, Protection} {
        self._usedProtection
    }

    
    // /**
    //  * ================================================================================
    //  * ================================================================================
    //  * =========================          COMPARISON          =========================
    //  * ================================================================================
    //  * ================================================================================
    //  */

    /**
     * Compare two symbols, to check if they contains the same thing (not only address or type)
     */
    pub def opEquals (self, o : &Symbol) -> bool {
        self._fullName == o._fullName
    }

    
    /**
     * ================================================================================
     * ================================================================================
     * =========================           SETTERS            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Change the referent of the symbol
     */
    pub def setReferent (mut self, dmut parent : &Symbol) {
        self._referent = (alias parent)?;
        self._fullName = self:.computeFullName ();
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================        MISCELLANEOUS         =========================
     * ================================================================================
     * ================================================================================
     */


    impl Streamable;
    impl Formattable;
    impl Hashable {

        /**
         * Two symbols have the same hash if they have the same path
         */
        pub over hash (self)-> u64 {
            hash (self._fullName)
        }
    }
        
    /**
     * ================================================================================
     * ================================================================================
     * =========================           PRIVATE            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Get all the symbols in the table, and the table of the parent
     * @params:
     *   - name: the name of the symbols to find
     *   - protection: the protection of the symbols to get
     *   - syms: the result set
     *   - callParent: true iif recursevily call parent symbols
     * @returns: in params syms
     */
    prv def getSymbolsInTable (mut self, name : [c8], protection : Protection, dmut syms : &HashSet!{dmut &Symbol}, callParent : bool = true) {
        let dmut x = self._table:.find (name, protection-> protection);
        for i in 0us .. x.len { syms:.insert (alias x [i]); }
        if (name == self._loc.str ()) { syms:.insert (alias self); }
        
        if (callParent) {
            match ref self._referent {
                Ok (dmut r : _) => r:.getSymbolsInTable (name, protection-> protection, alias syms);
            }
        }
    }

    /**
     * Get all the symbols in the table, and the table of the parent
     * @params:
     *   - name: the name of the symbols to find
     *   - protection: the protection of the symbols to get
     *   - syms: the result set
     *   - callParent: true iif recursevily call parent symbols
     * @returns: in params syms
     */
    prv def getSymbolsInTable (self, name : [c8], protection : Protection, dmut syms : &HashSet!{&Symbol}, callParent : bool = true) {
        let x = self._table.find (name, protection-> protection);
        for i in 0us .. x.len { syms:.insert (x [i]); }
        if (name == self._loc.str ()) { syms:.insert (self); }
        
        if (callParent) {
            match self._referent {
                Ok (r : _) => r.getSymbolsInTable (name, protection-> protection, alias syms);
            }
        }
    }
    
    /**
     * Compute the full name of the symbol
     */
    prot def computeFullName (mut self) -> &Path {
        let mut p = match self._referent {
            Ok (x : _) => {
                x.getPath ()
            }
            _ => { Path::new (""s8) }
        }
        
        p = p.push (self._loc.str ());
        p
    }    
    
}


pub import ymirc::semantic::symbol::aka_;
pub import ymirc::semantic::symbol::class_;
pub import ymirc::semantic::symbol::constructor;
pub import ymirc::semantic::symbol::empty;
pub import ymirc::semantic::symbol::enum_;
pub import ymirc::semantic::symbol::function;
pub import ymirc::semantic::symbol::global;
pub import ymirc::semantic::symbol::impl_;
pub import ymirc::semantic::symbol::macro_::_;
pub import ymirc::semantic::symbol::macro_::constructor;
pub import ymirc::semantic::symbol::macro_::rule;
pub import ymirc::semantic::symbol::module;
pub import ymirc::semantic::symbol::struct_;
pub import ymirc::semantic::symbol::table;
pub import ymirc::semantic::symbol::template;
pub import ymirc::semantic::symbol::trait_;
