mod ymirc::semantic::validator::template::declarator;

import std::collection::map;
import std::collection::vec;
import std::io;

import ymirc::semantic::validator::visitor;
import ymirc::semantic::validator::template::mapper;
import ymirc::semantic::validator::template::rewrite;
import ymirc::semantic::validator::errors;
import ymirc::semantic::symbol::_;
import ymirc::semantic::generator::_;

import ymirc::lexing::word;
import ymirc::syntax::expression::_;
import ymirc::syntax::declaration::_;
import ymirc::errors::_;


/**
 * This class apply a template rewriter on a template value to finalize a template specialization and declare the templates
 * It also stores the template resolution, in order to avoid to declare the same template specialization multiple times
 */
pub class TemplateDeclarator {

    /// The list of template specialization that were already 
    let dmut _declaredKeys = Vec!{(&TemplateRewriter, &TemplateRefValue)}::new ();

    /// The list of template values that were declared
    let dmut _declaredValues = Vec!{dmut &Symbol}::new ();
   
    /**
     * Create an empty template declarator
     */
    pub self () {}


    /**
     * Declare a symbol generated from a template resolution
     * @params: 
     *    - context: the context of the validation
     *    - loc: the location where the template specialization was required
     *    - rewriter: the rewriter that is used to rewrite the template syntax symbol
     *    - value: the symbol of the template to rewrite and declare
     * @returns: the symbol that have been declared
     * @throws:
     *   - &ErrorMsg: if the template rewrite, or declaration fails for some reason
     */
    pub def declare (mut self, dmut context : &Validator, loc : &Word, rewriter : &TemplateRewriter, value : &Value)-> dmut &Symbol
        throws &ErrorMsg
    {
        match value {
            x : &TemplateRefValue => {
                let dmut search = self:.find (x, rewriter);
                match ref search {
                    Ok (dmut s : &Symbol) => return alias s;
                    _ => {
                        let dmut ret = self.declareTemplateRefValue (alias context, loc, rewriter, x);
                        self._declaredKeys:.push ((rewriter, x));
                        self._declaredValues:.push (alias ret);

                        return alias ret;
                    }
                }
            }
            _ => { // What are you passing to the template declaration ??
                __pragma!panic ();
            }
        }
    }

    /**
     * Declare a template value that was never declared before
     * @params: 
     *    - context: the context of the validation
     *    - loc: the location where the template specialization was required
     *    - rewriter: the rewriter that is used to rewrite the template syntax symbol
     *    - value: the symbol of the template to rewrite and declare
     * @returns: the symbol that have been declared
     * @throws:
     *   - &ErrorMsg: if the template rewrite, or declaration fails for some reason
     */
    def declareTemplateRefValue (self, dmut context : &Validator, loc : &Word, rewriter : &TemplateRewriter, value : &TemplateRefValue)-> dmut &Symbol
        throws &ErrorMsg
    {
        context;
        loc;
        rewriter;
        value;
        __pragma!fake_throw (&ErrorMsg);
        __pragma!panic ();
    }
    

    /**
     * Search in the list of old template validation if the given template specilalization was not already declared
     * @params: 
     *    - value: the value to rewrite
     *    - rewriter: the specialization    
     * @returns: the symbol, or Err (), if the template was never seen before
     */
    def find (mut self, value : &TemplateRefValue, rewriter : &TemplateRewriter)-> dmut (&Symbol)? {        
        for it in 0us .. self._declaredKeys.len () {
            if (self._declaredKeys[it]._1.getLoc ().isSame (value.getLoc ()) &&
                self._declaredKeys[it]._0 == rewriter) {
                return (alias (alias self._declaredValues) [it])?;
            }
        }

        return alias (dmut (&Symbol)?)::__err__;
    } catch { // in case of out of vec, but that is not possible
        _ => {
            __pragma!panic ();
        }
    }
    
    
}
