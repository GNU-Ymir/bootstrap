in rewrite;

use std::stream;
use ymirc::syntax::expression::{template::_,
                                macro_::_,
                                literal::_,
                                operator::_};

use ymirc::syntax::{expression, declaration, expression::_, declaration::_};
use ymirc::errors::_;
use ymirc::utils::format;
use ymirc::lexing::word;

use ymirc::semantic::generator::type::syntax::_;
use ymirc::semantic::generator::value::syntax::_;
use ymirc::semantic::validator::template::mapper;

/**
 * This class is used to apply a template mapper to expressions, declarations, etc.
 */
pub record TemplateRewriter {

    // The mapper that will be applied to expressions
    let _mapper : TemplateMapper;

    /**
     * Create an template rewriter 
     * @params: 
     *    - mapper: the mapper that will be used to rewrite the template elements
     */
    pub self (mapper : TemplateMapper)
        with _mapper = mapper
    {}

    /*!
     * ================================================================================
     * ================================================================================
     * =========================           GETTERS            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * @returns: the score of the template specialization
     */
    pub fn getScore (self)-> u32 {
        self._mapper.getScore ()
    }

    /**
     * @returns: the template mapper used by the rewriter
     * */
    pub fn getTemplateMapper (self)-> TemplateMapper {
        self._mapper
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================          COMPARISON          =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * @returns: true if self and other can be used indistinguishably
     */
    pub fn opEquals (self, other : TemplateRewriter)-> bool {
        self._mapper == other._mapper
    }        

    /*!
     * ================================================================================
     * ================================================================================
     * =========================         DECLARATIONS         =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Rewrite a declaration
     * @params:
     *    - d: the declaration to rewrite
     * @returns: the rewritten declaration
     */
    pub fn rewrite (self, d : &Declaration)-> &Declaration
        match d {
            a : &AkaDecl               => { self.rewriteAkaDecl (a) }
            c : &ClassDecl             => { self.rewriteClassDecl (c) }
            c : &CondBlockDecl         => { self.rewriteCondBlockDecl (c) }
            c : &ConstructorDecl       => { self.rewriteConstructorDecl (c) }
            d_ : &BlockDecl            => { self.rewriteBlockDecl (d_) }
            d_ : &DestructorDecl       => { self.rewriteDtorDecl (d_) }
            e : &EnumDecl              => { self.rewriteEnumDecl (e) }
            e : &ExternBlockDecl       => { self.rewriteExternBlockDecl (e) }
            f : &FunctionDecl          => { self.rewriteFunctionDecl (f) }
            g : &GlobalDecl            => { self.rewriteGlobalDecl (g) }
            i : &ImplDecl              => { self.rewriteImplDecl (i) }
            i : &ImportDecl            => { self.rewriteImportDecl (i) }
            m : &MacroRuleDecl         => { self.rewriteMacroRuleDecl (m) }
            m : &ModuleDecl            => { self.rewriteModuleDecl (m) }
            m : &MacroDecl             => { self.rewriteMacroDecl (m) }
            p : &FunctionProtoDecl     => { self.rewriteFuncProtoDecl (p) }
            t : &TemplateDecl          => { self.rewriteTemplateDecl (t) }
            t : &TraitDecl             => { self.rewriteTraitDecl (t) }
            u : &UnitTestDecl          => { self.rewriteUnitTestDecl (u) }
            w : &ExpressionWrapperDecl => { self.rewriteExprWrapperDecl (w) }
            u : &UseDecl               => { self.rewriteUseDecl (u) }
            todo : _                   => {
                std::io::println (todo.__typeinfo__.name);
                panic;
            }
        }


    /**
     * Rewrite an aka declaration
     * @params:
     *    - a: the aka declaration to rewrite
     * @returns: the rewritten declaration
     */
    fn rewriteAkaDecl (self, a : &AkaDecl)-> &Declaration {
        let content = self.rewrite (a.getContent ());
        copy AkaDecl (a.getLoc (), a.getComments (), content, a.getTokDecl ())
    }

    /**
     * Rewrite a class declaration
     * @params:
     *    - c: the class decl to rewrite
     * @returns: the rewritten declaration
     */
    fn rewriteClassDecl (self, c : &ClassDecl)-> &Declaration {
        let ancestor = self.rewrite (c.getAncestor ());
        let content = copy [self.rewrite (i) for i in c.getDeclarations ()];

        copy ClassDecl (c.getLoc (),
                        c.getComments (),
                        content,
                        attrs-> c.getAttributes (),
                        ancestor-> ancestor,
                        isStruct-> c.isStruct (),
                        isRecord-> c.isRecord ())
    }

    /**
     * Rewrite a cond block decl
     * @params:
     *    - c: the conditional block to decl
     * @returns: the rewritten decl
     */
    fn rewriteCondBlockDecl (self, c : &CondBlockDecl)-> &Declaration {
        let decls = copy [self.rewrite (i) for i in c.getDeclarations ()];
        let test = self.rewrite (c.getTest ());
        let else_ = self.rewrite (c.getElse ());

        copy CondBlockDecl (c.getLoc (),
                            c.getComments (),
                            decls-> decls,
                            test-> test,
                            else_-> else_)
    }

    /**
     * Rewrite a constructor declaration
     * @params:
     *    - c: the constructor to rewrite
     * @returns: the rewritten declaration
     */
    fn rewriteConstructorDecl (self, c : &ConstructorDecl)-> &Declaration {
        let proto = self.rewriteFuncProtoDecl (c.getFunctionProtoDecl ());
        let superParams = copy [self.rewrite (i) for i in c.getSuperParams ()];
        let fields = copy [(i._0, self.rewrite (i._1)) for i in c.getFieldConstructors ()];
        let throwers = copy [self.rewrite (i) for i in c.getThrowers ()];

        copy ConstructorDecl (c.getLoc (),
                              c.getComments (),
                              rename-> c.getRename (),
                              proto,
                              superParams-> superParams,
                              superTemplateParams-> self.rewrite (c.getSuperTemplateParams ()),
                              fields-> fields,
                              self.rewrite (c.getBody ()),
                              explicitCstrsCall-> c.getExplicitCstrsCall (),
                              explicitSuperName-> c.getExplicitSuperName (),
                              attributes-> c.getAttributes (),
                              throwerLoc-> c.getThrowerLoc (),
                              throwers-> throwers)
    }


    /**
     * Rewrite a block decl
     * @params:
     *    - b: the block decl to rewrite
     * @returns: the rewritten declaration
     */
    fn rewriteBlockDecl (self, b : &BlockDecl)-> &BlockDecl {
        let content = copy [self.rewrite (i) for i in b.getDeclarations ()];
        copy BlockDecl (b.getLoc (),
                        b.getComments (),
                        content,
                        protection-> b.getProtection ())
    }

    /**
     * Rewrite a function declaration
     * @params:
     *    - f: the function decl to rewrite
     * @returns: the rewritten declaration
     */
    fn rewriteFunctionDecl (self, f : &FunctionDecl)-> &Declaration {
        let proto = self.rewriteFuncProtoDecl (f.getFunctionProto ());
        let body = self.rewrite (f.getBody ());
        let th = copy [self.rewrite (i) for i in f.getThrowers ()];

        copy FunctionDecl (f.getLoc (),
                           f.getComments (),
                           proto,
                           body,
                           attrs-> f.getAttributes (),
                           throwers-> th,
                           throwerLoc-> f.getThrowerLoc (),
                           isOver-> f.isOver ())
    }

    /**
     * Rewrite a destructor declaration
     * @params:
     *    - d: the dtor to rewrite
     * @returns: the rewritten declaration
     */
    fn rewriteDtorDecl (self, d : &DestructorDecl)-> &Declaration {
        let proto = self.rewriteFuncProtoDecl (d.getFunctionProto ());
        let body = self.rewrite (d.getBody ());

        copy DestructorDecl (d.getLoc (), d.getComments (), proto, body)
    }

    /**
     * Rewrite an enumeration decl
     * @params:
     *   - e: the enum to rewrite
     * @returns: the rewritten declaration
     */
    fn rewriteEnumDecl (self, e : &EnumDecl)-> &Declaration {
        let values = copy [self.rewriteVarDecl (i) for i in e.getValues ()];
        let type = self.rewrite (e.getType ());

        copy EnumDecl (e.getLoc (),
                       e.getComments (),
                       type-> type,
                       values-> values,
                       fieldComms-> e.getFieldComms ())
    }

    /**
     * Rewrite an extern block declaration
     * @params:
     *     - e: the extern block to rewrite
     * @returns: the rewritten extern block
     */
    fn rewriteExternBlockDecl (self, e : &ExternBlockDecl)-> &Declaration {
        copy ExternBlockDecl (e.getLoc (),
                              e.getComments (),
                              e.getLanguage (),
                              self.rewrite (e.getNamespace ()),
                              self.rewrite (e.getDeclaration ()))
    }

    /**
     * Rewrite a global var declaration
     * @params:
     *    - e: the global var to rewrite
     * @returns: the rewritten decl
     */
    fn rewriteGlobalDecl (self, e : &GlobalDecl)-> &Declaration {
        copy GlobalDecl (e.getLoc (),
                         e.getComments (),
                         self.rewriteVarDecl (e.getContent ()),
                         e.getAttributes (),
                         isField-> e.isField (),
                         isStatic-> e.isStatic ())
    }

    /**
     * Rewrite a impl declaration
     * @params:
     *    - i: the impl decl to rewrite
     * @returns: the rewritten declaration
     */
    fn rewriteImplDecl (self, i : &ImplDecl)-> &Declaration {
        let content = copy [self.rewrite (d) for d in i.getDeclarations ()];

        copy ImplDecl (i.getLoc (),
                       i.getComments (),
                       self.rewrite (i.getTrait ()),
                       content-> content)
    }

    /**
     * Rewrite an import declaration
     * @params:
     *    - i: the import decl to rewrite
     * @returns: the rewritten import declaration
     */
    fn rewriteImportDecl (self, i : &ImportDecl)-> &Declaration {
        i
    }

    /**
     * Rewrite a use declaration
     * @params:
     *    - i: the use declaration to rewrite
     * @returns: the rewrite use declaration
     * */
    fn rewriteUseDecl (self, u : &UseDecl)-> &Declaration {
        copy UseDecl (u.getLoc (), u.getComments (), self.rewrite (u.getModulePath ()))
    }

    /**
     * Rewrite a macro rule declaration
     * @params:
     *    - m: the macro rule to rewrite
     * @returns: the rewritten declaration
     */
    fn rewriteMacroRuleDecl (self, m : &MacroRuleDecl)-> &Declaration {
        m
    }

    /**
     * Rewrite a macro declaration
     * @params:
     *    - m: the macro decl to rewrite
     * @returns: the rewritten declaration
     */
    fn rewriteMacroDecl (self, m : &MacroDecl)-> &Declaration {
        let decls = copy [self.rewrite (i) for i in m.getDeclarations ()];
        copy MacroDecl (m.getLoc (),
                        m.getComments (),
                        decls)
    }

    /**
     * Rewrite a module declaration
     * @params:
     *    - m: the module declaration to rewrite
     * @returns: the rewritten declaration
     */
    fn rewriteModuleDecl (self, m : &ModuleDecl)-> &Declaration {
        copy ModuleDecl (m.getLoc (),
                         m.getPath (),
                         m.getComments (),
                         self.rewriteBlockDecl (m.getBlockDecl ()),
                         isGlobal-> m.isGlobal ())
    }

    /**
     * Rewrite a function proto decl
     * @params:
     *     - p: the proto decl to rewrite
     * @returns: the rewritten prototype
     */
    fn rewriteFuncProtoDecl (self, p : &FunctionProtoDecl)-> &FunctionProtoDecl {
        let params = copy [self.rewriteVarDecl (i) for i in p.getParameters ()];
        let retType = self.rewrite (p.getRetType ());

        copy FunctionProtoDecl (p.getLoc (),
                                comm-> p.getComments (),
                                params,
                                retType,
                                isVariadic-> p.isVariadic (),
                                forLambda-> p.isForLambda ())
    }

    /**
     * Rewrite a template declaration
     * @params:
     *    - t: the template declaration to rewrite
     * @returns: the rewritten declaration
     */
    fn rewriteTemplateDecl (self, t : &TemplateDecl)-> &Declaration {
        let params = copy [self.rewrite (p) for p in t.getParameters ()];

        copy TemplateDecl (t.getLoc (),
                           t.getComments (),
                           params,
                           test-> self.rewrite (t.getTest ()),
                           content-> self.rewrite (t.getContent ()))
    }

    /**
     * Rewrite a trait declaration
     * @params:
     *    - t: the trait declaration to rewrite
     * @returns: the rewritten declaration
     */
    fn rewriteTraitDecl (self, t : &TraitDecl)-> &Declaration {
        let decls = copy [self.rewrite (d) for d in t.getDeclarations ()];
        copy TraitDecl (t.getLoc (),
                        t.getComments (),
                        decls)
    }

    /**
     * Rewrite a unit test declaration
     * @params:
     *    - u: the unit test to rewrite
     * @returns: the rewritten declaration
     */
    fn rewriteUnitTestDecl (self, u : &UnitTestDecl)-> &Declaration {
        copy UnitTestDecl (u.getLoc (),
                           u.getComments (),
                           self.rewrite (u.getBody ()))
    }

    /**
     * Rewrite an expression wrapper declaration
     * @params:
     *    - e: the expression wrapper
     * @returns: the rewritten declaration
     */
    fn rewriteExprWrapperDecl (self, e : &ExpressionWrapperDecl)-> &Declaration {
        copy ExpressionWrapperDecl (e.getLoc (),
                                    e.getComments (),
                                    self.rewrite (e.getContent ()))
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================         EXPRESSIONS          =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Rewrite the expression using the mapper of the rewriter
     * @params:
     *    - expr: the expression to rewrite
     * @returns: the rewritten expression
     */
    pub fn rewrite (self, expr : &Expression)-> &Expression {
        match expr {
            a : &AssertExpr              => { self.rewriteAssert (a) }
            a : &AtomicExpr              => { self.rewriteAtomic (a) }
            b : &BinaryExpr              => { self.rewriteBinary (b) }
            b : &BlockExpr               => { self.rewriteBlock (b) }
            b : &BreakExpr               => { self.rewriteBreak (b) }
            c : &CastExpr                => { self.rewriteCast (c) }
            c : &ConditionalExpr         => { self.rewriteConditional (c) }
            d : &DecoratedExpr           => { self.rewriteDecorated (d) }
            _ : &EmptyExpression         => { expr }
            f : &ForLoopExpr             => { self.rewriteForLoop (f) }
            f : &FunctionPtrTypeExpr     => { self.rewriteFuncPtrType (f) }
            i : &IntrinsicExpr           => { self.rewriteIntrinsic (i) }
            l : &LambdaValueExpr         => { self.rewriteLambda (l) }
            l : &ListExpr                => { self.rewriteList (l) }
            l : &ListMapExpr             => { self.rewriteListMap (l) }
            f : &FutureTypeExpr          => { self.rewriteFuture (f) }
            r : &RangeTypeExpr           => { self.rewriteRangeType (r) }
            l : &LiteralExpr             => { self.rewriteLiteral (l) }
            m : &MacroCallExpr           => { self.rewriteMacroCall (m) }
            _ : &MacroRuleExpression     => { expr }
            m : &MatcherExpr             => { self.rewriteMatcher (m) }
            m : &MultOperatorExpr        => { self.rewriteMultOp (m) }
            n : &NamedExpr               => { self.rewrittenamed (n) }
            p : &PathExpr                => { self.rewritePath (p) }
            p : &PragmaExpr              => { self.rewritePragma (p) }
            r : &ReturnExpr              => { self.rewriteReturn (r) }
            u : &UnaryExpr               => { self.rewriteUnary (u) }
            s : &ScopeGuardExpr          => { self.rewriteScopeGuard (s) }
            s : &SetExpr                 => { self.rewriteSet (s) }
            s : &SliceAllocatorExpr      => { self.rewriteSliceAlloc (s) }
            t : &TemplateCallExpr        => { self.rewriteTemplateCall (t) }
            t : &TemplateCheckerExpr     => { self.rewriteTemplateChecker (t) }
            t : &TemplateOfVarExpr       => { self.rewriteTemplateOfVar (t) }
            t : &TemplateAndExpr         => { self.rewriteTemplateAndVar (t) }
            t : &TemplateVariadicVarExpr => { self.rewriteTemplateVariadicVar (t) }
            t : &TemplateVarExpr         => { self.rewriteTemplateVar (t) }
            t : &ThrowExpr               => { self.rewriteThrow (t) }
            t : &TryExpr                 => { self.rewriteTry (t) }
            v : &VarDeclExpr             => { self.rewriteVarDecl (v) }
            w : &WhileLoopExpr           => { self.rewriteWhileLoop (w) }
            w : &ValueWrapperExpr        => { return w; } // already rewritten
            t : &TypeWrapperExpr         => { return t; } // same, rewritten earlier
            u : &UnsafeExpr              => { self.rewriteUnsafe (u) }
            p : &PanicExpr               => { return p; }
            p : &PatternVarDeclExpr      => { self.rewritePatternVarDecl (p) }
            o : &OptionMatcherExpr       => { self.rewriteOptionMatch (o) }
            l : &ListMatcherExpr         => { self.rewriteListMatch (l) }
            s : &SliceForAllocatorExpr   => { self.rewriteSliceFor (s) }
            todo : _ => {
                std::io::println (todo.__typeinfo__.name);
                panic;
            }
        }
    }

    /**
     * Rewrite an assert expression
     * @params:
     *    - a: the assert expression
     * @returns: the rewritten expression
     */
    fn rewriteAssert (self, a : &AssertExpr)-> &Expression {
        copy AssertExpr (a.getLoc (),
                         self.rewrite (a.getTest ()),
                         self.rewrite (a.getMessage ()))
    }

    /**
     * Rewrite an atomic expression
     * @params:
     *    - a: the atomic expression
     * @returns: the rewritten expression
     */
    fn rewriteAtomic (self, a : &AtomicExpr)-> &Expression {
        copy AtomicExpr (a.getLoc (),
                         monitor-> self.rewrite (a.getMonitor ()),
                         self.rewrite (a.getValue ()))
    }

    /**
     * Rewrite a block expr
     * @params:
     *    - b: the block expression to rewrite
     * @returns: the rewritten expression
     */
    fn rewriteBlock (self, b : &BlockExpr)-> &Expression {
        let exprs  = copy [self.rewrite (i) for i in b.getExpressions ()];
        let scopes = copy [self.rewriteScopeGuard (i) for i in b.getGuards ()];
        let module  = self.rewrite (b.getModule ());
        let catcher = self.rewrite (b.getCatcher ());

        copy BlockExpr (b.getLoc (),
                        b.getEndLocation (),
                        module-> module,
                        content-> exprs,
                        catcher-> catcher,
                        guards-> scopes)
    }

    /**
     * Rewrite a break expression
     * @params:
     *    - b: the break expr to rewrite
     * @returns: the rewritten expression
     */
    fn rewriteBreak (self, b : &BreakExpr)-> &Expression {
        copy BreakExpr (b.getLoc (),
                        self.rewrite (b.getValue ()))
    }

    /**
     * Rewrite a cast expression
     * @params:
     *    - c: the cast expr to rewrite
     * @returns: the rewritten expression
     */
    fn rewriteCast (self, c : &CastExpr)-> &Expression {
        copy CastExpr (c.getLoc (),
                       self.rewrite (c.getType ()),
                       self.rewrite (c.getValue ()))
    }

    /**
     * Rewrite a condtional expression
     * @params:
     *    - c: the conditional expr to rewrite
     * @returns: the rewritten expression
     */
    fn rewriteConditional (self, c : &ConditionalExpr)-> &Expression {
        copy ConditionalExpr (c.getLoc (),
                              test-> self.rewrite (c.getTest ()),
                              content-> self.rewrite (c.getContent ()),
                              else_-> self.rewrite (c.getElse ()),
                              isLet-> c.isLet (),
                              guard-> self.rewrite (c.getGuard ()))
    }

    /**
     * Rewrite a decorated expression
     * @params:
     *    - d: the decorated expr to rewrite
     * @returns: the rewritten expression
     */
    fn rewriteDecorated (self, d : &DecoratedExpr)-> &Expression {
        let x = self.rewrite (d.getContent ());
        if let list : &TypeListWrapperExpr = x {
            let params = copy [copy DecoratedExpr (d.getLoc (),
                                                   content-> copy TypeWrapperExpr (i.getLoc (), i),
                                                   deco-> d.getDecorator ()) for i in list.getTypes ()];

            copy ListExpr (d.getLoc (),
                           d.getLoc (),
                           params,
                           isArray-> false)
        } else {
            copy DecoratedExpr (d.getLoc (),
                                content-> x,
                                deco-> d.getDecorator ())
        }
    }

    /**
     * Rewrite a for loop expr
     * @params:
     *    - f: the for loop to rewrite
     * @returns: the rewritten expression
     */
    fn rewriteForLoop (self, f : &ForLoopExpr)-> &Expression {
        let vars = copy [self.rewrite (i) for i in f.getVariables ()];
        copy ForLoopExpr (f.getLoc (),
                          vars,
                          self.rewrite (f.getValue ()),
                          self.rewrite (f.getBlock ()))
    }

    /**
     * Rewrite a function pointer type expr
     * @params:
     *    - f: to function ptr type to rewrite
     * @returns: the rewritten expression
     */
    pub fn rewriteFuncPtrType (self, f : &FunctionPtrTypeExpr)-> &FunctionPtrTypeExpr {
        let mut params : [mut &VarDeclExpr] = [];
        for v in f.getParameters () {
            let x = self.rewrite (v.getType ());
            if let list : &TypeListWrapperExpr = x {
                let inners = copy [copy VarDeclExpr (v.getLoc (), v.getName (),
                                                     value-> self.rewrite (v.getValue ()),
                                                     type-> copy TypeWrapperExpr (i.getLoc (), i),
                                                     isLazyOrRef-> v.getLazyOrRefLocation (),
                                                     isMutOrDmut-> v.getMutOrDmutLocation ())
                                   for i in list.getTypes ()];
                params ~= inners;
            } else {
                params ~= [copy VarDeclExpr (v.getLoc (), v.getName (),
                                             value-> self.rewrite (v.getValue ()),
                                             type-> x,
                                             isLazyOrRef-> v.getLazyOrRefLocation (),
                                             isMutOrDmut-> v.getMutOrDmutLocation ())];
            }
        }

        copy FunctionPtrTypeExpr (f.getLoc (),
                                  params,
                                  self.rewrite (f.getReturn ()))
    }

    /**
     * Rewrite an intrinsic expr
     * @params:
     *    - i: the intrinsic expr to rewrite
     * @returns: the rewritten expression
     */
    fn rewriteIntrinsic (self, i : &IntrinsicExpr)-> &Expression {
        copy IntrinsicExpr (i.getLoc (), i.getType (), self.rewrite (i.getContent ()))
    }

    /**
     * Rewrite a lambda value expr
     * @params:
     *    - l: the lambda value expr
     * @returns: the rewritten expression
     */
    fn rewriteLambda (self, l : &LambdaValueExpr)-> &Expression {
        copy LambdaValueExpr (l.getLoc (),
                              self.rewriteFuncProtoDecl (l.getFunctionProtoDecl ()),
                              self.rewrite (l.getValue ()))
    }

    /**
     * Rewrite a list value expr
     * @params:
     *    - l: the list value expr
     * @returns: the rewritten expression
     */
    fn rewriteList (self, l : &ListExpr)-> &Expression {
        let mut params : [mut &Expression] = [];
        for it in l.getParameters () {
            let x = self.rewrite (it);
            if let list : &TypeListWrapperExpr = x {
                let inners = copy [copy TypeWrapperExpr (i.getLoc (), i) for i in list.getTypes ()];
                params ~= inners;
            } else {
                params ~= [x];
            }
        }

        copy ListExpr (l.getLoc (),
                       l.getEndLocation (),
                       params,
                       isArray-> l.isArray ())
    }

    /**
     * Rewrite a list map expression
     * @params:
     *    - l: the list map value expr
     * @returns: the rewritten expression
     * */
    fn rewriteListMap (self, l : &ListMapExpr)-> &Expression {
        let keys = copy [self.rewrite (i) for i in l.getKeys ()];
        let values = copy [self.rewrite (i) for i in l.getValues ()];

        copy ListMapExpr (l.getLoc (),
                          end-> l.getEndLocation (),
                          keys,
                          values)
    }

    /**
     * Rewrite a future type expression
     * @params:
     *    - f: the future type to rewrite
     * @returns: the rewritten expression
     * */
    fn rewriteFuture (self, f : &FutureTypeExpr)-> &Expression {
        copy FutureTypeExpr (f.getLoc (), self.rewrite (f.getReturnType ()))
    }

    /**
     * Rewrite a range type expr
     * @params:
     *    - r: the range type to rewrite
     * @returns: the rewritten expression
     */
    fn rewriteRangeType (self, r : &RangeTypeExpr)-> &Expression {
        copy RangeTypeExpr (r.getLoc (), self.rewrite (r.getType ()))
    }


    /**
     * Rewrite a literal expression
     * @params:
     *    - l: the literal expr to rewrite
     * @returns: the rewritten expr
     */
    fn rewriteLiteral (self, l : &LiteralExpr)-> &Expression {
        match l {
            v : &VarExpr => {
                match self._mapper.getMapping () [v.getLoc ().str] {
                    Ok (x : &ValueWrapperExpr)       => { return copy ValueWrapperExpr (l.getLoc (), x.getValue ()); }
                    Ok (x : &TypeWrapperExpr)        => { return copy TypeWrapperExpr (l.getLoc (), x.getType (), asIs-> x.asIs ()); }
                    Ok (x : &TypeListWrapperExpr)    => { return copy TypeListWrapperExpr (l.getLoc (), x.getTypes ()); }
                    Ok (x : &LambdaValueWrapperExpr) => { return copy LambdaValueWrapperExpr (l.getLoc (), x.getName (), x.getType (), x.getValue ()); }
                    Ok (x : &Expression)             => { x }
                    _                                => { l }
                }
            }
            _ => { l }
        }
    }

    /**
     * Rewrite a macro call expression
     * @params:
     *    - l: the macro call expr to rewrite
     * @returns: the rewritten expr
     */
    fn rewriteMacroCall (self, m : &MacroCallExpr)-> &Expression {
        copy MacroCallExpr (m.getLoc (),
                            m.getEndLocation (),
                            self.rewrite (m.getMacro ()),
                            m.getContent ())

    }

    /**
     * Rewrite a matcher expression
     * @params:
     *    - m: the matcher expression to rewrite
     * @returns: the rewritten expr
     */
    fn rewriteMatcher (self, m : &MatcherExpr)-> &Expression {
        let matchers = copy [(self.rewrite (it._0), self.rewrite (it._1), self.rewrite (it._2)) for it in m.getMatchers ()];
        copy MatcherExpr (m.getLoc (),
                          self.rewrite (m.getContent ()),
                          matchers,
                          isCatcher-> m.isCatcher ())
    }

    /**
     * Rewrite a named expr
     * @params:
     *    - n: the named expression to rewrite
     * @returns: the rewritten expression
     */
    fn rewrittenamed (self, n : &NamedExpr)-> &Expression {
        copy NamedExpr (n.getLoc (),
                        self.rewrite (n.getContent ()))
    }

    /**
     * Rewrite a binary expression
     * @params:
     *    - b: the binary expr to rewrite
     * @returns: the rewritten expr
     */
    fn rewriteBinary (self, b : &BinaryExpr)-> &Expression {
        copy BinaryExpr (b.getLoc (),
                         self.rewrite (b.getLeft ()),
                         self.rewrite (b.getRight ()))
    }

    /**
     * Rewrite a mult op expr
     * @params:
     *    -m: the mult operation to rewrite
     * @returns: the rewritten expr
     */
    fn rewriteMultOp (self, m : &MultOperatorExpr)-> &Expression {
        let rights = copy [self.rewrite (it) for it in m.getRights ()];
        copy MultOperatorExpr (m.getLoc (), m.getEndLocation (),
                               self.rewrite (m.getLeft ()),
                               rights,
                               canBeDotCall-> m.canBeDotCall ())
    }

    /**
     * Rewrite a mult op expr
     * @params:
     *    -m: the mult operation to rewrite
     * @returns: the rewritten expr
     */
    fn rewritePath (self, p : &PathExpr)-> &Expression {
        p
    }

    /**
     * Rewrite an unary expr
     * @params:
     *    - u: the unary expr to rewrite
     * @returns: the rewritten expr
     */
    fn rewriteUnary (self, u : &UnaryExpr)-> &Expression {
        copy UnaryExpr (u.getLoc (),
                        self.rewrite (u.getOperand ()))
    }

    /**
     * Rewrite a pragma exprs
     * @params:
     *    - p: the pragma to rewrite
     * @returns: the rewritten expr
     */
    fn rewritePragma (self, p : &PragmaExpr)-> &Expression {
        let params = copy [self.rewrite (it) for it in p.getParameters ()];
        copy PragmaExpr (p.getLoc (), params)
    }

    /**
     * Rewrite a return expression
     * @params:
     *    - r: the return expression to rewrite
     * @returns: the rewritten expression
     */
    fn rewriteReturn (self, r : &ReturnExpr)-> &Expression {
        copy ReturnExpr (r.getLoc (),
                         self.rewrite (r.getValue ()))
    }

    /**
     * Rewrite a scope guard expression
     * @params:
     *    - sc: the scope guard to rewrite
     * @returns: the rewritten expression
     */
    fn rewriteScopeGuard (self, sc : &ScopeGuardExpr)-> &ScopeGuardExpr {
        copy ScopeGuardExpr (sc.getLoc (),
                             self.rewrite (sc.getContent ()),
                             sc.getKind ())
    }

    /**
     * Rewrite a set expression
     * @params:
     *    - sc: the set expr to rewrite
     * @returns: the rewritten expression
     */
    fn rewriteSet (self, s : &SetExpr)-> &Expression {
        let content = copy [self.rewrite (it) for it in s.getContent ()];
        copy SetExpr (s.getLoc (), content)
    }

    /**
     * Rewrite a slice allocator expression
     * @params:
     *    - s: the slice allocator
     * @returns: the rewritten expression
     */
    fn rewriteSliceAlloc (self, s : &SliceAllocatorExpr)-> &Expression {
        copy SliceAllocatorExpr (s.getLoc (),
                                 self.rewrite (s.getValue ()),
                                 self.rewrite (s.getSize ()))
    }

    /**
     * Rewrite a template call expr
     * @params:
     *    - t: the template call expr to rewrite
     * @returns: the rewritten expr
     */
    fn rewriteTemplateCall (self, t : &TemplateCallExpr)-> &Expression {
        if (t.getLeft () of VarExpr) {
            if let Ok (x) = self._mapper.getMapping () [t.getLeft ().getLoc ().str] {
                return x;
            }
        }

        let mut rights : [mut &Expression] = [];
        for it in t.getRights () {
            let x = self.rewrite (it);
            if let list : &TypeListWrapperExpr = x {
                let inners = copy [copy TypeWrapperExpr (i.getLoc (), i) for i in list.getTypes ()];
                rights ~= inners;
            } else {
                rights ~= [x];
            }
        }

        copy TemplateCallExpr (t.getLoc (),
                               self.rewrite (t.getLeft ()),
                               rights)
    }

    /**
     * Rewrite a template checker expr
     * @params:
     *    - t: the template checker to rewrite
     * @returns: the rewritten expression
     */
    fn rewriteTemplateChecker (self, t : &TemplateCheckerExpr)-> &Expression {
        let params = copy [self.rewrite (it) for it in t.getParameters ()];
        let mut rules : [mut &Expression] = [];
        for it in t.getRules () {
            let x = self.rewrite (it);
            if let list : &TypeListWrapperExpr = x {
                let inners = copy [copy TypeWrapperExpr (i.getLoc (), i) for i in list.getTypes ()];
                rules ~= inners;
            } else {
                rules ~= [x];
            }
        }

        copy TemplateCheckerExpr (t.getLoc (),
                                  params,
                                  rules)
    }

    /**
     * Rewrite a template of var
     * @params:
     *    - o: the template of var to rewrite
     * @returns: the rewritten expression
     */
    fn rewriteTemplateOfVar (self, o : &TemplateOfVarExpr)-> &TemplateOfVarExpr {
        copy TemplateOfVarExpr (o.getLoc (),
                                self.rewrite (o.getSpecialization ()),
                                o.getKind ())
    }

    /**
     * Rewrite a template and var
     * @params:
     *    - o: the template and var to rewrite
     * @returns: the rewritten expression
     */
    fn rewriteTemplateAndVar (self, o : &TemplateAndExpr)-> &TemplateAndExpr {
        let ret = copy [self.rewriteTemplateOfVar (i) for i in o.getSpecializations ()];
        copy TemplateAndExpr (o.getLoc (), ret)
    }

    /**
     * Rewrite a template variadic var
     * @params:
     *    - v: the template variadic var to rewrite
     * @returns: the rewritten var
     */
    fn rewriteTemplateVariadicVar (self, v : &TemplateVariadicVarExpr)-> &Expression {
        if let Ok (x) = self._mapper.getMapping ()[v.getLoc ().str] {
            x
        } else {
            v
        }
    }

    /**
     * Rewrite a template var
     * @params:
     *    - v: the template variadic var to rewrite
     * @returns: the rewritten var
     */
    fn rewriteTemplateVar (self, v : &TemplateVarExpr)-> &Expression {
        if let Ok (x) = self._mapper.getMapping ()[v.getLoc ().str] {
            x
        } else {
            v
        }
    }

    /**
     * Rewrite a throw expression
     * @params:
     *   - t: the throw expr to rewrite
     * @returns: the rewritten expr
     */
    fn rewriteThrow (self, t : &ThrowExpr)-> &Expression {
        copy ThrowExpr (t.getLoc (), self.rewrite (t.getValue ()))
    }

    /**
     * Rewrite a try expression
     * @params:
     *    - t: the try expr to rewrite
     * @returns: the rewritten expr
     */
    fn rewriteTry (self, t : &TryExpr)-> &Expression {
        copy TryExpr (t.getLoc (), self.rewrite (t.getValue ()))
    }


    /**
     * Rewrite a var decl expression
     * @params:
     *    - v: the var decl expr to rewrite
     * @returns: the rewritten expression
     */
    pub fn rewriteVarDecl (self, v : &VarDeclExpr)-> &VarDeclExpr {
        copy VarDeclExpr (v.getLoc (), v.getName (),
                          self.rewrite (v.getValue ()),
                          self.rewrite (v.getType ()),
                          isLazyOrRef-> v.getLazyOrRefLocation (),
                          isMutOrDmut-> v.getMutOrDmutLocation ())
    }

    /**
     * Rewrite a pattern var declaration
     * @params:
     *    - p: the var decl expr to rewrite
     * @returns: the rewritten expression
     * */
    fn rewritePatternVarDecl (self, p : &PatternVarDeclExpr)-> &PatternVarDeclExpr {
        copy PatternVarDeclExpr (p.getLoc (),
                                 self.rewrite (p.getPattern ()),
                                 self.rewrite (p.getValue ()))
    }

    /**
     * Rewrite an option matcher
     * @params:
     *    - o: the option matcher to rewrite
     * @returns: the rewritten expr
     * */
    fn rewriteOptionMatch (self, o : &OptionMatcherExpr)-> &OptionMatcherExpr {
        copy OptionMatcherExpr (o.getLoc (),
                                self.rewrite (o.getInner ()))
    }


    /**
     * Rewrite a list matcher
     * @params:
     *    - l: the list matcher to rewrite
     * @returns: the rewritten expr
     * */
    fn rewriteListMatch (self, l : &ListMatcherExpr)-> &ListMatcherExpr {
        let params = copy [self.rewrite (i) for i in l.getParameters ()];
        copy ListMatcherExpr (l.getLoc (), l.getEndLoc (),
                              params,
                              l.isVariadic ())
    }

    /**
     * Rewrite a slice for allocator
     * @params:
     *    - sl: the slice for to rewrite
     *  @returns: the rewritten expr
     * */
    fn rewriteSliceFor (self, sl : &SliceForAllocatorExpr)-> &SliceForAllocatorExpr {
        let val = self.rewrite (sl.getValue ());
        let vars = copy [self.rewrite (i) for i in sl.getVariables ()];
        let iter = self.rewrite (sl.getIter ());

        copy SliceForAllocatorExpr (sl.getLoc (),
                                    sl.getForLoc (),
                                    val,
                                    vars,
                                    iter,
                                    sl.isTuple ())
    }

    /**
     * Rewrite a while loop expression
     * @params:
     *    - w: the while loop expression to rewrite
     * @returns: the rewritten expression
     */
    fn rewriteWhileLoop (self, w : &WhileLoopExpr)-> &Expression {
        copy WhileLoopExpr (w.getLoc (),
                            test-> self.rewrite (w.getTest ()),
                            self.rewrite (w.getContent ()),
                            isDo-> w.isDo ())
    }

    /**
     * Rewrite an unsafe expression
     * @params:
     *    - u: the unsafe expression to rewrite
     * @returns: the rewritten expression
     * */
    fn rewriteUnsafe (self, u : &UnsafeExpr)-> &Expression {
        copy UnsafeExpr (u.getLoc (), self.rewrite (u.getValue ()))
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================            COMMON            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Create a new template parameter list from an old list and a pre template specialization
     * @params:
     *    - syntaxTemplate: the old template parameters
     *    - mapper: the template specialization
     * @returns: The transformed list
     */
    pub fn replaceSyntaxTempl (self, syntaxTemplate : [&Expression])-> [&Expression] {
        let mut results : [mut &Expression] = [];
        // THe idea is simple, we go through the list, and if the template was already validated, we reject it
        for it in syntaxTemplate match it {
            v : &VarExpr => {
                if !self._mapper.hasValidated (v.getLoc ().str) results ~= [v];
            }
            v : &TemplateOfVarExpr => {
                if !self._mapper.hasValidated (v.getLoc ().str) {
                    results ~= [self.rewriteTemplateOfVar (v)];
                }
            }
            v : &TemplateAndExpr => {
                if !self._mapper.hasValidated (v.getLoc ().str) {
                    results ~= [self.rewriteTemplateAndVar (v)];
                }
            }
            v : &TemplateVariadicVarExpr => {
                if !self._mapper.hasValidated (v.getLoc ().str) results ~= [v];
            }
            v : &TemplateVarExpr => { // different from VarExpr, as it has a value
                if !self._mapper.hasValidated (v.getLoc ().str) results ~= [v];
            }
            v : &VarDeclExpr => {
                if !self._mapper.hasValidated (v.getLoc ().str) {
                    results ~= [self.rewriteVarDecl (v)];
                }
            }
            _ => { // constant values are stored differently
                if !self._mapper.hasValidated (format ("%[%,%]", it.getLoc ().str, it.getLoc ().line, it.getLoc ().col)) results ~= [it];
            }
        }

        results
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================             MISC             =========================
     * ================================================================================
     * ================================================================================
     */

    impl Streamable;
    impl Formattable {
        pub over format (self, dmut stream : &Formatter) {
            stream:.write (self._mapper);
        }

    }

    /**
     * @returns: the rewriter into a string (with less information that with format)
     */
    pub fn simpleFormat (self)-> [c8] {
        self._mapper.simpleFormat ()
    }

}
