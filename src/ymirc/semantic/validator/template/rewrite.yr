mod ymirc::semantic::validator::template::rewrite;

import std::collection::map;
import std::collection::vec;
import std::io;

import ymirc::syntax::expression::_;
import ymirc::syntax::declaration::_;
import ymirc::errors::_;
import ymirc::utils::format;
import ymirc::lexing::word;

import ymirc::semantic::validator::template::mapper;

/**
 * This class is used to apply a template mapper to expressions, declarations, etc.
 */
pub class TemplateRewriter {

    /// The mapper that will be applied to expressions
    let _mapper : &TemplateMapper;
    
    /**
     * Create an template rewriter 
     * @params: 
     *    - mapper: the mapper that will be used to rewrite the template elements
     */
    pub self (mapper : &TemplateMapper)
        with _mapper = mapper
    {}

    /**
     * ================================================================================
     * ================================================================================
     * =========================           GETTERS            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * @returns: the score of the template specialization
     */
    pub def getScore (self)-> u32 {
        self._mapper.getScore ()
    }
    

    /**
     * ================================================================================
     * ================================================================================
     * =========================          COMPARISON          =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * @returns: true if self and other can be used indistinguishably
     */
    pub def opEquals (self, other : &TemplateRewriter)-> bool {
        other;
        false
    }        
    
    /**
     * ================================================================================
     * ================================================================================
     * =========================           SYMBOLS            =========================
     * ================================================================================
     * ================================================================================
     */

    
    /**
     * ================================================================================
     * ================================================================================
     * =========================         DECLARATIONS         =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Rewrite a declaration
     * @params: 
     *    - d: the declaration to rewrite
     * @returns: the rewritten declaration
     */
    pub def rewrite (self, d : &Declaration)-> &Declaration {
        match d {
            todo : _ => {
                println (todo);
                __pragma!panic ();
            }
        }
    }

    /**
     * Rewrite a function proto decl
     * @params: 
     *     - p: the proto decl to rewrite
     * @returns: the rewritten prototype
     */
    def rewriteFuncProtoDecl (self, p : &FunctionProtoDecl)-> &FunctionProtoDecl {
        p;
        __pragma!panic ();
    }
    

    /**
     * ================================================================================
     * ================================================================================
     * =========================         EXPRESSIONS          =========================
     * ================================================================================
     * ================================================================================
     */    
    
    /**
     * Rewrite the expression using the mapper of the rewriter
     * @params: 
     *    - expr: the expression to rewrite
     * @returns: the rewritten expression
     */
    pub def rewrite (self, expr : &Expression)-> &Expression {
        match expr {
            a : &AssertExpr => { self.rewriteAssert (a) }
            a : &AtomicExpr => { self.rewriteAtomic (a) }
            b : &BinaryExpr => { self.rewriteBinary (b) }
            b : &BlockExpr  => { self.rewriteBlock (b) }
            b : &BreakExpr  => { self.rewriteBreak (b) }
            c : &CastExpr   => { self.rewriteCast (c) }
            c : &ConditionalExpr => { self.rewriteConditional (c) }
            d : &DecoratedExpr => { self.rewriteDecorated (d) }
            d : &DestructVarDeclExpr => { self.rewriteDestructVarDecl (d) }
            _ : &EmptyExpression => { expr }
            f : &ForLoopExpr => { self.rewriteForLoop (f) }
            f : &FunctionPtrTypeExpr => { self.rewriteFuncPtrType (f) }
            i : &IntrinsicExpr => { self.rewriteIntrinsic (i) }
            l : &LambdaValueExpr => { self.rewriteLambda (l) }
            l : &ListExpr => { self.rewriteList (l) }
            l : &LiteralExpr => { self.rewriteLiteral (l) }
            m : &MacroCallExpr => { self.rewriteMacroCall (m) }
            _ : &MacroRuleExpression => { expr }
            m : &MatcherExpr => { self.rewriteMatcher (m) }
            m : &MultOperatorExpr => { self.rewriteMultOp (m) }            
            n : &NamedExpr => { self.rewriteNamed (n) }
            p : &PathExpr => { self.rewritePath (p) }            
            p : &PragmaExpr => { self.rewritePragma (p) }
            r : &ReturnExpr => { self.rewriteReturn (r) }
            u : &UnaryExpr => { self.rewriteUnary (u) }
            s : &ScopeGuardExpr => { cast!{&Expression} (self.rewriteScopeGuard (s)) }
            s : &SetExpr => { self.rewriteSet (s) }
            s : &SliceAllocatorExpr => { self.rewriteSliceAlloc (s) }
            t : &TemplateCallExpr => { self.rewriteTemplateCall (t) }
            t : &TemplateCheckerExpr =>  { self.rewriteTemplateChecker (t) }
            t : &TemplateOfVarExpr => { self.rewriteTemplateOfVar (t) }
            t : &TemplateVariadicVarExpr => { self.rewriteTemplateVariadicVar (t) }
            t : &TemplateVarExpr => { self.rewriteTemplateVar (t) }
            t : &ThrowExpr => { self.rewriteThrow (t) }
            t : &TryExpr => { self.rewriteTry (t) }
            v : &VarDeclExpr => { self.rewriteVarDecl (v) }
            w : &WhileLoopExpr => { self.rewriteWhileLoop (w) }
            d : &DisposeScopeExpr => { self.rewriteDisposeScope (d) }
            todo : _ => {
                println (todo);
                __pragma!panic ();
            }
        }
    }

    /**
     * Rewrite an assert expression
     * @params: 
     *    - a: the assert expression
     * @returns: the rewritten expression
     */
    def rewriteAssert (self, a : &AssertExpr)-> &Expression {
        AssertExpr::new (a.getLoc (),
                         self.rewrite (a.getTest ()),
                         self.rewrite (a.getMessage ()))
    }
    

    /**
     * Rewrite an atomic expression
     * @params:
     *    - a: the atomic expression
     * @returns: the rewritten expression
     */
    def rewriteAtomic (self, a : &AtomicExpr)-> &Expression {
        AtomicExpr::new (a.getLoc (),
                         monitor-> self.rewrite (a.getMonitor ()),
                         self.rewrite (a.getValue ()))
    }
    
    /**
     * Rewrite a block expr
     * @params:
     *    - b: the block expression to rewrite
     * @returns: the rewritten expression
     */
    def rewriteBlock (self, b : &BlockExpr)-> &Expression {
        let dmut scopes = Vec!{&ScopeGuardExpr}::new ();
        let dmut exprs = Vec!{&Expression}::new ();
        let module = self.rewrite (b.getModule ());
        let catcher = self.rewrite (b.getCatcher ());
        for it in b.getExpressions () { exprs:.push (self.rewrite (it)); }
        for it in b.getGuards () { scopes:.push (self.rewriteScopeGuard (it)); }

        return BlockExpr::new (b.getLoc (), b.getEndLocation (), module-> module, content-> exprs[], catcher-> catcher, guards-> scopes[]);
    }
    

    /**
     * Rewrite a break expression
     * @params:
     *    - b: the break expr to rewritte
     * @returns: the rewritten expression
     */
    def rewriteBreak (self, b : &BreakExpr)-> &Expression {
        BreakExpr::new (b.getLoc (),
                        self.rewrite (b.getValue ()))
    }

    /**
     * Rewrite a cast expression
     * @params:
     *    - c: the cast expr to rewritte
     * @returns: the rewritten expression
     */
    def rewriteCast (self, c : &CastExpr)-> &Expression {
        CastExpr::new (c.getLoc (),
                       self.rewrite (c.getType ()),
                       self.rewrite (c.getValue ()))                       
    }

    /**
     * Rewrite a condtional expression
     * @params:
     *    - c: the conditional expr to rewritte
     * @returns: the rewritten expression
     */
    def rewriteConditional (self, c : &ConditionalExpr)-> &Expression {
        ConditionalExpr::new (c.getLoc (),
                              test-> self.rewrite (c.getTest ()),
                              content-> self.rewrite (c.getContent ()),
                              else_-> self.rewrite (c.getElse ()))
    }

    /**
     * Rewrite a decorated expression
     * @params:
     *    - d: the decorated expr to rewritte
     * @returns: the rewritten expression
     */
    def rewriteDecorated (self, d : &DecoratedExpr)-> &Expression {
        DecoratedExpr::new (d.getLoc (),
                            content-> self.rewrite (d.getContent ()),
                            decorators-> d.getDecorators ())
    }

    /**
     * Rewrite a destructuring var declaration
     * @params:
     *    - d: the destructuring var decl to rewritte
     * @returns: the rewritten expression
     */
    def rewriteDestructVarDecl (self, d : &DestructVarDeclExpr)-> &Expression {
        let dmut params = Vec!{&Expression}::new ();
        for it in d.getParameters () {
            params:.push (self.rewrite (it));
        }
        
        DestructVarDeclExpr::new (d.getLoc (),
                                  params[],
                                  self.rewrite (d.getValue ()),
                                  isVariadic-> d.isVariadic ())
    }

    /**
     * Rewrite a for loop expr
     * @params:
     *    - f: the for loop to rewritte
     * @returns: the rewritten expression
     */
    def rewriteForLoop (self, f : &ForLoopExpr)-> &Expression {
        let dmut vars = Vec!{&Expression}::new ();
        for it in f.getVariables () { vars:.push (self.rewrite (it)) }

        ForLoopExpr::new (f.getLoc (),
                          vars[],
                          self.rewrite (f.getValue ()),
                          self.rewrite (f.getBlock ()))
    }

    /**
     * Rewrite a function pointer type expr
     * @params:
     *    - f: to function ptr type to rewritte
     * @returns: the rewritten expression
     */
    def rewriteFuncPtrType (self, f : &FunctionPtrTypeExpr)-> &Expression {
        let dmut params = Vec!{&Expression}::new ();
        for it in f.getParameters () { params:.push (self.rewrite (it)) }

        FunctionPtrTypeExpr::new (f.getLoc (),
                                  params[],
                                  self.rewrite (f.getReturn ()))
    }   

    /**
     * Rewrite an intrinsic expr
     * @params:
     *    - i: the intrinsic expr to rewritte
     * @returns: the rewritten expression
     */    
    def rewriteIntrinsic (self, i : &IntrinsicExpr)-> &Expression {
        IntrinsicExpr::new (i.getLoc (), i.getType (), self.rewrite (i.getContent ()))
    }

    /**
     * Rewrite a lambda value expr
     * @params:
     *    - l: the lambda value expr
     * @returns: the rewritten expression
     */    
    def rewriteLambda (self, l : &LambdaValueExpr)-> &Expression {
        LambdaValueExpr::new (l.getLoc (),
                              self.rewriteFuncProtoDecl (l.getFunctionProtoDecl ()),
                              self.rewrite (l.getValue ()))
    }

    /**
     * Rewrite a list value expr
     * @params:
     *    - l: the list value expr
     * @returns: the rewritten expression
     */        
    def rewriteList (self, l : &ListExpr)-> &Expression {
        let dmut params = Vec!{&Expression}::new ();
        for it in l.getParameters () { params:.push (self.rewrite (it)) }

        ListExpr::new (l.getLoc (), l.getEndLocation (), params[], isArray-> l.isArray ())
    }    
    
    /**
     * Rewrite a literal expression
     * @params: 
     *    - l: the literal expr to rewrite
     * @returns: the rewritten expr
     */
    def rewriteLiteral (self, l : &LiteralExpr)-> &Expression {
        match l {
            v : &VarExpr => {
                match self._mapper.getMapping ().find (v.getLoc ().str ()) {
                    Ok (x : &Expression) => { x }
                    _ => { cast!{&Expression} (l) }
                }
            }
            _ => { cast!{&Expression} (l) }
        }
    }    

    /**
     * Rewrite a macro call expression
     * @params: 
     *    - l: the macro call expr to rewrite
     * @returns: the rewritten expr
     */    
    def rewriteMacroCall (self, m : &MacroCallExpr)-> &Expression {
        MacroCallExpr::new (m.getLoc (),
                            m.getEndLocation (),
                            self.rewrite (m.getMacro ()),
                            m.getContent ())

    }

    /**
     * Rewrite a matcher expression
     * @params: 
     *    - m: the matcher expression to rewrite
     * @returns: the rewritten expr
     */
    def rewriteMatcher (self, m : &MatcherExpr)-> &Expression {
        let dmut matchers = Vec!{(&Expression, &Expression)}::new ();
        for it in m.getMatchers () { matchers:.push ((self.rewrite (it._0), self.rewrite (it._1))); }
        
        MatcherExpr::new (m.getLoc (),
                          self.rewrite (m.getContent ()),
                          matchers[],
                          isCatcher-> m.isCatcher ())
    }

    /**
     * Rewrite a named expr
     * @params: 
     *    - n: the named expression to rewrite
     * @returns: the rewritten expression
     */
    def rewriteNamed (self, n : &NamedExpr)-> &Expression {
        NamedExpr::new (n.getLoc (),
                        self.rewrite (n.getContent ()))
    }

    /**
     * Rewrite a binary expression
     * @params: 
     *    - b: the binary expr to rewrite
     * @returns: the rewritten expr
     */
    def rewriteBinary (self, b : &BinaryExpr)-> &Expression {
        BinaryExpr::new (b.getLoc (),
                         self.rewrite (b.getLeft ()),
                         self.rewrite (b.getRight ()))
    }

    /**
     * Rewrite a mult op expr
     * @params: 
     *    -m: the mult operation to rewrite
     * @returns: the rewritten expr
     */
    def rewriteMultOp (self, m : &MultOperatorExpr)-> &Expression {
        let dmut rights = Vec!{&Expression}::new ();
        for it in m.getRights () { rights:.push (self.rewrite (it)); }

        MultOperatorExpr::new (m.getLoc (), m.getEndLocation (),
                               self.rewrite (m.getLeft ()),
                               rights [],
                               canBeDotCall-> m.canBeDotCall ())
    }

    /**
     * Rewrite a mult op expr
     * @params: 
     *    -m: the mult operation to rewrite
     * @returns: the rewritten expr
     */    
    def rewritePath (self, p : &PathExpr)-> &Expression {
        p
    }

    /**
     * Rewrite an unary expr
     * @params: 
     *    - u: the unary expr to rewrite
     * @returns: the rewritten expr
     */
    def rewriteUnary (self, u : &UnaryExpr)-> &Expression {
        UnaryExpr::new (u.getLoc (),
                        self.rewrite (u.getOperand ()))
    }

    /**
     * Rewrite a pragma exprs
     * @params:
     *    - p: the pragma to rewrite
     * @returns: the rewritten expr
     */
    def rewritePragma (self, p : &PragmaExpr)-> &Expression {
        let dmut params = Vec!{&Expression}::new ();
        for it in p.getParameters () { params:.push (self.rewrite (it)); }

        PragmaExpr::new (p.getLoc (), params[])
    }

    /**
     * Rewrite a return expression
     * @params:
     *    - r: the return expression to rewrite
     * @returns: the rewritten expression
     */
    def rewriteReturn (self, r : &ReturnExpr)-> &Expression {
        ReturnExpr::new (r.getLoc (),
                         self.rewrite (r))
    }
    
    /**
     * Rewrite a scope guard expression
     * @params:
     *    - sc: the scope guard to rewrite
     * @returns: the rewritten expression
     */
    def rewriteScopeGuard (self, sc : &ScopeGuardExpr)-> &ScopeGuardExpr {
        ScopeGuardExpr::new (sc.getLoc (),
                             self.rewrite (sc.getContent ()),
                             sc.getKind ())
    }

    /**
     * Rewrite a set expression
     * @params:
     *    - sc: the set expr to rewrite
     * @returns: the rewritten expression
     */
    def rewriteSet (self, s : &SetExpr)-> &Expression {
        let dmut content = Vec!{&Expression}::new ();
        for it in s.getContent () { content:.push (self.rewrite (it)); }

        SetExpr::new (s.getLoc (), content[])
    }

    /**
     * Rewrite a slice allocator expression
     * @params: 
     *    - s: the slice allocator
     * @returns: the rewritten expression
     */
    def rewriteSliceAlloc (self, s : &SliceAllocatorExpr)-> &Expression {
        SliceAllocatorExpr::new (s.getLoc (),
                                 self.rewrite (s.getValue ()),
                                 self.rewrite (s.getSize ()),
                                 isDynamic-> s.isDynamic ())
    }

    /**
     * Rewrite a template call expr
     * @params: 
     *    - t: the template call expr to rewrite
     * @returns: the rewritten expr
     */
    def rewriteTemplateCall (self, t : &TemplateCallExpr)-> &Expression {
        let dmut rights = Vec!{&Expression}::new ();
        for it in t.getRights () { rights:.push (self.rewrite (it)) }

        TemplateCallExpr::new (t.getLoc (),
                               self.rewrite (t.getLeft ()),
                               rights [])
    }

    /**
     * Rewrite a template checker expr
     * @params: 
     *    - t: the template checker to rewrite
     * @returns: the rewritten expression
     */
    def rewriteTemplateChecker (self, t : &TemplateCheckerExpr)-> &Expression {
        let dmut params = Vec!{&Expression}::new ();
        let dmut rules = Vec!{&Expression}::new ();
        for it in t.getParameters () { params:.push (self.rewrite (it)); }
        for it in t.getRules () { rules:.push (self.rewrite (it)); }

        TemplateCheckerExpr::new (t.getLoc (),
                                  params[],
                                  rules[])        
    }

    /**
     * Rewrite a template of var
     * @params: 
     *    - o: the template of var to rewrite
     * @returns: the rewritten expression
     */
    def rewriteTemplateOfVar (self, o : &TemplateOfVarExpr)-> &Expression {
        TemplateOfVarExpr::new (o.getLoc (),
                            self.rewrite (o.getSpecialization ()),
                            o.getKind ())
    }

    /**
     * Rewrite a template variadic var
     * @params: 
     *    - v: the template variadic var to rewrite
     * @returns: the rewritten var
     */
    def rewriteTemplateVariadicVar (self, v : &TemplateVariadicVarExpr)-> &Expression {
        match self._mapper.getMapping ().find (v.getLoc ().str ()) {
            Ok (x : &Expression) => { x }
            _ => { cast!{&Expression} (v) }
        }        
    }

    /**
     * Rewrite a template var
     * @params: 
     *    - v: the template variadic var to rewrite
     * @returns: the rewritten var
     */
    def rewriteTemplateVar (self, v : &TemplateVarExpr)-> &Expression {
        match self._mapper.getMapping ().find (v.getLoc ().str ()) {
            Ok (x : &Expression) => { x }
            _ => { cast!{&Expression} (v) }
        }        
    }

    /**
     * Rewrite a throw expression
     * @params: 
     *   - t: the throw expr to rewrite
     * @returns: the rewritten expr
     */
    def rewriteThrow (self, t : &ThrowExpr)-> &Expression {
        ThrowExpr::new (t.getLoc (), self.rewrite (t.getValue ()))
    }

    /**
     * Rewrite a try expression
     * @params: 
     *    - t: the try expr to rewrite
     * @returns: the rewritten expr
     */
    def rewriteTry (self, t : &TryExpr)-> &Expression {
        TryExpr::new (t.getLoc (), self.rewrite (t.getValue ()))
    }


    /**
     * Rewrite a var decl expression
     * @params: 
     *    - v: the var decl expr to rewrite
     * @returns: the rewritten expression
     */
    def rewriteVarDecl (self, v : &VarDeclExpr)-> &Expression {
        VarDeclExpr::new (v.getLoc (), v.getName (),
                          self.rewrite (v.getValue ()),
                          self.rewrite (v.getType ()),
                          decos-> v.getDecos ())
    }

    /**
     * Rewrite a while loop expression
     * @params: 
     *    - w: the while loop expression to rewrite
     * @returns: the rewritten expression
     */
    def rewriteWhileLoop (self, w : &WhileLoopExpr)-> &Expression {
        WhileLoopExpr::new (w.getLoc (),
                            test-> self.rewrite (w.getTest ()),
                            self.rewrite (w.getContent ()),
                            isDo-> w.isDo ())
    }

    /**
     * Rewrite a dispose scope expression
     * @params: 
     *    - d: the dispose scope to rewrite
     * @returns: the rewritten expression
     */
    def rewriteDisposeScope (self, d : &DisposeScopeExpr)-> &Expression {
        let dmut vars = Vec!{&Expression}::new ();
        for it in d.getVariables () { vars:.push (self.rewrite (it)) }
        
        DisposeScopeExpr::new (d.getLoc (),
                               vars[],
                               self.rewrite (d.getBlock ()))                               
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================            COMMON            =========================
     * ================================================================================
     * ================================================================================
     */    
    
    /**
     * Create a new template parameter list from an old list and a pre template specialization
     * @params: 
     *    - syntaxTemplate: the old template parameters
     *    - mapper: the template specialization
     * @returns: The transformed list
     */
    pub def replaceSyntaxTempl (self, syntaxTemplate : [&Expression], mapper : &TemplateMapper)-> [&Expression] {
        let dmut results = Vec!{&Expression}::new ();
        // THe idea is simple, we go through the list, and if the template was already validated, we reject it
        for it in syntaxTemplate match it {
            v : &VarExpr => {
                if !mapper.hasValidated (v.getLoc ().str ()) results:.push (v);            
            }
            v : &TemplateOfVarExpr => {
                if !mapper.hasValidated (v.getLoc ().str ()) results:.push (v);
            }
            v : &TemplateVariadicVarExpr => {
                if !mapper.hasValidated (v.getLoc ().str ()) results:.push (v);
            }
            v : &TemplateVarExpr => { // different from VarExpr, as it has a value
                if !mapper.hasValidated (v.getLoc ().str ()) results:.push (v);
            }            
            _ => { // constant values are stored differently
                if !mapper.hasValidated (format ("%[%,%]", it.getLoc ().str (), it.getLoc ().line (), it.getLoc ().col ())) results:.push (it);
            }
        }

        results[]
    }
    
}
