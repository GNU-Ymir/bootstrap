mod ymirc::semantic::validator::template::rewrite;

import std::collection::map;
import std::collection::vec;
import std::io;

import ymirc::syntax::expression::_;
import ymirc::syntax::declaration::_;
import ymirc::errors::_;
import ymirc::utils::format;
import ymirc::lexing::word;
import ymirc::utils::format;

import ymirc::semantic::generator::type::syntax::_;
import ymirc::semantic::generator::value::syntax::_;
import ymirc::semantic::validator::template::mapper;

/**
 * This class is used to apply a template mapper to expressions, declarations, etc.
 */
pub class TemplateRewriter {

    /// The mapper that will be applied to expressions
    let _mapper : &TemplateMapper;
    
    /**
     * Create an template rewriter 
     * @params: 
     *    - mapper: the mapper that will be used to rewrite the template elements
     */
    pub self (mapper : &TemplateMapper)
        with _mapper = mapper
    {}

    /*!
     * ================================================================================
     * ================================================================================
     * =========================           GETTERS            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * @returns: the score of the template specialization
     */
    pub fn getScore (self)-> u32 {
        self._mapper.getScore ()
    }

    /**
     * @returns: the template mapper used by the rewriter
     * */
    pub fn getTemplateMapper (self)-> &TemplateMapper {
        self._mapper
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================          COMPARISON          =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * @returns: true if self and other can be used indistinguishably
     */
    pub fn opEquals (self, other : &TemplateRewriter)-> bool {
        self._mapper == other._mapper
    }        

    /*!
     * ================================================================================
     * ================================================================================
     * =========================         DECLARATIONS         =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Rewrite a declaration
     * @params:
     *    - d: the declaration to rewrite
     * @returns: the rewritten declaration
     */
    pub fn rewrite (self, d : &Declaration)-> &Declaration
        match d {
            a : &AkaDecl  => { self.rewriteAkaDecl (a) }
            c : &ClassDecl => { self.rewriteClassDecl (c) }
            c : &CondBlockDecl => { self.rewriteCondBlockDecl (c) }
            c : &ConstructorDecl => { self.rewriteConstructorDecl (c) }
            d_ : &BlockDecl => { cast!{&Declaration} (self.rewriteBlockDecl (d_)) }
            d_ : &DestructorDecl => { self.rewriteDtorDecl (d_) }
            e : &EnumDecl => { self.rewriteEnumDecl (e) }
            e : &ExternBlockDecl => { self.rewriteExternBlockDecl (e) }
            f : &FunctionDecl => { self.rewriteFunctionDecl (f) }
            g : &GlobalDecl => { self.rewriteGlobalDecl (g) }
            i : &ImplDecl => { self.rewriteImplDecl (i) }
            i : &ImportDecl => { self.rewriteImportDecl (i) }
            m : &MacroRuleDecl => { self.rewriteMacroRuleDecl (m) }
            m : &ModuleDecl => { self.rewriteModuleDecl (m) }
            m : &MacroDecl => { self.rewriteMacroDecl (m) }
            p : &FunctionProtoDecl => { cast!{&Declaration} (self.rewriteFuncProtoDecl (p)) }
            t : &TemplateDecl => { self.rewriteTemplateDecl (t) }
            t : &TraitDecl => { self.rewriteTraitDecl (t) }
            u : &UnitTestDecl => { self.rewriteUnitTestDecl (u) }
            w : &ExpressionWrapperDecl => { self.rewriteExprWrapperDecl (w) }
            u : &UseDecl => { self.rewriteUseDecl (u) }
            todo : _ => {
                println (todo);
                __pragma!panic ();
            }
        }


    /**
     * Rewrite an aka declaration
     * @params:
     *    - a: the aka declaration to rewrite
     * @returns: the rewritten declaration
     */
    fn rewriteAkaDecl (self, a : &AkaDecl)-> &Declaration {
        let content = self.rewrite (a.getContent ());
        AkaDecl::new (a.getLoc (), a.getComments (), content, a.getTokDecl ())
    }

    /**
     * Rewrite a class declaration
     * @params:
     *    - c: the class decl to rewrite
     * @returns: the rewritten declaration
     */
    fn rewriteClassDecl (self, c : &ClassDecl)-> &Declaration {
        let ancestor = self.rewrite (c.getAncestor ());
        let dmut content = Vec!{&Declaration}::new ();
        for i in c.getDeclarations () { content:.push (self.rewrite (i)) }

        ClassDecl::new (c.getLoc (), c.getComments (), content[], attrs-> c.getAttributes (), ancestor-> ancestor, isStruct-> c.isStruct (), isRecord-> c.isRecord ())
    }

    /**
     * Rewrite a cond block decl
     * @params:
     *    - c: the conditional block to decl
     * @returns: the rewritten decl
     */
    fn rewriteCondBlockDecl (self, c : &CondBlockDecl)-> &Declaration {
        let dmut decls = Vec!{&Declaration}::new ();
        for i in c.getDeclarations () { decls:.push (self.rewrite (i)) }
        let test = self.rewrite (c.getTest ());
        let else_ = self.rewrite (c.getElse ());

        CondBlockDecl::new (c.getLoc (), c.getComments (), decls-> decls[], test-> test, else_-> else_)
    }

    /**
     * Rewrite a constructor declaration
     * @params:
     *    - c: the constructor to rewrite
     * @returns: the rewritten declaration
     */
    fn rewriteConstructorDecl (self, c : &ConstructorDecl)-> &Declaration {
        let proto = self.rewriteFuncProtoDecl (c.getFunctionProtoDecl ());
        let dmut superParams = Vec!{&Expression}::new ();

        for i in c.getSuperParams () {
            superParams:.push (self.rewrite (i));
        }

        let dmut fields = Vec!{(&Word, &Expression)}::new ();
        for i in c.getFieldConstructors () {
            fields:.push ((i._0, self.rewrite (i._1)));
        }

        let dmut throwers = Vec!{&Expression}::new ();
        for i in c.getThrowers () {
            throwers:.push (self.rewrite (i));
        }

        ConstructorDecl::new (c.getLoc (),
                              c.getComments (),
                              rename-> c.getRename (),
                              proto,
                              superParams-> superParams[],
                              superTemplateParams-> self.rewrite (c.getSuperTemplateParams ()),
                              fields-> fields[],
                              self.rewrite (c.getBody ()),
                              explicitCstrsCall-> c.getExplicitCstrsCall (),
                              explicitSuperName-> c.getExplicitSuperName (),
                              attributes-> c.getAttributes (),
                              throwerLoc-> c.getThrowerLoc (),
                              throwers-> throwers[])
    }


    /**
     * Rewrite a block decl
     * @params:
     *    - b: the block decl to rewrite
     * @returns: the rewritten declaration
     */
    fn rewriteBlockDecl (self, b : &BlockDecl)-> &BlockDecl {
        let dmut content = Vec!{&Declaration}::new ();
        for i in b.getDeclarations () { content:.push (self.rewrite (i)) }

        BlockDecl::new (b.getLoc (), b.getComments (), content[], protection-> b.getProtection ())
    }

    /**
     * Rewrite a function declaration
     * @params:
     *    - f: the function decl to rewrite
     * @returns: the rewritten declaration
     */
    fn rewriteFunctionDecl (self, f : &FunctionDecl)-> &Declaration {
        let proto = self.rewriteFuncProtoDecl (f.getFunctionProto ());
        let body = self.rewrite (f.getBody ());
        let dmut th = Vec!{&Expression}::new ();
        for i in f.getThrowers () { th:.push (self.rewrite (i)); }

        FunctionDecl::new (f.getLoc (), f.getComments (), proto, body, attrs-> f.getAttributes (), throwers-> th[], throwerLoc-> f.getThrowerLoc (), isOver-> f.isOver ())
    }

    /**
     * Rewrite a destructor declaration
     * @params:
     *    - d: the dtor to rewrite
     * @returns: the rewritten declaration
     */
    fn rewriteDtorDecl (self, d : &DestructorDecl)-> &Declaration {
        let proto = self.rewriteFuncProtoDecl (d.getFunctionProto ());
        let body = self.rewrite (d.getBody ());

        DestructorDecl::new (d.getLoc (), d.getComments (), proto, body)
    }

    /**
     * Rewrite an enumeration decl
     * @params:
     *   - e: the enum to rewrite
     * @returns: the rewritten declaration
     */
    fn rewriteEnumDecl (self, e : &EnumDecl)-> &Declaration {
        let dmut values = Vec!{&VarDeclExpr}::new ();
        let type = self.rewrite (e.getType ());
        for i in e.getValues () { values:.push (self.rewriteVarDecl (i)) }

        EnumDecl::new (e.getLoc (), e.getComments (), type-> type, values-> values[], fieldComms-> e.getFieldComms ())
    }

    /**
     * Rewrite an extern block declaration
     * @params:
     *     - e: the extern block to rewrite
     * @returns: the rewritten extern block
     */
    fn rewriteExternBlockDecl (self, e : &ExternBlockDecl)-> &Declaration {
        ExternBlockDecl::new (e.getLoc (),
                              e.getComments (),
                              e.getLanguage (),
                              self.rewrite (e.getNamespace ()),
                              self.rewrite (e.getDeclaration ()))
    }

    /**
     * Rewrite a global var declaration
     * @params:
     *    - e: the global var to rewrite
     * @returns: the rewritten decl
     */
    fn rewriteGlobalDecl (self, e : &GlobalDecl)-> &Declaration {
        GlobalDecl::new (e.getLoc (),
                         e.getComments (),
                         self.rewriteVarDecl (e.getContent ()),
                         e.getAttributes (),
                         isField-> e.isField (),
                         isStatic-> e.isStatic ())
    }

    /**
     * Rewrite a impl declaration
     * @params:
     *    - i: the impl decl to rewrite
     * @returns: the rewritten declaration
     */
    fn rewriteImplDecl (self, i : &ImplDecl)-> &Declaration {
        let dmut content = Vec!{&Declaration}::new ();
        for d in i.getDeclarations () { content:.push (self.rewrite (d)) }

        ImplDecl::new (i.getLoc (), i.getComments (), self.rewrite (i.getTrait ()), content-> content[])
    }

    /**
     * Rewrite an import declaration
     * @params:
     *    - i: the import decl to rewrite
     * @returns: the rewritten import declaration
     */
    fn rewriteImportDecl (self, i : &ImportDecl)-> &Declaration {
        i
    }

    /**
     * Rewrite a use declaration
     * @params:
     *    - i: the use declaration to rewrite
     * @returns: the rewrite use declaration
     * */
    fn rewriteUseDecl (self, u : &UseDecl)-> &Declaration {
        UseDecl::new (u.getLoc (), u.getComments (), self.rewrite (u.getModulePath ()))
    }

    /**
     * Rewrite a macro rule declaration
     * @params:
     *    - m: the macro rule to rewrite
     * @returns: the rewritten declaration
     */
    fn rewriteMacroRuleDecl (self, m : &MacroRuleDecl)-> &Declaration {
        m
    }

    /**
     * Rewrite a macro declaration
     * @params:
     *    - m: the macro decl to rewrite
     * @returns: the rewritten declaration
     */
    fn rewriteMacroDecl (self, m : &MacroDecl)-> &Declaration {
        let dmut decls = Vec!{&Declaration}::new ();
        for i in m.getDeclarations () { decls:.push (self.rewrite (i)) }

        MacroDecl::new (m.getLoc (), m.getComments (), decls[])
    }

    /**
     * Rewrite a module declaration
     * @params:
     *    - m: the module declaration to rewrite
     * @returns: the rewritten declaration
     */
    fn rewriteModuleDecl (self, m : &ModuleDecl)-> &Declaration {
        ModuleDecl::new (m.getLoc (),
                         m.getPath (),
                         m.getComments (),
                         self.rewriteBlockDecl (m.getBlockDecl ()),
                         isGlobal-> m.isGlobal ())
    }

    /**
     * Rewrite a function proto decl
     * @params:
     *     - p: the proto decl to rewrite
     * @returns: the rewritten prototype
     */
    fn rewriteFuncProtoDecl (self, p : &FunctionProtoDecl)-> &FunctionProtoDecl {
        let dmut params = Vec!{&VarDeclExpr}::new ();
        let retType = self.rewrite (p.getRetType ());
        for i in p.getParameters () { params:.push (self.rewriteVarDecl (i)); }

        FunctionProtoDecl::new (p.getLoc (), comm-> p.getComments (), params[], retType, isVariadic-> p.isVariadic (), forLambda-> p.isForLambda ())
    }

    /**
     * Rewrite a template declaration
     * @params:
     *    - t: the template declaration to rewrite
     * @returns: the rewritten declaration
     */
    fn rewriteTemplateDecl (self, t : &TemplateDecl)-> &Declaration {
        let dmut params = Vec!{&Expression}::new ();
        for p in t.getParameters () { params:.push (self.rewrite (p)) }

        TemplateDecl::new (t.getLoc (),
                           t.getComments (),
                           params[],
                           test-> self.rewrite (t.getTest ()),
                           content-> self.rewrite (t.getContent ()))
    }

    /**
     * Rewrite a trait declaration
     * @params:
     *    - t: the trait declaration to rewrite
     * @returns: the rewritten declaration
     */
    fn rewriteTraitDecl (self, t : &TraitDecl)-> &Declaration {
        let dmut decls = Vec!{&Declaration}::new ();
        for d in t.getDeclarations () { decls:.push (self.rewrite (d)) }

        TraitDecl::new (t.getLoc (), t.getComments (), decls[])
    }

    /**
     * Rewrite a unit test declaration
     * @params:
     *    - u: the unit test to rewrite
     * @returns: the rewritten declaration
     */
    fn rewriteUnitTestDecl (self, u : &UnitTestDecl)-> &Declaration {
        UnitTestDecl::new (u.getLoc (),
                           u.getComments (),
                           self.rewrite (u.getBody ()))
    }

    /**
     * Rewrite an expression wrapper declaration
     * @params:
     *    - e: the expression wrapper
     * @returns: the rewritten declaration
     */
    fn rewriteExprWrapperDecl (self, e : &ExpressionWrapperDecl)-> &Declaration {
        ExpressionWrapperDecl::new (e.getLoc (), e.getComments (), self.rewrite (e.getContent ()))
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================         EXPRESSIONS          =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Rewrite the expression using the mapper of the rewriter
     * @params:
     *    - expr: the expression to rewrite
     * @returns: the rewritten expression
     */
    pub fn rewrite (self, expr : &Expression)-> &Expression {
        match expr {
            a : &AssertExpr => { self.rewriteAssert (a) }
            a : &AtomicExpr => { self.rewriteAtomic (a) }
            b : &BinaryExpr => { self.rewriteBinary (b) }
            b : &BlockExpr  => { self.rewriteBlock (b) }
            b : &BreakExpr  => { self.rewriteBreak (b) }
            c : &CastExpr   => { self.rewriteCast (c) }
            c : &ConditionalExpr => { self.rewriteConditional (c) }
            d : &DecoratedExpr => { self.rewriteDecorated (d) }
            _ : &EmptyExpression => { expr }
            f : &ForLoopExpr => { self.rewriteForLoop (f) }
            f : &FunctionPtrTypeExpr => { cast!{&Expression} (self.rewriteFuncPtrType (f)) }
            i : &IntrinsicExpr => { self.rewriteIntrinsic (i) }
            l : &LambdaValueExpr => { self.rewriteLambda (l) }
            l : &ListExpr => { self.rewriteList (l) }
            r : &RangeTypeExpr => { self.rewriteRangeType (r) }
            l : &LiteralExpr => { self.rewriteLiteral (l) }
            m : &MacroCallExpr => { self.rewriteMacroCall (m) }
            _ : &MacroRuleExpression => { expr }
            m : &MatcherExpr => { self.rewriteMatcher (m) }
            m : &MultOperatorExpr => { self.rewriteMultOp (m) }
            n : &NamedExpr => { self.rewrittenamed (n) }
            p : &PathExpr => { self.rewritePath (p) }
            p : &PragmaExpr => { self.rewritePragma (p) }
            r : &ReturnExpr => { self.rewriteReturn (r) }
            u : &UnaryExpr => { self.rewriteUnary (u) }
            s : &ScopeGuardExpr => { cast!{&Expression} (self.rewriteScopeGuard (s)) }
            s : &SetExpr => { self.rewriteSet (s) }
            s : &SliceAllocatorExpr => { self.rewriteSliceAlloc (s) }
            t : &TemplateCallExpr => { self.rewriteTemplateCall (t) }
            t : &TemplateCheckerExpr =>  { self.rewriteTemplateChecker (t) }
            t : &TemplateOfVarExpr => { cast!{&Expression} (self.rewriteTemplateOfVar (t)) }
            t : &TemplateAndExpr => { cast!{&Expression} (self.rewriteTemplateAndVar (t)) }
            t : &TemplateVariadicVarExpr => { self.rewriteTemplateVariadicVar (t) }
            t : &TemplateVarExpr => { self.rewriteTemplateVar (t) }
            t : &ThrowExpr => { self.rewriteThrow (t) }
            t : &TryExpr => { self.rewriteTry (t) }
            v : &VarDeclExpr => { cast!{&Expression} (self.rewriteVarDecl (v)) }
            w : &WhileLoopExpr => { self.rewriteWhileLoop (w) }
            w : &ValueWrapperExpr => { return w; } // already rewritten
            t : &TypeWrapperExpr => { return t; }  // same, rewritten earlier
            u : &UnsafeExpr => { self.rewriteUnsafe (u) }
            p : &PanicExpr => { return p; }
            p : &PatternVarDeclExpr => { cast!{&Expression} (self.rewritePatternVarDecl (p)) }
            o : &OptionMatcherExpr => { cast!{&Expression} (self.rewriteOptionMatch (o)) }
            l : &ListMatcherExpr => { cast!{&Expression} (self.rewriteListMatch (l)) }
            s : &SliceForAllocatorExpr => { cast!{&Expression} (self.rewriteSliceFor (s)) }
            todo : _ => {
                println (todo);
                __pragma!panic ();
            }
        }
    }

    /**
     * Rewrite an assert expression
     * @params:
     *    - a: the assert expression
     * @returns: the rewritten expression
     */
    fn rewriteAssert (self, a : &AssertExpr)-> &Expression {
        AssertExpr::new (a.getLoc (),
                         self.rewrite (a.getTest ()),
                         self.rewrite (a.getMessage ()))
    }


    /**
     * Rewrite an atomic expression
     * @params:
     *    - a: the atomic expression
     * @returns: the rewritten expression
     */
    fn rewriteAtomic (self, a : &AtomicExpr)-> &Expression {
        AtomicExpr::new (a.getLoc (),
                         monitor-> self.rewrite (a.getMonitor ()),
                         self.rewrite (a.getValue ()))
    }

    /**
     * Rewrite a block expr
     * @params:
     *    - b: the block expression to rewrite
     * @returns: the rewritten expression
     */
    fn rewriteBlock (self, b : &BlockExpr)-> &Expression {
        let dmut scopes = Vec!{&ScopeGuardExpr}::new ();
        let dmut exprs = Vec!{&Expression}::new ();
        let module = self.rewrite (b.getModule ());
        let catcher = self.rewrite (b.getCatcher ());
        for it in b.getExpressions () { exprs:.push (self.rewrite (it)); }
        for it in b.getGuards () { scopes:.push (self.rewriteScopeGuard (it)); }

        return BlockExpr::new (b.getLoc (), b.getEndLocation (), module-> module, content-> exprs[], catcher-> catcher, guards-> scopes[]);
    }


    /**
     * Rewrite a break expression
     * @params:
     *    - b: the break expr to rewrite
     * @returns: the rewritten expression
     */
    fn rewriteBreak (self, b : &BreakExpr)-> &Expression {
        BreakExpr::new (b.getLoc (),
                        self.rewrite (b.getValue ()))
    }

    /**
     * Rewrite a cast expression
     * @params:
     *    - c: the cast expr to rewrite
     * @returns: the rewritten expression
     */
    fn rewriteCast (self, c : &CastExpr)-> &Expression {
        CastExpr::new (c.getLoc (),
                       self.rewrite (c.getType ()),
                       self.rewrite (c.getValue ()))
    }

    /**
     * Rewrite a condtional expression
     * @params:
     *    - c: the conditional expr to rewrite
     * @returns: the rewritten expression
     */
    fn rewriteConditional (self, c : &ConditionalExpr)-> &Expression {
        ConditionalExpr::new (c.getLoc (),
                              test-> self.rewrite (c.getTest ()),
                              content-> self.rewrite (c.getContent ()),
                              else_-> self.rewrite (c.getElse ()),
                              isLet-> c.isLet (),
                              guard-> self.rewrite (c.getGuard ()))
    }

    /**
     * Rewrite a decorated expression
     * @params:
     *    - d: the decorated expr to rewrite
     * @returns: the rewritten expression
     */
    fn rewriteDecorated (self, d : &DecoratedExpr)-> &Expression {
        let x = self.rewrite (d.getContent ());
        match x {
            list : &TypeListWrapperExpr => {
                let dmut params = Vec!{&Expression}::new ();
                for i in list.getTypes () {
                    params:.push (DecoratedExpr::new (d.getLoc (),
                                                      content-> TypeWrapperExpr::new (i.getLoc (), i),
                                                      deco-> d.getDecorator ()));
                }

                ListExpr::new (d.getLoc (), d.getLoc (), params[], isArray-> false)
            }
            _ => {
                DecoratedExpr::new (d.getLoc (),
                                    content-> x,
                                    deco-> d.getDecorator ())
            }
        }
    }

    /**
     * Rewrite a for loop expr
     * @params:
     *    - f: the for loop to rewrite
     * @returns: the rewritten expression
     */
    fn rewriteForLoop (self, f : &ForLoopExpr)-> &Expression {
        let dmut vars = Vec!{&Expression}::new ();
        for it in f.getVariables () { vars:.push (self.rewrite (it)) }

        ForLoopExpr::new (f.getLoc (),
                          vars[],
                          self.rewrite (f.getValue ()),
                          self.rewrite (f.getBlock ()))
    }

    /**
     * Rewrite a function pointer type expr
     * @params:
     *    - f: to function ptr type to rewrite
     * @returns: the rewritten expression
     */
    pub fn rewriteFuncPtrType (self, f : &FunctionPtrTypeExpr)-> &FunctionPtrTypeExpr {
        let dmut params = Vec!{&VarDeclExpr}::new ();
        for v in f.getParameters () {
            let x = self.rewrite (v.getType ());
            match x {
                list : &TypeListWrapperExpr => {
                    for i in list.getTypes () {
                        params:.push (VarDeclExpr::new (v.getLoc (), v.getName (),
                                                        value-> self.rewrite (v.getValue ()),
                                                        type-> TypeWrapperExpr::new (i.getLoc (), i),
                                                        isLazyOrRef-> v.getLazyOrRefLocation (),
                                                        isMutOrDmut-> v.getMutOrDmutLocation ()));
                    }
                }
                _ => {
                    params:.push (VarDeclExpr::new (v.getLoc (), v.getName (),
                                                    value-> self.rewrite (v.getValue ()),
                                                    type-> x,
                                                    isLazyOrRef-> v.getLazyOrRefLocation (),
                                                    isMutOrDmut-> v.getMutOrDmutLocation ()));
                }
            }
        }

        FunctionPtrTypeExpr::new (f.getLoc (),
                                  params[],
                                  self.rewrite (f.getReturn ()))
    }

    /**
     * Rewrite an intrinsic expr
     * @params:
     *    - i: the intrinsic expr to rewrite
     * @returns: the rewritten expression
     */
    fn rewriteIntrinsic (self, i : &IntrinsicExpr)-> &Expression {
        IntrinsicExpr::new (i.getLoc (), i.getType (), self.rewrite (i.getContent ()))
    }

    /**
     * Rewrite a lambda value expr
     * @params:
     *    - l: the lambda value expr
     * @returns: the rewritten expression
     */
    fn rewriteLambda (self, l : &LambdaValueExpr)-> &Expression {
        LambdaValueExpr::new (l.getLoc (),
                              self.rewriteFuncProtoDecl (l.getFunctionProtoDecl ()),
                              self.rewrite (l.getValue ()))
    }

    /**
     * Rewrite a list value expr
     * @params:
     *    - l: the list value expr
     * @returns: the rewritten expression
     */
    fn rewriteList (self, l : &ListExpr)-> &Expression {
        let dmut params = Vec!{&Expression}::new ();
        for it in l.getParameters () {
            let x = self.rewrite (it);
            match x {
                list : &TypeListWrapperExpr => {
                    for i in list.getTypes () {
                        params:.push (TypeWrapperExpr::new (i.getLoc (), i));
                    }
                }
                _ => {
                    params:.push (x)
                }
            }
        }

        ListExpr::new (l.getLoc (), l.getEndLocation (), params[], isArray-> l.isArray ())
    }

    /**
     * Rewrite a range type expr
     * @params:
     *    - r: the range type to rewrite
     * @returns: the rewritten expression
     */
    fn rewriteRangeType (self, r : &RangeTypeExpr)-> &Expression {
        RangeTypeExpr::new (r.getLoc (), self.rewrite (r.getType ()))
    }


    /**
     * Rewrite a literal expression
     * @params:
     *    - l: the literal expr to rewrite
     * @returns: the rewritten expr
     */
    fn rewriteLiteral (self, l : &LiteralExpr)-> &Expression {
        match l {
            v : &VarExpr => {
                match self._mapper.getMapping ().find (v.getLoc ().str ()) {
                    Ok (x : &ValueWrapperExpr) => { return ValueWrapperExpr::new (l.getLoc (), x.getValue ()); }
                    Ok (x : &TypeWrapperExpr) => { return TypeWrapperExpr::new (l.getLoc (), x.getType (), asIs-> x.asIs ()); }
                    Ok (x : &TypeListWrapperExpr) => { return TypeListWrapperExpr::new (l.getLoc (), x.getTypes ()); }
                    Ok (x : &LambdaValueWrapperExpr) => { return LambdaValueWrapperExpr::new (l.getLoc (), x.getName (), x.getType (), x.getValue ()); }
                    Ok (x : &Expression) => { x }
                    _ => { cast!{&Expression} (l) }
                }
            }
            _ => { cast!{&Expression} (l) }
        }
    }

    /**
     * Rewrite a macro call expression
     * @params:
     *    - l: the macro call expr to rewrite
     * @returns: the rewritten expr
     */
    fn rewriteMacroCall (self, m : &MacroCallExpr)-> &Expression {
        MacroCallExpr::new (m.getLoc (),
                            m.getEndLocation (),
                            self.rewrite (m.getMacro ()),
                            m.getContent ())

    }

    /**
     * Rewrite a matcher expression
     * @params:
     *    - m: the matcher expression to rewrite
     * @returns: the rewritten expr
     */
    fn rewriteMatcher (self, m : &MatcherExpr)-> &Expression {
        let dmut matchers = Vec!{(&Expression, &Expression, &Expression)}::new ();
        for it in m.getMatchers () { matchers:.push ((self.rewrite (it._0), self.rewrite (it._1), self.rewrite (it._2))); }

        MatcherExpr::new (m.getLoc (),
                          self.rewrite (m.getContent ()),
                          matchers[],
                          isCatcher-> m.isCatcher ())
    }

    /**
     * Rewrite a named expr
     * @params:
     *    - n: the named expression to rewrite
     * @returns: the rewritten expression
     */
    fn rewrittenamed (self, n : &NamedExpr)-> &Expression {
        NamedExpr::new (n.getLoc (),
                        self.rewrite (n.getContent ()))
    }

    /**
     * Rewrite a binary expression
     * @params:
     *    - b: the binary expr to rewrite
     * @returns: the rewritten expr
     */
    fn rewriteBinary (self, b : &BinaryExpr)-> &Expression {
        BinaryExpr::new (b.getLoc (),
                         self.rewrite (b.getLeft ()),
                         self.rewrite (b.getRight ()))
    }

    /**
     * Rewrite a mult op expr
     * @params:
     *    -m: the mult operation to rewrite
     * @returns: the rewritten expr
     */
    fn rewriteMultOp (self, m : &MultOperatorExpr)-> &Expression {
        let dmut rights = Vec!{&Expression}::new ();
        for it in m.getRights () { rights:.push (self.rewrite (it)); }

        MultOperatorExpr::new (m.getLoc (), m.getEndLocation (),
                               self.rewrite (m.getLeft ()),
                               rights [],
                               canBeDotCall-> m.canBeDotCall ())
    }

    /**
     * Rewrite a mult op expr
     * @params:
     *    -m: the mult operation to rewrite
     * @returns: the rewritten expr
     */
    fn rewritePath (self, p : &PathExpr)-> &Expression {
        p
    }

    /**
     * Rewrite an unary expr
     * @params:
     *    - u: the unary expr to rewrite
     * @returns: the rewritten expr
     */
    fn rewriteUnary (self, u : &UnaryExpr)-> &Expression {
        UnaryExpr::new (u.getLoc (),
                        self.rewrite (u.getOperand ()))
    }

    /**
     * Rewrite a pragma exprs
     * @params:
     *    - p: the pragma to rewrite
     * @returns: the rewritten expr
     */
    fn rewritePragma (self, p : &PragmaExpr)-> &Expression {
        let dmut params = Vec!{&Expression}::new ();
        for it in p.getParameters () { params:.push (self.rewrite (it)); }

        PragmaExpr::new (p.getLoc (), params[])
    }

    /**
     * Rewrite a return expression
     * @params:
     *    - r: the return expression to rewrite
     * @returns: the rewritten expression
     */
    fn rewriteReturn (self, r : &ReturnExpr)-> &Expression {
        ReturnExpr::new (r.getLoc (),
                         self.rewrite (r.getValue ()))
    }

    /**
     * Rewrite a scope guard expression
     * @params:
     *    - sc: the scope guard to rewrite
     * @returns: the rewritten expression
     */
    fn rewriteScopeGuard (self, sc : &ScopeGuardExpr)-> &ScopeGuardExpr {
        ScopeGuardExpr::new (sc.getLoc (),
                             self.rewrite (sc.getContent ()),
                             sc.getKind ())
    }

    /**
     * Rewrite a set expression
     * @params:
     *    - sc: the set expr to rewrite
     * @returns: the rewritten expression
     */
    fn rewriteSet (self, s : &SetExpr)-> &Expression {
        let dmut content = Vec!{&Expression}::new ();
        for it in s.getContent () { content:.push (self.rewrite (it)); }

        SetExpr::new (s.getLoc (), content[])
    }

    /**
     * Rewrite a slice allocator expression
     * @params:
     *    - s: the slice allocator
     * @returns: the rewritten expression
     */
    fn rewriteSliceAlloc (self, s : &SliceAllocatorExpr)-> &Expression {
        SliceAllocatorExpr::new (s.getLoc (),
                                 self.rewrite (s.getValue ()),
                                 self.rewrite (s.getSize ()))
    }

    /**
     * Rewrite a template call expr
     * @params:
     *    - t: the template call expr to rewrite
     * @returns: the rewritten expr
     */
    fn rewriteTemplateCall (self, t : &TemplateCallExpr)-> &Expression {
        if (t.getLeft ().isOf!{&VarExpr} ()) {
            match (self._mapper.getMapping ().find (t.getLeft ().getLoc ().str ())) {
                Ok (x : _) => return x;
            }
        }

        let dmut rights = Vec!{&Expression}::new ();
        for it in t.getRights () {
            let x = self.rewrite (it);
            match x {
                list : &TypeListWrapperExpr => {
                    for i in list.getTypes () {
                        rights:.push (TypeWrapperExpr::new (i.getLoc (), i));
                    }
                }
                _ => {
                    rights:.push (self.rewrite (it))
                }
            }
        }

        TemplateCallExpr::new (t.getLoc (),
                               self.rewrite (t.getLeft ()),
                               rights [])
    }

    /**
     * Rewrite a template checker expr
     * @params:
     *    - t: the template checker to rewrite
     * @returns: the rewritten expression
     */
    fn rewriteTemplateChecker (self, t : &TemplateCheckerExpr)-> &Expression {
        let dmut params = Vec!{&Expression}::new ();
        let dmut rules = Vec!{&Expression}::new ();
        for it in t.getParameters () {
            params:.push (self.rewrite (it));
        }

        for it in t.getRules () {
            let x = self.rewrite (it);
            match x {
                list : &TypeListWrapperExpr => {
                    for i in list.getTypes () {
                        rules:.push (TypeWrapperExpr::new (i.getLoc (), i));
                    }
                }
                _ => { rules:.push (x); }
            }
        }

        TemplateCheckerExpr::new (t.getLoc (),
                                  params[],
                                  rules[])
    }

    /**
     * Rewrite a template of var
     * @params:
     *    - o: the template of var to rewrite
     * @returns: the rewritten expression
     */
    fn rewriteTemplateOfVar (self, o : &TemplateOfVarExpr)-> &TemplateOfVarExpr {
        TemplateOfVarExpr::new (o.getLoc (),
                                self.rewrite (o.getSpecialization ()),
                                o.getKind ())
    }

    /**
     * Rewrite a template and var
     * @params:
     *    - o: the template and var to rewrite
     * @returns: the rewritten expression
     */
    fn rewriteTemplateAndVar (self, o : &TemplateAndExpr)-> &TemplateAndExpr {
        let dmut ret = Vec!{&TemplateOfVarExpr}::new ();
        for i in o.getSpecializations () {
            ret:.push (self.rewriteTemplateOfVar (i));
        }

        TemplateAndExpr::new (o.getLoc (), ret[])
    }

    /**
     * Rewrite a template variadic var
     * @params:
     *    - v: the template variadic var to rewrite
     * @returns: the rewritten var
     */
    fn rewriteTemplateVariadicVar (self, v : &TemplateVariadicVarExpr)-> &Expression {
        match self._mapper.getMapping ().find (v.getLoc ().str ()) {
            Ok (x : &Expression) => { x }
            _ => { cast!{&Expression} (v) }
        }
    }

    /**
     * Rewrite a template var
     * @params:
     *    - v: the template variadic var to rewrite
     * @returns: the rewritten var
     */
    fn rewriteTemplateVar (self, v : &TemplateVarExpr)-> &Expression {
        match self._mapper.getMapping ().find (v.getLoc ().str ()) {
            Ok (x : &Expression) => { x }
            _ => { cast!{&Expression} (v) }
        }
    }

    /**
     * Rewrite a throw expression
     * @params:
     *   - t: the throw expr to rewrite
     * @returns: the rewritten expr
     */
    fn rewriteThrow (self, t : &ThrowExpr)-> &Expression {
        ThrowExpr::new (t.getLoc (), self.rewrite (t.getValue ()))
    }

    /**
     * Rewrite a try expression
     * @params:
     *    - t: the try expr to rewrite
     * @returns: the rewritten expr
     */
    fn rewriteTry (self, t : &TryExpr)-> &Expression {
        TryExpr::new (t.getLoc (), self.rewrite (t.getValue ()))
    }


    /**
     * Rewrite a var decl expression
     * @params:
     *    - v: the var decl expr to rewrite
     * @returns: the rewritten expression
     */
    pub fn rewriteVarDecl (self, v : &VarDeclExpr)-> &VarDeclExpr {
        VarDeclExpr::new (v.getLoc (), v.getName (),
                          self.rewrite (v.getValue ()),
                          self.rewrite (v.getType ()),
                          isLazyOrRef-> v.getLazyOrRefLocation (),
                          isMutOrDmut-> v.getMutOrDmutLocation ())
    }

    /**
     * Rewrite a pattern var declaration
     * @params:
     *    - p: the var decl expr to rewrite
     * @returns: the rewritten expression
     * */
    fn rewritePatternVarDecl (self, p : &PatternVarDeclExpr)-> &PatternVarDeclExpr {
        PatternVarDeclExpr::new (p.getLoc (),
                                 self.rewrite (p.getPattern ()),
                                 self.rewrite (p.getValue ()))
    }

    /**
     * Rewrite an option matcher
     * @params:
     *    - o: the option matcher to rewrite
     * @returns: the rewritten expr
     * */
    fn rewriteOptionMatch (self, o : &OptionMatcherExpr)-> &OptionMatcherExpr {
        OptionMatcherExpr::new (o.getLoc (),
                                self.rewrite (o.getInner ()))
    }


    /**
     * Rewrite a list matcher
     * @params:
     *    - l: the list matcher to rewrite
     * @returns: the rewritten expr
     * */
    fn rewriteListMatch (self, l : &ListMatcherExpr)-> &ListMatcherExpr {
        let dmut params = Vec!{&Expression}::new ();
        for i in l.getParameters () {
            params:.push (self.rewrite (i));
        }

        ListMatcherExpr::new (l.getLoc (), l.getEndLoc (),
                              params[],
                              l.isVariadic ())
    }

    /**
     * Rewrite a slice for allocator
     * @params:
     *    - sl: the slice for to rewrite
     *  @returns: the rewritten expr
     * */
    fn rewriteSliceFor (self, sl : &SliceForAllocatorExpr)-> &SliceForAllocatorExpr {
        let val = self.rewrite (sl.getValue ());
        let dmut vars = Vec!{&Expression}::new ();
        for i in sl.getVariables () {
            vars:.push (self.rewrite (i));
        }

        let iter = self.rewrite (sl.getIter ());

        SliceForAllocatorExpr::new (sl.getLoc (),
                                    sl.getForLoc (),
                                    val,
                                    vars[],
                                    iter,
                                    sl.isTuple ())
    }

    /**
     * Rewrite a while loop expression
     * @params:
     *    - w: the while loop expression to rewrite
     * @returns: the rewritten expression
     */
    fn rewriteWhileLoop (self, w : &WhileLoopExpr)-> &Expression {
        WhileLoopExpr::new (w.getLoc (),
                            test-> self.rewrite (w.getTest ()),
                            self.rewrite (w.getContent ()),
                            isDo-> w.isDo ())
    }

    /**
     * Rewrite an unsafe expression
     * @params:
     *    - u: the unsafe expression to rewrite
     * @returns: the rewritten expression
     * */
    fn rewriteUnsafe (self, u : &UnsafeExpr)-> &Expression {
        UnsafeExpr::new (u.getLoc (), self.rewrite (u.getValue ()))
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================            COMMON            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Create a new template parameter list from an old list and a pre template specialization
     * @params:
     *    - syntaxTemplate: the old template parameters
     *    - mapper: the template specialization
     * @returns: The transformed list
     */
    pub fn replaceSyntaxTempl (self, syntaxTemplate : [&Expression])-> [&Expression] {
        let dmut results = Vec!{&Expression}::new ();
        // THe idea is simple, we go through the list, and if the template was already validated, we reject it
        for it in syntaxTemplate match it {
            v : &VarExpr => {
                if !self._mapper.hasValidated (v.getLoc ().str ()) results:.push (v);
            }
            v : &TemplateOfVarExpr => {
                if !self._mapper.hasValidated (v.getLoc ().str ()) {
                    results:.push (self.rewriteTemplateOfVar (v));
                }
            }
            v : &TemplateAndExpr => {
                if !self._mapper.hasValidated (v.getLoc ().str ()) {
                    results:.push (self.rewriteTemplateAndVar (v));
                }
            }
            v : &TemplateVariadicVarExpr => {
                if !self._mapper.hasValidated (v.getLoc ().str ()) results:.push (v);
            }
            v : &TemplateVarExpr => { // different from VarExpr, as it has a value
                if !self._mapper.hasValidated (v.getLoc ().str ()) results:.push (v);
            }
            v : &VarDeclExpr => {
                if !self._mapper.hasValidated (v.getLoc ().str ()) {
                    results:.push (self.rewriteVarDecl (v));
                }
            }
            _ => { // constant values are stored differently
                if !self._mapper.hasValidated (format ("%[%,%]", it.getLoc ().str (), it.getLoc ().line (), it.getLoc ().col ())) results:.push (it);
            }
        }

        results[]
    }


    /*!
     * ================================================================================
     * ================================================================================
     * =========================             MISC             =========================
     * ================================================================================
     * ================================================================================
     */

    impl Streamable;
    impl Formattable {


        pub over format (self, dmut stream : &Formatter) {
            stream:.write (self._mapper);
        }

    }

    /**
     * @returns: the rewriter into a string (with less information that with format)
     */
    pub fn simpleFormat (self)-> [c8] {
        self._mapper.simpleFormat ()
    }

}
