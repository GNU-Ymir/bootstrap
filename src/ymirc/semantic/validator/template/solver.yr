mod ymirc::semantic::validator::template::solver;

import ymirc::semantic::validator::visitor;
import ymirc::semantic::validator::template::mapper;
import ymirc::semantic::validator::template::rewrite;
import ymirc::semantic::validator::errors;
import ymirc::semantic::symbol::template;
import ymirc::syntax::declaration::protection;
import ymirc::syntax::expression::_;
import ymirc::syntax::declaration::_;

import ymirc::syntax::keys;
import ymirc::semantic::generator::_;
import ymirc::semantic::symbol::_;
import ymirc::errors::_;
import ymirc::utils::format;
import ymirc::lexing::word;

import std::collection::vec;
import std::io, std::fs::path;

/**
 * The template validator is the template responsible for template symbol validation
 */
pub class TemplateSolver {

    /**
     * Create a new empty validator
     */
    pub self () {}
    
    /**
     * ================================================================================
     * ================================================================================
     * =========================             CALL             =========================
     * ================================================================================
     * ================================================================================
     */
    
    /**
     * Validate a template call that creates a value (function for example, or aka, etc.)
     * @params: 
     *    - context: the context of the validation
     *    - loc: the location of the call
     *    - left: the value that is template called
     *    - rights: the template arguments passed to the template
     * @returns: 
     *    - .0: the value
     *    - .1: the score of the call
     * @throws:
     *    - &ErrorMsg: if the call is impossible (for example left is not a valid template)    
     */
    pub def validateCallValue (self, dmut context : &Validator, loc : &Word, left : &Value, rights : [&Generator])-> &TemplateRewriter
        throws &ErrorMsg
    {
        match left {
            x : &TemplateRefValue => {
                return self.validateCallTemplateRefValue (alias context, loc, x, rights);
            }
            z : _ => {
                throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_TEMPLATE_CALL, left, rights), notes-> [ErrorMsg::note (z.getLoc (), ""s8)]);
            }
        }
    }


    /**
     * Validate a template call that creates a value
     * @params: 
     *    - context: the context of the validation
     *    - loc: the location of the call
     *    - left: the value that is template called
     *    - rights: the template arguments passed to the template
     * @returns: 
     *    - .0: the value
     *    - .1: the score of the call
     * @throws:
     *    - &ErrorMsg: if the call is impossible
     */
    pub def validateCallTemplateRefValue (self, dmut context : &Validator, _ : &Word, left : &TemplateRefValue, rights : [&Generator])-> &TemplateRewriter
        throws &ErrorMsg
    {
        let templateParams = left.getSymbol ().getContent ().getParameters ();
        let (mapper, consumed) = self.validateFromExplicit (alias context, templateParams, rights);

        if (consumed < rights.len) {
            throw ErrorMsg::fatal (rights[consumed].getLoc (), format (ValidateErrorMessage::TEMPLATE_REST, rights[consumed .. $]), notes-> [ErrorMsg::note (left.getSymbol ().getLoc (), format (ValidateErrorMessage::VALIDATING_SYMBOL, left))]);
        } 

        TemplateRewriter::new (mapper) // return the rewriter that can then be used to finalize the syntax rewritting before semantic validation                
    }

    /**
     * Validate a sort of template call, that was made inside a template checker
     * @params: 
     *    - context: the context of the validation
     *    - loc: the location of the template check
     *    - params: the template parameters of the check (rules)
     *    - rights: the arguments passed to the checker (already validated)
     * @returns: the template rewritter
     * @throws:
     *    - &ErrorMsg: if the specialization failed
     */
    pub def validateFromTemplateChecker (self, dmut context : &Validator, loc : &Word, params : [&Expression], rights : [&Generator])-> &TemplateRewriter
        throws &ErrorMsg
    {
        let (mapper, consumed) = self.validateFromExplicit (alias context, params, rights);

        if (consumed < rights.len) {
            throw ErrorMsg::fatal (rights[consumed].getLoc (), format (ValidateErrorMessage::TEMPLATE_REST, rights[consumed .. $]), notes-> [ErrorMsg::note (loc, ""s8)]);
        } 

        TemplateRewriter::new (mapper) // return the rewriter that can then be used to finalize the syntax rewritting before semantic validation                
    }
    
    /**
     * ================================================================================
     * ================================================================================
     * =========================           IMPLICIT           =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a template specialization from an implicit call
     * @params: 
     *    - context: the context of the validation
     *    - loc: the location of the specialization
     *    - left: the value to specialize
     *    - rights: the list of values used for specialization
     * @returns: 
     *    - .0: the template rewriter created by specialization
     *    - .1: the transformed parameters for correct specialization (for example variadic params are put inside tuples)
     * @throws:
     *    - &ErrorMsg: if the specialization failed
     */
    pub def validateImplicitValue (self, dmut context : &Validator, loc : &Word, left : &TemplateRefValue, rights : [&Value])-> (&TemplateRewriter, [&Value])
        throws &ErrorMsg
    {
        match left.getSymbol ().getContent ().getContent () {
            f : &FunctionDecl => {
                let dmut sym = context:.getSymbolFromRef (left.getSymbol ());
                context:.pushReferent (alias sym);                
                context:.enterForeign (isFnBody-> false);
                
                let ret = {
                    self.validateFromImplicit (alias context, loc, left.getSymbol ().getContent ().getParameters (), f.getFunctionProto ().getParameters (), rights)                
                } catch {
                    err : &ErrorMsg => {                        
                        context:.exitForeign ();
                        context:.popReferent ();
                        throw err;
                    }
                }

                context:.exitForeign ();
                context:.popReferent ();
                return ret;
            }
            x : _ => {
                println (format ("TODO : %", x));
                __pragma!panic ();
            }
        }
    }

    /**
     * Perform an implicit template specialization from a list of syntax parameters 
     * @params: 
     *    - context: the context of the validation
     *    - loc: the location of the template call
     *    - templates: the list of template parameters
     *    - parameters: the list of syntax parameters (basically a list of var decl)
     *    - rights: the list of values used to call the function
     * @returns: 
     *    - .0; the template rewritter of the specialization
     *    - .1: the transformed parameters for correct specialization (for example variadic params are put inside tuples)
     * @throws:
     *    - &ErrorMsg: if the specialization fails
     */
    def validateFromImplicit (self, dmut context : &Validator, loc : &Word, templates : [&Expression], parameters : [&Expression], rights : [&Value])-> (&TemplateRewriter, [&Value])
        throws &ErrorMsg
    {
        let dmut types = Vec!{&Type}::new ();
        for it in rights { types:.push (it.getType ().clone (isMutable-> false)); }

        if (parameters.len > types.len ()) { __pragma!panic (); } // where ??

        let dmut finalParams = Vec!{&Value}::new ();
        let mut consumed = 0u32;
        let dmut globalMapper = TemplateMapper::new ();
        let rewriter = TemplateRewriter::new (globalMapper);
        let mut syntTemplate = templates;

        for it in 0us .. parameters.len {
            // Rewritte the current parameter that will be specialized to remove any template that was already validated
            let currentParam = rewriter.rewrite (parameters[it]);
            let rest = types.len () - consumed; // number of types that still can be consumed (Note that there can be more types than parameters in case of variadics)
            let syntaxRest = (parameters.len - it) - 1us; // The number of parameters that where not validated yet, minus the current one
            let consomableTypes = types[][consumed .. consumed + (rest - syntaxRest)]; // The list of types that can be associated to the current parameter (can be more than 1 in case of variadics)

            {
                let (mapper, localConsumed) = self.validateParamTemplateFromImplicit (alias context, syntTemplate, currentParam, consomableTypes);
                globalMapper:.merge (mapper);
                if (localConsumed == 1us) finalParams:.push (rights[consumed]); 
                else {
                    let tupleTypes  = types[][consumed .. consumed + localConsumed];
                    let tupleValues = rights [consumed .. consumed + localConsumed];
                    finalParams:.push (TupleValue::new (currentParam.getLoc (), TupleType::new (currentParam.getLoc (), tupleTypes), tupleValues));
                }
                
                consumed += localConsumed;
                syntTemplate = rewriter.replaceSyntaxTempl (syntTemplate);
            } catch {
                err : &ErrorMsg => {
                    if (globalMapper.getMapping ().len () != 0us) {
                        let note = ErrorMsg::note (loc, format (ValidateErrorMessage::TEMPLATE_SPE, globalMapper));
                        throw ErrorMsg::list ([note, err]);
                    } else throw err;
                }
            }                        
        }

        (rewriter, finalParams[])
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================           EXPLICIT           =========================
     * ================================================================================
     * ================================================================================
     */
    
    /**
     * Validate a template explicit specialization
     * @params: 
     *    - context: the context of the validation
     *    - params: the template parameters
     *    - values: the list of compile time knwon values passed to the template     
     * @returns: 
     *     - .0: a template mapper containing the template specialization
     *     - .1: the number of values that were consumed during the specialization
     * @throws: 
     *    - &ErrorMsg: if the specialization is impossible
     */
    pub def validateFromExplicit (self, dmut context : &Validator, params : [&Expression], values : [&Generator])-> (&TemplateMapper, usize)
        throws &ErrorMsg
    {
        let mut consumed = 0us;
        let dmut globalMapper = TemplateMapper::new ();
        let rewriter = TemplateRewriter::new (globalMapper);
        let mut syntTemplate = params;
        
        while (consumed < values.len && syntTemplate.len != 0us) {
            // Create a slice on template arguments that have not been used yet
            // Template arguments are used in the order they are written, but sometimes several at a time
            let currentElems = values[consumed .. $];

            // Create a slice on the template parameters that are not directly referenced
            // Only the first template parameter is explicitly set, but maybe it will also set other parameters
            let rest = syntTemplate[1us .. $]; 

            {
                // Perform the explicit template validation, with the given template parameters, and call arguments
                let (mapper, localConsumed) = self.validateParamTemplateFromExplicit (alias context, rest, syntTemplate[0], currentElems);

                globalMapper:.merge (mapper);
                consumed += localConsumed;
                syntTemplate = rewriter.replaceSyntaxTempl (syntTemplate);
            } catch {
                err : &ErrorMsg => { // TODO partial resolution note
                    throw err; 
                }
            }
        }
        
        (globalMapper, consumed)
    }

    /**
     * Validate a template parameter from an explicit call
     * @params: 
     *    - context: the context of the validation
     *    - syntTemplate: the template parameters
     *    - current: the template parameter to validate
     *    - values: the values passed to the template call
     * @returns:
     *    - .0: the mapper containing the template specialisation
     *    - .1: the number of values that were consumed
     * @throws:
     *    - &ErrorMsg: if the specialization is impossible
     */
    def validateParamTemplateFromExplicit (self, dmut context : &Validator, syntaxTemplate : [&Expression], current : &Expression, values : [&Generator])-> (&TemplateMapper, usize)
        throws &ErrorMsg
    {
        match current {
            v : &VarExpr => {
                return self.validateVarExprFromExplicit (alias context, v, values);
            }
            ov : &TemplateOfVarExpr => {
                match ov.getKind () {
                    TemplateOfVarType::OF => {
                        return self.validateOfVarExprFromExplicit (alias context, syntaxTemplate, ov, values);
                    }
                    TemplateOfVarType::IMPL => {
                        return self.validateImplVarExprFromExplicit (alias context, syntaxTemplate, ov, values);
                    }
                    _ => {
                        return self.validateOverVarExprFromExplicit (alias context, syntaxTemplate, ov, values);
                    }
                }
            }
            t : &TemplateVarExpr => {
                return self.validateTemplateVarExprFromExplicit (alias context, syntaxTemplate, t, values);
            }
            v : &TemplateVariadicVarExpr => {
                return self.validateTemplateVariadicFromExplicit (alias context, syntaxTemplate, v, values);
            }
            _ : &VarDeclExpr => {
                __pragma!panic ();
            }
            _ => {
                println (format ("TODO %", current));
                __pragma!panic ();
            }
        }
    }    

    /**
     * Validate an explicit template specialization where template parameter is a simple varexpr
     * @params: 
     *    - context: the context of the validation
     *    - v: the var expression
     *    - values: the list of values passed to the template call
     * @returns:
     *    - .0: the template parameter specialization
     *    - .1: the number of consumed parameters (should be 1us)
     * @throws:
     *    - &ErrorMsg: if the values cannot be used to specialize the template parameter
     */
    def validateVarExprFromExplicit (self, dmut context : &Validator, v : &VarExpr, values : [&Generator])-> (&TemplateMapper, usize)
        throws &ErrorMsg
    {
        match values [0] {
            t : &Type => {
                context.verifyNotIsNativeType (v.getLoc ());
                let dmut mapper = TemplateMapper::new (score-> TemplateScore::VAR);
                mapper:.insert (v.getLoc ().str (), TypeWrapperExpr::new (t.getLoc (), t));
                
                return (mapper, 1us);
            }
            _ => {                  
                throw ErrorMsg::fatal (values[0].getLoc (), ValidateErrorMessage::USE_AS_TYPE,
                                       notes-> [ErrorMsg::note (v.getLoc (), ""s8)]);
            }
        }
    }


    /**
     * ================================================================================
     * ================================================================================
     * =========================       EXPLICIT OF VAR        =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate an explicit template specialization where template parameter is an of var
     * @params: 
     *    - context: the context of the validation
     *    - v: the template of var to validate
     *    - values: the list of values passed to the template call
     * @returns:
     *    - .0: the template parameter specialization
     *    - .1: the number of consumed parameters (should be 1us)
     * @throws:
     *    - &ErrorMsg: if the values cannot be used to specialize the template parameter
     */
    def validateOfVarExprFromExplicit (self, dmut context : &Validator, alls : [&Expression], ofV : &TemplateOfVarExpr, types : [&Generator])-> (&TemplateMapper, usize)
        throws &ErrorMsg
    {
        match types [0us] {
            t : &Type => {
                let mapper = self.validateOfVarExprFromExplicit (alias context, alls, ofV.getSpecialization (), t);
                let dmut retMapper = TemplateMapper::new (score-> TemplateScore::VAR);
                retMapper:.merge (mapper);
                retMapper:.insert (ofV.getLoc ().str (), TypeWrapperExpr::new (t.getLoc (), t));

                return (retMapper, 1us);
            }
            _ => {
                throw ErrorMsg::fatal (types[0].getLoc (), ValidateErrorMessage::USE_AS_TYPE,
                                       notes-> [ErrorMsg::note (ofV.getLoc (), ""s8)]);
            }
        }
    }
    
    /**
     * Validate an explicit template specialization where template parameter is an of var
     * @params: 
     *    - context: the context of the validation
     *    - expr: the content of the of var to validate
     *    - values: the list of values passed to the template call
     * @returns: the template parameter specialization
     * @throws:
     *    - &ErrorMsg: if the values cannot be used to specialize the template parameter
     */
    def validateOfVarExprFromExplicit (self, dmut context : &Validator, alls : [&Expression], expr : &Expression, type : &Type)-> &TemplateMapper
        throws &ErrorMsg
    {
        match expr {
            var : &VarExpr => {
                return self.validateOfVarInnerExplicit (alias context, alls, var, type);
            }
            un : &UnaryExpr => {
                return self.validateOfUnaryInnerExplicit (alias context, alls, un, type);
            }
            lst : &ListExpr => {
                if (lst.isArray ()) {
                    return self.validateOfSliceInnerExplicit (alias context, alls, lst, type);
                } else {
                    return self.validateOfTupleInnerExplicit (alias context, alls, lst, type);
                }
            }
            slc : &SliceAllocatorExpr => {
                return self.validateOfSliceAllocInnerExplicit (alias context, alls, slc, type);
            }
            spe : _ => {
                println ("TODO of var : ", format ("'%' is ", spe), spe);
                __pragma!panic ();
            }                    
        }    
    }
    
    /**
     * Validate an explicit inner part of an of var, where the inner part is simply a VarExpr (A of T)
     * @params: 
     *    - context: the context of the validation
     *    - alls: the list of template parameters that are not validated yet
     *    - v: the inner part of the ofvar (=> ofV.getSpecialization ())
     *    - values: the list of values passed to the template call
     * @returns:
     *    - .0: the template parameter specialization
     *    - .1: the number of consumed parameters (should be 1us)
     * @throws:
     *    - &ErrorMsg: if the values cannot be used to specialize the template parameter
     */
    def validateOfVarInnerExplicit (self, dmut context : &Validator, alls : [&Expression], v : &VarExpr, type : &Type)-> &TemplateMapper
        throws &ErrorMsg
    {
        let dmut retMapper = TemplateMapper::new (score-> TemplateScore::VAR);
        
        // Search the inner value (A of T => search T in the parameters)
        let expr = self.findExpression (v.getLoc ().str (), alls);
        if !expr.isOf!{&EmptyExpression} () {
            let (mapper, _) = self.validateParamTemplateFromExplicit (alias context, alls, expr, [cast!(&Generator) (type)]);
            retMapper:.merge (mapper);            
        }
        
        // Complete the type, and verify that it is correctly set, maybe for function ptr this will not work (thus TODO)
        let finalType = self.performTemplateRewrite (v, retMapper);
        let ofType = context:.validateType (finalType);
        context:.verifyCompatibleType (v.getLoc (), type.getLoc (), ofType, type);

        return retMapper;
    }

    
    /**
     * Validate an explicit inner part of an of var, where the inner part is a UnaryExpr (A of &T)
     * @params: 
     *    - context: the context of the validation
     *    - alls: the list of template parameters that are not validated yet
     *    - un: the unary expression (=> ofV.getSpecialization ())
     *    - values: the list of values passed to the template call
     * @returns: the template parameter specialization
     * @throws:
     *    - &ErrorMsg: if the specialization failed
     */
    def validateOfUnaryInnerExplicit (self, dmut context : &Validator, alls : [&Expression], un : &UnaryExpr, type : &Type)-> &TemplateMapper
        throws &ErrorMsg
    {
        // Unary are generaly &X, that can be either a pointer or a classptr type
        let inner : &Type = match type {
            cl : &ClassPtrType => { cast!{&Type} (cl.getInner ()) }
            ct : &CompoundType => {
                if (ct.getInners ().len == 1us) {
                    ct.getInners ()[0us]
                } else {
                    throw ErrorMsg::fatal (un.getLoc (), format (ValidateErrorMessage::TEMPLATE_SPECIALIZATION_FAILS, un, type));
                }
            }
            _ => {
                throw ErrorMsg::fatal (un.getLoc (), format (ValidateErrorMessage::TEMPLATE_SPECIALIZATION_FAILS, un, type));
            }
        };

        let mapper = self.validateOfVarExprFromExplicit (alias context, alls, un.getOperand (), inner);
        
        // Complete the type, and verify that it is correctly set, maybe for function ptr this will not work (thus TODO)
        let finalType = self.performTemplateRewrite (un, mapper);
        let ofType = context:.validateType (finalType);
        context:.verifyCompatibleType (un.getLoc (), type.getLoc (), ofType, type);

        return mapper;
    }

    /**
     * Validate an explicit inner part of an of var, where the inner part is a slice ListExpr (A of [T])
     * @params: 
     *    - context: the context of the validation
     *    - alls: the list of template parameters that are not validated yet
     *    - ofV: the of var expression
     *    - lst: the lsit expression (=> ofV.getSpecialization ())
     *    - type: the type passed to the template call
     * @returns: 
     *    - .0: the template parameter specialization
     *    - .1: the number of consumed parameters (should be 1us)
     * @throws:
     *    - &ErrorMsg: if the specialization failed
     */
    def validateOfSliceInnerExplicit (self, dmut context : &Validator, alls : [&Expression], lst : &ListExpr, type : &Type)-> &TemplateMapper
        throws &ErrorMsg
    {
        if (lst.getParameters ().len != 1us)  throw ErrorMsg::fatal (lst.getLoc (), ValidateErrorMessage::USE_AS_TYPE); // the template is malformed

        match type {
            slc : &SliceType => { // This verification is pretty straightfoward, we just need to verify that we have a slice, and validate what is inner the template slice
                let mapper = self.validateOfVarExprFromExplicit (alias context, alls, lst.getParameters ()[0us], slc.getInners ()[0us]); // so, we validate the inner part
                
                let finalType = self.performTemplateRewrite (lst, mapper);
                let ofType = context:.validateType (finalType); 
                context:.verifyCompatibleType (lst.getLoc (), type.getLoc (), ofType, type); // and verify that the two elements are equivalent

                return mapper;
            }
            _ => {
                throw ErrorMsg::fatal (type.getLoc (), format (ValidateErrorMessage::NOT_A_SLICE, type),
                                       notes-> [ErrorMsg::note (lst.getLoc (), ""s8)]);
                
            }
        }
    }

    /**
     * Validate an explicit inner part of an of var, where the inner part is a tuple ListExpr (A of (T, U, V))
     * @params: 
     *    - context: the context of the validation
     *    - alls: the list of template parameters that are not validated yet
     *    - lst: the list expression (=> ofV.getSpecialization ())
     *    - type: the type passed to the template call
     * @returns: the template parameter specialization
     * @throws:
     *    - &ErrorMsg: if the specialization failed
     */
    def validateOfTupleInnerExplicit (self, dmut context : &Validator, alls : [&Expression], lst : &ListExpr, type : &Type)-> &TemplateMapper
        throws &ErrorMsg
    {
        match type {
            t : &TupleType => {
                // Because the inner elements of the template tuple could be variadic templates, we must manage it
                let dmut retMapper = TemplateMapper::new (score-> TemplateScore::VAR);
                let rewriter = TemplateRewriter::new (retMapper);
                let mut consumed = 0us;

                // For the specialization to work, we need to have more or same number of types in the tuple than in the template => (T of (U, J...), J),  call!{(i32, i32, i32)} 
                if (lst.getParameters ().len > t.getInners ().len) throw ErrorMsg::fatal (t.getLoc (), format (ValidateErrorMessage::MISMATCH_TUPLE_ARITY, t.getInners ().len, lst.getParameters ().len),
                                                                                          notes-> [ErrorMsg::note (lst.getLoc (), ""s8)]);
                
                for i in 0us .. lst.getParameters ().len {
                    let currentParam = rewriter.rewrite (lst.getParameters ()[i]); // maybe some resolution already happened, we don't want to have collision in the mapper (e.g. (T of (U, U, U), U))
                    
                    // Give all the types that rests for variadics, I don't see a better way, because last elements could be other things than templates, so variadics must be the last template elements
                    let consomableTypes = t.getInners ()[consumed .. $]; 
                    let (mapper, localConsumed) = self.validateParamTemplateFromExplicit (alias context, alls, currentParam, consomableTypes);

                    // Merging the mapper
                    retMapper:.merge (mapper);
                    consumed += localConsumed; // increment the number of used types
                }

                {
                    // we don't check if all types of "type" were used,
                    // there is not need, because we validate the template, and check if it is equivalent to "type", so if some elements of "type" were unused, it should fail here
                    let finalType = self.performTemplateRewrite (lst, retMapper); 
                    let ofType = context:.validateType (finalType); 
                    context:.verifyCompatibleType (lst.getLoc (), type.getLoc (), ofType, type);
                } catch {
                    err : &ErrorMsg => {
                        throw ErrorMsg::note (lst.getLoc (), format (ValidateErrorMessage::TEMPLATE_SPE, retMapper), notes-> [err]);
                    }
                }
                
                return retMapper;
            }
            _ => {
                throw ErrorMsg::fatal (type.getLoc (), format (ValidateErrorMessage::NOT_A_TUPLE, type),
                                       notes-> [ErrorMsg::note (lst.getLoc (), ""s8)]);
            }
        }
    }


    /**
     * Validate an explicit inner part of an of var, where the inner part is a slice allocator (A of [T ; N])
     * @params: 
     *    - context: the context of the validation
     *    - alls: the list of template parameters that are not validated yet
     *    - slc: the slice allocator (=> ofV.getSpecialization ())
     *    - type: the type passed to the template call
     * @returns: the template parameter specialization
     * @throws:
     *    - &ErrorMsg: if the specialization failed
     */
    def validateOfSliceAllocInnerExplicit (self, dmut context : &Validator, alls : [&Expression], slc : &SliceAllocatorExpr, type : &Type)-> &TemplateMapper
        throws &ErrorMsg
    {
        // This verification is close to slices, but with the verification of the size of the alloc that must be known at compile time
        match type {
            arr : &ArrayType => {
                let dmut retMapper = TemplateMapper::new (score-> TemplateScore::VAR);
                
                let typeMapper = self.validateOfVarExprFromExplicit (alias context, alls, slc.getValue (), arr.getInners ()[0us]);
                retMapper:.merge (typeMapper);
                
                match slc.getSize () {
                    v : &VarExpr => {
                        let expr = self.findExpression (v.getLoc ().str (), alls);
                        if !expr.isOf!{&EmptyExpression} () {
                            let (valMapper, _) = self.validateParamTemplateFromExplicit (alias context, alls, expr, [cast!(&Generator) (arr.getSize ())]);
                            retMapper:.merge (valMapper);            
                        }
                    }
                }


                let finalType = self.performTemplateRewrite (slc, retMapper);
                let ofType = context:.validateType (finalType); 
                context:.verifyCompatibleType (slc.getLoc (), type.getLoc (), ofType, type);

                return retMapper;                
            }
            _ => {
                throw ErrorMsg::fatal (type.getLoc (), format (ValidateErrorMessage::NOT_AN_ARRAY, type),
                                       notes-> [ErrorMsg::note (slc.getLoc (), ""s8)]);
            }
        }
    }
    
    /**
     * ================================================================================
     * ================================================================================
     * =========================      EXPLICIT OVER VAR       =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate an explicit template specialization where template parameter is an over var
     * @params: 
     *    - context: the context of the validation
     *    - v: the template of var to validate
     *    - values: the list of values passed to the template call
     * @returns:
     *    - .0: the template parameter specialization
     *    - .1: the number of consumed parameters (should be 1us)
     * @throws:
     *    - &ErrorMsg: if the values cannot be used to specialize the template parameter
     */
    def validateOverVarExprFromExplicit (self, dmut context : &Validator, alls : [&Expression], v : &TemplateOfVarExpr, values : [&Generator])-> (&TemplateMapper, usize)
        throws &ErrorMsg
    {
        context;
        alls;
        v;
        values;        
        __pragma!fake_throw (&ErrorMsg);
        __pragma!panic ();
    }
    
    /**
     * ================================================================================
     * ================================================================================
     * =========================      EXPLICIT IMPL VAR       =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate an explicit template specialization where template parameter is an impl var
     * @params: 
     *    - context: the context of the validation
     *    - v: the template of var to validate
     *    - values: the list of values passed to the template call
     * @returns:
     *    - .0: the template parameter specialization
     *    - .1: the number of consumed parameters (should be 1us)
     * @throws:
     *    - &ErrorMsg: if the values cannot be used to specialize the template parameter
     */
    def validateImplVarExprFromExplicit (self, dmut context : &Validator, alls : [&Expression], v : &TemplateOfVarExpr, values : [&Generator])-> (&TemplateMapper, usize)
        throws &ErrorMsg
    {
        match values [0] {
            _ : &ClassPtrType => { // only class types can implement traits
                context;
                alls;
                __pragma!panic ();
            }
            t : _ => {
                throw ErrorMsg::fatal (t.getLoc (), ValidateErrorMessage::NOT_A_CLASS,
                                       notes-> [ErrorMsg::note (v.getLoc (), ""s8)]);
            }
        }
    }    

    /**
     * ================================================================================
     * ================================================================================
     * =========================    EXPLICIT TEMPLATE VAR     =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate an explicit template specialization where template parameter is an template var (struct T, class T, ...)
     * @params: 
     *    - context: the context of the validation
     *    - v: the template of var to validate
     *    - values: the list of values passed to the template call
     * @returns:
     *    - .0: the template parameter specialization
     *    - .1: the number of consumed parameters (should be 1us)
     * @throws:
     *    - &ErrorMsg: if the values cannot be used to specialize the template parameter
     */
    def validateTemplateVarExprFromExplicit (self, dmut _ : &Validator, _ : [&Expression], v : &TemplateVarExpr, values : [&Generator])-> (&TemplateMapper, usize)
        throws &ErrorMsg
    {
        match values [0] {
            t : &Type => { // TemplateVarType is here to check the kind of type that is used, ("alias", "class", "struct" and "tuple"), so it has to be a type
                match v.getKind () {
                    TemplateVarType::ALIAS => {
                        if (!t.needExplicitAlias ()) { // "alias", means its an aliasable type
                            throw ErrorMsg::fatal (values[0].getLoc (), format (ValidateErrorMessage::NOT_ALIASABLE, t),
                                                   notes-> [ErrorMsg::note (v.getLoc (), ""s8)]);
                        }
                    }
                    TemplateVarType::CLASS => { // "class" must be a class type
                        if (!t.isOf!{&ClassPtrType} ()) {
                            throw ErrorMsg::fatal (values[0].getLoc (), format (ValidateErrorMessage::NOT_A_CLASS, t),
                                                   notes-> [ErrorMsg::note (v.getLoc (), ""s8)]);
                        }
                    }
                    TemplateVarType::STRUCT => { // "struct" must be a struct type
                        if (!t.isOf!{&StructType} ()) {
                            throw ErrorMsg::fatal (values[0].getLoc (), format (ValidateErrorMessage::NOT_A_STRUCT, t),
                                                   notes-> [ErrorMsg::note (v.getLoc (), ""s8)]);
                        }
                    }
                    TemplateVarType::TUPLE => { // "tuple" must be a tuple type
                        if (!t.isOf!{&TupleType} ()) {
                            throw ErrorMsg::fatal (values[0].getLoc (), format (ValidateErrorMessage::NOT_A_TUPLE, t),
                                                   notes-> [ErrorMsg::note (v.getLoc (), ""s8)]);
                        }
                    }
                }

                // There was no problem, so we can return a mapper, with the type association
                let dmut retMapper = TemplateMapper::new (score-> TemplateScore::VAR); // normal score
                retMapper:.insert (v.getLoc ().str (), TypeWrapperExpr::new (t.getLoc (), t)); // insert the mapping
                return (retMapper, 1us); // 1 type consumed
            }
            _ => { // a value was passed, no association possible here
                throw ErrorMsg::fatal (values [0].getLoc (), ValidateErrorMessage::USE_AS_TYPE,
                                       notes-> [ErrorMsg::note (v.getLoc (), ""s8)]);
            }
        }
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================  VARIADIC TEMPLATE EXPLICIT  =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a template variadic var
     * @params: 
     *    - context: the context of the validation
     *    - alls: the list of template parameters of the current specialization
     *    - v: the variadic to validate
     *    - values: the list of values/types to pass to the variadic template
     * @returns: 
     *    - .0: the template parameter specialization
     *    - .1: the number of consumed parameters (should be 1us)
     * @throws:
     *    - &ErrorMsg: if the values cannot be used to specialize the template parameter
     */
    def validateTemplateVariadicFromExplicit (self, dmut _ : &Validator, _ : [&Expression], v : &TemplateVariadicVarExpr, values : [&Generator])-> (&TemplateMapper, usize)
        throws &ErrorMsg
    {
        // Not a complex function, simply transform all the types in 'values' into a template type
        let dmut retTypes = Vec!{&Type}::new ();
        for i in 0us .. values.len { 
            match values [i] {
                t : &Type => { retTypes:.push (t); }
                _ => { // only types can be used to perform a type specialization
                    throw ErrorMsg::fatal (values [i].getLoc (), ValidateErrorMessage::USE_AS_TYPE,
                                           notes-> [ErrorMsg::note (v.getLoc (), ""s8)]);
                }
            }
        }
        
        let tupleType = if (retTypes.len () != 1us) {
            cast!{&Type} (TupleType::new (v.getLoc (), retTypes[])) // Create the type to associate to the template
        } else {
            retTypes[][0us] // if there is only one type in the tuple, then it is not a tuple
        };
        
        let dmut retMapper = TemplateMapper::new (score-> TemplateScore::VAR); 
        retMapper:.insert (v.getLoc ().str (), TypeWrapperExpr::new (tupleType.getLoc (), tupleType)); // insert it in the mapper

        return (retMapper, values.len); // consumed as many types as there are to consumed
    }       
    
    /**
     * ================================================================================
     * ================================================================================
     * =========================           IMPLICIT           =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a template implicit validation of a parameter that may contain template variables
     * @params: 
     *    - context: the context of the validation
     *    - templates: the list of template associated to the parameter
     *    - parameter: the syntax expression (basically a vardecl) that contains a type that may contain template variable
     *    - types: the list of type that can be associated to the templates
     * @returns:
     *    - .0: the mapper in case of validation (used to create a valid rewriter)
     *    - .1: the number of types that were consumed during the validation
     * @throws:
     *    - &ErrorMsg: if the specialization failed
     */
    def validateParamTemplateFromImplicit (self, dmut context : &Validator, templates : [&Expression], param : &Expression, types : [&Type])-> (&TemplateMapper, u32)
        throws &ErrorMsg
    {
        match param {
            x : &VarDeclExpr => {
                match x.getType () { // we want to transform its type from implicit specialization
                    EmptyExpression () => { // It has no type
                        (TemplateMapper::new (), 0u32)
                    }
                    UnitExpr () => { // Also no type, 
                        (TemplateMapper::new (), 0u32) // we return an empty template mapper, because the specialization works, it just gives no information
                    }
                    type : _ => { // There is possible information, if the type contains templates, so we validate it
                        self.validateTypeFromImplicit (alias context, templates, type, types)
                    }
                }
            }
            _ => __pragma!panic ();  // necessarily a vardecl, implicit specialization are for function proto, ctor, and structs, so always vardecls are usable, we can't make an implicit specialization without them that is the premise
        }
    }

    /**
     * Validate the implicit specialization of 'typeExpr' from 'types' using 'templates' as template parameters 
     * @params: 
     *    - context: the context of the validation
     *    - templates: the list of tempalte to specialize
     *    - typeExpr: a type foudn during implicit validation (inside vardecl for example)
     *    - types: the types that will be used to transform typeExpr, and templates into specialized values
     * @returns:
     *    - .0: the mapper in case of validation (used to create a valid rewriter)
     *    - .1: the number of types that were consumed during the validation
     * @throws:
     *    - &ErrorMsg: if the specialization failed
     */
    def validateTypeFromImplicit (self, dmut context : &Validator, templates : [&Expression], typeExpr : &Expression, types : [&Type])-> (&TemplateMapper, u32)
        throws &ErrorMsg
    {
        match typeExpr {
            v : &VarExpr => {
                return self.validateTypeFromImplitVarExpr (alias context, templates, v, types);
            }           
            _ => {
                context:.validateType (typeExpr);
                return (TemplateMapper::new (), 1u32);
            }
        }
    }    

    /**
     * Validate the implicit specialization of 'var' from 'types' using 'templates' as template parameters
     * @params: 
     *    - context: the context of the validation
     *    - templates: the list of tempalte to specialize
     *    - var: a var expr describing a type
     *    - types: the types that will be used to transform typeExpr, and templates into specialized values
     * @returns:
     *    - .0: the mapper in case of validation (used to create a valid rewriter)
     *    - .1: the number of types that were consumed during the validation
     * @throws:
     *    - &ErrorMsg: if the specialization failed
     */
    def validateTypeFromImplitVarExpr (self, dmut context : &Validator, templates : [&Expression], var : &VarExpr, types : [&Type])-> (&TemplateMapper, u32)
        throws &ErrorMsg
    {
        let tmp = self.findExpression (var.getLoc ().str (), templates);
        match tmp {
            EmptyExpression () => {
                return (TemplateMapper::new (), 1u32);
            }
            _ => {
                let (ret, nb) = self.validateParamTemplateFromExplicit (alias context, templates, tmp, types);
                (ret, cast!u32 (nb))
            }
        }
    }
    
    /**
     * ================================================================================
     * ================================================================================
     * =========================            COMMON            =========================
     * ================================================================================
     * ================================================================================
     */


    /**
     * Create a new expression where template specialization or correclty rewritten
     * @params:
     *     - expr: the expression to rewrite
     *     - mapper: the template specialization
     * @returns: the rewritten expr
     */
    def performTemplateRewrite (self, expr : &Expression, mapper : &TemplateMapper)-> &Expression {    
        TemplateRewriter::new (mapper).rewrite (expr)
    }

    /**
     * Search in the list of template parameters a parameter whose name is 'name'
     * @params: 
     *    - name: the name to find
     *    - alls: the list of template params
     * @returns: an expression from 'alls' whose name is 'name' (&EmptyExpression if the expression does not exists)
     */
    def findExpression (self, name : [c8], alls : [&Expression])-> &Expression {   
        for i in alls match i {
            v : &VarExpr => {
                if v.getLoc ().str () == name {
                    return v;
                }
            }
            v : &TemplateOfVarExpr => {
                if v.getLoc ().str () == name {
                    return v;
                }
            }
            v : &TemplateVariadicVarExpr => {
                if v.getLoc ().str () == name {
                    return v;
                }
            }
            v : &TemplateVarExpr => {
                if v.getLoc ().str () == name {
                    return v;
                }
            }
        }


        EmptyExpression::new ()
    }
          
}
