mod ymirc::semantic::validator::template::solver;

import ymirc::semantic::validator::visitor;
import ymirc::semantic::validator::template::mapper;
import ymirc::semantic::validator::template::rewrite;
import ymirc::semantic::validator::errors;
import ymirc::semantic::symbol::template;
import ymirc::syntax::declaration::protection;
import ymirc::syntax::expression::_;
import ymirc::syntax::declaration::_;

import ymirc::syntax::keys;
import ymirc::semantic::generator::_;
import ymirc::semantic::symbol::_;
import ymirc::errors::_;
import ymirc::utils::format;
import ymirc::lexing::word;

import std::collection::vec;
import std::io, std::fs::path;

/**
 * The template validator is the template responsible for template symbol validation
 */
pub class TemplateSolver {

    /**
     * Create a new empty validator
     */
    pub self () {}
    
    /**
     * ================================================================================
     * ================================================================================
     * =========================             CALL             =========================
     * ================================================================================
     * ================================================================================
     */
    
    /**
     * Validate a template call that creates a value (function for example, or aka, etc.)
     * @params: 
     *    - context: the context of the validation
     *    - loc: the location of the call
     *    - left: the value that is template called
     *    - rights: the template arguments passed to the template
     * @returns: 
     *    - .0: the value
     *    - .1: the score of the call
     * @throws:
     *    - &ErrorMsg: if the call is impossible (for example left is not a valid template)    
     */
    pub def validateCallValue (self, dmut context : &Validator, loc : &Word, left : &Value, rights : [&Generator])-> &TemplateRewriter
        throws &ErrorMsg
    {
        match left {
            x : &TemplateRefValue => {
                return self.validateCallTemplateRefValue (alias context, loc, x, rights);
            }
            z : _ => {
                throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_TEMPLATE_CALL, left, rights), notes-> [ErrorMsg::note (z.getLoc (), ""s8)]);
            }
        }
    }


    /**
     * Validate a template call that creates a value
     * @params: 
     *    - context: the context of the validation
     *    - loc: the location of the call
     *    - left: the value that is template called
     *    - rights: the template arguments passed to the template
     * @returns: 
     *    - .0: the value
     *    - .1: the score of the call
     * @throws:
     *    - &ErrorMsg: if the call is impossible
     */
    pub def validateCallTemplateRefValue (self, dmut context : &Validator, _ : &Word, left : &TemplateRefValue, rights : [&Generator])-> &TemplateRewriter
        throws &ErrorMsg
    {
        let templateParams = left.getSymbol ().getContent ().getParameters ();
        let (mapper, consumed) = self.validateFromExplicit (alias context, templateParams, rights);

        if (consumed < rights.len) {
            throw ErrorMsg::fatal (rights[consumed].getLoc (), format (ValidateErrorMessage::TEMPLATE_REST, rights[consumed .. $]), notes-> [ErrorMsg::note (left.getSymbol ().getLoc (), format (ValidateErrorMessage::VALIDATING_SYMBOL, left))]);
        } 

        TemplateRewriter::new (mapper) // return the rewriter that can then be used to finalize the syntax rewritting before semantic validation                
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================           IMPLICIT           =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a template specialization from an implicit call
     * @params: 
     *    - context: the context of the validation
     *    - loc: the location of the specialization
     *    - left: the value to specialize
     *    - rights: the list of values used for specialization
     * @returns: 
     *    - .0: the template rewriter created by specialization
     *    - .1: the transformed parameters for correct specialization (for example variadic params are put inside tuples)
     * @throws:
     *    - &ErrorMsg: if the specialization failed
     */
    pub def validateImplicitValue (self, dmut context : &Validator, loc : &Word, left : &TemplateRefValue, rights : [&Value])-> (&TemplateRewriter, [&Value])
        throws &ErrorMsg
    {
        match left.getSymbol ().getContent ().getContent () {
            f : &FunctionDecl => {
                let dmut sym = context:.getSymbolFromRef (left.getSymbol ());
                context:.pushReferent (alias sym);
                context:.enterForeign (isFnBody-> false);
                let ret = {
                    self.validateFromImplicit (alias context, loc, left.getSymbol ().getContent ().getParameters (), f.getFunctionProto ().getParameters (), rights)
                } exit {
                    context:.exitForeign ();
                    context:.popReferent ();
                } catch {
                    err : &ErrorMsg => {
                        throw err;
                    }
                }

                return ret;
            }
            x : _ => {
                println (format ("TODO : %", x));
                __pragma!panic ();
            }
        }
    }

    /**
     * Perform an implicit template specialization from a list of syntax parameters 
     * @params: 
     *    - context: the context of the validation
     *    - loc: the location of the template call
     *    - templates: the list of template parameters
     *    - parameters: the list of syntax parameters (basically a list of var decl)
     *    - rights: the list of values used to call the function
     * @returns: 
     *    - .0; the template rewritter of the specialization
     *    - .1: the transformed parameters for correct specialization (for example variadic params are put inside tuples)
     * @throws:
     *    - &ErrorMsg: if the specialization fails
     */
    def validateFromImplicit (self, dmut context : &Validator, _ : &Word, templates : [&Expression], parameters : [&Expression], rights : [&Value])-> (&TemplateRewriter, [&Value])
        throws &ErrorMsg
    {
        let dmut types = Vec!{&Type}::new ();
        for it in rights { types:.push (it.getType ().clone (isMutable-> false)); }

        if (parameters.len > types.len ()) { __pragma!panic (); } // where ??

        let dmut finalParams = Vec!{&Value}::new ();
        let mut consumed = 0u32;
        let dmut globalMapper = TemplateMapper::new ();
        let rewriter = TemplateRewriter::new (globalMapper);
        let mut syntTemplate = templates;

        for it in 0us .. parameters.len {
            // Rewritte the current parameter that will be specialized to remove any template that was already validated
            let currentParam = rewriter.rewrite (parameters[it]);
            let rest = types.len () - consumed; // number of types that still can be consumed (Note that there can be more types than parameters in case of variadics)
            let syntaxRest = (parameters.len - it) - 1us; // The number of parameters that where not validated yet, minus the current one
            let consomableTypes = types[][consumed .. consumed + (rest - syntaxRest)]; // The list of types that can be associated to the current parameter (can be more than 1 in case of variadics)

            {
                let (mapper, localConsumed) = self.validateParamTemplateFromImplicit (alias context, syntTemplate, currentParam, consomableTypes);
                globalMapper:.merge (mapper);
                if (localConsumed == 1us) finalParams:.push (rights[consumed]); 
                else {
                    let tupleTypes  = types[][consumed .. consumed + localConsumed];
                    let tupleValues = rights [consumed .. consumed + localConsumed];
                    finalParams:.push (TupleValue::new (currentParam.getLoc (), TupleType::new (currentParam.getLoc (), tupleTypes), tupleValues));
                }
                
                consumed += localConsumed;
                syntTemplate = rewriter.replaceSyntaxTempl (syntTemplate);
            } catch {
                err : &ErrorMsg => { // TODO partial resolution note
                    throw err; 
                }
            }                        
        }

        (rewriter, finalParams[])
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================           EXPLICIT           =========================
     * ================================================================================
     * ================================================================================
     */
    
    /**
     * Validate a template explicit specialization
     * @params: 
     *    - context: the context of the validation
     *    - params: the template parameters
     *    - values: the list of compile time knwon values passed to the template     
     * @returns: 
     *     - .0: a template mapper containing the template specialization
     *     - .1: the number of values that were consumed during the specialization
     * @throws: 
     *    - &ErrorMsg: if the specialization is impossible
     */
    pub def validateFromExplicit (self, dmut context : &Validator, params : [&Expression], values : [&Generator])-> (&TemplateMapper, usize)
        throws &ErrorMsg
    {
        let mut consumed = 0us;
        let dmut globalMapper = TemplateMapper::new ();
        let rewriter = TemplateRewriter::new (globalMapper);
        let mut syntTemplate = params;
        
        while (consumed < values.len && syntTemplate.len != 0us) {
            // Create a slice on template arguments that have not been used yet
            // Template arguments are used in the order they are written, but sometimes several at a time
            let currentElems = values[consumed .. $];

            // Create a slice on the template parameters that are not directly referenced
            // Only the first template parameter is explicitly set, but maybe it will also set other parameters
            let rest = syntTemplate[1us .. $]; 

            {
                // Perform the explicit template validation, with the given template parameters, and call arguments
                let (mapper, localConsumed) = self.validateParamTemplateFromExplicit (alias context, rest, syntTemplate[0], currentElems);

                globalMapper:.merge (mapper);
                consumed += localConsumed;
                syntTemplate = rewriter.replaceSyntaxTempl (syntTemplate);
            } catch {
                err : &ErrorMsg => { // TODO partial resolution note
                    throw err; 
                }
            }
        }
        
        (globalMapper, consumed)
    }

    /**
     * Validate a template parameter from an explicit call
     * @params: 
     *    - context: the context of the validation
     *    - syntTemplate: the template parameters
     *    - current: the template parameter to validate
     *    - values: the values passed to the template call
     * @returns:
     *    - .0: the mapper containing the template specialisation
     *    - .1: the number of values that were consumed
     * @throws:
     *    - &ErrorMsg: if the specialization is impossible
     */
    def validateParamTemplateFromExplicit (self, dmut context : &Validator, syntaxTemplate : [&Expression], current : &Expression, values : [&Generator])-> (&TemplateMapper, usize)
        throws &ErrorMsg
    {
        match current {
            v : &VarExpr => {
                return self.validateVarExprFromExplicit (alias context, v, values);
            }
            ov : &TemplateOfVarExpr => {
                if (ov.getKind () == TemplateOfVarType::OF || ov.getKind () == TemplateOfVarType::OVER) {
                    return self.validateOfVarExprFromExplicit (alias context, syntaxTemplate, ov, values);
                } else {
                    __pragma!panic ();
                }
            }
            _ => {
                println (format ("TODO %", current));
                __pragma!panic ();
            }
        }
    }    

    /**
     * Validate an explicit template specialization where template parameter is a simple varexpr
     * @params: 
     *    - context: the context of the validation
     *    - v: the var expression
     *    - values: the list of values passed to the template call
     * @returns:
     *    - .0: the template parameter specialization
     *    - .1: the number of consumed parameters (should be 1us)
     * @throws:
     *    - &ErrorMsg: if the values cannot be used to specialize the template parameter
     */
    def validateVarExprFromExplicit (self, dmut context : &Validator, v : &VarExpr, values : [&Generator])-> (&TemplateMapper, usize)
        throws &ErrorMsg
    {
        match values [0] {
            t : &Type => {
                context.verifyNotIsNativeType (v.getLoc ());
                let dmut mapper = TemplateMapper::new (score-> TemplateScore::VAR);
                mapper:.insert (v.getLoc ().str (), TypeWrapperExpr::new (t.getLoc (), t));
                
                return (mapper, 1us);
            }
            _ => {                  
                throw ErrorMsg::fatal (values[0].getLoc (), ValidateErrorMessage::USE_AS_TYPE,
                                       notes-> [ErrorMsg::note (v.getLoc (), ""s8)]);
            }
        }
    }


    /**
     * ================================================================================
     * ================================================================================
     * =========================       EXPLICIT OF VAR        =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate an explicit template specialization where template parameter is an of var
     * @params: 
     *    - context: the context of the validation
     *    - v: the template of var to validate
     *    - values: the list of values passed to the template call
     * @returns:
     *    - .0: the template parameter specialization
     *    - .1: the number of consumed parameters (should be 1us)
     * @throws:
     *    - &ErrorMsg: if the values cannot be used to specialize the template parameter
     */
    def validateOfVarExprFromExplicit (self, dmut context : &Validator, alls : [&Expression], v : &TemplateOfVarExpr, values : [&Generator])-> (&TemplateMapper, usize)
        throws &ErrorMsg
    {
        match values[0] {
            t : &Type => {                
                match v.getSpecialization () {
                    var : &VarExpr => {
                        return self.validateOfVarInnerExplicit (alias context, alls, v, var, t);
                    }
                    un : &UnaryExpr => {
                        return self.validateOfUnaryInnerExplicit (alias context, alls, v, un, t);
                    }
                    _ => {
                        __pragma!panic ();
                    }                    
                }
            }
            _ => {
                throw ErrorMsg::fatal (values[0].getLoc (), ValidateErrorMessage::USE_AS_TYPE,
                                       notes-> [ErrorMsg::note (v.getLoc (), ""s8)]);
            }
        }        
    }

    /**
     * Validate an explicit inner part of an of var, where the inner part is simply a VarExpr (A of T)
     * @params: 
     *    - context: the context of the validation
     *    - alls: the list of template parameters that are not validated yet
     *    - ofV: the template of var to validate
     *    - v: the inner part of the ofvar (=> ofV.getInner ())
     *    - values: the list of values passed to the template call
     * @returns:
     *    - .0: the template parameter specialization
     *    - .1: the number of consumed parameters (should be 1us)
     * @throws:
     *    - &ErrorMsg: if the values cannot be used to specialize the template parameter
     */
    def validateOfVarInnerExplicit (self, dmut context : &Validator, alls : [&Expression], ofV : &TemplateOfVarExpr, v : &VarExpr, type : &Type)-> (&TemplateMapper, usize)
        throws &ErrorMsg
    {
        let dmut retMapper = TemplateMapper::new (score-> TemplateScore::VAR);
        
        // Search the inner value (A of T => search T in the parameters)
        let expr = self.findExpression (v.getLoc ().str (), alls);
        if !expr.isOf!{&EmptyExpression} () {

            let (mapper, _) = self.validateParamTemplateFromExplicit (alias context, alls, expr, [cast!(&Generator) (type)]);
            retMapper:.merge (mapper);
        }

        // Complete the type, and verify that it is correctly set, maybe for function ptr this will not work (thus TODO)
        let finalType = self.performTemplateRewrite (v, retMapper);
        let ofType = context:.validateType (finalType);
        if (ofV.getKind () == TemplateOfVarType::OVER) {
            context:.verifyAncestor (v.getLoc (), ofType, type);
        } else {
            context:.verifyCompatibleType (v.getLoc (), type.getLoc (), ofType, type);
        }

        retMapper:.insert (ofV.getLoc ().str (), TypeWrapperExpr::new (type.getLoc (), type));
        return (retMapper, 1us);
    }

    
    /**
     * Validate an explicit inner part of an of var, where the inner part is a UnaryExpr (A of &T)
     * @params: 
     *    - context: the context of the validation
     *    - alls: the list of template parameters that are not validated yet
     *    - ofV: the of var expression
     *    - un: the unary expression (=> ofV.getInner ())
     *    - values: the list of values passed to the template call
     * @returns: 
     *    - .0: the template parameter specialization
     *    - .1: the number of consumed parameters (should be 1us)
     * @throws:
     *    - &ErrorMsg: if the specialization failed
     */
    def validateOfUnaryInnerExplicit (self, dmut context : &Validator, alls : [&Expression], ofV : &TemplateOfVarExpr, un : &UnaryExpr, type : &Type)-> (&TemplateMapper, usize)
        throws &ErrorMsg
    {
        let dmut retMapper = TemplateMapper::new (score-> TemplateScore::VAR);
        
        match un.getOperand () {
            var : &VarExpr => {                
                let expr = self.findExpression (var.getLoc ().str (), alls);                
                if !expr.isOf!{&EmptyExpression} () {                    
                    // Unary are generaly &X, that can be either a pointer or a classptr type
                    let inner = match type {
                        cl : &ClassPtrType => { cl.getInner () }
                        ct : &CompoundType => {
                            if (ct.getInners ().len == 1us) {
                                ct.getInners ()[0us]
                            } else {
                                throw ErrorMsg::fatal (un.getLoc (), format (ValidateErrorMessage::TEMPLATE_SPECIALIZATION_FAILS, un, type));
                            }
                        }
                        _ => {
                            throw ErrorMsg::fatal (un.getLoc (), format (ValidateErrorMessage::TEMPLATE_SPECIALIZATION_FAILS, un, type));
                        }
                    };

                    let (mapper, _) = self.validateParamTemplateFromExplicit (alias context, alls, expr, [inner]);
                    retMapper:.merge (mapper);                    
                }
            }
        }

        // Complete the type, and verify that it is correctly set, maybe for function ptr this will not work (thus TODO)
        let finalType = self.performTemplateRewrite (un, retMapper);
        let ofType = context:.validateType (finalType);
        if (ofV.getKind () == TemplateOfVarType::OVER) {
            context:.verifyAncestor (un.getLoc (), ofType, type);
        } else {
            context:.verifyCompatibleType (un.getLoc (), type.getLoc (), ofType, type);
        }

        retMapper:.insert (ofV.getLoc ().str (), TypeWrapperExpr::new (type.getLoc (), type));
        return (retMapper, 1us);
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================           IMPLICIT           =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a template implicit validation of a parameter that may contain template variables
     * @params: 
     *    - context: the context of the validation
     *    - templates: the list of template associated to the parameter
     *    - parameter: the syntax expression (basically a vardecl) that contains a type that may contain template variable
     *    - types: the list of type that can be associated to the templates
     * @returns:
     *    - .0: the mapper in case of validation (used to create a valid rewriter)
     *    - .1: the number of types that were consumed during the validation
     * @throws:
     *    - &ErrorMsg: if the specialization failed
     */
    def validateParamTemplateFromImplicit (self, dmut context : &Validator, templates : [&Expression], param : &Expression, types : [&Type])-> (&TemplateMapper, u32)
        throws &ErrorMsg
    {
        match param {
            x : &VarDeclExpr => {
                match x.getType () { // we want to transform its type from implicit specialization
                    EmptyExpression () => { // It has no type
                        (TemplateMapper::new (), 0u32)
                    }
                    UnitExpr () => { // Also no type, 
                        (TemplateMapper::new (), 0u32) // we return an empty template mapper, because the specialization works, it just gives no information
                    }
                    type : _ => { // There is possible information, if the type contains templates, so we validate it
                        self.validateTypeFromImplicit (alias context, templates, type, types)
                    }
                }
            }
            _ => __pragma!panic ();  // necessarily a vardecl, implicit specialization are for function proto, ctor, and structs, so always vardecls are usable, we can't make an implicit specialization without them that is the premise
        }
    }

    /**
     * Validate the implicit specialization of 'typeExpr' from 'types' using 'templates' as template parameters 
     * @params: 
     *    - context: the context of the validation
     *    - templates: the list of tempalte to specialize
     *    - typeExpr: a type foudn during implicit validation (inside vardecl for example)
     *    - types: the types that will be used to transform typeExpr, and templates into specialized values
     * @returns:
     *    - .0: the mapper in case of validation (used to create a valid rewriter)
     *    - .1: the number of types that were consumed during the validation
     * @throws:
     *    - &ErrorMsg: if the specialization failed
     */
    def validateTypeFromImplicit (self, dmut context : &Validator, templates : [&Expression], typeExpr : &Expression, types : [&Type])-> (&TemplateMapper, u32)
        throws &ErrorMsg
    {
        match typeExpr {
            v : &VarExpr => {
                return self.validateTypeFromImplitVarExpr (alias context, templates, v, types);
            }           
            _ => {
                context:.validateType (typeExpr);
                return (TemplateMapper::new (), 1u32);
            }
        }
    }    

    /**
     * Validate the implicit specialization of 'var' from 'types' using 'templates' as template parameters
     * @params: 
     *    - context: the context of the validation
     *    - templates: the list of tempalte to specialize
     *    - var: a var expr describing a type
     *    - types: the types that will be used to transform typeExpr, and templates into specialized values
     * @returns:
     *    - .0: the mapper in case of validation (used to create a valid rewriter)
     *    - .1: the number of types that were consumed during the validation
     * @throws:
     *    - &ErrorMsg: if the specialization failed
     */
    def validateTypeFromImplitVarExpr (self, dmut context : &Validator, templates : [&Expression], var : &VarExpr, types : [&Type])-> (&TemplateMapper, u32)
        throws &ErrorMsg
    {
        let tmp = self.findExpression (var.getLoc ().str (), templates);
        match tmp {
            EmptyExpression () => {
                return (TemplateMapper::new (), 1u32);
            }
            _ => {
                let (ret, nb) = self.validateParamTemplateFromExplicit (alias context, templates, tmp, types);
                (ret, cast!u32 (nb))
            }
        }
    }
    
    /**
     * ================================================================================
     * ================================================================================
     * =========================            COMMON            =========================
     * ================================================================================
     * ================================================================================
     */


    /**
     * Create a new expression where template specialization or correclty rewritten
     * @params:
     *     - expr: the expression to rewrite
     *     - mapper: the template specialization
     * @returns: the rewritten expr
     */
    def performTemplateRewrite (self, expr : &Expression, mapper : &TemplateMapper)-> &Expression {    
        TemplateRewriter::new (mapper).rewrite (expr)
    }

    /**
     * Search in the list of template parameters a parameter whose name is 'name'
     * @params: 
     *    - name: the name to find
     *    - alls: the list of template params
     * @returns: an expression from 'alls' whose name is 'name' (&EmptyExpression if the expression does not exists)
     */
    def findExpression (self, name : [c8], alls : [&Expression])-> &Expression {   
        for i in alls match i {
            v : &VarExpr => {
                if v.getLoc ().str () == name {
                    return v;
                }
            }
            v : &TemplateOfVarExpr => {
                if v.getLoc ().str () == name {
                    return v;
                }
            }
            v : &TemplateVariadicVarExpr => {
                if v.getLoc ().str () == name {
                    return v;
                }
            }
            v : &TemplateVarExpr => {
                if v.getLoc ().str () == name {
                    return v;
                }
            }
        }


        EmptyExpression::new ()
    }
    
    
}
