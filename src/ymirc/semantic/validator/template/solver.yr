mod ymirc::semantic::validator::template::solver;

import ymirc::semantic::validator::visitor;
import ymirc::semantic::validator::template::mapper;
import ymirc::semantic::validator::template::rewrite;
import ymirc::semantic::validator::errors;
import ymirc::semantic::symbol::template;
import ymirc::syntax::declaration::protection;
import ymirc::syntax::expression::_;
import ymirc::syntax::declaration::_;

import ymirc::syntax::keys;
import ymirc::semantic::generator::_;
import ymirc::semantic::symbol::_;
import ymirc::errors::_;
import ymirc::utils::format;
import ymirc::lexing::word;

import std::collection::vec;
import std::io, std::fs::path;

/**
 * The template validator is the template responsible for template symbol validation
 */
pub class TemplateSolver {

    /**
     * Create a new empty validator
     */
    pub self () {}
    
    /*!
     * ================================================================================
     * ================================================================================
     * =========================             CALL             =========================
     * ================================================================================
     * ================================================================================
     */
    
    /**
     * Validate a template call that creates a value (function for example, or aka, etc.)
     * @params: 
     *    - context: the context of the validation
     *    - loc: the location of the call
     *    - left: the value that is template called
     *    - rights: the template arguments passed to the template
     * @returns: 
     *    - .0: the value
     *    - .1: the score of the call
     * @throws:
     *    - &ErrorMsg: if the call is impossible (for example left is not a valid template)    
     */
    pub fn validateCallValue (self, dmut context : &Validator, loc : &Word, left : &Value, rights : [&Generator])-> &TemplateRewriter
        throws &ErrorMsg
    {
        match left {
            x : &TemplateRefValue => {
                return self.validateCallTemplateRefValue (alias context, loc, x, rights);
            }
            z : _ => {
                throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_TEMPLATE_CALL, left, rights), notes-> [ErrorMsg::note (z.getLoc (), ""s8)]);
            }
        }
    }


    /**
     * Validate a template call that creates a value
     * @params: 
     *    - context: the context of the validation
     *    - loc: the location of the call
     *    - left: the value that is template called
     *    - rights: the template arguments passed to the template
     * @returns: 
     *    - .0: the value
     *    - .1: the score of the call
     * @throws:
     *    - &ErrorMsg: if the call is impossible
     */
    pub fn validateCallTemplateRefValue (self, dmut context : &Validator, _ : &Word, left : &TemplateRefValue, rights : [&Generator])-> &TemplateRewriter
        throws &ErrorMsg
    {
        let templateParams = left.getSymbol ().getContent ().getParameters ();
        let (mapper, consumed) = self.validateFromExplicit (alias context, templateParams, rights);

        if (consumed < rights.len) {
            throw ErrorMsg::fatal (rights[consumed].getLoc (), format (ValidateErrorMessage::TEMPLATE_REST, rights[consumed .. $]), notes-> [ErrorMsg::note (left.getSymbol ().getLoc (), format (ValidateErrorMessage::VALIDATING_SYMBOL, left))]);
        }

        TemplateRewriter::new (mapper) // return the rewriter that can then be used to finalize the syntax rewritting before semantic validation                
    }

    /**
     * Validate a sort of template call, that was made inside a template checker
     * @params: 
     *    - context: the context of the validation
     *    - loc: the location of the template check
     *    - params: the template parameters of the check (rules)
     *    - rights: the arguments passed to the checker (already validated)
     * @returns: the template rewritter
     * @throws:
     *    - &ErrorMsg: if the specialization failed
     */
    pub fn validateFromTemplateChecker (self, dmut context : &Validator, loc : &Word, params : [&Expression], rights : [&Generator])-> &TemplateRewriter
        throws &ErrorMsg
    {
        let (mapper, consumed) = self.validateFromExplicit (alias context, params, rights);

        if (consumed < rights.len) {
            throw ErrorMsg::fatal (rights[consumed].getLoc (), format (ValidateErrorMessage::TEMPLATE_REST, rights[consumed .. $]), notes-> [ErrorMsg::note (loc, ""s8)]);
        } 

        TemplateRewriter::new (mapper) // return the rewriter that can then be used to finalize the syntax rewritting before semantic validation                
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================           IMPLICIT           =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a template specialization from an implicit call
     * @params: 
     *    - context: the context of the validation
     *    - loc: the location of the specialization
     *    - left: the value to specialize
     *    - rights: the list of values used for specialization
     * @returns: 
     *    - .0: the template rewriter created by specialization
     *    - .1: the transformed parameters for correct specialization (for example variadic params are put inside tuples)
     * @throws:
     *    - &ErrorMsg: if the specialization failed
     */
    pub fn validateImplicitValue (self, dmut context : &Validator, loc : &Word, left : &TemplateRefValue, rights : [&Value], forMethod : bool = false)-> (&TemplateRewriter, [&Value])
        throws &ErrorMsg
    {
        match left.getSymbol ().getContent ().getContent () {
            f : &FunctionDecl => {
                let dmut sym = context:.getSymbolFromRef (left.getSymbol ());
                context:.pushReferent (alias sym);                
                context:.enterForeign (isFnBody-> false);
                
                let ret = {
                    if (forMethod) {
                        self.validateFromImplicit (alias context, loc, left.getSymbol ().getContent ().getParameters (), f.getFunctionProto ().getParameters ()[1us .. $], rights)
                    } else {
                        self.validateFromImplicit (alias context, loc, left.getSymbol ().getContent ().getParameters (), f.getFunctionProto ().getParameters (), rights)
                    }
                } catch {
                    err : &ErrorMsg => {                        
                        context:.exitForeign ();
                        context:.popReferent ();
                        throw err;
                    }
                }

                context:.exitForeign ();
                context:.popReferent ();

                return ret;
            }
            x : _ => {
                println (format ("TODO : %", x));
                __pragma!panic ();
            }
        }
    }

    /**
     * Perform an implicit template specialization from a list of syntax parameters 
     * @params: 
     *    - context: the context of the validation
     *    - loc: the location of the template call
     *    - templates: the list of template parameters
     *    - parameters: the list of syntax parameters (basically a list of var decl)
     *    - rights: the list of values used to call the function
     * @returns: 
     *    - .0; the template rewritter of the specialization
     *    - .1: the transformed parameters for correct specialization (for example variadic params are put inside tuples)
     * @throws:
     *    - &ErrorMsg: if the specialization fails
     */
    fn validateFromImplicit (self, dmut context : &Validator, loc : &Word, templates : [&Expression], parameters : [&Expression], rights : [&Value])-> (&TemplateRewriter, [&Value])
        throws &ErrorMsg
    {
        let types = self.createTypesFromRights (alias context, rights);
        if (parameters.len > types.len) {
            throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::TEMPLATE_SPECIALIZATION_FAILS, parameters, types));
        } // the implicit can be called without enough parameters 

        let dmut finalParams = Vec!{&Value}::new ();
        let mut consumed = 0us;
        let dmut globalMapper = TemplateMapper::new ();
        let rewriter = TemplateRewriter::new (globalMapper);
        let mut syntTemplate = templates;

        for it in 0us .. parameters.len {
            // Rewritte the current parameter that will be specialized to remove any template that was already validated
            let currentParam = rewriter.rewrite (parameters[it]);
            let rest = types.len - consumed; // number of types that still can be consumed (Note that there can be more types than parameters in case of variadics)
            let syntaxRest = (parameters.len - it) - 1us; // The number of parameters that where not validated yet, minus the current one
            let consomableTypes = types [consumed .. consumed + (rest - syntaxRest)]; // The list of types that can be associated to the current parameter (can be more than 1 in case of variadics)

            {
                let (mapper, localConsumed) = self.validateParamTemplateFromImplicit (alias context, syntTemplate, currentParam, consomableTypes);
                globalMapper:.merge (mapper);
                if (localConsumed == 1us) finalParams:.push (rights[consumed]); 
                else {
                    let tupleTypes  = types [consumed .. consumed + localConsumed];
                    let tupleValues = rights [consumed .. consumed + localConsumed];
                    finalParams:.push (TupleValue::new (currentParam.getLoc (), TupleType::new (currentParam.getLoc (), tupleTypes), tupleValues));
                }
                
                consumed += localConsumed;
                syntTemplate = rewriter.replaceSyntaxTempl (syntTemplate);
            } catch {
                err : &ErrorMsg => {
                    if (globalMapper.getMapping ().len () != 0us) {
                        let note = ErrorMsg::note (loc, format (ValidateErrorMessage::TEMPLATE_SPE, globalMapper));
                        throw ErrorMsg::list ([note, err]);
                    } else throw err;
                }
            }                        
        }

        for it in rights [cast!usize (consumed) .. $] {
            finalParams:.push (it)
        }

        (rewriter, finalParams[])
    }

    /**
     * Create the list of types from the right values
     * @params:
     *    - rights: the values used to implicitely specialize the template value
     * */
    fn createTypesFromRights (self, dmut context : &Validator, rights : [&Value])-> [&Type] {
        let dmut types = Vec!{&Type}::new ();
        for it in rights {
            match context:.implicitEnumUnwrap (it) {
                s : &StringValue => {
                    if (s.getType ().isOf!{&SliceType} ()) {
                        let t = s.getType ().asOf!{&SliceType} ();
                        types:.push (SliceType::new (t.getLoc (), t.getInners ()[0], withSize-> makeIntValue (t.getLoc (), s.getLen ())));
                    } else {
                        if (it.getType ().isMutable ()) {
                            types:.push (it.getType ().clone (0u32));
                        } else {
                            types:.push (it.getType ());
                        }
                    }
                }
                _ => {
                    if (it.getType ().isMutable ()) {
                        types:.push (it.getType ().clone (0u32));
                    } else {
                        types:.push (it.getType ());
                    }
                }
            }
        }

        types[]
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================           EXPLICIT           =========================
     * ================================================================================
     * ================================================================================
     */
    
    /**
     * Validate a template explicit specialization
     * @params: 
     *    - context: the context of the validation
     *    - params: the template parameters
     *    - values: the list of compile time knwon values passed to the template     
     * @returns: 
     *     - .0: a template mapper containing the template specialization
     *     - .1: the number of values that were consumed during the specialization
     * @throws: 
     *    - &ErrorMsg: if the specialization is impossible
     */
    pub fn validateFromExplicit (self, dmut context : &Validator, params : [&Expression], values : [&Generator])-> (&TemplateMapper, usize)
        throws &ErrorMsg
    {
        let mut consumed = 0us;
        let dmut globalMapper = TemplateMapper::new ();
        let rewriter = TemplateRewriter::new (globalMapper);
        let mut syntTemplate = params;
        
        while (consumed < values.len && syntTemplate.len != 0us) {
            // Create a slice on template arguments that have not been used yet
            // Template arguments are used in the order they are written, but sometimes several at a time
            let currentElems = values[consumed .. $];

            // Create a slice on the template parameters that are not directly referenced
            // Only the first template parameter is explicitly set, but maybe it will also set other parameters
            let rest = syntTemplate[1us .. $]; 

            {
                // Perform the explicit template validation, with the given template parameters, and call arguments
                let (mapper, localConsumed) = self.validateParamTemplateFromExplicit (alias context, rest, syntTemplate[0], currentElems);

                globalMapper:.merge (mapper);
                consumed += localConsumed;
                syntTemplate = rewriter.replaceSyntaxTempl (syntTemplate);
            } catch {
                err : &ErrorMsg => { // TODO partial resolution note
                    throw err; 
                }
            }
        }
        
        (globalMapper, consumed)
    }

    /**
     * Validate a template parameter from an explicit call
     * @params: 
     *    - context: the context of the validation
     *    - syntTemplate: the template parameters
     *    - current: the template parameter to validate
     *    - values: the values passed to the template call
     * @returns:
     *    - .0: the mapper containing the template specialisation
     *    - .1: the number of values that were consumed
     * @throws:
     *    - &ErrorMsg: if the specialization is impossible
     */
    fn validateParamTemplateFromExplicit (self, dmut context : &Validator, syntaxTemplate : [&Expression], current : &Expression, values : [&Generator])-> (&TemplateMapper, usize)
        throws &ErrorMsg
    {
        match current {
            v : &VarExpr => {
                return self.validateVarExprFromExplicit (alias context, v, values);
            }
            ov : &TemplateOfVarExpr => {
                match ov.getKind () {
                    TemplateOfVarType::OF => {
                        return self.validateOfVarExprFromExplicit (alias context, syntaxTemplate, ov, values);
                    }
                    TemplateOfVarType::IMPL => {
                        return self.validateImplVarExprFromExplicit (alias context, syntaxTemplate, ov, values);
                    }
                    _ => {
                        return self.validateOverVarExprFromExplicit (alias context, syntaxTemplate, ov, values);
                    }
                }
            }
            t : &TemplateVarExpr => {
                return self.validateTemplateVarExprFromExplicit (alias context, syntaxTemplate, t, values);
            }
            v : &TemplateVariadicVarExpr => {
                return self.validateTemplateVariadicFromExplicit (alias context, syntaxTemplate, v, values);
            }
            v : &VarDeclExpr => {
                return self.validateVarDeclExprFromExplicit (alias context, syntaxTemplate, v, values);
            }
            expr : &Expression => {
                return self.validateValueExpressionFromExplicit (alias context, expr, values);
            }
            _ => {
                println (format ("TODO %", current), " ", current::typeinfo.name);
                __pragma!panic ();
            }
        }
    }    

    /**
     * Validate an explicit template specialization where template parameter is a simple varexpr
     * @params: 
     *    - context: the context of the validation
     *    - v: the var expression
     *    - values: the list of values passed to the template call
     * @returns:
     *    - .0: the template parameter specialization
     *    - .1: the number of consumed parameters (should be 1us)
     * @throws:
     *    - &ErrorMsg: if the values cannot be used to specialize the template parameter
     */
    fn validateVarExprFromExplicit (self, dmut context : &Validator, v : &VarExpr, values : [&Generator])-> (&TemplateMapper, usize)
        throws &ErrorMsg
    {
        match values [0] {
            t : &Type => {
                context.verifyNotIsNativeType (v.getLoc (), v.getLoc ().str ());
                let dmut mapper = TemplateMapper::new (score-> TemplateScore::VAR);
                mapper:.insert (v.getLoc ().str (), self.createTypeWrapper (t.getLoc (), t));
                
                return (mapper, 1us);
            }
            _ => {                  
                throw ErrorMsg::fatal (values[0].getLoc (), format (ValidateErrorMessage::USE_AS_TYPE_TEMPLATE, values[0]),
                                       notes-> [ErrorMsg::note (v.getLoc (), ""s8)]);
            }
        }
    }


    /*!
     * ================================================================================
     * ================================================================================
     * =========================       EXPLICIT OF VAR        =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate an explicit template specialization where template parameter is an of var
     * @params:
     *    - context: the context of the validation
     *    - v: the template of var to validate
     *    - values: the list of values passed to the template call
     * @returns:
     *    - .0: the template parameter specialization
     *    - .1: the number of consumed parameters (should be 1us)
     * @throws:
     *    - &ErrorMsg: if the values cannot be used to specialize the template parameter
     */
    fn validateOfVarExprFromExplicit (self, dmut context : &Validator, alls : [&Expression], ofV : &TemplateOfVarExpr, types : [&Generator])-> (&TemplateMapper, usize)
        throws &ErrorMsg
    {
        let dmut asTypes = Vec!{&Type}::new ();
        for i in types {
            if (i.isOf!{&Type} ()) { asTypes:.push (i.asOf!{&Type} ()); }
        }

        if (asTypes.len () >= 1us) {
            let varName = ofV.getLoc ().str ();
            return match ofV.getSpecialization () {
                deco : &DecoratedExpr => {
                    self.validateOfDecoratedExplicit (alias context, varName, alls, deco, asTypes[])
                }
                _ => {
                    let dmut retMapper = TemplateMapper::new (score-> TemplateScore::VAR);
                    let (mapper, consumed) = self.validateOfVarExprFromExplicit (alias context, ofV.getLoc (), alls, ofV.getSpecialization (), asTypes[]);

                    retMapper:.merge (mapper);
                    let finalType = context:.validateType (self.performTemplateRewrite (ofV.getSpecialization (), mapper));
                    retMapper:.insert (varName, self.createTypeWrapper (ofV.getLoc (), finalType));

                    (retMapper, consumed)
                }
            };
        } else if (types.len != 0us) {
            throw ErrorMsg::fatal (types[0].getLoc (), format (ValidateErrorMessage::USE_AS_TYPE_TEMPLATE, types [0]),
                                   notes-> [ErrorMsg::note (ofV.getLoc (), ""s8)]);
        } else {
            throw ErrorMsg::fatal (ofV.getLoc (), format (ValidateErrorMessage::TEMPLATE_SPECIALIZATION_FAILS, alls, types));
        }
    }

    /**
     * Validate an explicit inner part of an of var, where the inner part is a decorated expression (A of dmut T, T)
     * @params:
     *     - context: the context of the validation
     *     - alls: the list of template parameters that are not validated yet
     *     - deco: the decorated of expression (=> ofv.getSpecialization ())
     *     - type: the type passed to the template call
     * @returns: the template mapper specialization
     * @throws:
     *    - &ErrorMsg: if the specialization failed
     */
    fn validateOfDecoratedExplicit (self, dmut context : &Validator, varName : [c8], alls : [&Expression], deco : &DecoratedExpr, types : [&Type])-> (&TemplateMapper, usize)
        throws &ErrorMsg
    {
        let type = types [0];
        let hasMut = deco.isMutable (), hasDmut = deco.isDeeplyMutable ();

        // Validate the type inside the template specialization
        // final template type won't have the mutability lvl, this is just a checking to see wether the decorator was used in the template call
        // For example MyTemplate!{dmut [i32]}, MyTemplate!{mut [i32]}, ...
        let (mapper, _) = self.validateOfVarExprFromExplicit (alias context, alls, deco.getContent (), [type]);
        if (hasDmut) {
            if (!type.isDeeplyMutable ()) { // if it was deeply mutable, it should have the same lvl as the same type but deeply mutable
                throw ErrorMsg::fatal (deco.getDecorator (), ValidateErrorMessage::DISCARD_CONST);
            }
        } else if (hasMut) {
            if (!type.isMutable ()) { // If the mut decorator is used the type has to be mutable
                throw ErrorMsg::fatal (deco.getDecorator (), ValidateErrorMessage::DISCARD_CONST);
            }
        }

        let dmut retMapper = TemplateMapper::new (score-> TemplateScore::VAR * 2us);
        retMapper:.merge (mapper);
        retMapper:.insert (varName, self.createTypeWrapper (deco.getLoc (), type), mutable-> hasMut, deeplyMut-> hasDmut);

        return (retMapper, 1us); // return the mapper containing the sub specialization
    }
    
    /**
     * Validate an explicit template specialization within another one (A of U, or A : U)
     * @params:
     *    - context: the context of the validation
     *    - v: the template of var to validate
     *    - values: the list of values passed to the template call
     * @returns:
     *    - .0: the template parameter specialization
     *    - .1: the number of consumed parameters (should be 1us)
     * @throws:
     *    - &ErrorMsg: if the values cannot be used to specialize the template parameter
     * */
    pub fn validateOfVarExprFromExplicit (self, dmut context : &Validator, alls : [&Expression], v : &Expression, types : [&Type])-> (&TemplateMapper, usize)
        throws &ErrorMsg
    {
        if (types.len >= 1us) {
            return self.validateOfVarExprFromExplicit (alias context, v.getLoc (), alls, v, types);
        } else {
            throw ErrorMsg::fatal (v.getLoc (), format (ValidateErrorMessage::TEMPLATE_SPECIALIZATION_FAILS, alls, types));
        }
    }
    
    /**
     * Validate an explicit template specialization where template parameter is an of var
     * @params: 
     *    - context: the context of the validation
     *    - expr: the content of the of var to validate
     *    - values: the list of values passed to the template call
     * @returns: the template parameter specialization
     * @throws:
     *    - &ErrorMsg: if the values cannot be used to specialize the template parameter
     */
    fn validateOfVarExprFromExplicit (self, dmut context : &Validator, loc : &Word, alls : [&Expression], expr : &Expression, types : [&Type])-> (&TemplateMapper, usize)
        throws &ErrorMsg
    {
        if (types.len == 0us) throw ErrorMsg::fatal (expr.getLoc (), format (ValidateErrorMessage::TEMPLATE_SPECIALIZATION_FAILS, alls, types));

        match expr {
            slc : &SliceAllocatorExpr => {
                return self.validateOfSliceAllocInnerExplicit (alias context, alls, slc, types);
            }
            c : &TemplateCallExpr => {
                return self.validateOfTemplateCallInnerExplicit (alias context, alls, c, types);
            }
            var : &VarExpr => {
                return self.validateOfVarInnerExplicit (alias context, alls, var, types);
            }
            p : &PathExpr => {
                return self.validateOfPathInnerExplicit (alias context, alls, p, types);
            }
            b : &BinaryExpr => {
                return self.validateOfBinaryInnerExplicit (alias context, alls, b, types);
            }
            un : &UnaryExpr => {
                return self.validateOfUnaryInnerExplicit (alias context, alls, un, types);
            }
            r : &RangeTypeExpr => {
                return self.validateOfRangeInnerExplicit (alias context, alls, r, types);
            }
            lst : &ListExpr => {
                if (lst.isArray ()) {
                    return self.validateOfSliceInnerExplicit (alias context, alls, lst, types);
                } else {
                    return self.validateOfTupleInnerExplicit (alias context, alls, lst, types);
                }
            }
            f : &FunctionPtrTypeExpr => {
                return self.validateOfFuncPtrInnerExplicit (alias context, alls, f, types);
            }
            spe : _ => {
                let speType = context:.validateType (spe);
                context:.verifyCompatibleType (loc, types [0].getLoc (), speType, types [0]);
                let dmut retMapper = TemplateMapper::new (score-> TemplateScore::VAR);

                (retMapper, 1us)
            }                    
        }    
    }

    /**
     * Validate an explicit inner part of an of var, where the inner part is a slice allocator (A of [T ; N])
     * @params:
     *    - context: the context of the validation
     *    - alls: the list of template parameters that are not validated yet
     *    - slc: the slice allocator (=> ofV.getSpecialization ())
     *    - type: the type passed to the template call
     * @returns: the template parameter specialization
     * @throws:
     *    - &ErrorMsg: if the specialization failed
     */
    fn validateOfSliceAllocInnerExplicit (self, dmut context : &Validator, alls : [&Expression], slc : &SliceAllocatorExpr, types : [&Type])-> (&TemplateMapper, usize)
        throws &ErrorMsg
    {
        let type = context:.implicitEnumUnwrap (types [0]);

        // This verification is close to slices, but with the verification of the size of the alloc that must be known at compile time
        match type {
            arr : &ArrayType => {
                let dmut retMapper = TemplateMapper::new (score-> TemplateScore::VAR * 2u32);
                let (typeMapper, _) = self.validateOfVarExprFromExplicit (alias context, alls, slc.getValue (), arr.getInners ());
                retMapper:.merge (typeMapper);

                match slc.getSize () {
                    v : &VarExpr => {
                        let expr = self.findExpression (v.getLoc ().str (), alls);
                        if !expr.isOf!{&EmptyExpression} () {
                            let (valMapper, _) = self.validateParamTemplateFromExplicit (alias context, alls, expr, [cast!(&Generator) (makeIntValue (arr.getLoc (), arr.getLen ()))]);
                            retMapper:.merge (valMapper);
                        }
                    }
                }

                let finalType = self.performTemplateRewrite (slc, retMapper);
                let ofType = context:.validateType (finalType);
                context:.verifyCompatibleType (slc.getLoc (), type.getLoc (), ofType, type);

                return (retMapper, 1us);
            }
            arr : &SliceType => {
                if (!arr.getSize ().isOf!{&UnitValue} ()) {
                    let dmut retMapper = TemplateMapper::new (score-> TemplateScore::VAR * 2u32);
                    let (typeMapper, _) = self.validateOfVarExprFromExplicit (alias context, alls, slc.getValue (), arr.getInners ());
                    retMapper:.merge (typeMapper);

                    match slc.getSize () {
                        v : &VarExpr => {
                            let expr = self.findExpression (v.getLoc ().str (), alls);
                            if !expr.isOf!{&EmptyExpression} () {
                                let (valMapper, _) = self.validateParamTemplateFromExplicit (alias context, alls, expr, [cast!(&Generator) (arr.getSize ())]);
                                retMapper:.merge (valMapper);
                            }
                        }
                    }

                    let finalType = self.performTemplateRewrite (slc, retMapper);
                    let ofType = context:.validateType (finalType);
                    context:.verifyCompatibleType (slc.getLoc (), type.getLoc (), ofType, type);

                    return (retMapper, 1us);
                }
            }
        }


        throw ErrorMsg::fatal (type.getLoc (), format (ValidateErrorMessage::NOT_AN_ARRAY, type),
                               notes-> [ErrorMsg::note (slc.getLoc (), ""s8)]);
    }


    /**
     * Validate an explicit inner part of an of var, where the inner part is a template call (A of T!{U})
     * @params:
     *    - context: the context of the validation
     *    - alls: the list of template parameters that are not validated yet
     *    - tmp: the template call to specialize
     *    - values: the list of values passed to the template call
     * @returns:
     *    - .0: the template parameter specialization
     *    - .1: the number of consumed parameters (should be 1us)
     * @throws:
     *    - &ErrorMsg: if the values cannot be used to specialize the template parameter
     * */
    fn validateOfTemplateCallInnerExplicit (self, dmut context : &Validator, alls : [&Expression], tmp : &TemplateCallExpr, types : [&Type])-> (&TemplateMapper, usize)
        throws &ErrorMsg
    {
        let type = context:.implicitEnumUnwrap (types [0]);
        let (has, clTemplates) = self.createTemplateListOfType (type);
        if (!has || tmp.getRights ().len > clTemplates.len) throw ErrorMsg::fatal (type.getLoc (), format (ValidateErrorMessage::TEMPLATE_SPECIALIZATION_FAILS, tmp, type),
                                                                                   notes-> [ErrorMsg::fatal (tmp.getLoc (), format (ValidateErrorMessage::INCOMPATIBLE_TYPE, tmp, type))]);

        let dmut retMapper = TemplateMapper::new (score-> TemplateScore::VAR);
        let rewriter = TemplateRewriter::new (retMapper);
        let mut consumed = 0us;
        let mut syntaxTemplate = alls;

        for i in 0us .. tmp.getRights ().len {
            let currentParam = rewriter.rewrite (tmp.getRights ()[i]);
            let rest = clTemplates.len - consumed;
            let syntaxRest = (tmp.getRights ().len - i) - 1us;

            let consomableTypes = clTemplates [consumed .. consumed + (rest - syntaxRest)];
            let (mapper, localConsumed) = if (consomableTypes.len > 0us && consomableTypes [0].isOf!{&Value} ()) {
                let (mp, _) = self.validateParamTemplateFromExplicit (alias context, syntaxTemplate, currentParam, [consomableTypes [0]]);
                (mp, 1us)
            } else {
                let dmut lst = Vec!{&Type}::new ();
                for ti in consomableTypes match ti {
                    t : &Type => { lst:.push (t); }
                    _ => { break {} }
                }
                self.validateOfVarExprFromExplicit (alias context, syntaxTemplate, currentParam, lst[])
            }

            retMapper:.merge (mapper);
            consumed += cast!usize (localConsumed);
            syntaxTemplate = rewriter.replaceSyntaxTempl (syntaxTemplate);
        }

        {
            let finalType = rewriter.rewrite (tmp);
            let ofType = context:.validateType (finalType);
            context:.verifyCompatibleType (tmp.getLoc (), type.getLoc (), ofType, type);
        } catch {
            err : &ErrorMsg => {
                throw ErrorMsg::note (tmp.getLoc (), format (ValidateErrorMessage::TEMPLATE_SPE, retMapper), notes-> [err]);
            }
        }

        return (retMapper, 1us);
    }

    /**
     * Validate an explicit inner part of an of var, where the inner part is simply a VarExpr (A of T)
     * @params: 
     *    - context: the context of the validation
     *    - alls: the list of template parameters that are not validated yet
     *    - v: the inner part of the ofvar (=> ofV.getSpecialization ())
     *    - values: the list of values passed to the template call
     * @returns:
     *    - .0: the template parameter specialization
     *    - .1: the number of consumed parameters (should be 1us)
     * @throws:
     *    - &ErrorMsg: if the values cannot be used to specialize the template parameter
     */
    fn validateOfVarInnerExplicit (self, dmut context : &Validator, alls : [&Expression], v : &VarExpr, types : [&Type])-> (&TemplateMapper, usize)
        throws &ErrorMsg
    {
        let dmut retMapper = TemplateMapper::new (score-> TemplateScore::VAR);
        
        // Search the inner value (A of T => search T in the parameters)
        let expr = self.findExpression (v.getLoc ().str (), alls);
        if !expr.isOf!{&EmptyExpression} () {
            let (mapper, localConsumed) = self.validateParamTemplateFromExplicit (alias context, alls, expr, types);
            retMapper:.merge (mapper);

            return (retMapper, localConsumed);
        } else {
            let ofType = context:.validateType (v);
            context:.verifyCompatibleType (v.getLoc (), types [0].getLoc (), ofType, types [0]);

            return (retMapper, 1us);
        }
    }

    /**
     * Validate an explicit inner part of an of var, where the inner part is a path expression (A of T::U)
     * @params:
     *    - context: the context of the validation
     *    - alls: the list of template parameters that are not validated yet
     *    - p: the inner part of the ofvar (=> ofV.getSpecialization ())
     *    - values: the list of values passed to the template call
     * @returns:
     *    - .0: the template parameter specialization
     *    - .1: the number of consumed parameters (should be 1us)
     * @throws:
     *    - &ErrorMsg: if the values cannot be used to specialize the template parameter
     * */
    fn validateOfPathInnerExplicit (self, dmut context : &Validator, alls : [&Expression], p : &PathExpr, types : [&Type])-> (&TemplateMapper, usize)
        throws &ErrorMsg
    {
        let type = types [0];
        let dmut retMapper = TemplateMapper::new (score-> TemplateScore::VAR);

        match p.getRight () {
            v : &VarExpr => {
                let expr = self.findExpression (v.getLoc ().str (), alls);
                if (!expr.isOf!{&EmptyExpression} ()) {
                    let (mapper, _) = self.validateParamTemplateFromExplicit (alias context, alls, expr, [type]);
                    retMapper:.merge (mapper);

                    let finalType = self.performTemplateRewrite (p, retMapper);
                    let ofType = context:.validateType (finalType);
                    context:.verifyCompatibleType (p.getLoc (), type.getLoc (), ofType, type);

                    return (retMapper, 1us);
                }
            }
        }

        let ofType = context:.validateType (p);
        context:.verifyCompatibleType (p.getLoc (), type.getLoc (), ofType, type);

        return (retMapper, 1us);
    }

    /**
     * Validate an explicit inner part of an of var, where the inner part is a binary expression (A of T::U)
     * @params:
     *    - context: the context of the validation
     *    - alls: the list of template parameters that are not validated yet
     *    - bin: the inner part of the ofvar (=> ofV.getSpecialization ())
     *    - values: the list of values passed to the template call
     * @returns:
     *    - .0: the template parameter specialization
     *    - .1: the number of consumed parameters (should be 1us)
     * @throws:
     *    - &ErrorMsg: if the values cannot be used to specialize the template parameter
     * */
    fn validateOfBinaryInnerExplicit (self, dmut context : &Validator, alls : [&Expression], bin : &BinaryExpr, types : [&Type])-> (&TemplateMapper, usize)
        throws &ErrorMsg
    {
        let type = types [0];
        let dmut retMapper = TemplateMapper::new (score-> TemplateScore::VAR);

        match (bin.getLoc ().str (), bin.getRight ()) {
            (BinaryOperators::DCOLON, v : &VarExpr) => {
                let expr = self.findExpression (v.getLoc ().str (), alls);
                if (!expr.isOf!{&EmptyExpression} ()) {
                    let (mapper, _) = self.validateParamTemplateFromExplicit (alias context, alls, expr, [type]);
                    retMapper:.merge (mapper);

                    let finalType = self.performTemplateRewrite (bin, retMapper);
                    let ofType = context:.validateType (finalType);
                    context:.verifyCompatibleType (bin.getLoc (), type.getLoc (), ofType, type);

                    return (retMapper, 1us);
                }
            }
        }

        let ofType = context:.validateType (bin);
        context:.verifyCompatibleType (bin.getLoc (), type.getLoc (), ofType, type);

        return (retMapper, 1us);
    }

    /**
     * Validate an explicit inner part of an of var, where the inner part is a UnaryExpr (A of &T)
     * @params: 
     *    - context: the context of the validation
     *    - alls: the list of template parameters that are not validated yet
     *    - un: the unary expression (=> ofV.getSpecialization ())
     *    - values: the list of values passed to the template call
     * @returns: the template parameter specialization
     * @throws:
     *    - &ErrorMsg: if the specialization failed
     */
    fn validateOfUnaryInnerExplicit (self, dmut context : &Validator, alls : [&Expression], un : &UnaryExpr, types : [&Type])-> (&TemplateMapper, usize)
        throws &ErrorMsg
    {
        let type = context:.implicitEnumUnwrap (types [0]);

        // Unary are generaly &X, that can be either a pointer or a classptr type
        let inner : &Type = match type {
            cl : &ClassPtrType => { cast!{&Type} (cl.getInner ()) }
            ct : &CompoundType => {
                if (ct.getInners ().len == 1us) {
                    ct.getInners ()[0us]
                } else {
                    throw ErrorMsg::fatal (un.getLoc (), format (ValidateErrorMessage::TEMPLATE_SPECIALIZATION_FAILS, un, type));
                }
            }
            _ => {
                throw ErrorMsg::fatal (un.getLoc (), format (ValidateErrorMessage::TEMPLATE_SPECIALIZATION_FAILS, un, type));
            }
        };

        let (mapper, _) = self.validateOfVarExprFromExplicit (alias context, alls, un.getOperand (), [inner]);
        
        // Complete the type, and verify that it is correctly set, maybe for function ptr this will not work (thus TODO)
        let finalType = self.performTemplateRewrite (un, mapper);
        let ofType = context:.validateType (finalType);
        context:.verifyCompatibleType (un.getLoc (), type.getLoc (), ofType, type);

        let dmut retMapper = TemplateMapper::new (score-> TemplateScore::VAR);
        retMapper:.merge (mapper);

        return (retMapper, 1us);
    }

    /**
     * Validate an explicit inner part of an of var, where the inner part is a RangeTypeExpr (A of ..T)
     * @params:
     *    - context: the context of the validation
     *    - alls: the list of template parameters that are not validated yet
     *    - r: the range type expression to validate
     *    - values: the list of values passed to the template call
     * @returns: the template parameter specialization
     * @throws:
     *    - &ErrorMsg: if the specialization failed
     */
    fn validateOfRangeInnerExplicit (self, dmut context : &Validator, alls : [&Expression], r : &RangeTypeExpr, types : [&Type])-> (&TemplateMapper, usize)
        throws &ErrorMsg
    {
        let type = context:.implicitEnumUnwrap (types [0]);
        let inner : &Type = match type {
            c : &RangeType => {
                c.getInners ()[0us]
            }
            _ => {
                throw ErrorMsg::fatal (r.getLoc (), format (ValidateErrorMessage::TEMPLATE_SPECIALIZATION_FAILS, r, type));
            }
        }

        let (mapper, _) = self.validateOfVarExprFromExplicit (alias context, alls, r.getType (), [inner]);
        
        // Complete the type, and verify that it is correctly set
        let finalType = self.performTemplateRewrite (r, mapper);
        let ofType = context:.validateType (finalType);
        context:.verifyCompatibleType (r.getLoc (), type.getLoc (), ofType, type);

        let dmut retMapper = TemplateMapper::new (score-> TemplateScore::VAR);
        retMapper:.merge (mapper);

        return (retMapper, 1us);
    }

    /**
     * Validate an explicit inner part of an of var, where the inner part is a slice ListExpr (A of [T])
     * @params:
     *    - context: the context of the validation
     *    - alls: the list of template parameters that are not validated yet
     *    - ofV: the of var expression
     *    - lst: the lsit expression (=> ofV.getSpecialization ())
     *    - type: the type passed to the template call
     * @returns:
     *    - .0: the template parameter specialization
     *    - .1: the number of consumed parameters (should be 1us)
     * @throws:
     *    - &ErrorMsg: if the specialization failed
     */
    fn validateOfSliceInnerExplicit (self, dmut context : &Validator, alls : [&Expression], lst : &ListExpr, types : [&Type])-> (&TemplateMapper, usize)
        throws &ErrorMsg
    {
        let type = context:.implicitEnumUnwrap (types [0]);
        if (lst.getParameters ().len != 1us)  throw ErrorMsg::fatal (lst.getLoc (), format (ValidateErrorMessage::USE_AS_TYPE_TEMPLATE, lst)); // the template is malformed

        match type {
            slc : &SliceType => { // This verification is pretty straightfoward, we just need to verify that we have a slice, and validate what is inner the template slice
                let (mapper, _) = self.validateOfVarExprFromExplicit (alias context, alls, lst.getParameters ()[0us], slc.getInners ()); // so, we validate the inner part

                let finalType = self.performTemplateRewrite (lst, mapper);
                let ofType = context:.validateType (finalType);
                context:.verifyCompatibleType (lst.getLoc (), type.getLoc (), ofType, type); // and verify that the two elements are equivalent

                let dmut retMapper = TemplateMapper::new (score-> TemplateScore::VAR);
                retMapper:.merge (mapper);

                return (retMapper, 1us);
            }
            _ => {
                throw ErrorMsg::fatal (type.getLoc (), format (ValidateErrorMessage::NOT_A_SLICE, type),
                                       notes-> [ErrorMsg::note (lst.getLoc (), ""s8)]);

            }
        }
    }

    /**
     * Validate an explicit inner part of an of var, where the inner part is a tuple ListExpr (A of (T, U, V))
     * @params:
     *    - context: the context of the validation
     *    - alls: the list of template parameters that are not validated yet
     *    - lst: the list expression (=> ofV.getSpecialization ())
     *    - type: the type passed to the template call
     * @returns: the template parameter specialization
     * @throws:
     *    - &ErrorMsg: if the specialization failed
     */
    fn validateOfTupleInnerExplicit (self, dmut context : &Validator, alls : [&Expression], lst : &ListExpr, types : [&Type])-> (&TemplateMapper, usize)
        throws &ErrorMsg
    {
        let type = context:.implicitEnumUnwrap (types [0]);

        match type {
            t : &TupleType => {
                // Because the inner elements of the template tuple could be variadic templates, we must manage it
                let dmut retMapper = TemplateMapper::new (score-> TemplateScore::VAR * 2u32);
                let mut consumed = 0us;

                // For the specialization to work, we need to have more or same number of types in the tuple than in the template => (T of (U, J...), J),  call!{(i32, i32, i32)}
                if (lst.getParameters ().len > t.getInners ().len) throw ErrorMsg::fatal (t.getLoc (), format (ValidateErrorMessage::MISMATCH_TUPLE_ARITY, t.getInners ().len, lst.getParameters ().len),
                                                                                          notes-> [ErrorMsg::note (lst.getLoc (), ""s8)]);
                let rewriter = TemplateRewriter::new (retMapper);
                let mut syntTemplate = alls;
                for i in 0us .. lst.getParameters ().len {
                    let currentParam = rewriter.rewrite (lst.getParameters ()[i]); // maybe some resolution already happened, we don't want to have collision in the mapper (e.g. (T of (U, U, U), U))
                    let rest = t.getInners ().len - consumed;
                    let syntaxRest = (lst.getParameters ().len - i) - 1us;

                    // Give all the types that rests for variadics, I don't see a better way, because last elements could be other things than templates, so variadics must be the last template elements
                    let consomableTypes = t.getInners ()[consumed .. consumed + (rest - syntaxRest)];
                    let (mapper, localConsumed) = self.validateOfVarExprFromExplicit (alias context, syntTemplate, currentParam, consomableTypes);

                    // Merging the mapper
                    retMapper:.merge (mapper);
                    consumed += cast!usize (localConsumed); // increment the number of used types
                    syntTemplate = rewriter.replaceSyntaxTempl (syntTemplate);
                }

                {
                    // we don't check if all types of "type" were used,
                    // there is not need, because we validate the template, and check if it is equivalent to "type", so if some elements of "type" were unused, it should fail here
                    let finalType = rewriter.rewrite (lst);
                    let ofType = context:.validateType (finalType);
                    context:.verifyCompatibleType (lst.getLoc (), type.getLoc (), ofType, type);
                } catch {
                    err : &ErrorMsg => {
                        throw ErrorMsg::note (lst.getLoc (), format (ValidateErrorMessage::TEMPLATE_SPE, retMapper), notes-> [err]);
                    }
                }

                return (retMapper, 1us);
            }
            _ => {
                throw ErrorMsg::fatal (type.getLoc (), format (ValidateErrorMessage::NOT_A_TUPLE, type),
                                       notes-> [ErrorMsg::note (lst.getLoc (), ""s8)]);
            }
        }
    }
    
    /**
     * Validate an explicit inner part of an of var, where the inner part is a FunctionPtrTypeExpr (A of fn (U)-> J)
     * @params:
     *    - context: the context of the validation
     *    - alls: the list of template parameters that are not validated yet
     *    - fptr: the function type expression to validate
     *    - values: the list of values passed to the template call
     * @returns: the template parameter specialization
     * @throws:
     *    - &ErrorMsg: if the specialization failed
     * */
    fn validateOfFuncPtrInnerExplicit (self, dmut context : &Validator, alls : [&Expression], fptr : &FunctionPtrTypeExpr, types : [&Type])-> (&TemplateMapper, usize)
        throws &ErrorMsg
    {
        let type = context:.implicitEnumUnwrap (types [0]);
        let (params, retType) = match (fptr.isClosure (), type) {
            (false, f : &FuncPtrType) => {
                (f.getParameters (), f.getRetType ())
            }
            (true, d : &DelegateType) => {
                (d.getParameters (), d.getRetType ())
            }
            _ => {
                throw ErrorMsg::fatal (fptr.getLoc (), format (ValidateErrorMessage::TEMPLATE_SPECIALIZATION_FAILS, fptr, type));
            }
        };

        if (fptr.getParameters ().len > params.len) {
            throw ErrorMsg::fatal (type.getLoc (), format (ValidateErrorMessage::TEMPLATE_SPECIALIZATION_FAILS, fptr, type),
                                   notes-> [ErrorMsg::fatal (fptr.getLoc (), format (ValidateErrorMessage::INCOMPATIBLE_TYPE, fptr, type))]);
        }

        let mut consumed = 0us;
        let dmut retMapper = TemplateMapper::new (score-> TemplateScore::TYPE);

        let rewriter = TemplateRewriter::new (retMapper);
        let mut syntTemplate = alls;

        for i in 0us .. fptr.getParameters ().len {
            match fptr.getParameters ()[i] {
                v : &VarDeclExpr => {
                    let currentParam = rewriter.rewrite (v.getType ());
                    let rest = params.len - consumed;
                    let syntaxRest = (fptr.getParameters ().len - i) - 1us;
                    let consomableTypes = params[consumed .. consumed + (rest - syntaxRest)];

                    let (tiMapper, localConsumed) = self.validateOfVarExprFromExplicit (alias context, syntTemplate, currentParam, consomableTypes);

                    retMapper:.merge (tiMapper);
                    consumed += cast!usize (localConsumed);
                    syntTemplate = rewriter.replaceSyntaxTempl (syntTemplate);
                }
                _ => __pragma!panic ();
            }
        }

        let retParam = rewriter.rewrite (fptr.getReturn ());
        let (tiMapper, _) = self.validateOfVarExprFromExplicit (alias context, syntTemplate, retParam, [retType]);
        retMapper:.merge (tiMapper);

        let finalType = rewriter.rewrite (fptr);
        let ofType = context:.validateType (finalType);
        context:.verifyCompatibleType (fptr.getLoc (), type.getLoc (), ofType, type);

        return (retMapper, 1us);
    }



    /*!
     * ================================================================================
     * ================================================================================
     * =========================      EXPLICIT OVER VAR       =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate an explicit template specialization where template parameter is an over var
     * @params: 
     *    - context: the context of the validation
     *    - v: the template of var to validate
     *    - values: the list of values passed to the template call
     * @returns:
     *    - .0: the template parameter specialization
     *    - .1: the number of consumed parameters (should be 1us)
     * @throws:
     *    - &ErrorMsg: if the values cannot be used to specialize the template parameter
     */
    fn validateOverVarExprFromExplicit (self, dmut context : &Validator, alls : [&Expression], v : &TemplateOfVarExpr, values : [&Generator])-> (&TemplateMapper, usize)
        throws &ErrorMsg
    {
        context;
        alls;
        v;
        values;        
        __pragma!fake_throw (&ErrorMsg);
        __pragma!panic ();
    }
    
    /*!
     * ================================================================================
     * ================================================================================
     * =========================      EXPLICIT IMPL VAR       =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate an explicit template specialization where template parameter is an impl var
     * @params: 
     *    - context: the context of the validation
     *    - v: the template of var to validate
     *    - values: the list of values passed to the template call
     * @returns:
     *    - .0: the template parameter specialization
     *    - .1: the number of consumed parameters (should be 1us)
     * @throws:
     *    - &ErrorMsg: if the values cannot be used to specialize the template parameter
     */
    fn validateImplVarExprFromExplicit (self, dmut context : &Validator, alls : [&Expression], v : &TemplateOfVarExpr, values : [&Generator])-> (&TemplateMapper, usize)
        throws &ErrorMsg
    {
        match values [0] {
            t : &Type => {
                match context:.implicitEnumUnwrap (t) {
                    c : &ClassPtrType => { // only class types can implement traits
                        let mapper = self.validateImplClassFromExplicit (alias context, alls, v, c);
                        let dmut retMapper = TemplateMapper::new (score-> TemplateScore::VAR);
                        retMapper:.merge (mapper);
                        retMapper:.insert (v.getLoc ().str (), self.createTypeWrapper (c.getLoc (), c));

                        return (retMapper, 1us);
                    }
                }
            }
        }

        throw ErrorMsg::fatal (values [0].getLoc (), format (ValidateErrorMessage::NOT_A_CLASS, values [0]),
                               notes-> [ErrorMsg::note (v.getLoc (), ""s8)]);
    }    

    /**
     * Validate an explicit template specialization where template parameter is an impl var, and type used for specialization is a class type
     * @params:
     *    - context: the context of the validation
     *    - alls: the list of template parameters to validate
     *    - v: the impl expr to validate
     *    - type: the class type used for validation
     * @returns: the template parameter specialization
     * @throws: 
     *    - &ErrorMsg: if the specialization is impossible 
     */
    fn validateImplClassFromExplicit (self, dmut context : &Validator, alls : [&Expression], v : &TemplateOfVarExpr, type : &ClassPtrType)-> &TemplateMapper
        throws &ErrorMsg
    {
        let inner = type.getInner ().asOf!{&ClassRefType} ();
        let dmut errors = Vec!{&ErrorMsg}::new ();
        let dmut retMapper = TemplateMapper::new (score-> TemplateScore::TYPE);

        for tr in inner.getAllImplTraits () {
            {
                let (mapper, _) = self.validateOfVarExprFromExplicit (alias context, alls, v.getSpecialization (), [tr]);
                let finalType = self.performTemplateRewrite (v.getSpecialization (), mapper);
                let ofType = context:.validateType (finalType);
                context:.verifyImplement (v.getLoc (), type, ofType);

                retMapper:.merge (mapper);
                return retMapper;
            } catch {
                err : &ErrorMsg => errors:.push (err);                
            }
        }

        throw ErrorMsg::fatal (v.getLoc (), format (ValidateErrorMessage::CLASS_NOT_IMPL, type, v.getSpecialization ()), notes-> errors[]);
    }

    
    /*!
     * ================================================================================
     * ================================================================================
     * =========================    EXPLICIT TEMPLATE VAR     =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate an explicit template specialization where template parameter is an template var (struct T, class T, ...)
     * @params: 
     *    - context: the context of the validation
     *    - v: the template of var to validate
     *    - values: the list of values passed to the template call
     * @returns:
     *    - .0: the template parameter specialization
     *    - .1: the number of consumed parameters (should be 1us)
     * @throws:
     *    - &ErrorMsg: if the values cannot be used to specialize the template parameter
     */
    fn validateTemplateVarExprFromExplicit (self, dmut context : &Validator, _ : [&Expression], v : &TemplateVarExpr, values : [&Generator])-> (&TemplateMapper, usize)
        throws &ErrorMsg
    {
        match values [0] {
            tx : &Type => { // TemplateVarType is here to check the kind of type that is used, ("alias", "class", "struct" and "tuple"), so it has to be a type
                let t = context:.implicitEnumUnwrap (tx);
                match v.getKind () {
                    TemplateVarType::ALIAS => {
                        if (!t.needExplicitAlias ()) { // "alias", means its an aliasable type
                            throw ErrorMsg::fatal (values[0].getLoc (), format (ValidateErrorMessage::NOT_ALIASABLE, t),
                                                   notes-> [ErrorMsg::note (v.getLoc (), ""s8)]);
                        }
                    }
                    TemplateVarType::CLASS => { // "class" must be a class type
                        if (!t.isOf!{&ClassPtrType} ()) {
                            throw ErrorMsg::fatal (values[0].getLoc (), format (ValidateErrorMessage::NOT_A_CLASS, t),
                                                   notes-> [ErrorMsg::note (v.getLoc (), ""s8)]);
                        }
                    }
                    TemplateVarType::STRUCT => { // "struct" must be a struct type
                        if (!t.isOf!{&StructType} ()) {
                            throw ErrorMsg::fatal (values[0].getLoc (), format (ValidateErrorMessage::NOT_A_STRUCT, t),
                                                   notes-> [ErrorMsg::note (v.getLoc (), ""s8)]);
                        }
                    }
                    TemplateVarType::TUPLE => { // "tuple" must be a tuple type
                        if (!t.isOf!{&TupleType} ()) {
                            throw ErrorMsg::fatal (values[0].getLoc (), format (ValidateErrorMessage::NOT_A_TUPLE, t),
                                                   notes-> [ErrorMsg::note (v.getLoc (), ""s8)]);
                        }
                    }
                }

                // There was no problem, so we can return a mapper, with the type association
                let dmut retMapper = TemplateMapper::new (score-> TemplateScore::VAR); // normal score
                retMapper:.insert (v.getLoc ().str (), self.createTypeWrapper (t.getLoc (), t)); // insert the mapping
                return (retMapper, 1us); // 1 type consumed
            }
            _ => { // a value was passed, no association possible here
                throw ErrorMsg::fatal (values [0].getLoc (), format (ValidateErrorMessage::USE_AS_TYPE_TEMPLATE, values[0]),
                                       notes-> [ErrorMsg::note (v.getLoc (), ""s8)]);
            }
        }
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================  VARIADIC TEMPLATE EXPLICIT  =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a template variadic var
     * @params: 
     *    - context: the context of the validation
     *    - alls: the list of template parameters of the current specialization
     *    - v: the variadic to validate
     *    - values: the list of values/types to pass to the variadic template
     * @returns: 
     *    - .0: the template parameter specialization
     *    - .1: the number of consumed parameters (should be 1us)
     * @throws:
     *    - &ErrorMsg: if the values cannot be used to specialize the template parameter
     */
    fn validateTemplateVariadicFromExplicit (self, dmut _ : &Validator, _ : [&Expression], v : &TemplateVariadicVarExpr, values : [&Generator])-> (&TemplateMapper, usize)
        throws &ErrorMsg
    {
        // Not a complex function, simply transform all the types in 'values' into a template type
        let dmut retTypes = Vec!{&Type}::new ();
        for i in 0us .. values.len { 
            match values [i] {
                t : &Type => { retTypes:.push (t); }
                _ => { // only types can be used to perform a type specialization
                    throw ErrorMsg::fatal (values [i].getLoc (), format (ValidateErrorMessage::USE_AS_TYPE_TEMPLATE, values [i]),
                                           notes-> [ErrorMsg::note (v.getLoc (), ""s8)]);
                }
            }
        }

        let dmut retMapper = TemplateMapper::new (score-> TemplateScore::VAR);
        if (retTypes.len () != 1us) {
            retMapper:.insert (v.getLoc ().str (), TypeListWrapperExpr::new (v.getLoc (), retTypes[])); // insert the tuple in the mapper            
        } else {
            retMapper:.insert (v.getLoc ().str (), self.createTypeWrapper (v.getLoc (), retTypes[][0us])); // insert a single type in the mapper
        }
        
        return (retMapper, values.len); // consumed as many types as there are to consumed
    }       


    /*!
     * ================================================================================
     * ================================================================================
     * =========================   ANY EXPRESSION EXPLICIT   ==========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a var decl expression test from explicit specialization
     * @params:
     *     - context: the context of the validation
     *     - vdecl: the var declaration to validate
     *     - values: the list of values explicitly passed for template specialization
     * @returns: 
     *     - .0: the template mapper specialization
     *     - .1: the number of consumed parameters 
     * @throws:
     *     - &ErrorMsg: if the var decl cannot be specialized from values
     */
    fn validateVarDeclExprFromExplicit (self, dmut context : &Validator, alls : [&Expression], vdecl : &VarDeclExpr, values : [&Generator])-> (&TemplateMapper, usize)
        throws &ErrorMsg
    {
        if (values.len == 0us) throw ErrorMsg::fatal (vdecl.getLoc (), format (ValidateErrorMessage::TEMPLATE_SPECIALIZATION_FAILS, vdecl, values));
        match values [0] {
            mut v : &Value => {
                let dmut retMapper = TemplateMapper::new (score-> TemplateScore::VALUE);

                match vdecl.getType () {
                    EmptyExpression () => {}
                    UnitExpr () => {}
                    func : &FunctionPtrTypeExpr => {
                        return self.validateVarDeclFunctionValueFromExplicit (alias context, vdecl.getLoc(), alls, func, v);
                    }
                    type : _ => {
                        let (mapper, _) = self.validateOfVarExprFromExplicit (alias context, alls, type, [v.getType ()]);
                        let rewriteType = self.performTemplateRewrite (type, mapper);
                        let vType = context:.validateType (rewriteType);
                        v = context:.verifyCompatibleTypeWithValue (type.getLoc (), vType, v, byReference-> false);

                        retMapper:.merge (mapper);
                    }
                }
                
                match vdecl.getValue () {
                    EmptyExpression () => {}
                    UnitExpr () => {}
                    val : _ => {
                        let vVal = context:.validateValue (val);
                        if (!context.getCompileTimeInterpreter ().isCte (vVal)) {
                            throw ErrorMsg::fatal (vVal.getLoc (), format (ValidateErrorMessage::UNKNOWN_AT_COMPILE_TIME, vVal.getType ()));
                        }

                        if (v != vVal) {
                            throw ErrorMsg::fatal (vdecl.getLoc (), format (ValidateErrorMessage::TEMPLATE_SPECIALIZATION_FAILS, vdecl, values), 
                                                   notes-> [ErrorMsg::fatal (v.getLoc (), format (ValidateErrorMessage::INCOMPATIBLE_VALUES, vVal, v))]);
                        }
                    }
                }

                retMapper:.insert (vdecl.getLoc ().str (), ValueWrapperExpr::new (vdecl.getLoc (), v));

                return (retMapper, 1us);
            }
            t : _ => {
                throw ErrorMsg::fatal (vdecl.getLoc (), format (ValidateErrorMessage::TEMPLATE_SPECIALIZATION_FAILS, vdecl, values), 
                                       notes-> [ErrorMsg::fatal (t.getLoc (), format (ValidateErrorMessage::USE_AS_VALUE_TEMPLATE, t))]);
            }
        }
    }

    /**
     * Validate a value expression test from explicit specialization
     * @params:
     *     - context: the context of the validation
     *     - expr: the expression to validate and compare
     *     - values: the list of values explicitely passed for template specialization
     * @returns: 
     *    - .0: the template mapper specialization
     *    - .1: the number of consumed parameters (should be always 1)
     * @throws:
     *    - &ErrorMsg: if the values are not compatible (or expr is not cte)
     */
    fn validateValueExpressionFromExplicit (self, dmut context : &Validator, expr : &Expression, values : [&Generator])-> (&TemplateMapper, usize)
        throws &ErrorMsg
    {
        let val = context:.validateValue (expr);
        if (!context.getCompileTimeInterpreter ().isCte (val)) {
            throw ErrorMsg::fatal (val.getLoc (), format (ValidateErrorMessage::UNKNOWN_AT_COMPILE_TIME, val.getType ()));
        }
        
        if (values.len == 0us) throw ErrorMsg::fatal (expr.getLoc (), format (ValidateErrorMessage::TEMPLATE_SPECIALIZATION_FAILS, expr, values));
        match values [0] {
            v : &Value => {
                if (v == val) {
                    let dmut retMapper = TemplateMapper::new (score-> TemplateScore::VALUE);
                    let loc = expr.getLoc ();
                    retMapper:.insert (format ("%[%,%]", loc.str (), loc.line (), loc.col ()), ValueWrapperExpr::new (loc, v));

                    return (retMapper, 1us);
                } else {
                    throw ErrorMsg::fatal (expr.getLoc (), format (ValidateErrorMessage::TEMPLATE_SPECIALIZATION_FAILS, expr, values), 
                                           notes-> [ErrorMsg::fatal (v.getLoc (), format (ValidateErrorMessage::INCOMPATIBLE_VALUES, val, v))]);
                }
            }
            t : _ => {                
                throw ErrorMsg::fatal (expr.getLoc (), format (ValidateErrorMessage::TEMPLATE_SPECIALIZATION_FAILS, expr, values),
                                       notes-> [ErrorMsg::fatal (t.getLoc (), format (ValidateErrorMessage::USE_AS_VALUE_TEMPLATE, t))]);
                
            }
        }
    }

    /*!
     * =============================================================================================
     * =============================================================================================
     * =========================           EXPLICIT LAMBDA VALUE           =========================
     * =============================================================================================
     * =============================================================================================
     */

    /**
     * Validate a function value expression (vardecl : fn (...)-> ...) using a cte value
     * @params:
     *   - context: the context of the validation
     *   - loc: the location of the vardecl
     *   - alls: the template parameters being specialied
     *   - fptrType: the type of the var decl being specialized
     *   - value: the value used for specialization
     * @returns:
     *   - .0: the template mapper, with the most information possible
     *   - .1: 1us
     * @warning:
     * The returned template mapper may contain lambdavaluewrapper,
     * and thus need to be finalized by the template declarator, to create
     * the function pointer from the lambda value with the correct types
     * */
    fn validateVarDeclFunctionValueFromExplicit (self, dmut context : &Validator, loc : &Word, alls : [&Expression], fptrType : &FunctionPtrTypeExpr, value : &Value)-> (&TemplateMapper, usize)
        throws &ErrorMsg
    {
        if (fptrType.isClosure ()) {
            throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::TEMPLATE_SPECIALIZATION_FAILS, fptrType, value.getType ()),
                                   notes-> [ErrorMsg::fatal (fptrType.getLoc (), ValidateErrorMessage::CLOSURE_TEMPLATE_LAMBDA)]);
        }

        match value {
            lmbdValue : &LambdaValue => {
                return self.validateVarDeclLambdaFromExplicit (alias context, loc, alls, fptrType, lmbdValue);
            }
            nameFunc : &NameFuncPtrValue => {
                return self.validateVarDeclNameFuncPtrFromExplicit (alias context, loc, alls, fptrType, nameFunc);
            }
            _ => {
                throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::TEMPLATE_SPECIALIZATION_FAILS, fptrType, value.getType ()),
                                       notes-> [ErrorMsg::fatal (fptrType.getLoc (), format (ValidateErrorMessage::INCOMPATIBLE_VALUES, fptrType, value))]);
            }
        }
    }

    /**
     * * Validate a function value expression (vardecl : fn (...)-> ...) using a function pointer value for specialization
     * * @params:
     *   - context: the context of the validation
     *   - loc: the location of the vardecl
     *   - alls: the template parameters being specialied
     *   - fptrType: the type of the var decl being specialized
     *   - fptrValue: the function pointer value used for specialization
     * @returns:
     *   - .0: the template mapper, with the most information possible
     *   - .1: 1us
     * */
    fn validateVarDeclNameFuncPtrFromExplicit (self, dmut context : &Validator, loc : &Word, alls : [&Expression], fptrType : &FunctionPtrTypeExpr, fptrValue : &NameFuncPtrValue)-> (&TemplateMapper, usize)
        throws &ErrorMsg
    {
        let fptrValueType = fptrValue.getType ().asOf!{&FuncPtrType} ();

        let dmut retMapper = TemplateMapper::new (score-> TemplateScore::VALUE);
        let (typeMapper, _) = self.validateOfFuncPtrInnerExplicit (alias context, alls, fptrType, [fptrValueType]);
        retMapper:.merge (typeMapper);

        let finalType = self.performTemplateRewrite (fptrType, retMapper);
        let ofType = context:.validateType (finalType);
        let ofValue = context:.verifyCompatibleTypeWithValue (loc, ofType, fptrValue, byReference-> false);

        retMapper:.insert (loc.str (), ValueWrapperExpr::new (loc, ofValue));

        return (retMapper, 1us);
    }

    /**
     * * Validate a function value expression (vardecl : fn (...)-> ...) using a lambda value for specialization
     * * @params:
     *   - context: the context of the validation
     *   - loc: the location of the vardecl
     *   - alls: the template parameters being specialied
     *   - fptrType: the type of the var decl being specialized
     *   - lmbdValue: the lambda value used for specialization
     * @returns:
     *   - .0: the template mapper, with the most information possible
     *   - .1: 1us
     * @warning:
     * The returned template mapper may contain lambdavaluewrapper,
     * and thus need to be finalized by the template declarator, to create
     * the function pointer from the lambda value with the correct types
     * */
    fn validateVarDeclLambdaFromExplicit (self, dmut context : &Validator, loc : &Word, alls : [&Expression], fptrType : &FunctionPtrTypeExpr, lmbdValue : &LambdaValue)-> (&TemplateMapper, usize)
        throws &ErrorMsg
    {
        if (lmbdValue.isClosure ()) {
            throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::TEMPLATE_SPECIALIZATION_FAILS, fptrType, lmbdValue),
                                   notes-> [ErrorMsg::fatal (lmbdValue.getLoc (), ValidateErrorMessage::CLOSURE_TEMPLATE_LAMBDA)]);
        }

        if (fptrType.getParameters ().len > lmbdValue.getParameters ().len) {
            throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::TEMPLATE_SPECIALIZATION_FAILS, fptrType, lmbdValue),
                                   notes-> [ErrorMsg::fatal (fptrType.getLoc (), format (ValidateErrorMessage::INCOMPATIBLE_VALUES, fptrType, lmbdValue))]);
        }

        let dmut retMapper = TemplateMapper::new (score-> TemplateScore::VALUE);
        let (paramMapper, uncomplete, paramTypes) = self.validateLambdaParameters (alias context, alls, fptrType, lmbdValue);
        retMapper:.merge (paramMapper);

        if (!uncomplete) { // the lambda value can be completed using the infered types
            self.finalizeLambdaPrototype (alias context, loc, alls, fptrType, lmbdValue, paramTypes, alias retMapper);
            return (retMapper, 1us);
        }

        // It cannot, but maybe we can get some more informations from it
        if (!lmbdValue.getRetType ().isOf!{&NoneType} ()) {
            let returnExpr = self.performTemplateRewrite (fptrType.getReturn (), retMapper);
            let (retTypeMapper, _) = self.validateOfVarExprFromExplicit (alias context, alls, returnExpr, [lmbdValue.getRetType ()]);
            retMapper:.merge (retTypeMapper);
        }

        match self.performTemplateRewrite (fptrType, retMapper) {
            fptr : &FunctionPtrTypeExpr => { // insert the uncomplete lambda, for future validation in finalization of the rewritter
                retMapper:.insert (loc.str (), LambdaValueWrapperExpr::new (loc, loc.str (), fptr, lmbdValue));
            }
            _ => __pragma!panic ();
        }

        return (retMapper, 1us);
    }


    /**
     * Try to infer the types of the function parameters, using an uncomplete lambda value
     * @returns:
     *   .0: the template mapper, with some validated types
     *   .1: true iif all the lambda types are validated
     *   .2: the list of types for the parameters (contains some none type if !.1)
     * */
    fn validateLambdaParameters (self, dmut context : &Validator, alls : [&Expression], fptrType : &FunctionPtrTypeExpr, lmbdValue : &LambdaValue)-> (&TemplateMapper, bool, [&Type])
        throws &ErrorMsg
    {
        let dmut retMapper = TemplateMapper::new ();
        let rewriter = TemplateRewriter::new (retMapper);
        let mut uncomplete = false;
        let dmut paramTypes = Vec!{&Type}::new ();

        if (fptrType.getParameters ().len != lmbdValue.getParameters ().len) {
            return (retMapper, true, []);
        }

        for i, ti in fptrType.getParameters () match lmbdValue.getParameters ()[i] {
            v : &ProtoVarValue => { // lambda has a type to validate
                match ti {
                    vd : &VarDeclExpr => {
                        let tiExpr = rewriter.rewrite (vd.getType ());
                        let (tiMapper, _) = self.validateOfVarExprFromExplicit (alias context, alls, tiExpr, [v.getType ()]);
                        retMapper:.merge (tiMapper);

                        let finalExpr = rewriter.rewrite (vd.getType ());
                        paramTypes:.push (context:.validateType (finalExpr));
                    }
                    _ => __pragma!panic ();
                }
            }
            _ => { paramTypes:.push (NONE_TYPE); }
        }

        for i, ti in fptrType.getParameters () match lmbdValue.getParameters ()[i] {
            ProtoVarValue () => {}
            _ => {
                match ti {
                    v : &VarDeclExpr => {
                        let tiExpr = rewriter.rewrite (v.getType ());
                        {
                            (alias paramTypes) [i] = context:.validateType (tiExpr);
                        } catch {
                            _ => { uncomplete = true; }
                        }
                    }
                    _ => __pragma!panic ();
                }
            }
        }

        (retMapper, uncomplete, paramTypes[])
    }

    /**
     * Finalize the creation of the prototype of the lambda function from the specialization
     * @assume: the paramTypes are complete
     * */
    fn finalizeLambdaPrototype (self, dmut context : &Validator, loc : &Word, alls : [&Expression], fptrType : &FunctionPtrTypeExpr, lmbdValue : &LambdaValue, paramTypes : [&Type], dmut retMapper : &TemplateMapper)
        throws &ErrorMsg
    {
        let (proto_, frame) = context:.getLambdaValidator ().validateLambdaBody (alias context, lmbdValue, paramTypes);
        let proto = proto_.asOf!{&NameFuncPtrValue} ();

        let retType = proto.getType ().asOf!{&FuncPtrType} ().getRetType ();
        let returnExpr = self.performTemplateRewrite (fptrType.getReturn (), retMapper);
        let (retTypeMapper, _) = self.validateOfVarExprFromExplicit (alias context, alls, returnExpr, [retType]);

        context:.getLambdaValidator ():.insertGenerator (alias context, frame);
        retMapper:.merge (retTypeMapper);
        retMapper:.insert (loc.str (), ValueWrapperExpr::new (loc, proto));

        let rewriter = TemplateRewriter::new (retMapper);
        let fptrFinal = rewriter.rewrite (fptrType);
        let ofType = context:.validateType (fptrFinal);

        context:.verifyCompatibleType (fptrType.getLoc (), lmbdValue.getLoc (), ofType, proto.getType ());
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================           IMPLICIT           =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a template implicit validation of a parameter that may contain template variables
     * @params: 
     *    - context: the context of the validation
     *    - templates: the list of template associated to the parameter
     *    - parameter: the syntax expression (basically a vardecl) that contains a type that may contain template variable
     *    - types: the list of type that can be associated to the templates
     * @returns:
     *    - .0: the mapper in case of validation (used to create a valid rewriter)
     *    - .1: the number of types that were consumed during the validation
     * @throws:
     *    - &ErrorMsg: if the specialization failed
     */
    fn validateParamTemplateFromImplicit (self, dmut context : &Validator, templates : [&Expression], param : &Expression, types : [&Type])-> (&TemplateMapper, usize)
        throws &ErrorMsg
    {
        match param {
            x : &VarDeclExpr => {
                match x.getType () { // we want to transform its type from implicit specialization
                    EmptyExpression () => { // It has no type
                        (TemplateMapper::new (), 0us)
                    }
                    UnitExpr () => { // Also no type, 
                        (TemplateMapper::new (), 0us) // we return an empty template mapper, because the specialization works, it just gives no information
                    }
                    type : _ => { // There is possible information, if the type contains templates, so we validate it
                        {
                            self.validateTypeFromImplicit (alias context, templates, type, types)
                        } catch {
                            err : &ErrorMsg => {
                                throw err;
                                // throw ErrorMsg::fatal (param.getLoc (), format (ValidateErrorMessage::PARAMETER_NAME, x.getName ()), notes-> [err]);
                            }
                        }
                    }
                }
            }
            _ => __pragma!panic ();  // necessarily a vardecl, implicit specialization are for function proto, ctor, and structs, so always vardecls are usable, we can't make an implicit specialization without them that is the premise
        }
    }

    /**
     * Validate the implicit specialization of 'typeExpr' from 'types' using 'templates' as template parameters 
     * @params: 
     *    - context: the context of the validation
     *    - templates: the list of tempalte to specialize
     *    - typeExpr: a type foudn during implicit validation (inside vardecl for example)
     *    - types: the types that will be used to transform typeExpr, and templates into specialized values
     * @returns:
     *    - .0: the mapper in case of validation (used to create a valid rewriter)
     *    - .1: the number of types that were consumed during the validation
     * @throws:
     *    - &ErrorMsg: if the specialization failed
     */
    fn validateTypeFromImplicit (self, dmut context : &Validator, templates : [&Expression], typeExpr : &Expression, types : [&Type])-> (&TemplateMapper, usize)
        throws &ErrorMsg
    {
        match typeExpr {
            s : &SliceAllocatorExpr => {
                return self.validateTypeFromImplicitAlloc (alias context, templates, s, types);
            }
            c : &TemplateCallExpr => {
                return self.validateTypeFromImplicitTemplateCall (alias context, templates, c, types);
            }
            v : &VarExpr => {
                return self.validateTypeFromImplicitVarExpr (alias context, templates, v, types);
            }
            p : &PathExpr => {
                return self.validateTypeFromImplicitPath (alias context, templates, p, types);
            }
            b : &BinaryExpr => {
                return self.validateTypeFromImplicitBinary (alias context, templates, b, types);
            }
            un : &UnaryExpr => {
                return self.validateTypeFromImplicitUnary (alias context, templates, un, types);
            }
            r : &RangeTypeExpr => {
                return self.validateTypeFromImplicitRangeExpr (alias context, templates, r, types);
            }
            d : &DecoratedExpr => {
                return self.validateTypeFromImplicit (alias context, templates, d.getContent (), types);
            }
            lst : &ListExpr => {
                if (lst.isArray ()) {
                    return self.validateTypeFromImplicitSlice (alias context, templates, lst, types);
                } else {
                    return self.validateTypeFromImplicitTuple (alias context, templates, lst, types);
                }
            }
            f : &FunctionPtrTypeExpr => {
                return self.validateTypeFromImplicitFptr (alias context, templates, f, types);
            }
            _ => {
                return (TemplateMapper::new (), 1us);
            }
        }
    }


    /**
     * Validate the implicit specialization of a type using a slice allocation expression
     * @params:
     *    - context: the context of the validaiton
     *    - templates: the list of template to specialize
     *    - lst: the list expression of slice type to validate
     *    - types: the types that will be used to transform typeExpr, and templates into specialized values
     * @returns:
     *    - .0: the mapper in case of validation (used to create a valid rewriter)
     *    - .1: the number of types that were consumed during the validation
     * @throws:
     *    - &ErrorMsg: if the specialization failed
     * */
    fn validateTypeFromImplicitAlloc (self, dmut context : &Validator, templates : [&Expression], s : &SliceAllocatorExpr, types : [&Type])-> (&TemplateMapper, usize)
        throws &ErrorMsg
    {
        if (types.len >= 1us) {
            match context:.implicitEnumUnwrap (types [0]) {
                slc : &SliceType => {
                    let dmut retMapper = TemplateMapper::new ();
                    let (typeMapper, _) = self.validateTypeFromImplicit (alias context, templates, s.getValue (), slc.getInners ());
                    retMapper:.merge (typeMapper);
                    match (s.getSize (), slc.getSize ()) {
                        (_, UnitValue ()) => {}
                        (v : &VarExpr, size : &Value) => {
                            let expr = self.findExpression (v.getLoc ().str (), templates);
                            if !expr.isOf!{&EmptyExpression} () {
                                let (valMapper, _) = self.validateParamTemplateFromExplicit (alias context, templates, expr, [cast!(&Generator) (size)]);
                                retMapper:.merge (valMapper);
                            }
                        }
                    }

                    return (retMapper, 1us);
                }
                arr : &ArrayType => {
                    let dmut retMapper = TemplateMapper::new ();
                    let (typeMapper, _) = self.validateTypeFromImplicit (alias context, templates, s.getValue (), arr.getInners ());
                    retMapper:.merge (typeMapper);

                    match s.getSize () {
                        v : &VarExpr => {
                            let expr = self.findExpression (v.getLoc ().str (), templates);
                            if !expr.isOf!{&EmptyExpression} () {
                                let (valMapper, _) = self.validateParamTemplateFromExplicit (alias context, templates, expr, [cast!(&Generator) (makeIntValue (arr.getLoc (), arr.getLen ()))]);
                                retMapper:.merge (valMapper);
                            }
                        }
                    }

                    return (retMapper, 1us);
                }
            }
        }

        return (TemplateMapper::new (), 1us);
    }

    /**
     * Validate the implicit specialization of a template call
     * @params:
     *    - context: the context of the validaiton
     *    - templates: the list of template to specialize
     *    - tmp: the template call to specialize
     *    - types: the types that will be used to transform typeExpr, and templates into specialized values
     * @returns:
     *    - .0: the mapper in case of validation (used to create a valid rewriter)
     *    - .1: the number of types that were consumed during the validation
     * @throws:
     *    - &ErrorMsg: if the specialization failed
     * */
    fn validateTypeFromImplicitTemplateCall (self, dmut context : &Validator, templates : [&Expression], tmp : &TemplateCallExpr, types : [&Type])-> (&TemplateMapper, usize)
        throws &ErrorMsg
    {
        if (types.len == 0us) { return (TemplateMapper::new (), 1us); }
        let (hasTmps, clTemplates) = self.createTemplateListOfType (context:.implicitEnumUnwrap (types [0]));
        if (!hasTmps) return (TemplateMapper::new (), 1us);

        if (tmp.getRights ().len > clTemplates.len) return (TemplateMapper::new (), 1us);
        let dmut retMapper = TemplateMapper::new ();
        let rewriter = TemplateRewriter::new (retMapper);
        let mut consumed = 0us;
        let mut syntTemplate = templates;

        for i in 0us .. tmp.getRights ().len {
            let currentParam = rewriter.rewrite (tmp.getRights ()[i]);
            let rest = clTemplates.len - consumed;
            let syntaxRest = (tmp.getRights ().len - i) - 1us;

            let consomableTypes = clTemplates [consumed .. consumed + (rest - syntaxRest)];
            let (mapper, localConsumed) = if (consomableTypes.len > 0us && consomableTypes [0].isOf!{&Value} ()) {
                let (mp, _) = self.validateParamTemplateFromExplicit (alias context, syntTemplate, currentParam, [consomableTypes [0]]);
                (mp, 1us)
            } else {
                let dmut lst = Vec!{&Type}::new ();
                for ti in consomableTypes match ti {
                    t : &Type => { lst:.push (t); }
                    _ => { break {} }
                }
                self.validateTypeFromImplicit (alias context, syntTemplate, currentParam, lst[])
            }

            retMapper:.merge (mapper);
            consumed += cast!usize (localConsumed);
            syntTemplate = rewriter.replaceSyntaxTempl (syntTemplate);
        }

        return (retMapper, 1us);
    }

    /**
     * Retreive the list of template from a type as a list of types
     * @warning: only return the types, leaving the values from the mapper
     * @info:
     *  - can return.0 be true, but with an empty list as .1, meaning there are templates, but some are values
     * @returns:
     *    - .0: true iif the type has templates
     *    - .1: the list of types
     * */
    fn createTemplateListOfType (self, type : &Type)-> (bool, [&Generator]) {
        let mapper = match type {
            cl : &ClassPtrType => {
                match cl.getInner ().getTemplateMapper () {
                    Ok (clTmps : _) => {
                        clTmps
                    }
                    _ => { return (false, []); }
                }
            }
            cl : &ClassRefType => {
                match cl.getTemplateMapper () {
                    Ok (clTmps : _) => {
                        clTmps
                    }
                    _ => { return (false, []); }
                }
            }
            _ => { return (false, []); }
        };

        let dmut vec = Vec!{&Generator}::new ();
        for mp in mapper.getMapperSorted () match mp {
            t : &TypeWrapperExpr => {
                vec:.push (t.getType ());
            }
            t : &TypeListWrapperExpr => {
                for ti in t.getTypes () { vec:.push (ti); }
            }
            v : &ValueWrapperExpr => {
                vec:.push (v.getValue ());
            }
        }

        (true, vec[])
    }

    /**
     * Validate the implicit specialization of 'var' from 'types' using 'templates' as template parameters
     * @params: 
     *    - context: the context of the validation
     *    - templates: the list of template to specialize
     *    - var: a var expr describing a type
     *    - types: the types that will be used to transform typeExpr, and templates into specialized values
     * @returns:
     *    - .0: the mapper in case of validation (used to create a valid rewriter)
     *    - .1: the number of types that were consumed during the validation
     * @throws:
     *    - &ErrorMsg: if the specialization failed
     */
    fn validateTypeFromImplicitVarExpr (self, dmut context : &Validator, templates : [&Expression], var : &VarExpr, types : [&Type])-> (&TemplateMapper, usize)
        throws &ErrorMsg
    {
        let tmp = self.findExpression (var.getLoc ().str (), templates);
        match tmp {
            EmptyExpression () => {
                return (TemplateMapper::new (), 1us);
            }
            _ => {
                let (ret, nb) = self.validateParamTemplateFromExplicit (alias context, templates, tmp, types);
                (ret, nb)
            }
        }
    }

    /**
     * Validate the implicit specialization of a path expression (A::B)
     * @params:
     *    - context: the context of the validation
     *    - templates: the list of templates to specialize
     *    - path: the path expression to specialize
     *    - types: the list of types used to specilize the path expr
     * @returns:
     *    - .0: the mapper in case of validation (used to create a valid rewriter)
     *    - .1: the number of types that were consumed during the validation
     * @throws:
     *    - &ErrorMsg: if the specialization failed
     * */
    fn validateTypeFromImplicitPath (self, dmut context : &Validator, templates : [&Expression], path : &PathExpr, types : [&Type])-> (&TemplateMapper, usize)
        throws &ErrorMsg
    {
        if (types.len >= 1us) {
            let (mapper, _) = self.validateTypeFromImplicit (alias context, templates, path.getRight (), types [0 .. 1]);
            return (mapper, 1us);
        }

        return (TemplateMapper::new (), 1us);
    }

    /**
     * Validate the implicit specialization of a binary expression (A::B)
     * @params:
     *    - context: the context of the validation
     *    - templates: the list of templates to specialize
     *    - bin: the binary expression to specialize
     *    - types: the list of types used to specilize the path expr
     * @returns:
     *    - .0: the mapper in case of validation (used to create a valid rewriter)
     *    - .1: the number of types that were consumed during the validation
     * @throws:
     *    - &ErrorMsg: if the specialization failed
     * */
    fn validateTypeFromImplicitBinary (self, dmut context : &Validator, templates : [&Expression], bin : &BinaryExpr, types : [&Type])-> (&TemplateMapper, usize)
        throws &ErrorMsg
    {
        if (types.len >= 1us) {
            match (bin.getLoc ().str (), bin.getRight ()) {
                (BinaryOperators::DCOLON, v : &Expression) => {
                    let (mapper, _) = self.validateTypeFromImplicit (alias context, templates, v, types [0..1]);
                    return (mapper, 1us);
                }
            }
        }

        return (TemplateMapper::new (), 1us);
    }

    /**
     * Validate the implicit specialization of a type using an unary operator expression
     * @params:
     *    - context: the context of the validaiton
     *    - templates: the list of template to specialize
     *    - un: the unary operator type to validate
     *    - types: the types that will be used to transform typeExpr, and templates into specialized values
     * @returns:
     *    - .0: the mapper in case of validation (used to create a valid rewriter)
     *    - .1: the number of types that were consumed during the validation
     * @throws:
     *    - &ErrorMsg: if the specialization failed
     * */
    fn validateTypeFromImplicitUnary (self, dmut context : &Validator, templates : [&Expression], un : &UnaryExpr, types : [&Type])-> (&TemplateMapper, usize)
        throws &ErrorMsg
    {
        if (types.len >= 1us) {
            match context:.implicitEnumUnwrap (types [0us]) {
                p : &PointerType => {
                    let (mapper, _) = self.validateTypeFromImplicit (alias context, templates, un.getOperand (), p.getInners ());
                    return (mapper, 1us);
                }
                c : &ClassPtrType => {
                    let (mapper, _) = self.validateTypeFromImplicit (alias context, templates, un.getOperand (), [c.getInner ()]);
                    return (mapper, 1us);
                }
            }
        }

        return (TemplateMapper::new (), 1us);
    }

    /**
     * Validate the implicit specialization of a range type expr, from 'types' using 'templates' as template parameters
     * @params:
     *    - context: the context of the validaiton
     *    - templates: the list of template to specialize
     *    - r: the range type to validate
     *    - types: the types that will be used to transform typeExpr, and templates into specialized values
     * @returns:
     *    - .0: the mapper in case of validation (used to create a valid rewriter)
     *    - .1: the number of types that were consumed during the validation
     * @throws:
     *    - &ErrorMsg: if the specialization failed
     */
    fn validateTypeFromImplicitRangeExpr (self, dmut context : &Validator, templates : [&Expression], r : &RangeTypeExpr, types : [&Type])-> (&TemplateMapper, usize)
        throws &ErrorMsg
    {
        if (types.len >= 1us) {
            match context:.implicitEnumUnwrap (types [0us]) {
                rng : &RangeType => {
                    let (mapper, _) = self.validateTypeFromImplicit (alias context, templates, r.getType (), rng.getInners ());

                    return (mapper, 1us)
                }
            }
        }

        return (TemplateMapper::new (), 1us);
    }

    /**
     * Validate the implicit specialization of a type using a list expression of a slice
     * @params:
     *    - context: the context of the validaiton
     *    - templates: the list of template to specialize
     *    - lst: the list expression of slice type to validate
     *    - types: the types that will be used to transform typeExpr, and templates into specialized values
     * @returns:
     *    - .0: the mapper in case of validation (used to create a valid rewriter)
     *    - .1: the number of types that were consumed during the validation
     * @throws:
     *    - &ErrorMsg: if the specialization failed
     * */
    fn validateTypeFromImplicitSlice (self, dmut context : &Validator, templates : [&Expression], lst : &ListExpr, types : [&Type])-> (&TemplateMapper, usize)
        throws &ErrorMsg
    {
        if (types.len >= 1us && lst.getParameters ().len == 1us) {
            match context:.implicitEnumUnwrap (types [0]) {
                s : &SliceType => {
                    let (mapper, _) = self.validateTypeFromImplicit (alias context, templates, lst.getParameters ()[0], s.getInners ());
                    return (mapper, 1us);
                }
            }
        }

        return (TemplateMapper::new (), 1us);
    }


    /**
     * Validate the implicit specialization of a type using a list expression of a tuple
     * @params:
     *    - context: the context of the validaiton
     *    - templates: the list of template to specialize
     *    - lst: the list expression of tuple type to validate
     *    - types: the types that will be used to transform typeExpr, and templates into specialized values
     * @returns:
     *    - .0: the mapper in case of validation (used to create a valid rewriter)
     *    - .1: the number of types that were consumed during the validation
     * @throws:
     *    - &ErrorMsg: if the specialization failed
     * */
    fn validateTypeFromImplicitTuple (self, dmut context : &Validator, templates : [&Expression], lst : &ListExpr, types : [&Type])-> (&TemplateMapper, usize)
        throws &ErrorMsg
    {
        if (types.len >= 1us) {
            match context:.implicitEnumUnwrap (types [0]) {
                t : &TupleType => {
                    if (lst.getParameters ().len > t.getInners ().len) return (TemplateMapper::new (), 1us);

                    let dmut retMapper = TemplateMapper::new ();
                    let rewriter = TemplateRewriter::new (retMapper);
                    let mut consumed = 0us;
                    let mut syntTemplate = templates;

                    for i in 0us .. lst.getParameters ().len {
                        let currentParam = rewriter.rewrite (lst.getParameters ()[i]);
                        let rest = t.getInners ().len - consumed;
                        let syntaxRest = (lst.getParameters ().len - i) - 1us;

                        let consomableTypes = t.getInners ()[consumed .. consumed + (rest - syntaxRest)];
                        let (mapper, localConsumed) = self.validateTypeFromImplicit (alias context, syntTemplate, currentParam, consomableTypes);

                        retMapper:.merge (mapper);
                        consumed += cast!usize (localConsumed);
                        syntTemplate = rewriter.replaceSyntaxTempl (syntTemplate);
                    }

                    return (retMapper, 1us);
                }
            }
        }

        return (TemplateMapper::new (), 1us);
    }

    /**
     * Validate the implicit specialization of a type using a function pointer type expression
     * @params:
     *    - context: the context of the validaiton
     *    - templates: the list of template to specialize
     *    - fptr: the function pointer expression of a fptr type to validate
     *    - types: the types that will be used to transform typeExpr, and templates into specialized values
     * @returns:
     *    - .0: the mapper in case of validation (used to create a valid rewriter)
     *    - .1: the number of types that were consumed during the validation
     * @throws:
     *    - &ErrorMsg: if the specialization failed
     * */
    fn validateTypeFromImplicitFptr (self, dmut context : &Validator, templates : [&Expression], fptrType : &FunctionPtrTypeExpr, types : [&Type])-> (&TemplateMapper, usize)
        throws &ErrorMsg
    {
        if (types.len >= 1us) {
            let (params, retType) = match context:.implicitEnumUnwrap (types [0]) {
                l : &LambdaType   => { return self.validateTypeFromImplicitLambda (alias context, templates, fptrType, l); }
                d : &DelegateType => { (d.getParameters (), d.getRetType ()) }
                f : &FuncPtrType   => { (f.getParameters (), f.getRetType ()) }
                _ => {
                    return (TemplateMapper::new (), 1us);
                }
            };

            if (fptrType.getParameters ().len > params.len) {
                return (TemplateMapper::new (), 1us);
            }

            let mut consumed = 0us;
            let dmut retMapper = TemplateMapper::new ();
            let rewriter = TemplateRewriter::new (retMapper);
            let mut syntTemplate = templates;

            for i in 0us .. fptrType.getParameters ().len {
                match fptrType.getParameters ()[i] {
                    v : &VarDeclExpr => {
                        let currentParam = rewriter.rewrite (v.getType ());
                        let rest = params.len - consumed;
                        let syntaxRest = (fptrType.getParameters ().len - i) - 1us;

                        let consomableTypes = params [consumed .. consumed + (rest - syntaxRest)];
                        let (tiMapper, localConsumed) = self.validateTypeFromImplicit (alias context, syntTemplate, currentParam, consomableTypes);

                        retMapper:.merge (tiMapper);
                        consumed += cast!usize (localConsumed);
                        syntTemplate = rewriter.replaceSyntaxTempl (syntTemplate);
                    }
                    _ => __pragma!panic ();
                }
            }

            let retParam = rewriter.rewrite (fptrType.getReturn ());
            let (tiMapper, _) = self.validateTypeFromImplicit (alias context, syntTemplate, retParam, [retType]);
            retMapper:.merge (tiMapper);

            return (retMapper, 1us);
        }

        return (TemplateMapper::new (), 1us);
    }

    /**
     * Validate an implicit specialization of a type using a function pointer type expression, and a lambda type
     * @params:
     *     - context: the context of the validation
     *     - templates: the list of template to specialize
     *    - fptr: the function pointer expression of a fptr type to validate
     *    - types: the types that will be used to transform typeExpr, and templates into specialized values
     * @returns:
     *    - .0: the mapper in case of validation (used to create a valid rewriter)
     *    - .1: the number of types that were consumed during the validation
     * @throws:
     *    - &ErrorMsg: if the specialization failed
     * */
    fn validateTypeFromImplicitLambda (self, dmut context : &Validator, templates : [&Expression], fptrType : &FunctionPtrTypeExpr, lmbd : &LambdaType)-> (&TemplateMapper, usize)
        throws &ErrorMsg
    {
        let (params, retType) = (lmbd.getParameters (), lmbd.getRetType ());
        let dmut retMapper = TemplateMapper::new ();
        if (fptrType.getParameters ().len != params.len) {
            return (retMapper, 1us);
        }

        let rewriter = TemplateRewriter::new (retMapper);

        for i in 0us .. fptrType.getParameters ().len {
            match fptrType.getParameters ()[i] {
                v : &VarDeclExpr => {
                    let currentParam = rewriter.rewrite (v.getType ());
                    if (!params [i].isOf!{&NoneType} ()) {
                        let (mapper, _) = self.validateTypeFromImplicit (alias context, templates, currentParam, [params [i]]);
                        retMapper:.merge (mapper);
                    }
                }
                _ => __pragma!panic ();
            }
        }

        if (!retType.isOf!{&NoneType} ()) {
            let currentParam = rewriter.rewrite (fptrType.getReturn ());
            let (mapper, _) = self.validateTypeFromImplicit (alias context, templates, currentParam, [retType]);
            retMapper:.merge (mapper);
        }

        return (retMapper, 1us);
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================            COMMON            =========================
     * ================================================================================
     * ================================================================================
     */


    /**
     * Create a new expression where template specialization or correclty rewritten
     * @params:
     *     - expr: the expression to rewrite
     *     - mapper: the template specialization
     * @returns: the rewritten expr
     */
    fn performTemplateRewrite (self, expr : &Expression, mapper : &TemplateMapper)-> &Expression {
        TemplateRewriter::new (mapper).rewrite (expr)
    }

    /**
     * Search in the list of template parameters a parameter whose name is 'name'
     * @params: 
     *    - name: the name to find
     *    - alls: the list of template params
     * @returns: an expression from 'alls' whose name is 'name' (&EmptyExpression if the expression does not exists)
     */
    fn findExpression (self, name : [c8], alls : [&Expression])-> &Expression {
        for i in alls match i {
            v : &VarExpr => {
                if v.getLoc ().str () == name {
                    return v;
                }
            }
            v : &TemplateOfVarExpr => {
                if v.getLoc ().str () == name {
                    return v;
                }
            }
            v : &TemplateVariadicVarExpr => {
                if v.getLoc ().str () == name {
                    return v;
                }
            }
            v : &TemplateVarExpr => {
                if v.getLoc ().str () == name {
                    return v;
                }
            }
            v : &VarDeclExpr => {
                if v.getLoc ().str () == name {
                    return v;
                }
            }
        }


        EmptyExpression::new ()
    }

    /**
     * Create a type wrapper expression from 'type'
     * */
    fn createTypeWrapper (self, loc : &Word, type : &Type)-> &Expression {
        if (type.isMutable ()) {
            TypeWrapperExpr::new (loc, type.clone (0u32))
        } else {
            TypeWrapperExpr::new (loc, type)
        }
    }

}
