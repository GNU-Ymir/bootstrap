in solver;

use ymirc::semantic::validator::visitor;
use ymirc::semantic::validator::template::{mapper, rewrite};
use ymirc::semantic::validator::errors;
use ymirc::semantic::symbol::template;
use ymirc::syntax::{_,
                    declaration::_,
                    expression::{_, literal::_, macro_::_, operator::_, template::_}};

use ymirc::semantic::{symbol::_, generator::_};
use ymirc::errors::_;
use ymirc::utils::format;
use ymirc::lexing::{word, keys};

use std::{io, stream};
use ymirc::semantic::generator::type::{_,
                                       syntax::_,
                                       custom::_,
                                       native::{_, scalar::_, compound::_},
                                       temporary::_};

use ymirc::semantic::generator::value::{_,
                                        construct::{_, delegate::_},
                                        literal::_,
                                        memory::_,
                                        syntax::_,
                                        operator::{_, binary::_, call::_, fields::_, map::_, slice::_, unary::_},
                                        operator::map::iteration::_,
                                        prototypes::_,
                                        scope::_,
                                        syntax::_,
                                        template::_};

/**
 * The template validator is the template responsible for template symbol validation
 */
pub record TemplateSolver {

    /**
     * Create a new empty validator
     */
    pub self () {}
    
    /*!
     * ================================================================================
     * ================================================================================
     * =========================             CALL             =========================
     * ================================================================================
     * ================================================================================
     */
    
    /**
     * Validate a template call that creates a value (function for example, or aka, etc.)
     * @params: 
     *    - context: the context of the validation
     *    - loc: the location of the call
     *    - left: the value that is template called
     *    - rights: the template arguments passed to the template
     * @returns: 
     *    - .0: the value
     *    - .1: the score of the call
     * @throws:
     *    - &ErrorMsg: if the call is impossible (for example left is not a valid template)    
     */
    pub fn validateCallValue (self, dmut context : &Validator, loc : &Word, left : &Value, rights : [&Generator])-> TemplateRewriter
        throws ErrorMsg
    {
        match left {
            x : &TemplateRefValue => {
                return self.validateCallTemplateRefValue (alias context, loc, x, rights);
            }
            m : &MethodDelegateTemplateValue => {
                return self.validateCallTemplateRefValue (alias context, loc, m.getPrototype (), rights);
            }
            z : &CtorDelegateTemplateValue => {
                return self.validateCallTemplateRefValue (alias context, loc, z.getPrototype (), rights);
            }
            z : _ => {
                if (z.getLoc () != loc) {
                    throw copy ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_TEMPLATE_CALL, left, rights, tags-> FormatTags (withParams-> true)), notes-> copy [copy ErrorMsg::note (z.getLoc (), "")]);
                } else {
                    throw copy ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_TEMPLATE_CALL, left, rights, tags-> FormatTags (withParams-> true)));
                }
            }
        }
    }


    /**
     * Validate a template call that creates a value
     * @params: 
     *    - context: the context of the validation
     *    - loc: the location of the call
     *    - left: the value that is template called
     *    - rights: the template arguments passed to the template
     * @returns: 
     *    - .0: the value
     *    - .1: the score of the call
     * @throws:
     *    - &ErrorMsg: if the call is impossible
     */
    pub fn validateCallTemplateRefValue (self, dmut context : &Validator, _ : &Word, left : &TemplateRefValue, rights : [&Generator])-> TemplateRewriter
        throws ErrorMsg
    {
        let templateParams = left.getSymbol ().getContent ().getParameters ();
        let (mapper, consumed) = self.validateFromExplicit (alias context, templateParams, rights);

        if (consumed < rights.len) {
            throw copy ErrorMsg::fatal (rights[consumed].getLoc (), format (ValidateErrorMessage::TEMPLATE_REST, rights[consumed .. $]),
                                        notes-> copy [copy ErrorMsg::note (left.getSymbol ().getLoc (), format (ValidateErrorMessage::VALIDATING_SYMBOL, left))]);
        }

        TemplateRewriter (mapper) // return the rewriter that can then be used to finalize the syntax rewritting before semantic validation
    }

    /**
     * Validate a sort of template call, that was made inside a template checker
     * @params: 
     *    - context: the context of the validation
     *    - loc: the location of the template check
     *    - params: the template parameters of the check (rules)
     *    - rights: the arguments passed to the checker (already validated)
     * @returns: the template rewriter
     * @throws:
     *    - &ErrorMsg: if the specialization failed
     */
    pub fn validateFromTemplateChecker (self, dmut context : &Validator, loc : &Word, params : [&Expression], rights : [&Generator])-> TemplateRewriter
        throws ErrorMsg
    {
        let (mapper, consumed) = self.validateFromExplicit (alias context, params, rights);

        if (consumed < rights.len) {
            throw copy ErrorMsg::fatal (rights[consumed].getLoc (), format (ValidateErrorMessage::TEMPLATE_REST, rights [consumed .. $]),
                                        notes-> copy [copy ErrorMsg::note (loc, "")]);
        } 

        TemplateRewriter (mapper) // return the rewriter that can then be used to finalize the syntax rewritting before semantic validation
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================           IMPLICIT           =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a template specialization from an implicit call
     * @params:
     *    - context: the context of the validation
     *    - loc: the location of the specialization
     *    - left: the value to specialize
     *    - rights: the list of values used for specialization
     * @returns:
     *    - .0: the template rewriter created by specialization
     *    - .1: the transformed parameters for correct specialization (for example variadic params are put inside tuples)
     * @throws:
     *    - &ErrorMsg: if the specialization failed
     */
    pub fn validateImplicitValue (self, dmut context : &Validator, loc : &Word, left : &TemplateRefValue, rights : [&Value], forMethod : bool = false)-> TemplateRewriter
        throws ErrorMsg
    {
        let dmut sym = context:.getSymbolFromRef (left.getSymbol ());
        context:.pushReferent (alias sym);
        context:.enterForeign (isFnBody-> false);

        let ret = {
            match left.getSymbol ().getContent ().getContent () {
                f : &FunctionDecl => {
                    if (forMethod) {
                        self.validateFromImplicit (alias context, loc, left.getSymbol ().getContent ().getParameters (), f.getFunctionProto ().getParameters ()[1us .. $], rights)
                    } else {
                        self.validateFromImplicit (alias context, loc, left.getSymbol ().getContent ().getParameters (), f.getFunctionProto ().getParameters (), rights)
                    }
                }
                c : &ConstructorDecl => {
                    self.validateFromImplicit (alias context, loc, left.getSymbol ().getContent ().getParameters (), c.getFunctionProtoDecl ().getParameters (), rights)
                }
                x : _ => {
                    println (format ("TODO : %", x));
                    panic;
                }
            }
        } catch {
            err : &ErrorMsg => {
                context:.exitForeign ();
                context:.popReferent ();
                throw err;
            }
        }

        context:.exitForeign ();
        context:.popReferent ();

        ret
    }

    /**
     * Perform an implicit template specialization from a list of syntax parameters 
     * @params: 
     *    - context: the context of the validation
     *    - loc: the location of the template call
     *    - templates: the list of template parameters
     *    - parameters: the list of syntax parameters (basically a list of var decl)
     *    - rights: the list of values used to call the function
     * @returns: 
     *    - .0; the template rewriter of the specialization
     *    - .1: the transformed parameters for correct specialization (for example variadic params are put inside tuples)
     * @throws:
     *    - &ErrorMsg: if the specialization fails
     */
    fn validateFromImplicit (self, dmut context : &Validator, loc : &Word, templates : [&Expression], parameters : [&VarDeclExpr], rights : [&Value])-> TemplateRewriter
        throws ErrorMsg
    {
        let types = self.createTypesFromRights (alias context, rights);
        if (parameters.len > types.len) {
            throw copy ErrorMsg::fatal (loc, format (ValidateErrorMessage::TEMPLATE_SPECIALIZATION_FAILS, parameters, types));
        } // the implicit can be called without enough parameters 

        let mut consumed = 0us;
        let mut globalMapper = TemplateMapper ();
        let mut syntTemplate = templates;

        for it in 0us .. parameters.len {
            // Rewrite the current parameter that will be specialized to remove any template that was already validated
            let currentParam = TemplateRewriter (globalMapper).rewriteVarDecl (parameters[it]);
            let rest = types.len - consumed; // number of types that still can be consumed (Note that there can be more types than parameters in case of variadics)
            let syntaxRest = (parameters.len - it) - 1us; // The number of parameters that where not validated yet, minus the current one
            let consomableTypes = types [consumed .. consumed + (rest - syntaxRest)]; // The list of types that can be associated to the current parameter (can be more than 1 in case of variadics)

            {
                let (mapper, localConsumed) = self.validateParamTemplateFromImplicit (alias context, syntTemplate, currentParam, consomableTypes);
                globalMapper:.merge (mapper);
                consumed += localConsumed;
                syntTemplate = TemplateRewriter (globalMapper).replaceSyntaxTempl (syntTemplate);
            } catch {
                err : &ErrorMsg => {
                    if (globalMapper.getMapping ().len != 0us) {
                        let note = copy ErrorMsg::note (loc, format (ValidateErrorMessage::TEMPLATE_SPE, globalMapper));
                        throw copy ErrorMsg::list (copy [note, err]);
                    } else throw err;
                }
            }                        
        }

        TemplateRewriter (globalMapper)
    }

    /**
     * Create the list of types from the right values
     * @params:
     *    - rights: the values used to implicitely specialize the template value
     * */
    fn createTypesFromRights (self, dmut context : &Validator, rights : [&Value])-> [&Type]
        throws ErrorMsg
    {
        let mut types : [mut &Type] = [];
        for it in rights match context.implicitEnumUnwrap (it) {
            s : &StringValue => {
                if let t : &SliceType = s.getType () {
                    types ~= [copy SliceType (t.getLoc (), t.getInners ()[0], withSize-> makeIntValue (t.getLoc (), s.getLen ()))];
                } else {
                    if (it.getType ().isMutable ()) {
                        types ~= [it.getType ().clone (0u32)];
                    } else {
                        types ~= [it.getType ()];
                    }
                }
            }
            _ => {
                if (it.getType ().isMutable ()) {
                    types ~= [it.getType ().clone (0u32)];
                } else {
                    types ~= [it.getType ()];
                }
            }
        }

        types
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================           EXPLICIT           =========================
     * ================================================================================
     * ================================================================================
     */
    
    /**
     * Validate a template explicit specialization
     * @params: 
     *    - context: the context of the validation
     *    - params: the template parameters
     *    - values: the list of compile time knwon values passed to the template     
     * @returns: 
     *     - .0: a template mapper containing the template specialization
     *     - .1: the number of values that were consumed during the specialization
     * @throws: 
     *    - &ErrorMsg: if the specialization is impossible
     */
    pub fn validateFromExplicit (self, dmut context : &Validator, params : [&Expression], values : [&Generator])-> (TemplateMapper, usize)
        throws ErrorMsg
    {
        let mut consumed = 0us;
        let mut globalMapper = TemplateMapper ();
        let mut syntTemplate = params;
        
        while (consumed < values.len && syntTemplate.len != 0us) {
            // Create a slice on template arguments that have not been used yet
            // Template arguments are used in the order they are written, but sometimes several at a time
            let currentElems = values [consumed .. $];

            // Create a slice on the template parameters that are not directly referenced
            // Only the first template parameter is explicitly set, but maybe it will also set other parameters
            let rest = syntTemplate [1 .. $];

            {
                // Perform the explicit template validation, with the given template parameters, and call arguments
                let (mapper, localConsumed) = self.validateParamTemplateFromExplicit (alias context, rest, syntTemplate [0], currentElems);

                globalMapper:.merge (mapper);
                consumed += localConsumed;
                syntTemplate = TemplateRewriter (globalMapper).replaceSyntaxTempl (syntTemplate);
            } catch {
                err : &ErrorMsg => { // TODO partial resolution note
                    throw err; 
                }
            }
        }
        
        (globalMapper, consumed)
    }

    /**
     * Validate a template parameter from an explicit call
     * @params:
     *    - context: the context of the validation
     *    - syntTemplate: the template parameters
     *    - current: the template parameter to validate
     *    - values: the values passed to the template call
     * @returns:
     *    - .0: the mapper containing the template specialisation
     *    - .1: the number of values that were consumed
     * @throws:
     *    - &ErrorMsg: if the specialization is impossible
     */
    fn validateParamTemplateFromExplicit (self, dmut context : &Validator, syntaxTemplate : [&Expression], current : &Expression, values : [&Generator])-> (TemplateMapper, usize)
        throws ErrorMsg
    {
        match current {
            v : &VarExpr => {
                return self.validateVarExprFromExplicit (alias context, v, values);
            }
            ov : &TemplateOfVarExpr => {
                match ov.getKind () {
                    TemplateOfVarType::OF => {
                        return self.validateOfVarExprFromExplicit (alias context, syntaxTemplate, ov, values);
                    }
                    TemplateOfVarType::IMPL => {
                        return self.validateImplVarExprFromExplicit (alias context, syntaxTemplate, ov, values);
                    }
                    _ => {
                        return self.validateOverVarExprFromExplicit (alias context, syntaxTemplate, ov, values);
                    }
                }
            }
            t : &TemplateAndExpr => {
                return self.validateTemplateAndFromExplicit (alias context, syntaxTemplate, t, values);
            }
            t : &TemplateVarExpr => {
                return self.validateTemplateVarExprFromExplicit (alias context, syntaxTemplate, t, values);
            }
            v : &TemplateVariadicVarExpr => {
                return self.validateTemplateVariadicFromExplicit (alias context, syntaxTemplate, v, values);
            }
            v : &VarDeclExpr => {
                return self.validateVarDeclExprFromExplicit (alias context, syntaxTemplate, v, values);
            }
            expr : _ => {
                return self.validateValueExpressionFromExplicit (alias context, expr, values);
            }
        }
    }    

    /**
     * Validate a template parameter from an explicit inner call where the template parameter is a value
     * @params:
     *    - context: the context of the validation
     *    - syntTemplate: the template parameters
     *    - current: the template parameter to validate
     *    - values: the values passed to the template call
     * @returns:
     *    - .0: the mapper containing the template specialisation
     *    - .1: the number of values that were consumed
     * @throws:
     *    - &ErrorMsg: if the specialization is impossible
     */
    fn validateTemplateCallParamValueFromExplicit (self, dmut context : &Validator, syntaxTemplate : [&Expression], current : &Expression, values : [&Generator])-> (TemplateMapper, usize)
        throws ErrorMsg
    {
        match current {
            v : &VarExpr => {
                let expr = self.findExpression (v.getLoc ().str, syntaxTemplate);
                if expr !of EmptyExpression {
                    return self.validateParamTemplateFromExplicit (alias context, syntaxTemplate, expr, values);
                }
            }
        }

        return self.validateValueExpressionFromExplicit (alias context, current, values);
    }

    /**
     * Validate an explicit template specialization where template parameter is a simple varexpr
     * @params: 
     *    - context: the context of the validation
     *    - v: the var expression
     *    - values: the list of values passed to the template call
     * @returns:
     *    - .0: the template parameter specialization
     *    - .1: the number of consumed parameters (should be 1us)
     * @throws:
     *    - &ErrorMsg: if the values cannot be used to specialize the template parameter
     */
    fn validateVarExprFromExplicit (self, dmut context : &Validator, v : &VarExpr, values : [&Generator])-> (TemplateMapper, usize)
        throws ErrorMsg
    {
        match values [0] {
            t : &Type => {
                context.verifyNotIsNativeType (v.getLoc (), v.getLoc ().str);
                let mut mapper = TemplateMapper (score-> TemplateScore::VAR);
                mapper:.insert (v.getLoc ().str, self.createTypeWrapper (t.getLoc (), t));
                
                return (mapper, 1us);
            }
            _ => {                  
                throw copy ErrorMsg::fatal (values[0].getLoc (), format (ValidateErrorMessage::USE_AS_TYPE_TEMPLATE, values[0]),
                                            notes-> copy [copy ErrorMsg::note (v.getLoc (), "")]);
            }
        }
    }


    /*!
     * ================================================================================
     * ================================================================================
     * =========================       EXPLICIT OF VAR        =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate an explicit template specialization where template parameter is an of var
     * @params:
     *    - context: the context of the validation
     *    - v: the template of var to validate
     *    - values: the list of values passed to the template call
     * @returns:
     *    - .0: the template parameter specialization
     *    - .1: the number of consumed parameters (should be 1us)
     * @throws:
     *    - &ErrorMsg: if the values cannot be used to specialize the template parameter
     */
    fn validateOfVarExprFromExplicit (self, dmut context : &Validator, alls : [&Expression], ofV : &TemplateOfVarExpr, types : [&Generator])-> (TemplateMapper, usize)
        throws ErrorMsg
    {
        let mut asTypes : [mut &Type] = [];
        for i in types if let t : &Type = i {
            asTypes ~= [t];
        }

        if (asTypes.len >= 1us) {
            let varName = ofV.getLoc ().str;
            return match ofV.getSpecialization () {
                deco : &DecoratedExpr => {
                    self.validateOfDecoratedExplicit (alias context, varName, alls, deco, asTypes)
                }
                _ => {
                    let (mapper, consumed) = self.validateOfVarExprFromExplicit (alias context, ofV.getLoc (), alls, ofV.getSpecialization (), asTypes);
                    let mut retMapper = TemplateMapper (score-> TemplateScore::VAR);
                    retMapper:.merge (mapper);

                    let finalType = context:.validateType (self.performTemplateRewrite (ofV.getSpecialization (), mapper));
                    retMapper:.insert (varName, self.createTypeWrapper (ofV.getLoc (), finalType));

                    (retMapper, consumed)
                }
            };
        } else if (types.len != 0us) {
            throw copy ErrorMsg::fatal (types[0].getLoc (), format (ValidateErrorMessage::USE_AS_TYPE_TEMPLATE, types [0]),
                                        notes-> copy [copy ErrorMsg::note (ofV.getLoc (), "")]);
        } else {
            throw copy ErrorMsg::fatal (ofV.getLoc (), format (ValidateErrorMessage::TEMPLATE_SPECIALIZATION_FAILS, alls, types));
        }
    }

    /**
     * Validate an explicit inner part of an of var, where the inner part is a decorated expression (A of dmut T, T)
     * @params:
     *     - context: the context of the validation
     *     - alls: the list of template parameters that are not validated yet
     *     - deco: the decorated of expression (=> ofv.getSpecialization ())
     *     - type: the type passed to the template call
     * @returns: the template mapper specialization
     * @throws:
     *    - &ErrorMsg: if the specialization failed
     */
    fn validateOfDecoratedExplicit (self, dmut context : &Validator, varName : [c8], alls : [&Expression], deco : &DecoratedExpr, types : [&Type])-> (TemplateMapper, usize)
        throws ErrorMsg
    {
        let type = types [0];
        let hasMut = deco.isMutable (), hasDmut = deco.isDeeplyMutable ();

        // Validate the type inside the template specialization
        // final template type won't have the mutability lvl, this is just a checking to see wether the decorator was used in the template call
        // For example MyTemplate!{dmut [i32]}, MyTemplate!{mut [i32]}, ...
        let (mapper, _) = self.validateOfVarExprFromExplicit (alias context, alls, deco.getContent (), copy [type]);
        if (hasDmut) {
            if (!type.isDeeplyMutable ()) { // if it was deeply mutable, it should have the same lvl as the same type but deeply mutable
                throw copy ErrorMsg::fatal (deco.getDecorator (), ValidateErrorMessage::DISCARD_CONST);
            }
        } else if (hasMut) {
            if (!type.isMutable ()) { // If the mut decorator is used the type has to be mutable
                throw copy ErrorMsg::fatal (deco.getDecorator (), ValidateErrorMessage::DISCARD_CONST);
            }
        }

        let mut resultMapper = TemplateMapper (score-> TemplateScore::VAR * 2us);
        resultMapper:.merge (mapper);
        resultMapper:.insert (varName, self.createTypeWrapper (deco.getLoc (), type), mutable-> hasMut, deeplyMut-> hasDmut);

        return (resultMapper, 1us); // return the mapper containing the sub specialization
    }
    
    /**
     * Validate an explicit template specialization within another one (A of U, or A : U)
     * @params:
     *    - context: the context of the validation
     *    - v: the template of var to validate
     *    - values: the list of values passed to the template call
     * @returns:
     *    - .0: the template parameter specialization
     *    - .1: the number of consumed parameters (should be 1us)
     * @throws:
     *    - &ErrorMsg: if the values cannot be used to specialize the template parameter
     * */
    pub fn validateOfVarExprFromExplicit (self, dmut context : &Validator, alls : [&Expression], v : &Expression, types : [&Type])-> (TemplateMapper, usize)
        throws ErrorMsg
    {
        if (types.len >= 1us) {
            return self.validateOfVarExprFromExplicit (alias context, v.getLoc (), alls, v, types);
        } else {
            throw copy ErrorMsg::fatal (v.getLoc (), format (ValidateErrorMessage::TEMPLATE_SPECIALIZATION_FAILS, alls, types));
        }
    }
    
    /**
     * Validate an explicit template specialization where template parameter is an of var
     * @params: 
     *    - context: the context of the validation
     *    - expr: the content of the of var to validate
     *    - values: the list of values passed to the template call
     * @returns: the template parameter specialization
     * @throws:
     *    - &ErrorMsg: if the values cannot be used to specialize the template parameter
     */
    fn validateOfVarExprFromExplicit (self, dmut context : &Validator, loc : &Word, alls : [&Expression], expr : &Expression, types : [&Type])-> (TemplateMapper, usize)
        throws ErrorMsg
    {
        if (types.len == 0us) throw copy ErrorMsg::fatal (expr.getLoc (), format (ValidateErrorMessage::TEMPLATE_SPECIALIZATION_FAILS, alls, types));

        match expr {
            slc : &SliceAllocatorExpr => {
                return self.validateOfSliceAllocInnerExplicit (alias context, alls, slc, types);
            }
            c : &TemplateCallExpr => {
                return self.validateOfTemplateCallInnerExplicit (alias context, alls, c, types);
            }
            var : &VarExpr => {
                return self.validateOfVarInnerExplicit (alias context, alls, var, types);
            }
            p : &PathExpr => {
                return self.validateOfPathInnerExplicit (alias context, alls, p, types);
            }
            b : &BinaryExpr => {
                return self.validateOfBinaryInnerExplicit (alias context, alls, b, types);
            }
            un : &UnaryExpr => {
                return self.validateOfUnaryInnerExplicit (alias context, alls, un, types);
            }
            tr : &TryExpr => {
                return self.validateOfTryInnerExplicit (alias context, alls, tr, types);
            }
            f : &FutureTypeExpr => {
                return self.validateOfFutureInnerExplicit (alias context, alls, f, types);
            }
            r : &RangeTypeExpr => {
                return self.validateOfRangeInnerExplicit (alias context, alls, r, types);
            }
            lst : &ListExpr => {
                if (lst.isArray ()) {
                    return self.validateOfSliceInnerExplicit (alias context, alls, lst, types);
                } else {
                    return self.validateOfTupleInnerExplicit (alias context, alls, lst, types);
                }
            }
            m : &ListMapExpr => {
                return self.validateOfMapInnerExplicit (alias context, alls, m, types);
            }
            f : &FunctionPtrTypeExpr => {
                return self.validateOfFuncPtrInnerExplicit (alias context, alls, f, types);
            }
            spe : _ => {
                let speType = context:.validateType (spe);
                context.verifyCompatibleType (loc, types [0].getLoc (), speType, types [0]);

                let mut retMapper = TemplateMapper (score-> TemplateScore::VAR);
                if (context.isDirectInstance (speType, types [0])) {
                    retMapper:.addScore (TemplateScore::VAR);
                }

                (retMapper, 1us)
            }                    
        }    
    }

    /**
     * Validate an explicit inner part of an of var, where the inner part is a slice allocator (A of [T ; N])
     * @params:
     *    - context: the context of the validation
     *    - alls: the list of template parameters that are not validated yet
     *    - slc: the slice allocator (=> ofV.getSpecialization ())
     *    - type: the type passed to the template call
     * @returns: the template parameter specialization
     * @throws:
     *    - &ErrorMsg: if the specialization failed
     */
    fn validateOfSliceAllocInnerExplicit (self, dmut context : &Validator, alls : [&Expression], slc : &SliceAllocatorExpr, types : [&Type])-> (TemplateMapper, usize)
        throws ErrorMsg
    {
        let type = context.implicitEnumUnwrap (types [0]);

        // This verification is close to slices, but with the verification of the size of the alloc that must be known at compile time
        match type {
            arr : &ArrayType => {
                let mut retMapper = TemplateMapper (score-> TemplateScore::VAR * 2u32);
                let (typeMapper, _) = self.validateOfVarExprFromExplicit (alias context, alls, slc.getValue (), arr.getInners ());
                retMapper:.merge (typeMapper);

                match slc.getSize () {
                    v : &VarExpr => {
                        let expr = self.findExpression (v.getLoc ().str, alls);
                        if expr !of EmptyExpression {
                            let (valMapper, _) = self.validateParamTemplateFromExplicit (alias context, alls, expr, copy [makeIntValue (arr.getLoc (), arr.getLen ())]);
                            retMapper:.merge (valMapper);
                        }
                    }
                }

                let finalType = self.performTemplateRewrite (slc, retMapper);
                let ofType = context:.validateType (finalType);
                context.verifyCompatibleType (slc.getLoc (), type.getLoc (), ofType, type);

                return (retMapper, 1us);
            }
            arr : &SliceType => {
                if (arr.getSize () !of UnitValue) {
                    let mut retMapper = TemplateMapper (score-> TemplateScore::VAR * 2u32);
                    let (typeMapper, _) = self.validateOfVarExprFromExplicit (alias context, alls, slc.getValue (), arr.getInners ());
                    retMapper:.merge (typeMapper);

                    match slc.getSize () {
                        v : &VarExpr => {
                            let expr = self.findExpression (v.getLoc ().str, alls);
                            if expr !of EmptyExpression {
                                let (valMapper, _) = self.validateParamTemplateFromExplicit (alias context, alls, expr, copy [arr.getSize ()]);
                                retMapper:.merge (valMapper);
                            }
                        }
                    }

                    let finalType = self.performTemplateRewrite (slc, retMapper);
                    let ofType = context:.validateType (finalType);
                    context.verifyCompatibleType (slc.getLoc (), type.getLoc (), ofType, type);

                    return (retMapper, 1us);
                }
            }
        }


        throw copy ErrorMsg::fatal (type.getLoc (), format (ValidateErrorMessage::NOT_AN_ARRAY, type),
                                    notes-> copy [copy ErrorMsg::note (slc.getLoc (), "")]);
    }


    /**
     * Validate an explicit inner part of an of var, where the inner part is a template call (A of T!{U})
     * @params:
     *    - context: the context of the validation
     *    - alls: the list of template parameters that are not validated yet
     *    - tmp: the template call to specialize
     *    - values: the list of values passed to the template call
     * @returns:
     *    - .0: the template parameter specialization
     *    - .1: the number of consumed parameters (should be 1us)
     * @throws:
     *    - &ErrorMsg: if the values cannot be used to specialize the template parameter
     * */
    fn validateOfTemplateCallInnerExplicit (self, dmut context : &Validator, alls : [&Expression], tmp : &TemplateCallExpr, types : [&Type])-> (TemplateMapper, usize)
        throws ErrorMsg
    {
        let type = context.implicitEnumUnwrap (types [0]);
        let (has, clTemplates) = self.createTemplateListOfType (type);
        if (!has || tmp.getRights ().len > clTemplates.len) throw copy ErrorMsg::fatal (type.getLoc (), format (ValidateErrorMessage::TEMPLATE_SPECIALIZATION_FAILS, tmp, type),
                                                                                        notes-> copy [copy ErrorMsg::fatal (tmp.getLoc (), format (ValidateErrorMessage::INCOMPATIBLE_TYPE, tmp, type))]);

        let mut retMapper = TemplateMapper (score-> TemplateScore::VAR);
        let mut consumed = 0us;
        let mut syntaxTemplate = alls;

        for i in 0us .. tmp.getRights ().len {
            let currentParam = TemplateRewriter (retMapper).rewrite (tmp.getRights ()[i]);
            let rest = clTemplates.len - consumed;
            let syntaxRest = (tmp.getRights ().len - i) - 1us;

            let consomableTypes = clTemplates [consumed .. consumed + (rest - syntaxRest)];
            let (mapper, localConsumed) = if (consomableTypes.len > 0 && consomableTypes [0] of Value) {
                let (mp, _) = self.validateTemplateCallParamValueFromExplicit (alias context, syntaxTemplate, currentParam, consomableTypes [0 .. 1]);
                (mp, 1us)
            } else {
                let mut lst : [mut &Type] = [];
                for ti in consomableTypes {
                    if let t : &Type = ti {
                        lst ~= [t];
                    } else break;
                }

                self.validateOfVarExprFromExplicit (alias context, syntaxTemplate, currentParam, lst)
            }

            retMapper:.merge (mapper);
            consumed += cast!usize (localConsumed);
            syntaxTemplate = TemplateRewriter (retMapper).replaceSyntaxTempl (syntaxTemplate);
        }

        if let v : &VarExpr = tmp.getLeft () {
            let expr = self.findExpression (v.getLoc ().str, alls);
            if expr !of EmptyExpression {
                let (valMapper, _) = self.validateParamTemplateFromExplicit (alias context, alls, expr, copy [type]);
                retMapper:.merge (valMapper);
                return (retMapper, 1us);
            }
        }

        {
            let finalType = TemplateRewriter (retMapper).rewrite (tmp);
            let ofType = context:.validateType (finalType);
            context.verifyCompatibleType (tmp.getLoc (), type.getLoc (), ofType, type);
        } catch {
            err : &ErrorMsg => {
                throw copy ErrorMsg::note (tmp.getLoc (), format (ValidateErrorMessage::TEMPLATE_SPE, retMapper), notes-> copy [err]);
            }
        }

        return (retMapper, 1us);
    }

    /**
     * Validate an explicit inner part of an of var, where the inner part is simply a VarExpr (A of T)
     * @params: 
     *    - context: the context of the validation
     *    - alls: the list of template parameters that are not validated yet
     *    - v: the inner part of the ofvar (=> ofV.getSpecialization ())
     *    - values: the list of values passed to the template call
     * @returns:
     *    - .0: the template parameter specialization
     *    - .1: the number of consumed parameters (should be 1us)
     * @throws:
     *    - &ErrorMsg: if the values cannot be used to specialize the template parameter
     */
    fn validateOfVarInnerExplicit (self, dmut context : &Validator, alls : [&Expression], v : &VarExpr, types : [&Type])-> (TemplateMapper, usize)
        throws ErrorMsg
    {

        // Search the inner value (A of T => search T in the parameters)
        let expr = self.findExpression (v.getLoc ().str, alls);
        if expr !of EmptyExpression {
            let mut retMapper = TemplateMapper (score-> TemplateScore::VAR);
            let (mapper, localConsumed) = self.validateParamTemplateFromExplicit (alias context, alls, expr, types);
            retMapper:.merge (mapper);

            return (mapper, localConsumed);
        } else {
            let mut retMapper = TemplateMapper (score-> TemplateScore::VAR);
            let ofType = context:.validateType (v);
            context.verifyCompatibleType (v.getLoc (), types [0].getLoc (), ofType, types [0]);
            if (context.isDirectInstance (ofType, types [0])) {
                retMapper:.addScore (TemplateScore::VAR);
            }

            return (alias retMapper, 1us);
        }
    }

    /**
     * Validate an explicit inner part of an of var, where the inner part is a path expression (A of T::U)
     * @params:
     *    - context: the context of the validation
     *    - alls: the list of template parameters that are not validated yet
     *    - p: the inner part of the ofvar (=> ofV.getSpecialization ())
     *    - values: the list of values passed to the template call
     * @returns:
     *    - .0: the template parameter specialization
     *    - .1: the number of consumed parameters (should be 1us)
     * @throws:
     *    - &ErrorMsg: if the values cannot be used to specialize the template parameter
     * */
    fn validateOfPathInnerExplicit (self, dmut context : &Validator, alls : [&Expression], p : &PathExpr, types : [&Type])-> (TemplateMapper, usize)
        throws ErrorMsg
    {
        let type = types [0];
        let mut retMapper = TemplateMapper (score-> TemplateScore::VAR);

        if let v : &VarExpr = p.getRight () {
            let expr = self.findExpression (v.getLoc ().str, alls);
            if expr !of EmptyExpression {
                let (mapper, _) = self.validateParamTemplateFromExplicit (alias context, alls, expr, types [0 .. 1]);
                retMapper:.merge (mapper);

                let finalType = self.performTemplateRewrite (p, retMapper);
                let ofType = context:.validateType (finalType);
                context.verifyCompatibleType (p.getLoc (), type.getLoc (), ofType, type);
                if context.isDirectInstance (ofType, type) {
                    retMapper:.addScore (TemplateScore::VAR);
                }

                return (alias retMapper, 1us);
            }
        }

        let ofType = context:.validateType (p);
        context.verifyCompatibleType (p.getLoc (), type.getLoc (), ofType, type);
        if context.isDirectInstance (ofType, type) {
            retMapper:.addScore (TemplateScore::VAR);
        }

        return (retMapper, 1us);
    }

    /**
     * Validate an explicit inner part of an of var, where the inner part is a binary expression (A of T::U)
     * @params:
     *    - context: the context of the validation
     *    - alls: the list of template parameters that are not validated yet
     *    - bin: the inner part of the ofvar (=> ofV.getSpecialization ())
     *    - values: the list of values passed to the template call
     * @returns:
     *    - .0: the template parameter specialization
     *    - .1: the number of consumed parameters (should be 1us)
     * @throws:
     *    - &ErrorMsg: if the values cannot be used to specialize the template parameter
     * */
    fn validateOfBinaryInnerExplicit (self, dmut context : &Validator, alls : [&Expression], bin : &BinaryExpr, types : [&Type])-> (TemplateMapper, usize)
        throws ErrorMsg
    {
        let type = types [0];
        let mut retMapper = TemplateMapper (score-> TemplateScore::VAR);

        if let v : &VarExpr = bin.getRight () && bin.getLoc () == BinaryOperators::DCOLON {
            let expr = self.findExpression (v.getLoc ().str, alls);
            if expr !of EmptyExpression {
                let (mapper, _) = self.validateParamTemplateFromExplicit (alias context, alls, expr, types [0 .. 1]);
                retMapper:.merge (mapper);

                let finalType = self.performTemplateRewrite (bin, retMapper);
                let ofType = context:.validateType (finalType);
                context.verifyCompatibleType (bin.getLoc (), type.getLoc (), ofType, type);
                if context.isDirectInstance (ofType, type) {
                    retMapper:.addScore (TemplateScore::VAR);
                }

                return (alias retMapper, 1us);
            }
        }

        let ofType = context:.validateType (bin);
        context.verifyCompatibleType (bin.getLoc (), type.getLoc (), ofType, type);
        if context.isDirectInstance (ofType, type) {
            retMapper:.addScore (TemplateScore::VAR);

        }
        return (retMapper, 1us);
    }

    /**
     * Validate an explicit inner part of an of var, where the inner part is a UnaryExpr (A of &T)
     * @params: 
     *    - context: the context of the validation
     *    - alls: the list of template parameters that are not validated yet
     *    - un: the unary expression (=> ofV.getSpecialization ())
     *    - values: the list of values passed to the template call
     * @returns: the template parameter specialization
     * @throws:
     *    - &ErrorMsg: if the specialization failed
     */
    fn validateOfUnaryInnerExplicit (self, dmut context : &Validator, alls : [&Expression], un : &UnaryExpr, types : [&Type])-> (TemplateMapper, usize)
        throws ErrorMsg
    {
        let type = context.implicitEnumUnwrap (types [0]);

        // Unary are generaly &X, that can be either a pointer or a classptr type
        let (mapper, _) = match type {
            cl : &ClassPtrType => {
                if (cl.isStruct ()) throw copy ErrorMsg::fatal (un.getLoc (), format (ValidateErrorMessage::TEMPLATE_SPECIALIZATION_FAILS, un, type));
                self.validateOfVarExprFromExplicit (alias context, alls, un.getOperand (), copy [cl.getInner ()])
            }
            ct : &CompoundType => {
                if (ct.getInners ().len == 1us) {
                    self.validateOfVarExprFromExplicit (alias context, alls, un.getOperand (), ct.getInners() [0 .. 1])
                } else {
                    throw copy ErrorMsg::fatal (un.getLoc (), format (ValidateErrorMessage::TEMPLATE_SPECIALIZATION_FAILS, un, type));
                }
            }
            _ => {
                throw copy ErrorMsg::fatal (un.getLoc (), format (ValidateErrorMessage::TEMPLATE_SPECIALIZATION_FAILS, un, type));
            }
        };
        
        // Complete the type, and verify that it is correctly set, maybe for function ptr this will not work (thus TODO)
        let finalType = self.performTemplateRewrite (un, mapper);
        let ofType = context:.validateType (finalType);
        context.verifyCompatibleType (un.getLoc (), type.getLoc (), ofType, type);

        let mut retMapper = TemplateMapper (score-> TemplateScore::VAR);
        retMapper:.merge (mapper);
        if context.isDirectInstance (ofType, type) {
            retMapper:.addScore (TemplateScore::VAR);
        }

        return (retMapper, 1us);
    }

    /**
     * Validate an explicit inner part of an of var, where the inner part is a RangeTypeExpr (A of ..T)
     * @params:
     *    - context: the context of the validation
     *    - alls: the list of template parameters that are not validated yet
     *    - r: the range type expression to validate
     *    - values: the list of values passed to the template call
     * @returns: the template parameter specialization
     * @throws:
     *    - &ErrorMsg: if the specialization failed
     */
    fn validateOfRangeInnerExplicit (self, dmut context : &Validator, alls : [&Expression], r : &RangeTypeExpr, types : [&Type])-> (TemplateMapper, usize)
        throws ErrorMsg
    {
        let type = context.implicitEnumUnwrap (types [0]);
        let (mapper, _) = match type {
            c : &RangeType => {
                self.validateOfVarExprFromExplicit (alias context, alls, r.getType (), c.getInners ()[0 .. 1])
            }
            _ => {
                throw copy ErrorMsg::fatal (r.getLoc (), format (ValidateErrorMessage::TEMPLATE_SPECIALIZATION_FAILS, r, type));
            }
        };

        let mut retMapper = TemplateMapper (score-> TemplateScore::VAR);
        // Complete the type, and verify that it is correctly set
        let finalType = self.performTemplateRewrite (r, mapper);
        let ofType = context:.validateType (finalType);
        context.verifyCompatibleType (r.getLoc (), type.getLoc (), ofType, type);
        retMapper:.merge (mapper);

        return (retMapper, 1us);
    }

    /**
     * Validate an explicit inner part of an of var, where the inner part is a TryTypeExpr (A of T?)
     * @params:
     *    - context: the context of the validation
     *    - alls: the list of template parameters that are not validated yet
     *    - r: the try type expression to validate
     *    - values: the list of values passed to the template call
     * @returns: the template parameter specialization
     * @throws:
     *    - &ErrorMsg: if the specialization failed
     */
    fn validateOfTryInnerExplicit (self, dmut context : &Validator, alls : [&Expression], r : &TryExpr, types : [&Type])-> (TemplateMapper, usize)
        throws ErrorMsg
    {
        let type = context.implicitEnumUnwrap (types [0]);
        let (mapper, _) = match type {
            c : &OptionType => {
                self.validateOfVarExprFromExplicit (alias context, alls, r.getValue (), c.getInners ()[0 .. 1])
            }
            _ => {
                throw copy ErrorMsg::fatal (r.getLoc (), format (ValidateErrorMessage::TEMPLATE_SPECIALIZATION_FAILS, r, type));
            }
        };

        let mut retMapper = TemplateMapper (score-> TemplateScore::VAR);
        // Complete the type, and verify that it is correctly set
        let finalType = self.performTemplateRewrite (r, mapper);
        let ofType = context:.validateType (finalType);
        context.verifyCompatibleType (r.getLoc (), type.getLoc (), ofType, type);
        retMapper:.merge (mapper);

        return (retMapper, 1us);
    }

    /**
     * Validate an explicit inner part of an of var, where the inner part is a FutureTypeExpr (A of future-> T)
     * @params:
     *    - context: the context of the validation
     *    - alls: the list of template parameters that are not validated yet
     *    - r: the future type expression to validate
     *    - values: the list of values passed to the template call
     * @returns: the template parameter specialization
     * @throws:
     *    - &ErrorMsg: if the specialization failed
     */
    fn validateOfFutureInnerExplicit (self, dmut context : &Validator, alls : [&Expression], r : &FutureTypeExpr, types : [&Type])-> (TemplateMapper, usize)
        throws ErrorMsg
    {
        let type = context.implicitEnumUnwrap (types [0]);
        let (mapper, _) = match type {
            c : &FutureType => {
                self.validateOfVarExprFromExplicit (alias context, alls, r.getReturnType (), c.getInners ()[0 .. 1])
            }
            _ => {
                throw copy ErrorMsg::fatal (r.getLoc (), format (ValidateErrorMessage::TEMPLATE_SPECIALIZATION_FAILS, r, type));
            }
        }

        // Complete the type, and verify that it is correctly set
        let finalType = self.performTemplateRewrite (r, mapper);
        let ofType = context:.validateType (finalType);
        context.verifyCompatibleType (r.getLoc (), type.getLoc (), ofType, type);

        let mut retMapper = TemplateMapper (score-> TemplateScore::VAR);
        retMapper:.merge (mapper);

        return (retMapper, 1us);
    }


    /**
     * Validate an explicit inner part of an of var, where the inner part is a slice ListExpr (A of [T])
     * @params:
     *    - context: the context of the validation
     *    - alls: the list of template parameters that are not validated yet
     *    - ofV: the of var expression
     *    - lst: the lsit expression (=> ofV.getSpecialization ())
     *    - type: the type passed to the template call
     * @returns:
     *    - .0: the template parameter specialization
     *    - .1: the number of consumed parameters (should be 1us)
     * @throws:
     *    - &ErrorMsg: if the specialization failed
     */
    fn validateOfSliceInnerExplicit (self, dmut context : &Validator, alls : [&Expression], lst : &ListExpr, types : [&Type])-> (TemplateMapper, usize)
        throws ErrorMsg
    {
        let type = context.implicitEnumUnwrap (types [0]);
        if (lst.getParameters ().len != 1us)  throw copy ErrorMsg::fatal (lst.getLoc (), format (ValidateErrorMessage::USE_AS_TYPE_TEMPLATE, lst)); // the template is malformed

        match type {
            slc : &SliceType => { // This verification is pretty straightfoward, we just need to verify that we have a slice, and validate what is inside the template slice
                let (mapper, _) = self.validateOfVarExprFromExplicit (alias context, alls, lst.getParameters ()[0us], slc.getInners ()); // so, we validate the inner part

                let finalType = self.performTemplateRewrite (lst, mapper);
                let ofType = context:.validateType (finalType);
                context.verifyCompatibleType (lst.getLoc (), type.getLoc (), ofType, type); // and verify that the two elements are equivalent

                let mut retMapper = TemplateMapper (score-> TemplateScore::VAR);
                retMapper:.merge (mapper);

                return (retMapper, 1us);
            }
            _ => {
                throw copy ErrorMsg::fatal (type.getLoc (), format (ValidateErrorMessage::NOT_A_SLICE, type),
                                            notes-> copy [copy ErrorMsg::note (lst.getLoc (), "")]);

            }
        }
    }

    /**
     * Validate an explicit inner part of an of var, where the inner part is a map ListMapExpr (A of [K => V])
     * @params:
     *    - context: the context of the validation
     *    - alls: the list of template parameters that are not validated yet
     *    - ofV: the of var expression
     *    - lst: the lsit expression (=> ofV.getSpecialization ())
     *    - type: the type passed to the template call
     * @returns:
     *    - .0: the template parameter specialization
     *    - .1: the number of consumed parameters (should be 1us)
     * @throws:
     *    - &ErrorMsg: if the specialization failed
     * */
    fn validateOfMapInnerExplicit (self, dmut context : &Validator, alls : [&Expression], lst : &ListMapExpr, types : [&Type])-> (TemplateMapper, usize)
        throws ErrorMsg
    {
        let type = context.implicitEnumUnwrap (types [0]);
        if (lst.getKeys ().len != 1us)  throw copy ErrorMsg::fatal (lst.getLoc (), format (ValidateErrorMessage::USE_AS_TYPE_TEMPLATE, lst));

        match type {
            m : &MapType => { // This verification is pretty straightfoward, we just need to verify that we have a map, and validate what is in the template map
                let dmut retMapper = TemplateMapper (score-> TemplateScore::VAR * 2u32);
                let (mapper, _) = self.validateOfVarExprFromExplicit (alias context, alls, lst.getKeys ()[0us], m.getInners ()[0 .. 1]);
                retMapper:.merge (mapper);

                let syntTemplate = TemplateRewriter (retMapper).replaceSyntaxTempl (alls);
                let valueParam = TemplateRewriter (retMapper).rewrite (lst.getValues ()[0us]);
                let (secondM, _) = self.validateOfVarExprFromExplicit (alias context, syntTemplate, valueParam, m.getInners ()[1 .. 2]);

                retMapper:.merge (secondM);

                return (retMapper, 1us);
            }
            _ => {
                throw copy ErrorMsg::fatal (type.getLoc (), format (ValidateErrorMessage::NOT_A_MAP, type),
                                            notes-> copy [copy ErrorMsg::note (lst.getLoc (), "")]);
            }
        }
    }
    
    /**
     * Validate an explicit inner part of an of var, where the inner part is a tuple ListExpr (A of (T, U, V))
     * @params:
     *    - context: the context of the validation
     *    - alls: the list of template parameters that are not validated yet
     *    - lst: the list expression (=> ofV.getSpecialization ())
     *    - type: the type passed to the template call
     * @returns: the template parameter specialization
     * @throws:
     *    - &ErrorMsg: if the specialization failed
     */
    fn validateOfTupleInnerExplicit (self, dmut context : &Validator, alls : [&Expression], lst : &ListExpr, types : [&Type])-> (TemplateMapper, usize)
        throws ErrorMsg
    {
        let type = context.implicitEnumUnwrap (types [0]);

        match type {
            t : &TupleType => {
                // Because the inner elements of the template tuple could be variadic templates, we must manage it
                let dmut retMapper = TemplateMapper (score-> TemplateScore::VAR * 2u32);
                let mut consumed = 0us;

                // For the specialization to work, we need to have more or same number of types in the tuple than in the template => (T of (U, J...), J),  call!{(i32, i32, i32)}
                if (lst.getParameters ().len > t.getInners ().len) throw copy ErrorMsg::fatal (t.getLoc (), format (ValidateErrorMessage::MISMATCH_TUPLE_ARITY, t.getInners ().len, lst.getParameters ().len),
                                                                                               notes-> copy [copy ErrorMsg::note (lst.getLoc (), "")]);
                let mut syntTemplate = alls;
                for i in 0us .. lst.getParameters ().len {
                    let currentParam = TemplateRewriter (retMapper).rewrite (lst.getParameters ()[i]); // maybe some resolution already happened, we don't want to have collision in the mapper (e.g. (T of (U, U, U), U))
                    let rest = t.getInners ().len - consumed;
                    let syntaxRest = (lst.getParameters ().len - i) - 1us;

                    // Give all the types that rests for variadics, I don't see a better way, because last elements could be other things than templates, so variadics must be the last template elements
                    let consomableTypes = t.getInners ()[consumed .. consumed + (rest - syntaxRest)];
                    let (mapper, localConsumed) = self.validateOfVarExprFromExplicit (alias context, syntTemplate, currentParam, consomableTypes);

                    // Merging the mapper
                    retMapper:.merge (mapper);
                    consumed += cast!usize (localConsumed); // increment the number of used types
                    syntTemplate = TemplateRewriter (retMapper).replaceSyntaxTempl (syntTemplate);
                }

                {
                    // we don't check if all types of "type" were used,
                    // there is not need, because we validate the template, and check if it is equivalent to "type", so if some elements of "type" were unused, it should fail here
                    let finalType = TemplateRewriter (retMapper).rewrite (lst);
                    let ofType = context:.validateType (finalType);
                    context.verifyCompatibleType (lst.getLoc (), type.getLoc (), ofType, type);
                } catch {
                    err : &ErrorMsg => {
                        throw copy ErrorMsg::note (lst.getLoc (), format (ValidateErrorMessage::TEMPLATE_SPE, retMapper), notes-> copy [err]);
                    }
                }

                return (retMapper, 1us);
            }
            _ => {
                throw copy ErrorMsg::fatal (type.getLoc (), format (ValidateErrorMessage::NOT_A_TUPLE, type),
                                            notes-> copy [copy ErrorMsg::note (lst.getLoc (), "")]);
            }
        }
    }
    
    /**
     * Validate an explicit inner part of an of var, where the inner part is a FunctionPtrTypeExpr (A of fn (U)-> J)
     * @params:
     *    - context: the context of the validation
     *    - alls: the list of template parameters that are not validated yet
     *    - fptr: the function type expression to validate
     *    - values: the list of values passed to the template call
     * @returns: the template parameter specialization
     * @throws:
     *    - &ErrorMsg: if the specialization failed
     * */
    fn validateOfFuncPtrInnerExplicit (self, dmut context : &Validator, alls : [&Expression], fptr : &FunctionPtrTypeExpr, types : [&Type])-> (TemplateMapper, usize)
        throws ErrorMsg
    {
        let type = context.implicitEnumUnwrap (types [0]);
        let (params, retType) = match (fptr.isClosure (), type) {
            (false, f : &FuncPtrType) => {
                (f.getParameters (), f.getRetType ())
            }
            (true, d : &DelegateType) => {
                (d.getParameters (), d.getRetType ())
            }
            _ => {
                throw copy ErrorMsg::fatal (fptr.getLoc (), format (ValidateErrorMessage::TEMPLATE_SPECIALIZATION_FAILS, fptr, type));
            }
        };

        if (fptr.getParameters ().len > params.len) {
            throw copy ErrorMsg::fatal (type.getLoc (), format (ValidateErrorMessage::TEMPLATE_SPECIALIZATION_FAILS, fptr, type),
                                        notes-> copy [copy ErrorMsg::fatal (fptr.getLoc (), format (ValidateErrorMessage::INCOMPATIBLE_TYPE, fptr, type))]);
        }

        let mut consumed = 0us;
        let mut retMapper = TemplateMapper (score-> TemplateScore::TYPE);
        let mut syntTemplate = alls;

        for i in 0us .. fptr.getParameters ().len {
            let v = fptr.getParameters ()[i];

            let currentParam = TemplateRewriter (retMapper).rewrite (v.getType ());
            let rest = params.len - consumed;
            let syntaxRest = (fptr.getParameters ().len - i) - 1us;
            let consomableTypes = params [consumed .. consumed + (rest - syntaxRest)];

            let (tiMapper, localConsumed) = self.validateOfVarExprFromExplicit (alias context, syntTemplate, currentParam, consomableTypes);

            retMapper:.merge (tiMapper);
            consumed += cast!usize (localConsumed);
            syntTemplate = TemplateRewriter (retMapper).replaceSyntaxTempl (syntTemplate);
        }

        let retParam = TemplateRewriter (retMapper).rewrite (fptr.getReturn ());
        let (tiMapper, _) = self.validateOfVarExprFromExplicit (alias context, syntTemplate, retParam, copy [retType]);
        retMapper:.merge (tiMapper);

        let finalType = TemplateRewriter (retMapper).rewrite (fptr);
        let ofType = context:.validateType (finalType);
        context.verifyCompatibleType (fptr.getLoc (), type.getLoc (), ofType, type);

        return (retMapper, 1us);
    }



    /*!
     * ================================================================================
     * ================================================================================
     * =========================      EXPLICIT OVER VAR       =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate an explicit template specialization where template parameter is an over var
     * @params: 
     *    - context: the context of the validation
     *    - v: the template of var to validate
     *    - values: the list of values passed to the template call
     * @returns:
     *    - .0: the template parameter specialization
     *    - .1: the number of consumed parameters (should be 1us)
     * @throws:
     *    - &ErrorMsg: if the values cannot be used to specialize the template parameter
     */
    fn validateOverVarExprFromExplicit (self, dmut context : &Validator, alls : [&Expression], v : &TemplateOfVarExpr, values : [&Generator])-> (TemplateMapper, usize)
        throws ErrorMsg
    {
        match values [0] {
            t : &Type => {
                match context.implicitEnumUnwrap (t) {
                    c : &ClassPtrType => {
                        if (!c.isStruct ()) { // record and entity does not override super classes
                            let mapper = self.validateOverClassFromExplicit (alias context, alls, v, c);
                            let dmut retMapper = TemplateMapper (score-> TemplateScore::VAR);
                            retMapper:.merge (mapper);
                            retMapper:.insert (v.getLoc ().str, self.createTypeWrapper (c.getLoc (), c));

                            return (retMapper, 1us);
                        }
                    }
                }
            }
        }

        throw copy ErrorMsg::fatal (values [0].getLoc (), format (ValidateErrorMessage::NOT_A_CLASS, values [0]),
                                    notes-> copy [copy ErrorMsg::note (v.getLoc (), "")]);
    }

    /**
     * Validate an explicit template specialization wheer template parameter is an over var, and type used for specialization is a class type
     * @params:
     *     - context: the context of the validation
     *     - alls: the list of template parameters to validate
     *     - v: the over expr to validation
     *     - type: the class type used for validation
     * @assume: type is not a struct type
     * @returns: the template parameters specialization
     * @throws:
     *    - &ErrorMsg: if the specialization is impossible
     * */
    fn validateOverClassFromExplicit (self, dmut context : &Validator, alls : [&Expression], v : &TemplateOfVarExpr, type : &ClassPtrType)-> TemplateMapper
        throws ErrorMsg
    {
        let inner : &ClassRefType = type.getInner ();
        let mut retMapper = TemplateMapper (score-> TemplateScore::TYPE);
        let mut errors : [mut &ErrorMsg] = [];
        let mut ancestors : [mut &Type] = [];

        let mut ancestor = inner.getAncestor ();
        while let Ok (c) = ancestor {
            ancestors ~= [c.createInstance (loc-> v.getLoc (), isMutable-> false, isInnerMutable-> false)];
            ancestor = c.getAncestor ();
        }

        for i in 0 .. ancestors.len {
            {
                let (mapper, _) = self.validateOfVarExprFromExplicit (alias context, alls, v.getSpecialization (), ancestors [i .. i + 1]);
                let finalType = self.performTemplateRewrite (v.getSpecialization (), mapper);
                let ofType = context:.validateType (finalType);
                context.verifyCompatibleType (type.getLoc (), ofType.getLoc (), ancestors [i], ofType);

                retMapper:.merge (mapper);
                return retMapper;
            } catch {
                err : &ErrorMsg => { errors ~= [err]; }
            }
        }

        throw copy ErrorMsg::fatal (v.getLoc (), format (ValidateErrorMessage::NOT_ANCESTOR, v.getSpecialization (), type), notes-> errors);
    }
    
    /*!
     * ================================================================================
     * ================================================================================
     * =========================      EXPLICIT IMPL VAR       =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate an explicit template specialization where template parameter is an impl var
     * @params: 
     *    - context: the context of the validation
     *    - v: the template of var to validate
     *    - values: the list of values passed to the template call
     * @returns:
     *    - .0: the template parameter specialization
     *    - .1: the number of consumed parameters (should be 1us)
     * @throws:
     *    - &ErrorMsg: if the values cannot be used to specialize the template parameter
     */
    fn validateImplVarExprFromExplicit (self, dmut context : &Validator, alls : [&Expression], v : &TemplateOfVarExpr, values : [&Generator])-> (TemplateMapper, usize)
        throws ErrorMsg
    {
        match values [0] {
            t : &Type => {
                match context.implicitEnumUnwrap (t) {
                    c : &ClassPtrType => { // only class types can implement traits
                        let mapper = self.validateImplClassFromExplicit (alias context, alls, v, c);
                        let dmut retMapper = TemplateMapper (score-> TemplateScore::VAR);
                        retMapper:.merge (mapper);
                        retMapper:.insert (v.getLoc ().str, self.createTypeWrapper (c.getLoc (), c));

                        return (retMapper, 1us);
                    }
                }
            }
        }

        throw copy ErrorMsg::fatal (values [0].getLoc (), format (ValidateErrorMessage::NOT_A_CLASS, values [0]),
                                    notes-> copy [copy ErrorMsg::note (v.getLoc (), "")]);
    }    

    /**
     * Validate an explicit template specialization where template parameter is an impl var, and type used for specialization is a class type
     * @params:
     *    - context: the context of the validation
     *    - alls: the list of template parameters to validate
     *    - v: the impl expr to validate
     *    - type: the class type used for validation
     * @returns: the template parameter specialization
     * @throws: 
     *    - &ErrorMsg: if the specialization is impossible 
     */
    fn validateImplClassFromExplicit (self, dmut context : &Validator, alls : [&Expression], v : &TemplateOfVarExpr, type : &ClassPtrType)-> TemplateMapper
        throws ErrorMsg
    {
        let inner = type.getInner ().asOf!{&ClassRefType} ();
        let mut errors : [mut &ErrorMsg] = [];
        let mut retMapper = TemplateMapper (score-> TemplateScore::TYPE);
        let trs = inner.getAllImplTraits ();

        for i in 0 .. trs.len {
            {
                let (mapper, _) = self.validateOfVarExprFromExplicit (alias context, alls, v.getSpecialization (), trs [i .. i + 1]);
                let finalType = self.performTemplateRewrite (v.getSpecialization (), mapper);
                let ofType = context:.validateType (finalType);
                context.verifyImplement (v.getLoc (), type, ofType);

                retMapper:.merge (mapper);
                return retMapper;
            } catch {
                err : &ErrorMsg => { errors ~= [err]; }
            }
        }

        throw copy ErrorMsg::fatal (v.getLoc (), format (ValidateErrorMessage::CLASS_NOT_IMPL, type, v.getSpecialization ()), notes-> errors);
    }


    /*!
     * ================================================================================
     * ================================================================================
     * =========================    EXPLICIT TEMPLATE AND     =========================
     * ================================================================================
     * ================================================================================
     */

    fn validateTemplateAndFromExplicit (self, dmut context : &Validator, alls : [&Expression], v : &TemplateAndExpr, values : [&Generator])-> (TemplateMapper, usize)
        throws ErrorMsg
    {
        match values [0] {
            tx : &Type => {
                let dmut retMapper = TemplateMapper (score-> TemplateScore::VAR);
                for index, t in v.getSpecializations () {
                    let templates = TemplateRewriter (retMapper).replaceSyntaxTempl (alls);
                    let ofv = TemplateRewriter (retMapper).rewrite (t);

                    let (mapper, _) = self.validateParamTemplateFromExplicit (alias context, templates, ofv, values [0 .. 1]);
                    retMapper:.merge (mapper, replace-> true);
                    retMapper:.remove (format ("%.%", v.getLoc ().str, index));
                }

                retMapper:.insert (v.getLoc ().str, self.createTypeWrapper (tx.getLoc (), tx));
                (retMapper, 1us)
            }
            _ => { // a value was passed, no association possible here
                throw copy ErrorMsg::fatal (values [0].getLoc (), format (ValidateErrorMessage::USE_AS_TYPE_TEMPLATE, values[0]),
                                            notes-> copy [copy ErrorMsg::note (v.getLoc (), "")]);
            }
        }
    }


    /*!
     * ================================================================================
     * ================================================================================
     * =========================    EXPLICIT TEMPLATE VAR     =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate an explicit template specialization where template parameter is an template var (struct T, class T, ...)
     * @params: 
     *    - context: the context of the validation
     *    - v: the template of var to validate
     *    - values: the list of values passed to the template call
     * @returns:
     *    - .0: the template parameter specialization
     *    - .1: the number of consumed parameters (should be 1us)
     * @throws:
     *    - &ErrorMsg: if the values cannot be used to specialize the template parameter
     */
    fn validateTemplateVarExprFromExplicit (self, dmut context : &Validator, _ : [&Expression], v : &TemplateVarExpr, values : [&Generator])-> (TemplateMapper, usize)
        throws ErrorMsg
    {
        match values [0] {
            tx : &Type => { // TemplateVarType is here to check the kind of type that is used, ("alias", "class", "struct" and "tuple"), so it has to be a type
                let t = context.implicitEnumUnwrap (tx);
                match v.getKind () {
                    TemplateVarType::ALIAS => {
                        if (!t.toDeeplyMutable ().needExplicitAlias ()) { // "alias", means its an aliasable type
                            throw copy ErrorMsg::fatal (values[0].getLoc (), format (ValidateErrorMessage::NOT_ALIASABLE, t),
                                                        notes-> copy [copy ErrorMsg::note (v.getLoc (), "")]);
                        }
                    }
                    TemplateVarType::CLASS => { // "class" must be a class type
                        let isClass = match t {
                            c : &ClassPtrType => { !c.isStruct () }
                            _ => { false }
                        };

                        if (!isClass) {
                            throw copy ErrorMsg::fatal (values[0].getLoc (), format (ValidateErrorMessage::NOT_A_CLASS, t),
                                                        notes-> copy [copy ErrorMsg::note (v.getLoc (), "")]);
                        }
                    }
                    TemplateVarType::ENTITY => { // "entity" must be a struct type
                        let isStruct = match t {
                            c : &ClassPtrType => { c.isEntity () }
                            _ => { false }
                        };

                        if (!isStruct) {
                            throw copy ErrorMsg::fatal (values[0].getLoc (), format (ValidateErrorMessage::NOT_AN_ENTITY, t),
                                                        notes-> copy [copy ErrorMsg::note (v.getLoc (), "")]);
                        }
                    }
                    TemplateVarType::ENTITY => { // "entity" must be a struct type
                        let isStruct = match t {
                            c : &ClassPtrType => { c.isUnion () }
                            _ => { false }
                        };

                        if (!isStruct) {
                            throw copy ErrorMsg::fatal (values[0].getLoc (), format (ValidateErrorMessage::NOT_AN_UNION, t),
                                                        notes-> copy [copy ErrorMsg::note (v.getLoc (), "")]);
                        }
                    }
                    TemplateVarType::RECORD => {
                        let isStruct = match t {
                            c : &ClassPtrType => { c.isRecord () }
                            _ => { false }
                        };

                        if (!isStruct) {
                            throw copy ErrorMsg::fatal (values[0].getLoc (), format (ValidateErrorMessage::NOT_A_RECORD, t),
                                                        notes-> copy [copy ErrorMsg::note (v.getLoc (), "")]);
                        }
                    }
                    TemplateVarType::TUPLE => { // "tuple" must be a tuple type
                        if (t !of TupleType) {
                            throw copy ErrorMsg::fatal (values[0].getLoc (), format (ValidateErrorMessage::NOT_A_TUPLE, t),
                                                        notes-> copy [copy ErrorMsg::note (v.getLoc (), "")]);
                        }
                    }
                }

                // There was no problem, so we can return a mapper, with the type association
                let dmut retMapper = TemplateMapper (score-> TemplateScore::VAR); // normal score
                retMapper:.insert (v.getLoc ().str, self.createTypeWrapper (t.getLoc (), t)); // insert the mapping
                return (retMapper, 1us); // 1 type consumed
            }
            _ => { // a value was passed, no association possible here
                throw copy ErrorMsg::fatal (values [0].getLoc (), format (ValidateErrorMessage::USE_AS_TYPE_TEMPLATE, values[0]),
                                            notes-> copy [copy ErrorMsg::note (v.getLoc (), "")]);
            }
        }
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================  VARIADIC TEMPLATE EXPLICIT  =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a template variadic var
     * @params: 
     *    - context: the context of the validation
     *    - alls: the list of template parameters of the current specialization
     *    - v: the variadic to validate
     *    - values: the list of values/types to pass to the variadic template
     * @returns: 
     *    - .0: the template parameter specialization
     *    - .1: the number of consumed parameters (should be 1us)
     * @throws:
     *    - &ErrorMsg: if the values cannot be used to specialize the template parameter
     */
    fn validateTemplateVariadicFromExplicit (self, dmut _ : &Validator, _ : [&Expression], v : &TemplateVariadicVarExpr, values : [&Generator])-> (TemplateMapper, usize)
        throws ErrorMsg
    {
        // Not a complex function, simply transform all the types in 'values' into a template type
        let mut retTypes : [mut &Type] = [];
        for i in 0us .. values.len { 
            match values [i] {
                t : &Type => { retTypes ~= [t]; }
                _ => { // only types can be used to perform a type specialization
                    throw copy ErrorMsg::fatal (values [i].getLoc (), format (ValidateErrorMessage::USE_AS_TYPE_TEMPLATE, values [i]),
                                                notes-> copy [copy ErrorMsg::note (v.getLoc (), "")]);
                }
            }
        }

        let dmut retMapper = TemplateMapper (score-> TemplateScore::VAR);
        if (retTypes.len != 1us) {
            retMapper:.insert (v.getLoc ().str, copy TypeListWrapperExpr (v.getLoc (), retTypes)); // insert the tuple in the mapper
        } else {
            retMapper:.insert (v.getLoc ().str, self.createTypeWrapper (v.getLoc (), retTypes [0])); // insert a single type in the mapper
        }
        
        return (retMapper, values.len); // consumed as many types as there are to consumed
    }       


    /*!
     * ================================================================================
     * ================================================================================
     * =========================   ANY EXPRESSION EXPLICIT   ==========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a var decl expression test from explicit specialization
     * @params:
     *     - context: the context of the validation
     *     - vdecl: the var declaration to validate
     *     - values: the list of values explicitly passed for template specialization
     * @returns: 
     *     - .0: the template mapper specialization
     *     - .1: the number of consumed parameters 
     * @throws:
     *     - &ErrorMsg: if the var decl cannot be specialized from values
     */
    fn validateVarDeclExprFromExplicit (self, dmut context : &Validator, alls : [&Expression], vdecl : &VarDeclExpr, values : [&Generator])-> (TemplateMapper, usize)
        throws ErrorMsg
    {
        if (values.len == 0us) throw copy ErrorMsg::fatal (vdecl.getLoc (), format (ValidateErrorMessage::TEMPLATE_SPECIALIZATION_FAILS, vdecl, values));
        match values [0] {
            mut v : &Value => {
                let dmut retMapper = TemplateMapper (score-> TemplateScore::VALUE);

                match vdecl.getType () {
                    EmptyExpression () => {}
                    func : &FunctionPtrTypeExpr => {
                        return self.validateVarDeclFunctionValueFromExplicit (alias context, vdecl.getLoc(), alls, func, v);
                    }
                    type : _ => {
                        let (mapper, _) = self.validateOfVarExprFromExplicit (alias context, alls, type, copy [v.getType ()]);
                        let rewriteType = self.performTemplateRewrite (type, mapper);
                        let vType = context:.validateType (rewriteType);
                        v = context:.verifyCompatibleTypeWithValue (type.getLoc (), vType, v, byReference-> false);

                        retMapper:.merge (mapper);
                    }
                }
                
                match vdecl.getValue () {
                    EmptyExpression () => {}
                    val : _ => {
                        let vVal = context:.validateValue (val);
                        if (!context:.getCompileTimeInterpreter ().isCte (vVal)) {
                            throw copy ErrorMsg::fatal (vVal.getLoc (), format (ValidateErrorMessage::UNKNOWN_AT_COMPILE_TIME, vVal.getType ()));
                        }

                        if (v != vVal) {
                            throw copy ErrorMsg::fatal (vdecl.getLoc (), format (ValidateErrorMessage::TEMPLATE_SPECIALIZATION_FAILS, vdecl, values),
                                                        notes-> copy [copy ErrorMsg::fatal (v.getLoc (), format (ValidateErrorMessage::INCOMPATIBLE_VALUES, vVal, v))]);
                        }
                    }
                }

                retMapper:.insert (vdecl.getLoc ().str, copy ValueWrapperExpr (vdecl.getLoc (), v));

                return (retMapper, 1us);
            }
            t : _ => {
                throw copy ErrorMsg::fatal (vdecl.getLoc (), format (ValidateErrorMessage::TEMPLATE_SPECIALIZATION_FAILS, vdecl, values),
                                            notes-> copy [copy ErrorMsg::fatal (t.getLoc (), format (ValidateErrorMessage::USE_AS_VALUE_TEMPLATE, t))]);
            }
        }
    }

    /**
     * Validate a value expression test from explicit specialization
     * @params:
     *     - context: the context of the validation
     *     - expr: the expression to validate and compare
     *     - values: the list of values explicitely passed for template specialization
     * @returns: 
     *    - .0: the template mapper specialization
     *    - .1: the number of consumed parameters (should be always 1)
     * @throws:
     *    - &ErrorMsg: if the values are not compatible (or expr is not cte)
     */
    fn validateValueExpressionFromExplicit (self, dmut context : &Validator, expr : &Expression, values : [&Generator])-> (TemplateMapper, usize)
        throws ErrorMsg
    {
        let val = context:.validateValue (expr);
        if (!context:.getCompileTimeInterpreter ().isCte (val)) {
            throw copy ErrorMsg::fatal (val.getLoc (), format (ValidateErrorMessage::UNKNOWN_AT_COMPILE_TIME, val.getType ()));
        }
        
        if (values.len == 0us) throw copy ErrorMsg::fatal (expr.getLoc (), format (ValidateErrorMessage::TEMPLATE_SPECIALIZATION_FAILS, expr, values));
        match values [0] {
            v : &Value => {
                {
                    let cmp = context:.getBinOpValidator ().validateComparisonOperation (alias context, expr.getLoc (), BinaryOperators::DEQUAL, v, val);
                    if (context:.getCompileTimeInterpreter ():.computeBool (cmp)) {
                        let mut retMapper = TemplateMapper (score-> TemplateScore::VALUE);
                        let loc = expr.getLoc ();
                        retMapper:.insert (format ("%[%,%]", loc.str, loc.line, loc.col), copy ValueWrapperExpr (loc, v));

                        return (retMapper, 1us);
                    } else {
                        throw copy ErrorMsg::fatal (v.getLoc (), format (ValidateErrorMessage::INCOMPATIBLE_VALUES, val, v));
                    }
                } catch {
                    innerErr : &ErrorMsg => throw copy ErrorMsg::fatal (expr.getLoc (), format (ValidateErrorMessage::TEMPLATE_SPECIALIZATION_FAILS, expr, values),
                                                                        notes-> copy [innerErr]);
                }
            }
            t : _ => {                
                throw copy ErrorMsg::fatal (expr.getLoc (), format (ValidateErrorMessage::TEMPLATE_SPECIALIZATION_FAILS, expr, values),
                                            notes-> copy [copy ErrorMsg::fatal (t.getLoc (), format (ValidateErrorMessage::USE_AS_VALUE_TEMPLATE, t))]);
                
            }
        }
    }

    /*!
     * =============================================================================================
     * =============================================================================================
     * =========================           EXPLICIT LAMBDA VALUE           =========================
     * =============================================================================================
     * =============================================================================================
     */

    /**
     * Validate a function value expression (vardecl : fn (...)-> ...) using a cte value
     * @params:
     *   - context: the context of the validation
     *   - loc: the location of the vardecl
     *   - alls: the template parameters being specialied
     *   - fptrType: the type of the var decl being specialized
     *   - value: the value used for specialization
     * @returns:
     *   - .0: the template mapper, with the most information possible
     *   - .1: 1us
     * @warning:
     * The returned template mapper may contain lambdavaluewrapper,
     * and thus need to be finalized by the template declarator, to create
     * the function pointer from the lambda value with the correct types
     * */
    fn validateVarDeclFunctionValueFromExplicit (self, dmut context : &Validator, loc : &Word, alls : [&Expression], fptrType : &FunctionPtrTypeExpr, value : &Value)-> (TemplateMapper, usize)
        throws ErrorMsg
    {
        if (fptrType.isClosure ()) {
            throw copy ErrorMsg::fatal (loc, format (ValidateErrorMessage::TEMPLATE_SPECIALIZATION_FAILS, fptrType, value.getType ()),
                                        notes-> copy [copy ErrorMsg::fatal (fptrType.getLoc (), ValidateErrorMessage::CLOSURE_TEMPLATE_LAMBDA)]);
        }

        match value {
            lmbdValue : &LambdaValue => {
                return self.validateVarDeclLambdaFromExplicit (alias context, loc, alls, fptrType, lmbdValue);
            }
            nameFunc : &ProtoFuncPtrValue => {
                return self.validateVarDeclProtoFuncPtrFromExplicit (alias context, loc, alls, fptrType, nameFunc);
            }
            _ => {
                throw copy ErrorMsg::fatal (loc, format (ValidateErrorMessage::TEMPLATE_SPECIALIZATION_FAILS, fptrType, value.getType ()),
                                            notes-> copy [copy ErrorMsg::fatal (fptrType.getLoc (), format (ValidateErrorMessage::INCOMPATIBLE_VALUES, fptrType, value))]);
            }
        }
    }

    /**
     * * Validate a function value expression (vardecl : fn (...)-> ...) using a function pointer value for specialization
     * * @params:
     *   - context: the context of the validation
     *   - loc: the location of the vardecl
     *   - alls: the template parameters being specialied
     *   - fptrType: the type of the var decl being specialized
     *   - fptrValue: the function pointer value used for specialization
     * @returns:
     *   - .0: the template mapper, with the most information possible
     *   - .1: 1us
     * */
    fn validateVarDeclProtoFuncPtrFromExplicit (self, dmut context : &Validator, loc : &Word, alls : [&Expression], fptrType : &FunctionPtrTypeExpr, fptrValue : &ProtoFuncPtrValue)-> (TemplateMapper, usize)
        throws ErrorMsg
    {
        if let fptrValueType : &FuncPtrType = fptrValue.getType () {
            let dmut retMapper = TemplateMapper (score-> TemplateScore::VALUE);
            let (typeMapper, _) = self.validateOfFuncPtrInnerExplicit (alias context, alls, fptrType, copy [fptrValueType]);
            retMapper:.merge (typeMapper);

            let finalType = self.performTemplateRewrite (fptrType, retMapper);
            let ofType = context:.validateType (finalType);
            let ofValue = context:.verifyCompatibleTypeWithValue (loc, ofType, fptrValue, byReference-> false);

            retMapper:.insert (loc.str, copy ValueWrapperExpr (loc, ofValue));

            return (retMapper, 1us);
        } else panic;
    }

    /**
     * * Validate a function value expression (vardecl : fn (...)-> ...) using a lambda value for specialization
     * * @params:
     *   - context: the context of the validation
     *   - loc: the location of the vardecl
     *   - alls: the template parameters being specialied
     *   - fptrType: the type of the var decl being specialized
     *   - lmbdValue: the lambda value used for specialization
     * @returns:
     *   - .0: the template mapper, with the most information possible
     *   - .1: 1us
     * @warning:
     * The returned template mapper may contain lambdavaluewrapper,
     * and thus need to be finalized by the template declarator, to create
     * the function pointer from the lambda value with the correct types
     * */
    fn validateVarDeclLambdaFromExplicit (self, dmut context : &Validator, loc : &Word, alls : [&Expression], fptrType : &FunctionPtrTypeExpr, lmbdValue : &LambdaValue)-> (TemplateMapper, usize)
        throws ErrorMsg
    {
        if (lmbdValue.isClosure ()) {
            throw copy ErrorMsg::fatal (loc, format (ValidateErrorMessage::TEMPLATE_SPECIALIZATION_FAILS, fptrType, lmbdValue),
                                        notes-> copy [copy ErrorMsg::fatal (lmbdValue.getLoc (), ValidateErrorMessage::CLOSURE_TEMPLATE_LAMBDA)]);
        }

        if (fptrType.getParameters ().len > lmbdValue.getParameters ().len) {
            throw copy ErrorMsg::fatal (loc, format (ValidateErrorMessage::TEMPLATE_SPECIALIZATION_FAILS, fptrType, lmbdValue),
                                        notes-> copy [copy ErrorMsg::fatal (fptrType.getLoc (), format (ValidateErrorMessage::INCOMPATIBLE_VALUES, fptrType, lmbdValue))]);
        }

        let mut retMapper = TemplateMapper (score-> TemplateScore::VALUE);
        let (paramMapper, uncomplete, paramTypes) = self.validateLambdaParameters (alias context, alls, fptrType, lmbdValue);
        retMapper:.merge (paramMapper);

        if (!uncomplete) { // the lambda value can be completed using the infered types
            self.finalizeLambdaPrototype (alias context, loc, alls, fptrType, lmbdValue, paramTypes, ref retMapper);
            return (retMapper, 1us);
        }

        // It cannot, but maybe we can get some more informations from it
        if lmbdValue.getRetType () !of NoneType {
            let returnExpr = self.performTemplateRewrite (fptrType.getReturn (), retMapper);
            let (retTypeMapper, _) = self.validateOfVarExprFromExplicit (alias context, alls, returnExpr, copy [lmbdValue.getRetType ()]);
            retMapper:.merge (retTypeMapper);
        }

        match self.performTemplateRewrite (fptrType, retMapper) {
            fptr : &FunctionPtrTypeExpr => { // insert the uncomplete lambda, for future validation in finalization of the rewriter
                retMapper:.insert (loc.str, copy LambdaValueWrapperExpr (loc, loc.str, fptr, lmbdValue));
            }
            _ => panic;
        }

        return (retMapper, 1us);
    }


    /**
     * Try to infer the types of the function parameters, using an uncomplete lambda value
     * @returns:
     *   .0: the template mapper, with some validated types
     *   .1: true iif all the lambda types are validated
     *   .2: the list of types for the parameters (contains some none type if !.1)
     * */
    fn validateLambdaParameters (self, dmut context : &Validator, alls : [&Expression], fptrType : &FunctionPtrTypeExpr, lmbdValue : &LambdaValue)-> (TemplateMapper, bool, [&Type])
        throws ErrorMsg
    {
        let mut retMapper = TemplateMapper ();
        let mut uncomplete = false;
        let mut paramTypes : [mut &Type] = [];

        if (fptrType.getParameters ().len != lmbdValue.getParameters ().len) {
            return (retMapper, true, []);
        }

        for i, vd in fptrType.getParameters () match lmbdValue.getParameters ()[i] {
            v : &ProtoVarValue => { // lambda has a type to validate
                let tiExpr = TemplateRewriter (retMapper).rewrite (vd.getType ());
                let (tiMapper, _) = self.validateOfVarExprFromExplicit (alias context, alls, tiExpr, copy [v.getType ()]);
                retMapper:.merge (tiMapper);

                let finalExpr = TemplateRewriter (retMapper).rewrite (vd.getType ());
                paramTypes ~= [context:.validateType (finalExpr)];
            }
            _ => { paramTypes ~= [NONE_TYPE]; }
        }

        for i, v in fptrType.getParameters () match lmbdValue.getParameters ()[i] {
            ProtoVarValue () => {}
            _ => {
                let tiExpr = TemplateRewriter (retMapper).rewrite (v.getType ());
                {
                    paramTypes [i] = context:.validateType (tiExpr);
                } catch {
                    _ => { uncomplete = true; }
                }
            }
        }

        (retMapper, uncomplete, paramTypes)
    }

    /**
     * Finalize the creation of the prototype of the lambda function from the specialization
     * @assume: the paramTypes are complete
     * */
    fn finalizeLambdaPrototype (self, dmut context : &Validator, loc : &Word, alls : [&Expression], fptrType : &FunctionPtrTypeExpr, lmbdValue : &LambdaValue, paramTypes : [&Type], ref mut retMapper : TemplateMapper)
        throws ErrorMsg
    {
        let (proto_, frame) = context:.getLambdaValidator ():.validateLambdaBody (alias context, lmbdValue, paramTypes);
        if let proto : &ProtoFuncPtrValue = proto_ {
            if let __fptrType : &FuncPtrType = proto.getType () {
                let retType = __fptrType.getRetType ();
                let returnExpr = self.performTemplateRewrite (fptrType.getReturn (), retMapper);
                let (retTypeMapper, _) = self.validateOfVarExprFromExplicit (alias context, alls, returnExpr, copy [retType]);

                context:.getLambdaValidator ().insertGenerator (alias context, frame);
                retMapper:.merge (retTypeMapper);
                retMapper:.insert (loc.str, copy ValueWrapperExpr (loc, proto));

                let fptrFinal = TemplateRewriter (retMapper).rewrite (fptrType);
                let ofType = context:.validateType (fptrFinal);

                context.verifyCompatibleType (fptrType.getLoc (), lmbdValue.getLoc (), ofType, proto.getType ());

                return;
            }
        }

        panic;
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================           IMPLICIT           =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a template implicit validation of a parameter that may contain template variables
     * @params: 
     *    - context: the context of the validation
     *    - templates: the list of template associated to the parameter
     *    - parameter: the syntax expression (basically a vardecl) that contains a type that may contain template variable
     *    - types: the list of type that can be associated to the templates
     * @returns:
     *    - .0: the mapper in case of validation (used to create a valid rewriter)
     *    - .1: the number of types that were consumed during the validation
     * @throws:
     *    - &ErrorMsg: if the specialization failed
     */
    fn validateParamTemplateFromImplicit (self, dmut context : &Validator, templates : [&Expression], param : &VarDeclExpr, types : [&Type])-> (TemplateMapper, usize)
        throws ErrorMsg
    {
        match param.getType () { // we want to transform its type from implicit specialization
            EmptyExpression () => { // It has no type
                (TemplateMapper (), 0us)
            }
            type : _ => { // There is possible information, if the type contains templates, so we validate it
                {
                    self.validateTypeFromImplicit (alias context, templates, type, types)
                } catch {
                    err : &ErrorMsg => {
                        throw err;
                        // throw copy ErrorMsg::fatal (param.getLoc (), format (ValidateErrorMessage::PARAMETER_NAME, x.getName ()), notes-> copy [err]);
                    }
                }
            }
        }
    }

    /**
     * Validate the implicit specialization of 'typeExpr' from 'types' using 'templates' as template parameters 
     * @params: 
     *    - context: the context of the validation
     *    - templates: the list of tempalte to specialize
     *    - typeExpr: a type foudn during implicit validation (inside vardecl for example)
     *    - types: the types that will be used to transform typeExpr, and templates into specialized values
     * @returns:
     *    - .0: the mapper in case of validation (used to create a valid rewriter)
     *    - .1: the number of types that were consumed during the validation
     * @throws:
     *    - &ErrorMsg: if the specialization failed
     */
    fn validateTypeFromImplicit (self, dmut context : &Validator, templates : [&Expression], typeExpr : &Expression, types : [&Type])-> (TemplateMapper, usize)
        throws ErrorMsg
    {
        match typeExpr {
            s : &SliceAllocatorExpr => {
                return self.validateTypeFromImplicitAlloc (alias context, templates, s, types);
            }
            c : &TemplateCallExpr => {
                return self.validateTypeFromImplicitTemplateCall (alias context, templates, c, types);
            }
            v : &VarExpr => {
                return self.validateTypeFromImplicitVarExpr (alias context, templates, v, types);
            }
            p : &PathExpr => {
                return self.validateTypeFromImplicitPath (alias context, templates, p, types);
            }
            b : &BinaryExpr => {
                return self.validateTypeFromImplicitBinary (alias context, templates, b, types);
            }
            un : &UnaryExpr => {
                return self.validateTypeFromImplicitUnary (alias context, templates, un, types);
            }
            t : &TryExpr => {
                return self.validateTypeFromImplicitTryExpr (alias context, templates, t, types);
            }
            f : &FutureTypeExpr => {
                return self.validateTypeFromImplicitFutureExpr (alias context, templates, f, types);
            }
            r : &RangeTypeExpr => {
                return self.validateTypeFromImplicitRangeExpr (alias context, templates, r, types);
            }
            d : &DecoratedExpr => {
                return self.validateTypeFromImplicit (alias context, templates, d.getContent (), types);
            }
            lst : &ListExpr => {
                if (lst.isArray ()) {
                    return self.validateTypeFromImplicitSlice (alias context, templates, lst, types);
                } else {
                    return self.validateTypeFromImplicitTuple (alias context, templates, lst, types);
                }
            }
            m : &ListMapExpr => {
                return self.validateTypeFromImplicitMap (alias context, templates, m, types);
            }
            f : &FunctionPtrTypeExpr => {
                return self.validateTypeFromImplicitFptr (alias context, templates, f, types);
            }
            _ => {
                return (TemplateMapper (), 1us);
            }
        }
    }


    /**
     * Validate the implicit specialization of a type using a slice allocation expression
     * @params:
     *    - context: the context of the validaiton
     *    - templates: the list of template to specialize
     *    - lst: the list expression of slice type to validate
     *    - types: the types that will be used to transform typeExpr, and templates into specialized values
     * @returns:
     *    - .0: the mapper in case of validation (used to create a valid rewriter)
     *    - .1: the number of types that were consumed during the validation
     * @throws:
     *    - &ErrorMsg: if the specialization failed
     * */
    fn validateTypeFromImplicitAlloc (self, dmut context : &Validator, templates : [&Expression], s : &SliceAllocatorExpr, types : [&Type])-> (TemplateMapper, usize)
        throws ErrorMsg
    {
        if (types.len >= 1us) {
            match context.implicitEnumUnwrap (types [0]) {
                slc : &SliceType => {
                    let dmut retMapper = TemplateMapper ();
                    let (typeMapper, _) = self.validateTypeFromImplicit (alias context, templates, s.getValue (), slc.getInners ());
                    retMapper:.merge (typeMapper);
                    match (s.getSize (), slc.getSize ()) {
                        (_, UnitValue ()) => {}
                        (v : &VarExpr, size : &Value) => {
                            let expr = self.findExpression (v.getLoc ().str, templates);
                            if expr !of EmptyExpression {
                                let (valMapper, _) = self.validateParamTemplateFromExplicit (alias context, templates, expr, copy [size]);
                                retMapper:.merge (valMapper);
                            }
                        }
                    }

                    return (retMapper, 1us);
                }
                arr : &ArrayType => {
                    let dmut retMapper = TemplateMapper ();
                    let (typeMapper, _) = self.validateTypeFromImplicit (alias context, templates, s.getValue (), arr.getInners ());
                    retMapper:.merge (typeMapper);

                    match s.getSize () {
                        v : &VarExpr => {
                            let expr = self.findExpression (v.getLoc ().str, templates);
                            if expr !of EmptyExpression {
                                let (valMapper, _) = self.validateParamTemplateFromExplicit (alias context, templates, expr, copy [makeIntValue (arr.getLoc (), arr.getLen ())]);
                                retMapper:.merge (valMapper);
                            }
                        }
                    }

                    return (retMapper, 1us);
                }
            }
        }

        return (TemplateMapper (), 1us);
    }

    /**
     * Validate the implicit specialization of a template call
     * @params:
     *    - context: the context of the validaiton
     *    - templates: the list of template to specialize
     *    - tmp: the template call to specialize
     *    - types: the types that will be used to transform typeExpr, and templates into specialized values
     * @returns:
     *    - .0: the mapper in case of validation (used to create a valid rewriter)
     *    - .1: the number of types that were consumed during the validation
     * @throws:
     *    - &ErrorMsg: if the specialization failed
     * */
    fn validateTypeFromImplicitTemplateCall (self, dmut context : &Validator, templates : [&Expression], tmp : &TemplateCallExpr, types : [&Type])-> (TemplateMapper, usize)
        throws ErrorMsg
    {
        if (types.len == 0us) { return (TemplateMapper (), 1us); }
        let (hasTmps, clTemplates) = self.createTemplateListOfType (context.implicitEnumUnwrap (types [0]));
        if (!hasTmps) return (TemplateMapper (), 1us);

        if (tmp.getRights ().len > clTemplates.len) return (TemplateMapper (), 1us);
        let mut retMapper = TemplateMapper ();
        let mut consumed = 0us;
        let mut syntTemplate = templates;

        for i in 0us .. tmp.getRights ().len {
            let currentParam = TemplateRewriter (retMapper).rewrite (tmp.getRights ()[i]);
            let rest = clTemplates.len - consumed;
            let syntaxRest = (tmp.getRights ().len - i) - 1us;

            let consomableTypes = clTemplates [consumed .. consumed + (rest - syntaxRest)];
            let (mapper, localConsumed) = if (consomableTypes.len > 0 && consomableTypes [0] of Value) {
                let mut mp = TemplateMapper ();
                let mut done = false;
                if let v : &VarExpr = currentParam {
                    let expr = self.findExpression (v.getLoc ().str, syntTemplate);
                    if expr !of EmptyExpression {
                        let (mp__,_) = self.validateParamTemplateFromExplicit (alias context, syntTemplate, expr, consomableTypes [0 .. 1]);
                        mp:.merge (mp__);
                        done = true;
                    }
                }

                if (!done) {
                    let (mp__, _) = self.validateParamTemplateFromExplicit (alias context, syntTemplate, currentParam, consomableTypes [0 .. 1]);
                    (mp__, 1us)
                } else {
                    (mp, 1us)
                }
            } else {
                let mut lst : [mut &Type] = [];
                for ti in consomableTypes match ti {
                    t : &Type => { lst ~= [t]; }
                    _ => { break; }
                }

                self.validateTypeFromImplicit (alias context, syntTemplate, currentParam, lst)
            }

            retMapper:.merge (mapper);
            consumed += cast!usize (localConsumed);
            syntTemplate = TemplateRewriter (retMapper).replaceSyntaxTempl (syntTemplate);
        }

        return (retMapper, 1us);
    }

    /**
     * Retreive the list of template from a type as a list of types
     * @warning: only return the types, leaving the values from the mapper
     * @info:
     *  - can return.0 be true, but with an empty list as .1, meaning there are templates, but some are values
     * @returns:
     *    - .0: true iif the type has templates
     *    - .1: the list of types
     * */
    fn createTemplateListOfType (self, type : &Type)-> (bool, [&Generator])
        throws ErrorMsg
    {
        let mapper = match type {
            cl : &ClassPtrType => {
                match cl.getInner ().getTemplateMapper () {
                    Ok (clTmps : _) => {
                        clTmps
                    }
                    _ => { return (false, []); }
                }
            }
            cl : &ClassRefType => {
                match cl.getTemplateMapper () {
                    Ok (clTmps : _) => {
                        clTmps
                    }
                    _ => { return (false, []); }
                }
            }
            t : &TraitRefType => {
                match t.getTemplateMapper () {
                    Ok (clTmps : _) => {
                        clTmps
                    }
                    _ => { return (false, []); }
                }
            }
            _ => { return (false, []); }
        };

        let mut vec : [mut &Generator] = [];
        for mp in mapper.getMapperSorted () match mp {
            t : &TypeWrapperExpr => {
                vec ~= [t.getType ()];
            }
            t : &TypeListWrapperExpr => {
                vec ~= t.getTypes ();
            }
            v : &ValueWrapperExpr => {
                vec ~= [v.getValue ()];
            }
        }

        (true, vec)
    }

    /**
     * Validate the implicit specialization of 'var' from 'types' using 'templates' as template parameters
     * @params: 
     *    - context: the context of the validation
     *    - templates: the list of template to specialize
     *    - var: a var expr describing a type
     *    - types: the types that will be used to transform typeExpr, and templates into specialized values
     * @returns:
     *    - .0: the mapper in case of validation (used to create a valid rewriter)
     *    - .1: the number of types that were consumed during the validation
     * @throws:
     *    - &ErrorMsg: if the specialization failed
     */
    fn validateTypeFromImplicitVarExpr (self, dmut context : &Validator, templates : [&Expression], var : &VarExpr, types : [&Type])-> (TemplateMapper, usize)
        throws ErrorMsg
    {
        let tmp = self.findExpression (var.getLoc ().str, templates);
        match tmp {
            EmptyExpression () => {
                return (TemplateMapper (), 1us);
            }
            _ => {
                let (ret, nb) = self.validateParamTemplateFromExplicit (alias context, templates, tmp, types);
                (ret, nb)
            }
        }
    }

    /**
     * Validate the implicit specialization of a path expression (A::B)
     * @params:
     *    - context: the context of the validation
     *    - templates: the list of templates to specialize
     *    - path: the path expression to specialize
     *    - types: the list of types used to specilize the path expr
     * @returns:
     *    - .0: the mapper in case of validation (used to create a valid rewriter)
     *    - .1: the number of types that were consumed during the validation
     * @throws:
     *    - &ErrorMsg: if the specialization failed
     * */
    fn validateTypeFromImplicitPath (self, dmut context : &Validator, templates : [&Expression], path : &PathExpr, types : [&Type])-> (TemplateMapper, usize)
        throws ErrorMsg
    {
        if (types.len >= 1us) {
            let (mapper, _) = self.validateTypeFromImplicit (alias context, templates, path.getRight (), types [0 .. 1]);
            return (mapper, 1us);
        }

        return (TemplateMapper (), 1us);
    }

    /**
     * Validate the implicit specialization of a binary expression (A::B)
     * @params:
     *    - context: the context of the validation
     *    - templates: the list of templates to specialize
     *    - bin: the binary expression to specialize
     *    - types: the list of types used to specilize the path expr
     * @returns:
     *    - .0: the mapper in case of validation (used to create a valid rewriter)
     *    - .1: the number of types that were consumed during the validation
     * @throws:
     *    - &ErrorMsg: if the specialization failed
     * */
    fn validateTypeFromImplicitBinary (self, dmut context : &Validator, templates : [&Expression], bin : &BinaryExpr, types : [&Type])-> (TemplateMapper, usize)
        throws ErrorMsg
    {
        if (types.len >= 1us) {
            if let v : &Expression = bin.getRight () && bin.getLoc () == BinaryOperators::DCOLON {
                let (mapper, _) = self.validateTypeFromImplicit (alias context, templates, v, types [0 .. 1]);
                return (mapper, 1us);
            }
        }

        return (TemplateMapper (), 1us);
    }

    /**
     * Validate the implicit specialization of a type using an unary operator expression
     * @params:
     *    - context: the context of the validaiton
     *    - templates: the list of template to specialize
     *    - un: the unary operator type to validate
     *    - types: the types that will be used to transform typeExpr, and templates into specialized values
     * @returns:
     *    - .0: the mapper in case of validation (used to create a valid rewriter)
     *    - .1: the number of types that were consumed during the validation
     * @throws:
     *    - &ErrorMsg: if the specialization failed
     * */
    fn validateTypeFromImplicitUnary (self, dmut context : &Validator, templates : [&Expression], un : &UnaryExpr, types : [&Type])-> (TemplateMapper, usize)
        throws ErrorMsg
    {
        if (types.len >= 1us) {
            match context.implicitEnumUnwrap (types [0]) {
                p : &PointerType => {
                    let (mapper, _) = self.validateTypeFromImplicit (alias context, templates, un.getOperand (), p.getInners ());
                    return (mapper, 1us);
                }
                c : &ClassPtrType => {
                    if (!c.isStruct ()) {
                        let (mapper, _) = self.validateTypeFromImplicit (alias context, templates, un.getOperand (), copy [c.getInner ()]);
                        return (mapper, 1us);
                    }
                }
            }
        }

        return (TemplateMapper (), 1us);
    }

    /**
     * Validate the implicit specialization of a try type expr, from 'types' using 'templates' as template parameters
     * @params:
     *    - context: the context of the validaiton
     *    - templates: the list of template to specialize
     *    - r: the try type to validate
     *    - types: the types that will be used to transform typeExpr, and templates into specialized values
     * @returns:
     *    - .0: the mapper in case of validation (used to create a valid rewriter)
     *    - .1: the number of types that were consumed during the validation
     * @throws:
     *    - &ErrorMsg: if the specialization failed
     */
    fn validateTypeFromImplicitTryExpr (self, dmut context : &Validator, templates : [&Expression], r : &TryExpr, types : [&Type])-> (TemplateMapper, usize)
        throws ErrorMsg
    {
        if (types.len >= 1us) {
            match context.implicitEnumUnwrap (types [0]) {
                rng : &OptionType => {
                    let (mapper, _) = self.validateTypeFromImplicit (alias context, templates, r.getValue (), rng.getInners ());
                    return (mapper, 1us)
                }
            }
        }

        return (TemplateMapper (), 1us);
    }

    /**
     * Validate the implicit specialization of a future type expr, from 'types' using 'templates' as template parameters
     * @params:
     *    - context: the context of the validaiton
     *    - templates: the list of template to specialize
     *    - f: the future type to validate
     *    - types: the types that will be used to transform typeExpr, and templates into specialized values
     * @returns:
     *    - .0: the mapper in case of validation (used to create a valid rewriter)
     *    - .1: the number of types that were consumed during the validation
     * @throws:
     *    - &ErrorMsg: if the specialization failed
     */
    fn validateTypeFromImplicitFutureExpr (self, dmut context : &Validator, templates : [&Expression], f : &FutureTypeExpr, types : [&Type])-> (TemplateMapper, usize)
        throws ErrorMsg
    {
        if (types.len >= 1us) {
            match context.implicitEnumUnwrap (types [0]) {
                ft : &FutureType => {
                    let (mapper, _) = self.validateTypeFromImplicit (alias context, templates, f.getReturnType (), ft.getInners ());
                    return (mapper, 1us)
                }
            }
        }

        return (TemplateMapper (), 1us);
    }

    /**
     * Validate the implicit specialization of a range type expr, from 'types' using 'templates' as template parameters
     * @params:
     *    - context: the context of the validaiton
     *    - templates: the list of template to specialize
     *    - r: the range type to validate
     *    - types: the types that will be used to transform typeExpr, and templates into specialized values
     * @returns:
     *    - .0: the mapper in case of validation (used to create a valid rewriter)
     *    - .1: the number of types that were consumed during the validation
     * @throws:
     *    - &ErrorMsg: if the specialization failed
     */
    fn validateTypeFromImplicitRangeExpr (self, dmut context : &Validator, templates : [&Expression], r : &RangeTypeExpr, types : [&Type])-> (TemplateMapper, usize)
        throws ErrorMsg
    {
        if (types.len >= 1us) {
            match context.implicitEnumUnwrap (types [0]) {
                rng : &RangeType => {
                    let (mapper, _) = self.validateTypeFromImplicit (alias context, templates, r.getType (), rng.getInners ());
                    return (mapper, 1us)
                }
            }
        }

        return (TemplateMapper (), 1us);
    }

    /**
     * Validate the implicit specialization of a type using a list expression of a slice
     * @params:
     *    - context: the context of the validaiton
     *    - templates: the list of template to specialize
     *    - lst: the list expression of slice type to validate
     *    - types: the types that will be used to transform typeExpr, and templates into specialized values
     * @returns:
     *    - .0: the mapper in case of validation (used to create a valid rewriter)
     *    - .1: the number of types that were consumed during the validation
     * @throws:
     *    - &ErrorMsg: if the specialization failed
     * */
    fn validateTypeFromImplicitSlice (self, dmut context : &Validator, templates : [&Expression], lst : &ListExpr, types : [&Type])-> (TemplateMapper, usize)
        throws ErrorMsg
    {
        if (types.len >= 1 && lst.getParameters ().len == 1) {
            match context.implicitEnumUnwrap (types [0]) {
                s : &SliceType => {
                    let (mapper, _) = self.validateTypeFromImplicit (alias context, templates, lst.getParameters ()[0], s.getInners ());
                    return (mapper, 1us);
                }
            }
        }

        return (TemplateMapper (), 1us);
    }


    /**
     * Validate the implicit specialization of a type using a list map expression of a map
     * @params:
     *    - context: the context of the validaiton
     *    - templates: the list of template to specialize
     *    - lst: the list expression of slice type to validate
     *    - types: the types that will be used to transform typeExpr, and templates into specialized values
     * @returns:
     *    - .0: the mapper in case of validation (used to create a valid rewriter)
     *    - .1: the number of types that were consumed during the validation
     * @throws:
     *    - &ErrorMsg: if the specialization failed
     * */
    fn validateTypeFromImplicitMap (self, dmut context : &Validator, templates : [&Expression], lst : &ListMapExpr, types : [&Type])-> (TemplateMapper, usize)
        throws ErrorMsg
    {
        if (types.len >= 1us && lst.getKeys ().len == 1us) {
            match context.implicitEnumUnwrap (types [0]) {
                m : &MapType => {
                    let dmut retMapper = TemplateMapper ();
                    let (mapper, _) = self.validateTypeFromImplicit (alias context, templates, lst.getKeys ()[0us], m.getInners ()[0 .. 1]);
                    retMapper:.merge (mapper);

                    let syntTemplate = TemplateRewriter (retMapper).replaceSyntaxTempl (templates);
                    let valueParam = TemplateRewriter (retMapper).rewrite (lst.getValues ()[0us]);
                    let (secondM, _) = self.validateOfVarExprFromExplicit (alias context, syntTemplate, valueParam, m.getInners ()[1 .. 2]);

                    retMapper:.merge (secondM);
                    return (retMapper, 1us);
                }
            }
        }

        return (TemplateMapper (), 1us);
    }

    /**
     * Validate the implicit specialization of a type using a list expression of a tuple
     * @params:
     *    - context: the context of the validaiton
     *    - templates: the list of template to specialize
     *    - lst: the list expression of tuple type to validate
     *    - types: the types that will be used to transform typeExpr, and templates into specialized values
     * @returns:
     *    - .0: the mapper in case of validation (used to create a valid rewriter)
     *    - .1: the number of types that were consumed during the validation
     * @throws:
     *    - &ErrorMsg: if the specialization failed
     * */
    fn validateTypeFromImplicitTuple (self, dmut context : &Validator, templates : [&Expression], lst : &ListExpr, types : [&Type])-> (TemplateMapper, usize)
        throws ErrorMsg
    {
        if (types.len >= 1us) {
            match context.implicitEnumUnwrap (types [0]) {
                t : &TupleType => {
                    if (lst.getParameters ().len > t.getInners ().len) return (TemplateMapper (), 1us);

                    let mut retMapper = TemplateMapper ();
                    let mut consumed = 0us;
                    let mut syntTemplate = templates;

                    for i in 0us .. lst.getParameters ().len {
                        let currentParam = TemplateRewriter (retMapper).rewrite (lst.getParameters ()[i]);
                        let rest = t.getInners ().len - consumed;
                        let syntaxRest = (lst.getParameters ().len - i) - 1us;

                        let consomableTypes = t.getInners ()[consumed .. consumed + (rest - syntaxRest)];
                        let (mapper, localConsumed) = self.validateTypeFromImplicit (alias context, syntTemplate, currentParam, consomableTypes);

                        retMapper:.merge (mapper);
                        consumed += cast!usize (localConsumed);
                        syntTemplate = TemplateRewriter (retMapper).replaceSyntaxTempl (syntTemplate);
                    }

                    return (retMapper, 1us);
                }
            }
        }

        return (TemplateMapper (), 1us);
    }

    /**
     * Validate the implicit specialization of a type using a function pointer type expression
     * @params:
     *    - context: the context of the validaiton
     *    - templates: the list of template to specialize
     *    - fptr: the function pointer expression of a fptr type to validate
     *    - types: the types that will be used to transform typeExpr, and templates into specialized values
     * @returns:
     *    - .0: the mapper in case of validation (used to create a valid rewriter)
     *    - .1: the number of types that were consumed during the validation
     * @throws:
     *    - &ErrorMsg: if the specialization failed
     * */
    fn validateTypeFromImplicitFptr (self, dmut context : &Validator, templates : [&Expression], fptrType : &FunctionPtrTypeExpr, types : [&Type])-> (TemplateMapper, usize)
        throws ErrorMsg
    {
        if (types.len >= 1us) {
            let (params, retType) = match context.implicitEnumUnwrap (types [0]) {
                l : &LambdaType   => { return self.validateTypeFromImplicitLambda (alias context, templates, fptrType, l); }
                d : &DelegateType => { (d.getParameters (), d.getRetType ()) }
                f : &FuncPtrType   => { (f.getParameters (), f.getRetType ()) }
                _ => {
                    return (TemplateMapper (), 1us);
                }
            };

            if (fptrType.getParameters ().len > params.len) {
                return (TemplateMapper (), 1us);
            }

            let mut consumed = 0us;
            let mut retMapper = TemplateMapper ();
            let mut syntTemplate = templates;

            for i in 0us .. fptrType.getParameters ().len {
                let v = fptrType.getParameters ()[i];
                let currentParam = TemplateRewriter (retMapper).rewrite (v.getType ());
                let rest = params.len - consumed;
                let syntaxRest = (fptrType.getParameters ().len - i) - 1us;

                let consomableTypes = params [consumed .. consumed + (rest - syntaxRest)];
                let (tiMapper, localConsumed) = self.validateTypeFromImplicit (alias context, syntTemplate, currentParam, consomableTypes);

                retMapper:.merge (tiMapper);
                consumed += cast!usize (localConsumed);
                syntTemplate = TemplateRewriter (retMapper).replaceSyntaxTempl (syntTemplate);
            }

            let retParam = TemplateRewriter (retMapper).rewrite (fptrType.getReturn ());
            let (tiMapper, _) = self.validateTypeFromImplicit (alias context, syntTemplate, retParam, copy [retType]);
            retMapper:.merge (tiMapper);

            return (retMapper, 1us);
        }

        return (TemplateMapper (), 1us);
    }

    /**
     * Validate an implicit specialization of a type using a function pointer type expression, and a lambda type
     * @params:
     *     - context: the context of the validation
     *     - templates: the list of template to specialize
     *    - fptr: the function pointer expression of a fptr type to validate
     *    - types: the types that will be used to transform typeExpr, and templates into specialized values
     * @returns:
     *    - .0: the mapper in case of validation (used to create a valid rewriter)
     *    - .1: the number of types that were consumed during the validation
     * @throws:
     *    - &ErrorMsg: if the specialization failed
     * */
    fn validateTypeFromImplicitLambda (self, dmut context : &Validator, templates : [&Expression], fptrType : &FunctionPtrTypeExpr, lmbd : &LambdaType)-> (TemplateMapper, usize)
        throws ErrorMsg
    {
        let (params, retType) = (lmbd.getParameters (), lmbd.getRetType ());
        let mut retMapper = TemplateMapper ();
        if (fptrType.getParameters ().len != params.len) {
            return (retMapper, 1us);
        }

        for i in 0us .. fptrType.getParameters ().len {
            let v = fptrType.getParameters ()[i];
            let currentParam = TemplateRewriter (retMapper).rewrite (v.getType ());
            if (params [i] !of NoneType) {
                let (mapper, _) = self.validateTypeFromImplicit (alias context, templates, currentParam, params [i .. i + 1]);
                retMapper:.merge (mapper);
            }
        }

        if (retType !of NoneType) {
            let currentParam = TemplateRewriter (retMapper).rewrite (fptrType.getReturn ());
            let (mapper, _) = self.validateTypeFromImplicit (alias context, templates, currentParam, copy [retType]);
            retMapper:.merge (mapper);
        }

        return (retMapper, 1us);
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================            COMMON            =========================
     * ================================================================================
     * ================================================================================
     */


    /**
     * Create a new expression where template specialization or correclty rewritten
     * @params:
     *     - expr: the expression to rewrite
     *     - mapper: the template specialization
     * @returns: the rewritten expr
     */
    fn performTemplateRewrite (self, expr : &Expression, mapper : TemplateMapper)-> &Expression {
        TemplateRewriter (mapper).rewrite (expr)
    }

    /**
     * Search in the list of template parameters a parameter whose name is 'name'
     * @params: 
     *    - name: the name to find
     *    - alls: the list of template params
     * @returns: an expression from 'alls' whose name is 'name' (&EmptyExpression if the expression does not exists)
     */
    fn findExpression (self, name : [c8], alls : [&Expression])-> &Expression {
        for i in alls match i {
            v : &VarExpr => {
                if v.getLoc ().str == name {
                    return v;
                }
            }
            v : &TemplateOfVarExpr => {
                if v.getLoc ().str == name {
                    return v;
                }
            }
            v : &TemplateAndExpr => {
                if v.getLoc ().str == name {
                    return v;
                }
            }
            v : &TemplateVariadicVarExpr => {
                if v.getLoc ().str == name {
                    return v;
                }
            }
            v : &TemplateVarExpr => {
                if v.getLoc ().str == name {
                    return v;
                }
            }
            v : &VarDeclExpr => {
                if v.getLoc ().str == name {
                    return v;
                }
            }
        }

        EMPTY_EXPR
    }

    /**
     * Create a type wrapper expression from 'type'
     * */
    fn createTypeWrapper (self, loc : &Word, type : &Type)-> &Expression {
        if (type.isMutable ()) {
            copy TypeWrapperExpr (loc, type.clone (0u32))
        } else {
            copy TypeWrapperExpr (loc, type)
        }
    }

}
