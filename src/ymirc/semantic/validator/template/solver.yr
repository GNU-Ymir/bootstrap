mod ymirc::semantic::validator::template::solver;

import ymirc::semantic::validator::visitor;
import ymirc::semantic::validator::template::mapper;
import ymirc::semantic::validator::template::rewrite;
import ymirc::semantic::validator::errors;
import ymirc::semantic::symbol::template;
import ymirc::syntax::declaration::protection;
import ymirc::syntax::expression::_;
import ymirc::syntax::declaration::_;

import ymirc::syntax::keys;
import ymirc::semantic::generator::_;
import ymirc::semantic::symbol::_;
import ymirc::errors::_;
import ymirc::utils::format;
import ymirc::lexing::word;

import std::collection::vec;
import std::io, std::fs::path;

/**
 * The template validator is the template responsible for template symbol validation
 */
pub class TemplateSolver {

    /**
     * Create a new empty validator
     */
    pub self () {}
    
    /**
     * ================================================================================
     * ================================================================================
     * =========================             CALL             =========================
     * ================================================================================
     * ================================================================================
     */
    
    /**
     * Validate a template call that creates a value (function for example, or aka, etc.)
     * @params: 
     *    - context: the context of the validation
     *    - loc: the location of the call
     *    - left: the value that is template called
     *    - rights: the template arguments passed to the template
     * @returns: 
     *    - .0: the value
     *    - .1: the score of the call
     * @throws:
     *    - &ErrorMsg: if the call is impossible (for example left is not a valid template)    
     */
    pub def validateCallValue (self, dmut context : &Validator, loc : &Word, left : &Value, rights : [&Generator])-> &TemplateRewriter
        throws &ErrorMsg
    {
        match left {
            x : &TemplateRefValue => {
                return self.validateCallTemplateRefValue (alias context, loc, x, rights);
            }
            z : _ => {
                throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_TEMPLATE_CALL, left, rights), notes-> [ErrorMsg::note (z.getLoc (), ""s8)]);
            }
        }
    }


    /**
     * Validate a template call that creates a value
     * @params: 
     *    - context: the context of the validation
     *    - loc: the location of the call
     *    - left: the value that is template called
     *    - rights: the template arguments passed to the template
     * @returns: 
     *    - .0: the value
     *    - .1: the score of the call
     * @throws:
     *    - &ErrorMsg: if the call is impossible
     */
    pub def validateCallTemplateRefValue (self, dmut context : &Validator, _ : &Word, left : &TemplateRefValue, rights : [&Generator])-> &TemplateRewriter
        throws &ErrorMsg
    {
        let templateParams = left.getSymbol ().getContent ().getParameters ();
        let (mapper, consumed) = self.validateFromExplicit (alias context, templateParams, rights);

        if (consumed < rights.len) {
            throw ErrorMsg::fatal (rights[consumed].getLoc (), format (ValidateErrorMessage::TEMPLATE_REST, rights[consumed .. $]), notes-> [ErrorMsg::note (left.getSymbol ().getLoc (), format (ValidateErrorMessage::VALIDATING_SYMBOL, left))]);
        } 

        TemplateRewriter::new (mapper) // return the rewriter that can then be used to finalize the syntax rewritting before semantic validation                
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================           IMPLICIT           =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a template specialization from an implicit call
     * @params: 
     *    - context: the context of the validation
     *    - loc: the location of the specialization
     *    - left: the value to specialize
     *    - rights: the list of values used for specialization
     * @returns: the template rewriter created by specialization
     * @throws:
     *    - &ErrorMsg: if the specialization failed
     */
    pub def validateImplicitValue (self, dmut context : &Validator, loc : &Word, left : &TemplateRefValue, rights : [&Value])-> &TemplateRewriter
        throws &ErrorMsg
    {
        match left.getSymbol ().getContent ().getContent () {
            f : &FunctionDecl => {
                return self.validateImplicitFunctionDecl (alias context, loc, left.getSymbol ().getContent ().getParameters (), f, rights);
            }
            x : _ => {
                println (format ("TODO : %", x));
                __pragma!panic ();
            }
        }
    }

    /**
     * Perform an implicit template specialization on a function declaration
     * @params: 
     *    - context: the context of the validation
     *    - loc: the location of the template call
     *    - templates: the list of template parameters
     *    - left: the function decl to specialize
     *    - rights: the list of values used to call the function
     * @returns: the template rewritter of the specialization
     * @throws:
     *    - &ErrorMsg: if the specialization fails
     */
    def validateImplicitFunctionDecl (self, dmut context : &Validator, loc : &Word, templates : [&Expression], left : &FunctionDecl, rights : [&Value])-> &TemplateRewriter
        throws &ErrorMsg
    {
        context;
        loc;
        templates;
        left;
        rights;
        __pragma!fake_throw (&ErrorMsg);
        __pragma!panic ();
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================           EXPLICIT           =========================
     * ================================================================================
     * ================================================================================
     */
    
    /**
     * Validate a template explicit specialization
     * @params: 
     *    - context: the context of the validation
     *    - params: the template parameters
     *    - values: the list of compile time knwon values passed to the template     
     * @returns: 
     *     - .0: a template mapper containing the template specialization
     *     - .1: the number of values that were consumed during the specialization
     * @throws: 
     *    - &ErrorMsg: if the specialization is impossible
     */
    pub def validateFromExplicit (self, dmut context : &Validator, params : [&Expression], values : [&Generator])-> (&TemplateMapper, usize)
        throws &ErrorMsg
    {
        let mut consumed = 0us;
        let dmut globalMapper = TemplateMapper::new ();
        let rewriter = TemplateRewriter::new (globalMapper);
        let mut syntTemplate = params;
        
        while (consumed < values.len && syntTemplate.len != 0us) {
            // Create a slice on template arguments that have not been used yet
            // Template arguments are used in the order they are written, but sometimes several at a time
            let currentElems = values[consumed .. $];

            // Create a slice on the template parameters that are not directly referenced
            // Only the first template parameter is explicitly set, but maybe it will also set other parameters
            let rest = syntTemplate[1us .. $]; 

            {
                // Perform the explicit template validation, with the given template parameters, and call arguments
                let (mapper, localConsumed) = self.validateParamTemplateFromExplicit (alias context, rest, syntTemplate[0], currentElems);

                globalMapper:.merge (mapper);
                consumed += localConsumed;
                syntTemplate = rewriter.replaceSyntaxTempl (syntTemplate);
            } catch {
                err : &ErrorMsg => { // TODO partial resolution note
                    throw err; 
                }
            }
        }
        
        (globalMapper, consumed)
    }

    /**
     * Validate a template parameter from an explicit call
     * @params: 
     *    - context: the context of the validation
     *    - syntTemplate: the template parameters
     *    - current: the template parameter to validate
     *    - values: the values passed to the template call
     * @returns:
     *    - .0: the mapper containing the template specialisation
     *    - .1: the number of values that were consumed
     * @throws:
     *    - &ErrorMsg: if the specialization is impossible
     */
    def validateParamTemplateFromExplicit (self, dmut context : &Validator, syntaxTemplate : [&Expression], current : &Expression, values : [&Generator])-> (&TemplateMapper, usize)
        throws &ErrorMsg
    {
        match current {
            v : &VarExpr => {
                return self.validateVarExprFromExplicit (alias context, v, values);
            }
            ov : &TemplateOfVarExpr => {
                if (ov.getKind () == TemplateOfVarType::OF || ov.getKind () == TemplateOfVarType::OVER) {
                    return self.validateOfVarExprFromExplicit (alias context, syntaxTemplate, ov, values);
                } else {
                    __pragma!panic ();
                }
            }
            _ => {
                println (format ("TODO %", current));
                __pragma!panic ();
            }
        }
    }    

    /**
     * Validate an explicit template specialization where template parameter is a simple varexpr
     * @params: 
     *    - context: the context of the validation
     *    - v: the var expression
     *    - values: the list of values passed to the template call
     * @returns:
     *    - .0: the template parameter specialization
     *    - .1: the number of consumed parameters (should be 1us)
     * @throws:
     *    - &ErrorMsg: if the values cannot be used to specialize the template parameter
     */
    def validateVarExprFromExplicit (self, dmut context : &Validator, v : &VarExpr, values : [&Generator])-> (&TemplateMapper, usize)
        throws &ErrorMsg
    {
        match values [0] {
            t : &Type => {
                context.verifyNotIsNativeType (v.getLoc ());
                let dmut mapper = TemplateMapper::new (score-> TemplateScore::VAR);
                mapper:.insert (v.getLoc ().str (), TypeWrapperExpr::new (t.getLoc (), t));
                
                return (mapper, 1us);
            }
            _ => {                  
                throw ErrorMsg::fatal (values[0].getLoc (), ValidateErrorMessage::USE_AS_TYPE,
                                       notes-> [ErrorMsg::note (v.getLoc (), ""s8)]);
            }
        }
    }


    /**
     * ================================================================================
     * ================================================================================
     * =========================       EXPLICIT OF VAR        =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate an explicit template specialization where template parameter is an of var
     * @params: 
     *    - context: the context of the validation
     *    - v: the template of var to validate
     *    - values: the list of values passed to the template call
     * @returns:
     *    - .0: the template parameter specialization
     *    - .1: the number of consumed parameters (should be 1us)
     * @throws:
     *    - &ErrorMsg: if the values cannot be used to specialize the template parameter
     */
    def validateOfVarExprFromExplicit (self, dmut context : &Validator, alls : [&Expression], v : &TemplateOfVarExpr, values : [&Generator])-> (&TemplateMapper, usize)
        throws &ErrorMsg
    {
        match values[0] {
            t : &Type => {                
                match v.getSpecialization () {
                    var : &VarExpr => {
                        return self.validateOfVarInnerExplicit (alias context, alls, v, var, t);
                    }
                    un : &UnaryExpr => {
                        return self.validateOfUnaryInnerExplicit (alias context, alls, v, un, t);
                    }
                    _ => {
                        __pragma!panic ();
                    }                    
                }
            }
            _ => {
                throw ErrorMsg::fatal (values[0].getLoc (), ValidateErrorMessage::USE_AS_TYPE,
                                       notes-> [ErrorMsg::note (v.getLoc (), ""s8)]);
            }
        }        
    }

    /**
     * Validate an explicit inner part of an of var, where the inner part is simply a VarExpr (A of T)
     * @params: 
     *    - context: the context of the validation
     *    - alls: the list of template parameters that are not validated yet
     *    - ofV: the template of var to validate
     *    - v: the inner part of the ofvar (=> ofV.getInner ())
     *    - values: the list of values passed to the template call
     * @returns:
     *    - .0: the template parameter specialization
     *    - .1: the number of consumed parameters (should be 1us)
     * @throws:
     *    - &ErrorMsg: if the values cannot be used to specialize the template parameter
     */
    def validateOfVarInnerExplicit (self, dmut context : &Validator, alls : [&Expression], ofV : &TemplateOfVarExpr, v : &VarExpr, type : &Type)-> (&TemplateMapper, usize)
        throws &ErrorMsg
    {
        let dmut retMapper = TemplateMapper::new (score-> TemplateScore::VAR);
        
        // Search the inner value (A of T => search T in the parameters)
        let expr = self.findExpression (v.getLoc ().str (), alls);
        if !expr.isOf!{&EmptyExpression} () {

            let (mapper, _) = self.validateParamTemplateFromExplicit (alias context, alls, expr, [cast!(&Generator) (type)]);
            retMapper:.merge (mapper);
        }

        // Complete the type, and verify that it is correctly set, maybe for function ptr this will not work (thus TODO)
        let finalType = self.performTemplateRewrite (v, retMapper);
        let ofType = context:.validateType (finalType);
        if (ofV.getKind () == TemplateOfVarType::OVER) {
            context:.verifyAncestor (v.getLoc (), ofType, type);
        } else {
            context:.verifyCompatibleType (v.getLoc (), type.getLoc (), ofType, type);
        }

        retMapper:.insert (ofV.getLoc ().str (), TypeWrapperExpr::new (type.getLoc (), type));
        return (retMapper, 1us);
    }

    
    /**
     * Validate an explicit inner part of an of var, where the inner part is a UnaryExpr (A of &T)
     * @params: 
     *    - context: the context of the validation
     *    - alls: the list of template parameters that are not validated yet
     *    - ofV: the of var expression
     *    - un: the unary expression (=> ofV.getInner ())
     *    - values: the list of values passed to the template call
     * @returns: 
     *    - .0: the template parameter specialization
     *    - .1: the number of consumed parameters (should be 1us)
     * @throws:
     *    - &ErrorMsg: if the specialization failed
     */
    def validateOfUnaryInnerExplicit (self, dmut context : &Validator, alls : [&Expression], ofV : &TemplateOfVarExpr, un : &UnaryExpr, type : &Type)-> (&TemplateMapper, usize)
        throws &ErrorMsg
    {
        let dmut retMapper = TemplateMapper::new (score-> TemplateScore::VAR);
        
        match un.getOperand () {
            var : &VarExpr => {                
                let expr = self.findExpression (var.getLoc ().str (), alls);                
                if !expr.isOf!{&EmptyExpression} () {                    
                    // Unary are generaly &X, that can be either a pointer or a classptr type
                    let inner = match type {
                        cl : &ClassPtrType => { cl.getInner () }
                        ct : &CompoundType => {
                            if (ct.getInners ().len == 1us) {
                                ct.getInners ()[0us]
                            } else {
                                throw ErrorMsg::fatal (un.getLoc (), format (ValidateErrorMessage::TEMPLATE_SPECIALIZATION_FAILS, un, type));
                            }
                        }
                        _ => {
                            throw ErrorMsg::fatal (un.getLoc (), format (ValidateErrorMessage::TEMPLATE_SPECIALIZATION_FAILS, un, type));
                        }
                    };

                    let (mapper, _) = self.validateParamTemplateFromExplicit (alias context, alls, expr, [inner]);
                    retMapper:.merge (mapper);                    
                }
            }
        }

        // Complete the type, and verify that it is correctly set, maybe for function ptr this will not work (thus TODO)
        let finalType = self.performTemplateRewrite (un, retMapper);
        let ofType = context:.validateType (finalType);
        if (ofV.getKind () == TemplateOfVarType::OVER) {
            context:.verifyAncestor (un.getLoc (), ofType, type);
        } else {
            context:.verifyCompatibleType (un.getLoc (), type.getLoc (), ofType, type);
        }

        retMapper:.insert (ofV.getLoc ().str (), TypeWrapperExpr::new (type.getLoc (), type));
        return (retMapper, 1us);
    }
    

    /**
     * ================================================================================
     * ================================================================================
     * =========================            COMMON            =========================
     * ================================================================================
     * ================================================================================
     */


    /**
     * Create a new expression where template specialization or correclty rewritten
     * @params:
     *     - expr: the expression to rewrite
     *     - mapper: the template specialization
     * @returns: the rewritten expr
     */
    def performTemplateRewrite (self, expr : &Expression, mapper : &TemplateMapper)-> &Expression {    
        TemplateRewriter::new (mapper).rewrite (expr)
    }

    /**
     * Search in the list of template parameters a parameter whose name is 'name'
     * @params: 
     *    - name: the name to find
     *    - alls: the list of template params
     * @returns: an expression from 'alls' whose name is 'name' (&EmptyExpression if the expression does not exists)
     */
    def findExpression (self, name : [c8], alls : [&Expression])-> &Expression {   
        for i in alls match i {
            v : &VarExpr => {
                if v.getLoc ().str () == name {
                    return v;
                }
            }
            v : &TemplateOfVarExpr => {
                if v.getLoc ().str () == name {
                    return v;
                }
            }
            v : &TemplateVariadicVarExpr => {
                if v.getLoc ().str () == name {
                    return v;
                }
            }
            v : &TemplateVarExpr => {
                if v.getLoc ().str () == name {
                    return v;
                }
            }
        }


        EmptyExpression::new ()
    }
    
    
}
