in mapper;

use std::stream;
use ymirc::syntax::expression::_;
use ymirc::errors::_;
use ymirc::utils::format;

pub enum
| VAR = 1u32
| TYPE = 2u32
| VALUE = 3u32
 -> TemplateScore;

/**
 * The template mapper class is a class containing a validation of a template specialization
 * It is constructed by a template resolution, and used to perform the rewrite of the template symbol into another symbol
 */
pub record TemplateMapper {

    // The score of the specialization
    let mut _score : u32 = 0u32;

    // The association between identifier to expression rewritte
    let mut _mapping : [[c8] => mut &Expression] = [];

    // The order of the name (order of the _mapping map, that has no guaranteed order)
    let mut _nameOrder : [mut [c8]] = [];

    // The list of templates that are mutable
    let mut _mutable : [[c8] => ()] = [];

    // The list of templates that are deeply mutable
    let mut _deeplyMutable : [[c8] => ()] = [];

    /**
     * Create an empty mapper
     */
    pub self (score : u32 = 0u32)
        with _score = score
    {}

    /*!
     * ================================================================================
     * ================================================================================
     * =========================           GETTERS            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * @returns: the score of the mapper
     */
    pub fn getScore (self)-> u32 {
        self._score
    }

    /**
     * @returns: the list of mapping association (name to syntax expression)
     */
    pub fn getMapping (self)-> [[c8] => &Expression] {
        self._mapping
    }

    /**
     * @returns: the name order of the templates
     * */
    pub fn getNameOrder (self)-> [[c8]] {
        self._nameOrder
    }

    /**
     * @returns: the list of mapper sorted by name order
     * */
    pub fn getMapperSorted (self)-> [&Expression] {
        let mut vec : [mut &Expression] = [];
        for i in self._nameOrder match self._mapping [i]? {
            Ok (x) => { vec ~= [x]; }
        }

        vec
    }

    pub fn getMutables (self)-> [[c8] => ()] {
        self._mutable
    }

    pub fn getDeeplyMutables (self)-> [[c8] => ()] {
        self._deeplyMutable
    }

    pub fn hasValidated (self, name : [c8])-> bool {
        name in self._mapping
    }
    
    /*!
     * ================================================================================
     * ================================================================================
     * =========================           SETTERS            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Insert a new template specialization in the mapper
     * @params: 
     *    - name: the name of the specialization
     *    - expr: the associated expr
     */
    pub fn insert (mut self, name : [c8], expr : &Expression, mutable : bool = false, deeplyMut : bool = false) {
        self._nameOrder ~= [name];
        self._mapping [name] = expr;

        if (deeplyMut) self._deeplyMutable [name] = ();
        else if (mutable) self._mutable [name] = ();
    }

    /**
     * Remove a template mapper name from the mapper
     * @params:
     *    - name: the mapper to remove
     * */
    pub fn remove (mut self, name : [c8]) {
        if name in self._mapping {
            self._mapping:.remove (name);
            self._mutable:.remove (name);
            self._deeplyMutable:.remove (name);

            let mut order : [mut [c8]] = [];
            for j in self._nameOrder {
                if j != name { order ~= [j]; }
            }

            self._nameOrder = order;
        }
    }

    /**
     * Add some score to the template mapper
     * */
    pub fn addScore (mut self, score : u32) {
        self._score += score;
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================          OPERATION           =========================
     * ================================================================================
     * ================================================================================
     */

    
    /**
     * Merge the template mapper with another template mapper
     * @params:
     *    - other: the other mapper that will include information in self
     *    - replace: true iif replace association when key is already in self
     * @returns: self
     */
    pub fn merge (mut self, other : TemplateMapper, replace : bool = false)-> TemplateMapper {
        for i in other._nameOrder {
            let insert = if (i in self._mapping) { replace } else { true };

            if (insert) {
                if let Ok (v) = other._mapping [i]? {
                    self._nameOrder ~= [i];
                    self._mapping [i] = v;
                } else panic;

                if (i in other._mutable) self._mutable [i] = ();
                if (i in other._deeplyMutable) self._deeplyMutable [i] = ();
            };
        }

        self._score += other._score;
        self
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================          COMPARISON          =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * @returns: true iif self and other are strictly equivalent
     */
    pub fn opEquals (self, other : TemplateMapper)-> bool {
        if (self._nameOrder.len != other._nameOrder.len) return false;
        if (self._mapping.len   != other._mapping.len) return false;

        for i in self._nameOrder {
            match (self._mapping [i]?, other._mapping [i]?) {
                (Ok (x), Ok (y)) => {
                    if (x != y) return false;
                }
                _ => { return false; }
            }
        }

        true
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================             MISC             =========================
     * ================================================================================
     * ================================================================================
     */

    impl Streamable;
    impl Formattable {
        pub over format (self, dmut stream : &Formatter) {
            stream:.write ('{');
            let mut z = 0us;
            for i in self._nameOrder {
                match self._mapping [i]? {
                    Ok (x) => {
                        if (z != 0) stream:.write (", ");
                        if (i in self._mutable) stream:.write ("mut ");
                        else if (i in self._deeplyMutable) stream:.write ("dmut ");

                        stream:.write (i, "=> ", x);
                        z += 1us;
                    }
                }
            }
            stream:.write ('}');
        }
    }

    /**
     * @returns: the mapper into a string (with less information than using format)
     */
    pub fn simpleFormat (self)-> [c8] {
        let dmut stream = Formatter::new ();
        stream:.write ('{');
        let mut z = 0us;
        for i in self._nameOrder {
            match self._mapping [i]? {
                Ok (x) => {
                    if (z != 0) stream:.write (", ");
                    if (i in self._mutable) stream:.write ("mut ");
                    else if (i in self._deeplyMutable) stream:.write ("dmut ");

                    stream:.write (x);
                    z += 1us;
                }
            }
        }
        stream:.write ('}');
        stream[]
    }
    
}
