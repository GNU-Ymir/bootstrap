mod ymirc::semantic::validator::literal;

import ymirc::semantic::validator::visitor;
import ymirc::semantic::validator::errors;
import ymirc::syntax::declaration::protection;
import ymirc::syntax::expression::_;
import ymirc::syntax::declaration::_;
import ymirc::semantic::symbol::_;
import ymirc::semantic::declarator::visitor;
import ymirc::semantic::validator::utf;


import ymirc::semantic::generator::_;
import ymirc::errors::_;
import ymirc::utils::format;
import ymirc::lexing::word;
import ymirc::syntax::keys;
import ymirc::lexing::tokens;


import std::collection::set;
import std::collection::vec;
import std::io, std::fs::path;

/**
 * The literal validator is the class responsible for literal expression validation
 */
pub class LiteralValidator {

    /// The visitor used to validate literal strings
    let _utfVisitor = UtfVisitor::new ();
    
    /**
     * Create a new empty validator
     */
    pub self () {}    

    
    /**
     * Validate a literal expression
     * @params: 
     *  - context: the context of the validation
     *  - lit: the literal to validate
     * @throws: &ErrorMsg, if the validation failed
     * @returns: a value
     */
    pub def validate (self, dmut context : &Validator, lit : &LiteralExpr)-> &Value
        throws &ErrorMsg
    {
        match lit {
            b : &BoolExpr => return self.validateBool (alias context, b);
            n : &NullExpr => return self.validateNull (alias context, n);
            d : &DollarExpr => return self.validateDollar (alias context, d);
            i : &IgnoreExpr => return self.validateIgnore (alias context, i);
            u : &UnitExpr => return self.validateUnit (alias context, u);
            f : &FixedExpr => return self.validateInt (alias context, f);
            f : &FloatExpr => return self.validateFloat (alias context, f);
            c : &CharExpr => return self.validateChar (alias context, c);
            s : &StringExpr => return self.validateString (alias context, s);
            v : &VarExpr => return self.validateVar (alias context, v);
            _ => {
                println ("Unknown literal : ", lit::typeinfo.name);
                __pragma!panic ();
            }
        }
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================           SIMPLES            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * @params: 
     *   - _ : the context of the validation
     *   - b: the bool expression to validate
     * @returns: a bool value
     */
    def validateBool (self, dmut _ : &Validator, b : &BoolExpr)-> &Value {
        BoolValue::new (b.getLoc (), b.getLoc () == Keys::TRUE)
    }


    /**
     * @params:
     *   - _: the context of the validation
     *   - n: the null expr to validate
     * @returns: a null value
     */
    def validateNull (self, dmut _ : &Validator, n : &NullExpr)-> &Value {
        NullValue::new (n.getLoc ())
    }

    /**
     * @params: 
     *   - _: the context of the validation
     *   - u: the unit expression to validate
     * @returns: a unit value
     */
    def validateUnit (self, dmut _ : &Validator, u : &UnitExpr)-> &Value {
        UnitValue::new (loc-> u.getLoc ())
    }

    /**
     * @params: 
     *   - _: the context of the validation
     *   - i: the ignore expression to validate
     * @returns: a unit value
     */
    def validateIgnore (self, dmut _ : &Validator, i : &IgnoreExpr)-> &Value {
        UnitValue::new (loc-> i.getLoc ())
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================            DOLLAR            =========================
     * ================================================================================
     * ================================================================================
     */

    
    /**
     * Validate a dollar expression
     * @params:
     *   - context: the context of the validation
     *   - d: the dollar expression
     * @returns: a value
     * @throws: &ErrorMsg if we are not in a dollar context
     */
    def validateDollar (self, dmut context : &Validator, d : &DollarExpr)-> &Value
        throws &ErrorMsg
    {
        context;
        d;
        __pragma!fake_throw (&ErrorMsg);
        __pragma!panic ();
    }


    /**
     * ================================================================================
     * ================================================================================
     * =========================         FLOAT / INT          =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * @params:
     *   - _: the context of the validation
     *   - f: the expression to validate
     * @returns: a float value
     */
    def validateFloat (self, dmut _ : &Validator, f : &FloatExpr)-> &Value
        throws &ErrorMsg
    {
        import std::conv;
        
        let dmut stream = StringStream::new ();
        self.removeUnders (f.getPrePart ().str (), alias stream, default-> "0"s8);
        stream:.write ('.'c8);
        self.removeUnders (f.getDecPart ().str (), alias stream, default-> "0"s8);

        {
            if (f.getSuffix () == FloatSuffixes::FLOAT) {
                FloatValue::new (f.getLoc (), 
                                 FloatType::new (f.getLoc (), size-> 32u16),
                                 f-> stream[].to!f32 ())
            } else {
                FloatValue::new  (f.getLoc (), 
                                  FloatType::new (f.getLoc (), size-> 64u16),
                                  d-> stream[].to!f64 ())
            }
        } catch {
            _ : &CastFailure => {
                throw ErrorMsg::fatal (f.getLoc (), format (ValidateErrorMessage::MALFORMED_FLOAT_LITERAL, stream[]));
            }
        }
        
    }

    /**
     * @params:
     *   - _: the context of the validation
     *   - f: the expression to validate
     * @returns: a int value
     */
    def validateInt (self, dmut _ : &Validator, f : &FixedExpr)-> &Value
        throws &ErrorMsg
    {
        import std::conv;
        
        let dmut stream = StringStream::new ();
        self.removeUnders (f.getLoc ().str (), alias stream, default-> "0"s8);

        let type = match f.getSuffix ().str () {
            FixedSuffixes::U8 => { IntType::new (f.getLoc (), size-> 8u16, signed-> false) }
            FixedSuffixes::U16 => { IntType::new (f.getLoc (), size-> 16u16, signed-> false) }
            FixedSuffixes::U32 => { IntType::new (f.getLoc (), size-> 32u16, signed-> false) }
            FixedSuffixes::U64 => { IntType::new (f.getLoc (), size-> 64u16, signed-> false) }
            FixedSuffixes::USIZE => { IntType::new (f.getLoc (), size-> 0u16, signed-> false) }
            FixedSuffixes::I8 => { IntType::new (f.getLoc (), size-> 8u16, signed-> true) }
            FixedSuffixes::I16 => { IntType::new (f.getLoc (), size-> 16u16, signed-> true) }
            FixedSuffixes::I64 => { IntType::new (f.getLoc (), size-> 64u16, signed-> true) }
            FixedSuffixes::ISIZE => { IntType::new (f.getLoc (), size-> 0u16, signed-> true) }
            _ => { IntType::new (f.getLoc (), size-> 32u16, signed-> true) }                
        };

        {
            if (stream[].len > 2us && stream[][0us .. 2us] == "0x"s8) {
                IntValue::new (f.getLoc (), type, stream[].to!{usize, "x"} ())
            } else if (stream[].len > 2us && stream[][0us .. 2us] == "0b"s8) {
                IntValue::new (f.getLoc (), type, stream[].to!{usize, "b"} ())
            } else if (stream[].len > 2us && stream[][0us .. 2us] == "0o"s8) {
                IntValue::new (f.getLoc (), type, stream[].to!{usize, "o"} ())
            } else {
                IntValue::new (f.getLoc (), type, stream[].to!{usize} ())
            }
        } catch {
            _ : &CastFailure => {
                throw ErrorMsg::fatal (f.getLoc (), format (ValidateErrorMessage::MALFORMED_INT_LITERAL, stream[]));
            } 
        }
    }
    
    /**
     * Write a string literal into the stream, except the '_'
     * @params: 
     *    - str: the string value to write
     *    - stream: the stream to fill
     *    - default: the value to write in the stream if nothing was printed from str
     */
    def removeUnders (self, str : [c8], dmut stream : &StringStream, default : [c8] = ""s8) {
        let mut wrote = false;
        for i in str {
            if (i != '_'c8) {
                wrote = true;
                stream:.write (i);
            }
        }

        if (!wrote) stream:.write (default);
    }


    /**
     * ================================================================================
     * ================================================================================
     * =========================        CHAR / STRING         =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * @params: 
     *   - _: the context of the validation
     *   - c: the char to validate
     * @throws: &ErrorMsg if the char is malformed
     * @returns: a char value
     */
    def validateChar (self, dmut _ : &Validator, c : &CharExpr)-> &Value
        throws &ErrorMsg
    {
        let inner : &Type = if (c.getSuffix () == CharSuffixes::UTF8) {
            CharType::new (c.getLoc (), size-> 8u16)
        } else {
            CharType::new (c.getLoc (), size-> 32u16)
        };

        let (value_c8, value_c32, len) = if (c.getSuffix () == CharSuffixes::UTF8) {
            let (v, l) = self._utfVisitor.convertUtf8 (c.getLoc (), c.getSequence ());
            (v, "\u{0}", l)
        } else {
            let (v, l) = self._utfVisitor.convertUtf32 (c.getLoc (), c.getSequence ());
            ("\u{0}"s8, v, l)
        };

        if (len != 1us) {
            throw ErrorMsg::fatal (c.getLoc (), format (ValidateErrorMessage::MALFORMED_CHAR, inner, len));
        }

        CharValue::new (c.getLoc (), inner, c8Val-> value_c8[0], c32Val-> value_c32[0])
    }

    /**
     * @params: 
     *   - _: the context of the validation
     *   - s: the string to validate
     * @throws: &ErrorMsg if the string is malformed
     * @returns: a string value
     */
    def validateString (self, dmut _ : &Validator, s : &StringExpr)-> &Value
        throws &ErrorMsg
    {
        let inner : &Type = if (s.getSuffix () == StringSuffixes::UTF8) {
            CharType::new (s.getLoc (), size-> 8u16)
        } else {
            CharType::new (s.getLoc (), size-> 32u16)
        };

        let (value_c8, value_c32, len) = if (s.getSuffix () == StringSuffixes::UTF8) {
            let (v, l) = self._utfVisitor.convertUtf8 (s.getLoc (), s.getSequence ());
            (v, "", l)
        } else {
            let (v, l) = self._utfVisitor.convertUtf32 (s.getLoc (), s.getSequence ());
            (""s8, v, l)
        };
        
        let arrType = ArrayType::new (s.getLoc (), inner, size-> int::usize (s.getLoc (), len), isMutable-> true);
        let slcType = SliceType::new (s.getLoc (), inner, isMutable-> true);

        AliaserValue::new (
            s.getLoc (),
            slcType,
            StringValue::new (s.getLoc (), arrType, c8Val-> value_c8, c32Val-> value_c32, len)) 
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================             VAR              =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * @params: 
     *   - context: the context of the validation
     *   - v: the var to validate
     * @throws: &ErrorMsg if the var is not found
     * @returns: a value
     */
    def validateVar (self, dmut context : &Validator, v : &VarExpr)-> &Value
        throws &ErrorMsg
    {
        let value = context:.getLocal (v.getLoc ().str ());
        match value {
            NoneValue () => return self.validateVarGlobal (alias context, v);
            protoV : &ProtoVarValue => {
                return VarRefValue::new (v.getLoc (), protoV.getLoc (), protoV.getType (), protoV.isMutable (), protoV.getUniqId (), isSelf-> protoV.isSelf ());
            }
            vdecl : &VarDeclValue => {
                match vdecl.getType () {
                    LambdaType () => {
                        return VarRefValue::new (v.getLoc (), vdecl.getLoc (), vdecl.getType (), value-> vdecl.getValue (), vdecl.isMutable (), vdecl.getUniqId (), isSelf-> false);
                    }
                    _ => {
                        return VarRefValue::new (v.getLoc (), vdecl.getLoc (), vdecl.getType (), vdecl.isMutable (), vdecl.getUniqId (), isSelf-> false);
                    }
                }
            }
            s : &StructFieldAccessValue => { // Closure
                return s;
            }
            _ => {
                println ("Unknown var type : ", value::typeinfo.name);
                __pragma!panic ();
            }
        }
    } 
     
    
    /**
     * Validate a var reference that was not found locally, and then must be searched in global symbols
     * @params: 
     *     - context: the context of the validation
     *     - v: the variable to search
     * @returns: a value containing the references to the global variable (multsym is possible)
     * @throws: &ErrorMsg, the variable refers to nothing
     */
    def validateVarGlobal (self, dmut context : &Validator, v : &VarExpr)-> &Value
        throws &ErrorMsg
    {
        let dmut syms = context:.getGlobal (v.getLoc ().str ());
        if (syms.len == 0us) {
            throw context:.createGlobalVarError (v.getLoc (), v.getLoc ().str ());
        } else {
            { 
                return self.validateMultSymbols (v.getLoc (), alias context, alias syms);
            } catch {
                err : &ErrorMsg => throw ErrorMsg::fatal (v.getLoc (), format (ValidateErrorMessage::UNDEF_VAR, v.getLoc ().str ()), notes-> [err]);        
            }
        }
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================          MULT SYMS           =========================
     * ================================================================================
     * ================================================================================
     */
    
    /**
     * Transform symbol references into a single value
     * @params:
     *   - loc: the location of the symbol ref
     *   - context: the context of the validation
     *   - syms: the list of symbols
     * @returns: a value containing multiple symbols (&MultSymValue), or a single one (&Value)
     * @throws: 
     *   - &ErrorMsg: if the transformation fails
     */
    pub def validateMultSymbols (self, loc : &Word, dmut context : &Validator, dmut syms : [&Symbol])-> &Value
        throws &ErrorMsg
    {
        let dmut res = Vec!{&Value}::new ();
        let dmut errors = Vec!{&ErrorMsg}::new ();
        let dmut typeErrors = Vec!{&ErrorMsg}::new ();
        for i in 0us .. syms.len {
            {
                context:.pushReferent (alias syms [i]);
                match ref syms [i] {
                    dmut f : &FunctionSymbol => {
                        if (!f.isMethod ()) 
                            res:.push (context:.getFunctionValidator ().validateFuncPrototype (alias context, alias f));
                    }
                    c : &ConstructorSymbol => {
                        typeErrors:.push (ErrorMsg::fatal (c.getLoc (), format (ValidateErrorMessage::USE_AS_VALUE, c)));
                    }
                    m : &ModuleSymbol => {
                        res:.push (ModuleRefValue::new (loc, m));
                    }
                    dmut a : &AkaSymbol => { // Aka are sometimes types, there is a special function to handle that
                        self.validateAkaSymbolMultSym (loc, alias context, alias a, alias res, alias typeErrors);
                    }
                    dmut t : &TemplateSymbol => { // Templates are sometimes types, there is a special function to handle that
                        self.validateTemplateSymbolMultSym (loc, alias context, alias t, alias res, alias typeErrors);
                    }
                    dmut c : &ClassSymbol => { // class are types
                        {
                            let type = context:.getClassValidator ():.validate (alias context, alias c, inModule-> false);
                            typeErrors:.push (ErrorMsg::fatal (loc, format (ValidateErrorMessage::USE_AS_VALUE, type)));
                        } catch { err : &ErrorMsg => { typeErrors:.push (err); } }
                    } 
                    dmut s : &StructSymbol => { // struct are also types
                        {
                            let type = context:.getStructValidator ().validate (alias context, alias s);
                            typeErrors:.push (ErrorMsg::fatal (loc, format (ValidateErrorMessage::USE_AS_VALUE, type)));
                        } catch { err : &ErrorMsg => { typeErrors:.push (err); } }
                    } 
                    dmut tr : &TraitSymbol => { // Traits are also types
                        {
                            let type = context:.getTraitValidator ().validate (alias context, alias tr);
                            typeErrors:.push (ErrorMsg::fatal (loc, format (ValidateErrorMessage::USE_AS_VALUE, type)));
                        } catch { err : &ErrorMsg => { typeErrors:.push (err); } }
                    } 
                    _ => {
                        println ("TODO : ", (syms [i])::typeinfo.name);
                        __pragma!panic ();
                    }
                }
            } exit {
                context:.popReferent ();
            } catch {
                err : &ErrorMsg => {
                    errors:.push (err);
                }
            }
        }

        // There are errors in value validation
        if (errors.len () != 0us) throw ErrorMsg::list (errors[]);

        if (res.len () == 1us) { 
            res[][0us]
        } else {
            if (res.len () == 0us) { // There are no values
                if (typeErrors.len () != 0us) throw ErrorMsg::list (typeErrors[]); // It has to be because of type error
                else  __pragma!panic ();                
            }
            
            cast!{&Value} (MultSymValue::new (loc, res[], prettyStr-> loc.str ()))
        }
    }

    /**
     * Aka symbol may refer to types, or to values
     * In order to show the correct error, we should try both validation
     * @params: 
     *   - loc: the location of the symbol reference
     *   - context: the context of the validation
     *   - sym: the symbol to validate
     * @throws: 
     *   - &ErrorMsg: if the aka is malformed (but not a type)
     * @returns: 
     *   - res: add the value to the vec
     *   - typeErrors: add an error, if the aka is a type (but not malformed)
     */
    def validateAkaSymbolMultSym (self, loc : &Word, dmut context : &Validator, dmut sym : &AkaSymbol, dmut res : &Vec!{&Value}, dmut typeErrors : &Vec!{&ErrorMsg})
        throws &ErrorMsg
    {
        {
            res:.push (context:.getAkaValidator ().validateValue (alias context, alias sym));
        } catch {
            err : &ErrorMsg => { // There are two possibilities 
                {
                    let type = context:.getAkaValidator ().validateType (alias context, alias sym); // 1) its a type
                    typeErrors:.push (ErrorMsg::fatal (loc, format (ValidateErrorMessage::USE_AS_VALUE, type))); // Then we add no value, but add an error in typeErrors
                } catch { // 2) it is just malformed
                    _ => throw err;
                }
            }
        }
    }

    /**
     * Template symbol may refer to types, or to values
     * In order to show the correct error, we should try both validation
     * @params: 
     *   - loc: the location of the symbol reference
     *   - context: the context of the validation
     *   - sym: the symbol to validate
     * @throws: 
     *   - &ErrorMsg: if the template is malformed (but not a type)
     * @returns: 
     *   - res: add the value to the vec
     *   - typeErrors: add an error, if the template is a type (but not malformed)
     */
    def validateTemplateSymbolMultSym (self, loc : &Word, dmut context : &Validator, dmut sym : &TemplateSymbol, dmut res : &Vec!{&Value}, dmut typeErrors : &Vec!{&ErrorMsg})
        throws &ErrorMsg
    {
        {
            res:.push (context:.getTemplateValidator ().validateValue (alias context, alias sym));
        } catch {
            err : &ErrorMsg => { // There are two possibilities 
                {
                    let type = context:.getTemplateValidator ().validateType (alias context, alias sym); // 1) its a type
                    typeErrors:.push (ErrorMsg::fatal (loc, format (ValidateErrorMessage::USE_AS_VALUE, type))); // Then we add no value, but add an error in typeErrors
                } catch { // 2) it is just malformed
                    _ => throw err;
                }
            }
        }
    }
}
