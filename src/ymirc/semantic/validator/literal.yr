in literal;

use ymirc::semantic::validator::{errors, visitor, utf};
use ymirc::syntax::{_,
                    declaration::_,
                    expression::{_, literal::_, macro_::_, operator::_, template::_}};

use ymirc::semantic::{generator::_, symbol::_, declarator::visitor};

use ymirc::global::core_;
use ymirc::errors::_;
use ymirc::utils::{format, bigint, bigfloat};
use ymirc::lexing::{word, tokens};
use ymirc::syntax::keys;
use std::{stream, io};

use ymirc::semantic::generator::type::{_,
                                       custom::_,
                                       native::{_, scalar::_, compound::_},
                                       temporary::_};

use ymirc::semantic::generator::value::{_,
                                        construct::{_, delegate::_},
                                        literal::_,
                                        memory::_,
                                        operator::{_, binary::_, call::_, fields::_, map::_, slice::_, unary::_},
                                        operator::map::iteration::_,
                                        prototypes::_,
                                        scope::_,
                                        syntax::_,
                                        template::_};

/**
 * The literal validator is the class responsible for literal expression validation
 */
pub record LiteralValidator {

    /**
     * Create a new empty validator
     */
    pub self () {}
    
    /**
     * Validate a literal expression
     * @params: 
     *  - context: the context of the validation
     *  - lit: the literal to validate
     * @throws: &ErrorMsg, if the validation failed
     * @returns: a value
     */
    pub fn validate (self, dmut context : &Validator, lit : &Expression)-> &Value
        throws ErrorMsg
    {
        match lit {
            b : &BoolExpr           => return self.validateBool (alias context, b);
            n : &NullExpr           => return self.validateNull (alias context, n);
            n : &NoneExpr           => return self.validateNone (alias context, n);
            d : &DollarExpr         => return self.validateDollar (alias context, d);
            i : &IgnoreExpr         => return self.validateIgnore (alias context, i);
            u : &EmptyExpression    => return self.validateUnit (alias context, u);
            f : &FixedExpr          => return self.validateInt (alias context, f);
            f : &FloatExpr          => return self.validateFloat (alias context, f);
            c : &CharExpr           => return self.validateChar (alias context, c);
            s : &StringExpr         => return self.validateString (alias context, s);
            v : &VarExpr            => return self.validateVar (alias context, v);
            l : &ListExpr           => return self.validateList (alias context, l);
            m : &ListMapExpr        => return self.validateListMap (alias context, m);
            s : &SliceAllocatorExpr => return self.validateSliceAllocator (alias context, s);
            _ => {
                throw copy ErrorMsg::fatal (lit.getLoc (), format (ValidateErrorMessage::USE_AS_VALUE));
            }
        }
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================           SIMPLES            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * @params: 
     *   - _ : the context of the validation
     *   - b: the bool expression to validate
     * @returns: a bool value
     */
    fn validateBool (self, dmut _ : &Validator, b : &BoolExpr)-> &Value {
        copy BoolValue (b.getLoc (), b.getLoc () == Keys::TRUE)
    }


    /**
     * @params:
     *   - _: the context of the validation
     *   - n: the null expr to validate
     * @returns: a null value
     */
    fn validateNull (self, dmut _ : &Validator, n : &NullExpr)-> &Value {
        copy NullValue (n.getLoc ())
    }

    /**
     * @params:
     *    - _: the context of the validation
     *    - n: the none expression to validate
     * */
    fn validateNone (self, dmut _ : &Validator, n : &NoneExpr)-> &Value {
        copy ErrOptionValue (n.getLoc ())
    }

    /**
     * @params: 
     *   - _: the context of the validation
     *   - u: the unit expression to validate
     * @returns: a unit value
     */
    fn validateUnit (self, dmut _ : &Validator, u : &EmptyExpression)-> &Value {
        copy UnitValue (loc-> u.getLoc ())
    }

    /**
     * @params: 
     *   - _: the context of the validation
     *   - i: the ignore expression to validate
     * @returns: a unit value
     */
    fn validateIgnore (self, dmut _ : &Validator, i : &IgnoreExpr)-> &Value {
        copy UnitValue (loc-> i.getLoc ())
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================            DOLLAR            =========================
     * ================================================================================
     * ================================================================================
     */

    
    /**
     * Validate a dollar expression
     * @params:
     *   - context: the context of the validation
     *   - d: the dollar expression
     * @returns: a value
     * @throws: &ErrorMsg if we are not in a dollar context
     */
    fn validateDollar (self, dmut context : &Validator, d : &DollarExpr)-> &Value
        throws ErrorMsg
    {
        match context.getCurrentDollarContext () {
            Ok (val : &Value) => {
                self.validateDollarValue (alias context, d.getLoc (), val)
            }
            _ => throw copy ErrorMsg::fatal (d.getLoc (), ValidateErrorMessage::DOLLAR_OUTSIDE_CONTEXT);
        }
    }

    /**
     * Validate a dollar operator on a value
     * @params:
     *    - context: the context of the validation
     *    - loc: the location of the dollar operator
     *    - val: the value that is opDollar accessed
     * @returns: the result of opDollar on the value
     * @throws:
     *    - &ErrorMsg: if the value cannot be opDollared
     */
    fn validateDollarValue (self, dmut context : &Validator, loc : &Word, val : &Value)-> &Value
        throws ErrorMsg
    {
        match val.getType () {
            _ : &SliceType => {
                let sizeType = copy IntType (loc, size-> 0u16, signed-> false);
                copy StructFieldAccessValue (loc, sizeType, val, SliceKeys::LEN)
            }
            array : &ArrayType => {
                makeIntValue (loc, array.getLen ())
            }
            t : &TupleType => {
                makeIntValue (loc, t.getInners ().len)
            }
            c : &ClassPtrType => {
                self.validateOpDollarClass (alias context, loc, c, val)
            }
            _ => throw copy ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_DOLLAR_OP, val.getType ()));
        }
    }

    /**
     * Validate the dollar operator on a class value
     * @params:
     *    - context: the context of the validation
     *    - loc: the location of the opDollar
     *    - cptr: the class type
     *    - val: the value being accessed
     * @returns: the call to the opDollar method
     * @throws:
     *    - &ErrorMsg: if the call is not valid
     * */
    pub fn validateOpDollarClass (self, dmut context : &Validator, loc : &Word, cptr : &ClassPtrType, val : &Value)-> &Value
        throws ErrorMsg
    {
        {
            let acc = context:.constructObjectMethodAcc (loc, cptr, val, OpOverrideNames::DOLLAR);
            return context:.getCallOpValidator ().validate (alias context, loc, acc, []);
        } catch {
            err : &ErrorMsg => {
                throw copy ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_DOLLAR_OP, cptr),
                                            notes-> copy [err]);
            }
        }
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================         FLOAT / INT          =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * @params:
     *   - context: the context of the validation
     *   - f: the expression to validate
     * @returns: a float value
     */
    fn validateFloat (self, dmut context : &Validator, f : &FloatExpr)-> &Value
        throws ErrorMsg
    {
        if (f.isHex ()) return self.validateFloatHex (alias context, f);

        let dmut stream = copy StringStream ();
        self.removeUnders (f.getPrePart ().str, alias stream, default-> "0"s8);
        stream:.write ('.'c8);
        self.removeUnders (f.getDecPart ().str, alias stream, default-> "0"s8);

        let exp : &BigFloat =
            if (!f.getExpPart ().isEof ()) {
                {
                    let dmut expStr = copy StringStream ();
                    self.removeUnders (f.getExpPart ().str, alias expStr, default-> "0"s8);
                    let exp = std::conv::to!{i64} (expStr[]);
                    if (f.expPartIsPositive ()) {
                        copy BigFloat (10.0) ^^ exp
                    } else {
                        copy BigFloat (10.0) ^^ -exp
                    }
                } catch {
                    e : _ => {
                        println (e);
                        throw copy ErrorMsg::fatal (f.getLoc (), format (ValidateErrorMessage::MALFORMED_FLOAT_LITERAL, f));
                    }
                }
            } else {
                copy BigFloat (1.0)
            };

        let val = copy BigFloat (stream[]);

        if (f.getSuffix () == FloatSuffixes::F32) {
            copy FloatValue (f.getLoc (),
                             copy FloatType (f.getLoc (), size-> 32u16),
                             val * exp)
        } else if (f.getSuffix () == FloatSuffixes::F64 || f.getSuffix ().isEof ()){
            copy FloatValue  (f.getLoc (),
                              copy FloatType (f.getLoc (), size-> 64u16),
                              val * exp)
        } else if (f.getSuffix () == FloatSuffixes::F80) {
            copy FloatValue  (f.getLoc (),
                              copy FloatType (f.getLoc (), size-> 80u16),
                              val * exp)
        } else {
            copy FloatValue  (f.getLoc (),
                              copy FloatType (f.getLoc (), size-> 0u16),
                              val * exp)
        }
    }

    /**
     * @params:
     *    - context: the context of the validation
     *    - f: the expression to validate
     * @returns: a float value
     * */
    fn validateFloatHex (self, dmut _ : &Validator, f : &FloatExpr)-> &Value
        throws ErrorMsg
    {
        let dmut intPart = copy StringStream ();
        let dmut decPart = copy StringStream ();
        let dmut expPart = copy StringStream ();

        self.removeUnders (f.getPrePart ().str[2us .. $], alias intPart, default-> "0"s8); // remove 0x
        self.removeUnders (f.getDecPart ().str, alias decPart, default-> "0"s8);
        self.removeUnders (f.getExpPart ().str, alias expPart, default-> "0"s8);

        let intPartV = copy BigFloat (copy BigInt (std::conv::to!{usize, 16} (intPart[])));
        let decPartV = copy BigFloat (copy BigInt (std::conv::to!{usize, 16} (decPart[]))) * (copy BigFloat (16.0) ^^ -cast!i64 (decPart[].len));
        let expPartV = std::conv::to!{i64} (expPart[]);

        let exp2 = if (f.expPartIsPositive ()) {
            copy BigInt (2) ^^ expPartV
        } else {
            copy BigInt (2) ^^ -expPartV
        }

        let val = intPartV + decPartV;
        let expVal = copy BigFloat (exp2);

        if (f.getSuffix () == FloatSuffixes::F32) {
            copy FloatValue (f.getLoc (), copy FloatType (f.getLoc (), size-> 32u16), val * expVal)
        } else if (f.getSuffix ().isEof () || f.getSuffix () == FloatSuffixes::F64) {
            copy FloatValue (f.getLoc (), copy FloatType (f.getLoc (), size-> 64u16), val * expVal)
        } else if (f.getSuffix () == FloatSuffixes::F80) {
            copy FloatValue (f.getLoc (), copy FloatType (f.getLoc (), size-> 80u16), val * expVal)
        } else {
            copy FloatValue (f.getLoc (), copy FloatType (f.getLoc (), size-> 0u16), val * expVal)
        }
    } catch {
        _ => throw copy ErrorMsg::fatal (f.getLoc (), format (ValidateErrorMessage::MALFORMED_FLOAT_LITERAL, f));
    }

    /**
     * @params:
     *   - _: the context of the validation
     *   - f: the expression to validate
     * @returns: a int value
     */
    fn validateInt (self, dmut context : &Validator, f : &FixedExpr)-> &Value
        throws ErrorMsg
    {
        let dmut stream = copy StringStream ();
        self.removeUnders (f.getLoc ().str, alias stream, default-> "0"s8);

        let type = match f.getSuffix ().str {
            FixedSuffixes::U8 => { copy IntType (f.getLoc (), size-> 8u16, signed-> false) }
            FixedSuffixes::U16 => { copy IntType (f.getLoc (), size-> 16u16, signed-> false) }
            FixedSuffixes::U32 => { copy IntType (f.getLoc (), size-> 32u16, signed-> false) }
            FixedSuffixes::U64 => { copy IntType (f.getLoc (), size-> 64u16, signed-> false) }
            FixedSuffixes::USIZE => { copy IntType (f.getLoc (), size-> 0u16, signed-> false) }
            FixedSuffixes::I8 => { copy IntType (f.getLoc (), size-> 8u16, signed-> true) }
            FixedSuffixes::I16 => { copy IntType (f.getLoc (), size-> 16u16, signed-> true) }
            FixedSuffixes::I64 => { copy IntType (f.getLoc (), size-> 64u16, signed-> true) }
            FixedSuffixes::ISIZE => { copy IntType (f.getLoc (), size-> 0u16, signed-> true) }
            _ => { copy IntType (f.getLoc (), size-> 32u16, signed-> true) }
        };

        let value : usize = {
            if (stream[].len > 2us && stream[][0us .. 2us] == "0x"s8) {
                std::conv::to!{usize, "x"} (stream[])
            } else if (stream[].len > 2us && stream[][0us .. 2us] == "0b"s8) {
                std::conv::to!{usize, "b"} (stream[])
            } else if (stream[].len > 2us && stream[][0us .. 2us] == "0o"s8) {
                std::conv::to!{usize, "o"} (stream[])
            } else {
                std::conv::to!{usize} (stream[])
            }
        } catch {
            _ => {
                throw copy ErrorMsg::fatal (f.getLoc (), format (ValidateErrorMessage::MALFORMED_INT_LITERAL, stream[]));
            }
        };

        // verify that there is no overflow in the value literal
        context:.getCompileTimeInterpreter ().verifyOverFlowInt (f.getLoc (), type, value);

        copy IntValue (f.getLoc (), type, value)
    }
    
    /**
     * Write a string literal into the stream, except the '_'
     * @params: 
     *    - str: the string value to write
     *    - stream: the stream to fill
     *    - default: the value to write in the stream if nothing was printed from str
     */
    fn removeUnders (self, str : [c8], dmut stream : &StringStream, default : [c8] = ""s8) {
        let mut wrote = false;
        for i in str {
            if (i != '_'c8) {
                wrote = true;
                stream:.write (i);
            }
        }

        if (!wrote) stream:.write (default);
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================        CHAR / STRING         =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * @params: 
     *   - _: the context of the validation
     *   - c: the char to validate
     * @throws: &ErrorMsg if the char is malformed
     * @returns: a char value
     */
    fn validateChar (self, dmut _ : &Validator, c : &CharExpr)-> &Value
        throws ErrorMsg
    {
        let str = utf::instance ().escape (c.getLoc (), c.getSequence ());

        let (len, res, inner) = match c.getSuffix () {
            CharSuffixes::UTF32 => {
                let encoded = utf::instance ().encodeUtf32 (str);
                let inner = copy CharType (c.getLoc (), size-> 32u16);

                (encoded.len, if encoded.len != 0us { copy CharValue (c.getLoc (), inner, encoded [0]) } else { UNIT_VALUE }, inner)
            }

            CharSuffixes::UTF16 => {
                let encoded = utf::instance ().encodeUtf16 (str);
                let inner = copy CharType (c.getLoc (), size-> 16u16);

                (encoded.len, if encoded.len != 0us { copy CharValue (c.getLoc (), inner, encoded [0]) } else { UNIT_VALUE }, inner)
            }

            _ => { // utf8 is more common than utf32 and utf16
                let encoded = utf::instance ().encodeUtf8 (str);
                let inner = copy CharType (c.getLoc (), size-> 8u16);

                (encoded.len, if encoded.len != 0us { copy CharValue (c.getLoc (), inner, encoded [0]) } else { UNIT_VALUE }, inner)
            }
        };

        if (len != 1us) {
            throw copy ErrorMsg::fatal (c.getLoc (), format (ValidateErrorMessage::MALFORMED_CHAR, inner, len));
        }

        res
    }

    /**
     * @params: 
     *   - _: the context of the validation
     *   - s: the string to validate
     * @throws: &ErrorMsg if the string is malformed
     * @returns: a string value
     */
    fn validateString (self, dmut _ : &Validator, s : &StringExpr)-> &Value
        throws ErrorMsg
    {
        let str = utf::instance ().escape (s.getLoc (), s.getSequence ());

        return match s.getSuffix () {
            StringSuffixes::UTF32 => {
                let encoded = utf::instance ().encodeUtf32 (str);
                let inner = copy CharType (s.getLoc (), size-> 32u16);
                let slcType = copy SliceType (s.getLoc (), inner, isMutable-> true,
                                              withSize-> makeIntValue (s.getLoc (), encoded.len));

                copy StringValue (s.getLoc (), slcType, encoded)
            }

            StringSuffixes::UTF16 => {
                let encoded = utf::instance ().encodeUtf16 (str);
                let inner = copy CharType (s.getLoc (), size-> 16u16);
                let slcType = copy SliceType (s.getLoc (), inner, isMutable-> true,
                                              withSize-> makeIntValue (s.getLoc (), encoded.len));

                copy StringValue (s.getLoc (), slcType, encoded)
            }

            _ => { // it is way more common to want utf8, than utf32 or utf16
                let encoded = utf::instance ().encodeUtf8 (str);
                let inner = copy CharType (s.getLoc (), size-> 8u16);
                let slcType = copy SliceType (s.getLoc (), inner, isMutable-> true,
                                              withSize-> makeIntValue (s.getLoc (), encoded.len));

                copy StringValue (s.getLoc (), slcType, encoded)
            }
        };
    }


    /*!
     * ================================================================================
     * ================================================================================
     * ======================            SLICE/ARRAYS             =====================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a list expression
     * @params:
     *   - context: the context of the validation
     *   - l: the list expression to validate
     *   - type: the type to force (if different to NONE_TYPE) and only applicable to ListArray
     * @returns: the validated value
     */
    pub fn validateList (self, dmut context : &Validator, l : &ListExpr)-> &Value
        throws ErrorMsg
    {
        if (l.isArray ()) {
            if (context.isDynamic (l)) {
                self.validateListSlice (alias context, l)
            } else {
                self.validateListStaticArray (alias context, l)
            }
        } else {
            self.validateListTuple (alias context, l)
        }
    }

    /**
     * Validate a list expression containing an array literal
     * @params:
     *   - context: the context of the validation
     *   - l: the list to validate
     * @returns: the validated value
     */
    fn validateListStaticArray (self, dmut context : &Validator, l : &ListExpr)-> &Value
        throws ErrorMsg
    {
        let mut parameters : [mut &Value] = [];
        let mut inner : &Type = copy NoneType (l.getLoc ());

        for it in l.getParameters () {
            let val = context:.validateValue (it);
            match val {
                e : &ExpandValue => {
                    for g_it in e.getInnerValues () {
                        inner = self.addArrayType (alias context, g_it, ref parameters, inner);
                    }
                }
                g_it : _ => {
                    inner = self.addArrayType (alias context, g_it, ref parameters, inner);
                }
            }
        }

        // If there is no value in the slice (i.e. []), its values is [void]
        if (parameters.len == 0us) inner = copy VoidType (l.getLoc ());

        let arrType = copy ArrayType (l.getLoc (), inner, parameters.len, isMutable-> true);
        copy ArrayValue (l.getLoc (), arrType, parameters)
    }

    /**
     * Validate a list expression containing a slice literal (same as array literal but within a copy or dcopy context)
     * @params:
     *    - context: the context of the validation
     *    - l: the list to validate
     * @returns: the validated value
     * */
    fn validateListSlice (self, dmut context : &Validator, l : &ListExpr)-> &Value
        throws ErrorMsg
    {
        let content = self.validateListStaticArray (alias context, l);
        if let arrType : &ArrayType = content.getType () {
            let inner = arrType.getInners ()[0];

            let slcType = copy SliceType (l.getLoc (), inner, isMutable-> true);
            if (arrType.getLen () == 0us) {
                return copy SliceCtorValue (l.getLoc (), slcType,
                                            copy NullValue (l.getLoc ()),
                                            copy NullValue (l.getLoc ()),
                                            makeIntValue (l.getLoc (), 0us), isImplicitAlias-> true);
            } else {
                if let i : &IntrinsicExpr = context.getDynamicExpr () {
                    let addr = copy AddressValue (l.getLoc (), copy PointerType (l.getLoc (), inner), content);
                    let ctor = copy SliceCtorValue (l.getLoc (), slcType,
                                                    addr,
                                                    copy NullValue (l.getLoc ()), // no need for blk info, the slice is copied
                                                    makeIntValue (l.getLoc (), arrType.getLen ()), isImplicitAlias-> true);


                    return copy CopierValue (i.getLoc (), slcType, ctor, isDeep-> i.getType () == IntrinsicKeys::DCOPY);
                }
            }
        }

        panic;
    }

    /**
     * Add a parameter to an list of array parameters
     * @params:
     *   - context: the context of the validation
     *   - val: the value to add
     *   - parameters: the list of parameters inside the array literal
     *   - innerType: the current type of the inner values of the array
     */
    pub fn addArrayType (self, dmut context : &Validator, val : &Value, ref mut parameters : [&Value], innerType : &Type)-> &Type
        throws ErrorMsg
    {
        if (val.getType () of NoneType || val.getType () of VoidType) {
            throw copy ErrorMsg::fatal (val.getLoc (), ValidateErrorMessage::VOID_VALUE);
        }

        let (t, v) = context:.inferTypeBranchingWithValue (innerType.getLoc (), innerType, val);
        parameters ~= [v];
        t
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================            TUPLES             ========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a list expression containing a tuple literal
     * @params:
     *   - context: the context of the validation
     *   - l: the list to validate
     * @returns: the validated value
     */
    fn validateListTuple (self, dmut context : &Validator, l : &ListExpr)-> &Value
        throws ErrorMsg
    {
        let mut parameters : [mut &Value] = [];
        let mut types : [mut &Type] = [];
        for it in l.getParameters () {
            let val = context:.validateValue (it);
            match val {
                e : &ExpandValue => {
                    for g_it in e.getInnerValues () {
                        self.addTupleType (alias context, g_it, ref parameters, ref types);
                    }
                }
                g_it : _ => {
                    self.addTupleType (alias context, g_it, ref parameters, ref types);
                }
            }
        }

        let type = copy TupleType (l.getLoc (), types, isMutable-> true);
        copy TupleValue (l.getLoc (), type, parameters)
    }

    /**
     * Add an element at the end of a list of tuple parameters and types
     * @params:
     *   - context: the context of the validation
     *   - val: the value to add
     *   - params: the list of parameters
     *   - types: the list of types
     */
    pub fn addTupleType (self, dmut context : &Validator, val : &Value, ref mut params : [&Value], ref mut types : [&Type])
        throws ErrorMsg
    {
        if (val.getType () of NoneType || val.getType () of VoidType) {
            throw copy ErrorMsg::fatal (val.getLoc (), ValidateErrorMessage::VOID_VALUE);
        }

        let type = context:.inferTypeImplicitMutability (val);

        params ~= [val];
        types ~= [type];
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          ALLOC MAP          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Validate a list map literal expression
     * @params:
     *    - context: the context of the validation
     *    - mp: the map literal to validate
     * @returns: a map value
     * @throws:
     *    - &ErrorMsg
     * */
    pub fn validateListMap (self, dmut context : &Validator, mp : &ListMapExpr)-> &Value
        throws ErrorMsg
    {
        let loc = mp.getLoc ();

        let mut keys : [mut &Value] = [];
        let mut values : [mut &Value] = [];
        let mut innerK : &Type = NONE_TYPE;
        let mut innerV : &Type = NONE_TYPE;

        for i in 0us .. mp.getKeys ().len {
            let k = context:.validateValue (mp.getKeys () [i]);
            innerK = self.addArrayType (alias context, k, ref keys, innerK);

            let v = context:.validateValue (mp.getValues ()[i]);
            innerV = self.addArrayType (alias context, v, ref values, innerV);
        }

        if (keys.len == 0us) {
            innerK = copy VoidType (loc);
            innerV = innerV;
        }

        let mpType = copy MapType (loc, innerK.clone (0u32), innerV, isMutable-> true);
        {
            context:.createMapTypeInfo (loc, mpType);
        } catch {
            err : &ErrorMsg => {
                throw err.withNote (copy [copy ErrorMsg::note (mp.getLoc (), format (ValidateErrorMessage::VALIDATING))]);
            }
        }

        let mpValue = copy MapValue (loc, mpType, keys, values);
        if (context.isDynamic (mp) && context.isDynamicDeep ()) { // dcopy [1 => 2], is prohibited
            throw copy ErrorMsg::fatal (loc, format (ValidateErrorMessage::CTOR_MAP_DCOPY, mpType),
                                        notes-> copy [copy ErrorMsg::note (context.getDynamicExpr ().getLoc (), format (ValidateErrorMessage::SIMPLE_COPY_CLASS_CTOR))]);
        }

        if (!context.isDynamic (mp) && keys.len != 0us) { // [1 => 2] must be placed inside a copy op (i.e. copy [1 => 2])
            throw copy ErrorMsg::fatal (loc, format (ValidateErrorMessage::CTOR_MAP_STACK, mpType),
                                        notes-> copy [copy ErrorMsg::note (context.getDynamicExpr ().getLoc (), format (ValidateErrorMessage::ENCLOSE_COPY_LST_COMPR), oneLine-> true)]);
        }

        mpValue
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===============================          ALLOC SLICE/ARRAYS          ===============================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Validate a slice allocator expression
     * @params:
     *     - context: the context of the validation
     *     - alloc: the allocation to validate
     *  @throws: &ErrorMsg: if the expression is not valid
     *  @returns: the value containing the allocation
     */
    pub fn validateSliceAllocator (self, dmut context : &Validator, alloc : &SliceAllocatorExpr)-> &Value
        throws ErrorMsg
    {
        if (context.isDynamic (alloc)) {
            self.validateDynamicSliceAllocator (alias context, alloc)
        } else {
            self.validateStaticSliceAllocator (alias context, alloc)
        }
    }

    /**
     * Validate a slice allocator whose size might not be cte
     * @params:
     *    - context: the context of the validation
     *    - allooc: the allocator to validate
     * */
    fn validateDynamicSliceAllocator (self, dmut context : &Validator, alloc : &SliceAllocatorExpr)-> &Value
        throws ErrorMsg
    {
        let size = context.implicitEnumUnwrap (context:.validateValue (alloc.getSize ()));
        match size.getType () {
            IntType () => {}
            _ => {
                let iType = copy IntType (alloc.getSize ().getLoc (), size-> 0u16, signed-> false);
                throw copy ErrorMsg::fatal (alloc.getSize ().getLoc (),
                                            format (ValidateErrorMessage::INCOMPATIBLE_TYPE, size.getType (), iType));
            }
        };

        let value = context:.validateValue (alloc.getValue ());
        self.validateDynamicSliceAllocator (alias context, alloc.getLoc (), value, size)
    }


    /**
     * Validate a array allocator that creates a slice (whose size does not need to be cte)
     * The returned value is a copier, or a dynamic array allocator.
     * @params:
     *    - context: the context of the validation
     *    - loc: the location of the allocation
     *    - value: the value to put in the slice
     *    - size: the size of the slice to allocate (can be cte, but is not mandatory)
     * @returns: the allocator (or copier)
     * @throws:
     *    - &ErrorMsg: if the validation failed
     * */
    pub fn validateDynamicSliceAllocator (self, dmut context : &Validator, loc : &Word, value : &Value, size : &Value)-> &Value
        throws ErrorMsg
    {
        let innerType = context:.inferTypeImplicitMutability (value);
        context.verifyCompleteType (value.getLoc (), innerType, false);
        if (innerType of NoneType || innerType of VoidType) {
            throw copy ErrorMsg::fatal (value.getLoc (), format (ValidateErrorMessage::EMPTY_ARRAY_INNER, innerType));
        }

        if let s : &IntValue = size {
            let tabSize = {
                s.getValue ().to!usize ()
            } catch {
                _ => throw copy ErrorMsg::fatal (size.getLoc (), format (ValidateErrorMessage::OVERFLOW_CAPACITY, copy IntType (size.getLoc (), size-> 0u16, signed-> false), size, u64::max));
            };

            if (tabSize <= 255us) { // then alloc from copy is faster (memset is slower than memcpy)
                let valSize = makeIntValue (size.getLoc (), tabSize);
                let type = copy ArrayType (loc, innerType, tabSize, isMutable-> true);
                let slcType = copy SliceType (loc, innerType, isMutable-> true);
                let content = copy AddressValue (loc, copy PointerType (loc, innerType),
                                                 copy ArrayAllocValue::stat (loc, type, value, valSize));

                let ctor = copy SliceCtorValue (loc, slcType,
                                                content,
                                                NULL_VALUE, // no need for blk info the slice is copied
                                                valSize, isImplicitAlias-> true);

                // We can make a dynamic alloc only if we are inside a copy
                if let i : &IntrinsicExpr = context.getDynamicExpr () {
                    return copy CopierValue (i.getLoc (), slcType, ctor, isDeep-> i.getType () == IntrinsicKeys::DCOPY);
                } else panic;
            }
        }

        // Size is unknown, we cannot make an array in the stack to copy from
        let type = copy SliceType (loc, innerType, isMutable-> true);
        copy ArrayAllocValue::dyn (loc, type, value, size)
    }

    /**
     * Validate an array allocator, thus whose size is cte
     * @params:
     *    - context: the context of the validaton
     *    - alloc: the allocator to validate
     * */
    fn validateStaticSliceAllocator (self, dmut context : &Validator, alloc : &SliceAllocatorExpr)-> &Value
        throws ErrorMsg
    {
        let sizeVal = context.implicitEnumUnwrap (context:.validateValue (alloc.getSize ()));
        let value = context:.validateValue (alloc.getValue ());

        {
            context:.getCompileTimeInterpreter ():.computeInt (sizeVal);
        } catch {
            err : &ErrorMsg => {
                throw err.withNote (copy [copy ErrorMsg::note (alloc.getLoc (), format (ValidateErrorMessage::ENCLOSE_COPY_CLASS_CTOR))]);
            }
        }

        self.validateStaticSliceAllocator (alias context, alloc.getLoc (), value, sizeVal)
    }

    /**
     * Validate a static array allocation, form an inner value, and a already validate size
     * @params:
     *    - context: the context of the validation
     *    - loc: the location of the allocator
     *    - value: the inner value to put in the array
     *    - sizeVal: the value containing the size of the array (should be cte)
     * @returns: the array allocator
     * @throws:
     *     - &ErrorMsg: if the allocation is not valid
     * */
    pub fn validateStaticSliceAllocator (self, dmut context : &Validator, loc : &Word, value : &Value, sizeVal : &Value)-> &Value
        throws ErrorMsg
    {
        let size = context:.getCompileTimeInterpreter ():.computeInt (sizeVal);
        let innerType = context:.inferTypeImplicitMutability (value);

        context.verifyCompleteType (value.getLoc (), innerType, false);
        if (innerType of NoneType || innerType of VoidType) {
            throw copy ErrorMsg::fatal (value.getLoc (), format (ValidateErrorMessage::EMPTY_ARRAY_INNER, innerType));
        }

        let tabSize = {
            size.to!usize ()
        } catch {
            _ => throw copy ErrorMsg::fatal (sizeVal.getLoc (), format (ValidateErrorMessage::OVERFLOW_CAPACITY, copy IntType (sizeVal.getLoc (), size-> 0u16, signed-> false), size, u64::max));
        };

        if (tabSize > 1048576us) { // 1MB
            throw copy ErrorMsg::fatal (sizeVal.getLoc (), format (ValidateErrorMessage::OVERFLOW_CAPACITY_ARRAY, tabSize, 1048576us));
        }

        let valSize = makeIntValue (sizeVal.getLoc (), tabSize);
        let type = copy ArrayType (loc, innerType, tabSize, isMutable-> true);
        copy ArrayAllocValue::stat (loc, type, value, valSize)
    }


    /*!
     * ================================================================================
     * ================================================================================
     * =========================             VAR              =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * @params: 
     *   - context: the context of the validation
     *   - v: the var to validate
     * @throws: &ErrorMsg if the var is not found
     * @returns: a value
     */
    fn validateVar (self, dmut context : &Validator, v : &VarExpr)-> &Value
        throws ErrorMsg
    {
        let value = context:.getLocal (v.getLoc (), v.getLoc ().str);
        match value {
            UnitValue () => return self.validateVarGlobal (alias context, v);
            protoV : &ProtoVarValue => {
                return copy VarRefValue (v.getLoc (), protoV.getLoc (), protoV.getType (), protoV.getUniqId (), isSelf-> protoV.isSelf (), isParam-> true, isReference-> protoV.isReference (), isLazy-> protoV.isLazy ());
            }
            vdecl : &VarDeclValue => {
                match vdecl.getVarType () {
                    LambdaType () => {
                        return vdecl.getValue (); // return the lambda value associated to the var decl
                        // return copy VarRefValue (v.getLoc (), vdecl.getLoc (), vdecl.getVarType (), value-> vdecl.getValue (), vdecl.getUniqId (), isSelf-> false);
                    }
                    _ => {
                        return copy VarRefValue (v.getLoc (),
                                                 vdecl.getLoc (),
                                                 vdecl.getVarType (),
                                                 vdecl.getUniqId (),
                                                 isSelf-> false,
                                                 canCte-> vdecl.isCte (),
                                                 isIterator-> vdecl.isIterator (),
                                                 isReference-> vdecl.isReference (),
                                                 isLazy-> vdecl.isLazy (),
                                                 value-> if (vdecl.isMutable ()) { UNIT_VALUE } else { vdecl.getValue () });
                    }
                }
            }
            s : &StructFieldAccessValue => { // Closure
                return s;
            }
            vl : &Value => { // Directly inserted a value, for example in Enum validation
                return vl;
            }
        }
    } 

    /**
     * Validate a var reference that was not found locally, and then must be searched in global symbols
     * @params: 
     *     - context: the context of the validation
     *     - v: the variable to search
     * @returns: a value containing the references to the global variable (multsym is possible)
     * @throws: &ErrorMsg, the variable refers to nothing
     */
    fn validateVarGlobal (self, dmut context : &Validator, v : &VarExpr)-> &Value
        throws ErrorMsg
    {
        let dmut syms = context:.getGlobal (v.getLoc ().str);
        if (syms.len == 0us) {
            throw context:.createGlobalVarError (v.getLoc (), v.getLoc ().str);
        } else {
            {
                return self.validateMultSymbols (v.getLoc (), alias context, alias syms);
            } catch {
                err : &ErrorMsg => {
                    throw copy ErrorMsg::fatal (v.getLoc (), format (ValidateErrorMessage::UNDEF_VAR, v.getLoc ().str), notes-> copy [err]);
                }
            }
        }
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================          MULT SYMS           =========================
     * ================================================================================
     * ================================================================================
     */
    
    /**
     * Transform symbol references into a single value
     * @params:
     *   - loc: the location of the symbol ref
     *   - context: the context of the validation
     *   - syms: the list of symbols
     *   - base: the list of values that were validated by another mean, and must be added inside the MultSymValue
     * @returns: a value containing multiple symbols (&MultSymValue), or a single one (&Value)
     * @throws: 
     *   - &ErrorMsg: if the transformation fails
     */
    pub fn validateMultSymbols (self, loc : &Word, dmut context : &Validator, dmut syms : [&Symbol], base : [&Value] = [])-> &Value
        throws ErrorMsg
    {
        let mut res : [&Value] = base;
        let mut errors : [mut &ErrorMsg] = [];
        let mut typeErrors : [mut &ErrorMsg] = [];

        for i in 0us .. syms.len {
            context:.pushReferent (alias syms [i]);
            {
                match alias syms [i] {
                    dmut f : &FunctionSymbol => {
                        if (!f.isMethod ()) {
                            res ~= [context:.getFunctionValidator ():.validateFuncPrototype (alias context, alias f)];
                        } else {
                            typeErrors ~= [copy ErrorMsg::fatal (f.getLoc (), format (ValidateErrorMessage::IS_A_METHOD, f.getPath ()))];
                        }
                    }
                    c : &ConstructorSymbol => {
                        typeErrors ~= [copy ErrorMsg::fatal (c.getLoc (), format (ValidateErrorMessage::USE_AS_VALUE_TYPE, c))];
                    }
                    m : &ModuleSymbol => {
                        res ~= [copy ModuleRefValue (loc, m)];
                    }
                    l : &LazyModuleSymbol => {
                        res ~= [copy ModuleRefValue (loc, context:.getModuleFromLazy (l))];
                    }
                    dmut gv : &GlobalSymbol => {
                        self.validateGlobalVarSymbolMultSym (loc, alias context, alias gv, ref res);
                    }
                    dmut a : &AkaSymbol => { // Aka are sometimes types, there is a special function to handle that
                        self.validateAkaSymbolMultSym (loc, alias context, alias a, ref res, ref typeErrors);
                    }
                    dmut t : &TemplateSymbol => { // At this point there is no way to determine if it is a type or a value
                        res ~= [copy TemplateRefValue (t.getLoc (), t)];
                    }
                    dmut m : &MacroSymbol => {
                        res ~= [copy MacroRefValue (loc, m)];
                    }
                    dmut c : &ClassSymbol => { // class are types
                        self.validateClassCtorMultSyms (loc, alias context, alias c, ref res);
                    }
                    dmut tr : &TraitSymbol => { // Traits are also types
                        {
                            let type = context:.getTraitValidator ().validate (alias context, alias tr);
                            typeErrors ~= [copy ErrorMsg::fatal (loc, format (ValidateErrorMessage::USE_AS_VALUE_TYPE, type))];
                        } catch { err : &ErrorMsg => { typeErrors ~= [err]; } }
                    }
                    dmut en : &EnumSymbol => { // Enum are also types
                        {
                            let type = context:.getEnumValidator ():.validate (alias context, alias en);
                            typeErrors ~= [copy ErrorMsg::fatal (loc, format (ValidateErrorMessage::USE_AS_VALUE_TYPE, type))];
                        } catch { err : &ErrorMsg => { typeErrors ~= [err]; } }
                    }
                    type : _ => {
                        typeErrors ~= [copy ErrorMsg::fatal (loc, end-> type.getLoc (), format (ValidateErrorMessage::USE_AS_VALUE_TYPE, type.getPath ()))];
                    }
                }
            } catch {
                err : &ErrorMsg => {
                    errors ~= [err];
                }
            }
            
            context:.popReferent ();
        }

        // There are errors in value validation
        if (errors.len != 0us) {
            let dmut form = copy StringStream ();
            for i, j in syms {
                if (i != 0us) form:.write (", ");
                form:.write (j.getPath ().toStr ());
            }

            throw copy ErrorMsg::fatal (loc, format (ValidateErrorMessage::INVALID_SYMBOLS, form[]), notes-> errors);
        }

        res = self.reduceMultSyms (res);
        if (res.len == 1us) {
            res [0]
        } else {
            if (res.len == 0us) {
                if (typeErrors.len != 0us) { // There are no values
                    throw copy ErrorMsg::list (typeErrors); // It has to be because of type error
                } else panic;
            }
            
            let prettyStr = self.createPrettyStringMultSym (res);
            copy MultSymValue (loc, res, prettyStr-> prettyStr)
        }
    }

    /**
     * @returns: a pretty string refereing to the content of 'values'
     */
    fn createPrettyStringMultSym (self, values : [&Value])-> [c8] {
        let mut set : [[c8] => mut ()] = [];
        for i in values {
            set [format ("%", i)] = ();
        }
        
        let dmut stream = copy StringStream ();
        if (set.len > 1us) stream:.write ("{");

        let mut i = 0us;
        for val in set {
            if (i != set.len - 1us && i == 2us) stream:.write (", ...");
            else if (i == set.len - 1us || i < 2us) {
                if i != 0us { stream:.write (", "); }
                stream:.write (val);
            }

            i += 1us;
        }

        if (set.len > 1) stream:.write ("}"s8);
        stream[]
    }

    /**
     * Remove the identical values from the result multsym
     * */
    fn reduceMultSyms (self, res : [&Value])-> [&Value] {
        let mut final : [mut &Value] = [];
        for v in res {
            let mut found = false;
            for v2 in final {
                if v2 == v {
                    found = true;
                    break;
                }
            }

            if !found {
                final ~= [v];
            }
        }

        final
    }
    
    /**
     * Aka symbol may refer to types, or to values
     * In order to show the correct error, we should try both validation
     * @params: 
     *   - loc: the location of the symbol reference
     *   - context: the context of the validation
     *   - sym: the symbol to validate
     * @throws: 
     *   - &ErrorMsg: if the aka is malformed (but not a type)
     * @returns: 
     *   - res: add the value to the vec
     *   - typeErrors: add an error, if the aka is a type (but not malformed)
     */
    fn validateAkaSymbolMultSym (self, loc : &Word, dmut context : &Validator, dmut sym : &AkaSymbol, ref mut res : [&Value], ref mut typeErrors : [&ErrorMsg])
        throws ErrorMsg
    {
        context:.getAkaValidator ():.validate (alias context, alias sym);
        match sym.getGenerator () {
            c : &ClassRefType => {
                let ctors = context:.getSubTypeValidator ().validateClassCtors (alias context, loc, c, name-> ""s8);
                match ctors {
                    m : &MultSymValue => {
                        res ~= m.getValues ();
                    }
                    _ => { res ~= [ctors]; }
                }
            }
            type : &Type => {
                typeErrors ~= [copy ErrorMsg::fatal (loc, format (ValidateErrorMessage::USE_AS_VALUE_TYPE, type))];
            }
            value : &Value => {
                res ~= [value.clone ()];
            }
            e : &ErrorGenerator => throw e.getErrorMessage ();
            _ => panic;
        };
    }

    /**
     * Class symbol names are used to refer to its ctors when used as a value
     * @params:
     *    - loc: the location of the symbol ref
     *    - context: the context of the validation
     *    - sym: the symbol to validate
     * @throws:
     *    - &ErrorMsg: if the symbol is malformed
     *  @returns:
     *    - res: add the ctor values
     * */
    fn validateClassCtorMultSyms (self, loc : &Word, dmut context : &Validator, dmut sym : &ClassSymbol, ref mut res : [&Value])
        throws ErrorMsg
    {
        let type = context:.getClassValidator ():.validate (alias context, alias sym, inModule-> false);
        let val = context:.getSubTypeValidator ().validateClassCtors (alias context, loc, type, name-> ""s8);

        match val {
            m : &MultSymValue => {
                res ~= m.getValues ();
            }
            _ => { res ~= [val]; }
        }
    }

    /**
     * Validate a global variable symbol and create a var reference to it
     * @params:
     *     - loc: the location of the symbol reference
     *     - context: the context of the validation
     *     - sym: the symbol to validate
     * @throws:
     *     - &ErrorMsg: if the validation of the gvar failed
     * @returns:
     *     - res: add the value to the vec
     * */
    fn validateGlobalVarSymbolMultSym (self, loc : &Word, dmut context : &Validator, dmut sym : &GlobalSymbol, ref mut res : [&Value])
        throws ErrorMsg
    {
        context:.getGlobalVarValidator ():.validate (alias context, alias sym, fromModule-> false);
        match sym.getGenerator () {
            gv : &GlobalVarGenerator => {
                res ~= [copy GlobalVarRefValue (loc, sym, gv)];
            }
            e : &ErrorGenerator => throw e.getErrorMessage ();
            _ => panic;
        }
    }

}
