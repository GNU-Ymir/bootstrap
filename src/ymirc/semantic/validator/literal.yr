mod ymirc::semantic::validator::literal;

import ymirc::semantic::validator::visitor;
import ymirc::semantic::validator::errors;
import ymirc::syntax::declaration::protection;
import ymirc::syntax::expression::_;
import ymirc::syntax::declaration::_;
import ymirc::semantic::symbol::_;
import ymirc::semantic::declarator::visitor;
import ymirc::semantic::validator::utf;


import ymirc::semantic::generator::_;
import ymirc::errors::_;
import ymirc::utils::format;
import ymirc::lexing::word;
import ymirc::syntax::keys;
import ymirc::lexing::tokens;


import std::collection::set;
import std::collection::vec;
import std::io, std::fs::path;

/**
 * The literal validator is the class responsible for literal expression validation
 */
pub class LiteralValidator {

    /// The visitor used to validate literal strings
    let _utfVisitor = UtfVisitor::new ();
    
    /**
     * Create a new empty validator
     */
    pub self () {}    

    
    /**
     * Validate a literal expression
     * @params: 
     *  - context: the context of the validation
     *  - lit: the literal to validate
     *  - forceType: the force type
     * @throws: &ErrorMsg, if the validation failed
     * @returns: a value
     */
    pub def validate (self, dmut context : &Validator, lit : &LiteralExpr, forceType : &Type = NONE_TYPE)-> &Value
        throws &ErrorMsg
    {
        match lit {
            b : &BoolExpr => return self.validateBool (alias context, b);
            n : &NullExpr => return self.validateNull (alias context, n);
            d : &DollarExpr => return self.validateDollar (alias context, d);
            i : &IgnoreExpr => return self.validateIgnore (alias context, i);
            u : &UnitExpr => return self.validateUnit (alias context, u);
            f : &FixedExpr => return self.validateInt (alias context, f);
            f : &FloatExpr => return self.validateFloat (alias context, f);
            c : &CharExpr => return self.validateChar (alias context, c);
            s : &StringExpr => return self.validateString (alias context, s, forceType-> forceType);
            v : &VarExpr => return self.validateVar (alias context, v);
            _ => {
                println ("Unknown literal : ", lit::typeinfo.name);
                __pragma!panic ();
            }
        }
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================           SIMPLES            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * @params: 
     *   - _ : the context of the validation
     *   - b: the bool expression to validate
     * @returns: a bool value
     */
    def validateBool (self, dmut _ : &Validator, b : &BoolExpr)-> &Value {
        BoolValue::new (b.getLoc (), b.getLoc () == Keys::TRUE)
    }


    /**
     * @params:
     *   - _: the context of the validation
     *   - n: the null expr to validate
     * @returns: a null value
     */
    def validateNull (self, dmut _ : &Validator, n : &NullExpr)-> &Value {
        NullValue::new (n.getLoc ())
    }

    /**
     * @params: 
     *   - _: the context of the validation
     *   - u: the unit expression to validate
     * @returns: a unit value
     */
    def validateUnit (self, dmut _ : &Validator, u : &UnitExpr)-> &Value {
        UnitValue::new (loc-> u.getLoc ())
    }

    /**
     * @params: 
     *   - _: the context of the validation
     *   - i: the ignore expression to validate
     * @returns: a unit value
     */
    def validateIgnore (self, dmut _ : &Validator, i : &IgnoreExpr)-> &Value {
        UnitValue::new (loc-> i.getLoc ())
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================            DOLLAR            =========================
     * ================================================================================
     * ================================================================================
     */

    
    /**
     * Validate a dollar expression
     * @params:
     *   - context: the context of the validation
     *   - d: the dollar expression
     * @returns: a value
     * @throws: &ErrorMsg if we are not in a dollar context
     */
    def validateDollar (self, dmut context : &Validator, d : &DollarExpr)-> &Value
        throws &ErrorMsg
    {
        context;
        d;
        __pragma!fake_throw (&ErrorMsg);
        __pragma!panic ();
    }


    /**
     * ================================================================================
     * ================================================================================
     * =========================         FLOAT / INT          =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * @params:
     *   - _: the context of the validation
     *   - f: the expression to validate
     * @returns: a float value
     */
    def validateFloat (self, dmut _ : &Validator, f : &FloatExpr)-> &Value
        throws &ErrorMsg
    {
        import std::conv;
        
        let dmut stream = StringStream::new ();
        self.removeUnders (f.getPrePart ().str (), alias stream, default-> "0"s8);
        stream:.write ('.'c8);
        self.removeUnders (f.getDecPart ().str (), alias stream, default-> "0"s8);

        {
            if (f.getSuffix () == FloatSuffixes::FLOAT) {
                FloatValue::new (f.getLoc (), 
                                 FloatType::new (f.getLoc (), size-> 32u16),
                                 f-> stream[].to!f32 ())
            } else {
                FloatValue::new  (f.getLoc (), 
                                  FloatType::new (f.getLoc (), size-> 64u16),
                                  d-> stream[].to!f64 ())
            }
        } catch {
            _ : &CastFailure => {
                throw ErrorMsg::fatal (f.getLoc (), format (ValidateErrorMessage::MALFORMED_FLOAT_LITERAL, stream[]));
            }
        }
        
    }

    /**
     * @params:
     *   - _: the context of the validation
     *   - f: the expression to validate
     * @returns: a int value
     */
    def validateInt (self, dmut context : &Validator, f : &FixedExpr)-> &Value
        throws &ErrorMsg
    {
        import std::conv;
        
        let dmut stream = StringStream::new ();
        self.removeUnders (f.getLoc ().str (), alias stream, default-> "0"s8);

        let type = match f.getSuffix ().str () {
            FixedSuffixes::U8 => { IntType::new (f.getLoc (), size-> 8u16, signed-> false) }
            FixedSuffixes::U16 => { IntType::new (f.getLoc (), size-> 16u16, signed-> false) }
            FixedSuffixes::U32 => { IntType::new (f.getLoc (), size-> 32u16, signed-> false) }
            FixedSuffixes::U64 => { IntType::new (f.getLoc (), size-> 64u16, signed-> false) }
            FixedSuffixes::USIZE => { IntType::new (f.getLoc (), size-> 0u16, signed-> false) }
            FixedSuffixes::I8 => { IntType::new (f.getLoc (), size-> 8u16, signed-> true) }
            FixedSuffixes::I16 => { IntType::new (f.getLoc (), size-> 16u16, signed-> true) }
            FixedSuffixes::I64 => { IntType::new (f.getLoc (), size-> 64u16, signed-> true) }
            FixedSuffixes::ISIZE => { IntType::new (f.getLoc (), size-> 0u16, signed-> true) }
            _ => { IntType::new (f.getLoc (), size-> 32u16, signed-> true) }                
        };

        let value : usize = {        
            if (stream[].len > 2us && stream[][0us .. 2us] == "0x"s8) {
                stream[].to!{usize, "x"} ()
            } else if (stream[].len > 2us && stream[][0us .. 2us] == "0b"s8) {
                stream[].to!{usize, "b"} ()
            } else if (stream[].len > 2us && stream[][0us .. 2us] == "0o"s8) {
                stream[].to!{usize, "o"} ()
            } else {
                stream[].to!{usize} ()
            }
        } catch {
            _ : &CastFailure => {
                throw ErrorMsg::fatal (f.getLoc (), format (ValidateErrorMessage::MALFORMED_INT_LITERAL, stream[]));
            } 
        };

        // verify that there is no overflow in the value literal
        self.verifyIntOverflow (alias context, f.getLoc (), type, value);

        IntValue::new (f.getLoc (), type, value)
    }
    
    /**
     * Write a string literal into the stream, except the '_'
     * @params: 
     *    - str: the string value to write
     *    - stream: the stream to fill
     *    - default: the value to write in the stream if nothing was printed from str
     */
    def removeUnders (self, str : [c8], dmut stream : &StringStream, default : [c8] = ""s8) {
        let mut wrote = false;
        for i in str {
            if (i != '_'c8) {
                wrote = true;
                stream:.write (i);
            }
        }

        if (!wrote) stream:.write (default);
    }

    /**
     * Verify that the value 'value' can be put in a variable of type "type" without any overflow
     * @params: 
     *    - type: the type of the int
     *    - value: the value that is checked
     * @throws:
     *    - &ErrorMsg: the error to throw if there is an overflow problem
     */
    def verifyIntOverflow (self, dmut _ : &Validator, loc : &Word, type : &IntType, value : usize)
        throws &ErrorMsg
    {
        // There is no sign in an int literal value, so no need to check if the value is lower than min
        let max : usize = match (type.getSize (), type.isSigned ()) {
            (8u16, false) => { cast!usize (u8::max) }
            (8u16, true) => { cast!usize (i8::max) }
            (16u16, false) => { cast!usize (u16::max) }
            (16u16, true) => { cast!usize (i16::max) }
            (32u16, false) => { cast!usize (u32::max) }
            (32u16, true) => { cast!usize (i32::max) }
            (64u16, false) => { cast!usize (u64::max) }
            (64u16, true) => { cast!usize (i64::max) }
            (0u16, false) => { cast!usize (u64::max) }
            _ => { cast!usize (i64::max) }            
        };

        if (value > max) {
            throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::OVERFLOW_CAPACITY, type, value, max));
        }
    }
    

    /**
     * ================================================================================
     * ================================================================================
     * =========================        CHAR / STRING         =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * @params: 
     *   - _: the context of the validation
     *   - c: the char to validate
     * @throws: &ErrorMsg if the char is malformed
     * @returns: a char value
     */
    def validateChar (self, dmut _ : &Validator, c : &CharExpr)-> &Value
        throws &ErrorMsg
    {
        let inner : &Type = if (c.getSuffix () == CharSuffixes::UTF8) {
            CharType::new (c.getLoc (), size-> 8u16)
        } else {
            CharType::new (c.getLoc (), size-> 32u16)
        };

        let (value_c8, value_c32, len) = if (c.getSuffix () == CharSuffixes::UTF8) {
            let (v, l) = self._utfVisitor.convertUtf8 (c.getLoc (), c.getSequence ());
            (v, "\u{0}", l)
        } else {
            let (v, l) = self._utfVisitor.convertUtf32 (c.getLoc (), c.getSequence ());
            ("\u{0}"s8, v, l)
        };

        if (len != 1us) {
            throw ErrorMsg::fatal (c.getLoc (), format (ValidateErrorMessage::MALFORMED_CHAR, inner, len));
        }

        CharValue::new (c.getLoc (), inner, c8Val-> value_c8[0], c32Val-> value_c32[0])
    }

    /**
     * @params: 
     *   - _: the context of the validation
     *   - s: the string to validate
     * @throws: &ErrorMsg if the string is malformed
     * @returns: a string value
     */
    def validateString (self, dmut _ : &Validator, s : &StringExpr, forceType : &Type = NONE_TYPE)-> &Value
        throws &ErrorMsg
    {
        let inner : &Type = if (s.getSuffix () == StringSuffixes::UTF8) {
            CharType::new (s.getLoc (), size-> 8u16)
        } else {
            CharType::new (s.getLoc (), size-> 32u16)
        };

        let (value_c8, value_c32, len) = if (s.getSuffix () == StringSuffixes::UTF8) {
            let (v, l) = self._utfVisitor.convertUtf8 (s.getLoc (), s.getSequence ());
            (v, "", l)
        } else {
            let (v, l) = self._utfVisitor.convertUtf32 (s.getLoc (), s.getSequence ());
            (""s8, v, l)
        };
        
        let arrType = ArrayType::new (s.getLoc (), inner, size-> int::usize (s.getLoc (), len), isMutable-> true);
        match forceType {
            ArrayType () => {
                StringValue::new (s.getLoc (), arrType, c8Val-> value_c8, c32Val-> value_c32, len)
            }
            _ => {                    
                let slcType = SliceType::new (s.getLoc (), inner, isMutable-> true);
                
                SliceValue::new (
                    s.getLoc (),
                    slcType,
                    StringValue::new (s.getLoc (), arrType, c8Val-> value_c8, c32Val-> value_c32, len)) 
            }
        }
        
    }
        
    /**
     * ================================================================================
     * ================================================================================
     * =========================             VAR              =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * @params: 
     *   - context: the context of the validation
     *   - v: the var to validate
     * @throws: &ErrorMsg if the var is not found
     * @returns: a value
     */
    def validateVar (self, dmut context : &Validator, v : &VarExpr)-> &Value
        throws &ErrorMsg
    {
        let value = context:.getLocal (v.getLoc (), v.getLoc ().str ());
        match value {
            NoneValue () => return self.validateVarGlobal (alias context, v);
            protoV : &ProtoVarValue => {
                return VarRefValue::new (v.getLoc (), protoV.getLoc (), protoV.getType (), protoV.isMutable (), protoV.getUniqId (), isSelf-> protoV.isSelf (), isReference-> protoV.isReference ());
            }
            vdecl : &VarDeclValue => {
                match vdecl.getType () {
                    LambdaType () => {
                        return VarRefValue::new (v.getLoc (), vdecl.getLoc (), vdecl.getType (), value-> vdecl.getValue (), vdecl.isMutable (), vdecl.getUniqId (), isSelf-> false, isReference-> false);
                    }
                    _ => {
                        if (vdecl.isMutable ()) {
                            return VarRefValue::new (v.getLoc (), vdecl.getLoc (), vdecl.getType (), vdecl.isMutable (), vdecl.getUniqId (), isSelf-> false, isReference-> false);
                        } else {
                            return VarRefValue::new (v.getLoc (), vdecl.getLoc (), vdecl.getType (), vdecl.isMutable (), vdecl.getUniqId (), isSelf-> false, value-> vdecl.getValue (), isReference-> false);
                        }
                    }
                }
            }
            s : &StructFieldAccessValue => { // Closure
                return s;
            }
            vl : &Value => { // Directly inserted a value, for example in Enum validation
                return vl;
            }
        }
    } 
     
    
    /**
     * Validate a var reference that was not found locally, and then must be searched in global symbols
     * @params: 
     *     - context: the context of the validation
     *     - v: the variable to search
     * @returns: a value containing the references to the global variable (multsym is possible)
     * @throws: &ErrorMsg, the variable refers to nothing
     */
    def validateVarGlobal (self, dmut context : &Validator, v : &VarExpr)-> &Value
        throws &ErrorMsg
    {
        let dmut syms = context:.getGlobal (v.getLoc ().str ());
        if (syms.len == 0us) {
            throw context:.createGlobalVarError (v.getLoc (), v.getLoc ().str ());
        } else {
            { 
                return self.validateMultSymbols (v.getLoc (), alias context, alias syms);
            } catch {
                err : &ErrorMsg => throw ErrorMsg::fatal (v.getLoc (), format (ValidateErrorMessage::UNDEF_VAR, v.getLoc ().str ()), notes-> [err]);        
            }
        }
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================          MULT SYMS           =========================
     * ================================================================================
     * ================================================================================
     */
    
    /**
     * Transform symbol references into a single value
     * @params:
     *   - loc: the location of the symbol ref
     *   - context: the context of the validation
     *   - syms: the list of symbols
     * @returns: a value containing multiple symbols (&MultSymValue), or a single one (&Value)
     * @throws: 
     *   - &ErrorMsg: if the transformation fails
     */
    pub def validateMultSymbols (self, loc : &Word, dmut context : &Validator, dmut syms : [&Symbol])-> &Value
        throws &ErrorMsg
    {
        let dmut res = Vec!{&Value}::new ();
        let dmut errors = Vec!{&ErrorMsg}::new ();
        let dmut typeErrors = Vec!{&ErrorMsg}::new ();
        for i in 0us .. syms.len {
            context:.pushReferent (alias syms [i]);
            {
                match ref syms [i] {
                    dmut f : &FunctionSymbol => {
                        if (!f.isMethod ()) 
                            res:.push (context:.getFunctionValidator ().validateFuncPrototype (alias context, alias f));
                    }
                    c : &ConstructorSymbol => {
                        typeErrors:.push (ErrorMsg::fatal (c.getLoc (), format (ValidateErrorMessage::USE_AS_VALUE, c)));
                    }
                    m : &ModuleSymbol => {
                        res:.push (ModuleRefValue::new (loc, m));
                    }
                    dmut a : &AkaSymbol => { // Aka are sometimes types, there is a special function to handle that
                        self.validateAkaSymbolMultSym (loc, alias context, alias a, alias res, alias typeErrors);
                    }
                    dmut t : &TemplateSymbol => { // At this point there is no way to determine if it is a type or a value
                        res:.push (TemplateRefValue::new (loc, t));
                    }
                    dmut c : &ClassSymbol => { // class are types
                        {
                            let type = context:.getClassValidator ():.validate (alias context, alias c, inModule-> false);
                            typeErrors:.push (ErrorMsg::fatal (loc, format (ValidateErrorMessage::USE_AS_VALUE, type)));
                        } catch { err : &ErrorMsg => { typeErrors:.push (err); } }
                    } 
                    dmut s : &StructSymbol => { // struct are also types
                        {
                            let type = context:.getStructValidator ().validate (alias context, alias s);
                            typeErrors:.push (ErrorMsg::fatal (loc, format (ValidateErrorMessage::USE_AS_VALUE, type)));
                        } catch { err : &ErrorMsg => { typeErrors:.push (err); } }
                    } 
                    dmut tr : &TraitSymbol => { // Traits are also types
                        {
                            let type = context:.getTraitValidator ().validate (alias context, alias tr);
                            typeErrors:.push (ErrorMsg::fatal (loc, format (ValidateErrorMessage::USE_AS_VALUE, type)));
                        } catch { err : &ErrorMsg => { typeErrors:.push (err); } }
                    }
                    dmut en : &EnumSymbol => { // Enum are also types
                        {
                            let type = context:.getEnumValidator ().validate (alias context, alias en);
                            typeErrors:.push (ErrorMsg::fatal (loc, format (ValidateErrorMessage::USE_AS_VALUE, type)));
                        } catch { err : &ErrorMsg => { typeErrors:.push (err); } }
                    }                
                    _ => {
                        println ("TODO : ", (syms [i])::typeinfo.name);
                        __pragma!panic ();
                    }
                }
            } catch {
                err : &ErrorMsg => {
                    errors:.push (err);
                }
            }
            
            context:.popReferent ();
        }

        // There are errors in value validation
        if (errors.len () != 0us) throw ErrorMsg::list (errors[]);

        if (res.len () == 1us) { 
            res[][0us]
        } else {
            if (res.len () == 0us) { // There are no values
                if (typeErrors.len () != 0us) throw ErrorMsg::list (typeErrors[]); // It has to be because of type error
                else  __pragma!panic ();                
            }
            
            let prettyStr = self.createPrettyStringMultSym (res[]);
            cast!{&Value} (MultSymValue::new (loc, res[], prettyStr-> prettyStr))
        }
    }

    /**
     * @returns: a pretty string refereing to the content of 'values'
     */
    def createPrettyStringMultSym (self, values : [&Value])-> [c8] {            
        let dmut set = HashSet!{[c8]}::new ();
        for i in values {
            set:.insert (format ("%", i));
        }
        
        let dmut stream = StringStream::new ();
        if (set.len () == 1us) { stream:.write (set[][0us]); }
        else {
            stream:.write ("{"s8);
            let mut i = 0us;
            for val in set {
                if (i != set.len () - 1us && i == 2us) stream:.write (", ...");
                else if (i == set.len () - 1us || i < 2us) {
                    if i != 0us { stream:.write (", "s8); }
                    stream:.write (val);
                }
                i += 1us;
            }
            stream:.write ("}"s8);
        }
        
        stream[]
    }
    
    /**
     * Aka symbol may refer to types, or to values
     * In order to show the correct error, we should try both validation
     * @params: 
     *   - loc: the location of the symbol reference
     *   - context: the context of the validation
     *   - sym: the symbol to validate
     * @throws: 
     *   - &ErrorMsg: if the aka is malformed (but not a type)
     * @returns: 
     *   - res: add the value to the vec
     *   - typeErrors: add an error, if the aka is a type (but not malformed)
     */
    def validateAkaSymbolMultSym (self, loc : &Word, dmut context : &Validator, dmut sym : &AkaSymbol, dmut res : &Vec!{&Value}, dmut typeErrors : &Vec!{&ErrorMsg})
        throws &ErrorMsg
    {
        {
            res:.push (context:.getAkaValidator ().validateValue (alias context, alias sym));
        } catch {
            err : &ErrorMsg => { // There are two possibilities 
                {
                    let type = context:.getAkaValidator ().validateType (alias context, alias sym); // 1) its a type
                    typeErrors:.push (ErrorMsg::fatal (loc, format (ValidateErrorMessage::USE_AS_VALUE, type))); // Then we add no value, but add an error in typeErrors
                } catch { // 2) it is just malformed
                    _ => throw err;
                }
            }
        }
    }
    
}
