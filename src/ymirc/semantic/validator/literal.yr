mod ymirc::semantic::validator::literal;

import ymirc::semantic::validator::visitor;
import ymirc::semantic::validator::errors;
import ymirc::syntax::declaration::protection;
import ymirc::syntax::expression::_;
import ymirc::syntax::declaration::_;
import ymirc::semantic::symbol::_;
import ymirc::semantic::declarator::visitor;


import ymirc::semantic::generator::_;
import ymirc::errors::_;
import ymirc::utils::format;
import ymirc::lexing::word;
import ymirc::syntax::keys;
import ymirc::lexing::tokens;


import std::collection::set;
import std::collection::vec;
import std::io, std::fs::path;

/**
 * The literal validator is the class responsible for literal expression validation
 */
pub class LiteralValidator {

    /**
     * Create a new empty validator
     */
    pub self () {}    

    
    /**
     * Validate a literal expression
     * @params: 
     *  - context: the context of the validation
     *  - lit: the literal to validate
     * @throws: &ErrorMsg, if the validation failed
     * @returns: a value
     */
    pub def validate (self, dmut context : &Validator, lit : &LiteralExpr)-> &Value
        throws &ErrorMsg
    {
        match lit {
            b : &BoolExpr => return self.validateBool (alias context, b);
            n : &NullExpr => return self.validateNull (alias context, n);
            d : &DollarExpr => return self.validateDollar (alias context, d);
            i : &IgnoreExpr => return self.validateIgnore (alias context, i);
            u : &UnitExpr => return self.validateUnit (alias context, u);
            f : &FixedExpr => return self.validateInt (alias context, f);
            f : &FloatExpr => return self.validateFloat (alias context, f);
            c : &CharExpr => return self.validateChar (alias context, c);
            s : &StringExpr => return self.validateString (alias context, s);
            v : &VarExpr => return self.validateVar (alias context, v);
            _ => {
                println ("Unknown literal : ", lit::typeinfo.name);
                __pragma!panic ();
            }
        }
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================           SIMPLES            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * @params: 
     *   - _ : the context of the validation
     *   - b: the bool expression to validate
     * @returns: a bool value
     */
    def validateBool (self, dmut _ : &Validator, b : &BoolExpr)-> &Value {
        BoolValue::new (b.getLoc (), b.getLoc () == Keys::TRUE)
    }


    /**
     * @params:
     *   - _: the context of the validation
     *   - n: the null expr to validate
     * @returns: a null value
     */
    def validateNull (self, dmut _ : &Validator, n : &NullExpr)-> &Value {
        NullValue::new (n.getLoc ())
    }

    /**
     * @params: 
     *   - _: the context of the validation
     *   - u: the unit expression to validate
     * @returns: a unit value
     */
    def validateUnit (self, dmut _ : &Validator, u : &UnitExpr)-> &Value {
        UnitValue::new (loc-> u.getLoc ())
    }

    /**
     * @params: 
     *   - _: the context of the validation
     *   - i: the ignore expression to validate
     * @returns: a unit value
     */
    def validateIgnore (self, dmut _ : &Validator, i : &IgnoreExpr)-> &Value {
        UnitValue::new (loc-> i.getLoc ())
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================            DOLLAR            =========================
     * ================================================================================
     * ================================================================================
     */

    
    /**
     * Validate a dollar expression
     * @params:
     *   - context: the context of the validation
     *   - d: the dollar expression
     * @returns: a value
     * @throws: &ErrorMsg if we are not in a dollar context
     */
    def validateDollar (self, dmut context : &Validator, d : &DollarExpr)-> &Value
        throws &ErrorMsg
    {
        context;
        d;
        __pragma!fake_throw (&ErrorMsg);
        __pragma!panic ();
    }


    /**
     * ================================================================================
     * ================================================================================
     * =========================         FLOAT / INT          =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * @params:
     *   - _: the context of the validation
     *   - f: the expression to validate
     * @returns: a float value
     */
    def validateFloat (self, dmut _ : &Validator, f : &FloatExpr)-> &Value
        throws &ErrorMsg
    {
        import std::conv;
        
        let dmut stream = StringStream::new ();
        self.removeUnders (f.getPrePart ().str (), alias stream, default-> "0"s8);
        stream:.write ('.'c8);
        self.removeUnders (f.getDecPart ().str (), alias stream, default-> "0"s8);

        {
            if (f.getSuffix () == FloatSuffixes::FLOAT) {
                FloatValue::new (f.getLoc (), 
                                 FloatType::new (f.getLoc (), size-> 32u16),
                                 f-> stream[].to!f32 ())
            } else {
                FloatValue::new  (f.getLoc (), 
                                  FloatType::new (f.getLoc (), size-> 64u16),
                                  d-> stream[].to!f64 ())
            }
        } catch {
            _ : &CastFailure => {
                throw ErrorMsg::fatal (f.getLoc (), format (ValidateErrorMessage::MALFORMED_FLOAT_LITERAL, stream[]));
            }
        }
        
    }

    /**
     * @params:
     *   - _: the context of the validation
     *   - f: the expression to validate
     * @returns: a int value
     */
    def validateInt (self, dmut _ : &Validator, f : &FixedExpr)-> &Value
        throws &ErrorMsg
    {
        import std::conv;
        
        let dmut stream = StringStream::new ();
        self.removeUnders (f.getLoc ().str (), alias stream, default-> "0"s8);

        let type = match f.getSuffix ().str () {
            FixedSuffixes::U8 => { IntType::new (f.getLoc (), size-> 8u16, signed-> false) }
            FixedSuffixes::U16 => { IntType::new (f.getLoc (), size-> 16u16, signed-> false) }
            FixedSuffixes::U32 => { IntType::new (f.getLoc (), size-> 32u16, signed-> false) }
            FixedSuffixes::U64 => { IntType::new (f.getLoc (), size-> 64u16, signed-> false) }
            FixedSuffixes::USIZE => { IntType::new (f.getLoc (), size-> 0u16, signed-> false) }
            FixedSuffixes::I8 => { IntType::new (f.getLoc (), size-> 8u16, signed-> true) }
            FixedSuffixes::I16 => { IntType::new (f.getLoc (), size-> 16u16, signed-> true) }
            FixedSuffixes::I64 => { IntType::new (f.getLoc (), size-> 64u16, signed-> true) }
            FixedSuffixes::ISIZE => { IntType::new (f.getLoc (), size-> 0u16, signed-> true) }
            _ => { IntType::new (f.getLoc (), size-> 32u16, signed-> true) }                
        };

        {
            if (stream[].len > 2us && stream[][0us .. 2us] == "0x"s8) {
                IntValue::new (f.getLoc (), type, stream[].to!{usize, "x"} ())
            } else if (stream[].len > 2us && stream[][0us .. 2us] == "0b"s8) {
                IntValue::new (f.getLoc (), type, stream[].to!{usize, "b"} ())
            } else if (stream[].len > 2us && stream[][0us .. 2us] == "0o"s8) {
                IntValue::new (f.getLoc (), type, stream[].to!{usize, "o"} ())
            } else {
                IntValue::new (f.getLoc (), type, stream[].to!{usize} ())
            }
        } catch {
            _ : &CastFailure => {
                throw ErrorMsg::fatal (f.getLoc (), format (ValidateErrorMessage::MALFORMED_INT_LITERAL, stream[]));
            } 
        }
    }
    
    /**
     * Write a string literal into the stream, except the '_'
     * @params: 
     *    - str: the string value to write
     *    - stream: the stream to fill
     *    - default: the value to write in the stream if nothing was printed from str
     */
    def removeUnders (self, str : [c8], dmut stream : &StringStream, default : [c8] = ""s8) {
        let mut wrote = false;
        for i in str {
            if (i != '_'c8) {
                wrote = true;
                stream:.write (i);
            }
        }

        if (!wrote) stream:.write (default);
    }


    /**
     * ================================================================================
     * ================================================================================
     * =========================        CHAR / STRING         =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * @params: 
     *   - _: the context of the validation
     *   - c: the char to validate
     * @throws: &ErrorMsg if the char is malformed
     * @returns: a char value
     */
    def validateChar (self, dmut _ : &Validator, c : &CharExpr)-> &Value
        throws &ErrorMsg
    {
        c;
        __pragma!fake_throw (&ErrorMsg);
        __pragma!panic ();
    }

    /**
     * @params: 
     *   - _: the context of the validation
     *   - s: the string to validate
     * @throws: &ErrorMsg if the string is malformed
     * @returns: a string value
     */
    def validateString (self, dmut _ : &Validator, s : &StringExpr)-> &Value
        throws &ErrorMsg
    {
        s;
        __pragma!fake_throw (&ErrorMsg);
        __pragma!panic ();
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================             VAR              =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * @params: 
     *   - context: the context of the validation
     *   - v: the var to validate
     * @throws: &ErrorMsg if the var is not found
     * @returns: a value
     */
    def validateVar (self, dmut context : &Validator, v : &VarExpr)-> &Value
        throws &ErrorMsg
    {
        let value = context:.getLocal (v.getLoc ().str ());
        match value {
            NoneValue () => return self.validateVarGlobal (alias context, v);
            protoV : &ProtoVarValue => {
                return VarRefValue::new (v.getLoc (), protoV.getLoc (), protoV.getType (), protoV.isMutable (), protoV.getUniqId (), isSelf-> protoV.isSelf ());
            }
            _ => {
                println ("Unknown var type : ", value::typeinfo.name);
                __pragma!panic ();
            }
        }
    }
    
    /**
     * Validate a var reference that was not found locally, and then must be searched in global symbols
     * @params: 
     *     - context: the context of the validation
     *     - v: the variable to search
     * @returns: a value containing the references to the global variable (multsym is possible)
     * @throws: &ErrorMsg, the variable refers to nothing
     */
    def validateVarGlobal (self, dmut context : &Validator, v : &VarExpr)-> &Value
        throws &ErrorMsg
    {
        let dmut syms = context:.getGlobal (v.getLoc ().str ());
        if (syms.len == 0us) {
            let prvSyms = context:.getGlobalPrivate (v.getLoc ().str ());
            let dmut notes = Vec!{&ErrorMsg}::new ();
            for s in prvSyms {
                notes:.push (ErrorMsg::note (s.getLoc (), oneLine-> true, format (ValidateErrorMessage::PRIVATE_IN_THIS_CONTEXT, s.getPath ().toStr (sep-> Tokens::DCOLON))));
            }
            
            if (prvSyms.len == 0us) {
                let closeSyms = context:.getCloseGlobal (v.getLoc ().str (), distance-> 2us);
                let dmut used = HashSet!{&Path}::new ();
                for s in closeSyms {
                    if (s.getPath () !in used) {
                        notes:.push (ErrorMsg::note (s.getLoc (), oneLine-> true, format (ValidateErrorMessage::MAYBE_WAS_MEANT, s.getPath ().toStr (sep-> Tokens::DCOLON))));
                        used:.insert (s.getPath ());
                    }
                }   
            }
            
            throw ErrorMsg::fatal (v.getLoc (), format (ValidateErrorMessage::UNDEF_VAR, v.getLoc ().str ()), notes-> notes[]);        
        } else {
            return self.validateMultSymbols (v.getLoc (), alias context, alias syms);
        }
    }

    /**
     * Transform symbol references into a single value
     * @params:
     *   - context: the context of the validation
     *   - syms: the list of symbols
     */
    def validateMultSymbols (self, loc : &Word, dmut context : &Validator, dmut syms : [&Symbol])-> &Value
        throws &ErrorMsg
    {
        let dmut res = Vec!{&Generator}::new ();
        for i in 0us .. syms.len {
            match ref syms [i] {
                dmut a : &AkaSymbol => {
                    res:.push (context:.getAkaValidator ().validate (alias context, alias a));
                }
                dmut c : &ClassSymbol => {
                    res:.push (context:.getClassValidator ().validate (alias context, alias c));
                }
                dmut f : &FunctionSymbol => {
                    if (!f.isMethod ())
                        res:.push (context:.getFunctionValidator ().validatePrototype (alias context, alias f));
                }
                dmut c : &ConstructorSymbol => {
                    res:.push (context:.getFunctionValidator ().validatePrototype (alias context, alias c));
                }
                m : &ModuleSymbol => {
                    res:.push (ModuleRefValue::new (loc, m));
                }
                dmut s : &StructSymbol => {
                    res:.push (context:.getStructValidator ().validate (alias context, alias s));
                }
                dmut tr : &TraitSymbol => {
                    res:.push (context:.getTraitValidator ().validate (alias context, alias tr));
                }
                dmut t : &TemplateSymbol => {
                    res:.push (context:.getTemplateValidator ().validate (alias context, alias t));
                }
                _ => {
                    println ("TODO : ", (syms [i])::typeinfo.name);
                    __pragma!panic ();
                }
            }
        }

        __pragma!panic ();
    }
}
