mod ymirc::semantic::validator::literal;

import ymirc::semantic::validator::visitor;
import ymirc::semantic::validator::errors;
import ymirc::syntax::declaration::protection;
import ymirc::syntax::expression::_;
import ymirc::syntax::declaration::_;
import ymirc::semantic::symbol::_;
import ymirc::semantic::declarator::visitor;
import ymirc::semantic::validator::utf;


import ymirc::semantic::generator::_;
import ymirc::errors::_;
import ymirc::utils::format;
import ymirc::lexing::word;
import ymirc::syntax::keys;
import ymirc::lexing::tokens;


import std::collection::set;
import std::collection::vec;
import std::io, std::fs::path;

/**
 * The literal validator is the class responsible for literal expression validation
 */
pub class LiteralValidator {

    /// The visitor used to validate literal strings
    let _utfVisitor = UtfVisitor::new ();
    
    /**
     * Create a new empty validator
     */
    pub self () {}    

    
    /**
     * Validate a literal expression
     * @params: 
     *  - context: the context of the validation
     *  - lit: the literal to validate
     * @throws: &ErrorMsg, if the validation failed
     * @returns: a value
     */
    pub def validate (self, dmut context : &Validator, lit : &LiteralExpr)-> &Value
        throws &ErrorMsg
    {
        match lit {
            b : &BoolExpr => return self.validateBool (alias context, b);
            n : &NullExpr => return self.validateNull (alias context, n);
            d : &DollarExpr => return self.validateDollar (alias context, d);
            i : &IgnoreExpr => return self.validateIgnore (alias context, i);
            u : &UnitExpr => return self.validateUnit (alias context, u);
            f : &FixedExpr => return self.validateInt (alias context, f);
            f : &FloatExpr => return self.validateFloat (alias context, f);
            c : &CharExpr => return self.validateChar (alias context, c);
            s : &StringExpr => return self.validateString (alias context, s);
            v : &VarExpr => return self.validateVar (alias context, v);
            _ => {
                println ("Unknown literal : ", lit::typeinfo.name);
                __pragma!panic ();
            }
        }
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================           SIMPLES            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * @params: 
     *   - _ : the context of the validation
     *   - b: the bool expression to validate
     * @returns: a bool value
     */
    def validateBool (self, dmut _ : &Validator, b : &BoolExpr)-> &Value {
        BoolValue::new (b.getLoc (), b.getLoc () == Keys::TRUE)
    }


    /**
     * @params:
     *   - _: the context of the validation
     *   - n: the null expr to validate
     * @returns: a null value
     */
    def validateNull (self, dmut _ : &Validator, n : &NullExpr)-> &Value {
        NullValue::new (n.getLoc ())
    }

    /**
     * @params: 
     *   - _: the context of the validation
     *   - u: the unit expression to validate
     * @returns: a unit value
     */
    def validateUnit (self, dmut _ : &Validator, u : &UnitExpr)-> &Value {
        UnitValue::new (loc-> u.getLoc ())
    }

    /**
     * @params: 
     *   - _: the context of the validation
     *   - i: the ignore expression to validate
     * @returns: a unit value
     */
    def validateIgnore (self, dmut _ : &Validator, i : &IgnoreExpr)-> &Value {
        UnitValue::new (loc-> i.getLoc ())
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================            DOLLAR            =========================
     * ================================================================================
     * ================================================================================
     */

    
    /**
     * Validate a dollar expression
     * @params:
     *   - context: the context of the validation
     *   - d: the dollar expression
     * @returns: a value
     * @throws: &ErrorMsg if we are not in a dollar context
     */
    def validateDollar (self, dmut context : &Validator, d : &DollarExpr)-> &Value
        throws &ErrorMsg
    {
        context;
        d;
        __pragma!fake_throw (&ErrorMsg);
        __pragma!panic ();
    }


    /**
     * ================================================================================
     * ================================================================================
     * =========================         FLOAT / INT          =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * @params:
     *   - _: the context of the validation
     *   - f: the expression to validate
     * @returns: a float value
     */
    def validateFloat (self, dmut _ : &Validator, f : &FloatExpr)-> &Value
        throws &ErrorMsg
    {
        import std::conv;
        
        let dmut stream = StringStream::new ();
        self.removeUnders (f.getPrePart ().str (), alias stream, default-> "0"s8);
        stream:.write ('.'c8);
        self.removeUnders (f.getDecPart ().str (), alias stream, default-> "0"s8);

        {
            if (f.getSuffix () == FloatSuffixes::FLOAT) {
                FloatValue::new (f.getLoc (), 
                                 FloatType::new (f.getLoc (), size-> 32u16),
                                 f-> stream[].to!f32 ())
            } else {
                FloatValue::new  (f.getLoc (), 
                                  FloatType::new (f.getLoc (), size-> 64u16),
                                  d-> stream[].to!f64 ())
            }
        } catch {
            _ : &CastFailure => {
                throw ErrorMsg::fatal (f.getLoc (), format (ValidateErrorMessage::MALFORMED_FLOAT_LITERAL, stream[]));
            }
        }
        
    }

    /**
     * @params:
     *   - _: the context of the validation
     *   - f: the expression to validate
     * @returns: a int value
     */
    def validateInt (self, dmut _ : &Validator, f : &FixedExpr)-> &Value
        throws &ErrorMsg
    {
        import std::conv;
        
        let dmut stream = StringStream::new ();
        self.removeUnders (f.getLoc ().str (), alias stream, default-> "0"s8);

        let type = match f.getSuffix ().str () {
            FixedSuffixes::U8 => { IntType::new (f.getLoc (), size-> 8u16, signed-> false) }
            FixedSuffixes::U16 => { IntType::new (f.getLoc (), size-> 16u16, signed-> false) }
            FixedSuffixes::U32 => { IntType::new (f.getLoc (), size-> 32u16, signed-> false) }
            FixedSuffixes::U64 => { IntType::new (f.getLoc (), size-> 64u16, signed-> false) }
            FixedSuffixes::USIZE => { IntType::new (f.getLoc (), size-> 0u16, signed-> false) }
            FixedSuffixes::I8 => { IntType::new (f.getLoc (), size-> 8u16, signed-> true) }
            FixedSuffixes::I16 => { IntType::new (f.getLoc (), size-> 16u16, signed-> true) }
            FixedSuffixes::I64 => { IntType::new (f.getLoc (), size-> 64u16, signed-> true) }
            FixedSuffixes::ISIZE => { IntType::new (f.getLoc (), size-> 0u16, signed-> true) }
            _ => { IntType::new (f.getLoc (), size-> 32u16, signed-> true) }                
        };

        {
            if (stream[].len > 2us && stream[][0us .. 2us] == "0x"s8) {
                IntValue::new (f.getLoc (), type, stream[].to!{usize, "x"} ())
            } else if (stream[].len > 2us && stream[][0us .. 2us] == "0b"s8) {
                IntValue::new (f.getLoc (), type, stream[].to!{usize, "b"} ())
            } else if (stream[].len > 2us && stream[][0us .. 2us] == "0o"s8) {
                IntValue::new (f.getLoc (), type, stream[].to!{usize, "o"} ())
            } else {
                IntValue::new (f.getLoc (), type, stream[].to!{usize} ())
            }
        } catch {
            _ : &CastFailure => {
                throw ErrorMsg::fatal (f.getLoc (), format (ValidateErrorMessage::MALFORMED_INT_LITERAL, stream[]));
            } 
        }
    }
    
    /**
     * Write a string literal into the stream, except the '_'
     * @params: 
     *    - str: the string value to write
     *    - stream: the stream to fill
     *    - default: the value to write in the stream if nothing was printed from str
     */
    def removeUnders (self, str : [c8], dmut stream : &StringStream, default : [c8] = ""s8) {
        let mut wrote = false;
        for i in str {
            if (i != '_'c8) {
                wrote = true;
                stream:.write (i);
            }
        }

        if (!wrote) stream:.write (default);
    }


    /**
     * ================================================================================
     * ================================================================================
     * =========================        CHAR / STRING         =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * @params: 
     *   - _: the context of the validation
     *   - c: the char to validate
     * @throws: &ErrorMsg if the char is malformed
     * @returns: a char value
     */
    def validateChar (self, dmut _ : &Validator, c : &CharExpr)-> &Value
        throws &ErrorMsg
    {
        let inner : &Type = if (c.getSuffix () == CharSuffixes::UTF8) {
            CharType::new (c.getLoc (), size-> 8u16)
        } else {
            CharType::new (c.getLoc (), size-> 32u16)
        };

        let (value_c8, value_c32, len) = if (c.getSuffix () == CharSuffixes::UTF8) {
            let (v, l) = self._utfVisitor.convertUtf8 (c.getLoc (), c.getSequence ());
            (v, "\u{0}", l)
        } else {
            let (v, l) = self._utfVisitor.convertUtf32 (c.getLoc (), c.getSequence ());
            ("\u{0}"s8, v, l)
        };

        if (len != 1us) {
            throw ErrorMsg::fatal (c.getLoc (), format (ValidateErrorMessage::MALFORMED_CHAR, inner, len));
        }

        CharValue::new (c.getLoc (), inner, c8Val-> value_c8[0], c32Val-> value_c32[0])
    }

    /**
     * @params: 
     *   - _: the context of the validation
     *   - s: the string to validate
     * @throws: &ErrorMsg if the string is malformed
     * @returns: a string value
     */
    def validateString (self, dmut _ : &Validator, s : &StringExpr)-> &Value
        throws &ErrorMsg
    {
        let inner : &Type = if (s.getSuffix () == StringSuffixes::UTF8) {
            CharType::new (s.getLoc (), size-> 8u16)
        } else {
            CharType::new (s.getLoc (), size-> 32u16)
        };

        let (value_c8, value_c32, len) = if (s.getSuffix () == StringSuffixes::UTF8) {
            let (v, l) = self._utfVisitor.convertUtf8 (s.getLoc (), s.getSequence ());
            (v, "", l)
        } else {
            let (v, l) = self._utfVisitor.convertUtf32 (s.getLoc (), s.getSequence ());
            (""s8, v, l)
        };
        
        let arrType = ArrayType::new (s.getLoc (), inner, size-> int::usize (s.getLoc (), len), isMutable-> true);
        let slcType = SliceType::new (s.getLoc (), inner, isMutable-> true);

        AliaserValue::new (
            s.getLoc (),
            slcType,
            StringValue::new (s.getLoc (), arrType, c8Val-> value_c8, c32Val-> value_c32, len)) 
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================             VAR              =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * @params: 
     *   - context: the context of the validation
     *   - v: the var to validate
     * @throws: &ErrorMsg if the var is not found
     * @returns: a value
     */
    def validateVar (self, dmut context : &Validator, v : &VarExpr)-> &Value
        throws &ErrorMsg
    {
        let value = context:.getLocal (v.getLoc ().str ());
        match value {
            NoneValue () => return self.validateVarGlobal (alias context, v);
            protoV : &ProtoVarValue => {
                return VarRefValue::new (v.getLoc (), protoV.getLoc (), protoV.getType (), protoV.isMutable (), protoV.getUniqId (), isSelf-> protoV.isSelf ());
            }
            vdecl : &VarDeclValue => {
                match vdecl.getType () {
                    LambdaType () => {
                        return VarRefValue::new (v.getLoc (), vdecl.getLoc (), vdecl.getType (), value-> vdecl.getValue (), vdecl.isMutable (), vdecl.getUniqId (), isSelf-> false);
                    }
                    _ => {
                        return VarRefValue::new (v.getLoc (), vdecl.getLoc (), vdecl.getType (), vdecl.isMutable (), vdecl.getUniqId (), isSelf-> false);
                    }
                }
            }
            s : &StructAccessValue => { // Closure
                return s;
            }
            _ => {
                println ("Unknown var type : ", value::typeinfo.name);
                __pragma!panic ();
            }
        }
    } 
     
    
    /**
     * Validate a var reference that was not found locally, and then must be searched in global symbols
     * @params: 
     *     - context: the context of the validation
     *     - v: the variable to search
     * @returns: a value containing the references to the global variable (multsym is possible)
     * @throws: &ErrorMsg, the variable refers to nothing
     */
    def validateVarGlobal (self, dmut context : &Validator, v : &VarExpr)-> &Value
        throws &ErrorMsg
    {
        let dmut syms = context:.getGlobal (v.getLoc ().str ());
        if (syms.len == 0us) {
            let prvSyms = context:.getGlobalPrivate (v.getLoc ().str ());
            let dmut notes = Vec!{&ErrorMsg}::new ();
            for s in prvSyms {
                notes:.push (ErrorMsg::note (s.getLoc (), oneLine-> true, format (ValidateErrorMessage::PRIVATE_IN_THIS_CONTEXT, s.getPath ().toStr (sep-> Tokens::DCOLON))));
            }
            
            if (prvSyms.len == 0us) {
                let closeSyms = context:.getCloseGlobal (v.getLoc ().str (), distance-> 2us);
                let dmut used = HashSet!{&Path}::new ();
                for s in closeSyms {
                    if (s.getPath () !in used) {
                        let p = s.getPath ().parent ().toStr (sep-> Tokens::DCOLON);
                        if (p.len != 0us) {
                            notes:.push (ErrorMsg::note (s.getLoc (), oneLine-> true, format (ValidateErrorMessage::MAYBE_WAS_MEANT_FROM_MOD, s.getPath ().file (), p)));
                        } else
                            notes:.push (ErrorMsg::note (s.getLoc (), oneLine-> true, format (ValidateErrorMessage::MAYBE_WAS_MEANT, s.getPath ().file ())));
                        
                        used:.insert (s.getPath ());
                    }
                }   
            }
            
            throw ErrorMsg::fatal (v.getLoc (), format (ValidateErrorMessage::UNDEF_VAR, v.getLoc ().str ()), notes-> notes[]);        
        } else {
            { 
                return self.validateMultSymbols (v.getLoc (), alias context, alias syms);
            } catch {
                err : &ErrorMsg => throw ErrorMsg::fatal (v.getLoc (), format (ValidateErrorMessage::UNDEF_VAR, v.getLoc ().str ()), notes-> [err]);        
            }
        }
    }

    /**
     * Transform symbol references into a single value
     * @params:
     *   - context: the context of the validation
     *   - syms: the list of symbols
     */
    pub def validateMultSymbols (self, loc : &Word, dmut context : &Validator, dmut syms : [&Symbol])-> &Value
        throws &ErrorMsg
    {
        let dmut res = Vec!{&Value}::new ();
        let dmut errors = Vec!{&ErrorMsg}::new ();
        for i in 0us .. syms.len {
            {
                context:.pushReferent (alias syms [i]);
                match ref syms [i] {
                    dmut a : &AkaSymbol => {
                        res:.push (context:.getAkaValidator ().validate (alias context, alias a));
                    }
                    dmut c : &ClassSymbol => {
                        res:.push (context:.getClassValidator ().validate (alias context, alias c));
                    }
                    dmut f : &FunctionSymbol => {
                        if (!f.isMethod ())
                            res:.push (context:.getFunctionValidator ().validatePrototype (alias context, alias f));
                    }
                    dmut c : &ConstructorSymbol => {
                        res:.push (context:.getFunctionValidator ().validatePrototype (alias context, alias c));
                    }
                    m : &ModuleSymbol => {
                        res:.push (ModuleRefValue::new (loc, m));
                    }
                    dmut s : &StructSymbol => {
                        res:.push (context:.getStructValidator ().validate (alias context, alias s));
                    }
                    dmut tr : &TraitSymbol => {
                        res:.push (context:.getTraitValidator ().validate (alias context, alias tr));
                    }
                    dmut t : &TemplateSymbol => {
                        res:.push (context:.getTemplateValidator ().validate (alias context, alias t));
                    }
                    _ => {
                        println ("TODO : ", (syms [i])::typeinfo.name);
                        __pragma!panic ();
                    }
                }
            } exit {
                context:.popReferent ();
            } catch {
                err : &ErrorMsg => {
                    errors:.push (err);
                }
            }
        }

        if (errors.len () != 0us) throw ErrorMsg::list (errors[]);

        if (res.len () == 1us) {
            res[][0us]
        } else {
            if (res.len () == 0us) { println (syms); __pragma!panic (); }
            cast!{&Value} (MultSymValue::new (loc, res[], prettyStr-> loc.str ()))
        }
    }
}
