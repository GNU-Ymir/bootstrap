mod ymirc::semantic::validator::literal;

import ymirc::semantic::validator::visitor;
import ymirc::semantic::validator::errors;
import ymirc::syntax::declaration::protection;
import ymirc::syntax::expression::_;
import ymirc::syntax::declaration::_;
import ymirc::semantic::symbol::_;
import ymirc::semantic::declarator::visitor;
import ymirc::semantic::validator::utf;


import ymirc::semantic::generator::_;
import ymirc::errors::_;
import ymirc::utils::format;
import ymirc::utils::bigint, ymirc::utils::bigfloat;
import ymirc::lexing::word;
import ymirc::syntax::keys;
import ymirc::lexing::tokens;


import std::collection::set;
import std::collection::vec;
import std::io, std::fs::path;

/**
 * The literal validator is the class responsible for literal expression validation
 */
pub class LiteralValidator {

    /// The visitor used to validate literal strings
    let _utfVisitor = UtfVisitor::new ();
    
    /**
     * Create a new empty validator
     */
    pub self () {}    

    
    /**
     * Validate a literal expression
     * @params: 
     *  - context: the context of the validation
     *  - lit: the literal to validate
     *  - forceType: the force type
     * @throws: &ErrorMsg, if the validation failed
     * @returns: a value
     */
    pub def validate (self, dmut context : &Validator, lit : &LiteralExpr, forceType : &Type = NONE_TYPE)-> &Value
        throws &ErrorMsg
    {
        match lit {
            b : &BoolExpr => return self.validateBool (alias context, b);
            n : &NullExpr => return self.validateNull (alias context, n);
            d : &DollarExpr => return self.validateDollar (alias context, d);
            i : &IgnoreExpr => return self.validateIgnore (alias context, i);
            u : &UnitExpr => return self.validateUnit (alias context, u);
            f : &FixedExpr => return self.validateInt (alias context, f);
            f : &FloatExpr => return self.validateFloat (alias context, f);
            c : &CharExpr => return self.validateChar (alias context, c);
            s : &StringExpr => return self.validateString (alias context, s, forceType-> forceType);
            v : &VarExpr => return self.validateVar (alias context, v);
            _ => {
                println ("Unknown literal : ", lit::typeinfo.name);
                __pragma!panic ();
            }
        }
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================           SIMPLES            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * @params: 
     *   - _ : the context of the validation
     *   - b: the bool expression to validate
     * @returns: a bool value
     */
    def validateBool (self, dmut _ : &Validator, b : &BoolExpr)-> &Value {
        BoolValue::new (b.getLoc (), b.getLoc () == Keys::TRUE)
    }


    /**
     * @params:
     *   - _: the context of the validation
     *   - n: the null expr to validate
     * @returns: a null value
     */
    def validateNull (self, dmut _ : &Validator, n : &NullExpr)-> &Value {
        NullValue::new (n.getLoc ())
    }

    /**
     * @params: 
     *   - _: the context of the validation
     *   - u: the unit expression to validate
     * @returns: a unit value
     */
    def validateUnit (self, dmut _ : &Validator, u : &UnitExpr)-> &Value {
        UnitValue::new (loc-> u.getLoc ())
    }

    /**
     * @params: 
     *   - _: the context of the validation
     *   - i: the ignore expression to validate
     * @returns: a unit value
     */
    def validateIgnore (self, dmut _ : &Validator, i : &IgnoreExpr)-> &Value {
        UnitValue::new (loc-> i.getLoc ())
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================            DOLLAR            =========================
     * ================================================================================
     * ================================================================================
     */

    
    /**
     * Validate a dollar expression
     * @params:
     *   - context: the context of the validation
     *   - d: the dollar expression
     * @returns: a value
     * @throws: &ErrorMsg if we are not in a dollar context
     */
    def validateDollar (self, dmut context : &Validator, d : &DollarExpr)-> &Value
        throws &ErrorMsg
    {
        match context:.getCurrentDollarContext () {
            Ok (val : &Value) => {
                self.validateDollarValue (alias context, d.getLoc (), val)
            }
            _ => throw ErrorMsg::fatal (d.getLoc (), ValidateErrorMessage::DOLLAR_OUTSIDE_CONTEXT);
        }
    }

    /**
     * Validate a dollar operator on a value
     * @params:
     *    - context: the context of the validation
     *    - loc: the location of the dollar operator
     *    - val: the value that is opDollar accessed
     * @returns: the result of opDollar on the value
     * @throws:
     *    - &ErrorMsg: if the value cannot be opDollared
     */
    def validateDollarValue (self, dmut _ : &Validator, loc : &Word, val : &Value)-> &Value
        throws &ErrorMsg
    {
        match val.getType () {
            _ : &SliceType => {
                let sizeType = IntType::new (loc, size-> 0u16, signed-> false);
                StructFieldAccessValue::new (loc, sizeType, val, SliceKeys::LEN)
            }
            array : &ArrayType => {
                array.getSize ()
            }
            _ => throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_DOLLAR_OP, val.getType ()));
        }
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================         FLOAT / INT          =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * @params:
     *   - context: the context of the validation
     *   - f: the expression to validate
     * @returns: a float value
     */
    def validateFloat (self, dmut context : &Validator, f : &FloatExpr)-> &Value
        throws &ErrorMsg
    {
        import std::conv;

        if (f.isHex ()) return self.validateFloatHex (alias context, f);

        let dmut stream = StringStream::new ();
        self.removeUnders (f.getPrePart ().str (), alias stream, default-> "0"s8);
        stream:.write ('.'c8);
        self.removeUnders (f.getDecPart ().str (), alias stream, default-> "0"s8);

        let exp : &BigFloat =
            if (!f.getExpPart ().isEof ()) {
                {
                    let dmut expStr = StringStream::new ();
                    self.removeUnders (f.getExpPart ().str (), alias expStr, default-> "0"s8);
                    let exp = expStr[].to!{i64} ();
                    if (f.expPartIsPositive ()) {
                        BigFloat::new (10.0) ^^ exp
                    } else {
                        BigFloat::new (10.0) ^^ -exp
                    }
                } catch {
                    e : _ => {
                        println (e);
                        throw ErrorMsg::fatal (f.getLoc (), format (ValidateErrorMessage::MALFORMED_FLOAT_LITERAL, f));
                    }
                }
            } else {
                BigFloat::new (1.0)
            };

        let val = BigFloat::new (stream[]);

        if (f.getSuffix () == FloatSuffixes::F32) {
            FloatValue::new (f.getLoc (),
                             FloatType::new (f.getLoc (), size-> 32u16),
                              val * exp)
        } else if (f.getSuffix () == FloatSuffixes::F64 || f.getSuffix ().isEof ()){
            FloatValue::new  (f.getLoc (),
                              FloatType::new (f.getLoc (), size-> 64u16),
                              val * exp)
        } else if (f.getSuffix () == FloatSuffixes::F80) {
            FloatValue::new  (f.getLoc (),
                              FloatType::new (f.getLoc (), size-> 80u16),
                              val * exp)
        } else {
            FloatValue::new  (f.getLoc (),
                              FloatType::new (f.getLoc (), size-> 0u16),
                              val * exp)
        }
    }

    /**
     * @params:
     *    - context: the context of the validation
     *    - f: the expression to validate
     * @returns: a float value
     * */
    def validateFloatHex (self, dmut _ : &Validator, f : &FloatExpr)-> &Value
        throws &ErrorMsg
    {
        import std::conv;

        let dmut intPart = StringStream::new ();
        let dmut decPart = StringStream::new ();
        let dmut expPart = StringStream::new ();

        self.removeUnders (f.getPrePart ().str ()[2us .. $], alias intPart, default-> "0"s8); // remove 0x
        self.removeUnders (f.getDecPart ().str (), alias decPart, default-> "0"s8);
        self.removeUnders (f.getExpPart ().str (), alias expPart, default-> "0"s8);

        let intPartV = BigFloat::new (BigInt::new (intPart[].to!{usize, 16us} ()));
        let decPartV = BigFloat::new (BigInt::new (decPart[].to!{usize, 16us} ())) * (BigFloat::new (16.0) ^^ -cast!i64 (decPart[].len));
        let expPartV = expPart[].to!{i64} ();

        let exp2 = if (f.expPartIsPositive ()) {
            BigInt::new (2) ^^ expPartV
        } else {
            BigInt::new (2) ^^ -expPartV
        }

        let val = intPartV + decPartV;
        let expVal = BigFloat::new (exp2);

        if (f.getSuffix () == FloatSuffixes::F32) {
            FloatValue::new (f.getLoc (), FloatType::new (f.getLoc (), size-> 32u16), val * expVal)
        } else if (f.getSuffix ().isEof () || f.getSuffix () == FloatSuffixes::F64) {
            FloatValue::new (f.getLoc (), FloatType::new (f.getLoc (), size-> 64u16), val * expVal)
        } else if (f.getSuffix () == FloatSuffixes::F80) {
            FloatValue::new (f.getLoc (), FloatType::new (f.getLoc (), size-> 80u16), val * expVal)
        } else {
            FloatValue::new (f.getLoc (), FloatType::new (f.getLoc (), size-> 0u16), val * expVal)
        }
    } catch {
        _ => throw ErrorMsg::fatal (f.getLoc (), format (ValidateErrorMessage::MALFORMED_FLOAT_LITERAL, f));
    }

    /**
     * @params:
     *   - _: the context of the validation
     *   - f: the expression to validate
     * @returns: a int value
     */
    def validateInt (self, dmut context : &Validator, f : &FixedExpr)-> &Value
        throws &ErrorMsg
    {
        import std::conv;
        
        let dmut stream = StringStream::new ();
        self.removeUnders (f.getLoc ().str (), alias stream, default-> "0"s8);

        let type = match f.getSuffix ().str () {
            FixedSuffixes::U8 => { IntType::new (f.getLoc (), size-> 8u16, signed-> false) }
            FixedSuffixes::U16 => { IntType::new (f.getLoc (), size-> 16u16, signed-> false) }
            FixedSuffixes::U32 => { IntType::new (f.getLoc (), size-> 32u16, signed-> false) }
            FixedSuffixes::U64 => { IntType::new (f.getLoc (), size-> 64u16, signed-> false) }
            FixedSuffixes::USIZE => { IntType::new (f.getLoc (), size-> 0u16, signed-> false) }
            FixedSuffixes::I8 => { IntType::new (f.getLoc (), size-> 8u16, signed-> true) }
            FixedSuffixes::I16 => { IntType::new (f.getLoc (), size-> 16u16, signed-> true) }
            FixedSuffixes::I64 => { IntType::new (f.getLoc (), size-> 64u16, signed-> true) }
            FixedSuffixes::ISIZE => { IntType::new (f.getLoc (), size-> 0u16, signed-> true) }
            _ => { IntType::new (f.getLoc (), size-> 32u16, signed-> true) }                
        };

        let value : usize = {
            if (stream[].len > 2us && stream[][0us .. 2us] == "0x"s8) {
                stream[].to!{usize, "x"} ()
            } else if (stream[].len > 2us && stream[][0us .. 2us] == "0b"s8) {
                stream[].to!{usize, "b"} ()
            } else if (stream[].len > 2us && stream[][0us .. 2us] == "0o"s8) {
                stream[].to!{usize, "o"} ()
            } else {
                stream[].to!{usize} ()
            }
        } catch {
            _ : &CastFailure => {
                throw ErrorMsg::fatal (f.getLoc (), format (ValidateErrorMessage::MALFORMED_INT_LITERAL, stream[]));
            }
        };

        // verify that there is no overflow in the value literal
        self.verifyIntOverflow (alias context, f.getLoc (), type, value);

        IntValue::new (f.getLoc (), type, value)
    }
    
    /**
     * Write a string literal into the stream, except the '_'
     * @params: 
     *    - str: the string value to write
     *    - stream: the stream to fill
     *    - default: the value to write in the stream if nothing was printed from str
     */
    def removeUnders (self, str : [c8], dmut stream : &StringStream, default : [c8] = ""s8) {
        let mut wrote = false;
        for i in str {
            if (i != '_'c8) {
                wrote = true;
                stream:.write (i);
            }
        }

        if (!wrote) stream:.write (default);
    }

    /**
     * Verify that the value 'value' can be put in a variable of type "type" without any overflow
     * @params:
     *    - type: the type of the int
     *    - value: the value that is checked
     * @throws:
     *    - &ErrorMsg: the error to throw if there is an overflow problem
     */
    pub def verifyIntOverflow (self, context : &Validator, loc : &Word, type : &IntType, value : usize)
        throws &ErrorMsg
    {
        let max = context.getCompileTimeInterpreter ().createIntMaxValue (type);
        let min = context.getCompileTimeInterpreter ().createIntMinValue (type);

        if (value > max) {
            throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::OVERFLOW_CAPACITY, type, value, max));
        }

        if (value < min) {
            throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::OVERFLOW_CAPACITY_MIN, type, value, min));
        }
    }

    /**
     * Verify that the value 'value' can be put in a variable of type "type" without any overflow
     * @params:
     *    - type: the type of the int
     *    - value: the value that is checked
     * @throws:
     *    - &ErrorMsg: the error to throw if there is an overflow problem
     */
    pub def verifyIntOverflow (self, context : &Validator, loc : &Word, type : &IntType, value : &BigInt)
        throws &ErrorMsg
    {
        let max = context.getCompileTimeInterpreter ().createIntMaxValue (type);
        let min = context.getCompileTimeInterpreter ().createIntMinValue (type);

        if (value > max) {
            throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::OVERFLOW_CAPACITY, type, value, max));
        }
        if (value < min) {
            throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::OVERFLOW_CAPACITY_MIN, type, value, min));
        }
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================        CHAR / STRING         =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * @params: 
     *   - _: the context of the validation
     *   - c: the char to validate
     * @throws: &ErrorMsg if the char is malformed
     * @returns: a char value
     */
    def validateChar (self, dmut _ : &Validator, c : &CharExpr)-> &Value
        throws &ErrorMsg
    {
        let inner : &Type = if (c.getSuffix () == CharSuffixes::UTF8) {
            CharType::new (c.getLoc (), size-> 8u16)
        } else if (c.getSuffix () == CharSuffixes::UTF16) {
            CharType::new (c.getLoc (), size-> 16u16)
        } else {
            CharType::new (c.getLoc (), size-> 32u16)
        };

        let (len, res) = if (c.getSuffix () == CharSuffixes::UTF8) {
            let (v, l) = self._utfVisitor.convertUtf8 (c.getLoc (), c.getSequence ());
            (l, CharValue::new (c.getLoc (), inner, v [0]))
        } else if (c.getSuffix () == CharSuffixes::UTF16) {
            let (v, l) = self._utfVisitor.convertUtf16 (c.getLoc (), c.getSequence ());
            (l, CharValue::new (c.getLoc (), inner, v [0]))
        } else {
            let (v, l) = self._utfVisitor.convertUtf32 (c.getLoc (), c.getSequence ());
            (l, CharValue::new (c.getLoc (), inner, v [0]))
        };

        if (len != 1us) {
            throw ErrorMsg::fatal (c.getLoc (), format (ValidateErrorMessage::MALFORMED_CHAR, inner, len));
        }

        res
    }

    /**
     * @params: 
     *   - _: the context of the validation
     *   - s: the string to validate
     * @throws: &ErrorMsg if the string is malformed
     * @returns: a string value
     */
    def validateString (self, dmut _ : &Validator, s : &StringExpr, forceType : &Type = NONE_TYPE)-> &Value
        throws &ErrorMsg
    {
        let inner : &Type = if (s.getSuffix () == StringSuffixes::UTF8) {
            CharType::new (s.getLoc (), size-> 8u16)
        } else {
            CharType::new (s.getLoc (), size-> 32u16)
        };

        let (value_c8, value_c32, len) = if (s.getSuffix () == StringSuffixes::UTF8) {
            let (v, l) = self._utfVisitor.convertUtf8 (s.getLoc (), s.getSequence ());
            (v, "", l)
        } else {
            let (v, l) = self._utfVisitor.convertUtf32 (s.getLoc (), s.getSequence ());
            (""s8, v, l)
        };
        
        let arrType = ArrayType::new (s.getLoc (), inner, size-> int::usize (s.getLoc (), len), isMutable-> true);
        match forceType {
            ArrayType () => {
                StringValue::new (s.getLoc (), arrType, c8Val-> value_c8, c32Val-> value_c32, len)
            }
            _ => {                    
                let slcType = SliceType::new (s.getLoc (), inner, isMutable-> true);
                
                SliceValue::new (
                    s.getLoc (),
                    slcType,
                    StringValue::new (s.getLoc (), arrType, c8Val-> value_c8, c32Val-> value_c32, len),
                    implicitAlias-> true) 
            }
        }
        
    }
        
    /**
     * ================================================================================
     * ================================================================================
     * =========================             VAR              =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * @params: 
     *   - context: the context of the validation
     *   - v: the var to validate
     * @throws: &ErrorMsg if the var is not found
     * @returns: a value
     */
    def validateVar (self, dmut context : &Validator, v : &VarExpr)-> &Value
        throws &ErrorMsg
    {
        let value = context:.getLocal (v.getLoc (), v.getLoc ().str ());
        match value {
            NoneValue () => return self.validateVarGlobal (alias context, v);
            protoV : &ProtoVarValue => {
                return VarRefValue::new (v.getLoc (), protoV.getLoc (), protoV.getType (), protoV.isMutable (), protoV.getUniqId (), isSelf-> protoV.isSelf (), isReference-> protoV.isReference ());
            }
            vdecl : &VarDeclValue => {
                match vdecl.getVarType () {
                    LambdaType () => {
                        return VarRefValue::new (v.getLoc (), vdecl.getLoc (), vdecl.getVarType (), value-> vdecl.getValue (), vdecl.isMutable (), vdecl.getUniqId (), isSelf-> false, isReference-> false);
                    }
                    _ => {
                        if (vdecl.isMutable ()) {
                            return VarRefValue::new (v.getLoc (), vdecl.getLoc (), vdecl.getVarType (), vdecl.isMutable (), vdecl.getUniqId (), isSelf-> false, isReference-> false);
                        } else {
                            return VarRefValue::new (v.getLoc (), vdecl.getLoc (), vdecl.getVarType (), vdecl.isMutable (), vdecl.getUniqId (), isSelf-> false, value-> vdecl.getValue (), isReference-> false);
                        }
                    }
                }
            }
            s : &StructFieldAccessValue => { // Closure
                return s;
            }
            vl : &Value => { // Directly inserted a value, for example in Enum validation
                return vl;
            }
        }
    } 
     
    
    /**
     * Validate a var reference that was not found locally, and then must be searched in global symbols
     * @params: 
     *     - context: the context of the validation
     *     - v: the variable to search
     * @returns: a value containing the references to the global variable (multsym is possible)
     * @throws: &ErrorMsg, the variable refers to nothing
     */
    def validateVarGlobal (self, dmut context : &Validator, v : &VarExpr)-> &Value
        throws &ErrorMsg
    {
        let dmut syms = context:.getGlobal (v.getLoc ().str ());
        if (syms.len == 0us) {
            throw context:.createGlobalVarError (v.getLoc (), v.getLoc ().str ());
        } else {
            { 
                return self.validateMultSymbols (v.getLoc (), alias context, alias syms);
            } catch {
                err : &ErrorMsg => throw ErrorMsg::fatal (v.getLoc (), format (ValidateErrorMessage::UNDEF_VAR, v.getLoc ().str ()), notes-> [err]);        
            }
        }
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================          MULT SYMS           =========================
     * ================================================================================
     * ================================================================================
     */
    
    /**
     * Transform symbol references into a single value
     * @params:
     *   - loc: the location of the symbol ref
     *   - context: the context of the validation
     *   - syms: the list of symbols
     * @returns: a value containing multiple symbols (&MultSymValue), or a single one (&Value)
     * @throws: 
     *   - &ErrorMsg: if the transformation fails
     */
    pub def validateMultSymbols (self, loc : &Word, dmut context : &Validator, dmut syms : [&Symbol])-> &Value
        throws &ErrorMsg
    {
        let dmut res = Vec!{&Value}::new ();
        let dmut errors = Vec!{&ErrorMsg}::new ();
        let dmut typeErrors = Vec!{&ErrorMsg}::new ();
        for i in 0us .. syms.len {
            context:.pushReferent (alias syms [i]);
            {
                match ref syms [i] {
                    dmut f : &FunctionSymbol => {
                        if (!f.isMethod ()) 
                            res:.push (context:.getFunctionValidator ().validateFuncPrototype (alias context, alias f));
                    }
                    c : &ConstructorSymbol => {
                        typeErrors:.push (ErrorMsg::fatal (c.getLoc (), format (ValidateErrorMessage::USE_AS_VALUE, c)));
                    }
                    m : &ModuleSymbol => {
                        res:.push (ModuleRefValue::new (loc, m));
                    }
                    dmut a : &AkaSymbol => { // Aka are sometimes types, there is a special function to handle that
                        self.validateAkaSymbolMultSym (loc, alias context, alias a, alias res, alias typeErrors);
                    }
                    dmut t : &TemplateSymbol => { // At this point there is no way to determine if it is a type or a value
                        res:.push (TemplateRefValue::new (loc, t));
                    }
                    dmut c : &ClassSymbol => { // class are types
                        {
                            let type = context:.getClassValidator ():.validate (alias context, alias c, inModule-> false);
                            typeErrors:.push (ErrorMsg::fatal (loc, format (ValidateErrorMessage::USE_AS_VALUE, type)));
                        } catch { err : &ErrorMsg => { typeErrors:.push (err); } }
                    } 
                    dmut s : &StructSymbol => { // struct are also types
                        {
                            let type = context:.getStructValidator ().validate (alias context, alias s);
                            typeErrors:.push (ErrorMsg::fatal (loc, format (ValidateErrorMessage::USE_AS_VALUE, type)));
                        } catch { err : &ErrorMsg => { typeErrors:.push (err); } }
                    } 
                    dmut tr : &TraitSymbol => { // Traits are also types
                        {
                            let type = context:.getTraitValidator ().validate (alias context, alias tr);
                            typeErrors:.push (ErrorMsg::fatal (loc, format (ValidateErrorMessage::USE_AS_VALUE, type)));
                        } catch { err : &ErrorMsg => { typeErrors:.push (err); } }
                    }
                    dmut en : &EnumSymbol => { // Enum are also types
                        {
                            let type = context:.getEnumValidator ().validate (alias context, alias en);
                            typeErrors:.push (ErrorMsg::fatal (loc, format (ValidateErrorMessage::USE_AS_VALUE, type)));
                        } catch { err : &ErrorMsg => { typeErrors:.push (err); } }
                    }                
                    _ => {
                        println ("TODO : ", (syms [i])::typeinfo.name);
                        __pragma!panic ();
                    }
                }
            } catch {
                err : &ErrorMsg => {
                    errors:.push (err);
                }
            }
            
            context:.popReferent ();
        }

        // There are errors in value validation
        if (errors.len () != 0us) throw ErrorMsg::list (errors[]);

        if (res.len () == 1us) { 
            res[][0us]
        } else {
            if (res.len () == 0us) { // There are no values
                if (typeErrors.len () != 0us) throw ErrorMsg::list (typeErrors[]); // It has to be because of type error
                else  __pragma!panic ();                
            }
            
            let prettyStr = self.createPrettyStringMultSym (res[]);
            cast!{&Value} (MultSymValue::new (loc, res[], prettyStr-> prettyStr))
        }
    }

    /**
     * @returns: a pretty string refereing to the content of 'values'
     */
    def createPrettyStringMultSym (self, values : [&Value])-> [c8] {            
        let dmut set = HashSet!{[c8]}::new ();
        for i in values {
            set:.insert (format ("%", i));
        }
        
        let dmut stream = StringStream::new ();
        if (set.len () == 1us) { stream:.write (set[][0us]); }
        else {
            stream:.write ("{"s8);
            let mut i = 0us;
            for val in set {
                if (i != set.len () - 1us && i == 2us) stream:.write (", ...");
                else if (i == set.len () - 1us || i < 2us) {
                    if i != 0us { stream:.write (", "s8); }
                    stream:.write (val);
                }
                i += 1us;
            }
            stream:.write ("}"s8);
        }
        
        stream[]
    }
    
    /**
     * Aka symbol may refer to types, or to values
     * In order to show the correct error, we should try both validation
     * @params: 
     *   - loc: the location of the symbol reference
     *   - context: the context of the validation
     *   - sym: the symbol to validate
     * @throws: 
     *   - &ErrorMsg: if the aka is malformed (but not a type)
     * @returns: 
     *   - res: add the value to the vec
     *   - typeErrors: add an error, if the aka is a type (but not malformed)
     */
    def validateAkaSymbolMultSym (self, loc : &Word, dmut context : &Validator, dmut sym : &AkaSymbol, dmut res : &Vec!{&Value}, dmut typeErrors : &Vec!{&ErrorMsg})
        throws &ErrorMsg
    {
        {
            res:.push (context:.getAkaValidator ().validateValue (alias context, alias sym));
        } catch {
            err : &ErrorMsg => { // There are two possibilities 
                {
                    let type = context:.getAkaValidator ().validateType (alias context, alias sym); // 1) its a type
                    typeErrors:.push (ErrorMsg::fatal (loc, format (ValidateErrorMessage::USE_AS_VALUE, type))); // Then we add no value, but add an error in typeErrors
                } catch { // 2) it is just malformed
                    _ => throw err;
                }
            }
        }
    }
    
}
