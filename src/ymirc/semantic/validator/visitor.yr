in visitor;

use ymirc::semantic::declarator::visitor;
use ymirc::semantic::validator::{_,
                                 macro_::_,
                                 symbol::_,
                                 operator::_,
                                 template::_};

use ymirc::syntax::{_,
                    declaration::_,
                    expression::{_, literal::_, macro_::_, operator::_, template::_}};

use ymirc::errors::_;
use ymirc::lexing::{word, tokens};
use ymirc::utils::format;
use ymirc::global::{core_, state};
use std::{io, stream, fs::path};

use ymirc::semantic::{generator::_, symbol::{_, macro_::_}};
use ymirc::semantic::generator::type::{_,
                                       syntax::_,
                                       custom::_,
                                       native::{_, scalar::_, compound::_},
                                       temporary::_};

use ymirc::semantic::generator::value::{_,
                                        syntax::_,
                                        construct::{_, delegate::_},
                                        literal::_,
                                        memory::_,
                                        operator::{_, binary::_, call::_, fields::_, map::_, slice::_, unary::_},
                                        operator::map::iteration::_,
                                        prototypes::_,
                                        scope::_,
                                        syntax::_,
                                        template::_};


extern (C) fn _yrt_exc_get_stack_trace ()-> [*void];
extern (C) fn _yrt_exc_resolve_stack_trace (trc : [*void])-> [c8];

/**
 * The validator class is the class that transform the declared symbols into validated generators that can be passed to the backend
 */
pub class Validator {

    /*!
     * ================================================================================
     * ================================================================================
     * =========================          DECLARATOR          =========================
     * ================================================================================
     * ================================================================================
     */

    // The declarator for post semantic symbol declaration
    let dmut _declarator : &Declarator;

    /*!
     * ================================================================================
     * ================================================================================
     * =========================      SYMBOL VALIDATORS       =========================
     * ================================================================================
     * ================================================================================
     */

    // The validator that is in charge of aka validation
    let dmut _akaValidator = copy AkaValidator ();

    // The validator that is in charge of class validation
    let dmut _classValidator = copy ClassValidator ();
    
    // The validator that is in charge of validating cast expressions
    let _castValidator = CastValidator ();
    
    // The validator that is in charge of validating functions
    let dmut _functionValidator = copy FunctionValidator ();

    // The validator that is in charge of validating modules
    let _moduleValidator = ModuleValidator ();

    // The validator that is in charge of enum validation
    let dmut _enumValidator = copy EnumValidator ();

    // The validator that is in charge of template validation
    let _templateSolver = TemplateSolver ();

    // The declarator that is in charge of template rewritting and declaration
    let dmut _templateDeclarator = copy TemplateDeclarator ();

    // The validator that is in charge of template validation
    let _traitValidator = TraitValidator ();

    // The validator that is in charge of the lambda validation
    let dmut _lambdaValidator = copy LambdaValidator ();

    // The validator that is in charge of the pragma exprs validation
    let _pragmaValidator = PragmaValidator ();

    // The validator in charge of the validation of global variables
    let dmut _globalValidator = copy GlobalValidator ();

    // The validator in charge of the validation of sizeof
    let dmut _sizeofValidator = copy SizeofValidator ();

    // The validator in charge of the validation of typeinfo
    let _typeinfoValidator = TypeInfoValidator ();

    // The validator in charge of validation of copy/dcopy
    let _copyValidator = CopyOpValidator ();

    // The validator in charge of validation of expand
    let _expandOpValidator = ExpandOpValidator ();

    // The list of already reduced values
    let dmut _compileTimeInterpret = copy CompileTimeInterpreter ([]);

    /*!
     * ================================================================================
     * ================================================================================
     * =========================        SUB VALIDATORS        =========================
     * ================================================================================
     * ================================================================================
     */

    // The validator that is in charge of validating types
    let _typeValidator = TypeValidator ();

    // The validator that is in charge of validating values
    let _valueValidator = ValueValidator ();

    // The validator used to validate binary operators
    let _binOpValidator = BinaryOpValidator ();

    // The validator used to validate unary operators
    let _unOpValidator = UnaryOpValidator ();

    // The validator used to validate call operators
    let _callOpValidator = CallOpValidator ();

    // The validator used to validate call to macros
    let _macroSolver = MacroSolver ();

    // The validator used to validate index operators
    let _indexOpValidator = IndexOpValidator ();

    // The validator used to validate literals
    let _literalValidator = LiteralValidator ();

    // The validator used to validate for loops
    let _forLoopValidator = ForLoopValidator ();

    // The validator used to validate '::' operation where left operand is a type
    let _subTypeValidator = SubTypeValidator ();

    // The validator used to validate match expressions
    let _matcherValidator = MatcherValidator ();
    
    /*!
     * ================================================================================
     * ================================================================================
     * =========================           CONTEXT            =========================
     * ================================================================================
     * ================================================================================
     */

    // The referent are used when accessing symbols
    let mut _referent : [dmut &Symbol] = [];
    
    // The current scope variable declarations
    let mut _symbols : [mut [mut [[c8] => mut &Value]]] = [];

    // The list of symbols that are used in the current block
    let mut _usedSyms : [mut [mut [[c8] => mut ()]]] = [];

    // The current return type of the current function
    let mut _functionReturns : [mut &Type] = [];

    // True iif we are currently validating a lambda body
    let mut _inLambda : [mut bool] = [];

    // True iif we are currently validating a function body (can be a lambda)
    let mut _inFunctionBody : [mut bool] = [];

    // True iif we are currently validating an unsafe block
    let mut _inUnsafeContext : [mut &Word] = [];

    // Location of the use of unsafe (unsafe operation in an unsafe context, EOF if none)
    let mut _inUnsafeContextUsed : [mut &Word] = [];

    // Location of the scope guards being validated
    let mut _inScopeGuard : [mut &Word] = [];

    // The current type of the breaks for the current loop
    let mut _loopBreakTypes : [mut [mut &Type]] = [];

    // The current closure type
    let mut _closureType : [dmut &ClosureType] = [];

    // The current type whose fields are being validated
    let mut _fieldConstructionTypes : [mut &Type] = [];

    // The list of fields that have been validated during the pre construction
    let mut _fieldConstructionValidated : [mut [[c8] => mut ()]] = [];

    // The class that is being validated (methods, constructors, etc.)
    let mut _classContext : [mut &Type] = [];

    // The current value that is being indexed for opDollar
    let mut _dollarContext : [mut [mut &Value]] = [];

    // The current copy context entered
    let mut _copyContext : [mut [mut &Expression]] = [];

    // All the generators created during the validation
    let mut _generators : [mut &Generator] = [];

    // List of custom generators already inserted
    let mut _customGenerators : [[c8] => mut ()] = [];

    // Generator errors that stop the insertion of a generator insertion but that was not holding the validation of other symbols
    let mut _genErrors : [mut &ErrorMsg] = [];

    /*!
     * ================================================================================
     * ================================================================================
     * =========================        VERIFICATIONS         =========================
     * ================================================================================
     * ================================================================================
     */

    // The native type names
    let mut _nativeTypeNames : [[c8] => mut ()] = [];

    /*!
     * ================================================================================
     * ================================================================================
     * =========================         CONSTRUCTION         =========================
     * ================================================================================
     * ================================================================================
     */
    
    /**
     * Create a new empty validator
     */
    pub self (dmut declarator : &Declarator)
        with _declarator = alias declarator
    {        
        for t in NativeTypes::__members__ {
            if (t != NativeTypes::ERROR) {
                self._nativeTypeNames [t] = ();
            }
        }
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================          VALIDATION          =========================
     * ================================================================================
     * ================================================================================
     */
    
    /**
     * Validate a symbol
     * @params: 
     *   - sym: the symbol to validate
     * @throws: 
     *   - &ErrorMsg: if there was an error in the validation
     */
    pub fn validate (mut self, dmut sym : &Symbol)
        throws ErrorMsg
    {
        match alias sym {
            dmut m : &ModuleSymbol => {
                self._moduleValidator.validate (alias self, alias m);
            }
            dmut l : &LazyModuleSymbol => {
                self._moduleValidator.validate (alias self, alias self:.getModuleFromLazy (l));
            }
            dmut f : &FunctionSymbol => {
                self._functionValidator:.validate (alias self, alias f);
            }
            dmut c : &ClassSymbol => {
                self._classValidator:.validate (alias self, alias c, inModule-> true);
            }
            dmut tr : &TraitSymbol => {
                self._traitValidator.validate (alias self, alias tr);
            }
            dmut en : &EnumSymbol => {
                self._enumValidator:.validate (alias self, alias en);
            }
            dmut glb : &GlobalSymbol => {
                self._globalValidator:.validate (alias self, alias glb, fromModule-> true);
            }
            dmut aka : &AkaSymbol => {
                self._akaValidator:.validate (alias self, alias aka);
            }
            MacroSymbol () => {
                // Only validated when called
            }
            EmptySymbol () => {
                // Just do nothing 
            }
            TemplateSymbol () => {
                // TODO, verify that the symbols can be infered without any call, and if yes then validate it
            }
            _ => {
                println ("TODO : ", sym.__typeinfo__.name);
                panic;
            }                
        }
    }
    
    /*!
     * ================================================================================
     * ================================================================================
     * =========================            TYPES             =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate an expression assuming its a type
     * @params: 
     *    - type: the expression to validate
     * @returns: the generator
     * @throws: &ErrorMsg, if the type is not valid
     */
    pub fn validateType (mut self, type : &Expression, parentMutable : bool = true)-> &Type
        throws ErrorMsg
    {
        self._typeValidator.validate (alias self, type, parentMutable-> parentMutable)
    }


    /**
     * Validate an expression assuming its a type
     * @params: 
     *    - type: the expression to validate
     * @returns: the generator of the type
     * @throws: &ErrorMsg, if the type is not valid
     */
    pub fn validateTypeForVarDecl (mut self, type : &Expression, v : &VarDeclExpr, canBeRef : bool = false, canBeLazy : bool = false)-> &Type
        throws ErrorMsg
    {
        if (v.isRef () && !canBeRef) {
            throw copy ErrorMsg::fatal (v.getRefLocation (), format (ValidateErrorMessage::UNDEF_DECORATOR_HERE, Keys::REF));
        }

        if (v.isLazy () && !canBeLazy) {
            throw copy ErrorMsg::fatal (v.getLazyLocation (), format (ValidateErrorMessage::UNDEF_DECORATOR_HERE, Keys::LAZY));
        }

        let (isMutable, isDeeplyMutable) = (v.isMutable (), v.isDeeplyMutable ());
        let ret = self._typeValidator.validate (alias self, type, isMutable-> (isMutable || isDeeplyMutable), parentMutable-> (isMutable || isDeeplyMutable), isDeeplyMutable-> isDeeplyMutable);

        ret
    }

    /**
     * Validate the typeinfo struct and return it
     * @params:
     *    - loc: the location where the type is required
     * */
    pub fn validateTypeInfo (mut self, loc : &Word)-> &ClassPtrType
        throws ErrorMsg
    {
        let name = self.createSyntaxVarFromPath (loc, TypeUtils::TYPEINFO_TYPE);
        {
            match self:.validateType (name) {
                s : &ClassPtrType => {
                    return s;
                }
                _ => throw copy ErrorMsg::fatal (loc, ValidateErrorMessage::MALFORMED_CORE);
            }
        } catch {
            err : &ErrorMsg => {
                throw err.appendNotes (copy [copy ErrorMsg::note (loc, ValidateErrorMessage::HERE)]);
            }
        }
    }

    /**
     * Validate the typeids enumeration and return it
     * @params:
     *    - loc: the location where the typeids are required
     * */
    pub fn validateTypeIDs (mut self, loc : &Word, field : [c8])-> &Value
        throws ErrorMsg
    {
        let name = self.createSyntaxVarFromPath (loc, TypeUtils::TYPEIDS_TYPE);
        {
            match self:.validateType (name) {
                en : &EnumType => {
                    return self._subTypeValidator.validateEnumField (alias self, loc, en, field);
                }
                _ => throw copy ErrorMsg::fatal (loc, ValidateErrorMessage::MALFORMED_CORE);
            }
        } catch {
            err : &ErrorMsg => {
                throw err.appendNotes (copy [copy ErrorMsg::note (loc, ValidateErrorMessage::HERE)]);
            }
        }
    }

    /**
     * Validate the fieldinfo struct and return it
     * @params:
     *    - loc: the location where the type is required
     * */
    pub fn validateFieldInfo (mut self, loc : &Word)-> &ClassPtrType
        throws ErrorMsg
    {
        let name = self.createSyntaxVarFromPath (loc, TypeUtils::FIELDINFO_TYPE);
        {
            match self:.validateType (name) {
                s : &ClassPtrType => {
                    return s;
                }
                _ => throw copy ErrorMsg::fatal (loc, ValidateErrorMessage::MALFORMED_CORE);
            }
        } catch {
            err : &ErrorMsg => {
                throw err.appendNotes (copy [copy ErrorMsg::note (loc, ValidateErrorMessage::MALFORMED_CORE)]);
            }
        }
    }

    /**
     * Validate the trait ref for iterators
     * @params:
     *     - loc: the location where the type is required
     * */
    pub fn validateIteratorTrait (mut self, loc : &Word)-> &TraitRefType
        throws ErrorMsg
    {
        let name = self.createSyntaxVarFromPath (loc, GlobalTraitUtils::ITERABLE_TRAIT);
        {
            match self:.validateType (name) {
                t : &TraitRefType => {
                    return t;
                }
                _ => throw copy ErrorMsg::fatal (loc, ValidateErrorMessage::MALFORMED_CORE);
            }
        } catch {
            err : &ErrorMsg => {
                throw err.appendNotes (copy [copy ErrorMsg::note (loc, ValidateErrorMessage::MALFORMED_CORE)]);
            }
        }
    }

    /**
     * Validate the trait ref for hashing class and records
     * @params:
     *     - loc: the location where the type is required
     * */
    pub fn validateHashableTrait (mut self, loc : &Word)-> &TraitRefType
        throws ErrorMsg
    {
        let name = self.createSyntaxVarFromPath (loc, GlobalTraitUtils::HASHABLE_TRAIT);
        {
            match self:.validateType (name) {
                t : &TraitRefType => {
                    return t;
                }
                _ => throw copy ErrorMsg::fatal (loc, ValidateErrorMessage::MALFORMED_CORE);
            }
        } catch {
            err : &ErrorMsg => {
                throw err.appendNotes (copy [copy ErrorMsg::note (loc, ValidateErrorMessage::MALFORMED_CORE)]);
            }
        }
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================            VALUES            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate an expression assuming its a value
     * @params: 
     *    - value: the expression to validate
     * @returns: the generator
     * @throws: &ErrorMsg, if the value is not valid
     */
    pub fn validateValue (mut self, value : &Expression, noReduce : bool = false)-> &Value
        throws ErrorMsg
    {
        let val = self._valueValidator.validate (alias self, value);
        if (!noReduce) {
            self:.getCompileTimeInterpreter ():.reduce (val)
        } else {
            val
        }
    }

    /**
     * Validate an expression assuming its a value
     * @params: 
     *    - loc: the location of the affection
     *    - value: the expression to validate
     *    - type: the expected type (and mutability)
     * @returns: the generator
     * @throws: &ErrorMsg, if the value is not valid, or cannot be put in type
     */
    pub fn validateValue (mut self, loc : &Word, value : &Expression, type : &Type, verif : bool = true, noReduce : bool = false)-> &Value
        throws ErrorMsg
    {
        let v = self:.validateValue (value, noReduce-> noReduce);
        if (verif) {
            self.verifyCompleteTypeWithValue (loc, v.getType (), v, construct-> false);
            let v_ = self:.verifyCompatibleTypeWithValue (loc, type, v, byReference-> false);
            self.verifyMemoryOwner (loc, type, v_, byReference-> false);
            v_
        } else
            v
    }

    /**
     * Validate cte expressions (e.g. cte if, cte assert, ...) or expressions that must be known at compilation time
     * @params: 
     *   - value: the value to validate
     * @returns: the result value
     * @throws:
     *   - &ErrorMsg: if the validation failed, or the value cannot be known at compilation time
     */
    pub fn validateCteValue (mut self, value : &Expression)-> &Value
        throws ErrorMsg
    {
        self._valueValidator.validateCteExpr (alias self, value)
    }    


    /**
     * Implicit cast value unwrapping, for the value ot be used in an operation
     * @info: if the value is not of an enum type, return 'value'
     * */
    pub fn implicitEnumUnwrap (self, value : &Value)-> &Value {
        match value.getType () {
            en : &EnumType => {
                match value {
                    v : &EnumFieldAccessValue => {
                        return self.implicitEnumUnwrap (v.getContent ());
                    }
                    _ => {
                        return self.implicitEnumUnwrap (copy CastValue (value.getLoc (), en.getProxy (), value));
                    }
                }
            }
            _ => { return value; }
        }
    }

    /**
     * Implicit cast type unwrapping, for the type to be used in a template operation for instance
     * @info: if the type is not an enum type, return 'type'
     * */
    pub fn implicitEnumUnwrap (self, type : &Type)-> &Type {
        match type {
            en : &EnumType => return self.implicitEnumUnwrap (en.getProxy ());
            _ => return type;
        }
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================           GETTERS            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * @returns: the declarator for symbol declaration
     */
    pub fn getDeclarator (mut self)-> dmut &Declarator {
        alias self._declarator
    }
    
    /**
     * @returns: the validator for binary operations
     */
    pub fn getBinOpValidator (mut self)-> BinaryOpValidator {
        self._binOpValidator
    }

    /**
     * @returns: the validator for unary operations
     */
    pub fn getUnOpValidator (mut self)-> UnaryOpValidator {
        self._unOpValidator
    }

    /**
     * @returns: the validator for call operators
     */
    pub fn getCallOpValidator (mut self)-> CallOpValidator {
        self._callOpValidator
    }

    /**
     * @returns: the validator for macro calls
     * */
    pub fn getMacroSolver (mut self)-> MacroSolver {
        self._macroSolver
    }

    /**
     * @returns: the validator for cast expressions
     */
    pub fn getCastValidator (mut self)-> CastValidator {
        self._castValidator
    }

    /**
     * @returns: the validator for index operators
     */
    pub fn getIndexOpValidator (mut self)-> IndexOpValidator {
        self._indexOpValidator
    }

    /**
     * @returns: the validator for literals
     */
    pub fn getLiteralValidator (mut self)-> LiteralValidator {
        self._literalValidator
    }

    /**
     * @returns: the validator for any kind of values
     */
    pub fn getValueValidator (mut self)-> ValueValidator {
        self._valueValidator
    }

    /**
     * @returns: the validator of sub type access ('::' on type left operand)
     */
    pub fn getSubTypeValidator (mut self)-> SubTypeValidator {
        self._subTypeValidator
    }

    /**
     * @returns: the validator for akas
     */
    pub fn getAkaValidator (mut self)-> dmut &AkaValidator {
        alias self._akaValidator
    }

    /**
     * @returns: the validator for classes
     */
    pub fn getClassValidator (mut self)-> dmut &ClassValidator {
        alias self._classValidator
    }
    
    /**
     * @returns: the validator for functions
     */
    pub fn getFunctionValidator (mut self)-> dmut &FunctionValidator {
        alias self._functionValidator
    }

    /**
     * @returns: the validator for global vars
     * */
    pub fn getGlobalVarValidator (mut self)-> dmut &GlobalValidator {
        alias self._globalValidator
    }

    /**
     * @returns: the validator for modules
     */
    pub fn getModuleValidator (mut self)-> ModuleValidator {
        self._moduleValidator
    }

    /**
     * @returns: the validator for templates
     */
    pub fn getTemplateSolver (mut self)-> TemplateSolver {
        self._templateSolver
    }

    /**
     * @returns: the declarator for templates 
     */
    pub fn getTemplateDeclarator (mut self)-> dmut &TemplateDeclarator {
        alias self._templateDeclarator
    }
    
    /**
     * @returns: the validator for traits
     */
    pub fn getTraitValidator (mut self)-> TraitValidator {
        self._traitValidator
    }

    /**
     * @returns: the validator for enums
     */
    pub fn getEnumValidator (mut self)-> dmut &EnumValidator {
        alias self._enumValidator
    }
    
    /**
     * @returns: the validator for lambdas
     */
    pub fn getLambdaValidator (mut self)-> dmut &LambdaValidator {
        alias self._lambdaValidator
    }

    /**
     * @returns: the validator for pragmas
     */
    pub fn getPragmaValidator (mut self)-> PragmaValidator {
        self._pragmaValidator
    }

    /**
     * @returns: the validator for 'sizeof's
     * */
    pub fn getSizeofValidator (mut self)-> dmut &SizeofValidator {
        alias self._sizeofValidator
    }

    /**
     * @returns: the validator for 'typeinfo'
     * */
    pub fn getTypeInfoValidator (mut self)-> TypeInfoValidator {
        self._typeinfoValidator
    }

    /**
     * @returns: the validator used to validate copy/dcopy
     * */
    pub fn getCopyValidator (mut self)-> CopyOpValidator {
        self._copyValidator
    }

    /**
     * @returns: the validator in charge of expand operator validation
     * */
    pub fn getExpandValidator (mut self)-> ExpandOpValidator {
        self._expandOpValidator
    }

    /**
     * @returns: the interpreter that can compute cte values
     */
    pub fn getCompileTimeInterpreter (mut self, forRef : bool = false)-> dmut &CompileTimeInterpreter {
        if (!forRef) {
            return alias self._compileTimeInterpret;
        } else {
            return copy CompileTimeInterpreter (forRef-> true, alias self._compileTimeInterpret:.getReduced ());
        }
    }

    /**
     * @returns: the for loop validator
     */
    pub fn getForLoopValidator (mut self)-> ForLoopValidator {
        self._forLoopValidator
    }

    /**
     * @returns: the matcher expression validator
     */
    pub fn getMatcherValidator (mut self)-> MatcherValidator {
        self._matcherValidator
    }
    
    /*!
     * ================================================================================
     * ================================================================================
     * =========================           CONTEXT            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Push a new referent 
     * @params: 
     *   - sym: the symbol that will be used for future symbol access
     */
    pub fn pushReferent (mut self, dmut sym : &Symbol) {
        self._referent ~= [alias sym];
    }

    /**
     * Exit the current referent
     */
    pub fn popReferent (mut self) {
        self._referent = alias self._referent [0 .. $ - 1];
    }


    /**
     * @returns: the current referent
     * @info: empty if not in a symbol context
     */
    pub fn getReferent (mut self)-> dmut &Symbol {
        if (self._referent.len == 0us) { return copy EmptySymbol (); }
        else {
            return alias self._referent [$ - 1];
        }
    }

    /**
     * @returns: the current referent
     * @info: empty if not in a symbol context
     * */
    pub fn getReferent (self)-> &Symbol {
        if (self._referent.len == 0us) return copy EmptySymbol ();
        else {
            return self._referent [$ - 1];
        }
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================       LOCAL VARIABLES        =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Enter a new foreign scope space
     * @params: 
     *   - isLambda: true iif the foreign that will be validated is lambda function (closure or not)
     *   - isFnBody: true iif the foreign we just entered is for validating a function body
     *   - clContext: type of the class whose symbol is being validated (applicable for symbol defined inside classes, e.g. methods, ctors)
     */
    pub fn enterForeign (mut self, isLambda : bool = false, isFnBody : bool, clContext : &Type = NONE_TYPE) {
        self._symbols                    ~= [cast!{[[[c8] => &Value]]} ([])];
        self._usedSyms                   ~= [cast!{[[[c8] => ()]]} ([])];
        self._functionReturns            ~= [NONE_TYPE];
        self._inLambda                   ~= [isLambda];
        self._inFunctionBody             ~= [isFnBody];
        self._inUnsafeContext            ~= [EOF_WORD];
        self._inUnsafeContextUsed        ~= [EOF_WORD];
        self._inScopeGuard               ~= [EOF_WORD];
        self._loopBreakTypes             ~= [cast!{[&Type]} ([])];
        self._fieldConstructionTypes     ~= [NONE_TYPE];
        self._fieldConstructionValidated ~= [cast!{[[c8] => ()]} ([])];
        self._classContext               ~= [clContext];
        self._dollarContext              ~= [cast!{[&Value]} ([])];
        self._copyContext                ~= [cast!{[&Expression]} ([])];
    }

    /**
     * Exit a foreign scope space
     */
    pub fn exitForeign (mut self) {
        self._symbols                    = alias self._symbols [0 .. $ - 1];
        self._usedSyms                   = alias self._usedSyms [0 .. $ - 1];
        self._functionReturns            = alias self._functionReturns [0 .. $ - 1];
        self._loopBreakTypes             = alias self._loopBreakTypes [0 .. $ - 1];
        self._inLambda                   = alias self._inLambda [0 .. $ - 1];
        self._inFunctionBody             = alias self._inFunctionBody [0 .. $ - 1];
        self._inUnsafeContext            = alias self._inUnsafeContext [0 .. $ - 1];
        self._inUnsafeContextUsed        = alias self._inUnsafeContextUsed [0 .. $ - 1];
        self._inScopeGuard               = alias self._inScopeGuard [0 .. $ - 1];
        self._fieldConstructionValidated = alias self._fieldConstructionValidated [0 .. $ - 1];
        self._fieldConstructionTypes     = alias self._fieldConstructionTypes [0 .. $ - 1];
        self._classContext               = alias self._classContext [0 .. $ - 1];
        self._dollarContext              = alias self._dollarContext [0 .. $ - 1];
        self._copyContext                = alias self._copyContext [0 .. $ - 1];
    }
    
    /**
     * After entering a foreign with isFnBody-> false, we can change the context with this function 
     * This allows to avoid exiting foreign, and reentering it just after
     * @info: this does not have to be exited
     * @example: 
     * ==================
     * enterForeign (isFnBody-> false); // <-    
     * // Validate prototype                | 
     * enterFunctionBody (); //             |
     * // Validate function body            |
     * exitForeign (); // ------------------+
     * ==================
     */
    pub fn enterFunctionBody (mut self) {
        self._inFunctionBody [$ - 1] = true;
    }

    /**
     * Enter an unsafe context (either an unsafe keyword, or the whole function body)
     * */
    pub fn enterUnsafeContext (mut self, loc : &Word) {
        self._inUnsafeContext [$ - 1] = loc;
    }

    /**
     * Exit an unsafe context (either an unsafe keyword, or the whole function body)
     * */
    pub fn exitUnsafeContext (mut self, force : bool = false)
        throws ErrorMsg
    {
        let unsafeLoc = self._inUnsafeContext [$ - 1];
        let unsafeUsed = self._inUnsafeContextUsed [$ - 1];

        self._inUnsafeContext [$ - 1] = EOF_WORD;
        self._inUnsafeContextUsed [$ - 1] = EOF_WORD;

        // if force is true, the unsafe was entered implicitely (extern C functions for example)
        // So no need to warn that no unsafe were made
        if (!force && !unsafeLoc.isEof () && unsafeUsed.isEof ()) {
            throw copy ErrorMsg::fatal (unsafeLoc, ValidateErrorMessage::NOT_UNSAFE);
        }
    }

    /**
     * @returns: the location of the unsafe block if any, EOF_WORD otherwise
     * */
    pub fn getUnsafeContextLoc (self)-> &Word {
        self._inUnsafeContext [$ - 1]
    }

    /**
     * Enter a scope guard validation
     * */
    pub fn enterScopeGuard (mut self, loc : &Word) {
        self._inScopeGuard [$ - 1] = loc;
    }

    /**
     * Exit a scope guard validation
     * */
    pub fn exitScopeGuard (mut self) {
        self._inScopeGuard [$ - 1] = EOF_WORD;
    }

    /**
     * @returns: the location of the scope guard being validated if any
     * */
    pub fn getInScopeGuard (self)-> &Word {
        self._inScopeGuard [$ - 1]
    }

    /**
     * @returns: true iif the context is currently in validation of a function body (or lambda)
     */
    pub fn isInFunctionBody (self)-> bool {
        if (self._inFunctionBody.len != 0) {
            self._inFunctionBody [$ - 1]
        } else {
            false
        }
    }

    /**
     * @returns: true iif the context is currently in validation of a lambda body
     */
    pub fn isInLambdaBody (self)-> bool {
        if (self._inLambda.len != 0us) {
            self._inLambda [$ - 1]
        } else {
            false
        }
    }
    
    /**
     * @returns: the index of the foreign that would be enclosed if a lambda closure was created in current context
     */
    pub fn getCurrentClosingIndex (self)-> usize {
        self._symbols.len - 1us
    }

    /**
     * @returns: the class being validated (might be NONE_TYPE)
     */
    pub fn getCurrentClassContext (self)-> &Type {
        if (self._classContext.len == 0us) return NONE_TYPE;
        self._classContext [$ - 1]
    }

    /**
     * @params: 
     *    - clRef: the type whose element we want to access
     * @returns: 
     *    - .0: true if the current context allows to access the private elements of clRef type
     *    - .1: true if the current context allows to access the protected elements of clRef type
     */
    pub fn getCurrentClassContextProtections (self, clRef : &ClassRefType)-> (bool, bool) {
        let mut current = self.getCurrentClassContext (); 
        match current {
            cl : &ClassRefType => {
                if (cl == clRef) return (true, true); // We are in the class definition (a method, a ctor, etc.)
                
                current = cl.getAncestor (); // Maybe we are in the class definition of a child class
                loop { 
                    match current {
                        anc : &ClassRefType => {
                            if (anc == clRef) return (false, true); // This is a child class, so we have access to protected content
                            current = anc.getAncestor ();
                        }
                        _ => { return (false, false); } // No, this is not a child class, we are outside
                    }                
                }                
            }
        }

        (false, false)
    }

    /**
     * @returns: true iif private symbols from the macro are accessible from that context
     * */
    pub fn getCurrentMacroContextProtection (self, m : &MacroRefValue)-> bool {
        match self.getReferent () {
            msym : &MacroSymbol => {
                msym == m.getSymbol ()
            }
            mct : &MacroConstructorSymbol => {
                mct.getReferent () == m.getSymbol ()
            }
            mru : &MacroRuleSymbol => {
                mru.getReferent () == m.getSymbol ()
            }
            _ => { false }
        }
    }

    /**
     * Enter a closure, that can enclose variable from the parent function
     * @params: 
     *   - refId: the uniq id of the declaration of the enclosing variable in the parent function
     *   - closureIndex: the index of the closure (index of the foreign to enclose)
     */
    pub fn enterClosure (mut self, loc : &Word, refId : usize, closureIndex : usize) {
        self._symbols [$ - 1][0]["#{CLOSURE-VARREF}"] = copy VarRefValue (copy Word ("#{CLOSURE-VARREF}", loc), EOF_WORD, VOID_TYPE, refId);
        self._usedSyms [$ - 1][0]["#{CLOSURE-VARREF}"] = ();
        
        self._closureType ~= [copy ClosureType (EOF_WORD, [], [], [], refId,
                                                self._symbols [closureIndex],
                                                alias self._usedSyms [closureIndex])];
    }

    /**
     * Exit the current closure validation
     * @returns: the closure type
     */
    pub fn exitClosure (mut self) -> &ClosureType {
        let type = self._closureType [$ - 1];
        self._closureType = alias self._closureType [0 .. $ - 1];
        
        type
    } catch {
        _ => panic;
    }
    
    /**
     * Set the type of the current function
     */
    pub fn setFunctionReturn (mut self, type : &Type) {
        self._functionReturns [$ - 1] = type;
    }

    /**
     * @returns: the current function return type
     */
    pub fn getFunctionReturn (self)-> &Type {
        self._functionReturns [$ - 1]
    }

    /**
     * Enter a dollar context (opDollar is available on 'value')
     * @params:
     *    - value: the value being indexed
     */
    pub fn enterDollar (mut self, value : &Value) {
        self._dollarContext [$ - 1] ~= [value];
    }

    /**
     * Quit a dollar context (opDollar is no longer usable on the last dollar context entered)
     */
    pub fn exitDollar (mut self) {
        self._dollarContext [$ - 1] = alias self._dollarContext [$ - 1][0 .. $ - 1];
    }

    /**
     * Enter a copy context, where inner expression are affected by the copy
     * @params:
     *    - cp: the expression performing the copy
     * */
    pub fn enterCopy (mut self, cp : &Expression) {
        self._copyContext [$ - 1] ~= [cp];
    }

    /**
     * Exit the current copy context
     * */
    pub fn exitCopy (mut self) {
        self._copyContext [$ - 1] = alias self._copyContext [$ - 1][0 .. $ - 1];
    }

    /**
     * @returns: the value being indexed that can be used for opDollar
     */
    pub fn getCurrentDollarContext (self)-> (&Value)? {
        let v = self._dollarContext [$ - 1];
        match v.len {
            0us => { none }
            _ => {
                (v [$ - 1])?
            }
        }
    }

    /**
     * Enter a new scope
     */
    pub fn enterBlock (mut self) {
        self._symbols [$ - 1] ~= copy [cast!{[[c8] => &Value]} ([])];
        self._usedSyms [$ - 1] ~= copy [cast!{[[c8] => ()]} ([])];
    }

    /**
     * Exit a scope
     */
    pub fn safeQuitBlock (mut self) {
        self._symbols [$ - 1] = alias self._symbols [$ - 1][0 .. $ - 1];
        self._usedSyms [$ - 1] = alias self._usedSyms [$ - 1][0 .. $ - 1];
    }
    
    /**
     * Exit a scope
     * @throws: 
     *   - &ErrorMsg: if a symbol was declared but unused and warnUnused
     */
    pub fn quitBlock (mut self, warnUnused : bool = true)
        throws ErrorMsg
    {
        let mut errors : [mut &ErrorMsg] = [];
        if (warnUnused) {
            for name, g in self._symbols [$ - 1][$ - 1] {
                if (name != Keys::SELF && !self.isIgnorableVar (name)) { // SELF does not need to be used
                    if (name !in self._usedSyms [$ - 1][$ - 1]) {
                        errors ~= [copy ErrorMsg::warn (g.getLoc (), format (ValidateErrorMessage::DECLARED_NOT_USED, name))];
                    }
                }
            }
        }
        
        self:.safeQuitBlock ();
        if (errors.len != 0us) throw copy ErrorMsg::list (errors);
    }

    /**
     * An ignorable variable does not trigger unused error.
     * They are starting with _ and ends with _
     * @params:
     *    - name: the name of the variable
     * @returns: true iif the variable can die without being used
     * */
    pub fn isIgnorableVar (self, name : [c8])-> bool {
        if (name == "_") return true;
        if (name.len >= 2 && name [0] == '_' && name [$ - 1] == '_') return true;
        if (name.len >= 1 && name [0] == '#') return true;

        false
    }

    /**
     * Enter a new loop
     * @params: 
     *    - type: the type of the breaks
     */
    pub fn enterLoop (mut self, type : &Type = NONE_TYPE) {
        self._loopBreakTypes [$ - 1] ~= [type];
    }

    /**
     * Set the type of the break types
     * @params: 
     *    - type: the type to set for the breaks
     */
    pub fn setCurrentLoopType (mut self, type : &Type) {
        self._loopBreakTypes [$ - 1][$ - 1] = type;
    }

    /**
     * @returns: the type of the current loop breaks
     */
    pub fn getCurrentLoopType (self)-> &Type {
        self._loopBreakTypes [$ - 1][$ - 1]
    }

    /**
     * Quit the loop scope
     * @returns: the type of the breaks inside the closing loop
     */
    pub fn quitLoop (mut self)-> &Type {
        let ret = self._loopBreakTypes [$ - 1][$ - 1];
        self._loopBreakTypes [$ - 1] = alias self._loopBreakTypes [$ - 1][0 .. $ - 1];
        ret
    }

    /**
     * @returns: true if the context is actually validating a loop in the current validated function scope
     */
    pub fn isInLoop (self)-> bool {
        self._loopBreakTypes [$ - 1].len != 0
    }

    /**
     * Enter the validation of a pre constructor during field validation
     * @params: 
     *    - type: the type whose field are being validated
     */
    pub fn enterFieldConstruction (mut self, type : &ClassRefType) {
        self._fieldConstructionTypes [$ - 1] = type;
        __version DEBUG {
            // we didn't enter a new foreign apparently
            assert (self._fieldConstructionValidated [$ - 1].len == 0us);
        }
    }

    /**
     * @returns: the list of fields that have been validated during pre validation
     */
    pub fn getFieldValidated (self)-> [[c8] => ()] {
        self._fieldConstructionValidated [$ - 1]
    }

    /**
     * Insert a field inside the list of validated field
     * @params: 
     *   - field: the name of the field that have been validated and then is usable
     */
    pub fn setFieldValidated (mut self, field : [c8]) {
        self._fieldConstructionValidated [$ - 1][field] = ();
    }

    /**
     * @returns: true iif we are currently validating the fields in a pre construction of a ctor of a class
     */
    pub fn isInFieldConstruction (self)-> bool {
        if (self._fieldConstructionTypes.len == 0us) return false;

        match self._fieldConstructionTypes[$ - 1] {
            NoneType () => { false }
            _ => { true }
        }
    }

    /**
     * @returns: the type whose fields are being constructed (might be NONE_TYPE)
     */
    pub fn getFieldConstructionType (self)-> &Type {
        if (self._fieldConstructionTypes.len == 0us) return NONE_TYPE;
        else {
            self._fieldConstructionTypes[$ - 1]
        }
    }
    
    /**
     * Quit the pre validation of fields 
     */
    pub fn quitFieldConstruction (mut self) {
        self._fieldConstructionValidated [$ - 1] = [];
        self._fieldConstructionTypes [$ - 1] = NONE_TYPE;
    }
    
    /**
     * Insert a new variable in the current block
     * @params: 
     *    - name: the name of the variable
     *    - val: the declaration of the variable
     */
    pub fn insertLocal (mut self, loc : &Word, name : [c8], val : &Value, canShadow : bool = false)
        throws ErrorMsg
    {
        if (name == Keys::UNDER) return {}
        if (!canShadow) {
            self.verifyShadow (loc, name-> name);
        }

        self._symbols [$ - 1][$ - 1][name] = val;
    }

    /**
     * Clear the current scope
     */
    pub fn clearLocalScope (mut self) {
        self._symbols [$ - 1][$ - 1] = [];
    }

    /**
     * Search the definition of a local variable
     * @params: 
     *   - name: the name of the variable to search
     *   - canBeInClosure: if the variable can be a variable from the parent of a closure
     * @returns: the generator of the variable or UnitValue
     */
    pub fn getLocal (mut self, loc : &Word, name : [c8], canBeInClosure : bool = true)-> &Value
        throws ErrorMsg
    {
        if (self._symbols.len != 0us) {
            for i in 0 .. self._symbols [$ - 1].len {
                if let Ok (g) = self._symbols [$ - 1][i][name]? {
                    self._usedSyms [$ - 1][i][name] = ();
                    return g;
                }
            }

            if (canBeInClosure) {
                return self:.getInClosure (loc, name);
            }
        }

        UNIT_VALUE
    }

    /**
     * Search the definition of a local variable 
     * @warning: use only for shadowing verification, it does not update used variable infos
     * @params: 
     *   - name: the name of the variable to search
     * @returns: the generator of the variable or UnitValue
     */
    fn getLocalNoUse (self, name : [c8])-> &Value {
        if (self._symbols.len != 0us) {
            for i in 0 .. self._symbols [$ - 1].len {
                if let Ok (g) = self._symbols [$ - 1][i][name]? {
                    return g;
                }
            }
        }

        UNIT_VALUE
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================        GLOBAL SYMBOLS        =========================
     * ================================================================================
     * ================================================================================
     */


    /**
     * Search all the global symbols whose name are name
     * @params: 
     *   - name: the name of the symbols to get
     * @returns: the list of symbols whose name are name, and are accessible from the current context
     */
    pub fn getGlobal (mut self, name : [c8])-> dmut [&Symbol] {
        if (self._referent.len == 0us) return [];
        else {
            let dmut lst = self._referent [$ - 1]:.getSymbols (name);
            return lst:[];
        }
    }

    /**
     * Finalize the validation of a module importation
     * @params:
     *    - l: the lazy module to finalize
     * @returns: the declared module
     * */
    pub fn getModuleFromLazy (mut self, l : &LazyModuleSymbol)-> dmut &ModuleSymbol
        throws ErrorMsg
    {
        self._declarator:.finalizeImportDecl (l)
    }

    /**
     * Search all the global symbols whose name are close to `name`, with a distance of `distance`
     * @params:
     *   - name: the name of the symbols to get
     *   - distance: the distance of the name of the symbol to `name`
     * @returns: the list of symbols whose name are close to `name` (only public ones)
     */
    pub fn getCloseGlobal (self, name : [c8], distance : usize = 2us)-> [&Symbol] {
        if (name.len <= distance + 1us) return [];
        else if (self._referent.len == 0us) return [];
        else {
            let lst = self._referent [$ - 1].getCloseSymbols (name, distance);
            return lst[];
        }
    }

    /**
     * Search all the global symbols whose name are name
     * @params:
     *   - name: the name of the symbols to get
     * @returns: the list of symbols whose name are name, even if they are not accessible from the current context (protection)
     */
    pub fn getGlobalPrivate (mut self, name : [c8])-> dmut [&Symbol] {
        if (self._referent.len == 0us) return [];
        else {
            let dmut lst = self._referent [$ - 1]:.getSymbols (name, protection-> Protection::PRIVATE);
            return lst:[];
        }
    }

    /**
     * Search all the local symbols whose name are name in the module mref
     * @params:
     *    - mref: the module in which the search is made
     *    - name: the name of the symbols to get
     * @returns: the list of found symbols
     * */
    pub fn getLocalFromMod (mut self, mref : &ModuleRefValue, name : [c8])-> dmut [&Symbol] {
        self._declarator:.getLocalFromContext (name, self.getReferent (), mref.getSymbol ())
    }

    /**
     * Search all the local symbols whose name are name in the module mref with private protection
     * @params:
     *    - mref: the module in which the search is made
     *    - name: the name of the symbols to get
     * @returns: the list of found symbols even if they are not accessible from the current context
     * */
    pub fn getLocalFromModPrivate (mut self, mref : &ModuleRefValue, name : [c8])-> dmut [&Symbol] {
        self._declarator:.getLocalFromContext (name, self.getReferent (), mref.getSymbol (), protection-> Protection::PRIVATE)
    }

    /**
     * Search all the local symbols whose name are close to name
     * @params:
     *    - mref: the module in which the search is made
     *    - name: the name of the symbols to get
     * @returns: the list of found symbols
     * */
    pub fn getCloseLocalFromMod (self, mref : &ModuleRefValue, name : [c8], distance : usize = 2us)-> [&Symbol] {
        self._declarator.getCloseLocalFromContext (name, distance-> distance, self.getReferent (), mref.getSymbol ())
    }

    /**
     * @returns: the mutable version of the module registered in the module ref
     * @panic: if the module ref points to an invalid module
     */
    pub fn getModuleFromRef (mut self, module : &ModuleRefValue)-> dmut &Symbol {
        self._declarator:.getMutableSymbol (module.getSymbol ())
    }

    /**
     * @returns: the mutable version of the symbol 
     * @panic: if the symbol is invalid, and was not declared by the current context
     */
    pub fn getClassFromRef (mut self, sym : &ClassSymbol)-> dmut &Symbol {
        self._declarator:.getMutableSymbol (sym)
    }

    /**
     * @returns: the mutable version of the symbol 
     * @panic: if the symbol is invalid, and was not declared by the current context
     */
    pub fn getSymbolFromRef (mut self, sym : &Symbol)-> dmut &Symbol {
        self._declarator:.getMutableSymbol (sym)
    }

    /**
     * Insert a generator for post validation
     * @params:
     *    - sym: the symbol responsible of the generation
     *    - gen: the generator created
     * */
    pub fn insertGenerator (mut self, dmut sym : &Symbol, gen : &Generator) {
        self._generators ~= [gen];
        sym:.insertGenerator (gen);
    }

    /**
     * Insert a custom generator
     * @info: a custom generator is not attached to a symbol (for example the comparison informations of a map type)
     * @info: only insert the generator if it does not exist
     * @params:
     *    - name: the name of the custom generator
     *    - gen: the generator to insert
     * */
    pub fn insertCustomGenerator (mut self, name : [c8], gen : &Generator) {
        if (name !in self._customGenerators) {
            self._customGenerators [name] = ();
            self._generators ~= [gen];
        }
    }

    /**
     * @returns: true if the custom generator 'name' is already inserted
     * */
    pub fn hasCustomGenerator (self, name : [c8])-> bool {
        name in self._customGenerators
    }

    /**
     * Insert a named generator
     * @info: only insert the generator if it does not exist
     * @params:
     *    - name: the name of the custom generator
     *    - gen: the generator to insert
     * */
    pub fn insertNamedGenerator (mut self, name : [c8], dmut sym : &Symbol, gen : &Generator) {
        if (name !in self._customGenerators) {
            self._customGenerators [name] = ();
            self._generators ~= [gen];
            sym:.insertGenerator (gen);
        }
    }

    /**
     * Insert errors that explains missing symbols generation
     * This errors might be caught by the parser, or may not be depending on when they were thrown but will stop the parsing before the generation phase
     * */
    pub fn insertMissingGenerator (mut self, err : &ErrorMsg) {
        self._genErrors ~= [err];
    }

    /**
     * Errors that were not caught, but that provoke failure in generator insertions
     * */
    pub fn getMissingGenerators (self)-> [&ErrorMsg] {
        self._genErrors
    }

    /**
     * @returns: the list of generators created during validation
     * */
    pub fn getGenerators (self)-> [&Generator] {
        self._generators
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================          INFERENCE           =========================
     * ================================================================================
     * ================================================================================
     */


    /**
     * Infer the type of two values
     * @params:
     *    - loc: the location of the operation
     *    - left: the left value
     *    - right: the right value
     * @returns:
     *    - .0: the infered type
     *    - .1: the left value implicitely casted to .0
     *    - .2: the right value implicitely casted to .0
     * */
    pub fn inferTypeBranchingWithValues (mut self, loc : &Word, left : &Value, right : &Value)-> (&Type, &Value, &Value)
        throws ErrorMsg
    {
        { // try by casting to left
            let (t1, resLeft) = self:.inferTypeBranchingWithValue (loc, NONE_TYPE, left);
            let (t2, resRight) = self:.inferTypeBranchingWithValue (loc, t1, right);

            return (t2, resLeft, resRight);
        } catch {
            lerr : &ErrorMsg => {
                { // try by casting to right
                    let (t1, resRight) = self:.inferTypeBranchingWithValue (loc, NONE_TYPE, right);
                    let (t2, resLeft) = self:.inferTypeBranchingWithValue (loc, t1, left);

                    return (t2, resLeft, resRight);
                } catch {
                    err : &ErrorMsg => {
                        throw copy ErrorMsg::list (copy [lerr, err]);
                    }
                }
            }
        }
    }

    /**
     * Infer the type from two branch that must lead to a common type 
     * @info: by setting none to oldType, only the type of val will be used
     * @params: 
     *   - loc: the location of the branching
     *   - oldType: the type of the other branch
     *   - val: the value of the current branch
     * @returns: the type that is common to oldType and val.getType (), without explicit cast needed
     * @throws:
     *   - &ErrorMsg: if there is no common type possible
     */
    pub fn inferTypeBranchingWithValue (mut self, loc : &Word, oldType : &Type, val : &Value)-> (&Type, &Value)
        throws ErrorMsg
    {
        let v = {
            self:.verifyCompatibleTypeWithValue (loc, oldType, val, byReference-> false)
        } catch {
            _ => { val }
        };

        let ret = self.inferTypeBranching (loc, val.getLoc (), oldType, v.getType ());

        let value = self:.verifyCompatibleTypeWithValue (loc, ret, v, byReference-> false);
        let finRet = self:.inferTypeImplicitMutability (ret, value);
        (finRet, value)
    }

    /**
     * Infer the type from two branch that must lead to a common type 
     * @info: by setting none to oldType, only the type of val will be used
     * @params: 
     *   - lloc: the location of the left branch
     *   - rloc: the location of the right branch
     *   - left: the type of the left branch
     *   - right: the type of the right branch
     * @returns: the type that is common to oldType and val.getType (), without explicit cast needed
     * @throws:
     *   - &ErrorMsg: if there is no common type possible
     */
    pub fn inferTypeBranching (self, lloc : &Word, rloc : &Word, left : &Type, right : &Type)-> &Type
        throws ErrorMsg
    {
        if (left of NoneType) return right;

        if (left == right) {
            if (!left.mutabilityFit (right)) return left; // mutability of right is higher than the one of left, e.g. l = [i32], r = mut [mut i32]
            else return right; // left.mutabilityFit (right), e.g. l = mut [mut i32], r = [i32] or r = mut [mut i32]
        }
        
        match (left, right) {
            (slc : &SliceType, rslc : &SliceType) => {
                return self.inferTypeBranchingSlices (lloc, rloc, slc, rslc);
            }
            (lp : &ClassPtrType, rp : &ClassPtrType) => {
                return self.inferTypeBranchingClass (lloc, rloc, lp, rp);
            }
            (ltp : &TupleType, rtp : &TupleType) => {
                return self.inferTypeBranchingTuple (lloc, rloc, ltp, rtp);
            }
            (opL : &OptionType, opR : &OptionType) => {
                return self.inferTypeBranchingOptions (lloc, rloc, opL, opR);
            }
            (ptrL : &PointerType, ptrR : &PointerType) => {
                return self.inferTypeBranchingPointers (lloc, rloc, ptrL, ptrR);
            }
            (EnumType (), _) => {
                return self.inferTypeBranching (lloc, rloc, self.implicitEnumUnwrap (left), right);
            }
            (_, EnumType ()) => {
                return self.inferTypeBranching (lloc, rloc, left, self.implicitEnumUnwrap (right));
            }
        }

        throw copy ErrorMsg::fatal (lloc, end-> rloc, format (ValidateErrorMessage::INCOMPATIBLE_TYPE, left, right));
    }

    /**
     * Infer the type from two branch that must lead to a common type , where left and right types are slice types but not equal
     * @params:
     *   - lloc: the location of the left branch
     *   - rloc: the location of the right branch
     *   - left: the type of the left branch
     *   - right: the type of the right branch
     * @returns: the type that is common to oldType and val.getType (), without explicit cast needed
     * @throws:
     *   - &ErrorMsg: if there is no common type possible
     */
    fn inferTypeBranchingSlices (self, lloc : &Word, rloc : &Word, left : &SliceType, right : &SliceType)-> &Type
        throws ErrorMsg
    {
        if (left.getInners ()[0] of VoidType) return right;
        if (right.getInners ()[0] of VoidType) return left;
        
        let inner = {
            self.inferTypeBranching (lloc, rloc, left.getInners ()[0], right.getInners ()[0])
        } catch {
            ErrorMsg () => {
                throw copy ErrorMsg::fatal (lloc, end-> rloc, format (ValidateErrorMessage::INCOMPATIBLE_TYPE, left, right));
            }
        }

        copy SliceType (lloc, inner, isMutable-> left.isMutable () && right.isMutable ())
    }

    /**
     * Infer the type from two branch that must lead to a common type , where left and right types are option types but not equal
     * @params:
     *   - lloc: the location of the left branch
     *   - rloc: the location of the right branch
     *   - left: the type of the left branch
     *   - right: the type of the right branch
     * @returns: the type that is common to oldType and val.getType (), without explicit cast needed
     * @throws:
     *   - &ErrorMsg: if there is no common type possible
     */
    fn inferTypeBranchingOptions (self, lloc : &Word, rloc : &Word, left : &OptionType, right : &OptionType)-> &Type
        throws ErrorMsg
    {
        if (left.getInners ()[0] of NoneType) return right; // none literal
        if (right.getInners ()[0] of NoneType) return left; // none literal

        let inner = {
            self.inferTypeBranching (lloc, rloc, left.getInners ()[0], right.getInners ()[0])
        } catch {
            ErrorMsg () => {
                throw copy ErrorMsg::fatal (lloc, end-> rloc, format (ValidateErrorMessage::INCOMPATIBLE_TYPE, left, right));
            }
        }

        copy OptionType (lloc, inner, isMutable-> left.isMutable () && right.isMutable ())
    }

    /**
     * Infer the type from two branch that must lead to a common type , where left and right types are option types but not equal
     * @params:
     *   - lloc: the location of the left branch
     *   - rloc: the location of the right branch
     *   - left: the type of the left branch
     *   - right: the type of the right branch
     * @returns: the type that is common to oldType and val.getType (), without explicit cast needed
     * @throws:
     *   - &ErrorMsg: if there is no common type possible
     */
    fn inferTypeBranchingPointers (self, lloc : &Word, rloc : &Word, left : &PointerType, right : &PointerType)-> &Type
        throws ErrorMsg
    {
        if (left.getInners ()[0] of NoneType) return right; // null literal
        if (right.getInners ()[0] of NoneType) return left; // null literal

        let inner = {
            self.inferTypeBranching (lloc, rloc, left.getInners ()[0], right.getInners ()[0])
        } catch {
            ErrorMsg () => {
                throw copy ErrorMsg::fatal (lloc, end-> rloc, format (ValidateErrorMessage::INCOMPATIBLE_TYPE, left, right));
            }
        }

        copy PointerType (lloc, inner, isMutable-> left.isMutable () && right.isMutable ())
    }


    /**
     * Infer the type from two branch that must lead to a common type , where left and right types are class ptr types but not equal
     * @params: 
     *   - lloc: the location of the left branch
     *   - rloc: the location of the right branch
     *   - left: the type of the left branch
     *   - right: the type of the right branch
     * @returns: the type that is common to oldType and val.getType (), without explicit cast needed
     * @throws:
     *   - &ErrorMsg: if there is no common type possible
     */
    fn inferTypeBranchingClass (self, lloc : &Word, rloc : &Word, left : &ClassPtrType, right : &ClassPtrType)-> &Type
        throws ErrorMsg
    {
        if (self.isAncestor (left, right)) {
            if (left.mutabilityFit (right)) return left.clone (pattern-> right);
            else return left;
        }
        if (self.isAncestor (right, left)) {
            if (right.mutabilityFit (left)) return right.clone (pattern-> left);
            else return right;
        }

        match self.getCommonAncestor (lloc, left, right) {
            c : &ClassPtrType => {
                let distLeft = c.mutabilityDistance (left), distRight = c.mutabilityDistance (right);
                if (distLeft > distRight) return c.clone (pattern-> left);
                else return c.clone (pattern-> right);
            }
            _ => {
                throw copy ErrorMsg::fatal (lloc, end-> rloc, format (ValidateErrorMessage::INCOMPATIBLE_TYPE, left, right));
            }
        }        
    }

    /**    
     * Infer the type from two branch that must lead to a common type , where left and right types are tuple types but not equal
     * @params: 
     *   - lloc: the location of the left branch
     *   - rloc: the location of the right branch
     *   - left: the type of the left branch
     *   - right: the type of the right branch
     * @returns: the type that is common to oldType and val.getType (), without explicit cast needed
     * @throws:
     *   - &ErrorMsg: if there is no common type possible
     */
    fn inferTypeBranchingTuple (self, lloc : &Word, rloc : &Word, left : &TupleType, right : &TupleType)-> &Type
        throws ErrorMsg
    {
        if (left.getInners ().len != right.getInners ().len ) {
            throw copy ErrorMsg::fatal (lloc, end-> rloc, format (ValidateErrorMessage::INCOMPATIBLE_TYPE, left, right));
        }

        let mut inners : [mut &Type] = [];
        {
            for i in 0us .. left.getInners ().len {
                let inner = self.inferTypeBranching (lloc, rloc, left.getInners ()[i], right.getInners ()[i]);
                self.verifyCompleteType (lloc, inner, false);

                inners ~= [inner];
            }
        } catch {
            ErrorMsg () => {
                throw copy ErrorMsg::fatal (lloc, end-> rloc, format (ValidateErrorMessage::INCOMPATIBLE_TYPE, left, right));
            }
        }

        copy TupleType (lloc, inners, isMutable-> left.isMutable () && right.isMutable ())
    }

    /**
     * Infer a lambda value from a function or delegate type
     * @params: 
     *   - type: the type that will help for the inference
     *   - val: the value in which the search is performed
     * @returns: a lambda value
     * @throws: 
     *   - &ErrorMsg: if is was not found, or the inference is impossible 
     */
    pub fn inferLambdaValue (mut self, type : &Type, val : &Value)-> &Value
        throws ErrorMsg
    {
        let innerVal = match val {
            v : &VarRefValue => { v.getValue () } // The lambda value can be hidden in a variable
            _ => { val }
        };
        
        match innerVal {            
            lmbd : &LambdaValue => {
                let paramTypes = match type {
                    f : &FuncPtrType => { f.getParameters () }
                    d : &DelegateType => { d.getParameters () }
                    _ => { throw copy ErrorMsg::fatal (val.getLoc (), format (ValidateErrorMessage::INCOMPATIBLE_TYPE, type, val.getType ())); } // The lambda value was found, but the result cannot be infered
                }
                
                if (lmbd.getParameters ().len != paramTypes.len) {
                    throw copy ErrorMsg::fatal (val.getLoc (), format (ValidateErrorMessage::INCOMPATIBLE_TYPE, type, val.getType ()));
                }
                
                let (proto, frame) = self._lambdaValidator:.validateLambdaBody (alias self, lmbd, paramTypes); // Validate the lambda from the parameters of  'type'
                self._lambdaValidator.insertGenerator (alias self, frame);
                return proto;
            }
            _ => { // The lambda value was not found
                throw copy ErrorMsg::fatal (val.getLoc (), format (ValidateErrorMessage::INCOMPATIBLE_TYPE, type, val.getType ()));
            }
        };
    }

    /**
     * Infer the correct mutability for an inner type inside an array, tuple or slice from a value
     * @params:
     *    - val: the value that will be put in the array
     * */
    pub fn inferTypeImplicitMutability (mut self, innerType : &Type, val : &Value)-> &Type {
        if (!innerType.isMutable ()) {
            innerType.cloneMutableTilBorrow ()
        } else {
            self.verifyMemoryOwner (val.getLoc (), innerType, val, byReference-> false);
            innerType
        } catch {
            _ => innerType.cloneMutableTilBorrow ()
        }
    }

    /**
     * Infer the correct mutability for an inner type inside an array, tuple or slice from a value
     * @params:
     *    - val: the value that will be put in the array
     * */
    pub fn inferTypeImplicitMutability (mut self, val : &Value)-> &Type {
        let innerType = val.getType ();
        if (!innerType.isMutable ()) {
            innerType.cloneMutableTilBorrow ()
        } else {
            self.verifyMemoryOwner (val.getLoc (), innerType, val, byReference-> false);
            innerType
        } catch {
            _ => innerType.cloneMutableTilBorrow ()
        }
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================         VERIFICATION         =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Verify if the current context is not explicitely unsafe, in which case an error is thrown
     * */
    pub fn verifyUnsafeContext (mut self, loc : &Word, msg : [c8] = ValidateErrorMessage::UNSAFE_OPERATION)
        throws ErrorMsg
    {
        if (self._inUnsafeContext [$ - 1].isEof ()) {
            throw copy ErrorMsg::fatal (loc, msg);
        } else {
            self._inUnsafeContextUsed [$ - 1] = loc;
        }
    }

    /**
     * Verify that the variable is not shadowing another variable
     * And that the variable name is a valid variable identifier (not a native type)
     * @params: 
     *    - loc: the location and name of the variable that may shadow
     * @throws: &ErrorMsg, if the variable shadows another local declaration, or the variable name is a type name
     */
    pub fn verifyShadow (self, loc : &Word, name : [c8] = "")
        throws ErrorMsg
    {
        let realName = if (name == "") {
            loc.str
        } else { name };

        // No shadow for ignore var
        if (realName == Keys::UNDER) return;

        // No shadow for internal variables
        if (realName.len > 0us && realName [0] == '#') return;

        self.verifyNotIsNativeType (loc, realName);
        match self.getLocalNoUse (realName) {
            UnitValue () => {}
            gen : _ => {
                throw copy ErrorMsg::fatal (loc, format (ValidateErrorMessage::SHADOWING_DECL, realName),
                                            notes-> copy [copy ErrorMsg::note (gen.getLoc (), ValidateErrorMessage::FIRST_DEFINED)]);
            }
        }
    }

    /**
     * Verify that the name of the variable is not a native type
     * @params: 
     *   - loc: the location and name of the variable
     * @throws: &ErrorMsg, iif the name of the variable is a native type
     */
    pub fn verifyNotIsNativeType (self, loc : &Word, name : [c8])
        throws ErrorMsg
    {
        if name in self._nativeTypeNames {
            throw copy ErrorMsg::fatal (loc, format (ValidateErrorMessage::IS_NATIVE_TYPE, name));
        }
    }

    /**
     * Verify that the value is not a breaker, or a returner value
     * And thus that the statement at loc 'loc' is reachable
     * @params:
     *   - loc: the location of the next statement
     *   - value: the value being checked
     * */
    pub fn verifyNoBreaking (self, loc : &Word, value : &Value)
        throws ErrorMsg
    {
        if (value.isBreaker ()) {
            throw copy ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNREACHBLE_STATEMENT),
                                        notes-> copy [copy ErrorMsg::note (value.getBreakerLoc (), ValidateErrorMessage::EXITING_SCOPE_HERE)]);
        } else if (value.isReturner ()) {
            throw copy ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNREACHBLE_STATEMENT),
                                        notes-> copy [copy ErrorMsg::note (value.getReturnerLoc (), ValidateErrorMessage::EXITING_SCOPE_HERE)]);
        }
    }

    /**
     * Verify that the value can be place in a position where its direct value can be modified
     * @example:
     * ===========
     * a = 1; // for a
     * foo (ref a); // for a
     * a [0] = 9; // for a [0]
     * &a // for a
     * ===========
     * @params:
     *    - loc: the location of the movement
     *    - value: the value that could be modified
     *    - allowImmutable: true if we allow the variable to be immutable (for memory address for example, or implicit ref)
     * @throws:
     *    - ErrorMsg: if it is not allowed
     * */
    pub fn verifyLeftOperandMove (self, loc : &Word, value : &Value, allowImmutable : bool = false, forMove : bool = false, allowSelf : bool = false)
        throws ErrorMsg
    {
        if (value of FakeValue) return {}
        if (allowSelf && self.isSelf (value)) {
            if (!allowImmutable && !value.getType ().isMutable ()) { // only mutable element can be used as left operand
                throw copy ErrorMsg::fatal (end-> loc, value.getLoc (), format (ValidateErrorMessage::IMMUTABLE_LVALUE, value.getType ()));
            }

            return {}
        }

        if (!value.isLvalue ()) { // only lvalue can be used as left operand, and not self
            throw copy ErrorMsg::fatal (end-> loc, value.getLoc (), format (ValidateErrorMessage::NOT_A_LVALUE, value));
        } else if (!allowImmutable && self.isSelf (value)) {
            throw copy ErrorMsg::fatal (end-> loc, value.getLoc (), format (ValidateErrorMessage::NOT_A_LVALUE, value));
        } else if (!allowImmutable && !forMove && self.isParameter (value) && !self.isReference (value)) {
            throw copy ErrorMsg::fatal (end-> loc, value.getLoc (), format (ValidateErrorMessage::NOT_A_LVALUE_PARAM, value));
        } else if (!allowImmutable && !forMove && self.isIterator (value) && !self.isReference (value)) {
            throw copy ErrorMsg::fatal (end-> loc, value.getLoc (), format (ValidateErrorMessage::NOT_A_LVALUE_ITERATOR, value));
        } else if (!allowImmutable && value of ClosureFieldAccessValue) {
            throw copy ErrorMsg::fatal (end-> loc, value.getLoc (), format (ValidateErrorMessage::NOT_A_LVALUE_CLOSURE, value));
        } else if (self.isLazy (value)) {
            throw copy ErrorMsg::fatal (end-> loc, value.getLoc (), format (ValidateErrorMessage::NOT_A_LVALUE_LAZY, value));
        }

        if (!allowImmutable && !value.getType ().isMutable ()) { // only mutable element can be used as left operand
            throw copy ErrorMsg::fatal (end-> loc, value.getLoc (), format (ValidateErrorMessage::IMMUTABLE_LVALUE, value.getType ()));
        }
    }

    /**
     * Verify that the value `value` can be casted into the type `type` implicitely
     * @warning: this does not check implicit aliases and references (cf. self.verifyMemoryOwner)
     * @params: 
     *   - loc: the location of the affectation    
     *   - type: the type into which the cast is made
     *   - value: the value used
     *   - byReference: true if the compatibility can be by reference (immutable)
     * @returns: the value 'value' (casted if needed)
     * @throws: &ErrorMsg: if the cast cannot be made
     */
    pub fn verifyCompatibleTypeWithValue (mut self, loc : &Word, type : &Type, value : &Value, byReference : bool)-> &Value
        throws ErrorMsg
    {
        if (byReference) {
            if (value !of ReferencerValue && !type.isMutable ()) {
                let inner = self:.verifyCompatibleTypeWithValue (loc, type, value, byReference-> false);
                if (!self.checkLeftOperandMove (inner, allowImmutable-> true, allowSelf-> true)) {
                    return inner;
                } else {
                    return copy ReferencerValue (value.getLoc (), inner.getType (), inner, isMutable-> false);
                }
            } else {
                self.verifyCompatibleType (loc, value.getLoc (), type, value.getType (), noAncestor-> true);
                return value;
            }
        }

        let result = self._castValidator.validateImplicit (alias self, loc, value, type);
        result
    }

    /**
     * Verify the compatibility of two types (not complete equals)
     * @params: 
     *   - lLoc: the location of the left type (or left operand, this is the location that will be shown in the error message)
     *   - rLoc: the location of the right type (or right operand, this is the location that will be shown in the error message)
     *   - noAncestor: don't check for ancestor compatibility 
     * @throws: &ErrorMsg: if the type are not compatible
     */
    pub fn verifyCompatibleType (self, lLoc : &Word, rLoc : &Word, left : &Type, right : &Type, noAncestor : bool = false)
        throws ErrorMsg
    {
        if (!left.isCompatible (right)) {
            let mut innerErr : [mut &ErrorMsg] = [];
            {
                if (self.isProxy (left, right)) return;
                if (!noAncestor) {
                    if (self.isAncestor (left, right)) return;;
                    if (self.verifyAncestorCompatibleInNativeCompound (left, right)) return;;
                } else {
                    if (self.isAncestor (left, right)) {
                        throw copy ErrorMsg::fatal (lLoc, end-> rLoc, format (ValidateErrorMessage::CANNOT_CASTTO_BASE_CLASS, right, left));
                    }
                }
            } catch {
                err : &ErrorMsg => {
                    innerErr ~= [err];
                }
            }

            if (lLoc.line == rLoc.line) {
                throw copy ErrorMsg::fatal (lLoc, end-> rLoc, format (ValidateErrorMessage::INCOMPATIBLE_TYPE, left, right), notes-> innerErr);
            } else {
                innerErr ~= [copy ErrorMsg::note (lLoc, "")];
                throw copy ErrorMsg::fatal (rLoc, format (ValidateErrorMessage::INCOMPATIBLE_TYPE, left, right), notes-> innerErr);
            }
        }
    }

    /**
     * Verify that left is compatible with right
     * @info: if left and right are native compound types (array, slice, pointer, tuple...) they might be imcompatble but implicitely castable if they contains objects
     * @params:
     *    - left: the type of the left operand (to which the cast is done)
     *    - right: the type of the right operand (from which the implicit cast is done)
     * @returns: true if the cast is possible (false means this not a native compound type)
     * @throws:
     *    - &ErrorMsg: if the cast is forbidden within the compound native type
     * */
    fn verifyAncestorCompatibleInNativeCompound (self, left : &Type, right : &Type, noAncestor : bool = false)-> bool
        throws ErrorMsg
    {
        {
            match (left, right) {
                (lArr : &ArrayType, rArr : &ArrayType) => { // [&A ; 4] <= [&B ; 4] iif B over A
                    if (lArr.getLen () == rArr.getLen ()) {
                        let innerLeft = lArr.getInners ()[0];
                        let innerRight = rArr.getInners ()[0];
                        self.verifyCompatibleType (innerLeft.getLoc (), innerRight.getLoc (), innerLeft, innerRight, noAncestor-> noAncestor);

                        return true;
                    }
                }
                (lSlc : &SliceType, rSlc : &SliceType) => { // [&A] <= [&B] iif B over A
                    let innerLeft = lSlc.getInners ()[0];
                    let innerRight = rSlc.getInners ()[0];
                    self.verifyCompatibleType (innerLeft.getLoc (), innerRight.getLoc (), innerLeft, innerRight, noAncestor-> noAncestor);

                    return true;
                }
                (lTu : &TupleType, rTu : &TupleType) => {
                    if (lTu.getInners ().len == rTu.getInners ().len) { // (&A,) <= (&B,) iif B over A
                        for i in 0us .. lTu.getInners ().len {
                            let innerLeft = lTu.getInners ()[i];
                            let innerRight = rTu.getInners ()[i];
                            self.verifyCompatibleType (innerLeft.getLoc (), innerRight.getLoc (), innerLeft, innerRight, noAncestor-> noAncestor);
                        }
                        return true;
                    }
                }
                (lMT : &MapType, rMT : &MapType) => {
                    let innerKeyLeft = lMT.getInners ()[0];
                    let innerKeyRight = rMT.getInners ()[0];
                    self.verifyCompatibleType (innerKeyLeft.getLoc (), innerKeyRight.getLoc (), innerKeyLeft, innerKeyRight, noAncestor-> noAncestor);

                    let innerValLeft = lMT.getInners ()[1];
                    let innerValRight = rMT.getInners ()[1];
                    self.verifyCompatibleType (innerValLeft.getLoc (), innerValRight.getLoc (), innerValLeft, innerValRight, noAncestor-> noAncestor);

                    return true;
                }
                (lo : &OptionType, ro : &OptionType) => {
                    let innerLeft = lo.getInners ()[0];
                    let innerRight = ro.getInners ()[0];

                    self.verifyCompatibleType (innerLeft.getLoc (), innerRight.getLoc (), innerLeft, innerRight, noAncestor-> noAncestor);

                    return true;
                }
            }
        }

        return false;
    }

    /**
     * Create a slice alias using an array value
     * @warning: this function does not make a copy of the array, thus it assumes that the value will be used to create a copy of some sort
     * @params:
     *     - loc: the location of the operation
     *     - a: the type of the array to alias
     *     - v: the value of the array to alias
     *     - mutable: true if the alias is mutable (if array is not mutable, does not override its real mutability)
     * @returns: a slice ctor values, containing the address of the array as a pointer
     * */
    pub fn createSliceAliasFromArray (self, loc : &Word, a : &ArrayType, v : &Value, mutable : bool = true)-> &Value {
        let inner = if (mutable) {
            a.getInners ()[0]
        } else { a.getInners ()[0].clone (0u32) };

        let sliceType = {
            copy SliceType (loc, inner, isMutable-> (inner.isMutable () && mutable))
        } catch { // array type cannot enclose movable, so inner cannot be a movable
            _ => panic;
        };

        if (a.getLen () != 0us) {
            let ptrType = copy PointerType (loc, inner, isMutable-> inner.isMutable ());
            let arrayAddr = copy AddressValue (loc, ptrType, v);
            copy SliceCtorValue (loc, sliceType, arrayAddr,
                                 copy NullValue (loc), // no blk info, array are stack located
                                 makeIntValue (loc, a.getLen ()), isImplicitAlias-> false)
        } else {
            let nl = copy NullValue (loc);
            copy SliceCtorValue (loc, sliceType,
                                 nl,
                                 nl, // blk info is empty since slice is empty
                                 makeIntValue (loc, 0us), isImplicitAlias-> false)
        }
    }

    /**
     * Create a slice containing only one element from a single element
     * It can be useful to append values at the end of slices for example
     * @params:
     *    - loc: the location of the creation
     *    - v: the value to put in the slice
     *     - mutable: true if the alias is mutable (if array is not mutable, does not override its real mutability)
     * @returns: a slice ctor values, containing the address of the array as a pointer
     */
    pub fn createSliceFromSingleValue (self, loc : &Word, v : &Value, mutable : bool = true)-> &Value
        throws ErrorMsg
    {
        let arrType = copy ArrayType (loc, v.getType (), 1us, isMutable-> mutable);
        return self.createSliceAliasFromArray (loc, arrType, copy ArrayValue (loc, arrType, copy [v]));
    }

    /**
     * @warning: Function that must be called at any affectation or memory movement in the code
     * Verify that the movement of memory is permitted (no implicit alias, no const disqualifier, etc.)
     * @params:
     *   - loc: the location of the affectation
     *   - type: the type of the operation, to which the value is casted
     *   - value: the value that is moved
     *   - construct: true iif this is the construction of a new variable (this is the only time lambda are allowed)
     *   - checkTypes: if false does not call verifyCompatibleTypeWithValue, (this should be disable only if this was done beforehand)
     *   - byReference: if true the left type is a reference
     *   - byLazy: for matcher only? force the inner lazy matching
     *   - byMove: for matcher only? force the inner move matching (upper matching already verified that move was used)
     * @throws:
     *   - ErrorMsg: if the operation is not permitted
     */
    pub fn verifyMemoryOwner (self, loc : &Word, valueLoc : &Word = EOF_WORD, type : &Type, value : &Value, construct : bool = false, byReference : bool, byLazy : bool = false, byMove : bool = false)
        throws ErrorMsg
    {
        let endLoc = if valueLoc.isEof () { value.getLoc () } else { valueLoc };

        self.verifyCompleteTypeWithValue (loc, valueLoc-> endLoc, type, value, construct); // Verify that the type can be used (if it is incomplete it cannot)
        self.verifyImplicitAlias (loc, valueLoc-> endLoc, type, value, byReference-> byReference); // Verify that the movement is not made implicitely
        self.verifyImplicitLazy (loc, valueLoc-> endLoc, type, value, byLazy);
        if (!byReference && !byMove) self.verifyImplicitMove (loc, valueLoc-> endLoc, type, value);

        match type {
            l : &LambdaType => { // lambda type cannot be changed, they are not really values
                if (!construct || value !of LambdaValue) throw copy ErrorMsg::fatal (endLoc,
                                                                                     format (ValidateErrorMessage::USE_AS_VALUE_TYPE, l), notes-> copy [copy ErrorMsg::note (loc, "")]);
                
                self.verifyMutabilityLevel (loc, endLoc, type, value.getType (), byReference);
            }
            OptionType () => { // Same as pointer , but with none
                if (value !of ErrOptionValue) {
                    self.verifyMutabilityLevel (loc, endLoc, type, value.getType (), byReference);
                }
            }
            _ => { // all the other types must be checked in a deeper analyses
                self.verifyMutabilityLevel (loc, endLoc, type, value.getType (), byReference);
            }
        }
    }

    /**
     * Verify that the type is complete and non void to be used in a variable declaration
     * */
    pub fn verifyNonVoidType (self, loc : &Word, type : &Type, construct : bool)
        throws ErrorMsg
    {
        self.verifyCompleteType (loc, type, construct);
        if (type of LambdaType && construct) return {}
        if (!type.isAddressable ()) {
            throw copy ErrorMsg::fatal (loc, format (ValidateErrorMessage::DECLARE_VOID_VAR, type));
        }

        if (type of VoidType) {
            throw copy ErrorMsg::fatal (loc, format (ValidateErrorMessage::DECLARE_VOID_VAR, type));
        }
    }


    /**
     * Verification that the type used is complete and therefore can be used inside another type or to create a value
     * @params: 
     *  - loc: the location of the use
     *  - type: the type to check
     *  - construct: true iif this is the creation of a new variable (in that case lambda type are authorized)
     * @throws:
     *  - &ErrorMsg: if there is something not allowed here
     */
    pub fn verifyCompleteType (self, loc : &Word, type : &Type, construct : bool)
        throws ErrorMsg
    {
        if (type of LambdaType && construct) return {}
        if (type of TemporaryType) {
            let endLoc = if (!loc.isSame (type.getLoc ()) && !type.getLoc ().isEof ()) {
                type.getLoc ()
            } else { EOF_WORD };

            match (type) {
                cl : &ClassRefType => {
                    if (!cl.isStruct ()) {
                        let notes = copy [copy ErrorMsg::note (loc, format (ValidateErrorMessage::FORGET_AND_CLASS), oneLine-> true)];
                        throw copy ErrorMsg::fatal (loc, end-> endLoc, format (ValidateErrorMessage::INCOMPLETE_TYPE_CLREF, type), notes-> notes);
                    }
                }
            }

            throw copy ErrorMsg::fatal (loc, end-> endLoc, format (ValidateErrorMessage::INCOMPLETE_TYPE, type));
        }
    }

    /**
     * Verification that type used is complete and therefore can be used to create a value
     * */
    pub fn verifyCompleteTypeWithValue (self, loc : &Word, valueLoc : &Word = EOF_WORD, type : &Type, value : &Value, construct : bool)
        throws ErrorMsg
    {
        let endLoc = if valueLoc.isEof () { value.getLoc () } else { valueLoc };
        match value {
            m : &MethodDelegateValue => {
                if (!m.isAddressed ()) {
                    throw copy ErrorMsg::fatal (loc, end-> endLoc, format (ValidateErrorMessage::IMPLICIT_ADDRESS_METHOD, m, tags-> FormatTags (withParams-> true)),
                                                notes-> copy [copy ErrorMsg::note (loc, format (ValidateErrorMessage::FORGET_PAR_PROTO_CALL, "()"), oneLine-> true),
                                                              copy ErrorMsg::note (loc, format (ValidateErrorMessage::FORGET_AND_PROTO), oneLine-> true)]);
                }
            }
            p : &PrototypeValue => {
                throw copy ErrorMsg::fatal (loc, end-> endLoc, format (ValidateErrorMessage::IMPLICIT_ADDRESS_FUNCTION, p, tags-> FormatTags (withParams-> true)),
                                            notes-> copy [copy ErrorMsg::note (loc, format (ValidateErrorMessage::FORGET_PAR_PROTO_CALL, "()"), oneLine-> true),
                                                          copy ErrorMsg::note (loc, format (ValidateErrorMessage::FORGET_AND_PROTO), oneLine-> true)]);
            }
        }

        {
            self.verifyCompleteType (loc, type, construct);
        } catch {
            err : &ErrorMsg => {
                throw err.withNote (copy [copy ErrorMsg::note (endLoc, format (ValidateErrorMessage::WHEN_CREATING_VALUE, value))]);
            }
        }
    }

    /**
     * Verification that the the type does not need alias, and otherwise that the value is an aliaser
     * @warning: does not fully check the mutability etc., cf. verifyMutabilityLevel
     * @params: 
     *  - loc: the location of the movement
     *  - value: the value that is moved
     * @throws:
     *  - &ErrorMsg: if there is something not allowed here
     */
    fn verifyImplicitAlias (self, loc : &Word, valueLoc : &Word = EOF_WORD, type : &Type, value : &Value, byReference : bool)
        throws ErrorMsg
    {
        let endLoc = if valueLoc.isEof () { value.getLoc () } else { valueLoc };

        // Value to a value that needs ref, but without explicitely writing it
        // e.g. { let z = 12; let ref x = z; }
        if byReference && value !of ReferencerValue {
            throw copy ErrorMsg::fatal (loc, end-> endLoc, format (ValidateErrorMessage::IMPLICIT_REFERENCE, value.getType ()));
        }

        // Value to a value that needs mutable ref, but only simple ref was used
        // e.g. { let mut z = 12; let mut ref x = ref z; } // mref has to be used not ref
        else if (byReference) {
            if let r : &ReferencerValue = value {
                if (type.isMutable () && !r.isMutable ()) {
                    throw copy ErrorMsg::fatal (loc, end-> endLoc, format (ValidateErrorMessage::IMPLICIT_MUT_REFERENCE, value.getType ()));
                } else if (!type.isMutable () && r.isMutable ()) {
                    throw copy ErrorMsg::fatal (loc, end-> endLoc, format (ValidateErrorMessage::IMPLICIT_CONST_REFERENCE, value.getType ()));
                }
            } else panic;
        }

        // Reference to a value that does not need ref
        // e.g. { let z = 12; let x = ref z; }
        else if (!byReference && value !of ReferencerValue) {
            throw copy ErrorMsg::fatal (loc, end-> endLoc, ValidateErrorMessage::UNECESSARY_REFERENCE);
        }

        // Alias of borrowable data, but without explicitely writing it
        // e.g. { let z = [1, 2, 3]; let dmut a = z; }
        else if (!byReference && type.needExplicitAlias () && self.needExplicitAlias (value)) {
            throw copy ErrorMsg::fatal (loc, ValidateErrorMessage::DISCARD_CONST,
                                        notes-> copy [copy ErrorMsg::note (endLoc, format (ValidateErrorMessage::IMPLICIT_ALIAS, value.getType ()))]);
        }

        // Alias but on non borrowable data, or on a const borrowable data, so when it is not needed
        // e.g. { let dmut z = copy [12]; let x = alias z; }
        else if let a : &AliaserValue = value {
            if (!type.needExplicitAlias () && a.isFromExpansion ()) {
                throw copy ErrorMsg::fatal (loc, end-> endLoc, format (ValidateErrorMessage::UNECESSARY_ALIAS, type));
            }
        }
    }

    /**
     * Check if the value can be used without explicit alias over it
     * @params: 
     *  - type: the type that will receive the data
     *  - value: the value that is moved
     */
    pub fn needExplicitAlias (self, value : &Value)-> bool {
        if (!value.getType ().needExplicitAlias ()) return false; // no data are borrowed
        match value {
            AddressValue ()      => return false;
            AliaserValue ()      => return false;
            CopierValue ()       => return false;
            LiteralValue ()      => return false;
            sc : &SliceCtorValue => { if (sc.isImplicitAlias ()) return false; }
            ConstructValue ()    => return false;
            b : &BlockValue      => { if (!b.isSet ()) return false; }
            ScopeValue ()        => return false;
            CallOperatorValue () => return false;
            SliceConcatValue ()  => return false;
            SliceAppendValue ()  => return false;
            TryFinallyValue ()   => return false;
            TryCatchValue ()     => return false;
            l : &LazyValue       => { if (l.byAlias ()) return false; }
            f : &FutureValue     => { if (f.byAlias ()) return false; }
        }
        
        value.getType ().needExplicitAlias ()
    }

    /**
     * Verify that a value is not lazy unecessarily or that it is not passed to lazy implicitely
     * @params:
     *    - loc: the location of the movement
     *    - type: the type of the left operand
     *    - value: the value that is moved
     *    - byLazy: true if left require a lazy value
     * @throws: if there is something prohibited
     * */
    fn verifyImplicitLazy (self, loc : &Word, valueLoc : &Word = EOF_WORD, _ : &Type, value : &Value, byLazy : bool)
        throws ErrorMsg
    {
        let endLoc = if valueLoc.isEof () { value.getLoc () } else { valueLoc };

        // Value to a variable that needs lazy
        // e.g. { let lazy a = lazy foo (); }
        if (byLazy) {
            let ok = match value {
                a : &AliaserValue => { a.getValue () of LazyValue }
                _ : &LazyValue => { true }
                _ => { false }
            };

            if (!ok) {
                throw copy ErrorMsg::fatal (loc, end-> endLoc, format (ValidateErrorMessage::IMPLICIT_LAZY, value.getType ()));
            }
        }

        // e.g. { let x = lazy foo (); }
        else {
            let ok = match value {
                _ : &LazyValue => { false }
                a : &AliaserValue => { a.getValue () !of LazyValue }
                _ => { true }
            };


            if (!ok) {
                throw copy ErrorMsg::fatal (loc, end-> endLoc, format (ValidateErrorMessage::UNECESSARY_LAZY));
            }
        }
    }

    /**
     * Verify that the value of v is moved if the type 'c' is movable
     * @params:
     *    - loc: the location of the movement
     *    - c: the type being verified
     *    - v: the value being moved (or not)
     * @throws: if 'move' was not explicitely written
     **/
    fn verifyImplicitMove (self, loc : &Word, valueLoc : &Word = EOF_WORD, c : &Type, v : &Value)
        throws ErrorMsg
    {
        let endLoc = if (valueLoc.isEof ()) { v.getLoc () } else { valueLoc };

        if (c.isMovable ()) {
            let isImplicitMovable = match v {
                MoverValue ()        => { true }
                b : &BlockValue      => { !b.isSet () }
                CtorCallValue ()     => { true }
                ScopeValue ()        => { true }
                CallOperatorValue () => { true }
                _                    => { false }
            };

            if (!isImplicitMovable) {
                match (c, v) {
                    (ct : &TupleType, vt : &TupleValue) => {
                        {
                            for vi in 0us .. vt.getArity () {
                                self.verifyImplicitMove (loc, ct.getInners ()[vi], vt.getValues ()[vi]);
                            }
                        } catch {
                            err : &ErrorMsg => {
                                throw copy ErrorMsg::fatal (loc, end-> endLoc, format (ValidateErrorMessage::IMPLICIT_MOVE, c), notes-> copy [err]);
                            }
                        }
                    }
                    (ca : &ArrayType, va : &ArrayValue) => {
                        {
                            for vi in 0us .. va.getValues ().len {
                                self.verifyImplicitMove (loc, ca.getInners ()[0], va.getValues ()[vi]);
                            }
                        } catch {
                            err : &ErrorMsg => {
                                throw copy ErrorMsg::fatal (loc, end-> endLoc, format (ValidateErrorMessage::IMPLICIT_MOVE, c), notes-> copy [err]);
                            }
                        }
                    }
                    _ => {
                        throw copy ErrorMsg::fatal (loc, end-> endLoc, format (ValidateErrorMessage::IMPLICIT_MOVE, c));
                    }
                }
            }
        }
    }

    /**
     * @returns: true if the type is movable and need an explicit move
     * */
    pub fn needExplicitMove (self, v : &Value)-> bool {
        if (v.getType ().isMovable ()) {
            let isImplicitMovable = match v {
                MoverValue ()        => { true }
                b : &BlockValue      => { !b.isSet () }
                CtorCallValue ()     => { true }
                ScopeValue ()        => { true }
                CallOperatorValue () => { true }
                _                    => { false }
            };

            if (!isImplicitMovable) {
                match v {
                    vt : &TupleValue => {
                        for vi in 0us .. vt.getArity () {
                            if (self.needExplicitMove (vt.getValues ()[vi])) return true;
                        }

                        return false;
                    }
                    va : &ArrayValue => {
                        for vi in 0us .. va.getValues ().len {
                            if (self.needExplicitMove (va.getValues ()[vi])) return true;
                        }

                        return false;
                    }
                }

                return true;
            } else return false;
        }

        false
    }


    /**
     * Verify that the mutability level of lType is higher or equal than those of rType, otherwise memory movement creates a discard of const
     * @example:
     * ===================
     * let mut a = [1, 2, 3];
     * let dmut b = alias a; // no implicit alias, but a cannot give mutable access to inner values
     * b [0] = 9;
     * println (a); // [9, 2, 3]; we did not respected the contract of a
     * ===================
     * @params: 
     *   - lLoc: the location of the left operand in the movement operation
     *   - rLoc: the location of the right operation in the movement operation
     *   - lType: the type on the left of the operation (type of `b` in the example)
     *   - rType: the type on the right of the operation (type of `a` in the example)
     *   - byReference: true iif the types are a reference     
     * @throws:
     *  - &ErrorMsg: if the movement is not allowed 
     */
    fn verifyMutabilityLevel (self, lLoc : &Word, rLoc : &Word, lType : &Type, rType : &Type, byReference : bool)
        throws ErrorMsg
    {        
        match lType {
            LambdaType () => {
                if (lType.isMutable ()) {
                    throw copy ErrorMsg::fatal (rLoc, ValidateErrorMessage::DISCARD_CONST);
                }
            }
            _ => {
                // this test is useless I think, native scalar types have always a mutability level of 1, but it is probably faster that way
                if (byReference || lType.borrowDatas ()) {
                    if (byReference) {
                        if (!rType.isMutable () && lType.isMutable ()) {
                            throw copy ErrorMsg::fatal (lLoc, ValidateErrorMessage::DISCARD_CONST,
                                                        notes-> copy [copy ErrorMsg::note (rLoc, format (ValidateErrorMessage::DISCARD_CONST_LEVEL_TYPES, rType, lType))]);
                        }
                    }

                    {
                        if (!rType.mutabilityFit (lType, borrowed-> byReference)) {
                            throw copy ErrorMsg::fatal (lLoc, ValidateErrorMessage::DISCARD_CONST,
                                                        notes-> copy [copy ErrorMsg::note (rLoc, format (ValidateErrorMessage::DISCARD_CONST_LEVEL_TYPES, rType, lType))]);
                        }
                    }
                }
            }
        }
    }

    /**
     * @returns: true if `type` is slice of containing void elements
     */
    fn isVoidSliceType (self, type : &Type)-> bool {
        match type {
            s : &SliceType => {
                s.getInners ()[0] of VoidType
            }
            _ => { false }
        }
    }

    /**
     * @returns: true if right is a enumeration type that is proxying somthing implicitelty castable to the left type
     * */
    pub fn isProxy (self, left : &Type, right : &Type)-> bool {
        match right {
            re : &EnumType => {
                {
                    self.verifyCompatibleType (left.getLoc (), re.getLoc (), left, re.getProxy ());
                    true
                } catch {
                    _ => {
                        false
                    }
                }
            }
            _ => {
                false
            }
        }
    }


    /**
     * Testing if left is an ancestor class of right, this is usefull for type compatibility checking
     * @info: check if the types are ClassPtrType, or ClassRefType (works with both)
     * @params: 
     *    - left: any type
     *    - right: any type
     * @returns: true if the left type is a classptrtype and is an ancestor of the right type (a classptrtype as well)
     */
    pub fn isAncestor (self, left : &Type, right : &Type)-> bool
        throws ErrorMsg
    {
        let rInner : &ClassRefType = match right { // This function is made to work with classptr and classref
            c : &ClassPtrType => { c.getInner () }
            c : &ClassRefType => { c }
            _ => { return false; }
        };

        let lInner : &ClassRefType = match left { // This function is made to work with classptr and classref
            c : &ClassPtrType => { c.getInner () }
            c : &ClassRefType => { c }
            _ => { return false; }
        };

        let mut ancestor = rInner.getAncestor ();
        loop { // we traverse the ancestor of right
            match ancestor {
                c : &ClassRefType => { 
                    if (c == lInner) { break true; } // if one of the ancestor of right is equal to left, then left is an ancestor of right
                    ancestor = c.getAncestor (); // else we go up again
                }
                _ => { break false; } // No ancestor left
            }
        }
    }

    /**
     * Test if left and right are the same class ptr types (or a classref of the same type)
     * */
    pub fn isDirectInstance (self, left : &Type, right : &Type)-> bool
        throws ErrorMsg
    {
        let rInner : &ClassRefType = match right {
            c : &ClassPtrType => { c.getInner () }
            c : &ClassRefType => { c }
            _ => { return false; }
        };

        let lInner : &ClassRefType = match left { // This function is made to work with classptr and classref
            c : &ClassPtrType => { c.getInner () }
            c : &ClassRefType => { c }
            _ => { return false; }
        };

        return (lInner == rInner);
    }

    /**
     * Verify that 'left' is an ancestor of 'right'
     * @params: 
     *    - left: any type
     *    - right: any type
     * @throws:
     *    - &ErrorMsg: if 'left' is not an ancestor of 'right'
     */
    pub fn verifyAncestor (self, loc : &Word, left : &Type, right : &Type)
        throws ErrorMsg
    {
        if (!self.isAncestor (left, right)) {
            throw copy ErrorMsg::fatal (loc, format (ValidateErrorMessage::NOT_ANCESTOR, left, right));
        }
    }

    /**
     * Verify that 'left' implements the trait 'right'
     * @params:
     *    - left: any type (but needs to be a class in order to work)
     *    - right: any type  (but needs to be a trait in order to work)
     * @throws:
     *   - &ErrorMsg: if 'left' does not implement 'right'
     */
    pub fn verifyImplement (self, loc : &Word, left : &Type, right : &Type)
        throws ErrorMsg
    {
        if (right !of TraitRefType) {
            throw copy ErrorMsg::fatal (loc, format (ValidateErrorMessage::NOT_A_TRAIT, right));
        }

        let lInner : &ClassRefType = match left { // This function is made to work with classptr and classref
            c : &ClassPtrType => { c.getInner () }
            c : &ClassRefType => { c }
            _ => {
                throw copy ErrorMsg::fatal (loc, format (ValidateErrorMessage::NOT_A_CLASS, left));
            }
        };

        for im in lInner.getAllImplTraits () {
            if (im == right) return;
        }

        throw copy ErrorMsg::fatal (loc, format (ValidateErrorMessage::CLASS_NOT_IMPL, lInner, right));
    }

    /**
     * Check wether 'left' implements the trait 'right'
     * @params:
     *    - left: any type (but needs to be a class in order to work)
     *    - right: any type  (but needs to be a trait in order to work)
     * @throws:
     *   - &ErrorMsg: if 'left' does not implement 'right'
     */
    pub fn isImplement (self, left : &Type, right : &Type)-> bool
        throws ErrorMsg
    {
        if (right !of TraitRefType) {
            return false;
        }

        let lInner : &ClassRefType = match left { // This function is made to work with classptr and classref
            c : &ClassPtrType => { c.getInner () }
            c : &ClassRefType => { c }
            _ => {
                return false;
            }
        };

        for im in lInner.getAllImplTraits () {
            if (im == right) return true;
        }

        false
    }
    
    /**
     * Get the common ancestor of left and right 
     * @params: 
     *   - loc: the location of the operation
     *   - left: a class type
     *   - right: a class type
     * @returns: a class type containing the common ancestor, or NoneType
     */
    pub fn getCommonAncestor (self, loc : &Word, left : &ClassPtrType, right : &ClassPtrType)-> &Type
        throws ErrorMsg
    {
        let mut ancestor : &Type = left.getInner ();

        // We traverse the list of ancestor of the left 
        loop {
            match ancestor {
                c : &ClassRefType => {
                    // if one of the ancestor of left is also an ancestor of right, then it is a common ancestor
                    if (self.isAncestor (ancestor, right)) break c.createInstance (loc-> loc, isMutable-> false, isInnerMutable-> false);
                    else { // We go back again
                        ancestor = c.getAncestor ();
                    }
                }
                _ => { // No ancestor left to check
                    break NONE_TYPE;
                }
            }            
        }
    }

    /**
     * Verify that a constructor call does not generate an infinite recursion
     * */
    pub fn verifyInfiniteCtorRecursion (self, ctor : &CtorPrototypeValue, ref mut entered : [&Symbol => mut ()])
        throws ErrorMsg
    {
        entered [ctor.getSymbol ()] = ();
        match ctor.getSymbol () {
            ctorSym : &ConstructorSymbol => {
                let redirect = match ctorSym.getBody () {
                    bl : &BlockValue => {
                        if (bl.getValues ().len > 0us) {
                            if let c : &CtorCallValue = bl.getValues () [0us] {
                                c
                            } else return;
                        } else return;
                    }
                    _ => return;
                };

                match redirect.getCtor ().getPrototype ().getSymbol () {
                    redirectSym : &ConstructorSymbol => {
                        if (redirectSym in entered) {
                            throw copy ErrorMsg::fatal (redirect.getLoc (), format (ValidateErrorMessage::CTOR_INFINITE_REDIRECTION, redirect.getCtor ().getPrototype (), tags-> FormatTags (withParams-> true)));
                        }

                        if (redirectSym.hasRedirect ()) {
                            self.verifyInfiniteCtorRecursion (redirect.getCtor ().getPrototype (), entered-> ref entered);
                        } catch {
                            err : &ErrorMsg => {
                                throw copy ErrorMsg::fatal (redirect.getLoc (), format (ValidateErrorMessage::CTOR_INFINITE_REDIRECTION, redirect.getCtor ().getPrototype (), tags-> FormatTags (withParams-> true)), notes-> copy [err]);
                            }
                        }
                    } 
                }
            }
        }
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================            UTILS             =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Create a syntax var path (a PathExpr) leading to a given path
     * This function can be used to create path to core functions, or core files
     * @panic: the path contains at least one element
     * @example:
     * ====================
     * let syntVar = context.createSyntaxVarFromPath (loc, Path ("core/array/opCmp"));
     * println (format ("%", syntVar)); // core::array::opCmp
     * ====================
     * @params:
     *   - loc: the location of the expression
     *   - path: the path to the transform into a var
     * @returns: a syntax expression containing the path
     */
    pub fn createSyntaxVarFromPath (self, loc : &Word, path : Path)-> &Expression {
        return self.createSyntaxVarFromPath (loc, path.parts ());
    }

    /**
     * Create a syntax var path (a PathExpr) leading to a given path
     * This function can be used to create path to core functions, or core files
     * @panic: the path contains at least one element
     * @example:
     * ====================
     * let syntVar = context.createSyntaxVarFromPath (loc, ["core", "array", "opCmp"]);
     * println (format ("%", syntVar)); // core::array::opCmp
     * ====================
     * @params:
     *   - loc: the location of the expression
     *   - path: the path to the transform into a var
     * @returns: a syntax expression containing the path
     */
    fn createSyntaxVarFromPath (self, loc : &Word, path : [[c8]])-> &Expression {
        if (path.len == 0us) panic;
        let mut leaf : &Expression = copy VarExpr (copy Word (path [0us], loc));
        for i in 1us .. path.len { // This is relatively simple, we just create a list
            leaf = copy PathExpr (copy Word (Tokens::DCOLON, loc),
                                  leaf,
                                  copy VarExpr (copy Word (path[i], loc)));
        }

        leaf
    }

    /**
     * Retreive the type core::exception::Exception and validate it
     * @params: 
     *   - loc: the location of the creation
     * @returns: the exception type (ClassPtrType)
     * @throws: 
     *    - &ErrorMsg: if the type is not found (e.g. compiled in standalone)
     */
    pub fn getExceptionType (mut self, loc : &Word = EOF_WORD)-> &ClassPtrType
        throws ErrorMsg
    {
        let var = self.createSyntaxVarFromPath (loc, ExceptionUtils::EXCEPTION);
        let type = self:.validateType (var);
        match type {
            c : &ClassRefType => { c.createInstance (true, true) }
            _ => panic;
        }
    }

    /**
     * Create a class instance type (ClassPtrType) from a class reference or a class ptr
     * @params:
     *    - type: the type used to create the instance
     *    - mutable: true iif the reference is mutable
     *    - innerMutable: true iif the value referenced is mutable
     * */
    pub fn createClassInstance (self, type : &Type, mutable : bool = false, innerMutable : bool = false)-> &Type
        throws ErrorMsg
    {
        match type {
            c : &ClassRefType => { c.createInstance (mutable, innerMutable) }
            c : &ClassPtrType => { c.getInner ().createInstance (mutable, innerMutable) }
            _ => panic;
        }
    }


    /**
     * Retreive an exception from the core::exception module (e.g. AssertError, EmptyOption, EmptyErrOption, etc.)
     * @params:
     *    - loc: the location of the use
     * @returns: the exception type
     * @throws:
     *    - &ErrorMsg: if the type is not found
     * */
    pub fn getExceptionFromName (mut self, loc : &Word = EOF_WORD, name : Path)-> &Type
        throws ErrorMsg
    {
        let var = self.createSyntaxVarFromPath (loc, name);
        let type = self:.validateType (var);
        match type {
            c : &ClassRefType => { c.createInstance (true, true) }
            _ => panic;
        }
    }

    /**
     * Retreive the global symbols that contains the function to lock and unlock the global atomic mutex
     * @params:
     *    - loc: the location of the retreival
     * @returns:
     *    - .0: the locker function
     *    - .1: the unlocker function
     * */
    pub fn getAtomicLockerNoMonitorFuncs (mut self, loc : &Word = EOF_WORD)-> (&Value, &Value)
        throws ErrorMsg
    {
        let lockVar = self.createSyntaxVarFromPath (loc, AtomicUtils::LOCK_GLOBAL);
        let unlockVar = self.createSyntaxVarFromPath (loc, AtomicUtils::UNLOCK_GLOBAL);

        (self:.validateValue (lockVar),
         self:.validateValue (unlockVar))
    }

    /**
     * Retreive the global symbols that contains the function to lock and unlock a class monitor
     * @params:
     *    - loc: the location of the retreival
     * @returns:
     *    - .0: the locker function
     *    - .1: the unlocker function
     * */

    pub fn getAtomicLockerWithMonitorFuncs (mut self, loc : &Word = EOF_WORD)-> (&Value, &Value)
        throws ErrorMsg
    {
        let lockVar = self.createSyntaxVarFromPath (loc, AtomicUtils::LOCK_MONITOR);
        let unlockVar = self.createSyntaxVarFromPath (loc, AtomicUtils::UNLOCK_MONITOR);

        (self:.validateValue (lockVar),
         self:.validateValue (unlockVar))
    }

    /**
     * Construct an object instance from an object type and parameters (usefull to instanciate internal exceptions for example)
     * @params:
     *    - loc: the location of the construction
     *    - type: the type of the class to instanciate (assumed to be ClassPtrType or ClassRefType)
     *    - params: the list of parameters to pass to the ctor
     * @returns: a object value construction
     * @throws:
     *    - &ErrorMsg: if the creation failed
     * */
    pub fn constructObjectInstance (mut self, loc : &Word, type : &Type, params : [&Value])-> &Value
        throws ErrorMsg
    {
        let (ctors, isStruct) = match type {
            c : &ClassPtrType => {
                (self._subTypeValidator.validateClassCtors (alias self, loc, c.getInner ()), c.isStruct ())
            }
            c : &ClassRefType => {
                (self._subTypeValidator.validateClassCtors (alias self, loc, c), c.isStruct ())
            }
            _ => panic;
        }

        self._callOpValidator.validate (alias self, loc, ctors, params, inCopy-> !isStruct)
    }

    /**
     * Find the method of a class by its name (useful for op overrides)
     * @params:
     *    - loc: the location of the access
     *    - cptr: the type of the class being accessed
     *    - value: the value of the object instance
     *    - meth: the method to find
     * @returns: the method (mult sym)
     * @throws:
     *    - &ErrorMsg: if the class does not have that method
     * */
    pub fn constructObjectMethodAcc (mut self, loc : &Word, cptr : &ClassPtrType, value : &Value, meth : [c8], allowImmut : bool = false)-> &Value
        throws ErrorMsg
    {
        let (inPrv, inProt) = self.getCurrentClassContextProtections (cptr.getInner ());
        let var = copy VarExpr (copy Word (meth, loc));

        match self._binOpValidator.validateClassVtableAccess (alias self, value, var, cptr.getInner (), value of SuperProxyValue, inProt, inPrv, allowImmut-> allowImmut, fieldCall-> false) {
            UnitValue () => {
                throw copy ErrorMsg::fatal (loc, format (ValidateErrorMessage::CLASS_NO_METHOD, value.getType (), meth));
            }
            v : _ => { v }
        }
    }

    /**
     * Create an error message for global retreival fail
     * This create an error message, with alternative variable with close names, or private variables inaccessible from the current context
     * @params: 
     *   - loc: the location of the var to find
     *   - name: the name of the variable to find
     * @returns: the error message, that can be thrown as it is
     */
    pub fn createGlobalVarError (mut self, loc : &Word, name : [c8], subError : [&ErrorMsg] = [])-> &ErrorMsg {
        let glb = self._declarator.createGlobalAccessError (loc, name, self.getReferent ());
        {
            self.verifyNotIsNativeType (loc, name);
        } catch {
            err : &ErrorMsg => {
                return copy ErrorMsg::list (copy [glb, err] ~ subError);
            }
        }

        glb.withNote (subError)
    }

    /**
     * Create an error message for local retreival fail
     * This create an error message with alternative variable with close names, or private variable inaccessible from the current context
     * @params:
     *    - loc: the location of the variable to find
     *    - modules: the module in which the local access is made
     *    - name: the name of the variable to find
     * @returns: the list of notes to attach to the real error
     * */
    pub fn createLocalVarError (mut self, loc : &Word, module : &ModuleRefValue, name : [c8], subError : [&ErrorMsg] = [])-> [&ErrorMsg] {
        let glb = self._declarator.createLocalAccessError (loc, name, module.getSymbol (), self.getReferent ());
        {
            self.verifyNotIsNativeType (loc, name);
        } catch {
            err : &ErrorMsg => {
                return (glb ~ [err]) ~ subError;
            }
        }

        glb ~ subError
    }

    /**
     * Validate the arguments of a template call/checker
     * @params: 
     *    - lst: the list of template arguments
     * @returns: 
     *    - a list of generator (can be a mix of types and values)
     * @throws:
     *    - &ErrorMsg: if there is an error in the validation
     */
    pub fn validateTemplateArgumentList (mut self, lst : [&Expression])-> [&Generator]
        throws ErrorMsg
    {
        let mut results : [mut &Generator] = [];
        for i in lst {
            let mut typeButNotComplete = false;
            { // We first try a type
                let type = self:.validateType (i);
                typeButNotComplete = true;

                self.verifyCompleteType (i.getLoc (), type, construct-> true);
                results ~= [type];
            } catch {
                err : &ErrorMsg => { // Apparently its not a type
                    // It is a type, but it is not a complete type (none, or temporary, classref, etc.)
                    if (typeButNotComplete) throw err;
                    else {
                        let val = self:.validateValue (i); // Maybe its a value
                        if (!self:.getCompileTimeInterpreter ().isCte (val)) { // but we need to know it a compile time
                            throw copy ErrorMsg::fatal (val.getLoc (), format (ValidateErrorMessage::UNKNOWN_AT_COMPILE_TIME, val.getType ()));
                        }

                        results ~= [val];
                    } catch {
                        err2 : &ErrorMsg => { // Another error, we print both errors (type and value) for better debugging
                            let valueError = copy ErrorMsg::note (i.getLoc (), ValidateErrorMessage::TEMPLATE_VALUE_TRY, notes-> copy [err2]);
                            throw copy ErrorMsg::list (copy [err, valueError]);
                        }
                    }
                }
            };
        }

        results // Everything is ok
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          MAP UTILS          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Find the function that will be used to hash the keys of a map
     * @params:
     *    - loc: the location of the usage
     *    - type: the type of the key
     * @returns: the function prototype
     * @throws:
     *    - &ErrorMsg: if the keys are not hashable
     * */
    pub fn createKeyHashFunction (mut self, loc : &Word, type : &Type)-> &PrototypeValue
        throws ErrorMsg
    {
        {
            let var = self.createSyntaxVarFromPath (loc, MapUtils::HASH_KEY_FUNC);
            let func = self:.getValueValidator ().validateTemplateCall (alias self, loc, self:.validateValue (var), copy [type]);
            match func {
                p : &PrototypeValue => return p;
            }

            panic;
        } catch {
            err : &ErrorMsg => {
                throw copy ErrorMsg::fatal (loc, format (ValidateErrorMessage::MAP_KEY_NOT_HASHABLE, type),
                                            notes-> copy [err]);
            }
        }
    }


    /**
     * Find the function that will be used to compare the keys of a map
     * @params:
     *    - loc: the location of the usage
     *    - type: the type of the key
     * @returns: the function prototype
     * @throws:
     *    - &ErrorMsg: if the keys are not comparable
     * */
    pub fn createKeyCmpFunction (mut self, loc : &Word, type : &Type)-> &PrototypeValue
        throws ErrorMsg
    {
        {
            let v = copy ValueWrapperExpr (loc, copy FakeValue (type));
            let bin = copy BinaryExpr (copy Word (Tokens::DEQUAL, loc), v, v);
            self:.validateValue (bin);

            let var = self.createSyntaxVarFromPath (loc, MapUtils::CMP_KEY_FUNC);
            let func = self:.getValueValidator ().validateTemplateCall (alias self, loc, self:.validateValue (var), copy [type]);
            match func {
                p : &PrototypeValue => return p;
            }

            panic;
        } catch {
            err : &ErrorMsg => {
                throw copy ErrorMsg::fatal (loc, format (ValidateErrorMessage::MAP_KEY_NOT_COMPARABLE, type),
                                            notes-> copy [err]);
            }
        }
    }

    /**
     * Validate the type info of a map type (i.e. compare and hash functions of key)
     * @params:
     *   - context: the context of the validation
     *   - loc: the location of the validation
     *   - type: the type to validate
     * @throws:
     *   - &ErrorMsg: if the validation failed
     * */
    pub fn createMapTypeInfo (mut self, loc : &Word, type : &MapType)
        throws ErrorMsg
    {
        // Insert the map information (vtable) in the list of generators
        let cstResult = if (type.isMutable ()) { type.clone (0u32) } else { type };
        let name = format ("#_map_info:%", cstResult);

        // Map type info was already validated
        if (self.hasCustomGenerator (name)) return;

        let keyType = type.getInners ()[0];

        // Key must be hashable
        let keyHashFunc = {
            match keyType {
                c : &ClassPtrType => { // We verify the trait to have a better error display
                    let hashTrait = self:.validateHashableTrait (loc);
                    self.verifyImplement (keyType.getLoc (), c, hashTrait);
                }
            }

            // Find the hash function
            self:.createKeyHashFunction (loc, keyType)
        } catch {
            err : &ErrorMsg => {
                throw copy ErrorMsg::fatal (loc, end-> keyType.getLoc (), format (ValidateErrorMessage::MAP_KEY_NOT_HASHABLE),
                                            notes-> copy [err]);
            }
        };

        // And comparable
        let keyCmpFunc = {
            // We check for the operator to have a better error display
            let _ = self._pragmaValidator.validateBinOperator (alias self, loc, Tokens::DEQUAL, keyType, keyType);

            // The comparison function used to compare two keys
            self:.createKeyCmpFunction (loc, keyType)
        } catch {
            err : &ErrorMsg => {
                throw copy ErrorMsg::fatal (loc, end-> keyType.getLoc (), format (ValidateErrorMessage::MAP_KEY_NOT_COMPARABLE),
                                            notes-> copy [err]);
            }
        };

        // Insert the generator for the type to be properly transformed in YIL
        if let m : &MapType = cstResult {
            self:.insertCustomGenerator (name, copy MapInfoGenerator (type.getLoc (), m, keyCmpFunc, keyHashFunc));
        } else panic;
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================             MISC             =========================
     * ================================================================================
     * ================================================================================
     */


    /**
     * Check if value is the var value 'self'
     * @params: 
     *    - value: the value to check
     * @returns: true iif the value is a var ref value containing the 'self' variable 
     */
    pub fn isSelf (self, value : &Value)-> bool {
        match value {
            v : &VarRefValue => { v.isSelf () }
            _ => { false }
        }
    }

    /**
     * Check if value the a var reference to a parameter value
     * @params:
     *    - value: the value to check
     * @returns: true iif the value is a var ref to a parameter value
     * */
    pub fn isParameter (self, value : &Value)-> bool {
        match value {
            v : &VarRefValue => { v.isParam () }
            _ => { false }
        }
    }

    /**
     * Check if value is a var reference to an iterator value
     * @params:
     *    - value: the value to check
     * @returns: true iif the value is a var ref to an iterator value
     * */
    pub fn isIterator (self, value : &Value)-> bool {
        match value {
            v : &VarRefValue => { v.isIterator () }
            _ => { false }
        }
    }

    /**
     * Check if value is a var reference to a value passed by reference
     * @params:
     *    - value: the value to check
     * @returns: true iif the value is a var ref to a value passed by reference
     * */
    pub fn isReference (self, value : &Value)-> bool {
        match value {
            v : &VarRefValue => { v.isReference () }
            _ => { false }
        }
    }

    /**
     * Check if the value is a var reference to a lazy value
     * @params:
     *    - value: the value to check
     * @returns: true iif the value is a var ref to a lazy value
     * */
    pub fn isLazy (self, value : &Value)-> bool {
        match value {
            v : &VarRefValue => { v.isLazy () }
            gv : &GlobalVarRefValue => { gv.isLazy () }
            _ => { false }
        }
    }

    /**
     * @returns: true iif the expression is located in a copy or a deep copy
     * */
    pub fn isDynamic (self, expr : &Expression)-> bool {
        let i = self._copyContext [$ - 1];
        match i.len {
            0us => { return false; }
            _ => {
                return self.isDynamic (i [$ - 1], expr);
            }
        }
    }

    /**
     * @returns: the location of the current copy/dcopy operator
     * @warning: return EmptyExpression if not inside a dynamic expression
     * */
    pub fn getDynamicExpr (self)-> &Expression {
        let i = self._copyContext [$ - 1];
        match i.len {
            0us => { EMPTY_EXPR }
            _ => {
                i [$ - 1]
            }
        }
    }

    /**
     * @returns: true if the current dynamic expression is deep (false if not in dynamic expression)
     * */
    pub fn isDynamicDeep (self)-> bool {
        let i = self._copyContext [$ - 1];
        match i.len {
            0us => { false }
            _ => {
                match i [$ - 1] {
                    intr : &IntrinsicExpr => { (intr.getType () == IntrinsicKeys::DCOPY) }
                    _ => { false }
                }
            }
        }
    }

    /**
     * @returns: true if the intricic values has an effect on the expr as copiyng
     * */
    fn isDynamic (self, copier : &Expression, expr : &Expression, inDeep : bool = false)-> bool {
        if (copier is expr) return true;
        match copier {
            cp : &IntrinsicExpr => {
                if (cp.getType () == IntrinsicKeys::COPY) {
                    return self.isDynamic (cp.getContent (), expr, inDeep-> false || inDeep);
                } else if (cp.getType () == IntrinsicKeys::DCOPY) {
                    return self.isDynamic (cp.getContent (), expr, inDeep-> true);
                }
            }
            t : &TryExpr => {
                return self.isDynamic (t.getValue (), expr, inDeep-> inDeep);
            }
            l : &ListExpr => {
                if (inDeep) { // if not deep, then it the list that is copied, however l !is expr
                    for i in l.getParameters () {
                        if (self.isDynamic (i, expr, inDeep-> inDeep)) return true;
                    }
                }
            }
            l : &ListMapExpr => {
                if (inDeep) { // if not deep, then it the list that is copied, however l !is expr
                    for i in l.getValues () {
                        if (self.isDynamic (i, expr, inDeep-> inDeep)) return true;
                    }
                    for i in l.getKeys () {
                        if (self.isDynamic (i, expr, inDeep-> inDeep)) return true;
                    }
                }
            }
            s : &SliceAllocatorExpr => {
                if (inDeep) {  // if not deep, then it the list that is copied, however s !is expr
                    return self.isDynamic (s.getValue (), expr, inDeep-> inDeep);
                }
            }
            s : &SliceForAllocatorExpr => {
                if (inDeep) {  // if not deep, then it the list that is copied, however s !is expr
                    return self.isDynamic (s.getValue (), expr, inDeep-> inDeep);
                }
            }
        }

        return false;
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================           PRIVATE            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * @returns: a local variable that is enclosed
     */
    fn getInClosure (mut self, loc : &Word, name : [c8])-> &Value
        throws ErrorMsg
    {
        if (self._closureType.len == 0us) return UNIT_VALUE;

        let dmut closureType = alias self._closureType [$ - 1];
        let (field, index) = closureType.getField (name);
        if (field of NoneType) {
            let syms = closureType.getClosureSymbols ();
            for i in 0us .. syms.len {
                if let Ok (g) = syms [i][name]? {
                    let val = self.checkEnclosable (loc, g);
                    let type = val.getType ();
                    closureType:.getClosureUsed ()[i][name] = ();

                    let types = closureType.getInnerTypes () ~ [type];
                    let names = closureType.getInnerNames () ~ [name];
                    let values = closureType.getInnerValues () ~ [val];
                    let fndIndex = values.len - 1us;

                    let dmut secClosureType = ClosureType (closureType.getLoc (), types, names, values, closureType.getRefId (), syms, closureType:.getClosureUsed ());
                    self._closureType [$ - 1] = alias secClosureType;

                    let oldRef = self:.getLocal (EOF_WORD, "#{CLOSURE-VARREF}", canBeInClosure-> false);
                    if let v : &VarRefValue = oldRef {
                        let closureRef = copy VarRefValue (oldRef.getLoc (), EOF_WORD, secClosureType, v.getRefId (), isSelf-> v.isSelf ());
                        self._symbols [$ - 1][0us]["#{CLOSURE-VARREF}"] = closureRef;

                        return copy ClosureFieldAccessValue (copy Word (name, loc), type, closureRef, fndIndex, name-> name);
                    } else panic;
                }
            }
        } else {
            let closureRef = self:.getLocal (EOF_WORD, "#{CLOSURE-VARREF}", canBeInClosure-> false);
            return copy ClosureFieldAccessValue (copy Word (name, loc), field, closureRef, index, name-> name);
        }
        
        UNIT_VALUE
    } catch {
        err : &ErrorMsg => throw err;
    }

    /**
     * Check that the value is enclosable, and return a the enclosable value derived from it
     * @params:
     *    - loc: the location of the enclosing
     *    - value: the value being enclosed
     */
    fn checkEnclosable (self, loc : &Word, value : &Value)-> &Value
        throws ErrorMsg
    {
        match value {
            v : &VarDeclValue => {
                if (v.getVarType ().isMovable ()) {
                    throw copy ErrorMsg::fatal (loc, format (ValidateErrorMessage::ENCLOSE_MOVABLE_TYPE, v.getVarType ()),
                                                notes-> copy [copy ErrorMsg::note (value.getLoc (), ValidateErrorMessage::DECLARED_HERE)]);
                }

                match v.getVarType () {
                    LambdaType () => {
                        throw copy ErrorMsg::fatal (loc, format (ValidateErrorMessage::ENCLOSE_INCOMPLETE_TYPE, v.getVarType ()),
                                                    notes-> copy [copy ErrorMsg::note (value.getLoc (), ValidateErrorMessage::DECLARED_HERE)]);
                    }
                    _ => {
                        copy VarRefValue (loc, v.getLoc (), v.getVarType (), v.getUniqId (), isSelf-> false,
                                          canCte-> v.isCte (),
                                          isIterator-> v.isIterator (),
                                          isReference-> v.isReference (),
                                          isLazy-> v.isLazy (),
                                          value-> if (v.isMutable ()) { UNIT_VALUE } else { v.getValue () })
                    }
                }
            }
            p : &ProtoVarValue => {
                if (p.getType ().isMovable ()) {
                    throw copy ErrorMsg::fatal (loc, format (ValidateErrorMessage::ENCLOSE_MOVABLE_TYPE, p.getType ()),
                                                notes-> copy [copy ErrorMsg::note (value.getLoc (), ValidateErrorMessage::DECLARED_HERE)]);
                }

                copy VarRefValue (loc, p.getLoc (), p.getType (), p.getUniqId (), isSelf-> p.isSelf (),
                                  isParam-> true,
                                  isReference-> p.isReference (),
                                  isLazy-> p.isLazy ())
            }
            _ => {
                if (value.getType ().isMovable ()) {
                    throw copy ErrorMsg::fatal (loc, format (ValidateErrorMessage::ENCLOSE_MOVABLE_TYPE, value.getType ()),
                                                notes-> copy [copy ErrorMsg::note (value.getLoc (), ValidateErrorMessage::DECLARED_HERE)]);
                }

                value
            }
        }
    }

    /**
     * Check if the value can be used as a left operand in a memory movement
     *      * @example:
     * ===========
     * a = 1; // for a
     * foo (ref a); // for a
     * a [0] = 9; // for a [0]
     * &a // for a
     * ===========
     * @params:
     *    - loc: the location of the movement
     *    - value: the value that could be modified
     *    - allowImmutable: true if we allow the variable to be immutable (for memory address for example, or implicit ref)
     *    - allowSelf: true if we allow the variable to be self (for memory address for example, or implicit ref)
     * @returns: true iif it can
     */
    pub fn checkLeftOperandMove (self, value : &Value, allowImmutable : bool = false, forMove : bool = false, allowSelf : bool = false)-> bool {
        if (value of FakeValue) return true;
        if (allowSelf && self.isSelf (value)) {
            if (!allowImmutable && !value.getType ().isMutable ()) return false;
            return true;
        }

        if (!value.isLvalue ()) { // only lvalue can be used as left operand, and not self
            false
        } else if (!allowImmutable && self.isSelf (value)) {
            false
        } else if (!allowImmutable && !forMove && self.isParameter (value) && !self.isReference (value)) {
            false
        } else if (!allowImmutable && !forMove && self.isIterator (value) && !self.isReference (value)) {
            false
        } else if (self.isLazy (value)) {
            false
        } else if (!allowImmutable && value of ClosureFieldAccessValue) {
            false
        } else if (!allowImmutable && !value.getType ().isMutable ()) { // only mutable element can be used as left operand
            false
        } else {
            true
        }
    }
}
