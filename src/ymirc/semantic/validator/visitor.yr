mod ymirc::semantic::validator::visitor;

import ymirc::semantic::validator::symbol::_;
import ymirc::semantic::validator::operator::_;
import ymirc::semantic::validator::type;
import ymirc::semantic::validator::value;
import ymirc::semantic::validator::literal;
import ymirc::semantic::validator::errors;
import ymirc::semantic::validator::interpret;

import ymirc::semantic::symbol::_;
import ymirc::semantic::generator::_;
import ymirc::syntax::keys;
import ymirc::syntax::expression::_;
import ymirc::syntax::declaration::protection;
import ymirc::errors::_;
import ymirc::lexing::word;
import ymirc::utils::format;

import std::collection::vec;
import std::collection::map;
import std::collection::set;
import std::algorithm::comparison;
import std::io;


/**
 * The validator class is the class that transform the declared symbols into validated generators that can be passed to the backend
 */
pub class Validator {

    /// The list of generators to pass to the backend
    let dmut _generated = Vec!{&Generator}::new ();

    /**
     * ================================================================================
     * ================================================================================
     * =========================      SYMBOL VALIDATORS       =========================
     * ================================================================================
     * ================================================================================
     */

    /// The validator that is in charge of aka validation
    let dmut _akaValidator = AkaValidator::new ();

    /// The validator that is in charge of class validation
    let dmut _classValidator = ClassValidator::new ();
    
    /// The validator that is in charge of validating functions
    let dmut _functionValidator = FunctionValidator::new ();

    /// The validator that is in charge of validating modules
    let dmut _moduleValidator = ModuleValidator::new ();
    
    /// The validator that is in charge of class validation
    let dmut _structValidator = StructValidator::new ();

    /// The validator that is in charge of template validation
    let dmut _templateValidator = TemplateValidator::new ();

    /// The validator that is in charge of template validation
    let dmut _traitValidator = TraitValidator::new ();

    /**
     * ================================================================================
     * ================================================================================
     * =========================        SUB VALIDATORS        =========================
     * ================================================================================
     * ================================================================================
     */

    /// The validator that is in charge of validating types
    let dmut _typeValidator = TypeValidator::new ();

    /// The validator that is in charge of validating values
    let dmut _valueValidator = ValueValidator::new ();

    /// The validator used to validate binary operators
    let dmut _binOpValidator = BinaryOpValidator::new ();

    /// The validator used to validate unary operators
    let dmut _unOpValidator = UnaryOpValidator::new ();

    /// The validator used to validate mult operators
    let dmut _multOpValidator = MultOpValidator::new ();

    /// The validator used to validate literals
    let dmut _literalValidator = LiteralValidator::new ();

    /// The intepreter used to compute cte values
    let dmut _compileTimeInterpreter = CompileTimeInterpreter::new ();
    
    /**
     * ================================================================================
     * ================================================================================
     * =========================           CONTEXT            =========================
     * ================================================================================
     * ================================================================================
     */

    /// The referent are used when accessing symbols
    let dmut _referent = Vec!{dmut &Symbol}::new ();
    
    /// The current scope variable declarations
    let dmut _symbols = Vec!{dmut &Vec!{dmut &HashMap!{[c8], &Value}}}::new ();

    /// The list of symbols that are used in the current block
    let dmut _usedSyms = Vec!{dmut &Vec!{dmut &HashSet!{[c8]}}}::new ();

    /// The current return type of the current function
    let dmut _functionReturns = Vec!{&Type}::new ();

    /// True iif we are currently validating a closure
    let mut _isInClosure = false;

    /**
     * ================================================================================
     * ================================================================================
     * =========================        VERIFICATIONS         =========================
     * ================================================================================
     * ================================================================================
     */

    /// The native type names
    let dmut _nativeTypeNames = HashSet!{[c8]}::new ();    
    
    /**
     * ================================================================================
     * ================================================================================
     * =========================         CONSTRUCTION         =========================
     * ================================================================================
     * ================================================================================
     */
    
    /**
     * Create a new empty validator
     */
    pub self () {        
        for t in NativeTypes::__members__ {
            self._nativeTypeNames:.insert (t);
        }
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================          VALIDATION          =========================
     * ================================================================================
     * ================================================================================
     */
    
    /**
     * Validate a symbol
     * @params: 
     *   - sym: the symbol to validate
     * @throws: 
     *   - &ErrorMsg: if there was an error in the validation
     */
    pub def validate (mut self, dmut sym : &Symbol)
        throws &ErrorMsg
    {
        match ref sym {
            dmut m : &ModuleSymbol => {
                self._moduleValidator:.validate (alias self, alias m);
            }
            dmut f : &FunctionSymbol => {
                self._functionValidator:.validate (alias self, alias f);
            }
            EmptySymbol () => {
                // Just do nothing 
            }
            _ => {
                println ("TODO : ", sym::typeinfo.name);
                __pragma!panic ();
            }                
        }
    }


    /**
     * ================================================================================
     * ================================================================================
     * =========================            TYPES             =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate an expression assuming its a type
     * @params: 
     *    - type: the expression to validate
     * @returns: the generator
     * @throws: &ErrorMsg, if the type is not valid
     */
    pub def validateType (mut self, type : &Expression)-> &Type
        throws &ErrorMsg
    {
        self._typeValidator:.validate (alias self, type)
    }


    /**
     * Validate an expression assuming its a type
     * @params: 
     *    - type: the expression to validate
     *    - decos: the additional decoration of the type (basically the decorations of a vardecl)
     * @returns: the generator of the type
     * @throws: &ErrorMsg, if the type is not valid
     */
    pub def validateType (mut self, type : &Expression, decos : [DecoratorWord])-> &Type
        throws &ErrorMsg
    {
        let dmut found = HashMap!{Decorators, &Word}::new ();
        let dmut antiAffs = hmap #[
            Decorators::PURE => hset #{Decorators::MUT, Decorators::CONST, Decorators::DMUT},
            Decorators::MUT  => hset #{Decorators::CONST, Decorators::DMUT, Decorators::PURE},
            Decorators::DMUT  => hset #{Decorators::CONST, Decorators::MUT, Decorators::PURE},
            Decorators::CONST  => hset #{Decorators::PURE, Decorators::MUT, Decorators::DMUT}
        ];
        
        for i in decos {
            match i.deco {
                Decorators::STATIC => {
                    throw ErrorMsg::fatal (i.loc, format (ValidateErrorMessage::UNDEF_DECORATOR_TYPE, Decorators::STATIC));
                }
                Decorators::CTE => {
                    throw ErrorMsg::fatal (i.loc, format (ValidateErrorMessage::UNDEF_DECORATOR_TYPE, Decorators::STATIC));
                }                
                _ => {
                    match found.find (i.deco) {
                        Ok (l : _) => throw ErrorMsg::warn (i.loc, format (ValidateErrorMessage::MULTIPLE_DECORATORS, i.deco), notes-> [ErrorMsg::note (l, ""s8)]);
                    }

                    match antiAffs.find (i.deco) {
                        Ok (an : _) => {
                            for j in an {
                                match found.find (j) {
                                    Ok (l : _) => throw ErrorMsg::fatal (i.loc, format (ValidateErrorMessage::CONFLIT_DECORATORS, j, i.deco), notes-> [ErrorMsg::note (l, ""s8)]);
                                }
                            }
                        }
                    }

                    found:.insert (i.deco, i.loc);
                }
            }
        }

        let (isMutable, isDeeplyMutable, _) = (Decorators::MUT in found, Decorators::DMUT in found, Decorators::PURE in found);
        
        self._typeValidator:.validate (alias self, type, isMutable-> (isMutable || isDeeplyMutable), parentMutable-> (isMutable || isDeeplyMutable), isDeeplyMutable-> isDeeplyMutable)
    }
    

    /**
     * ================================================================================
     * ================================================================================
     * =========================            VALUES            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate an expression assuming its a value
     * @params: 
     *    - value: the expression to validate
     * @returns: the generator
     * @throws: &ErrorMsg, if the value is not valid
     */
    pub def validateValue (mut self, value : &Expression)-> &Value
        throws &ErrorMsg
    {
        self._valueValidator:.validate (alias self, value)
    }


    /**
     * Validate an expression assuming its a value
     * @params: 
     *    - loc: the location of the affection
     *    - value: the expression to validate
     *    - type: the expected type (and mutability)
     * @returns: the generator
     * @throws: &ErrorMsg, if the value is not valid, or cannot be put in type
     */
    pub def validateValue (mut self, loc : &Word, value : &Expression, type : &Type)-> &Value
        throws &ErrorMsg
    {
        let v = self._valueValidator:.validate (alias self, value);
        self:.verifyCompatibleTypeWithValue (loc, type, v);
        self:.verifyMemoryOwner (loc, type, v);

        v
    }


    /**
     * ================================================================================
     * ================================================================================
     * =========================           GETTERS            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * @returns: the validator for binary operations
     */
    pub def getBinOpValidator (mut self)-> dmut &BinaryOpValidator {
        alias self._binOpValidator
    }

    /**
     * @returns: the validator for unary operations
     */
    pub def getUnOpValidator (mut self)-> dmut &UnaryOpValidator {
        alias self._unOpValidator
    }

    /**
     * @returns: the validator for mult operators
     */
    pub def getMultOpValidator (mut self)-> dmut &MultOpValidator {
        alias self._multOpValidator
    }

    /**
     * @returns: the validator for literals
     */
    pub def getLiteralValidator (mut self)-> dmut &LiteralValidator {
        alias self._literalValidator
    }

    /**
     * @returns: the validator for akas
     */
    pub def getAkaValidator (mut self)-> dmut &AkaValidator {
        alias self._akaValidator
    }

    /**
     * @returns: the validator for classes
     */
    pub def getClassValidator (mut self)-> dmut &ClassValidator {
        alias self._classValidator
    }
    
    /**
     * @returns: the validator for functions
     */
    pub def getFunctionValidator (mut self)-> dmut &FunctionValidator {
        alias self._functionValidator
    }

    /**
     * @returns: the validator for modules
     */
    pub def getModuleValidator (mut self)-> dmut &ModuleValidator {
        alias self._moduleValidator
    }

    /**
     * @returns: the validator for struct
     */
    pub def getStructValidator (mut self)-> dmut &StructValidator {
        alias self._structValidator
    }

    /**
     * @returns: the validator for templates
     */
    pub def getTemplateValidator (mut self)-> dmut &TemplateValidator {
        alias self._templateValidator
    }

    /**
     * @returns: the validator for traits
     */
    pub def getTraitValidator (mut self)-> dmut &TraitValidator {
        alias self._traitValidator
    }

    /**
     * @returns: the interpreter that can compute cte values
     */
    pub def getCompileTimeInterpreter (mut self)-> dmut &CompileTimeInterpreter {
        alias self._compileTimeInterpreter
    }
    
    /**
     * ================================================================================
     * ================================================================================
     * =========================           CONTEXT            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Push a new referent 
     * @params: 
     *   - sym: the symbol that will be used for future symbol access
     */
    pub def pushReferent (mut self, dmut sym : &Symbol) {
        self._referent:.push (alias sym);
    }

    /**
     * Exit the current referent
     */
    pub def popReferent (mut self) {
        self._referent:.pop (1u64);
    }


    /**
     * @returns: the current referent
     */
    pub def getReferent (mut self)-> dmut &Symbol {
        return alias (alias self._referent)[self._referent.len () - 1us];
    } catch {
        _ : &OutOfArray => __pragma!panic ();
    }
    

    /**
     * ================================================================================
     * ================================================================================
     * =========================       LOCAL VARIABLES        =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Enter a new foreign scope space
     */
    pub def enterForeign (mut self) {
        self._symbols:.push (Vec!{dmut &HashMap!{[c8], &Value}}::new ());
        self._usedSyms:.push (Vec!{dmut &HashSet!{[c8]}}::new ());
        self._functionReturns:.push (NoneType::new (loc-> EOF_WORD));
    }

    /**
     * Exit a foreign scope space
     */
    pub def exitForeign (mut self) {
        self._symbols:.pop (1u64);
        self._usedSyms:.pop (1u64);
        self._functionReturns:.pop (1u64);
    }

    /**
     * Set the type of the current function
     */
    pub def setFunctionReturn (mut self, type : &Type) {
        (alias self._functionReturns)[self._functionReturns.len () - 1us] = type;        
    } catch {
        _ => __pragma!panic ();
    }
    
    /**
     * Enter a new scope
     */
    pub def enterBlock (mut self) {
        (alias self._symbols)[][$ - 1us]:.push (HashMap!{[c8], &Value}::new ());
        (alias self._usedSyms)[][$ - 1us]:.push (HashSet!{[c8]}::new ());
    }

    /**
     * Exit a scope
     * @throws: 
     *   - &ErrorMsg: if a symbol was declared but unused and warnUnused
     */
    pub def quitBlock (mut self, warnUnused : bool = true)
        throws &ErrorMsg
    {        
        if (warnUnused) {
            let dmut errors = Vec!{&ErrorMsg}::new ();
            for name, g in self._symbols[][$ - 1us][][$ - 1us] {
                if (name != Keys::SELF) { // SELF does not need to be used
                    if (name !in self._usedSyms[][$ - 1us][][$ - 1us]) {
                        errors:.push (ErrorMsg::warn (g.getLoc (), format (ValidateErrorMessage::DECLARED_NOT_USED, name)));
                    }
                }
            }
            
            if errors.len () != 0us {
                throw ErrorMsg::list (errors[]);
            }
        }

        (alias self._symbols)[][$ - 1us]:.pop (1u64);
        (alias self._usedSyms)[][$ - 1us]:.pop (1u64);
    }
    
    /**
     * Insert a new variable in the current block
     * @params: 
     *    - name: the name of the variable
     *    - val: the declaration of the variable
     */
    pub def insertLocal (mut self, name : [c8], val : &Value) {
        (alias ((alias self._symbols)[][$ - 1us]))[][$ - 1us]:.insert (name, val);
    }

    /**
     * Clear the current scope
     */
    pub def clearLocalScope (mut self) {
        (alias ((alias self._symbols)[][$ - 1us]))[][$ - 1us]:.clear ();
    }

    /**
     * Search the definition of a local variable
     * @params: 
     *   - name: the name of the variable to search
     *   - canBeInClosure: if the variable can be a variable from the parent of a closure
     * @returns: the generator of the variable or NoneValue
     */
    pub def getLocal (mut self, name : [c8], canBeInClosure : bool = true)-> &Value {
        for i in 0us .. self._symbols [][$ - 1us].len () {
            let ptr = self._symbols[][$ - 1us][][i].find (name);
            match ptr {
                Ok (g : &Value) => {
                    (alias ((alias self._usedSyms)[][$ - 1us])[][$ - 1us]):.insert (name);
                    return g;
                }
            }
        }

        if (canBeInClosure) {
            return self:.getInClosure (name);
        } else {
            return NoneValue::new ();
        }
    }

    /**
     * Search the definition of a local variable 
     * @warning: use only for shadowing verification, it does not update used variable infos
     * @params: 
     *   - name: the name of the variable to search
     *   - canBeInClosure: if the variable can be a variable from the parent of a closure
     * @returns: the generator of the variable or NoneValue
     */
    def getLocalNoUse (self, name : [c8])-> &Value {
        for i in 0us .. self._symbols [][$ - 1us].len () {
            let ptr = self._symbols[][$ - 1us][][i].find (name);
            match ptr {
                Ok (g : _) => {
                    return g;
                }
            }
        }

        NoneValue::new ()        
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================        GLOBAL SYMBOLS        =========================
     * ================================================================================
     * ================================================================================
     */


    /**
     * Search all the global symbols whose name are name
     * @params: 
     *   - name: the name of the symbols to get
     * @returns: the list of symbols whose name are name, and are accessible from the current context
     */
    pub def getGlobal (mut self, name : [c8])-> dmut [&Symbol] {
        if (self._referent.len () == 0us) return [];
        let dmut res = (alias self._referent) [self._referent.len () - 1us]:.getSymbols (name);
        return (alias res)[];
    } catch {
        _ => __pragma!panic ();
    }

    /**
     * Search all the global symbols whose name are close to `name`, with a distance of `distance`
     * @params: 
     *   - name: the name of the symbols to get
     *   - distance: the distance of the name of the symbol to `name`
     * @returns: the list of symbols whose name are close to `name` (only public ones)
     */
    pub def getCloseGlobal (self, name : [c8], distance : usize = 2us)-> [&Symbol] {
        if (self._referent.len () == 0us) return [];
        let res = ( self._referent) [self._referent.len () - 1us].getCloseSymbols (name, distance);
        return res[];
    } catch {
        _ => __pragma!panic ();
    }    

    /**
     * Search all the global symbols whose name are name
     * @params: 
     *   - name: the name of the symbols to get
     * @returns: the list of symbols whose name are name, even if they are not accessible from the current context (protection)
     */
    pub def getGlobalPrivate (mut self, name : [c8])-> dmut [&Symbol] {
        if (self._referent.len () == 0us) return [];
        let dmut res = (alias self._referent) [self._referent.len () - 1us]:.getSymbols (name, protection-> Protection::PRIVATE);
        return (alias res)[];
    } catch {
        _ => __pragma!panic ();
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================          INFERENCE           =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Infer the type from two branch that must lead to a common type 
     * @info: by setting none to oldType, only the type of val will be used
     * @params: 
     *   - loc: the location of the branching
     *   - oldType: the type of the other branch
     *   - val: the value of the current branch
     * @returns: the type that is common to oldType and val.getType (), without explicit cast needed
     * @throws:
     *   - &ErrorMsg: if there is no common type possible
     */
    pub def inferTypeBranchingWithValue (self, loc : &Word, oldType : &Type, val : &Value)-> &Type
        throws &ErrorMsg
    {
        loc;
        oldType;
        val;
        __pragma!fake_throw (&ErrorMsg);
        __pragma!panic ();
    }
        
    
    /**
     * ================================================================================
     * ================================================================================
     * =========================         VERIFICATION         =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Verify that the variable is not shadowing another variable
     * And that the variable name is a valid variable identifier (not a native type)
     * @params: 
     *    - loc: the location and name of the variable that may shadow
     * @throws: &ErrorMsg, if the variable shadows another local declaration, or the variable name is a type name
     */
    pub def verifyShadow (self, loc : &Word)
        throws &ErrorMsg
    {
        self.verifyNotIsNativeType (loc);
        match self.getLocalNoUse (loc.str ()) {
            NoneValue () => {}
            gen : _ => {
                throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::SHADOWING_DECL, loc.str ()),
                                       notes-> [ErrorMsg::note (gen.getLoc (), ValidateErrorMessage::FIRST_DEFINED)]
                                       );
            }
        }
    }

    /**
     * Verify that the name of the variable is not a native type
     * @params: 
     *   - loc: the location and name of the variable
     * @throws: &ErrorMsg, iif the name of the variable is a native type
     */
    def verifyNotIsNativeType (self, loc : &Word)
        throws &ErrorMsg
    {
        if loc.str () in self._nativeTypeNames {
            throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::IS_NATIVE_TYPE, loc.str ()));
        }
    }

    /**
     * Verify that the value `value` can be casted into the type `type` implicitely
     * @warning: this does not check implicit aliases and references (cf. self.verifyMemoryOwner)
     * @params: 
     *   - loc: the location of the affectation    
     *   - type: the type into which the cast is made
     *   - value: the value used
     * @throws: &ErrorMsg: if the cast cannot be made
     */
    pub def verifyCompatibleTypeWithValue (self, loc : &Word, type : &Type, value : &Value)
        throws &ErrorMsg
    {
        match (type, value) {
            (_ : &PointerType, _ : &NullValue) => return {} // ptr = null;
            (_ : &SliceType, _) => { 
                match value.getType () {
                    s : &SliceType => { if s.getInners ()[0].isOf!{&VoidType} () return {} } // slice = [];
                }
            }
            (_, u : &UniqValue) => { // uniq values contains other things 
                self.verifyCompatibleTypeWithValue (loc, type, u.getValue ());
                return {}
            }        
        }
        
        self.verifyCompatibleType (loc, value.getLoc (), type, value.getType ())
    }

    /**
     * Verify the compatibility of two types (not complete equals)
     * @params: 
     *   - lLoc: the location of the left type (or left operand, this is the location that will be shown in the error message)
     *   - rLoc: the location of the right type (or right operand, this is the location that will be shown in the error message)
     *   - noAncestor: don't check for ancestor compatibility 
     * @throws: &ErrorMsg: if the type are not compatible
     */
    pub def verifyCompatibleType (self, lLoc : &Word, rLoc : &Word, left : &Type, right : &Type, noAncestor : bool = false)
        throws &ErrorMsg
    {        
        if (left != right) {
            if (!noAncestor) {
                if (self.isAncestor (left, right)) { return {} }
            }
            
            if (lLoc.line () == rLoc.line ()) {
                throw ErrorMsg::fatal (lLoc, end-> rLoc, format (ValidateErrorMessage::INCOMPATIBLE_TYPE, left, right));
            } else {
                throw ErrorMsg::fatal (rLoc, format (ValidateErrorMessage::INCOMPATIBLE_TYPE, left, right),
                                       notes-> [ErrorMsg::note (lLoc, ""s8)]);
            }
        }
    }

    /**
     * @warning: Function that must be called at any affectation or memory movement in the code
     * Verify that the movement of memory is permitted (no implicit alias, no const disqualifier, etc.)
     * @params: 
     *   - loc: the location of the affectation
     *   - type: the type of the operation, to which the value is casted
     *   - value: the value that is moved
     *   - construct: true iif this is the construction of a new variable (this is the only time lambda are allowed)
     *   - checkTypes: if false does not call verifyCompatibleTypeWithValue, (this should be disable only if this was done beforehand)
     * @throws: 
     *   - ErrorMsg: if the operation is not permitted    
     */
    pub def verifyMemoryOwner (self, loc : &Word, type : &Type, value : &Value, construct : bool = false, checkTypes : bool = true)
        throws &ErrorMsg
    {
        match value {
            u : &UniqValue => { // we must check with the content of the uniq value, maybe it contains alias or ref, or pure, etc.
                self.verifyMemoryOwner (loc, type, u.getValue ());
                return {}
            }
        }
        
        if (checkTypes) self.verifyCompatibleTypeWithValue (loc, type, value);

        self.verifyCompleteType (loc, type); // Verify that the type can be used (if it is incomplete it cannot)
        self.verifyImplicitAlias (loc, type, value); // Verify that the movement is not made implicitely
        self.verifyImplicitPure (loc, type, value); // verify that there is no pure movement

        match type {
            LambdaType () => { // lambda type cannot be changed, they are not really values
                if (!construct || !value.isOf!{&LambdaValue} ()) throw ErrorMsg::fatal (value.getLoc (), ValidateErrorMessage::USE_AS_VALUE, notes-> [ErrorMsg::note (loc, ""s8)]);
                
                self.verifyMutabilityLevel (loc, value.getLoc (), type, value.getType ());
            }
            PointerType () => { // If we put null in a pointer it is necessarily a lesser level, but that is authorized
                let llevel = type.mutabilityLevel ();
                let rlevel = value.getType ().mutabilityLevel ();
                if (llevel > max (1u32, rlevel) && !value.isOf!{&NullValue} ()) {
                    self.verifyMutabilityLevel (loc, value.getLoc (), type, value.getType ());
                }
            }
            _ => { // all the other types must be checked in a deeper analyses
                self.verifyMutabilityLevel (loc, value.getLoc (), type, value.getType ());
            }
        }
    }

    /**
     * Verification that the type used is complete and therefore can be used for a variable data type (so not a TemporaryType)
     * @params: 
     *  - loc: the location of the use
     *  - type: the type to check
     * @throws:
     *  - &ErrorMsg: if there is something not allowed here
     */
    def verifyCompleteType (self, loc : &Word, type : &Type)
        throws &ErrorMsg
    {
        if (type.isOf!{&TemporaryType} ()) {
            throw ErrorMsg::fatal (type.getLoc (), format (ValidateErrorMessage::INCOMPLETE_TYPE, type), notes-> if (!loc.isSame (type.getLoc ())) { [ErrorMsg::note (loc, ""s8)] } else { [] });
        }
    }

    /**
     * Verification that the the type does not need alias, and otherwise that the value is an aliaser
     * @warning: does not fully check the mutability etc., cf. verifyMutabilityLevel
     * @params: 
     *  - loc: the location of the movement
     *  - type: the type that will receive the data
     *  - value: the value that is moved
     * @throws:
     *  - &ErrorMsg: if there is something not allowed here
     */
    def verifyImplicitAlias (self, loc : &Word, type : &Type, value : &Value)
        throws &ErrorMsg
    {
        if (!type.needExplicitAlias ()) return {} // no data are borrowed
        let max_level = max (1u32, match value {
            MemoryValue () => return {} // It is not implicit, it is specified
            LiteralValue () => return {} // No need for alias, it would be rebarbative, the construction does not own its data
            ConstructValue () => return {} // No need for alias, it would be rebarbative, the construction does not own its data
            s : &ScopeValue => { // alias is mandatory at the end of scope, otherwise the type is not mutable
                s.getType ().mutabilityLevel ()
            }
            c : &CallValue => { // function call is a kind of scope, even if it is an outer scope
                c.getType ().mutabilityLevel ()
            }
            _ => { 1u32 }
        });

        let llevel = type.mutabilityLevel ();
        if (llevel > max_level) {
            let dmut notes = Vec!{&ErrorMsg}::new ();
            notes:.push (ErrorMsg::note (value.getLoc (), format (ValidateErrorMessage::IMPLICIT_ALIAS, value.getType ())));
            match type {
                s : &CompoundType => { // if the type is struct, then the implicit alias is due to a inner field 
                    let (ftype, floc) = s.getExplicitAliasFieldLoc (); 
                    if (!floc.isSame (loc)) 
                        notes:.push (ErrorMsg::note (floc, 
                                                     format (ValidateErrorMessage::IMPLICIT_ALIAS, ftype)));
                }
            }

            throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::DISCARD_CONST_LEVEL, llevel, max_level), notes-> notes[]);
        }        
    }
    

    /**
     * Verify that there is no movement of pure data 
     * @example: 
     * ==========================
     * let dmut a = [1, 2, 3];
     * let pure b = a; // prohibited because 
     * a [0] = 9;
     * // b is changed
     * println (b); // [9, 2, 3], but it is pure ??
     * ==========================
     * @warning: does not fully check the mutability etc., cf. verifyMutabilityLevel
     * @params: 
     *   - loc: the location of the movement 
     *   - type: the left type of the operation
     *   - value: the value that is moved
     * @throws: if there is something prohibited
     */
    def verifyImplicitPure (self, loc : &Word, type : &Type, value : &Value)
        throws &ErrorMsg
    {
        if (type.isPure ()) {
            if (value.getType ().isPure () || value.isOf!{&DeepCopierValue} ()) return {}
            else {
                throw ErrorMsg::fatal (loc, ValidateErrorMessage::DISCARD_CONST,
                                       notes-> [ErrorMsg::note (value.getLoc (), format (ValidateErrorMessage::IMPLICIT_PURE, value.getType ()))]);
            }
        }

    }

    /**
     * Verify that the mutability level of lType is higher or equal than those of rType, otherwise memory movement creates a discard of const
     * @example:
     * ===================
     * let mut a = [1, 2, 3];
     * let dmut b = alias a; // no implicit alias, but a cannot give mutable access to inner values
     * b [0] = 9;
     * println (a); // [9, 2, 3]; we did not respected the contract of a
     * ===================
     * @params: 
     *   - lLoc: the location of the left operand in the movement operation
     *   - rLoc: the location of the right operation in the movement operation
     *   - lType: the type on the left of the operation (type of `b` in the example)
     *   - rType: the type on the right of the operation (type of `a` in the example)
     *   - construct: true if we are creating a new variable (true in the above example, `b` is declared)
     * @throws:
     *  - &ErrorMsg: if the movement is not allowed 
     */
    def verifyMutabilityLevel (self, lLoc : &Word, rLoc : &Word, lType : &Type, rType : &Type)
        throws &ErrorMsg
    {        
        match lType {
            t : &TupleType => { self.verifyMutabilityLevelTuple (lLoc, rLoc, lType, t); }
            LambdaType () => {
                if (lType.isMutable ()) {
                    throw ErrorMsg::fatal (rLoc, format (ValidateErrorMessage::DISCARD_CONST_LEVEL, 1, 0));
                }
            }
            _ => {
                if (lType.isOf!{&CustomType} () || lType.isOf!{&CompoundType} ()) {
                    let lLevel = lType.mutabilityLevel ();
                    let rLevel = if (self.isVoidSliceType (rType)) {
                        lLevel
                    } else {
                        rType.mutabilityLevel ()
                    };
                    
                    if (lLevel > max (1u32, rLevel)) {
                        throw ErrorMsg::fatal (lLoc, format (ValidateErrorMessage::DISCARD_CONST_LEVEL, lLevel, max (1u32, rLevel)), notes-> [ErrorMsg::note (rLoc, ""s8)]);
                    }
                }
            }
        }
    }

    /**
     * @returns: true if `type` is slice of containing void elements
     */
    def isVoidSliceType (self, type : &Type)-> bool {
        match type {
            s : &SliceType => {
                s.getInners ()[0].isOf!{&VoidType} ()
            }
            _ => { false }
        }
    }

    /**
     * Tuple are trees, thus the mutability level does not work, we have to make a different validation
     * @params: 
     *   - lLoc: the location of the left operand
     *   - rLoc: the location of the right operand
     *   - lType: the left type of the operation
     *   - rType: the right type of the operation
     * @throws: 
     *  - &ErrorMsg: if the movement is not allowed 
     */
    def verifyMutabilityLevelTuple (self, lLoc : &Word, _ : &Word, lType : &Type, rType : &TupleType)
        throws &ErrorMsg
    {
        match lType {
            left : &TupleType => {
                {
                    for i in 0us .. left.getInners ().len {
                        let litype = left.getInners ()[i], ritype = rType.getInners ()[i];
                        self.verifyMutabilityLevel (litype.getLoc (), ritype.getLoc (), litype, ritype);
                    }
                } catch {
                    err : &ErrorMsg => {
                        throw ErrorMsg::fatal (lLoc, ValidateErrorMessage::DISCARD_CONST, notes-> [err]);
                    }
                }
            }
            _ => {
                __pragma!panic ();
            }
        }
    }
    
    /**
     * Testing if left is an ancestor class of right, this is usefull for type compatibility checking
     * @info: check if the types are ClassPtrType, or ClassRefType (works with both)
     * @params: 
     *    - left: any type
     *    - right: any type
     * @returns: true if the left type is a classptrtype and is an ancestor of the right type (a classptrtype as well)
     */
    pub def isAncestor (self, left : &Type, right : &Type)-> bool {
        let rInner : &ClassRefType = match right {
            c : &ClassPtrType => { c.getInner () }
            c : &ClassRefType => { c }
            _ => { return false; }
        }

        let lInner : &ClassRefType = match left {
            c : &ClassPtrType => { c.getInner () }
            c : &ClassRefType => { c }
            _ => { return false; }
        }

        let mut ancestor = rInner.getAncestor ();
        loop {
            match ancestor {
                c : &ClassRefType => {
                    if (c == lInner) { break true; }
                    ancestor = c.getAncestor ();
                }
                _ => { break false; }
            }
        }
    }
    
    /**
     * ================================================================================
     * ================================================================================
     * =========================          GENERATION          =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Insert a new generator that will be sent to the backend for final transformation
     * @params: 
     *    - gen: a generator that can be transformed into a valid backend element (e.g. FrameGenerator)
     */
    pub def insertNewGenerator (mut self, gen : &Generator) {
        self._generated:.push (gen);
    }

    /**
     * @returns: the list of generators that were inserted for final transformation
     */
    pub def getGenerators (self)-> [&Generator] {
        self._generated[]
    }
    
    /**
     * ================================================================================
     * ================================================================================
     * =========================           PRIVATE            =========================
     * ================================================================================
     * ================================================================================
     */
    
    /**
     * @returns: a local variable that is enclosed
     */
    def getInClosure (mut self, name : [c8])-> &Value {
        if (!self._isInClosure) return NoneValue::new ();

        name;
        NoneValue::new ()
    }
        
}
