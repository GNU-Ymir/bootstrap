mod ymirc::semantic::validator::visitor;

import ymirc::semantic::validator::module;
import ymirc::semantic::validator::function;
import ymirc::semantic::validator::type;
import ymirc::semantic::validator::value;
import ymirc::semantic::validator::errors;

import ymirc::semantic::symbol::_;
import ymirc::semantic::generator::_;
import ymirc::syntax::keys;
import ymirc::syntax::expression::_;
import ymirc::errors::_;
import ymirc::lexing::word;
import ymirc::utils::format;

import std::collection::vec;
import std::collection::map;
import std::collection::set;
import std::io;


/**
 * The validator class is the class that transform the declared symbols into validated generators that can be passed to the backend
 */
pub class Validator {

    /// The list of generators to pass to the backend
    let dmut _generated = Vec!{&Generator}::new ();

    /**
     * ================================================================================
     * ================================================================================
     * =========================        SUB VALIDATORS        =========================
     * ================================================================================
     * ================================================================================
     */
    
    /// The validator that is in charge of validating modules
    let dmut _moduleValidator = ModuleValidator::new ();

    /// The validator that is in charge of validating functions
    let dmut _functionValidator = FunctionValidator::new ();

    /// The validator that is in charge of validating types
    let dmut _typeValidator = TypeValidator::new ();

    /// The validator that is in charge of validating values
    let dmut _valueValidator = ValueValidator::new ();


    /**
     * ================================================================================
     * ================================================================================
     * =========================           CONTEXT            =========================
     * ================================================================================
     * ================================================================================
     */

    /// The referent are used when accessing symbols
    let dmut _referent = Vec!{dmut &Symbol}::new ();
    
    /// The current block symbols
    let dmut _symbols = Vec!{dmut &Vec!{dmut &HashMap!{[c8], &Generator}}}::new ();

    /// The list of symbols that are used in the current block
    let dmut _usedSyms = Vec!{dmut &Vec!{dmut &HashSet!{[c8]}}}::new ();

    /// The current return type of the current function
    let dmut _functionReturns = Vec!{&Type}::new ();

    /// True iif we are currently validating a closure
    let mut _isInClosure = false;

    /**
     * ================================================================================
     * ================================================================================
     * =========================        VERIFICATIONS         =========================
     * ================================================================================
     * ================================================================================
     */

    /// The native type names
    let dmut _nativeTypeNames = HashSet!{[c8]}::new ();    
    
    /**
     * ================================================================================
     * ================================================================================
     * =========================         CONSTRUCTION         =========================
     * ================================================================================
     * ================================================================================
     */
    
    /**
     * Create a new empty validator
     */
    pub self () {        
        for t in NativeTypes::__members__ {
            self._nativeTypeNames:.insert (t);
        }
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================          VALIDATION          =========================
     * ================================================================================
     * ================================================================================
     */
    
    /**
     * Validate a symbol
     * @params: 
     *   - sym: the symbol to validate
     * @throws: 
     *   - &ErrorMsg: if there was an error in the validation
     */
    pub def validate (mut self, dmut sym : &Symbol)
        throws &ErrorMsg
    {
        match ref sym {
            dmut m : &ModuleSymbol => {
                self._moduleValidator:.validate (alias self, alias m);
            }
            dmut f : &FunctionSymbol => {
                self._functionValidator:.validate (alias self, alias f);
            }
            _ => {
                println ("TODO : ", sym::typeinfo.name);
                __pragma!panic ();
            }                
        }
    }


    /**
     * ================================================================================
     * ================================================================================
     * =========================            TYPES             =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate an expression assuming its a type
     * @params: 
     *    - type: the expression to validate
     * @returns: the generator
     * @throws: &ErrorMsg, if the type is not valid
     */
    pub def validateType (mut self, type : &Expression)-> &Type
        throws &ErrorMsg
    {
        self._typeValidator:.validate (alias self, type)
    }
    

    /**
     * ================================================================================
     * ================================================================================
     * =========================            VALUES            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate an expression assuming its a value
     * @params: 
     *    - value: the expression to validate
     * @returns: the generator
     * @throws: &ErrorMsg, if the value is not valid
     */
    pub def validateValue (mut self, value : &Expression)-> &Value
        throws &ErrorMsg
    {
        self._valueValidator:.validate (alias self, value)
    }
    

    /**
     * ================================================================================
     * ================================================================================
     * =========================           CONTEXT            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Push a new referent 
     * @params: 
     *   - sym: the symbol that will be used for future symbol access
     */
    pub def pushReferent (mut self, dmut sym : &Symbol) {
        self._referent:.push (alias sym);
    }

    /**
     * Exit the current referent
     */
    pub def popReferent (mut self) {
        self._referent:.pop (1u64);
    }


    /**
     * ================================================================================
     * ================================================================================
     * =========================       LOCAL VARIABLES        =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Enter a new foreign scope space
     */
    pub def enterForeign (mut self) {
        self._symbols:.push (Vec!{dmut &HashMap!{[c8], &Generator}}::new ());
        self._usedSyms:.push (Vec!{dmut &HashSet!{[c8]}}::new ());
        self._functionReturns:.push (NoneType::new (loc-> EOF_WORD));
    }

    /**
     * Exit a foreign scope space
     */
    pub def exitForeign (mut self) {
        self._symbols:.pop (1u64);
        self._usedSyms:.pop (1u64);
        self._functionReturns:.pop (1u64);
    }

    /**
     * Set the type of the current function
     */
    pub def setFunctionReturn (mut self, type : &Type) {
        (alias self._functionReturns)[self._functionReturns.len () - 1us] = type;        
    } catch {
        _ => __pragma!panic ();
    }
    
    /**
     * Enter a new scope
     */
    pub def enterBlock (mut self) {
        (alias self._symbols)[][$ - 1us]:.push (HashMap!{[c8], &Generator}::new ());
        (alias self._usedSyms)[][$ - 1us]:.push (HashSet!{[c8]}::new ());
    }

    /**
     * Exit a scope
     * @throws: 
     *   - &ErrorMsg: if a symbol was declared but unused and warnUnused
     */
    pub def quitBlock (mut self, warnUnused : bool = true)
        throws &ErrorMsg
    {        
        if (warnUnused) {
            let dmut errors = Vec!{&ErrorMsg}::new ();
            for name, g in self._symbols[][$ - 1us][][$ - 1us] {
                if (name != Keys::SELF) { // SELF does not need to be used
                    if (name !in self._usedSyms[][$ - 1us][][$ - 1us]) {
                        errors:.push (ErrorMsg::warn (g.getLoc (), format (ValidateErrorMessage::DECLARED_NOT_USED, name)));
                    }
                }
            }
            
            if errors.len () != 0us {
                throw ErrorMsg::list (errors[]);
            }
        }

        (alias self._symbols)[][$ - 1us]:.pop (1u64);
        (alias self._usedSyms)[][$ - 1us]:.pop (1u64);
    }
    
    /**
     * Insert a new variable in the current block
     * @params: 
     *    - name: the name of the variable
     *    - generator: the generator of the variable
     */
    pub def insertLocal (mut self, name : [c8], generator : &Generator) {
        (alias ((alias self._symbols)[][$ - 1us]))[][$ - 1us]:.insert (name, generator);
    }

    /**
     * Clear the current scope
     */
    pub def clearLocalScope (mut self) {
        (alias ((alias self._symbols)[][$ - 1us]))[][$ - 1us]:.clear ();
    }

    /**
     * Search the definition of a local variable
     * @params: 
     *   - name: the name of the variable to search
     *   - canBeInClosure: if the variable can be a variable from the parent of a closure
     * @returns: the generator of the variable or EmptyGenerator
     */
    pub def getLocal (mut self, name : [c8], canBeInClosure : bool = false)-> &Generator {
        for i in 0us .. self._symbols [][$ - 1us].len () {
            let ptr = self._symbols[][$ - 1us][][i].find (name);
            match ptr {
                Ok (g : _) => {
                    (alias ((alias self._usedSyms)[][$ - 1us])[][$ - 1us]):.insert (name);
                    return g;
                }
            }
        }

        if (canBeInClosure) {
            self:.getInClosure (name)
        } else {
            EmptyGenerator::new ()
        }
    }

    /**
     * Search the definition of a local variable 
     * @warning: use only for shadowing verification, it does not update used variable infos
     * @params: 
     *   - name: the name of the variable to search
     *   - canBeInClosure: if the variable can be a variable from the parent of a closure
     * @returns: the generator of the variable or EmptyGenerator
     */
    def getLocalNoUse (self, name : [c8])-> &Generator {
        for i in 0us .. self._symbols [][$ - 1us].len () {
            let ptr = self._symbols[][$ - 1us][][i].find (name);
            match ptr {
                Ok (g : _) => {
                    return g;
                }
            }
        }

        EmptyGenerator::new ()        
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================         VERIFICATION         =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Verify that the variable is not shadowing another variable
     * And that the variable name is a valid variable identifier (not a native type)
     * @params: 
     *    - loc: the location and name of the variable that may shadow
     * @throws: &ErrorMsg, if the variable shadows another local declaration, or the variable name is a type name
     */
    pub def verifyShadow (self, loc : &Word)
        throws &ErrorMsg
    {
        self.verifyNotIsNativeType (loc);
        match self.getLocalNoUse (loc.str ()) {
            EmptyGenerator () => {}
            gen : _ => {
                throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::SHADOWING_DECL, loc.str ()),
                                       notes-> [ErrorMsg::note (gen.getLoc (), ValidateErrorMessage::FIRST_DEFINED)]
                                       );
            }
        }
    }

    /**
     * Verify that the name of the variable is not a native type
     * @params: 
     *   - loc: the location and name of the variable
     * @throws: &ErrorMsg, iif the name of the variable is a native type
     */
    def verifyNotIsNativeType (self, loc : &Word)
        throws &ErrorMsg
    {
        if loc.str () in self._nativeTypeNames {
            throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::IS_NATIVE_TYPE, loc.str ()));
        }
    }

    
    pub def verifyCompatibleTypeWithValue (self, loc : &Word, type : &Type, value : &Value)
        throws &ErrorMsg
    {
        match (type, value) {
            (_ : &PointerType, _ : &NullValue) => {
                return {}
            }
        }

        loc;
        __pragma!fake_throw (&ErrorMsg);
    }

    pub def verifyCompatibleType (self, loc : &Word, left : &Type, right : &Type)
        throws &ErrorMsg
    {
        left;
        right;
        loc;
        __pragma!fake_throw (&ErrorMsg);
    }

    pub def verifyMemoryOwner (self, loc : &Word, left : &Type, right : &Value)
        throws &ErrorMsg
    {
        left;
        right;
        loc;
        __pragma!fake_throw (&ErrorMsg);
    }

    
    /**
     * ================================================================================
     * ================================================================================
     * =========================           PRIVATE            =========================
     * ================================================================================
     * ================================================================================
     */
    
    /**
     * @returns: a local variable that is enclosed
     */
    def getInClosure (mut self, name : [c8])-> &Generator {
        if (!self._isInClosure) return EmptyGenerator::new ();

        name;
        EmptyGenerator::new ()
    }
        
}
