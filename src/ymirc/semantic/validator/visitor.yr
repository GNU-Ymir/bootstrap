mod ymirc::semantic::validator::visitor;

import ymirc::semantic::validator::symbol::_;
import ymirc::semantic::validator::operator::_;
import ymirc::semantic::validator::template::_;
import ymirc::semantic::declarator::visitor;
import ymirc::semantic::validator::type;
import ymirc::semantic::validator::value;
import ymirc::semantic::validator::literal;
import ymirc::semantic::validator::errors;
import ymirc::semantic::validator::interpret;
import ymirc::semantic::validator::pragma;
import ymirc::semantic::validator::sizeof_;
import ymirc::semantic::validator::operator::copyop;

import ymirc::semantic::symbol::_;
import ymirc::semantic::generator::_;
import ymirc::syntax::keys;
import ymirc::syntax::expression::_;
import ymirc::syntax::declaration::protection;
import ymirc::errors::_;
import ymirc::lexing::word;
import ymirc::lexing::tokens;
import ymirc::utils::format;
import ymirc::utils::timer;
import ymirc::global::core_;
import std::collection::vec;
import std::collection::map;
import std::collection::set;
import std::algorithm::comparison;
import std::io, std::fs::path;
import std::time::_;


extern (C) fn _yrt_exc_get_stack_trace ()-> [&(void)];
extern (C) fn _yrt_exc_resolve_stack_trace (trc : [&void])-> [c8];

/**
 * The validator class is the class that transform the declared symbols into validated generators that can be passed to the backend
 */
pub class Validator {

    /**
     * ================================================================================
     * ================================================================================
     * =========================          DECLARATOR          =========================
     * ================================================================================
     * ================================================================================
     */

    /// The declarator for post semantic symbol declaration
    let dmut _declarator : &Declarator;

    /**
     * ================================================================================
     * ================================================================================
     * =========================      SYMBOL VALIDATORS       =========================
     * ================================================================================
     * ================================================================================
     */

    /// The validator that is in charge of aka validation
    let dmut _akaValidator = AkaValidator::new ();

    /// The validator that is in charge of class validation
    let dmut _classValidator = ClassValidator::new ();
    
    /// The validator that is in charge of validating cast expressions
    let dmut _castValidator = CastValidator::new ();
    
    /// The validator that is in charge of validating functions
    let dmut _functionValidator = FunctionValidator::new ();

    /// The validator that is in charge of validating modules
    let dmut _moduleValidator = ModuleValidator::new ();
    
    /// The validator that is in charge of class validation
    let dmut _structValidator = StructValidator::new ();

    /// The validator that is in charge of enum validation
    let dmut _enumValidator = EnumValidator::new ();

    /// The validator that is in charge of template validation
    let dmut _templateSolver = TemplateSolver::new ();

    /// The declarator that is in charge of template rewritting and declaration
    let dmut _templateDeclarator = TemplateDeclarator::new ();

    /// The validator that is in charge of template validation
    let dmut _traitValidator = TraitValidator::new ();

    /// The validator that is in charge of the lambda validation
    let dmut _lambdaValidator = LambdaValidator::new ();

    /// The validator that is in charge of the pragma exprs validation 
    let dmut _pragmaValidator = PragmaValidator::new ();

    /// The validator in charge of the validation of global variables
    let dmut _globalValidator = GlobalValidator::new ();

    /// The validator in charge of the validation of sizeof
    let dmut _sizeofValidator = SizeofValidator::new ();

    /// The validator in charge of validation of copy/dcopy
    let dmut _copyValidator = CopyOpValidator::new ();

    /// The interpreter to compute compile time values
    let dmut _compileTimeInterpreter = CompileTimeInterpreter::new ();

    /**
     * ================================================================================
     * ================================================================================
     * =========================        SUB VALIDATORS        =========================
     * ================================================================================
     * ================================================================================
     */

    /// The validator that is in charge of validating types
    let dmut _typeValidator = TypeValidator::new ();

    /// The validator that is in charge of validating values
    let dmut _valueValidator = ValueValidator::new ();

    /// The validator used to validate binary operators
    let dmut _binOpValidator = BinaryOpValidator::new ();

    /// The validator used to validate unary operators
    let dmut _unOpValidator = UnaryOpValidator::new ();

    /// The validator used to validate call operators
    let dmut _callOpValidator = CallOpValidator::new ();

    /// The validator used to validate index operators
    let dmut _indexOpValidator = IndexOpValidator::new ();

    /// The validator used to validate literals
    let dmut _literalValidator = LiteralValidator::new ();

    /// The validator used to validate for loops
    let dmut _forLoopValidator = ForLoopValidator::new ();

    /// The validator used to validate '::' operation where left operand is a type
    let dmut _subTypeValidator = SubTypeValidator::new ();

    /// The validator used to validate match expressions
    let dmut _matcherValidator = MatcherValidator::new ();
    
    /**
     * ================================================================================
     * ================================================================================
     * =========================           CONTEXT            =========================
     * ================================================================================
     * ================================================================================
     */

    /// The referent are used when accessing symbols
    let dmut _referent = Vec!{dmut &Symbol}::new ();
    
    /// The current scope variable declarations
    let dmut _symbols = Vec!{dmut &Vec!{dmut &HashMap!{[c8], &Value}}}::new ();

    /// The list of symbols that are used in the current block
    let dmut _usedSyms = Vec!{dmut &Vec!{dmut &HashSet!{[c8]}}}::new ();

    /// The current return type of the current function
    let dmut _functionReturns = Vec!{&Type}::new ();

    /// True iif we are currently validating a lambda body
    let dmut _inLambda = Vec!{bool}::new ();

    /// True iif we are currently validating a function body (can be a lambda)
    let dmut _inFunctionBody = Vec!{bool}::new ();

    /// True iif we are currently validating an unsafe block
    let dmut _inUnsafeContext = Vec!{&Word}::new ();

    /// Location of the use of unsafe (unsafe operation in an unsafe context, EOF if none)
    let dmut _inUnsafeContextUsed = Vec!{&Word}::new ();

    /// The current type of the breaks for the current loop
    let dmut _loopBreakTypes = Vec!{dmut &Vec!{&Type}}::new ();

    /// The current closure type
    let dmut _closureType = Vec!{dmut &ClosureType}::new ();

    /// The current type whose fields are being validated
    let dmut _fieldConstructionTypes = Vec!{&Type}::new ();

    /// The list of fields that have been validated during the pre construction
    let dmut _fieldConstructionValidated = Vec!{dmut &HashSet!{[c8]}}::new ();

    /// The class that is being validated (methods, constructors, etc.)
    let dmut _classContext = Vec!{&Type}::new ();

    /// The current value that is being indexed for opDollar
    let dmut _dollarContext = Vec!{dmut &Vec!{&Value}}::new ();

    /// The current copy context entered
    let dmut _copyContext = Vec!{dmut &Vec!{&Expression}}::new ();

    /// All the generators created during the validation
    let dmut _generators = Vec!{&Generator}::new ();

    /**
     * ================================================================================
     * ================================================================================
     * =============================        TIMERS         ============================
     * ================================================================================
     * ================================================================================
     */

    // The time to remove from timer (declaration, syntax...)
    let mut _removeTime = dur::seconds (0);

    /**
     * ================================================================================
     * ================================================================================
     * =========================        VERIFICATIONS         =========================
     * ================================================================================
     * ================================================================================
     */

    /// The native type names
    let dmut _nativeTypeNames = HashSet!{[c8]}::new ();    

    /**
     * ================================================================================
     * ================================================================================
     * =========================         CONSTRUCTION         =========================
     * ================================================================================
     * ================================================================================
     */
    
    /**
     * Create a new empty validator
     */
    pub self (dmut declarator : &Declarator)
        with _declarator = alias declarator
    {        
        for t in NativeTypes::__members__ {
            self._nativeTypeNames:.insert (t);
        }
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================          VALIDATION          =========================
     * ================================================================================
     * ================================================================================
     */
    
    /**
     * Validate a symbol
     * @params: 
     *   - sym: the symbol to validate
     * @throws: 
     *   - &ErrorMsg: if there was an error in the validation
     */
    pub fn validate (mut self, dmut sym : &Symbol)
        throws &ErrorMsg
    {
        let start = instant::now ();
        match ref sym {
            dmut m : &ModuleSymbol => {
                self._moduleValidator:.validate (alias self, alias m);
            }
            dmut f : &FunctionSymbol => {
                self._functionValidator:.validate (alias self, alias f);
            }
            dmut s : &StructSymbol => {
                self._structValidator:.validate (alias self, alias s);
            }
            dmut c : &ClassSymbol => {
                self._classValidator:.validate (alias self, alias c, inModule-> true);
            }
            dmut tr : &TraitSymbol => {
                self._traitValidator:.validate (alias self, alias tr);
            }
            dmut en : &EnumSymbol => {
                self._enumValidator:.validate (alias self, alias en);
            }
            dmut glb : &GlobalSymbol => {
                self._globalValidator:.validate (alias self, alias glb);
            }
            EmptySymbol () => {
                // Just do nothing 
            }
            TemplateSymbol () => {
                // TODO, verify that the symbols can be infered without any call, and if yes then validate it
            }
            _ => {
                println ("TODO : ", sym::typeinfo.name);
                __pragma!panic ();
            }                
        }

        let end = instant::now ();
        timer::instance ():.getValidationMap ():.insert (sym.getPath ().toStr (), (end - start));
    }
    
    /**
     * ================================================================================
     * ================================================================================
     * =========================            TYPES             =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate an expression assuming its a type
     * @params: 
     *    - type: the expression to validate
     * @returns: the generator
     * @throws: &ErrorMsg, if the type is not valid
     */
    pub fn validateType (mut self, type : &Expression)-> &Type
        throws &ErrorMsg
    {
        self._typeValidator:.validate (alias self, type)
    }


    /**
     * Validate an expression assuming its a type
     * @params: 
     *    - type: the expression to validate
     *    - decos: the additional decoration of the type (basically the decorations of a vardecl)
     * @returns: the generator of the type
     * @throws: &ErrorMsg, if the type is not valid
     */
    pub fn validateType (mut self, type : &Expression, decos : [DecoratorWord], canBeRef : bool = false)-> (bool, &Type)
        throws &ErrorMsg
    {
        let dmut found = HashMap!{Decorators, &Word}::new ();
        let dmut antiAffs = hmap #[
            Decorators::PURE => hset #{Decorators::MUT, Decorators::CONST, Decorators::DMUT, Decorators::REF},
            Decorators::MUT  => hset #{Decorators::CONST, Decorators::DMUT, Decorators::PURE},
            Decorators::DMUT  => hset #{Decorators::CONST, Decorators::MUT, Decorators::PURE},
            Decorators::CONST  => hset #{Decorators::PURE, Decorators::MUT, Decorators::DMUT},
            Decorators::REF => hset #{Decorators::PURE}
        ];
        
        for i in decos {      
            if (i.deco == Decorators::REF && !canBeRef) {
                throw ErrorMsg::fatal (i.loc, format (ValidateErrorMessage::UNDEF_DECORATOR_TYPE, Decorators::REF));
            }
            
            match found.find (i.deco) {
                Ok (l : _) => throw ErrorMsg::warn (i.loc, format (ValidateErrorMessage::MULTIPLE_DECORATORS, i.deco), notes-> [ErrorMsg::note (l, ""s8)]);
            }

            match antiAffs.find (i.deco) {
                Ok (an : _) => {
                    for j in an {
                        match found.find (j) {
                            Ok (l : _) => throw ErrorMsg::fatal (i.loc, format (ValidateErrorMessage::CONFLIT_DECORATORS, j, i.deco), notes-> [ErrorMsg::note (l, ""s8)]);
                        }
                    }
                }
                Err () => {
                    throw ErrorMsg::fatal (i.loc, format (ValidateErrorMessage::UNDEF_DECORATOR_TYPE, i.deco));
                }
            }
            
            found:.insert (i.deco, i.loc);
        }
        
        let (isMutable, isDeeplyMutable, isRef) = (Decorators::MUT in found, Decorators::DMUT in found, Decorators::REF in found);
        
        (isRef, self._typeValidator:.validate (alias self, type, isMutable-> (isMutable || isDeeplyMutable), parentMutable-> (isMutable || isDeeplyMutable), isDeeplyMutable-> isDeeplyMutable))
    }


    /**
     * @params: 
     *    - decos: a list of decorated word (for example those of a var decl)
     *    - toFind: a list of decorators to check
     * @returns: true if one of the `toFind` can be found in `decos`
     * @warning: does not check integrity of the `decos` set
     * @example: 
     * ======================
     * let isPure = self.findDecos ([DecoratorWord (Word::eof (), Decorators::PURE)], [Decorators::PURE]);
     * let isMutable = self.findDecos ([DecoratorWord (Word::eof (), Decorators::PURE)], [Decorators::MUT, Decorators::DMUT]);
     * 
     * assert (isPure && !isMutable)
     * ======================
     */
    pub fn findDecos (self, decos : [DecoratorWord], toFind : [Decorators])-> bool {
        for i in decos {
            for j in toFind {
                if (i.deco == j) return true;
            }
        }

        false
    }

    /**
     * Validate the typeinfo struct and return it
     * @params:
     *    - loc: the location where the type is required
     * */
    pub fn validateTypeInfo (mut self, loc : &Word)-> &Type
        throws &ErrorMsg
    {
        let name = self.createSyntaxVarFromPath (loc, [CoreNames::CORE_MODULE, CoreNames::TYPEINFO_MODULE, CoreNames::TYPEINFO_TYPE]);
        {
            self:.validateType (name)
        } catch {
            err : &ErrorMsg => {
                throw err.appendNotes ([ErrorMsg::note (loc, ValidateErrorMessage::HERE)]);
            }
        }
    }

    /**
     * Validate the typeids enumeration and return it
     * @params:
     *    - loc: the location where the typeids are required
     * */
    pub fn validateTypeIDs (mut self, loc : &Word, field : [c8])-> &Value
        throws &ErrorMsg
    {
        let name = self.createSyntaxVarFromPath (loc, [CoreNames::CORE_MODULE, CoreNames::TYPEINFO_MODULE, CoreNames::TYPEINFO_IDS]);
        {
            match self:.validateType (name) {
                en : &EnumType => {
                    return self._subTypeValidator.validateEnumField (alias self, loc, en, field);
                }
                _ => throw ErrorMsg::fatal (loc, ValidateErrorMessage::MALFORMED_TYPEINFO_CORE);
            }
        } catch {
            err : &ErrorMsg => {
                throw err.appendNotes ([ErrorMsg::note (loc, ValidateErrorMessage::HERE)]);
            }
        }
    }


    /**
     * ================================================================================
     * ================================================================================
     * =========================            VALUES            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate an expression assuming its a value
     * @params: 
     *    - value: the expression to validate
     * @returns: the generator
     * @throws: &ErrorMsg, if the value is not valid
     */
    pub fn validateValue (mut self, value : &Expression, noReduce : bool = false)-> &Value
        throws &ErrorMsg
    {
        let val = self._valueValidator:.validate (alias self, value);
        if (!noReduce) {
            self._compileTimeInterpreter.reduce (val)
        } else {
            val
        }
    }

    /**
     * Validate an expression assuming its a value
     * @params: 
     *    - loc: the location of the affection
     *    - value: the expression to validate
     *    - type: the expected type (and mutability)
     * @returns: the generator
     * @throws: &ErrorMsg, if the value is not valid, or cannot be put in type
     */
    pub fn validateValue (mut self, loc : &Word, value : &Expression, type : &Type, verif : bool = true, noReduce : bool = false)-> &Value
        throws &ErrorMsg
    {
        let v = self:.validateValue (value, noReduce-> noReduce);
        if (verif) {
            self.verifyCompleteTypeWithValue (loc, v.getType (), v, construct-> false);
            let v_ = self:.verifyCompatibleTypeWithValue (loc, type, v);
            self:.verifyMemoryOwner (loc, type, v_, byReference-> false);
            v_
        } else
            v
    }

    /**
     * Validate cte expressions (e.g. cte if, cte assert, ...) or expressions that must be known at compilation time
     * @params: 
     *   - value: the value to validate
     * @returns: the result value
     * @throws:
     *   - &ErrorMsg: if the validation failed, or the value cannot be known at compilation time
     */
    pub fn validateCteValue (mut self, value : &Expression)-> &Value
        throws &ErrorMsg
    {
        value;
        __pragma!fake_throw (&ErrorMsg);
        __pragma!panic ();
    }    

    /**
     * ================================================================================
     * ================================================================================
     * =========================           GETTERS            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * @returns: the declarator for symbol declaration
     */
    pub fn getDeclarator (mut self)-> dmut &Declarator {
        alias self._declarator
    }
    
    /**
     * @returns: the validator for binary operations
     */
    pub fn getBinOpValidator (mut self)-> dmut &BinaryOpValidator {
        alias self._binOpValidator
    }

    /**
     * @returns: the validator for unary operations
     */
    pub fn getUnOpValidator (mut self)-> dmut &UnaryOpValidator {
        alias self._unOpValidator
    }

    /**
     * @returns: the validator for call operators
     */
    pub fn getCallOpValidator (mut self)-> dmut &CallOpValidator {
        alias self._callOpValidator
    }

    /**
     * @returns: the validator for cast expressions
     */
    pub fn getCastValidator (mut self)-> dmut &CastValidator {
        alias self._castValidator
    }

    /**
     * @returns: the validator for index operators
     */
    pub fn getIndexOpValidator (mut self)-> dmut &IndexOpValidator {
        alias self._indexOpValidator
    }

    /**
     * @returns: the validator for literals
     */
    pub fn getLiteralValidator (mut self)-> dmut &LiteralValidator {
        alias self._literalValidator
    }

    /**
     * @returns: the validator for any kind of values
     */
    pub fn getValueValidator (mut self)-> dmut &ValueValidator {
        alias self._valueValidator
    }

    /**
     * @returns: the validator of sub type access ('::' on type left operand)
     */
    pub fn getSubTypeValidator (mut self)-> dmut &SubTypeValidator {
        alias self._subTypeValidator
    }

    /**
     * @returns: the validator of sub type access ('::' on type left operand)
     */
    pub fn getSubTypeValidator (self)-> &SubTypeValidator {
        self._subTypeValidator
    }

    /**
     * @returns: the validator for akas
     */
    pub fn getAkaValidator (mut self)-> dmut &AkaValidator {
        alias self._akaValidator
    }

    /**
     * @returns: the validator for classes
     */
    pub fn getClassValidator (mut self)-> dmut &ClassValidator {
        alias self._classValidator
    }
    
    /**
     * @returns: the validator for functions
     */
    pub fn getFunctionValidator (mut self)-> dmut &FunctionValidator {
        alias self._functionValidator
    }

    /**
     * @returns: the validator for modules
     */
    pub fn getModuleValidator (mut self)-> dmut &ModuleValidator {
        alias self._moduleValidator
    }

    /**
     * @returns: the validator for struct
     */
    pub fn getStructValidator (mut self)-> dmut &StructValidator {
        alias self._structValidator
    }

    /**
     * @returns: the validator for templates
     */
    pub fn getTemplateSolver (mut self)-> dmut &TemplateSolver {
        alias self._templateSolver
    }

    /**
     * @returns: the declarator for templates 
     */
    pub fn getTemplateDeclarator (mut self)-> dmut &TemplateDeclarator {
        alias self._templateDeclarator
    }
    
    /**
     * @returns: the validator for traits
     */
    pub fn getTraitValidator (mut self)-> dmut &TraitValidator {
        alias self._traitValidator
    }

    /**
     * @returns: the validator for enums
     */
    pub fn getEnumValidator (mut self)-> dmut &EnumValidator {
        alias self._enumValidator
    }
    
    /**
     * @returns: the validator for lambdas
     */
    pub fn getLambdaValidator (mut self)-> dmut &LambdaValidator {
        alias self._lambdaValidator
    }

    /**
     * @returns: the validator for pragmas
     */
    pub fn getPragmaValidator (mut self)-> dmut &PragmaValidator {
        alias self._pragmaValidator
    }

    /**
     * @returns: the validator for 'sizeof's
     * */
    pub fn getSizeofValidator (mut self)-> dmut &SizeofValidator {
        alias self._sizeofValidator
    }

    /**
     * @returns: the validator used to validate copy/dcopy
     * */
    pub fn getCopyValidator (mut self)-> dmut &CopyOpValidator {
        alias self._copyValidator
    }

    /**
     * @returns: the interpreter that can compute cte values
     */
    pub fn getCompileTimeInterpreter (mut self)-> dmut &CompileTimeInterpreter {
        alias self._compileTimeInterpreter
    }

    /**
     * @returns: the interpreter that can compute cte values
     * */
    pub fn getCompileTimeInterpreter (self)-> &CompileTimeInterpreter {
        self._compileTimeInterpreter
    }

    /**
     * @returns: the for loop validator
     */
    pub fn getForLoopValidator (mut self)-> dmut &ForLoopValidator {
        alias self._forLoopValidator
    }

    /**
     * @returns: the matcher expression validator
     */
    pub fn getMatcherValidator (mut self)-> dmut &MatcherValidator {
        alias self._matcherValidator
    }
    
    /**
     * ================================================================================
     * ================================================================================
     * =========================           CONTEXT            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Push a new referent 
     * @params: 
     *   - sym: the symbol that will be used for future symbol access
     */
    pub fn pushReferent (mut self, dmut sym : &Symbol) {
        self._referent:.push (alias sym);
    }

    /**
     * Exit the current referent
     */
    pub fn popReferent (mut self) {
        self._referent:.pop (1u64);
    }


    /**
     * @returns: the current referent
     * @info: empty if not in a symbol context
     */
    pub fn getReferent (mut self)-> dmut &Symbol {
        if (self._referent.len () == 0us) { return EmptySymbol::new (); }
        else {
            return alias (alias self._referent)[self._referent.len () - 1us];
        }
    }

    /**
     * @returns: the current referent
     * @info: empty if not in a symbol context
     * */
    pub fn getReferent (self)-> &Symbol {
        if (self._referent.len () == 0us) return EmptySymbol::new ();
        else {
            return self._referent [$ - 1us];
        }
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================       LOCAL VARIABLES        =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Enter a new foreign scope space
     * @params: 
     *   - isLambda: true iif the foreign that will be validated is lambda function (closure or not)
     *   - isFnBody: true iif the foreign we just entered is for validating a function body
     *   - clContext: type of the class whose symbol is being validated (applicable for symbol defined inside classes, e.g. methods, ctors)
     */
    pub fn enterForeign (mut self, isLambda : bool = false, isFnBody : bool, clContext : &Type = NONE_TYPE) {
        self._symbols:.push (Vec!{dmut &HashMap!{[c8], &Value}}::new ());
        self._usedSyms:.push (Vec!{dmut &HashSet!{[c8]}}::new ());
        self._functionReturns:.push (NoneType::new (loc-> EOF_WORD));
        self._inLambda:.push (isLambda);
        self._inFunctionBody:.push (isFnBody);
        self._inUnsafeContext:.push (EOF_WORD);
        self._inUnsafeContextUsed:.push (EOF_WORD);
        self._loopBreakTypes:.push (Vec!{&Type}::new ());
        self._fieldConstructionTypes:.push (NONE_TYPE);
        self._fieldConstructionValidated:.push (HashSet!{[c8]}::new ());
        self._classContext:.push (clContext);
        self._dollarContext:.push (Vec!{&Value}::new ());
        self._copyContext:.push (Vec!{&Expression}::new ());
    }

    /**
     * Exit a foreign scope space
     */
    pub fn exitForeign (mut self) {
        self._symbols:.pop (1u64);
        self._usedSyms:.pop (1u64);
        self._functionReturns:.pop (1u64);
        self._loopBreakTypes:.pop (1u64);
        self._inLambda:.pop (1u64);
        self._inFunctionBody:.pop (1u64);
        self._inUnsafeContext:.pop (1u64);
        self._inUnsafeContextUsed:.pop (1u64);
        self._fieldConstructionValidated:.pop (1u64);
        self._fieldConstructionTypes:.pop (1u64);
        self._classContext:.pop (1u64);
        self._dollarContext:.pop (1u64);
        self._copyContext:.pop (1u64);
    }
    
    /**
     * After entering a foreign with isFnBody-> false, we can change the context with this function 
     * This allows to avoid exiting foreign, and reentering it just after
     * @info: this does not have to be exited
     * @example: 
     * ==================
     * enterForeign (isFnBody-> false); // <-    
     * // Validate prototype                | 
     * enterFunctionBody (); //             |
     * // Validate function body            |
     * exitForeign (); // ------------------+
     * ==================
     */
    pub fn enterFunctionBody (mut self) {
        __pragma!trusted ({
            (alias self._inFunctionBody) [self._inFunctionBody.len () - 1us] = true;
        });
    }

    /**
     * Enter an unsafe context (either an unsafe keyword, or the whole function body)
     * */
    pub fn enterUnsafeContext (mut self, loc : &Word) {
        __pragma!trusted ({
            (alias self._inUnsafeContext) [self._inUnsafeContext.len () - 1us] = loc;
        });
    }

    /**
     * Exit an unsafe context (either an unsafe keyword, or the whole function body)
     * */
    pub fn exitUnsafeContext (mut self)
        throws &ErrorMsg
    {
        let unsafeLoc = self._inUnsafeContext[][$ - 1us];
        let unsafeUsed = self._inUnsafeContextUsed [][$ - 1us];

        __pragma!trusted ({
            (alias self._inUnsafeContext) [self._inUnsafeContext.len () - 1us] = EOF_WORD;
            (alias self._inUnsafeContextUsed) [self._inUnsafeContextUsed.len () - 1us] = EOF_WORD;
        });

        if (!unsafeLoc.isEof () && unsafeUsed.isEof ()) {
            throw ErrorMsg::fatal (unsafeLoc, ValidateErrorMessage::NOT_UNSAFE);
        }
    }

    /**
     * @returns: the location of the unsafe block if any, EOF_WORD otherwise
     * */
    pub fn getUnsafeContextLoc (self)-> &Word {
        __pragma!trusted ({
            self._inUnsafeContext [self._inUnsafeContext.len () - 1us]
        })
    }

    /**
     * @returns: true iif the context is currently in validation of a function body (or lambda)
     */
    pub fn isInFunctionBody (self)-> bool {
        __pragma!trusted ({
            if (self._inFunctionBody.len () != 0us) {
                self._inFunctionBody [self._inFunctionBody.len () - 1us]
            } else {
                false
            }
        })
    }

    /**
     * @returns: true iif the context is currently in validation of a lambda body
     */
    pub fn isInLambdaBody (self)-> bool {
        __pragma!trusted ({
            if (self._inLambda.len () != 0us) {
                self._inLambda [self._inLambda.len () - 1us]
            } else {
                false
            }
        })
    }
    
    /**
     * @returns: the index of the foreign that would be enclosed if a lambda closure was created in current context
     */
    pub fn getCurrentClosingIndex (self)-> usize {
        self._symbols.len () - 1us
    }

    /**
     * @returns: the class being validated (might be NONE_TYPE)
     */
    pub fn getCurrentClassContext (self)-> &Type {
        if (self._classContext.len () == 0us) return NONE_TYPE;
        __pragma!trusted ({
            self._classContext [self._classContext.len () - 1us]
        })
    }

    /**
     * @params: 
     *    - clRef: the type whose element we want to access
     * @returns: 
     *    - .0: true if the current context allows to access the private elements of clRef type
     *    - .1: true if the current context allows to access the protected elements of clRef type
     */
    pub fn getCurrentClassContextProtections (self, clRef : &ClassRefType)-> (bool, bool) {
        let mut current = self.getCurrentClassContext (); 
        match current {
            cl : &ClassRefType => {
                if (cl == clRef) return (true, true); // We are in the class definition (a method, a ctor, etc.)
                
                current = cl.getAncestor (); // Maybe we are in the class definition of a child class
                loop { 
                    match current {
                        anc : &ClassRefType => {
                            if (anc == clRef) return (false, true); // This is a child class, so we have access to protected content
                            current = anc.getAncestor ();
                        }
                        _ => { return (false, false); } // No, this is not a child class, we are outside
                    }                
                }                
            }
        }

        (false, false)
    }
    
    /**
     * Enter a closure, that can enclose variable from the parent function
     * @params: 
     *   - refId: the uniq id of the declaration of the enclosing variable in the parent function
     *   - closureIndex: the index of the closure (index of the foreign to enclose)
     */
    pub fn enterClosure (mut self, loc : &Word, refId : usize, closureIndex : usize) {
        (alias (alias self._symbols)[self._symbols.len () - 1us])[0us]:.insert ("#{CLOSURE-VARREF}"s8, VarRefValue::new (Word::new ("#{CLOSURE-VARREF}"s8, loc), EOF_WORD, VoidType::new (EOF_WORD), refId));
        (alias (alias self._usedSyms)[self._usedSyms.len () - 1us])[0us]:.insert ("#{CLOSURE-VARREF}"s8);
        
        self._closureType:.push (ClosureType::new (EOF_WORD, [], [], [], refId, (alias self._symbols)[closureIndex], alias (alias self._usedSyms)[closureIndex]));
    }

    /**
     * Exit the current closure validation
     * @returns: the closure type
     */
    pub fn exitClosure (mut self) -> &Type {
        let type = self._closureType[self._closureType.len () - 1us];
        
        self._closureType:.pop ();
        
        type
    } catch {
        _ => __pragma!panic ();
    }
    
    /**
     * Set the type of the current function
     */
    pub fn setFunctionReturn (mut self, type : &Type) {
        (alias self._functionReturns)[self._functionReturns.len () - 1us] = type;        
    }

    /**
     * @returns: the current function return type
     */
    pub fn getFunctionReturn (self)-> &Type {
        self._functionReturns[][$ - 1us]
    }

    /**
     * Enter a dollar context (opDollar is available on 'value')
     * @params:
     *    - value: the value being indexed
     */
    pub fn enterDollar (mut self, value : &Value) {
        ((alias self._dollarContext)[self._dollarContext.len () - 1us]):.push (value);
    }

    /**
     * Quit a dollar context (opDollar is no longer usable on the last dollar context entered)
     */
    pub fn exitDollar (mut self) {
        ((alias self._dollarContext)[self._dollarContext.len () - 1us]):.pop (1u64);
    }

    /**
     * Enter a copy context, where inner expression are affected by the copy
     * @params:
     *    - cp: the expression performing the copy
     * */
    pub fn enterCopy (mut self, cp : &Expression) {
        ((alias self._copyContext)[self._copyContext.len () - 1us]):.push (cp);
    }

    /**
     * Exit the current copy context
     * */
    pub fn exitCopy (mut self) {
        ((alias self._copyContext)[self._copyContext.len () - 1us]):.pop (1u64);
    }

    /**
     * @returns: the value being indexed that can be used for opDollar
     */
    pub fn getCurrentDollarContext (self)-> (&Value)? {
        let v = self._dollarContext [self._dollarContext.len () - 1us];
        match v.len () {
            0us => { ((&Value)?)::__err__ }
            _ => {
                (v [$ - 1us])?
            }
        }
    }

    /**
     * Enter a new scope
     */
    pub fn enterBlock (mut self) {
        (alias self._symbols)[][$ - 1us]:.push (HashMap!{[c8], &Value}::new ());
        (alias self._usedSyms)[][$ - 1us]:.push (HashSet!{[c8]}::new ());
    }

    /**
     * Exit a scope
     */
    pub fn safeQuitBlock (mut self) {
        (alias self._symbols)[][$ - 1us]:.pop (1u64);
        (alias self._usedSyms)[][$ - 1us]:.pop (1u64);
    }
    
    /**
     * Exit a scope
     * @throws: 
     *   - &ErrorMsg: if a symbol was declared but unused and warnUnused
     */
    pub fn quitBlock (mut self, warnUnused : bool = true)
        throws &ErrorMsg
    {
        let dmut errors = Vec!{&ErrorMsg}::new ();
        if (warnUnused) {
            for name, g in self._symbols[][$ - 1us][][$ - 1us] {
                if (name != Keys::SELF) { // SELF does not need to be used
                    if (name !in self._usedSyms[][$ - 1us][][$ - 1us]) {
                        errors:.push (ErrorMsg::warn (g.getLoc (), format (ValidateErrorMessage::DECLARED_NOT_USED, name)));
                    }
                }
            }
        }
        
        (alias self._symbols)[][$ - 1us]:.pop (1u64);
        (alias self._usedSyms)[][$ - 1us]:.pop (1u64);

        if errors.len () != 0us {
            throw ErrorMsg::list (errors[]);
        }
    }

    /**
     * Enter a new loop
     * @params: 
     *    - type: the type of the breaks
     */
    pub fn enterLoop (mut self, type : &Type = NoneType::new (EOF_WORD)) {
        __pragma!trusted ({
            (alias self._loopBreakTypes)[self._loopBreakTypes.len () - 1us]:.push (type);
        });
    }

    /**
     * Set the type of the break types
     * @params: 
     *    - type: the type to set for the breaks
     */
    pub fn setCurrentLoopType (mut self, type : &Type) {
        __pragma!trusted ({
            let dmut v = alias (alias self._loopBreakTypes)[self._loopBreakTypes.len () - 1us];
            (alias v)[v.len () - 1us] = type;
        });
    }

    /**
     * @returns: the type of the current loop breaks
     */
    pub fn getCurrentLoopType (self)-> &Type {
        self._loopBreakTypes[][$ - 1us][][$ - 1us]
    }

    /**
     * Quit the loop scope
     * @returns: the type of the breaks inside the closing loop
     */
    pub fn quitLoop (mut self)-> &Type {
        let ret = self._loopBreakTypes[][$ - 1us][][$ - 1us];
        __pragma!trusted ({(alias self._loopBreakTypes)[][$ - 1us]:.pop ();});
        ret
    }

    /**
     * @returns: true if the context is actually validating a loop in the current validated function scope
     */
    pub fn isInLoop (self)-> bool {
        self._loopBreakTypes[][$ - 1us].len () != 0us
    }

    /**
     * Enter the validation of a pre constructor during field validation
     * @params: 
     *    - type: the type whose field are being validated
     */
    pub fn enterFieldConstruction (mut self, type : &ClassRefType) {
        __pragma!trusted ({
            (alias self._fieldConstructionTypes)[self._fieldConstructionTypes.len () - 1us] = type;
            __version DEBUG {
                // we didn't enter a new foreign apparently
                assert (self._fieldConstructionValidated[self._fieldConstructionValidated.len () - 1us].len () == 0us);
            }
        })
    }

    /**
     * @returns: the list of fields that have been validated during pre validation
     */
    pub fn getFieldValidated (self)-> &HashSet!{[c8]} {
        __pragma!trusted ({
            self._fieldConstructionValidated[self._fieldConstructionValidated.len () - 1us]
        })
    }

    /**
     * Insert a field inside the list of validated field
     * @params: 
     *   - field: the name of the field that have been validated and then is usable
     */
    pub fn setFieldValidated (mut self, field : [c8]) {
        __pragma!trusted ({
            (alias self._fieldConstructionValidated)[self._fieldConstructionValidated.len () - 1us]:.insert (field);
        })
    }

    /**
     * @returns: true iif we are currently validating the fields in a pre construction of a ctor of a class
     */
    pub fn isInFieldConstruction (self)-> bool {
        if (self._fieldConstructionTypes.len () == 0us) return false;
        __pragma!trusted ({
            match self._fieldConstructionTypes[self._fieldConstructionTypes.len () - 1us] {
                NoneType () => { false }
                _ => { true }
            }
        })
    }

    /**
     * @returns: the type whose fields are being constructed (might be NONE_TYPE)
     */
    pub fn getFieldConstructionType (self)-> &Type {
        if (self._fieldConstructionTypes.len () == 0us) return NONE_TYPE;
        __pragma!trusted ({
            self._fieldConstructionTypes[self._fieldConstructionTypes.len () - 1us]            
        })
    }
    
    /**
     * Quit the pre validation of fields 
     */
    pub fn quitFieldConstruction (mut self) {
        __pragma!trusted ({
            (alias self._fieldConstructionValidated)[self._fieldConstructionValidated.len () - 1us]:.clear ();
            (alias self._fieldConstructionTypes)[self._fieldConstructionTypes.len () - 1us] = NONE_TYPE;
        });
    }
    
    /**
     * Insert a new variable in the current block
     * @params: 
     *    - name: the name of the variable
     *    - val: the declaration of the variable
     */
    pub fn insertLocal (mut self, name : [c8], val : &Value) {
        (alias ((alias self._symbols)[][$ - 1us]))[][$ - 1us]:.insert (name, val);
    }

    /**
     * Clear the current scope
     */
    pub fn clearLocalScope (mut self) {
        (alias ((alias self._symbols)[][$ - 1us]))[][$ - 1us]:.clear ();
    }

    /**
     * Search the definition of a local variable
     * @params: 
     *   - name: the name of the variable to search
     *   - canBeInClosure: if the variable can be a variable from the parent of a closure
     * @returns: the generator of the variable or UnitValue
     */
    pub fn getLocal (mut self, loc : &Word, name : [c8], canBeInClosure : bool = true)-> &Value
        throws &ErrorMsg
    {
        if (self._symbols.len () != 0us) {
            for i in 0us .. self._symbols [][$ - 1us].len () {
                let ptr = self._symbols[][$ - 1us][][i].find (name);
                match ptr {
                    Ok (g : &Value) => {
                        (alias ((alias self._usedSyms)[][$ - 1us])[][i]):.insert (name);
                        return g;
                    }
                }
            }

            if (canBeInClosure) {
                return self:.getInClosure (loc, name);
            }
        }

        UNIT_VALUE
    }

    /**
     * Search the definition of a local variable 
     * @warning: use only for shadowing verification, it does not update used variable infos
     * @params: 
     *   - name: the name of the variable to search
     *   - canBeInClosure: if the variable can be a variable from the parent of a closure
     * @returns: the generator of the variable or UnitValue
     */
    fn getLocalNoUse (self, name : [c8])-> &Value {
        if (self._symbols.len () != 0us) {
            for i in 0us .. self._symbols [][$ - 1us].len () {
                let ptr = self._symbols[][$ - 1us][][i].find (name);
                match ptr {
                    Ok (g : _) => {
                        return g;
                    }
                }
            }
        }

        UNIT_VALUE
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================        GLOBAL SYMBOLS        =========================
     * ================================================================================
     * ================================================================================
     */


    /**
     * Search all the global symbols whose name are name
     * @params: 
     *   - name: the name of the symbols to get
     * @returns: the list of symbols whose name are name, and are accessible from the current context
     */
    pub fn getGlobal (mut self, name : [c8])-> dmut [&Symbol] {
        if (self._referent.len () == 0us) return [];
        let dmut res = (alias self._referent) [self._referent.len () - 1us]:.getSymbols (name);
        return (alias res)[];
    }

    /**
     * Search all the global symbols whose name are close to `name`, with a distance of `distance`
     * @params:
     *   - name: the name of the symbols to get
     *   - distance: the distance of the name of the symbol to `name`
     * @returns: the list of symbols whose name are close to `name` (only public ones)
     */
    pub fn getCloseGlobal (self, name : [c8], distance : usize = 2us)-> [&Symbol] {
        if (name.len <= distance + 1us) return [];
        if (self._referent.len () == 0us) return [];
        let res = ( self._referent) [self._referent.len () - 1us].getCloseSymbols (name, distance);
        return res[];
    }

    /**
     * Search all the global symbols whose name are name
     * @params:
     *   - name: the name of the symbols to get
     * @returns: the list of symbols whose name are name, even if they are not accessible from the current context (protection)
     */
    pub fn getGlobalPrivate (mut self, name : [c8])-> dmut [&Symbol] {
        if (self._referent.len () == 0us) return [];
        let dmut res = (alias self._referent) [self._referent.len () - 1us]:.getSymbols (name, protection-> Protection::PRIVATE);
        return (alias res)[];
    }

    /**
     * Search all the local symbols whose name are name in the module mref
     * @params:
     *    - mref: the module in which the search is made
     *    - name: the name of the symbols to get
     * @returns: the list of found symbols
     * */
    pub fn getLocalFromMod (mut self, mref : &ModuleRefValue, name : [c8])-> dmut [&Symbol] {
        return self._declarator:.getLocalFromContext (name, self.getReferent (), mref.getSymbol ());
    }

    /**
     * Search all the local symbols whose name are name in the module mref with private protection
     * @params:
     *    - mref: the module in which the search is made
     *    - name: the name of the symbols to get
     * @returns: the list of found symbols even if they are not accessible from the current context
     * */
    pub fn getLocalFromModPrivate (mut self, mref : &ModuleRefValue, name : [c8])-> dmut [&Symbol] {
        return self._declarator:.getLocalFromContext (name, self.getReferent (), mref.getSymbol (), protection-> Protection::PRIVATE);
    }

    /**
     * Search all the local symbols whose name are close to name
     * @params:
     *    - mref: the module in which the search is made
     *    - name: the name of the symbols to get
     * @returns: the list of found symbols
     * */
    pub fn getCloseLocalFromMod (self, mref : &ModuleRefValue, name : [c8], distance : usize = 2us)-> [&Symbol] {
        return self._declarator.getCloseLocalFromContext (name, distance-> distance, self.getReferent (), mref.getSymbol ());
    }

    /**
     * @returns: the mutable version of the module registered in the module ref
     * @panic: if the module ref points to an invalid module
     */
    pub fn getModuleFromRef (mut self, module : &ModuleRefValue)-> dmut &Symbol {
        alias self._declarator:.getMutableSymbol (module.getSymbol ())
    }

    /**
     * @returns: the mutable version of the symbol 
     * @panic: if the symbol is invalid, and was not declared by the current context
     */
    pub fn getClassFromRef (mut self, sym : &ClassSymbol)-> dmut &Symbol {
        alias self._declarator:.getMutableSymbol (sym)
    }

    /**
     * @returns: the mutable version of the symbol 
     * @panic: if the symbol is invalid, and was not declared by the current context
     */
    pub fn getSymbolFromRef (mut self, sym : &Symbol)-> dmut &Symbol {
        alias self._declarator:.getMutableSymbol (sym)
    }

    /**
     * Insert a generator for post validation
     * @params:
     *    - sym: the symbol responsible of the generation
     *    - gen: the generator created
     * */
    pub fn insertGenerator (mut self, dmut sym : &Symbol, gen : &Generator) {
        self._generators:.push (gen);
        sym:.insertGenerator (gen);
    }

    /**
     * @returns: the list of generators created during validation
     * */
    pub fn getGenerators (self)-> [&Generator] {
        self._generators[]
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================          INFERENCE           =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Infer the type from two branch that must lead to a common type 
     * @info: by setting none to oldType, only the type of val will be used
     * @params: 
     *   - loc: the location of the branching
     *   - oldType: the type of the other branch
     *   - val: the value of the current branch
     * @returns: the type that is common to oldType and val.getType (), without explicit cast needed
     * @throws:
     *   - &ErrorMsg: if there is no common type possible
     */
    pub fn inferTypeBranchingWithValue (mut self, loc : &Word, oldType : &Type, val : &Value)-> (&Type, &Value)
        throws &ErrorMsg
    {
        let v = {
            self:.verifyCompatibleTypeWithValue (loc, oldType, val)
        } catch {
            _ => { val }
        };

        let ret = self.inferTypeBranching (loc, val.getLoc (), oldType, v.getType ());
        {
            // Trying to implicit alias the type
            let value = self:.verifyCompatibleTypeWithValue (loc, ret, v);
            self.verifyMemoryOwner (loc, ret, value, byReference-> false);
            (ret, value)
        } catch {
            _ => {  // if it didn't succeed, then return an imutable version of the type
                (ret.clone (0u32), v)
            }
        }
    }

    /**
     * Infer the type from two branch that must lead to a common type 
     * @info: by setting none to oldType, only the type of val will be used
     * @params: 
     *   - lloc: the location of the left branch
     *   - rloc: the location of the right branch
     *   - left: the type of the left branch
     *   - right: the type of the right branch
     * @returns: the type that is common to oldType and val.getType (), without explicit cast needed
     * @throws:
     *   - &ErrorMsg: if there is no common type possible
     */
    fn inferTypeBranching (self, lloc : &Word, rloc : &Word, left : &Type, right : &Type)-> &Type
        throws &ErrorMsg
    {
        if (left.isOf!{&NoneType} ()) return right;
        
        if (left == right) {
            if (left.mutabilityLevel () < right.mutabilityLevel ()) return left;
            else return right;
        }
        
        match (left, right) {
            (slc : &SliceType, rslc : &SliceType) => {
                return self.inferTypeBranchingSlices (lloc, rloc, slc, rslc);
            }
            (lp : &ClassPtrType, rp : &ClassPtrType) => {
                return self.inferTypeBranchingClass (lloc, rloc, lp, rp);
            }
            (ltp : &TupleType, rtp : &TupleType) => {
                return self.inferTypeBranchingTuple (lloc, rloc, ltp, rtp);
            }            
        }

        throw ErrorMsg::fatal (lloc, end-> rloc, format (ValidateErrorMessage::INCOMPATIBLE_TYPE, left, right));
    }

    /**
     * Infer the type from two branch that must lead to a common type , where left and right types are slice types but not equal
     * @params: 
     *   - lloc: the location of the left branch
     *   - rloc: the location of the right branch
     *   - left: the type of the left branch
     *   - right: the type of the right branch
     * @returns: the type that is common to oldType and val.getType (), without explicit cast needed
     * @throws:
     *   - &ErrorMsg: if there is no common type possible
     */
    fn inferTypeBranchingSlices (self, lloc : &Word, rloc : &Word, left : &SliceType, right : &SliceType)-> &Type
        throws &ErrorMsg
    {
        if (left.getInners ()[0].isOf!{&VoidType} ()) return right;
        if (right.getInners ()[0].isOf!{&VoidType} ()) return left;
        
        let inner = {
            self.inferTypeBranching (lloc, rloc, left.getInners ()[0], right.getInners ()[0])
        } catch {
            ErrorMsg () => {
                throw ErrorMsg::fatal (lloc, end-> rloc, format (ValidateErrorMessage::INCOMPATIBLE_TYPE, left, right));
            }
        }
        
        SliceType::new (lloc, inner, isMutable-> left.isMutable () && right.isMutable ())
    }

    /**
     * Infer the type from two branch that must lead to a common type , where left and right types are class ptr types but not equal
     * @params: 
     *   - lloc: the location of the left branch
     *   - rloc: the location of the right branch
     *   - left: the type of the left branch
     *   - right: the type of the right branch
     * @returns: the type that is common to oldType and val.getType (), without explicit cast needed
     * @throws:
     *   - &ErrorMsg: if there is no common type possible
     */
    fn inferTypeBranchingClass (self, lloc : &Word, rloc : &Word, left : &ClassPtrType, right : &ClassPtrType)-> &Type
        throws &ErrorMsg
    {
        if (self.isAncestor (left, right)) return left.clone (mutLevel-> min (left.mutabilityLevel (), right.mutabilityLevel ()));
        if (self.isAncestor (right, left)) return right.clone (mutLevel-> min (left.mutabilityLevel (), right.mutabilityLevel ()));

        match self.getCommonAncestor (lloc, left, right) {
            c : &ClassPtrType => return c.clone (mutLevel-> min (left.mutabilityLevel (), right.mutabilityLevel ()));
            _ => {
                throw ErrorMsg::fatal (lloc, end-> rloc, format (ValidateErrorMessage::INCOMPATIBLE_TYPE, left, right));
            }
        }        
    }

    /**    
     * Infer the type from two branch that must lead to a common type , where left and right types are tuple types but not equal
     * @params: 
     *   - lloc: the location of the left branch
     *   - rloc: the location of the right branch
     *   - left: the type of the left branch
     *   - right: the type of the right branch
     * @returns: the type that is common to oldType and val.getType (), without explicit cast needed
     * @throws:
     *   - &ErrorMsg: if there is no common type possible
     */
    fn inferTypeBranchingTuple (self, lloc : &Word, rloc : &Word, left : &TupleType, right : &TupleType)-> &Type
        throws &ErrorMsg
    {
        if (left.getInners ().len != right.getInners ().len ) {
            throw ErrorMsg::fatal (lloc, end-> rloc, format (ValidateErrorMessage::INCOMPATIBLE_TYPE, left, right));   
        }

        let dmut inners = Vec!{&Type}::new ();
        {
            for i in 0us .. left.getInners ().len {
                inners:.push (self.inferTypeBranching (lloc, rloc, left.getInners ()[i], right.getInners ()[i]));
            }
        } catch {
            ErrorMsg () => {
                throw ErrorMsg::fatal (lloc, end-> rloc, format (ValidateErrorMessage::INCOMPATIBLE_TYPE, left, right));
            }
        }
                
        TupleType::new (lloc, inners[], isMutable-> left.isMutable () && right.isMutable ())
    }
        
    /**
     * Infer a lambda value from a function or delegate type
     * @params: 
     *   - type: the type that will help for the inference
     *   - val: the value in which the search is performed
     * @returns: a lambda value
     * @throws: 
     *   - &ErrorMsg: if is was not found, or the inference is impossible 
     */
    pub fn inferLambdaValue (mut self, type : &Type, val : &Value)-> &Value
        throws &ErrorMsg
    {
        let innerVal = match val {
            v : &VarRefValue => { v.getValue () } // The lambda value can be hidden in a variable
            _ => { val }
        };
        
        match innerVal {            
            lmbd : &LambdaValue => {
                let paramTypes = match type {
                    f : &FuncPtrType => { f.getParameters () }
                    d : &DelegateType => { d.getParameters () }
                    _ => { throw ErrorMsg::fatal (val.getLoc (), format (ValidateErrorMessage::INCOMPATIBLE_TYPE, type, val.getType ())); } // The lambda value was found, but the result cannot be infered
                }
                
                if (lmbd.getParameters ().len != paramTypes.len) {
                    throw ErrorMsg::fatal (val.getLoc (), format (ValidateErrorMessage::INCOMPATIBLE_TYPE, type, val.getType ()));         
                }
                
                let (proto, frame) = self._lambdaValidator:.validateLambdaBody (alias self, lmbd, paramTypes); // Validate the lambda from the parameters of  'type'
                self._lambdaValidator:.insertGenerator (alias self, frame);
                return proto;
            }
            _ => { // The lambda value was not found
                throw ErrorMsg::fatal (val.getLoc (), format (ValidateErrorMessage::INCOMPATIBLE_TYPE, type, val.getType ()));
            }
        };
    }
    
    /**
     * ================================================================================
     * ================================================================================
     * =========================         VERIFICATION         =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Verify if the current context is not explicitely unsafe, in which case an error is thrown
     * */
    pub fn verifyUnsafeContext (mut self, loc : &Word, msg : [c8] = ValidateErrorMessage::UNSAFE_OPERATION)
        throws &ErrorMsg
    {
        if (self._inUnsafeContext [][$ - 1us].isEof ()) {
            throw ErrorMsg::fatal (loc, msg);
        } else {
            __pragma!trusted ({
                (alias self._inUnsafeContextUsed) [self._inUnsafeContextUsed.len () - 1us] = loc;
            });
        }
    }

    /**
     * Verify that the variable is not shadowing another variable
     * And that the variable name is a valid variable identifier (not a native type)
     * @params: 
     *    - loc: the location and name of the variable that may shadow
     * @throws: &ErrorMsg, if the variable shadows another local declaration, or the variable name is a type name
     */
    pub fn verifyShadow (self, loc : &Word)
        throws &ErrorMsg
    {
        self.verifyNotIsNativeType (loc);
        match self.getLocalNoUse (loc.str ()) {
            UnitValue () => {}
            gen : _ => {
                throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::SHADOWING_DECL, loc.str ()),
                                       notes-> [ErrorMsg::note (gen.getLoc (), ValidateErrorMessage::FIRST_DEFINED)]
                                       );
            }
        }
    }

    /**
     * Verify that the name of the variable is not a native type
     * @params: 
     *   - loc: the location and name of the variable
     * @throws: &ErrorMsg, iif the name of the variable is a native type
     */
    pub fn verifyNotIsNativeType (self, loc : &Word)
        throws &ErrorMsg
    {
        if loc.str () in self._nativeTypeNames {
            throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::IS_NATIVE_TYPE, loc.str ()));
        }
    }

    /**
     * Verify that the value `value` can be casted into the type `type` implicitely
     * @warning: this does not check implicit aliases and references (cf. self.verifyMemoryOwner)
     * @params: 
     *   - loc: the location of the affectation    
     *   - type: the type into which the cast is made
     *   - value: the value used
     * @returns: the value 'value' (casted if needed)
     * @throws: &ErrorMsg: if the cast cannot be made
     */
    pub fn verifyCompatibleTypeWithValue (mut self, loc : &Word, type : &Type, value : &Value)-> &Value
        throws &ErrorMsg
    {
        match (type, value) {
            (_ : &PointerType, n : &NullValue) => return n; // ptr = null;
            (i : &IntType, v : &Value) => {
                return self.verifyCompatibleTypeIntValue (loc, i, v);
            }
            (f : &FloatType, v : &Value) => {
                return self.verifyCompatibleTypeFloatValue (loc, f, v);
            }
            (c : &CharType, v : &Value) => {
                return self.verifyCompatibleTypeCharValue (loc, c, v);
            }
            (a : &ArrayType, av : &ArrayValue) => {
                return self:.verifyCompatibleTypeArrayValue (loc, a, av);
            }
            (s : &SliceType, _) => {
                return self.verifyCompatibleTypeSliceValue (loc, s, value);
            }
            (a : &ArrayType, _) => {
                return self.verifyCompatibleTypeSliceValue (loc, a, value);
            }
            (t : &TupleType, v : &TupleValue) => {
                return self:.verifyCompatibleTypeTupleValue (loc, t, v);
            }
            (fptr : &FuncPtrType, l : &LambdaValue) => {
                return self:.verifyCompatibleTypeLambdaValue (loc, fptr, l);
            }
            (del : &DelegateType, l : &LambdaValue) => {
                return self:.verifyCompatibleTypeLambdaValue (loc, del, l);
            }
        }
        
        self.verifyCompatibleType (loc, value.getLoc (), type, value.getType ());
        value
    }

    /**
     * Verify the compatibility of two types (not complete equals)
     * @params: 
     *   - lLoc: the location of the left type (or left operand, this is the location that will be shown in the error message)
     *   - rLoc: the location of the right type (or right operand, this is the location that will be shown in the error message)
     *   - noAncestor: don't check for ancestor compatibility 
     * @throws: &ErrorMsg: if the type are not compatible
     */
    pub fn verifyCompatibleType (self, lLoc : &Word, rLoc : &Word, left : &Type, right : &Type, noAncestor : bool = false)
        throws &ErrorMsg
    {
        if (!left.isCompatible (right)) {
            let dmut innerErr = Vec!{&ErrorMsg}::new ();
            {
                if (!noAncestor) {
                    if (self.isAncestor (left, right)) return {};
                    if (self.verifyAncestorCompatibleInNativeCompound (left, right)) return {};
                }
            } catch {
                err : &ErrorMsg => {
                    innerErr:.push (err);
                }
            }


            if (lLoc.line () == rLoc.line ()) {
                throw ErrorMsg::fatal (lLoc, end-> rLoc, format (ValidateErrorMessage::INCOMPATIBLE_TYPE, left, right), notes-> innerErr[]);
            } else {
                innerErr:.push (ErrorMsg::note (lLoc, ""s8))
                throw ErrorMsg::fatal (rLoc, format (ValidateErrorMessage::INCOMPATIBLE_TYPE, left, right), notes-> innerErr[]);
            }
        }
    }

    /**
     * Verify that left is compatible with right
     * @info: if left and right are native compound types (array, slice, pointer, tuple...) they might be imcompatble but implicitely castable if they contains objects
     * @params:
     *    - left: the type of the left operand (to which the cast is done)
     *    - right: the type of the right operand (from which the implicit cast is done)
     * @returns: true if the cast is possible (false means this not a native compound type)
     * @throws:
     *    - &ErrorMsg: if the cast is forbidden within the compound native type
     * */
    fn verifyAncestorCompatibleInNativeCompound (self, left : &Type, right : &Type)-> bool
        throws &ErrorMsg
    {
        {
            match (left, right) {
                (lArr : &ArrayType, rArr : &ArrayType) => { // [&A ; 4] <= [&B ; 4] iif B over A
                    if (lArr.getLen () == rArr.getLen ()) {
                        let innerLeft = lArr.getInners ()[0];
                        let innerRight = rArr.getInners ()[0];
                        self.verifyCompatibleType (innerLeft.getLoc (), innerRight.getLoc (), innerLeft, innerRight, noAncestor-> false);

                        return true;
                    }
                }
                (lSlc : &SliceType, rSlc : &SliceType) => { // [&A] <= [&B] iif B over A
                    let innerLeft = lSlc.getInners ()[0];
                    let innerRight = rSlc.getInners ()[0];
                    self.verifyCompatibleType (innerLeft.getLoc (), innerRight.getLoc (), innerLeft, innerRight, noAncestor-> false);

                    return true;
                }
                (lTu : &TupleType, rTu : &TupleType) => {
                    if (lTu.getInners ().len == rTu.getInners ().len) { // (&A,) <= (&B,) iif B over A
                        for i in 0us .. lTu.getInners ().len {
                            let innerLeft = lTu.getInners ()[i];
                            let innerRight = rTu.getInners ()[i];
                            self.verifyCompatibleType (innerLeft.getLoc (), innerRight.getLoc (), innerLeft, innerRight, noAncestor-> false);
                        }
                        return true;
                    }
                }
            }
        }

        return false;
    }


    /**
     * Verify the compatibility of a int type, and a int value
     * @params:
     *     - loc: the location of the operation
     *     - i: the int type as left operand
     *     - v: the value of the right operand
     * @throws: &ErrorMsg: if the types are not compatible
     * */
    fn verifyCompatibleTypeIntValue (self, loc : &Word, i : &IntType, v : &Value)-> &Value
        throws &ErrorMsg
    {
        match self.verifyCompatibleType (loc, v.getLoc (), i, v.getType ())? {
            Ok () => { return v; }
            Err (err : &ErrorMsg) => {
                let sv = self.getCompileTimeInterpreter ().reduce (v);
                match sv {
                    iv : &IntValue => {
                        { // it is a cte int, we might implicit cast it if it does not overflow (ex: 1924 -> u8)
                            self._compileTimeInterpreter.verifyOverFlowInt (iv.getLoc (), i, iv.getValue ()); // but we need to verify overflow
                        } catch {
                            innerErr : &ErrorMsg => {
                                throw err.appendNotes ([innerErr]);
                            }
                        }

                        return IntValue::new (loc, i, iv.getValue ());
                    }
                    _ => throw err;
                }
            }
            _ => __pragma!panic ();
        }
    }

    /**
     * Verify the compatibility of a float type, and a float value
     * @params:
     *    - loc: the location of the operation
     *    - f: the float type of the left operand
     *    - v: the value of the right operand
     * @throws: &ErrorMsg: if the types are not compatible
     * */
    fn verifyCompatibleTypeFloatValue (self, loc : &Word, f : &FloatType, v : &Value)-> &Value
        throws &ErrorMsg
    {
        match self.verifyCompatibleType (loc, v.getLoc (), f, v.getType ())? {
            Ok () => return v;
            Err (err : &ErrorMsg) => {
                let sv = self.getCompileTimeInterpreter ().reduce (v);
                match sv {
                    fv : &FloatValue => { // it is cte, we can automatically transform the value into a value of type 'f'
                        return FloatValue::new (loc, f, fv.getValue ());
                    }
                    _ => throw err; // it is not cte, types must be exactly the same
                }
            }
            _ => __pragma!panic ();
        }
    }

    /**
     * Verify the compatibility of a char type and a value
     * @params:
     *    - loc: the location of the operation
     *    - c: the char type of the left operand
     *    - v: the value of the right operand
     * @throws:
     *    - &ErrorMsg: if the types are not compatible
     * */
    fn verifyCompatibleTypeCharValue (self, loc : &Word, c : &CharType, v : &Value)-> &Value
        throws &ErrorMsg
    {
        match self.verifyCompatibleType (loc, v.getLoc (), c, v.getType ())? {
            Ok () => { return v; }
            Err (err : &ErrorMsg) => {
                let sv = self.getCompileTimeInterpreter ().reduce (v);
                match sv { // incompatible might mean c32 -> c8
                    cv : &CharValue => {
                        { // Cte char value, that may be casted to other char types ('a' -> 'a'c8)
                            self._compileTimeInterpreter.verifyOverFlowChar (cv.getLoc (), c, cv);
                        } catch {
                            innerErr : &ErrorMsg => { // apparently not
                                throw err.appendNotes ([innerErr]);
                            }
                        }

                        match cv.getEncodingSize () {
                            8u16 =>  return makeCharValue (loc, cast!u32 (cv.getValue ().utf8), size-> c.getSize ());
                            16u16 => return makeCharValue (loc, cast!u32 (cv.getValue ().utf16), size-> c.getSize ());
                            _ => return makeCharValue (loc, cv.getValue ().utf32, size-> c.getSize ());
                        }
                    }
                }

                throw err;
            }
            _ => __pragma!panic ();
        }
    }

    /**
     * Verify the compatibility of a tuple type, and a tuple value
     * @params:
     *    - loc: the location of the operation
     *    - t: the tuple type
     *    - v: the tuple value
     * @throws: &ErrorMsg: if the types are not compatible
     * */
    fn verifyCompatibleTypeTupleValue (mut self, loc : &Word, t : &TupleType, v : &TupleValue)-> &Value
        throws &ErrorMsg
    {
        match self.verifyCompatibleType (loc, v.getLoc (), t, v.getType (), noAncestor-> true)? {
            Ok () => { return v; }
            Err (err : &ErrorMsg) => {
                if (v.getArity () != t.getInners ().len) {
                    throw err;
                }

                let dmut params = Vec!{&Value}::new ();
                let dmut types = Vec!{&Type}::new ();
                {
                    for i in 0us .. v.getArity () {
                        let innerv = self:.verifyCompatibleTypeWithValue (v.getInners()[i].getLoc (), t.getInners ()[i], v.getInners ()[i]);
                        params:.push (innerv);
                        types:.push (innerv.getType ());
                    }
                } catch {
                    innerErr : &ErrorMsg => {
                        throw err.withNote ([innerErr]);
                    }
                }

                let type = TupleType::new (v.getLoc (), types[]).clone (pattern-> v.getType ()).asOf!{&TupleType} ();
                return TupleValue::new (v.getLoc (), type, params[]);
            }
            _ => __pragma!panic ();
        }
    }

    /**
     * Try to validate a lambda value from a function pointer type
     * @params:
     *     - loc: the location of the operation
     *     - f: the function pointer type validation
     *     - l: the lambda value to validate
     * @returns: the validated lambda
     * @throws:
     *     - &ErrorMsg: if the types are incompatible
     * */
    fn verifyCompatibleTypeLambdaValue (mut self, loc : &Word, f : &FuncPtrType, lmbd : &LambdaValue)-> &Value
        throws &ErrorMsg
    {
        let (proto, frame) = self._lambdaValidator:.validateLambdaBody (alias self, lmbd, f.getParameters ());
        self.verifyCompatibleType (loc, lmbd.getLoc (), f, proto.getType ());
        self._lambdaValidator:.insertGenerator (alias self, frame);

        return proto;
    }

    /**
     * Try to validate a lambda value from a function pointer type
     * @params:
     *     - loc: the location of the operation
     *     - f: the function pointer type validation
     *     - l: the lambda value to validate
     * @returns: the validated lambda
     * @throws:
     *     - &ErrorMsg: if the types are incompatible
     * */
    fn verifyCompatibleTypeLambdaValue (mut self, loc : &Word, f : &DelegateType, lmbd : &LambdaValue)-> &Value
        throws &ErrorMsg
    {
        let (proto, frame) = self._lambdaValidator:.validateLambdaBody (alias self, lmbd, f.getParameters ());
        self.verifyCompatibleType (loc, lmbd.getLoc (), f, proto.getType ());
        self._lambdaValidator:.insertGenerator (alias self, frame);

        return proto;
    }

    /**
     * Verify the compatibility of a slice type and a value that may be a array value, or a string value
     * @params:
     *    - loc: the location of the operation
     *    - slc: the slice type of the left operand
     *    - value: the right operand
     * @throws: &ErrorMsg, if the types are not compatible
     * */
    fn verifyCompatibleTypeSliceValue (self, loc : &Word, slc : &SliceType, value : &Value)-> &Value
        throws &ErrorMsg
    {
        match self.verifyCompatibleType (loc, value.getLoc (), slc, value.getType ())? {
            Ok () => { return value; }
            Err (err : &ErrorMsg) => {
                let sv = self.getCompileTimeInterpreter ().reduce (value); // simplify, maybe it is more complex than a string lit, but still cte string lit
                match (sv, sv.getType ()) {
                    (str : &StringValue, _ : &SliceType) => {
                        if (slc.getInners ()[0].isOf!{&CharType} ()) {
                            let ch = slc.getInners ()[0].asOf!{&CharType} ();
                            return literal::string::convertStringSliceValue (value.getLoc (), str, resultSize-> ch.getSize ());
                        }
                    }
                    (_ : &SliceCtorValue, sr : &SliceType) => {
                        if sr.getInners ()[0].isOf!{&VoidType} () { // slice = [];
                            return value;
                        }
                    }
                    (_, a : &ArrayType) => {
                        if a.getInners ()[0].isOf!{&VoidType} () { // slice = [];
                            return SliceCtorValue::new (loc, slc, NullValue::new (loc), makeIntValue (loc, 0us))
                        }
                    }
                }

                throw err;
            }
            _ => __pragma!panic ();
        }
    }


    /**
     * Create a slice alias using an array value
     * @warning: this function does not make a copy of the array, thus it assumes that the value will be used to create a copy of some sort
     * @params:
     *     - loc: the location of the operation
     *     - a: the type of the array to alias
     *     - v: the value of the array to alias
     *     - mutable: true if the alias is mutable (if array is not mutable, does not override its real mutability)
     * @returns: a slice ctor values, containing the address of the array as a pointer
     * */
    pub fn createSliceAliasFromArray (self, loc : &Word, a : &ArrayType, v : &Value, mutable : bool = true)-> &Value {
        let inner = if (mutable) {
            a.getInners ()[0]
        } else { a.getInners ()[0].clone (0u32) }
        
        let sliceType = SliceType::new (loc, inner, isMutable-> (inner.isMutable () && mutable));

        if (a.getLen () != 0us) {
            let ptrType = PointerType::new (loc, inner, isMutable-> inner.isMutable ());
            let arrayAddr = AddressValue::new (loc, ptrType, v);
            SliceCtorValue::new (loc, sliceType, arrayAddr, makeIntValue (loc, a.getLen ()))
        } else {
            SliceCtorValue::new (loc, sliceType, NullValue::new (loc), makeIntValue (loc, 0us))
        }
    }

    /**
     * Verify that a slice value can be implicitely casted into an array value
     * This can be the case for string literal for example
     * @params:
     *    - loc: the location of the data movement
     *    - arr: the type to which the cast is done
     *    - slc: the slice value from which the cast is made
     * @returns: an array typed value
     * @throws:
     *    - &ErrorMsg: if the cast is impossible or forbidden implicitely
     * */
    fn verifyCompatibleTypeSliceValue (self, loc : &Word, arr : &ArrayType, slc : &Value)-> &Value
        throws &ErrorMsg
    {
        match self.verifyCompatibleType (loc, slc.getLoc (), arr, slc.getType ())? {
            Ok () => { return slc; } // mmh, does not seem possible ?
            Err (err : &ErrorMsg) => {
                match arr.getInners ()[0] {
                    c : &CharType => {
                        let sv = self.getCompileTimeInterpreter ().reduce (slc); // simplify, maybe it is more complex than a string lit, but still cte string lit
                        if (!sv.isOf!{&StringValue} ()) throw err; // Did not return a string value ?
                        let s = sv.asOf!{&StringValue} ();

                        let result = convertStringArrayValue (loc, s, resultSize-> c.getSize ());
                        if (result.getLen () == arr.getLen ()) return result;
                    }
                }

                throw err
            }
            _ => __pragma!panic ();
        }
    }

    /**
     * Verify that an array literal value can be implicitely casted into an array value
     * This can be the case for array literal containing implicitely castable content (ex: [0] -> [0us])
     * Or for [] being [void ; 0] to any [T ; 0]
     * @params:
     *    - loc: the location of the data movement
     *    - arr: the type to which the cast is done
     *    - value: the array literal value from which the cast is made
     * @returns: an array typed value
     * @throws:
     *    - &ErrorMsg: if the cast is impossible or forbidden implicitely
     * */
    fn verifyCompatibleTypeArrayValue (mut self, loc : &Word, arr : &ArrayType, value : &ArrayValue)-> &Value
        throws &ErrorMsg
    {
        match self.verifyCompatibleType (loc, value.getLoc (), arr, value.getType (), noAncestor-> true)? {
            Ok () => { return value; }
            Err (err : &ErrorMsg) => {
                let typeLen = arr.getLen ();
                let typeInnerType = arr.getInners ()[0];

                let valueInnerType = value.getType ().asOf!{&ArrayType} ().getInners ()[0];
                let valueLen = value.getType ().asOf!{&ArrayType} ().getLen ();

                match (valueLen, valueInnerType, typeLen, typeInnerType) {
                    (0us, VoidType (), 0us, _) => { // [void ; 0] -> [T ; 0]
                        return ArrayValue::new (value.getLoc (), arr, []);
                    }
                    (x : usize, _, y : usize, t2 : &Type) => {
                        if (x == y) { // [T ; N] -> [U ; N]
                            let dmut params = Vec!{&Value}::new ();
                            {
                                for i in 0us .. x {
                                    let innerV = self:.verifyCompatibleTypeWithValue (value.getInners ()[i].getLoc (), t2, value.getInners ()[i]);
                                    params:.push (innerV);
                                }
                            } catch {
                                innerErr : &ErrorMsg =>
                                throw err.withNote ([innerErr]);
                            }

                            return ArrayValue::new (value.getLoc (), arr, params[]);
                        }
                    }
                }

                throw err;
            }
            _ => __pragma!panic ();
        }
    }

    /**
     * @warning: Function that must be called at any affectation or memory movement in the code
     * Verify that the movement of memory is permitted (no implicit alias, no const disqualifier, etc.)
     * @params:
     *   - loc: the location of the affectation
     *   - type: the type of the operation, to which the value is casted
     *   - value: the value that is moved
     *   - construct: true iif this is the construction of a new variable (this is the only time lambda are allowed)
     *   - checkTypes: if false does not call verifyCompatibleTypeWithValue, (this should be disable only if this was done beforehand)
     *   - byReference: if true the left type is a reference
     * @throws:
     *   - ErrorMsg: if the operation is not permitted
     */
    pub fn verifyMemoryOwner (self, loc : &Word, type : &Type, value : &Value, construct : bool = false, byReference : bool)
        throws &ErrorMsg
    {
        self.verifyCompleteTypeWithValue (loc, type, value, construct); // Verify that the type can be used (if it is incomplete it cannot)
        self.verifyImplicitAlias (loc, type, value, byReference-> byReference); // Verify that the movement is not made implicitely
        self.verifyImplicitPure (loc, type, value); // verify that there is no pure movement

        match type {
            LambdaType () => { // lambda type cannot be changed, they are not really values
                if (!construct || !value.isOf!{&LambdaValue} ()) throw ErrorMsg::fatal (value.getLoc (), ValidateErrorMessage::USE_AS_VALUE, notes-> [ErrorMsg::note (loc, ""s8)]);
                
                self.verifyMutabilityLevel (loc, value.getLoc (), type, value.getType (), byReference);
            }
            PointerType () => { // If we put null in a pointer it is necessarily a lesser level, but that is authorized
                let llevel = type.mutabilityLevel ();
                let rlevel = value.getType ().mutabilityLevel ();
                if (llevel > max (1u32, rlevel) && !value.isOf!{&NullValue} ()) {
                    self.verifyMutabilityLevel (loc, value.getLoc (), type, value.getType (), byReference);
                }
            }
            _ => { // all the other types must be checked in a deeper analyses
                self.verifyMutabilityLevel (loc, value.getLoc (), type, value.getType (), byReference);
            }
        }
    }

    /**
     * Verification that the type used is complete and therefore can be used inside another type or to create a value
     * @params: 
     *  - loc: the location of the use
     *  - type: the type to check
     *  - construct: true iif this is the creation of a new variable (in that case lambda type are authorized)
     * @throws:
     *  - &ErrorMsg: if there is something not allowed here
     */
    pub fn verifyCompleteType (self, loc : &Word, type : &Type, construct : bool)
        throws &ErrorMsg
    {
        if (type.isOf!{&LambdaType}() && construct) return {}
        if (type.isOf!{&TemporaryType} ()) {
            println (type::typeinfo.name, " ", construct);
            let endLoc = if (!loc.isSame (type.getLoc ()) && !type.getLoc ().isEof ()) {
                type.getLoc ()
            } else { EOF_WORD };

            match (type) {
                ClassRefType () => {
                    let notes = [ErrorMsg::note (loc, ValidateErrorMessage::FORGET_AND_CLASS, oneLine-> true)];
                    throw ErrorMsg::fatal (loc, end-> endLoc, format (ValidateErrorMessage::INCOMPLETE_TYPE, type), notes-> notes);
                }
                _ => {
                    throw ErrorMsg::fatal (loc, end-> endLoc, format (ValidateErrorMessage::INCOMPLETE_TYPE, type));
                }
            }
        }
    }

    /**
     * Verification that type used is complete and therefore can be used to create a value
     * */
    pub fn verifyCompleteTypeWithValue (self, loc : &Word, type : &Type, value : &Value, construct : bool)
        throws &ErrorMsg
    {
        {
            self.verifyCompleteType (loc, type, construct);
        } catch {
            err : &ErrorMsg => {
                throw err.withNote ([ErrorMsg::note (value.getLoc (), format (ValidateErrorMessage::WHEN_CREATING_VALUE, value))]);
            }
        }
    }

    /**
     * Verification that the the type does not need alias, and otherwise that the value is an aliaser
     * @warning: does not fully check the mutability etc., cf. verifyMutabilityLevel
     * @params: 
     *  - loc: the location of the movement
     *  - type: the type that will receive the data
     *  - value: the value that is moved
     * @throws:
     *  - &ErrorMsg: if there is something not allowed here
     */
    fn verifyImplicitAlias (self, loc : &Word, type : &Type, value : &Value, byReference : bool)
        throws &ErrorMsg
    {
        // Value to a value that needs ref, but without explicitely writing it
        // e.g. { let z = 12; let ref x = z; } 
        if (byReference && !value.isOf!{&ReferencerValue} ()) { 
            throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::IMPLICIT_REFERENCE, value.getType ()));
        }

        // Reference to a value that does not need ref
        // e.g. { let z = 12; let x = ref z; }
        else if (!byReference && value.isOf!{&ReferencerValue} ()) { 
            throw ErrorMsg::fatal (loc, ValidateErrorMessage::UNECESSARY_REFERENCE);
        }

        // Alias of borrowable data, but without explicitely writing it
        // e.g. { let z = [1, 2, 3]; let dmut a = z; }
        else if (!byReference && self.needExplicitAlias (type, value)) {
            self.throwImplicitAlias (loc, type, value);
        }

        // Alias but on non borrowable data, or on a const borrowable data, so when it is not needed
        // e.g. { let mut z = [12]; let x = alias z; } 
        else if (value.isOf!{&AliaserValue} ()) {
            if (!self.needExplicitAlias (type)) {
                throw ErrorMsg::fatal (loc, ValidateErrorMessage::UNECESSARY_ALIAS);
            }
        }
        // else if ((byReference && value.isOf!{&ReferencerValue} ()) || !self.needExplicitAlias ()) {}
    }

    /**
     * Check if the value can be used without explicit alias over it
     * @params: 
     *  - type: the type that will receive the data
     *  - value: the value that is moved
     */
    pub fn needExplicitAlias (self, type : &Type, value : &Value)-> bool {
        if (!type.needExplicitAlias ()) return false; // no data are borrowed
        match value {
            AddressValue () => return false;
            AliaserValue () => return false; 
            CopierValue () => return false;
            LiteralValue () => return false; 
            ConstructValue () => return false; 
            BlockValue () => return false;            
            ScopeValue () => return false; 
            CallValue () => return false;
            CtorCallValue () => return false;
            SliceConcatValue () => return false;
        }
        
        self.needExplicitAlias (type)
    }

    /**
     * Check if the type must be enclosed inside an explicit alias
     * @params:
     *    - type: the type that will receive the data
     * */
    fn needExplicitAlias (self, type : &Type)-> bool {
        match type {
            t : &TupleType => {
                for it in t.getInners () {
                    if (self.needExplicitAlias (it)) return true;
                }

                false
            }
            _ => {
                type.needExplicitAlias () && (type.mutabilityLevel () > 1u32)
            }
        }
    }

    /**
     * Throw the implicit alias error
     * @params:
     *    - loc: the location of the implicit alias
     *    - type: the type that need explicit alias
     *    - value: the value being implicitely aliased
     * */
    fn throwImplicitAlias (self, loc : &Word, type : &Type, value : &Value, isRoot : bool = true)
        throws &ErrorMsg
    {
        match type {
            t : &TupleType => {
                {
                    for it in t.getInners () {
                        if (self.needExplicitAlias (it)) self.throwImplicitAlias (loc, it, value, isRoot-> false);
                    }
                } catch {
                    err : &ErrorMsg => {
                        if (isRoot) {
                            throw err.withNote ([ErrorMsg::note (loc, oneLine-> true, format (ValidateErrorMessage::FOR_TUPLE_TYPE, type))]);
                        } else throw err;
                    }
                }
            }
            _ => {
                let llevel = type.mutabilityLevel ();
                throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::DISCARD_CONST_LEVEL, llevel, 1u32),
                                       notes-> [ErrorMsg::note (value.getLoc (), format (ValidateErrorMessage::IMPLICIT_ALIAS, type))]);
            }
        }
    }

    /**
     * Verify that there is no movement of pure data 
     * @example: 
     * ==========================
     * let dmut a = [1, 2, 3];
     * let pure b = a; // prohibited because 
     * a [0] = 9;
     * // b is changed
     * println (b); // [9, 2, 3], but it is pure ??
     * ==========================
     * @warning: does not fully check the mutability etc., cf. verifyMutabilityLevel
     * @params: 
     *   - loc: the location of the movement 
     *   - type: the left type of the operation
     *   - value: the value that is moved
     * @throws: if there is something prohibited
     */
    fn verifyImplicitPure (self, loc : &Word, type : &Type, value : &Value)
        throws &ErrorMsg
    {
        if (type.isPure ()) {
            match value {
                c : &CopierValue => {
                    if (c.isDeep () && c.getType ().isPure ()) return {}
                }
            }

            throw ErrorMsg::fatal (loc, ValidateErrorMessage::DISCARD_CONST,
                                   notes-> [ErrorMsg::note (value.getLoc (), format (ValidateErrorMessage::IMPLICIT_PURE, value.getType ()))]);
        }
    }

    /**
     * Verify that the mutability level of lType is higher or equal than those of rType, otherwise memory movement creates a discard of const
     * @example:
     * ===================
     * let mut a = [1, 2, 3];
     * let dmut b = alias a; // no implicit alias, but a cannot give mutable access to inner values
     * b [0] = 9;
     * println (a); // [9, 2, 3]; we did not respected the contract of a
     * ===================
     * @params: 
     *   - lLoc: the location of the left operand in the movement operation
     *   - rLoc: the location of the right operation in the movement operation
     *   - lType: the type on the left of the operation (type of `b` in the example)
     *   - rType: the type on the right of the operation (type of `a` in the example)
     *   - byReference: true iif the types are a reference     
     * @throws:
     *  - &ErrorMsg: if the movement is not allowed 
     */
    fn verifyMutabilityLevel (self, lLoc : &Word, rLoc : &Word, lType : &Type, rType : &Type, byReference : bool)
        throws &ErrorMsg
    {        
        match lType {
            t : &TupleType => { self.verifyMutabilityLevelTuple (lLoc, rLoc, lType, t); }
            LambdaType () => {
                if (lType.isMutable ()) {
                    throw ErrorMsg::fatal (rLoc, format (ValidateErrorMessage::DISCARD_CONST_LEVEL, 1, 0));
                }
            }
            _ => {
                // this test is useless I think, native scalar types have always a mutability level of 1, but it is probably faster that way
                if (byReference || lType.borrowDatas ()) {
                    if (byReference) {
                        if (!rType.isMutable () && lType.isMutable ()) {
                            throw ErrorMsg::fatal (lLoc, format (ValidateErrorMessage::DISCARD_CONST_LEVEL, 1u32, 0u32),
                                                   notes-> [ErrorMsg::note (rLoc, format (ValidateErrorMessage::DISCARD_CONST_LEVEL_TYPES, rType, lType))]);
                        }
                    }

                    {
                        let lLevel = lType.mutabilityLevel ();
                        let rLevel = if (self.isVoidSliceType (rType)) {
                            lLevel
                        } else {
                            rType.mutabilityLevel ()
                        };

                        if (lLevel > max (1u32, rLevel)) {
                            throw ErrorMsg::fatal (lLoc, format (ValidateErrorMessage::DISCARD_CONST_LEVEL, lLevel, max (1u32, rLevel)),
                                                   notes-> [ErrorMsg::note (rLoc, format (ValidateErrorMessage::DISCARD_CONST_LEVEL_TYPES, rType, lType))]);
                        }
                    }
                }
            }
        }
    }

    /**
     * @returns: true if `type` is slice of containing void elements
     */
    fn isVoidSliceType (self, type : &Type)-> bool {
        match type {
            s : &SliceType => {
                s.getInners ()[0].isOf!{&VoidType} ()
            }
            _ => { false }
        }
    }

    /**
     * Tuple are trees, thus the mutability level does not work, we have to make a different validation
     * @params: 
     *   - lLoc: the location of the left operand
     *   - rLoc: the location of the right operand
     *   - lType: the left type of the operation
     *   - rType: the right type of the operation
     * @throws: 
     *  - &ErrorMsg: if the movement is not allowed 
     */
    fn verifyMutabilityLevelTuple (self, lLoc : &Word, _ : &Word, lType : &Type, rType : &TupleType)
        throws &ErrorMsg
    {
        match lType {
            left : &TupleType => {
                {
                    for i in 0us .. left.getInners ().len { // The mutability level of tuple is a bit more complicated, we need to check the level of every branch, it is a tree not a list
                        let litype = left.getInners ()[i], ritype = rType.getInners ()[i];
                        self.verifyMutabilityLevel (litype.getLoc (), ritype.getLoc (), litype, ritype, byReference-> false);
                    }
                } catch {
                    err : &ErrorMsg => {
                        throw ErrorMsg::fatal (lLoc, ValidateErrorMessage::DISCARD_CONST, notes-> [err]);
                    }
                }
            }
            _ => {
                __pragma!panic ();
            }
        }
    }
    
    /**
     * Testing if left is an ancestor class of right, this is usefull for type compatibility checking
     * @info: check if the types are ClassPtrType, or ClassRefType (works with both)
     * @params: 
     *    - left: any type
     *    - right: any type
     * @returns: true if the left type is a classptrtype and is an ancestor of the right type (a classptrtype as well)
     */
    pub fn isAncestor (self, left : &Type, right : &Type)-> bool {
        let rInner : &ClassRefType = match right { // This function is made to work with classptr and classref
            c : &ClassPtrType => { c.getInner () }
            c : &ClassRefType => { c }
            _ => { return false; }
        };

        let lInner : &ClassRefType = match left { // This function is made to work with classptr and classref
            c : &ClassPtrType => { c.getInner () }
            c : &ClassRefType => { c }
            _ => { return false; }
        };

        let mut ancestor = rInner.getAncestor ();
        loop { // we traverse the ancestor of right
            match ancestor {
                c : &ClassRefType => { 
                    if (c == lInner) { break true; } // if one of the ancestor of right is equal to left, then left is an ancestor of right
                    ancestor = c.getAncestor (); // else we go up again
                }
                _ => { break false; } // No ancestor left
            }
        }
    }

    /**
     * Verify that 'left' is an ancestor of 'right'
     * @params: 
     *    - left: any type
     *    - right: any type
     * @throws:
     *    - &ErrorMsg: if 'left' is not an ancestor of 'right'
     */
    pub fn verifyAncestor (self, loc : &Word, left : &Type, right : &Type)
        throws &ErrorMsg
    {
        if (!self.isAncestor (left, right)) {
            throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::NOT_ANCESTOR, left, right));
        }
    }

    /**
     * Verify that 'right' implement the trait 'left'
     * @params: 
     *    - left: any type (but needs to be a trait in order to work)
     *    - right: any type (but needs to be a class in order to work)
     * @throws: 
     *   - &ErrorMsg: if 'right' does not implement 'left'
     */
    pub fn verifyImplement (self, loc : &Word, left : &Type, right : &Type)
        throws &ErrorMsg
    {
        if (!right.isOf!{&TraitRefType} ()) {
            throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::NOT_A_TRAIT, right));
        }

        let lInner : &ClassRefType = match left { // This function is made to work with classptr and classref
            c : &ClassPtrType => { c.getInner () }
            c : &ClassRefType => { c }
            _ => {
                throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::NOT_A_CLASS, left));
            }
        };

        for im in lInner.getAllImplTraits () {
            if (im == right) return {}
        }

        throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::CLASS_NOT_IMPL, lInner, right));
    }

    /**
     * Get the common ancestor of left and right 
     * @params: 
     *   - loc: the location of the operation
     *   - left: a class type
     *   - right: a class type
     * @returns: a class type containing the common ancestor, or NoneType
     */
    pub fn getCommonAncestor (self, loc : &Word, left : &ClassPtrType, right : &ClassPtrType)-> &Type {
        let mut ancestor : &Type = left.getInner ();

        // We traverse the list of ancestor of the left 
        loop {
            match ancestor {
                c : &ClassRefType => {
                    // if one of the ancestor of left is also an ancestor of right, then it is a common ancestor
                    if (self.isAncestor (ancestor, right)) break ClassPtrType::new (loc, c, isMutable-> false); 
                    else { // We go back again
                        ancestor = c.getAncestor ();
                    }
                }
                _ => { // No ancestor left to check
                    break NONE_TYPE;
                }
            }            
        }
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================            UTILS             =========================
     * ================================================================================
     * ================================================================================
     */
    
    /**
     * Create a syntax var path (a PathExpr) leading to a given path
     * This function can be used to create path to core functions, or core files
     * @panic: the path contains at least one element 
     * @example: 
     * ====================
     * let syntVar = context.createSyntaxVarFromPath (loc, ["core", "array", "opCmp"]);
     * println (format ("%", syntVar)); // core::array::opCmp
     * ====================
     * @params: 
     *   - loc: the location of the expression
     *   - path: the path to the transform into a var
     * @returns: a syntax expression containing the path
     */
    pub fn createSyntaxVarFromPath (self, loc : &Word, path : [[c8]])-> &Expression {
        if (path.len == 0us) __pragma!panic ();
        let mut leaf : &Expression = VarExpr::new (Word::new (path[0us], loc));
        for i in 1us .. path.len { // This is relatively simple, we just create a list
            leaf = PathExpr::new (Word::new (Tokens::DCOLON, loc),
                                  leaf,
                                  VarExpr::new (Word::new (path[i], loc)));                                  
        }
        
        leaf
    }

    /**
     * Retreive the type core::exception::Exception and validate it
     * @params: 
     *   - loc: the location of the creation
     * @returns: the exception type (ClassPtrType)
     * @throws: 
     *    - &ErrorMsg: if the type is not found (e.g. compiled in standalone)
     */
    pub fn getExceptionType (mut self, loc : &Word = EOF_WORD)-> &Type
        throws &ErrorMsg
    {
        let var = self.createSyntaxVarFromPath (loc, path-> [CoreNames::CORE_MODULE, CoreNames::EXCEPTION_MODULE, CoreNames::EXCEPTION_TYPE]);
        let type = self:.validateType (var);
        match type {
            c : &ClassRefType => { c.createInstance (true, true) }
            _ => { __pragma!panic (); }
        }
    }

    
    /**
     * Create an error message for global retreival fail
     * This create an error message, with alternative variable with close names, or private variables inaccessible from the current context
     * @params: 
     *   - loc: the location of the var to find
     *   - name: the name of the variable to find
     * @returns: the error message, that can be thrown as it is
     */
    pub fn createGlobalVarError (mut self, loc : &Word, name : [c8])-> &ErrorMsg {
        self._declarator.createGlobalAccessError (loc, name, self.getReferent ())
    }

    /**
     * Create an error message for local retreival fail
     * This create an error message with alternative variable with close names, or private variable inaccessible from the current context
     * @params:
     *    - loc: the location of the variable to find
     *    - modules: the module in which the local access is made
     *    - name: the name of the variable to find
     * @returns: the list of notes to attach to the real error
     * */
    pub fn createLocalVarError (mut self, loc : &Word, module : &ModuleRefValue, name : [c8])-> [&ErrorMsg] {
        self._declarator.createLocalAccessError (loc, name, module.getSymbol (), self.getReferent ())
    }



    /**
     * Validate the arguments of a template call/checker
     * @params: 
     *    - lst: the list of template arguments
     * @returns: 
     *    - a list of generator (can be a mix of types and values)
     * @throws:
     *    - &ErrorMsg: if there is an error in the validation
     */
    pub fn validateTemplateArgumentList (mut self, lst : [&Expression])-> [&Generator]
        throws &ErrorMsg
    {
        let dmut errors = Vec!{&ErrorMsg}::new ();
        let dmut results = Vec!{&Generator}::new ();
        for i in lst {
            { // We first try a type
                results:.push (self:.validateType (i));
            } catch {
                err : &ErrorMsg => { // Apparently its not a type
                    let val = self:.validateValue (i); // Maybe its a value
                    if (!self.getCompileTimeInterpreter ().isCte (val)) { // but we need to know it a compile time
                        throw ErrorMsg::fatal (val.getLoc (), format (ValidateErrorMessage::UNKNOWN_AT_COMPILE_TIME, val.getType ()));
                    }
                    results:.push (val);
                } catch {
                    err2 : &ErrorMsg => { // Another error, we print both errors (type and value) for better debugging
                        let valueError = ErrorMsg::note (i.getLoc (), ValidateErrorMessage::TEMPLATE_VALUE_TRY, notes-> [err2]);
                        errors:.push (ErrorMsg::list ([err, valueError]));
                    }
                }
            };
        }

        if (errors.len () != 0us) throw ErrorMsg::list (errors[]); // Some arguments are invalid
        
        results[] // Everything is ok
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================             MISC             =========================
     * ================================================================================
     * ================================================================================
     */


    /**
     * Check if value is the var value 'self'
     * @params: 
     *    - value: the value to check
     * @returns: true iif the value is a var ref value containing the 'self' variable 
     */
    pub fn isSelf (self, value : &Value)-> bool {
        match value {
            v : &VarRefValue => { v.isSelf () }
            _ => { false }
        }
    }

    /**
     * @returns: true iif the expression is located in a copy or a deep copy
     * */
    pub fn isDynamic (self, expr : &Expression)-> bool {
        let i = self._copyContext [self._copyContext.len () - 1us];
        match i.len () {
            0us => { return false; }
            _ => {
                return self.isDynamic (i [$ - 1us], expr);
            }
        }
    }

    /**
     * @returns: the location of the current copy/dcopy operator
     * @warning: assuming we indeed are inside a dynamic context (cf. self.isDynamic)
     * */
    pub fn getDynamicExpr (self)-> &Expression {
        let i = self._copyContext [self._copyContext.len () - 1us];
        match i.len () {
            0us => { __pragma!panic (); }
            _ => {
                i [$ - 1us]
            }
        }
    }

    /**
     * @returns: true if the intricic values has an effect on the expr as copiyng
     * */
    fn isDynamic (self, copier : &Expression, expr : &Expression, inDeep : bool = false)-> bool {
        if (copier is expr) return true;
        match copier {
            cp : &IntrinsicExpr => {
                if (cp.getType () == IntrinsicKeys::COPY) {
                    return self.isDynamic (cp.getContent (), expr, inDeep-> false || inDeep);
                } else if (cp.getType () == IntrinsicKeys::DCOPY) {
                    return self.isDynamic (cp.getContent (), expr, inDeep-> true);
                }
            }
            t : &TryExpr => {
                return self.isDynamic (t.getValue (), expr, inDeep-> inDeep);
            }
            l : &ListExpr => {
                if (inDeep) { // if not deep, then it the list that is copied, however l !is expr
                    for i in l.getParameters () {
                        if (self.isDynamic (i, expr, inDeep-> inDeep)) return true;
                    }
                }
            }
            s : &SliceAllocatorExpr => {
                if (inDeep) {  // if not deep, then it the list that is copied, however s !is expr
                    return self.isDynamic (s.getValue (), expr, inDeep-> inDeep);
                }
            }
            s : &SliceForAllocatorExpr => {
                if (inDeep) {  // if not deep, then it the list that is copied, however s !is expr
                    return self.isDynamic (s.getValue (), expr, inDeep-> inDeep);
                }
            }
        }

        return false;
    }

    /**
     * Add time to remove from the timer of the validation
     * */
    pub fn removeTime (mut self, time : Duration) {
        self._removeTime += time;
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================           PRIVATE            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * @returns: a local variable that is enclosed
     */
    fn getInClosure (mut self, loc : &Word, name : [c8])-> &Value
        throws &ErrorMsg
    {
        if (self._closureType.len () == 0us) return UNIT_VALUE;

        let dmut closureType = (alias self._closureType) [self._closureType.len () - 1us];
        let (field, index) = closureType.getField (name);
        if (field.isOf!{&NoneType} ()) {
            let syms = closureType.getClosureSymbols ();
            let dmut used = closureType:.getClosureUsed ();
            
            for i in 0us .. syms.len () {
                let ptr = syms[i].find (name);
                match ptr {
                    Ok (g : &Value) => {
                        let val = self.checkEnclosable (loc, g);
                        let type = val.getType ();
                        (alias used)[][i]:.insert (name);

                        let types = closureType.getInnerTypes () ~ [type];
                        let names = closureType.getInnerNames () ~ [name];
                        let values = closureType.getInnerValues () ~ [val];
                        let fndIndex = values.len - 1us;

                        let dmut secClosureType = ClosureType::new (closureType.getLoc (), types, names, values, closureType.getRefId (), syms, alias used);
                        (alias self._closureType)[][$ - 1us] = alias secClosureType;

                        let oldRef = self:.getLocal (EOF_WORD, "#{CLOSURE-VARREF}"s8, canBeInClosure-> false);
                        match oldRef {
                            v : &VarRefValue => {
                                let closureRef = VarRefValue::new (oldRef.getLoc (), EOF_WORD, secClosureType, v.getRefId ());
                                (alias (alias self._symbols)[self._symbols.len () - 1us])[0us]:.insert ("#{CLOSURE-VARREF}"s8, closureRef);

                                return ClosureFieldAccessValue::new (EOF_WORD, type, closureRef, fndIndex);
                            }
                            _ => __pragma!panic ();
                        }
                    }
                }
            }
        } else {
            let closureRef = self:.getLocal (EOF_WORD, "#{CLOSURE-VARREF}"s8, canBeInClosure-> false);
            return ClosureFieldAccessValue::new (EOF_WORD, field, closureRef, index);
        }
        
        UNIT_VALUE
    } catch {
        err : &ErrorMsg => throw err;
    }

    /**
     * Check that the value is enclosable, and return a the enclosable value derived from it
     * @params:
     *    - loc: the location of the enclosing
     *    - value: the value being enclosed
     */
    fn checkEnclosable (self, loc : &Word, value : &Value)-> &Value
        throws &ErrorMsg
    {
        match value {
            v : &VarDeclValue => {
                match v.getVarType () {
                    LambdaType () => {
                        throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::ENCLOSE_INCOMPLETE_TYPE, v.getVarType ()),
                                               notes-> [ErrorMsg::note (value.getLoc (), ValidateErrorMessage::DECLARED_HERE)]);
                    }
                    _ => {
                        cast!{&Value} (VarRefValue::new (loc, v.getLoc (), v.getVarType (), v.getUniqId (), isSelf-> false))
                    }
                }
            }
            p : &ProtoVarValue => {
                cast!{&Value} (VarRefValue::new (loc, p.getLoc (), p.getType (), p.getUniqId (), isSelf-> p.isSelf ()))
            }
            _ => {
                value
            }
        }        
    }
}
