mod ymirc::semantic::validator::visitor;

import ymirc::semantic::validator::symbol::_;
import ymirc::semantic::validator::operator::_;
import ymirc::semantic::validator::type;
import ymirc::semantic::validator::value;
import ymirc::semantic::validator::literal;
import ymirc::semantic::validator::errors;

import ymirc::semantic::symbol::_;
import ymirc::semantic::generator::_;
import ymirc::syntax::keys;
import ymirc::syntax::expression::_;
import ymirc::syntax::declaration::protection;
import ymirc::errors::_;
import ymirc::lexing::word;
import ymirc::utils::format;

import std::collection::vec;
import std::collection::map;
import std::collection::set;
import std::io;


/**
 * The validator class is the class that transform the declared symbols into validated generators that can be passed to the backend
 */
pub class Validator {

    /// The list of generators to pass to the backend
    let dmut _generated = Vec!{&Generator}::new ();

    /**
     * ================================================================================
     * ================================================================================
     * =========================      SYMBOL VALIDATORS       =========================
     * ================================================================================
     * ================================================================================
     */

    /// The validator that is in charge of aka validation
    let dmut _akaValidator = AkaValidator::new ();

    /// The validator that is in charge of class validation
    let dmut _classValidator = ClassValidator::new ();
    
    /// The validator that is in charge of validating functions
    let dmut _functionValidator = FunctionValidator::new ();

    /// The validator that is in charge of validating modules
    let dmut _moduleValidator = ModuleValidator::new ();
    
    /// The validator that is in charge of class validation
    let dmut _structValidator = StructValidator::new ();

    /// The validator that is in charge of template validation
    let dmut _templateValidator = TemplateValidator::new ();

    /// The validator that is in charge of template validation
    let dmut _traitValidator = TraitValidator::new ();

    /**
     * ================================================================================
     * ================================================================================
     * =========================        SUB VALIDATORS        =========================
     * ================================================================================
     * ================================================================================
     */

    /// The validator that is in charge of validating types
    let dmut _typeValidator = TypeValidator::new ();

    /// The validator that is in charge of validating values
    let dmut _valueValidator = ValueValidator::new ();

    /// The validator used to validate binary operators
    let dmut _binOpValidator = BinaryOpValidator::new ();

    /// The validator used to validate unary operators
    let dmut _unOpValidator = UnaryOpValidator::new ();

    /// The validator used to validate mult operators
    let dmut _multOpValidator = MultOpValidator::new ();

    /// The validator used to validate literals
    let dmut _literalValidator = LiteralValidator::new ();

    /**
     * ================================================================================
     * ================================================================================
     * =========================           CONTEXT            =========================
     * ================================================================================
     * ================================================================================
     */

    /// The referent are used when accessing symbols
    let dmut _referent = Vec!{dmut &Symbol}::new ();
    
    /// The current scope variable declarations
    let dmut _symbols = Vec!{dmut &Vec!{dmut &HashMap!{[c8], &Value}}}::new ();

    /// The list of symbols that are used in the current block
    let dmut _usedSyms = Vec!{dmut &Vec!{dmut &HashSet!{[c8]}}}::new ();

    /// The current return type of the current function
    let dmut _functionReturns = Vec!{&Type}::new ();

    /// True iif we are currently validating a closure
    let mut _isInClosure = false;

    /**
     * ================================================================================
     * ================================================================================
     * =========================        VERIFICATIONS         =========================
     * ================================================================================
     * ================================================================================
     */

    /// The native type names
    let dmut _nativeTypeNames = HashSet!{[c8]}::new ();    
    
    /**
     * ================================================================================
     * ================================================================================
     * =========================         CONSTRUCTION         =========================
     * ================================================================================
     * ================================================================================
     */
    
    /**
     * Create a new empty validator
     */
    pub self () {        
        for t in NativeTypes::__members__ {
            self._nativeTypeNames:.insert (t);
        }
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================          VALIDATION          =========================
     * ================================================================================
     * ================================================================================
     */
    
    /**
     * Validate a symbol
     * @params: 
     *   - sym: the symbol to validate
     * @throws: 
     *   - &ErrorMsg: if there was an error in the validation
     */
    pub def validate (mut self, dmut sym : &Symbol)
        throws &ErrorMsg
    {
        match ref sym {
            dmut m : &ModuleSymbol => {
                self._moduleValidator:.validate (alias self, alias m);
            }
            dmut f : &FunctionSymbol => {
                self._functionValidator:.validate (alias self, alias f);
            }
            EmptySymbol () => {
                // Just do nothing 
            }
            _ => {
                println ("TODO : ", sym::typeinfo.name);
                __pragma!panic ();
            }                
        }
    }


    /**
     * ================================================================================
     * ================================================================================
     * =========================            TYPES             =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate an expression assuming its a type
     * @params: 
     *    - type: the expression to validate
     * @returns: the generator
     * @throws: &ErrorMsg, if the type is not valid
     */
    pub def validateType (mut self, type : &Expression)-> &Type
        throws &ErrorMsg
    {
        self._typeValidator:.validate (alias self, type)
    }


    /**
     * Validate an expression assuming its a type
     * @params: 
     *    - type: the expression to validate
     *    - decos: the additional decoration of the type (basically the decorations of a vardecl)
     * @returns: the generator of the type
     * @throws: &ErrorMsg, if the type is not valid
     */
    pub def validateType (mut self, type : &Expression, decos : [DecoratorWord])-> &Type
        throws &ErrorMsg
    {
        let _ = self._typeValidator:.validate (alias self, type);
        decos;
        __pragma!panic ();
    }
    

    /**
     * ================================================================================
     * ================================================================================
     * =========================            VALUES            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate an expression assuming its a value
     * @params: 
     *    - value: the expression to validate
     * @returns: the generator
     * @throws: &ErrorMsg, if the value is not valid
     */
    pub def validateValue (mut self, value : &Expression)-> &Value
        throws &ErrorMsg
    {
        self._valueValidator:.validate (alias self, value)
    }


    /**
     * Validate an expression assuming its a value
     * @params: 
     *    - loc: the location of the affection
     *    - value: the expression to validate
     *    - type: the expected type (and mutability)
     * @returns: the generator
     * @throws: &ErrorMsg, if the value is not valid, or cannot be put in type
     */
    pub def validateValue (mut self, loc : &Word, value : &Expression, type : &Type)-> &Value
        throws &ErrorMsg
    {
        let v = self._valueValidator:.validate (alias self, value);
        self:.verifyCompatibleTypeWithValue (loc, type, v);
        self:.verifyMemoryOwner (loc, type, v);

        v
    }


    /**
     * ================================================================================
     * ================================================================================
     * =========================           GETTERS            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * @returns: the validator for binary operations
     */
    pub def getBinOpValidator (mut self)-> dmut &BinaryOpValidator {
        alias self._binOpValidator
    }

    /**
     * @returns: the validator for unary operations
     */
    pub def getUnOpValidator (mut self)-> dmut &UnaryOpValidator {
        alias self._unOpValidator
    }

    /**
     * @returns: the validator for mult operators
     */
    pub def getMultOpValidator (mut self)-> dmut &MultOpValidator {
        alias self._multOpValidator
    }

    /**
     * @returns: the validator for literals
     */
    pub def getLiteralValidator (mut self)-> dmut &LiteralValidator {
        alias self._literalValidator
    }

    /**
     * @returns: the validator for akas
     */
    pub def getAkaValidator (mut self)-> dmut &AkaValidator {
        alias self._akaValidator
    }

    /**
     * @returns: the validator for classes
     */
    pub def getClassValidator (mut self)-> dmut &ClassValidator {
        alias self._classValidator
    }
    
    /**
     * @returns: the validator for functions
     */
    pub def getFunctionValidator (mut self)-> dmut &FunctionValidator {
        alias self._functionValidator
    }

    /**
     * @returns: the validator for modules
     */
    pub def getModuleValidator (mut self)-> dmut &ModuleValidator {
        alias self._moduleValidator
    }

    /**
     * @returns: the validator for struct
     */
    pub def getStructValidator (mut self)-> dmut &StructValidator {
        alias self._structValidator
    }

    /**
     * @returns: the validator for templates
     */
    pub def getTemplateValidator (mut self)-> dmut &TemplateValidator {
        alias self._templateValidator
    }

    /**
     * @returns: the validator for traits
     */
    pub def getTraitValidator (mut self)-> dmut &TraitValidator {
        alias self._traitValidator
    }
    
    /**
     * ================================================================================
     * ================================================================================
     * =========================           CONTEXT            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Push a new referent 
     * @params: 
     *   - sym: the symbol that will be used for future symbol access
     */
    pub def pushReferent (mut self, dmut sym : &Symbol) {
        self._referent:.push (alias sym);
    }

    /**
     * Exit the current referent
     */
    pub def popReferent (mut self) {
        self._referent:.pop (1u64);
    }


    /**
     * @returns: the current referent
     */
    pub def getReferent (mut self)-> dmut &Symbol {
        return alias (alias self._referent)[self._referent.len () - 1us];
    } catch {
        _ : &OutOfArray => __pragma!panic ();
    }
    

    /**
     * ================================================================================
     * ================================================================================
     * =========================       LOCAL VARIABLES        =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Enter a new foreign scope space
     */
    pub def enterForeign (mut self) {
        self._symbols:.push (Vec!{dmut &HashMap!{[c8], &Value}}::new ());
        self._usedSyms:.push (Vec!{dmut &HashSet!{[c8]}}::new ());
        self._functionReturns:.push (NoneType::new (loc-> EOF_WORD));
    }

    /**
     * Exit a foreign scope space
     */
    pub def exitForeign (mut self) {
        self._symbols:.pop (1u64);
        self._usedSyms:.pop (1u64);
        self._functionReturns:.pop (1u64);
    }

    /**
     * Set the type of the current function
     */
    pub def setFunctionReturn (mut self, type : &Type) {
        (alias self._functionReturns)[self._functionReturns.len () - 1us] = type;        
    } catch {
        _ => __pragma!panic ();
    }
    
    /**
     * Enter a new scope
     */
    pub def enterBlock (mut self) {
        (alias self._symbols)[][$ - 1us]:.push (HashMap!{[c8], &Value}::new ());
        (alias self._usedSyms)[][$ - 1us]:.push (HashSet!{[c8]}::new ());
    }

    /**
     * Exit a scope
     * @throws: 
     *   - &ErrorMsg: if a symbol was declared but unused and warnUnused
     */
    pub def quitBlock (mut self, warnUnused : bool = true)
        throws &ErrorMsg
    {        
        if (warnUnused) {
            let dmut errors = Vec!{&ErrorMsg}::new ();
            for name, g in self._symbols[][$ - 1us][][$ - 1us] {
                if (name != Keys::SELF) { // SELF does not need to be used
                    if (name !in self._usedSyms[][$ - 1us][][$ - 1us]) {
                        errors:.push (ErrorMsg::warn (g.getLoc (), format (ValidateErrorMessage::DECLARED_NOT_USED, name)));
                    }
                }
            }
            
            if errors.len () != 0us {
                throw ErrorMsg::list (errors[]);
            }
        }

        (alias self._symbols)[][$ - 1us]:.pop (1u64);
        (alias self._usedSyms)[][$ - 1us]:.pop (1u64);
    }
    
    /**
     * Insert a new variable in the current block
     * @params: 
     *    - name: the name of the variable
     *    - val: the declaration of the variable
     */
    pub def insertLocal (mut self, name : [c8], val : &Value) {
        (alias ((alias self._symbols)[][$ - 1us]))[][$ - 1us]:.insert (name, val);
    }

    /**
     * Clear the current scope
     */
    pub def clearLocalScope (mut self) {
        (alias ((alias self._symbols)[][$ - 1us]))[][$ - 1us]:.clear ();
    }

    /**
     * Search the definition of a local variable
     * @params: 
     *   - name: the name of the variable to search
     *   - canBeInClosure: if the variable can be a variable from the parent of a closure
     * @returns: the generator of the variable or NoneValue
     */
    pub def getLocal (mut self, name : [c8], canBeInClosure : bool = true)-> &Value {
        for i in 0us .. self._symbols [][$ - 1us].len () {
            let ptr = self._symbols[][$ - 1us][][i].find (name);
            match ptr {
                Ok (g : &Value) => {
                    (alias ((alias self._usedSyms)[][$ - 1us])[][$ - 1us]):.insert (name);
                    return g;
                }
            }
        }

        if (canBeInClosure) {
            return self:.getInClosure (name);
        } else {
            return NoneValue::new ();
        }
    }

    /**
     * Search the definition of a local variable 
     * @warning: use only for shadowing verification, it does not update used variable infos
     * @params: 
     *   - name: the name of the variable to search
     *   - canBeInClosure: if the variable can be a variable from the parent of a closure
     * @returns: the generator of the variable or NoneValue
     */
    def getLocalNoUse (self, name : [c8])-> &Value {
        for i in 0us .. self._symbols [][$ - 1us].len () {
            let ptr = self._symbols[][$ - 1us][][i].find (name);
            match ptr {
                Ok (g : _) => {
                    return g;
                }
            }
        }

        NoneValue::new ()        
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================        GLOBAL SYMBOLS        =========================
     * ================================================================================
     * ================================================================================
     */


    /**
     * Search all the global symbols whose name are name
     * @params: 
     *   - name: the name of the symbols to get
     * @returns: the list of symbols whose name are name, and are accessible from the current context
     */
    pub def getGlobal (mut self, name : [c8])-> dmut [&Symbol] {
        if (self._referent.len () == 0us) return [];
        let dmut res = (alias self._referent) [self._referent.len () - 1us]:.getSymbols (name);
        return (alias res)[];
    } catch {
        _ => __pragma!panic ();
    }

    /**
     * Search all the global symbols whose name are close to `name`, with a distance of `distance`
     * @params: 
     *   - name: the name of the symbols to get
     *   - distance: the distance of the name of the symbol to `name`
     * @returns: the list of symbols whose name are close to `name` (only public ones)
     */
    pub def getCloseGlobal (self, name : [c8], distance : usize = 2us)-> [&Symbol] {
        if (self._referent.len () == 0us) return [];
        let res = ( self._referent) [self._referent.len () - 1us].getCloseSymbols (name, distance);
        return res[];
    } catch {
        _ => __pragma!panic ();
    }    

    /**
     * Search all the global symbols whose name are name
     * @params: 
     *   - name: the name of the symbols to get
     * @returns: the list of symbols whose name are name, even if they are not accessible from the current context (protection)
     */
    pub def getGlobalPrivate (mut self, name : [c8])-> dmut [&Symbol] {
        if (self._referent.len () == 0us) return [];
        let dmut res = (alias self._referent) [self._referent.len () - 1us]:.getSymbols (name, protection-> Protection::PRIVATE);
        return (alias res)[];
    } catch {
        _ => __pragma!panic ();
    }
    
    /**
     * ================================================================================
     * ================================================================================
     * =========================         VERIFICATION         =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Verify that the variable is not shadowing another variable
     * And that the variable name is a valid variable identifier (not a native type)
     * @params: 
     *    - loc: the location and name of the variable that may shadow
     * @throws: &ErrorMsg, if the variable shadows another local declaration, or the variable name is a type name
     */
    pub def verifyShadow (self, loc : &Word)
        throws &ErrorMsg
    {
        self.verifyNotIsNativeType (loc);
        match self.getLocalNoUse (loc.str ()) {
            NoneValue () => {}
            gen : _ => {
                throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::SHADOWING_DECL, loc.str ()),
                                       notes-> [ErrorMsg::note (gen.getLoc (), ValidateErrorMessage::FIRST_DEFINED)]
                                       );
            }
        }
    }

    /**
     * Verify that the name of the variable is not a native type
     * @params: 
     *   - loc: the location and name of the variable
     * @throws: &ErrorMsg, iif the name of the variable is a native type
     */
    def verifyNotIsNativeType (self, loc : &Word)
        throws &ErrorMsg
    {
        if loc.str () in self._nativeTypeNames {
            throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::IS_NATIVE_TYPE, loc.str ()));
        }
    }

    
    pub def verifyCompatibleTypeWithValue (self, loc : &Word, type : &Type, value : &Value)
        throws &ErrorMsg
    {
        match (type, value) {
            (_ : &PointerType, _ : &NullValue) => {
                return {}
            }
        }

        loc;
        __pragma!fake_throw (&ErrorMsg);
    }

    pub def verifyCompatibleType (self, loc : &Word, left : &Type, right : &Type)
        throws &ErrorMsg
    {
        left;
        right;
        loc;
        __pragma!fake_throw (&ErrorMsg);
    }

    pub def verifyMemoryOwner (self, loc : &Word, left : &Type, right : &Value)
        throws &ErrorMsg
    {
        left;
        right;
        loc;
        __pragma!fake_throw (&ErrorMsg);
    }


    /**
     * ================================================================================
     * ================================================================================
     * =========================          GENERATION          =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Insert a new generator that will be sent to the backend for final transformation
     * @params: 
     *    - gen: a generator that can be transformed into a valid backend element (e.g. FrameGenerator)
     */
    pub def insertNewGenerator (mut self, gen : &Generator) {
        self._generated:.push (gen);
    }

    /**
     * @returns: the list of generators that were inserted for final transformation
     */
    pub def getGenerators (self)-> [&Generator] {
        self._generated[]
    }
    
    /**
     * ================================================================================
     * ================================================================================
     * =========================           PRIVATE            =========================
     * ================================================================================
     * ================================================================================
     */
    
    /**
     * @returns: a local variable that is enclosed
     */
    def getInClosure (mut self, name : [c8])-> &Value {
        if (!self._isInClosure) return NoneValue::new ();

        name;
        NoneValue::new ()
    }
        
}
