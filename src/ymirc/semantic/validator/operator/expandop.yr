mod ymirc::semantic::validator::operator::expandop;


import std::io;
import std::collection::vec;

import ymirc::semantic::validator::visitor;
import ymirc::semantic::validator::errors;
import ymirc::semantic::validator::template::_;

import ymirc::errors::_;
import ymirc::utils::format;
import ymirc::semantic::generator::value::_;
import ymirc::syntax::expression::_;
import ymirc::syntax::keys;
import ymirc::lexing::word;
import ymirc::lexing::tokens;
import ymirc::global::core_;

import ymirc::semantic::generator::type::_;

/**
 * The validator for expand and deep expand
 * */
pub class ExpandOpValidator {

    /**
     * Create an empty validator
     * */
    pub self () {}


    /**
     * Validate a expansion operation
     * @params:
     *    - context: the context of the validation
     *    - i: the intrinsic expression to validate
     * @returns: the expanded value
     * @throws:
     *    - &ErrorMsg: if the validation failed
     * */
    pub fn validateExpand (self, dmut context : &Validator, i : &IntrinsicExpr)-> &Value
        throws &ErrorMsg
    {
        let mValue = context:.getCompileTimeInterpreter ().reduce (context:.getValueValidator ().validate (alias context, i.getContent ()));
        let (byAlias, fVal) = match mValue {
            a : &AliaserValue => { (true, a.getValue ()) }
            _ => { (false, mValue) }
        };

        let (result, useAlias) = match fVal.getType () {
            t : &TupleType => {
                self.validateExpandTuple (alias context, t, fVal, i, byAlias)
            }
            a : &ArrayType => {
                self.validateExpandArray (alias context, a, fVal, i, byAlias)
            }
            a : &SliceType => {
                self.validateExpandSlice (alias context, a, fVal, i, byAlias)
            }
            _ => {
                return mValue;
            }
        };

        if (!useAlias && byAlias) {
            throw ErrorMsg::fatal (mValue.getLoc (), format (ValidateErrorMessage::UNECESSARY_ALIAS, mValue.getType ()));
        }

        result
    }

    /**
     * Validate an expansion operation on a tuple value
     * @params:
     *    - context: the context of the validation
     *    - t: the tuple type being expanded
     *    - value: the value to expand
     *    - i: the operator
     * @returns: the expanded value
     * */
    fn validateExpandTuple (self, dmut context : &Validator, t : &TupleType, value : &Value, i : &IntrinsicExpr, byAlias : bool)-> (&Value, bool)
        throws &ErrorMsg
    {
        let dmut values = Vec!{&Value}::new ();
        let mut useAlias = false;
        for it in 0us .. t.getInners ().len {
            let type = t.getInners ()[it];
            if (!byAlias) {
                let access = context:.getBinOpValidator ().createTupleFieldAccess (i.getLoc (), type.clone (0u32), value, it);
                values:.push (context.getCompileTimeInterpreter ().reduce (access));
            } else {
                let access = TupleFieldAccessValue::new (i.getLoc (), type, value, it);
                let (fAcc, useAlias_) = if (byAlias && type.isMutable () && type.needExplicitAlias ()) {
                    (cast!{&Value} (AliaserValue::new (access.getLoc (), access.getType (), access, fromExpansion-> true)), true)
                } else {
                    (access, false)
                };

                values:.push (fAcc);
                useAlias = useAlias || useAlias_;
            }
        }

        (ExpandValue::new (i.getLoc (), values[]), useAlias)
    }

    /**
     * Validate an expansion operation on an array value
     * @params:
     *    - context: the context of the validation
     *    - a: the array type being expanded
     *    - value: the value to expand
     *    - i: the operator
     * @returns: the expanded value
     * */
    fn validateExpandArray (self, dmut context : &Validator, a : &ArrayType, value : &Value, i : &IntrinsicExpr, byAlias : bool)-> (&Value, bool)
        throws &ErrorMsg
    {
        let dmut values = Vec!{&Value}::new ();
        let mut useAlias = false;

        let type = a.getInners ()[0];
        for it in 0us .. a.getLen () {
            if (!byAlias) {
                let access = context:.getIndexOpValidator ().createArrayAccess (i.getLoc (), type, value, makeIntValue (i.getLoc (), it));
                values:.push (context.getCompileTimeInterpreter ().reduce (access));
            } else {
                let access = ArrayAccessValue::new (i.getLoc (), type, value, makeIntValue (i.getLoc (), it));
                let (fAcc, useAlias_) = if (byAlias && type.isMutable () && type.needExplicitAlias ()) {
                    (cast!{&Value} (AliaserValue::new (access.getLoc (), access.getType (), access, fromExpansion-> true)), true)
                } else {
                    (access, false)
                };

                values:.push (fAcc);
                useAlias = useAlias || useAlias_;
            }

        }

        (ExpandValue::new (i.getLoc (), values[]), useAlias)
    }

    /**
     * Validate an expansion operation on a slice value
     * @params:
     *    - context: the context of the validation
     *    - a: the slice type being expanded
     *    - value: the value to expand
     *    - i: the operator
     * @returns: the expanded value
     * */
    fn validateExpandSlice (self, dmut context : &Validator, a : &SliceType, value : &Value, i : &IntrinsicExpr, byAlias : bool)-> (&Value, bool)
        throws &ErrorMsg
    {
        let sizeType = IntType::new (i.getLoc (), size-> 0u16, signed-> false);
        let len = {
            context:.getCompileTimeInterpreter ().computeInt (StructFieldAccessValue::new (i.getLoc (), sizeType, value, SliceKeys::LEN))
        } catch {
            _ : &ErrorMsg => {
                throw ErrorMsg::fatal (i.getLoc (), format (ValidateErrorMessage::UNKNOWN_LENGTH_OF_EXPANSION, a));
            }
        }

        let dmut values = Vec!{&Value}::new ();
        let mut useAlias = false;

        let type = a.getInners ()[0];
        for it in 0us .. len.toT!{usize} () {
            let access = SliceAccessValue::new (i.getLoc (), type, value, makeIntValue (i.getLoc (), it));
            let (fAcc, useAlias_) = if (byAlias && type.isMutable () && type.needExplicitAlias ()) {
                (cast!{&Value} (AliaserValue::new (access.getLoc (), access.getType (), access, fromExpansion-> true)), true)
            } else {
                (access, false)
            };

            values:.push (fAcc);
            useAlias = useAlias || useAlias_;
        }


        (ExpandValue::new (i.getLoc (), values[]), useAlias)
    }

}
