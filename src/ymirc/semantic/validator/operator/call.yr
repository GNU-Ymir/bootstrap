
mod ymirc::semantic::validator::operator::call;

import ymirc::semantic::validator::visitor;
import ymirc::semantic::validator::errors;
import ymirc::semantic::validator::scores;
import ymirc::semantic::validator::template::_;
import ymirc::errors::_;
import ymirc::utils::format;

import ymirc::semantic::symbol::_;
import ymirc::semantic::generator::value::_;
import ymirc::semantic::generator::type::_;
import ymirc::semantic::generator::value::expandvalue;
import ymirc::lexing::word;
import ymirc::lexing::tokens;

import ymirc::syntax::keys;
import ymirc::syntax::declaration::_;
import ymirc::syntax::expression::_;


import std::collection::vec;
import std::fs::path;
import std::io;

/**
 * The call validator is used to validate MultOpExpr
 * It is a class validator because call operations are complex
 */
pub class CallOpValidator {

    /**
     * Create an empty validator     
     */
    pub self () {}

    /**
     * Validate a call expression
     * @params: 
     *  - context: the context of the validation
     *  - mult: the mult operator to validate
     * @returns: a value
     * @throws: 
     *    - &ErrorMsg: if the validation failed
     */
    pub def validate (self, dmut context : &Validator, mult : &MultOperatorExpr) -> &Value
        throws &ErrorMsg
    {
        let (left, rightDot) = self.validateLeftOperand (alias context, mult.getLeft (), mult.canBeDotCall ());
        let rights = self.validateRightOperands (alias context, mult.getRights (), rightDot);

        self.validate (alias context, mult.getLoc (), left, rights)
    }

    /**
     * Validate a mult expression
     * @params: 
     *    - context: the context of the validation
     *    - left: the left operand of the operation
     *    - right: the right operand of the operation
     * @returns: the result value
     * @throws:
     *    - &ErrorMsg: if the validation failed
     */
    pub def validate (self, dmut context : &Validator, loc : &Word, left : &Value, rights : [&Value])-> &Value
        throws &ErrorMsg
    {
        let value : &MultSymValue = match left {
            m : &MultSymValue => { m }
            tmp : _ => { MultSymValue::new (tmp.getLoc (), [tmp], prettyStr-> format ("%", tmp)) }
        };

        self.validateMultSym (alias context, loc, value, rights)._0
    }
    

    /**
     * ================================================================================
     * ================================================================================
     * =========================         LEFT OPERAND         =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate the left operand of the mult operator
     * @params: 
     *   - context: the context of the validation
     *   - left: the left operand to validate
     *   - canBeDotCall: true iif the left expression can be a dot call syntax
     * @returns: 
     *   - .0: the value of the left operand
     *   - .1: the list of parameters to add to the right operand (applicable only iif dot call)
     */
    def validateLeftOperand (self, dmut context : &Validator, left : &Expression, canBeDotCall : bool)-> (&Value, [&Value])
        throws &ErrorMsg
    {
        {
            let l = context:.validateValue (left);
            return (l, []);
        } catch {
            err : &ErrorMsg => {
                if (canBeDotCall) { // If left was not correct, maybe it is a dotCall syntax
                    return self.validateDotCall (alias context, left, err);                    
                } else throw err;
            }
        }
    }

    /**
     * Try to validate a dot call expression
     * @params: 
     *   - context: the context of the validation
     *   - left: the left operand of the mult operation
     *   - err: the error that occured when validating without trying dot call
     * @returns: 
     *   - .0: the left operand of the expression
     *   - .1: the list of parameters to add to the mult operators (len == 1us, or throws)
     * @throws: &ErrorMsg, if this is not a dot call
     */
    def validateDotCall (self, dmut context : &Validator, left : &Expression, err : &ErrorMsg)-> (&Value, [&Value])
        throws &ErrorMsg
    {
        let (leftSynt, rightSynt) = self.rewriteDotCallSyntax (alias context, left, err);
        let lval = {
            context:.validateValue (leftSynt)
        } catch {
            // Just throw the error passed as parameter, it should be almost the same, so no need to add an error
            ErrorMsg () => throw err; 
        };

        let rval = {
            context:.validateValue (rightSynt)
        } catch {
            rerr : &ErrorMsg => {
                // We add the error, in case the user really wanted a dot call but the function is miswritten or something
                let note = ErrorMsg::note (rightSynt.getLoc (), ValidateErrorMessage::UFC_REWRITING, notes-> [rerr]);
                throw ErrorMsg::list ([note, err]);
            }
        };

        (rval, [lval])
    }

    /**
     * Try to transform unwrap 'left' to get two elements for dot call validation      
     * @params:
     *    - context: the context of the validation
     *    - left: the left operand of the mult operation
     *    - err: the error to throw if the unwrapping fails
     * @returns: 
     *    - .0: the first parameter of the call (element on the left of the dot call)
     *    - .1: the function to call 
     * @throws: 
     *   - &ErrorMsg: parameter err, if the unwrap fails, and thus this is not a dot call
     */
    def rewriteDotCallSyntax (self, dmut _ : &Validator, left : &Expression, err : &ErrorMsg)-> (&Expression, &Expression)
        throws &ErrorMsg
    {
        match left {
            bin : &BinaryExpr => { 
                if (bin.getLoc () == Tokens::DOT_AND) { // rewrite (a:.b)
                    let intr : &Expression = IntrinsicExpr::new (left.getLoc (), IntrinsicKeys::ALIAS, bin.getLeft ());
                    (intr, bin.getRight ())               
                } else if (bin.getLoc () == Tokens::DOT){ // rewritte (a.b)
                    (bin.getLeft (), bin.getRight ())
                } else throw err;
            }
            t : &TemplateCallExpr => {
                match t.getLeft () { 
                    bin : &BinaryExpr => { 
                        if (bin.getLoc () == Tokens::DOT_AND) { // rewritte ( (a:.b)!{params} )
                            let intr : &Expression = IntrinsicExpr::new (left.getLoc (), IntrinsicKeys::ALIAS, bin.getLeft ());
                            let right : &Expression = TemplateCallExpr::new (t.getLoc (), bin.getRight (), t.getRights ());
                            (intr, right)               
                        } else if (bin.getLoc () == Tokens::DOT) { // rewritte ( (a.b)!{params} )
                            let right : &Expression = TemplateCallExpr::new (t.getLoc (), bin.getRight (), t.getRights ());
                            (bin.getLeft (), right)
                        } else throw err;
                    }
                    _ => throw err;                    
                }
            }
            _ => throw err;
        }
    }
    
    /**
     * ================================================================================
     * ================================================================================
     * =========================       RIGHT OPERANDS         =========================
     * ================================================================================
     * ================================================================================
     */


    /**
     * Validate the right operands
     * @params: 
     *   - context: the context of the validation
     *   - rightOps: the list of right operands
     *   - validated: the list of values already validated by Dot call syntax
     * @returns: the list of right operands
     */
    def validateRightOperands (self, dmut context : &Validator, rightOps : [&Expression], validated : [&Value])-> [&Value]
        throws &ErrorMsg
    {
        let dmut errors = Vec!{&ErrorMsg}::new ();
        let dmut rights = Vec!{&Value}::new ();
        
        for r in validated { rights:.push (r); }        
        for r in rightOps {
            {
                let v = context:.getValueValidator ().validate (alias context, r, canBeRef-> true);
                match v {
                    e : &ExpandValue => {
                        for i_v in e.getInnerValues () rights:.push (i_v); 
                    }
                    _ => {
                        rights:.push (v);
                    }
                }            
            } catch {
                err : &ErrorMsg => {
                    errors:.push (err);
                }
            }
        }

        if (errors.len () != 0us) throw ErrorMsg::list (errors[]);

        rights []
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================           MULTSYM            =========================
     * ================================================================================
     * ================================================================================
     */
    
    /**
     * Validate the calling where the values left and rights are already validated, and the left value is a multsym
     * @params: 
     *   - context: the context of the validation
     *   - loc: the location of the operator
     *   - left: the left operand
     *   - rights: the right operands
     * @returns: 
     *   - .0: a value
     *   - .1: the score of the validation
     * @throws: if the operation is impossible
     */
    def validateMultSym (self, dmut context : &Validator, loc : &Word, left : &MultSymValue, rights : [&Value])-> (&Value, u32)
        throws &ErrorMsg
    {
        let prettyName = self.prettyName (left);
        let (nonTemplates, templates) = self.divideByPriority (left.getValues ()); // non template values have higher priorities than template ones, so if there can be called then no need to validate template ones
        let (call, res, score) = {
            self.validateValueList (alias context, loc, prettyName, nonTemplates, rights)
        } catch { // there is no need to worry of empty list, it is managed in validateValueList
            err : &ErrorMsg => { // there is no value in non template values that works with rigths
                if (templates.len != 0us) {
                    {
                        let (call, res, rewrite, score) = self.validateValueTemplateList (alias context, loc, prettyName, templates, rights); // so we try the template values
                        if (res.len == 1us) { // there is only success validation, then we finalize the validation of the template symbol (@assert, res.len != 0us, or an error is thrown by 'validateValueTemplateList')
                            context:.getTemplateDeclarator ().declare (alias context, loc, rewrite [0us], call [0us]);
                        }
                        
                        (call, res, score)
                    } catch { // there is no need to worry of empty list here either, it is managed in validateValueList
                        templateError : &ErrorMsg => { // Does not work with both template and non templates
                            if (nonTemplates.len != 0us)  throw ErrorMsg::list ([err, templateError]);
                            else throw templateError;
                        }
                    }
                } else throw err;
            }
        };

        if (res.len != 1us) { // there are more than one success in the call validation, so we need to throw the error of 'works with both'
            // This error is not managed in validateValueList, because we don't want to validate templates when it occurs
            let dmut errors = Vec!{&ErrorMsg}::new ();
            for i in 0us .. call.len {
                errors:.push (ErrorMsg::note (call[i].getLoc (), format (ValidateErrorMessage::CANDIDATE_ARE, self.prettyName (call[i])), oneLine-> true));
            }        
            
            throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::WORKS_WITH_BOTH, prettyName, rights), notes-> errors[]);
        }

        // Only one success ! we return it
        (res [0us], score)
    }

    /**
     * Validate a call on a list of values, where only the values with the highest score are called
     * @params: 
     *    - context: the context of the validation
     *    - loc: the loc of the call
     *    - prettyName: the pretty name to use in error throwing
     *    - lefts: the list of values to call
     *    - rights: the list of values used as right operands
     * @returns:
     *    - .0: the list of values that are called with highest score (left[i])
     *    - .1: the list of call values (validation of: left[i] (rights))
     *    - .2: the score of the call (the highest one)
     * @throws:
     *    - &ErrorMsg: if no value can be called
     */
    def validateValueList (self, dmut context : &Validator, loc : &Word, prettyName : [c8], lefts : [&Value], rights : [&Value])-> ([&Value], [&Value], u32)
        throws &ErrorMsg
    {
        let dmut results = Vec!{&Value}::new (); // stores the list of call validation (left[i] (rigths)
        let dmut call = Vec!{&Value}::new (); // stores the list of used values (left[i])
        let mut highestScore = 0u32;
        let dmut errors = Vec!{&ErrorMsg}::new ();

        for it in lefts { // traverse all the candidates
            { 
                let (gen, score) = self.validateCall (alias context, loc, it, rights, candidate-> true); // try to use it
                if (score > highestScore) { // It works and has a better score than previous candidates
                    highestScore = score;
                    results:.clear (); // all the last success are removed, they have a lesser score
                    call:.clear ();
                    results:.push (gen);
                    call:.push (it);
                } else if (score == highestScore) { // It works and has the same score
                    results:.push (gen);
                    call:.push (it);
                } // Does work, but with a lesser score, just skip it
            } catch {
                err : &ErrorMsg => { // Does not work
                    errors:.push (err); // we store the error, if no candidate works we need to use the error
                }
            }
        }
        
        if (results.len () == 0us) { // No candidates work, we throw all the stored errors
            throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_CALL_OP, prettyName, self.formatParamsWithTypes (rights)), notes-> errors[])
        }

        // Some values succeeded in the call, so we return them, along with the score they generate
        (call[], results[], highestScore)                    
    }

    /**
     * Validate a call on a list of template ref values, where only the values with the highest score are called (and validated)
     * @params: 
     *    - context: the context of the validation
     *    - loc: the loc of the call
     *    - prettyName: the pretty name to use in error throwing
     *    - lefts: the list of values to call
     *    - rights: the list of values used as right operands
     * @returns:
     *    - .0: the list of values that are called with highest score (left[i])
     *    - .1: the list of call values (validation of: left[i] (rights))
     *    - .2: the rewritters to use to create the final symbols needed for the calls
     *    - .3: the score of the call (the highest one)
     * @throws:
     *    - &ErrorMsg: if no value can be called
     */
    def validateValueTemplateList (self, dmut context : &Validator, loc : &Word, prettyName : [c8], lefts : [&TemplateRefValue], rights : [&Value])-> ([&Value], [&Value], [&TemplateRewriter], u32)
        throws &ErrorMsg
    {
        // We store the results inside a vector, where to each valid values is associated the correct rewritter
        let dmut results = Vec!{&Value}::new (); // stores the list of call validation (left[i] (rigths)
        let dmut call = Vec!{&Value}::new (); // stores the list of used values (left[i])
        let dmut syms = Vec!{&TemplateRewriter}::new (); // stores the list of generated symbols
        let mut highestScore = 0u32;
        let dmut errors = Vec!{&ErrorMsg}::new ();
        for it in lefts {
            {
                let (value, sym, score) = self.validateTemplateCall (alias context, loc, it, rights, candidate-> true);
                if (score > highestScore) { // It works and has a better score than previous candidates
                    highestScore = score;
                    results:.clear (); // all the last success are removed, they have a lesser score
                    call:.clear ();
                    syms:.clear ();
                    results:.push (value);
                    call:.push (it);
                    syms:.push (sym);
                } else if (score == highestScore) { // It works and has the same score
                    results:.push (value);
                    call:.push (it);
                    syms:.push (sym);
                }
            } catch {
                err : &ErrorMsg => { // does not work
                    errors:.push (err);
                }
            }
        }

        if (results.len () == 0us) { // No candidates work, we throw all the stored errors
            throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_CALL_OP, prettyName, self.formatParamsWithTypes (rights)), notes-> errors[])
        }
        
        // Some values succeeded in the call, so we return them, along with the score they generate
        (call[], results[], syms[], highestScore)                    
    }
    
    /**
     * ================================================================================
     * ================================================================================
     * =========================           CALLING            =========================
     * ================================================================================
     * ================================================================================
     */


    /**
     * Validate the calling where the values left and rights are already validated
     * @params: 
     *   - context: the context of the validation
     *   - loc: the location of the operator
     *   - left: the left operand
     *   - rights: the right operands
     * @returns: 
     *   - .0: a value
     *   - .1: the score of the validation
     * @throws: if the operation is impossible
     */
    def validateCall (self, dmut context : &Validator, loc : &Word, left : &Value, rights : [&Value], candidate : bool = true)-> (&Value, u32)
        throws &ErrorMsg
    {
        match left.getType () {
            FuncPtrType () => { self.validateFuncPtrType (alias context, loc, left, rights, candidate-> candidate) }
            dl : &DelegateType => { self.validateDelegateType (alias context, loc, dl, left, rights, candidate-> candidate) }
            _ => {                    
                match left {
                    m : &MethodDelegateValue => {
                        self.validateMethodDelegateCall (alias context, loc, m, rights, candidate-> candidate)
                    }
                    m : &CtorDelegateValue => {
                        self.validateCtorDelegateCall (alias context, loc, m, rights, candidate-> candidate) 
                    }
                    f : &PrototypeValue => {
                        self.validatePrototype (alias context, loc, f, rights, candidate-> candidate)
                    }
                    v : &VarRefValue => {
                        if (!v.getValue ().isOf!{&NoneValue} ()) {
                            self.validateCall (alias context, loc, v.getValue (), rights, candidate-> candidate)
                        } else {
                            throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_CALL_OP, self.prettyName (left), self.formatParamsWithTypes (rights)))
                        }
                    }
                    l : &LambdaValue => {
                        self.validateLambdaCall (alias context, loc, l, rights, candidate-> candidate)
                    }
                    _ => {
                        throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_CALL_OP, self.prettyName (left), self.formatParamsWithTypes (rights)))
                    }
                    // l : &LambdaValue => {}
                }
            }
        }
    }

    /**
     * Divide the list of values into two lists where the first list values have higher priorities than those in the right one
     * @info: this function places template values in the right list
     * @params:
     *    - list: the list of values to divide
     * @returns: 
     *    - .0: the list of values with high priority
     *    - .1: the list of values with low priority     
     */
    def divideByPriority (self, list : [&Value])-> ([&Value], [&TemplateRefValue]) {
        let dmut left = Vec!{&Value}::new ();
        let dmut right = Vec!{&TemplateRefValue}::new ();
        for i in list match i {
            t : &TemplateRefValue => { right:.push (t); }
            _ => { left:.push (i); }
        }

        (left[], right[])
    }        

    /**
     * ================================================================================
     * ================================================================================
     * =========================     FUNCTION PROTOTYPE       =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a function prototype call
     * @params: 
     *    - context: the context of the validation
     *    - loc: the location of the call
     *    - left: the left operand
     *    - rights: the right operands
     *    - candidate: add the candidate_are not in case of failure ?
     * @returns: 
     *   - .0: the call
     *   - .1: the score of the call
     * @throws: &ErrorMsg, if the call is not possible
     */
    def validatePrototype (self, dmut context : &Validator, loc : &Word, left : &PrototypeValue, rights : [&Value], candidate : bool = false)-> (&Value, u32)
        throws &ErrorMsg
    {
        let (params, rest) = self.validateParameterList (left.getParameters (), rights);
        if (rest.len != 0us && !left.isCVariadic ()) {
            let dmut err = Vec!{&ErrorMsg}::new ();
            for it in rest {
                match it {
                    n : &NamedValue => {
                        err:.push (ErrorMsg::fatal (it.getLoc (), format (ValidateErrorMessage::NO_PARAMETER_NAMED, n.getName ())));
                    }
                }
            }

            if ((params.len + rest.len) != left.getParameters ().len) {
                throw ErrorMsg::fatal (loc, format (if (params.len + rest.len == 1us)  { ValidateErrorMessage::TOO_FEW_PARAMETERS_ONE } else { ValidateErrorMessage::TOO_FEW_PARAMETERS}, left.getParameters ().len, params.len + rest.len), notes-> err[]);
            } else {
                throw ErrorMsg::list (err[]);
            }
        } else if (params.len != left.getParameters ().len) {
            throw ErrorMsg::fatal (loc, format (if (params.len == 1us)  { ValidateErrorMessage::TOO_FEW_PARAMETERS_ONE } else { ValidateErrorMessage::TOO_FEW_PARAMETERS}, left.getParameters ().len, params.len));
        }

        let (_, n_params, score) = self.validateTypeParameterList (alias context, loc, left.getParameters (), params, verifType-> true, verifMemory-> true, isLambda-> false);

        (CallValue::new (loc, left.getRetType (), left, n_params, addParams-> rest), score)
    } catch {
        err : &ErrorMsg => {
            if (!candidate) throw err;
            throw ErrorMsg::note (left.getLoc (), format (ValidateErrorMessage::CANDIDATE_ARE, self.prettyName (left)), notes-> [err], oneLine-> true);
        }
    }

    /**
     * Validate the list of paramters where prototype only have types, (e.g. delegate or funcptr)
     * @params:
     *    - arguments: the list of parameters of the prototype
     *    - parameters: the list of parameters used to call the prototype
     * @returns: the score of the call
     * @throws: &ErrorMsg, if the parameters are not usable
     */
    def validateTypeParameterList (self, dmut context : &Validator, references : [bool], arguments : [&Type], parameters : [&Value])-> ([&Value], u32)
        throws &ErrorMsg
    {
        let dmut errors = Vec!{&ErrorMsg}::new ();
        let mut score = 0u32;
        let dmut values = Vec!{&Value}::new ();
        
        for i in 0us .. arguments.len {
            {
                let ch = context:.verifyCompatibleTypeWithValue (parameters [i].getLoc (), arguments [i], parameters [i]);
                context:.verifyMemoryOwner (parameters [i].getLoc (), arguments [i], ch, construct-> true, byReference-> references [i]);
                values:.push (ch);
                
                score += Scores::TYPE;
                let llevel = parameters [i].getType ().mutabilityLevel ();
                let rlevel = arguments [i].mutabilityLevel () + 1u32;
                if (rlevel > llevel) {
                    score += rlevel - llevel;
                }            
            } catch {
                err : &ErrorMsg => {
                    errors:.push (err);
                }
            }
        }

        if (errors.len () != 0us) throw ErrorMsg::list (errors[]);        
        (values[], score)
    }
    
    /**
     * Validate the list of parameters 
     * @params: 
     *   - arguments: the list of parameters of the prototype
     *   - parameters: the list of values passed to the call
     * @returns: 
     *   - .0: the list of parameters (in the correct order)
     *   - .1: the list of parameters that are associated to no arguments (in the correct order)
     */
    def validateParameterList (self, arguments : [&ProtoVarValue], parameters : [&Value])-> ([&Value], [&Value])
        // throws &ErrorMsg
    {
        let dmut result = Vec!{&Value}::new ();
        let mut rest = parameters;
        for i in 0us .. arguments.len {
            let indexes = self.findParameter (rest, arguments [i]);
            if (indexes.len == 0us) return (result[], rest);
            
            if indexes.len != 1us { __pragma!panic (); }
            for index in indexes {
                result:.push (index._1);
                if (index._0 < rest.len) { // the inserted parameters is not a default param, thus we need to remove it from the list
                    rest = rest [0us .. index._0] ~ rest [(index._0 + 1us) .. $];
                }
            }
        }

        (result[], rest)
    }

    /**
     * Validate the type of the parameters
     * @params: 
     *   - context: the context of the validation
     *   - loc: the location of the call
     *   - arguments: the list of arguments of the prototype
     *   - parameters: the list of parameters passed to the prototype
     *   - verifType: verify the equality of the types
     *   - verifMemory: verify that the memory const, alias, etc are respected
     *   - isLambda: the prototype is a lambda prototype
     * @returns: 
     *   - .0: the list of types of the parameters
     *   - .1: the score of the call
     */
    def validateTypeParameterList (self, dmut context : &Validator, loc : &Word, arguments : [&ProtoVarValue], parameters : [&Value], verifType : bool = true, verifMemory : bool = true, isLambda : bool = false)-> ([&Type], [&Value], u32)
        throws &ErrorMsg
    {
        let dmut types = Vec!{&Type}::new ();
        let dmut values = Vec!{&Value}::new ();
        let dmut errors = Vec!{&ErrorMsg}::new ();
        let mut score = 0u32;

        for i in 0us .. arguments.len {
            let argType = arguments[i].getType ();
            let paramType = parameters [i].getType ();
            
            if (isLambda && argType.isOf!{&NoneType} ()) {
                types:.push (parameters [i].getType ().clone (isMutable-> false));
            } else {
                {
                    let ch = if (verifType) {
                        context:.verifyCompatibleTypeWithValue (parameters [i].getLoc (), argType, parameters [i])
                    } else {
                        parameters [i]
                    }

                    if (verifMemory) {
                        context:.verifyMemoryOwner (parameters [i].getLoc (), argType, ch, construct-> true, byReference-> arguments [i].isReference ());
                    }

                    values:.push (ch);
                    
                    score += Scores::TYPE;
                    let llevel = paramType.mutabilityLevel ();
                    let rlevel = argType.mutabilityLevel () + 1u32;
                    if (rlevel > llevel) {
                        score += rlevel - llevel;
                    }
                } catch {
                    err : &ErrorMsg => {
                        errors:.push (err.withNote ([ErrorMsg::note (loc, format (ValidateErrorMessage::PARAMETER_NAME, arguments [i]), oneLine-> true)]));
                    }
                }
            }
        }

        if (errors.len () != 0us) throw ErrorMsg::list (errors[]);

        (types[], values[], score)
    }


    /**
     * Find the parameter in the list that is associated to the var
     * @params: 
     *   - parameters: a list of value that are passed to the call
     *   - var: the protovar that is called
     * @returns: a array composed of : (it's an array because in case of Variadic/tuple var, multiple values can be consumed)
     *    - .0: the index of the value to use
     *    - .1: the value to use
     */
    def findParameter (self, parameters : [&Value], var : &ProtoVarValue)-> [(usize, &Value)] {
        if (var.getNbConsume () == 1us) { // non template validation        
            let (i, v) = self.findSingleParameter (parameters, var);
            match v {
                NoneValue () => { [] }
                _ => { [(i, v)] }
            }
        } else {
            __pragma!panic ();
        }
    }
    
    /**
     * Find the parameter in the list that is associated to the var
     * @params: 
     *    - parameters: the list of parameters
     *    - var: the protovar that is called
     * @returns: 
     *    - .0: the index of the value to use
     *    - .1: the value to use
     */
    def findSingleParameter (self, parameters : [&Value], var : &ProtoVarValue, canBeNamed : bool = true)-> (usize, &Value) {
        let mut toRet = parameters.len, mut pos = true;
        for i, p in parameters {
            match p {
                n : &NamedValue => {
                    if (n.getName () == var.getName () && canBeNamed) {
                        toRet = i;
                        pos = false;
                        break {}
                    }
                }
                _ => {
                    if (toRet == parameters.len) {
                        toRet = i;
                    }
                }
            }
        }

        if (toRet == parameters.len || pos) {
            if (!var.getDefaultValue ().isOf!{&NoneValue} ()) {
                return (parameters.len, var.getDefaultValue ());
            }
        }

        if (toRet != parameters.len) {
            (toRet, parameters [toRet])
        } else {
            (parameters.len, NONE_VALUE)
        }
    }
    
    
    /**
     * ================================================================================
     * ================================================================================
     * =========================      FPTR AND DELEGATE       =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a function pointer call
     * @params: 
     *    - context: the context of the validation
     *    - loc: the location of the call
     *    - left: the left operand
     *    - rights: the right operands
     *    - candidate: add the candidate_are not in case of failure ?
     * @returns: 
     *   - .0: the call
     *   - .1: the score of the call
     * @throws: &ErrorMsg, if the call is not possible
     */
    def validateFuncPtrType (self, dmut context : &Validator, loc : &Word, left : &Value, rights : [&Value], candidate : bool = false)-> (&Value, u32)
        throws &ErrorMsg
    {
        context;
        loc;
        left;
        rights;
        candidate;
        __pragma!fake_throw (&ErrorMsg);
        __pragma!panic ();
    }
    
    /**
     * Validate a delegate call
     * @params: 
     *    - context: the context of the validation
     *    - loc: the location of the call
     *    - left: the left operand
     *    - rights: the right operands
     *    - candidate: add the candidate_are not in case of failure ?
     * @returns: 
     *   - .0: the call
     *   - .1: the score of the call
     * @throws: &ErrorMsg, if the call is not possible
     */
    def validateDelegateType (self, dmut context : &Validator, loc : &Word, delegate : &DelegateType, left : &Value, rights : [&Value], candidate : bool = false)-> (&Value, u32)
        throws &ErrorMsg
    {
        {
            if (delegate.getParameters ().len != rights.len) {
                let msg = if (rights.len == 1us) {
                    ValidateErrorMessage::TOO_FEW_PARAMETERS_ONE
                } else {
                    ValidateErrorMessage::TOO_FEW_PARAMETERS
                };
                
                throw ErrorMsg::fatal (loc, format (msg, delegate.getParameters ().len, rights.len));
            }
            
            let (n_params, score) = self.validateTypeParameterList (alias context, delegate.getReferences (), delegate.getParameters (), rights);
            let fptr = FuncPtrType::new (loc, delegate.getReferences (), delegate.getParameters (), delegate.getRetType ());
            let clPtr = PointerType::new (loc, VoidType::new (loc)); 
            
            let uniq = UniqValue::new (loc, left);
            let fstParam : &Value = StructFieldAccessValue::new (loc, clPtr, uniq, DelegateKeys::CLOSURE);
            let func = StructFieldAccessValue::new (loc, fptr, uniq, DelegateKeys::FUNC);
            
            (FuncPtrCallValue::new (loc, delegate.getRetType (), func, [fstParam] ~ n_params), score)
        } catch {
            err : &ErrorMsg => {
                if (!candidate) throw err;
                throw ErrorMsg::note (left.getLoc (), format (ValidateErrorMessage::CANDIDATE_ARE, self.prettyName (left)), notes-> [err], oneLine-> true);
            }
        }
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================            METHOD             ========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate the call of a method of a class
     * @params:
     *     - context: the context of the validation
     *     - loc: the location of the call
     *     - rights: the right operands
     *     - candidate: add the candidate_are error in case of failure ?
     * @returns:
     *     - .0: the call
     *     - .1: the score of the call
     * @throws: &ErrorMsg, if the call is impossible
     */
    def validateMethodDelegateCall (self, dmut context : &Validator, loc : &Word, meth : &MethodDelegateValue, rights : [&Value], candidate : bool = false)-> (&Value, u32)
        throws &ErrorMsg
    {
        let (call, score) = self.validatePrototype (alias context, loc, meth.getPrototype (), rights, candidate-> candidate);
        match call {
            c : &CallValue => {
                (MethodCallValue::new (c.getLoc (), c.getType (), meth, c.getParameters (), addParams-> c.getAddParameters ()), score)
            }
            _ => __pragma!panic ();
        }
    }
    
    /**
     * ================================================================================
     * ================================================================================
     * =========================            CTORS             =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate the call of a ctor of a class
     * @params: 
     *    - context: the context of the validation
     *    - loc: the location of the call
     *    - ctor: the ctor to call
     *    - rights: the right operands
     *    - candidate: add the candidate_are error in case of failure ?
     * @returns: 
     *   - .0: the call
     *   - .1: the score of the call
     * @throws: &ErrorMsg, if the call is not possible
     */
    def validateCtorDelegateCall (self, dmut context : &Validator, loc : &Word, ctor : &CtorDelegateValue, rights : [&Value], candidate : bool = false)-> (&Value, u32)
        throws &ErrorMsg
    {        
        let (call, score) = self.validatePrototype (alias context, loc, ctor.getPrototype (), rights, candidate-> candidate);
        match call {
            c : &CallValue => { // It should be a call, otherwise an error has been thrown
                (CtorCallValue::new (c.getLoc (), ctor.getType (), ctor, c.getParameters (), addParams-> c.getAddParameters ()), score) // replace the prototype by the delegate
            }
            _ => { __pragma!panic (); }
        }
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================          TEMPLATES           =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a call where left value is a template, and thus needs a specialization
     * @params: 
     *    - context: the context of the validation
     *    - loc: the location of the call
     *    - left: the template value
     *    - rights: the list of values used to call the template value
     *    - candidate: if true add the candidate_are error in case of failure (for multsym error handling)
     * @returns: 
     *    - .0: the call value
     *    - .1: the symbol that was created by the template validation
     *    - .2: the score of the call
     * @throws: 
     *    - &ErrorMsg: if the call if not possible
     */
    def validateTemplateCall (self, dmut context : &Validator, loc : &Word, left : &TemplateRefValue, rights : [&Value], candidate : bool = false)-> (&Value, &TemplateRewriter, u32)
        throws &ErrorMsg
    {
        match left.getSymbol ().getContent ().getContent () {
            f : &FunctionDecl => {
                return self.validateTemplateCallFunction (alias context, loc, left, f, rights, candidate-> candidate);
            }
            x : _ => {
                println (format ("TODO : %", x));
                __pragma!panic ();
            }
        }
    }

    /**
     * Validate a call on a template value that contains a function declaration
     * @params: 
     *    - context: the context of the declaration
     *    - loc: the location of the call
     *    - left: the template ref that is called
     *    - func: the function contained in the template ref (left.getSymbol ().getContent ().getContent ())
     *    - rigths: the list of parameters passed to the call
     * @returns: 
     *    - .0: the call value
     *    - .1: the symbol that was created by the template validation
     *    - .2: the score of the call
     * @throws: 
     *    - &ErrorMsg: if the call failed (from template solving, declaration, or simply cannot be called with the parameters)
     */
    def validateTemplateCallFunction (self, dmut context : &Validator, loc : &Word, left : &TemplateRefValue, func : &FunctionDecl, rights : [&Value], candidate : bool = false)-> (&Value, &TemplateRewriter, u32)
        throws &ErrorMsg
    {
        {
            // the function is not validated thus we don't have real prototype to use, so we transform the informations we have into something usable
            let argList = self.createTemplatePrototypeValues (alias context, left, func.getFunctionProto ().getParameters ()); 
            let (params, rest) = self.validateParameterList (argList, rights); // we use the fake prototype to sort the parameters, at least we have the names
            
            // Perform the template specialization, and get the rewritter, and the finalParameters (in the correct order, and tupled if needed)
            let (rewriter, finalParams) = context:.getTemplateSolver ().validateImplicitValue (alias context, loc, left, params ~ rest);

            {
                // Validate the rewrite of the prototype (only the prototype, in order to get the score)
                let (proto, hasTest) = self.createPrototypeFromTemplateRewriter (alias context, loc, left, rewriter, func);

                // Verify that the template specialization effectively worked as expected and formatted the parameters
                if (proto.getParameters ().len != finalParams.len) {
                    throw ErrorMsg::fatal (loc, format (if (proto.getParameters ().len == 1us)  { ValidateErrorMessage::TOO_FEW_PARAMETERS_ONE } else { ValidateErrorMessage::TOO_FEW_PARAMETERS}, proto.getParameters ().len, finalParams.len));
                }
                
                // Normal call can be performed now
                let (_, n_params, score) = self.validateTypeParameterList (alias context, loc, proto.getParameters (), finalParams, verifType-> true, verifMemory-> true, isLambda-> false);
                
                // We have a call, a rewriter and a score to return
                (CallValue::new (loc, proto.getRetType (), proto, n_params), rewriter, score + rewriter.getScore () + if (hasTest) { 1u32 } else { 0u32 })
            } catch {
                err : &ErrorMsg => {
                    let nErr = err.withNote ([ErrorMsg::note (loc, format (ValidateErrorMessage::TEMPLATE_SPE, rewriter), oneLine-> true)]);
                    throw nErr;
                }
            }
        } catch {
            err : &ErrorMsg => {
                if (!candidate) throw err; // as for normal call, template call might be in multsymbol, so we don't add candidate error
                throw ErrorMsg::note (left.getLoc (), format (ValidateErrorMessage::CANDIDATE_ARE, self.prettyName (left)), notes-> [err], oneLine-> true); // alone call, add the candidate are error
            }
        }
    }


    /**
     * Create a list of prototype value from an unvalidated function
     * @params: 
     *    - context: the context of the validation
     *    - arguments: the list of expression of the prototype
     * @returns: the list of protovalues
     */
    def createTemplatePrototypeValues (self, dmut context : &Validator, left : &TemplateRefValue, arguments : [&Expression])-> [&ProtoVarValue]
    {
        let dmut result = Vec!{&ProtoVarValue}::new ();        
        context:.pushReferent (alias context:.getSymbolFromRef (left.getSymbol ())); // we push the referent to be in the template prototype context
        context:.enterForeign (isFnBody-> false);
        
        for arg in arguments { 
            context:.enterBlock ();
            
            // We validate what can be validated, and let what cannot be validated as it is
            let (isMut, isRef, type, value) = context:.getFunctionValidator ().validateTemplateParamDecl (alias context, arg);  
            let paramGen = ProtoVarValue::new (arg.getLoc (), type, value, isMut, isRef, isSelf-> false);
            result:.push (paramGen);            
            {
                context:.quitBlock (warnUnused-> false);
            } catch { _ => __pragma!panic (); }
        }
    
        context:.exitForeign ();
        context:.popReferent ();


        result[]
    }

    /**
     * Create a prototype from a template rewritting, without declaring the rewritten template
     * This is used to verify that the symbol can be called before trying to declare the function
     * @params: 
     *    - context: the context of the validation
     *    - templateRef: the symbol declaring the template
     *    - rewriter: the rewriter generated by template solving
     *    - func: the function to rewrite
     * @returns: the prototype value 
     * @throws: 
     *    - &ErrorMsg: if the validation fails
     */
    def createPrototypeFromTemplateRewriter (self, dmut context : &Validator, loc : &Word, templateRef : &TemplateRefValue, rewriter : &TemplateRewriter, func : &FunctionDecl)-> (&PrototypeValue, bool)
        throws &ErrorMsg
    {
        self.checkComplete (rewriter, templateRef);

        let test = rewriter.rewrite (templateRef.getSymbol ().getContent ().getTest ());
        context:.getTemplateDeclarator ().validateTemplateTest (alias context, loc, templateRef, test); // If the template has a test, we have to check if it pass before returning a prototype value
        
        let decl = rewriter.rewrite (func);

        match decl {
            funcRewritten : &FunctionDecl => { // rewritten a function, and its test has passed
                let dmut sym = context:.getSymbolFromRef (templateRef.getSymbol ());
                let proto = context:.getFunctionValidator ():.validateFuncPrototypeFromTemplate (alias context, alias sym, funcRewritten, rewriter); // validate only the prototype not the body
                
                (proto, match test { 
                    EmptyExpression () => { false } // no test has been checked, so no additional score
                    _ => { true } // There was a test, so need to add some value to the specialization score
                })                
            }
            _ => __pragma!panic (); // this is not a function ?? so how do you expect a prototype
        }
    }

    /**
     * Check if the template ref value is complete and can be used to call a function
     * @params:
     *     - context: the context of the validation
     *     - rewriter: the template specialization rewriter
     *     - value: the template ref being specialized
     * @throws:
     *     - &ErrorMsg: if there are still template parameters
     * */
    def checkComplete (self, rewriter : &TemplateRewriter, value : &TemplateRefValue)
        throws &ErrorMsg
    {
        let templates = rewriter.replaceSyntaxTempl (value.getSymbol ().getContent ().getParameters ());
        if (templates.len != 0us) {
            let dmut list = Vec!{&ErrorMsg}::new ();
            for i in templates {
                list:.push (ErrorMsg::fatal (i.getLoc (), ValidateErrorMessage::UNRESOLVED_TEMPLATE));
            }
            throw ErrorMsg::list (list[]);
        }
    }

    
    /**
     * ================================================================================
     * ================================================================================
     * ==============================     LAMBDA VALUE       ==========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a call on an lambda value
     * @params:
     *    - context: the context of the validation
     *    - loc: the location of the call
     *    - lmbd: the lambda to call
     *    - rights: the parameters of the call
     *    - candidate: append the candidate error in case of failure ?
     * @returns:
     *    - .0: the call
     *    - .1: the score of the call
     * @throws: &ErrorMsg, if the call is not possible
     */
    def validateLambdaCall (self, dmut context : &Validator, loc : &Word, lmbd : &LambdaValue, rights : [&Value], candidate : bool = false)-> (&Value, u32)
        throws &ErrorMsg
    {
        if (rights.len != lmbd.getParameters ().len) {
            throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_CALL_OP, lmbd, self.formatParamsWithTypes (rights)));
        }
            
        let dmut types = Vec!{&Type}::new ();
        types:.reserve (rights.len);
        for i in rights {
            types:.push (i.getType ());
        }

        let proto = context:.getLambdaValidator ().validateLambdaBody (alias context,
                                                                       Path::new (lmbd.getName ()),
                                                                       lmbd,
                                                                       types[]);

        self.validateCall (alias context, loc, proto, rights, candidate-> candidate)
    }    
    
    /**
     * ================================================================================
     * ================================================================================
     * =========================             MISC             =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Transform a value into a printable string, with correct debug informations
     * @params: 
     *    - v: the value 
     * @returns: a string, that can be put in an error message
     */
    def prettyName (self, v : &Value)-> [c8] {
        match v {
            m : &MultSymValue => {
                if (m.getValues ().len == 1us) return self.prettyName (m.getValues ()[0]);
            }
            vdecl : &VarDeclValue => {
                match v.getType () {
                    LambdaType () => {
                        return format ("%", vdecl.getValue (), withTags-> ["withParams"s8]);
                    }
                }
            }
            vref : &VarRefValue => {
                match v.getType () {
                    LambdaType () => {
                        return format ("%", vref.getValue (), withTags-> ["withParams"s8]);
                    }
                }
            }
            p : &DelegateValue => {
                return format ("%", p.getType (), withTags-> ["withParams"s8]);
            }
            t : &TemplateRefValue => {
                match t.getSymbol ().getContent ().getContent () {
                    f : &FunctionDecl => {
                        return format ("% %%",
                                       t.getSymbol ().getPath ().toStr (sep-> "::"s8),
                                       t.getSymbol ().getContent ().getParameters (),
                                       f.getFunctionProto ());
                    }
                }
            }
        }
        
        format ("%", v, withTags-> ["withParams"s8])
    }

    /**
     * Transform right operands values, into printable string with value and types
     * @params:
     *     - v: the values to transform
     * */
    def formatParamsWithTypes (self, v : [&Value])-> [c8] {
        let dmut stream = Formatter::new ();
        stream:.write ('{');
        for i, j in v {
            if (i != 0us) stream:.write (", ");
            stream:.write (format ("%(y) : %(y)", j, j.getType ()));
        }
        stream:.write ('}');

        stream[]
    }

    
}
