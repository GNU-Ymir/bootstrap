mod ymirc::semantic::validator::operator::call;

import ymirc::semantic::validator::visitor;
import ymirc::semantic::validator::errors;
import ymirc::semantic::validator::scores;
import ymirc::semantic::validator::template::_;
import ymirc::errors::_;
import ymirc::utils::format;
import ymirc::syntax::expression::_;
import ymirc::semantic::generator::value::_;
import ymirc::semantic::generator::type::_;
import ymirc::semantic::generator::value::expandvalue;
import ymirc::lexing::word;
import ymirc::lexing::tokens;
import ymirc::syntax::keys;


import std::collection::vec;
import std::io;

/**
 * The call validator is used to validate MultOpExpr
 * It is a class validator because call operations are complex
 */
pub class CallOpValidator {

    /**
     * Create an empty validator     
     */
    pub self () {}

    /**
     * Validate a call expression
     * @params: 
     *  - context: the context of the validation
     *  - mult: the mult operator to validate
     * @returns: a value
     * @throws: 
     *    - &ErrorMsg: if the validation failed
     */
    pub def validate (self, dmut context : &Validator, mult : &MultOperatorExpr) -> &Value
        throws &ErrorMsg
    {
        let (left, rightDot) = self.validateLeftOperand (alias context, mult.getLeft (), mult.canBeDotCall ());
        let rights = self.validateRightOperands (alias context, mult.getRights (), rightDot);

        self.validate (alias context, mult.getLoc (), left, rights)
    }

    /**
     * Validate a mult expression
     * @params: 
     *    - context: the context of the validation
     *    - left: the left operand of the operation
     *    - right: the right operand of the operation
     * @returns: the result value
     * @throws:
     *    - &ErrorMsg: if the validation failed
     */
    pub def validate (self, dmut context : &Validator, loc : &Word, left : &Value, rights : [&Value])-> &Value
        throws &ErrorMsg
    {
        let (res, _) = match left {
            m : &MultSymValue => { // Mult syms are flattened
                self.validateMultSym (alias context, loc, m, rights)
            }
            _ => {
                self.validateCall (alias context, loc, left, rights)
            }
        }

        res        
    }
    

    /**
     * ================================================================================
     * ================================================================================
     * =========================         LEFT OPERAND         =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate the left operand of the mult operator
     * @params: 
     *   - context: the context of the validation
     *   - left: the left operand to validate
     *   - canBeDotCall: true iif the left expression can be a dot call syntax
     * @returns: 
     *   - .0: the value of the left operand
     *   - .1: the list of parameters to add to the right operand (applicable only iif dot call)
     */
    def validateLeftOperand (self, dmut context : &Validator, left : &Expression, canBeDotCall : bool)-> (&Value, [&Value])
        throws &ErrorMsg
    {
        {
            let l = context:.validateValue (left);
            return (l, []);
        } catch {
            err : &ErrorMsg => {
                if (canBeDotCall) { // If left was not correct, maybe it is a dotCall syntax
                    return self.validateDotCall (alias context, left, err);                    
                } else throw err;
            }
        }
    }

    /**
     * Try to validate a dot call expression
     * @params: 
     *   - context: the context of the validation
     *   - left: the left operand of the mult operation
     *   - err: the error that occured when validating without trying dot call
     * @returns: 
     *   - .0: the left operand of the expression
     *   - .1: the list of parameters to add to the mult operators (len == 1us, or throws)
     * @throws: &ErrorMsg, if this is not a dot call
     */
    def validateDotCall (self, dmut context : &Validator, left : &Expression, err : &ErrorMsg)-> (&Value, [&Value])
        throws &ErrorMsg
    {
        let (leftSynt, rightSynt) = self.rewriteDotCallSyntax (alias context, left, err);
        let lval = {
            context:.validateValue (leftSynt)
        } catch {
            // Just throw the error passed as parameter, it should be almost the same, so no need to add an error
            ErrorMsg () => throw err; 
        };

        let rval = {
            context:.validateValue (rightSynt)
        } catch {
            rerr : &ErrorMsg => {
                // We add the error, in case the user really wanted a dot call but the function is miswritten or something
                let note = ErrorMsg::note (rightSynt.getLoc (), ValidateErrorMessage::UFC_REWRITING, notes-> [rerr]);
                throw ErrorMsg::list ([note, err]);
            }
        };

        (rval, [lval])
    }

    /**
     * Try to transform unwrap 'left' to get two elements for dot call validation      
     * @params:
     *    - context: the context of the validation
     *    - left: the left operand of the mult operation
     *    - err: the error to throw if the unwrapping fails
     * @returns: 
     *    - .0: the first parameter of the call (element on the left of the dot call)
     *    - .1: the function to call 
     * @throws: 
     *   - &ErrorMsg: parameter err, if the unwrap fails, and thus this is not a dot call
     */
    def rewriteDotCallSyntax (self, dmut _ : &Validator, left : &Expression, err : &ErrorMsg)-> (&Expression, &Expression)
        throws &ErrorMsg
    {
        match left {
            bin : &BinaryExpr => { 
                if (bin.getLoc () == Tokens::DOT_AND) { // rewrite (a:.b)
                    let intr : &Expression = IntrinsicExpr::new (left.getLoc (), IntrinsicKeys::ALIAS, bin.getLeft ());
                    (intr, bin.getRight ())               
                } else { // rewritte (a.b)
                    (bin.getLeft (), bin.getRight ())
                }
            }
            t : &TemplateCallExpr => {
                match t.getLeft () { 
                    bin : &BinaryExpr => { 
                        if (bin.getLoc () == Tokens::DOT_AND) { // rewritte ( (a:.b)!{params} )
                            let intr : &Expression = IntrinsicExpr::new (left.getLoc (), IntrinsicKeys::ALIAS, bin.getLeft ());
                            let right : &Expression = TemplateCallExpr::new (t.getLoc (), bin.getRight (), t.getRights ());
                            (intr, right)               
                        } else { // rewritte ( (a.b)!{params} )
                            let right : &Expression = TemplateCallExpr::new (t.getLoc (), bin.getRight (), t.getRights ());
                            (bin.getLeft (), right)
                        }
                    }
                    _ => throw err;                    
                }
            }
            _ => throw err;
        }
    }
    
    /**
     * ================================================================================
     * ================================================================================
     * =========================       RIGHT OPERANDS         =========================
     * ================================================================================
     * ================================================================================
     */


    /**
     * Validate the right operands
     * @params: 
     *   - context: the context of the validation
     *   - rightOps: the list of right operands
     *   - validated: the list of values already validated by Dot call syntax
     * @returns: the list of right operands
     */
    def validateRightOperands (self, dmut context : &Validator, rightOps : [&Expression], validated : [&Value])-> [&Value]
        throws &ErrorMsg
    {
        let dmut errors = Vec!{&ErrorMsg}::new ();
        let dmut rights = Vec!{&Value}::new ();
        
        for r in validated { rights:.push (r); }        
        for r in rightOps {
            {
                let v = context:.validateValue (r);
                match v {
                    e : &ExpandValue => {
                        for i_v in e.getInnerValues () rights:.push (i_v); 
                    }
                    _ => {
                        rights:.push (v);
                    }
                }            
            } catch {
                err : &ErrorMsg => {
                    errors:.push (err);
                }
            }
        }

        if (errors.len () != 0us) throw ErrorMsg::list (errors[]);

        rights []
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================           MULTSYM            =========================
     * ================================================================================
     * ================================================================================
     */
    
    /**
     * Validate the calling where the values left and rights are already validated, and the left value is a multsym
     * @params: 
     *   - context: the context of the validation
     *   - loc: the location of the operator
     *   - left: the left operand
     *   - rights: the right operands
     * @returns: 
     *   - .0: a value
     *   - .1: the score of the validation
     * @throws: if the operation is impossible
     */
    def validateMultSym (self, dmut context : &Validator, loc : &Word, left : &MultSymValue, rights : [&Value])-> (&Value, u32)
        throws &ErrorMsg
    {
        let prettyName = self.prettyName (left);
        let (nonTemplates, templates) = self.divideByPriority (left.getValues ()); // non template values have higher priorities than template ones, so if there can be called then no need to validate template ones
        let (call, res, score) = {
            self.validateValueList (alias context, loc, prettyName, nonTemplates, rights)
        } catch { // there is no need to worry of empty list, it is managed in validateValueList
            err : &ErrorMsg => { // there is no value in non template values that works with rigths
                {
                    self.validateValueTemplateList (alias context, loc, prettyName, templates, rights) // so we try the template values
                } catch { // there is no need to worry of empty list here either, it is managed in validateValueList
                    templateError : &ErrorMsg => { // Does not work with both template and non templates
                        throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_CALL_OP, prettyName, rights), notes-> [err, templateError])
                    }
                }
            }
        };

        if (res.len != 1us) { // there are more than one success in the call validation, so we need to throw the error of 'works with both'
            let dmut errors = Vec!{&ErrorMsg}::new ();
            for i in 0us .. call.len {
                errors:.push (ErrorMsg::note (call[i].getLoc (), format (ValidateErrorMessage::CANDIDATE_ARE, call[i])));
            }        
            
            throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::WORKS_WITH_BOTH, prettyName, rights), notes-> errors[]);
        }

        // Only one success ! we return it
        (res[0us], score)
    }

    /**
     * Validate a call on a list of values, where only the values with the highest score are called
     * @params: 
     *    - context: the context of the validation
     *    - loc: the loc of the call
     *    - prettyName: the pretty name to use in error throwing
     *    - lefts: the list of values to call
     *    - rights: the list of values used as right operands
     * @returns:
     *    - .0: the list of values that are called with highest score (left[i])
     *    - .1: the list of call values (validation of: left[i] (rights))
     *    - .2: the score of the call (the highest one)
     * @throws:
     *    - &ErrorMsg: if no value can be called
     */
    def validateValueList (self, dmut context : &Validator, loc : &Word, prettyName : [c8], lefts : [&Value], rights : [&Value])-> ([&Value], [&Value], u32)
        throws &ErrorMsg
    {
        let dmut results = Vec!{&Value}::new (); // stores the list of call validation (left[i] (rigths)
        let dmut call = Vec!{&Value}::new (); // stores the list of used values (left[i])
        let mut highestScore = 0u32;
        let dmut errors = Vec!{&ErrorMsg}::new ();

        for it in lefts { // traverse all the candidates
            { 
                let (gen, score) = self.validateCall (alias context, loc, it, rights, candidate-> true); // try to use it
                if (score > highestScore) { // It works and has a better score than previous candidates
                    highestScore = score;
                    results:.clear (); // all the last success are removed, they have a lesser score
                    call:.clear ();
                    results:.push (gen);
                    call:.push (it);
                } else if (score == highestScore) { // It works and has the same score
                    results:.push (gen);
                    call:.push (it);
                } // Does work, but with a lesser score, just skip it
            } catch {
                err : &ErrorMsg => { // Does not work
                    errors:.push (err); // we store the error, if no candidate works we need to use the error
                }
            }
        }
        
        if (results.len () == 0us) { // No candidates work, we throw all the stored errors
            throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_CALL_OP, prettyName, rights), notes-> errors[])
        }

        // Some values succeeded in the call, so we return them, along with the score they generate
        (call[], results[], highestScore)                    
    }

    /**
     * Validate a call on a list of template ref values, where only the values with the highest score are called (and validated)
     * @params: 
     *    - context: the context of the validation
     *    - loc: the loc of the call
     *    - prettyName: the pretty name to use in error throwing
     *    - lefts: the list of values to call
     *    - rights: the list of values used as right operands
     * @returns:
     *    - .0: the list of values that are called with highest score (left[i])
     *    - .1: the list of call values (validation of: left[i] (rights))
     *    - .2: the score of the call (the highest one)
     * @throws:
     *    - &ErrorMsg: if no value can be called
     */
    def validateValueTemplateList (self, dmut context : &Validator, loc : &Word, prettyName : [c8], lefts : [&TemplateRefValue], rights : [&Value])-> ([&Value], [&Value], u32)
        throws &ErrorMsg
    {
                // We store the results inside a vector, where to each valid values is associated the correct rewritter
        let mut results : mut [mut (u32, [(&TemplateRewriter, &Value)])] = []; 
        let dmut errors = Vec!{&ErrorMsg}::new ();
        for it in lefts {
            {
                let rewriter = context:.getTemplateSolver ().validateImplicitValue (alias context, loc, it, rights);                    
                let mut found = false;
                for i in 0us .. results.len {                    
                    if (results[i]._0 == rewriter.getScore ()) {
                        (alias results)[i] = (results[i]._0, results[i]._1 ~ [(rewriter, cast!{&Value} (it))]);
                        found = true;
                        break {}
                    } else if (results[i]._0 < rewriter.getScore ()) {
                        results = alias ((alias results[0us .. i] ~ [(rewriter.getScore (), [(rewriter, cast!{&Value} (it))])]) ~ results[i .. $]);
                        found = true;
                        break {}
                    }
                }

                if (!found) results = alias (results ~ [(rewriter.getScore (), [(rewriter, cast!{&Value} (it))])]);
            } catch {
                err : &ErrorMsg => { // does not work
                    errors:.push (err);
                }
            }
        }

        if (results.len == 0us && errors.len () != 0us) { // No value succeded, and there was some errors        
            throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_CALL_OP, prettyName, rights), notes-> errors[]);
        }

        // We only rewrite the values with the highest score ? maybe their score is high but does not work
        let multSym = context:.getValueValidator ().finalizeTemplateCallMultSym (alias context, loc, results[0us]._1);
        match multSym {
            m : &MultSymValue => {
                return self.validateValueList (alias context, loc, prettyName, m.getValues (), rights);
            }
            _ => __pragma!panic ();
        }
    }        
    
    /**
     * ================================================================================
     * ================================================================================
     * =========================           CALLING            =========================
     * ================================================================================
     * ================================================================================
     */


    /**
     * Validate the calling where the values left and rights are already validated
     * @params: 
     *   - context: the context of the validation
     *   - loc: the location of the operator
     *   - left: the left operand
     *   - rights: the right operands
     * @returns: 
     *   - .0: a value
     *   - .1: the score of the validation
     * @throws: if the operation is impossible
     */
    def validateCall (self, dmut context : &Validator, loc : &Word, left : &Value, rights : [&Value], candidate : bool = true)-> (&Value, u32)
        throws &ErrorMsg
    {
        match left.getType () {
            FuncPtrType () => { self.validateFuncPtrType (alias context, loc, left, rights, candidate-> candidate) }
            DelegateType () => { self.validateDelegateType (alias context, loc, left, rights, candidate-> candidate) }
            _ => {                    
                match left {
                    m : &CtorDelegateValue => {
                        self.validateCtorDelegateCall (alias context, loc, m, rights, candidate-> candidate) 
                    }
                    f : &PrototypeValue => {
                        self.validatePrototype (alias context, loc, f, rights, candidate-> candidate)
                    }
                    v : &VarRefValue => {
                        if (!v.getValue ().isOf!{&NoneValue} ()) {
                            self.validateCall (alias context, loc, v.getValue (), rights, candidate-> candidate)
                        } else {
                            throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_CALL_OP, self.prettyName (left), rights))
                        }
                    }
                    _ => {
                        throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_CALL_OP, self.prettyName (left), rights))
                    }
                    // l : &LambdaValue => {}
                }
            }
        }
    }

    /**
     * Divide the list of values into two lists where the first list values have higher priorities than those in the right one
     * @info: this function places template values in the right list
     * @params:
     *    - list: the list of values to divide
     * @returns: 
     *    - .0: the list of values with high priority
     *    - .1: the list of values with low priority     
     */
    def divideByPriority (self, list : [&Value])-> ([&Value], [&TemplateRefValue]) {
        let dmut left = Vec!{&Value}::new ();
        let dmut right = Vec!{&TemplateRefValue}::new ();
        for i in list match i {
            t : &TemplateRefValue => { right:.push (t); }
            _ => { left:.push (i); }
        }

        (left[], right[])
    }        

    /**
     * ================================================================================
     * ================================================================================
     * =========================     FUNCTION PROTOTYPE       =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a function prototype call
     * @params: 
     *    - context: the context of the validation
     *    - loc: the location of the call
     *    - left: the left operand
     *    - rights: the right operands
     *    - candidate: add the candidate_are not in case of failure ?
     * @returns: 
     *   - .0: the call
     *   - .1: the score of the call
     * @throws: &ErrorMsg, if the call is not possible
     */
    def validatePrototype (self, dmut context : &Validator, loc : &Word, left : &PrototypeValue, rights : [&Value], candidate : bool = false)-> (&Value, u32)
        throws &ErrorMsg
    {
        let (params, rest) = self.validateParameterList (left.getParameters (), rights);
        if (rest.len != 0us && !left.isCVariadic ()) {
            let dmut err = Vec!{&ErrorMsg}::new ();
            for it in rest {
                match it {
                    n : &NamedValue => {
                        err:.push (ErrorMsg::fatal (it.getLoc (), format (ValidateErrorMessage::NO_PARAMETER_NAMED, n.getName ())));
                    }
                }
            }

            if ((params.len + rest.len) != left.getParameters ().len) {
                throw ErrorMsg::fatal (loc, format (if (params.len + rest.len == 1us)  { ValidateErrorMessage::TOO_FEW_PARAMETERS_ONE } else { ValidateErrorMessage::TOO_FEW_PARAMETERS}, left.getParameters ().len, params.len + rest.len), notes-> err[]);
            } else {
                throw ErrorMsg::list (err[]);
            }
        } else if (params.len != left.getParameters ().len) {
            throw ErrorMsg::fatal (loc, format (if (params.len == 1us)  { ValidateErrorMessage::TOO_FEW_PARAMETERS_ONE } else { ValidateErrorMessage::TOO_FEW_PARAMETERS}, left.getParameters ().len, params.len));
        }

        let (_, score) = self.validateTypeParameterList (alias context, loc, left.getParameters (), params, verifType-> true, verifMemory-> true, isLambda-> false);

        (CallValue::new (loc, left.getRetType (), left, params, addParams-> rest), score) 
    } catch {
        err : &ErrorMsg => {
            if (!candidate) throw err;
            throw ErrorMsg::note (left.getLoc (), format (ValidateErrorMessage::CANDIDATE_ARE, left.getLoc (), left), notes-> [err]);
        }
    }

    /**
     * Validate the list of parameters 
     * @params: 
     *   - arguments: the list of parameters of the prototype
     *   - parameters: the list of values passed to the call
     * @returns: 
     *   - .0: the list of parameters (in the correct order)
     *   - .1: the list of parameters that are associated to no arguments (in the correct order)
     */
    def validateParameterList (self, arguments : [&ProtoVarValue], parameters : [&Value])-> ([&Value], [&Value])
        // throws &ErrorMsg
    {
        let dmut result = Vec!{&Value}::new ();
        let mut rest = parameters;
        for i in 0us .. arguments.len {
            let indexes = self.findParameter (rest, arguments [i]);
            if (indexes.len == 0us) return (result[], rest);
            
            if indexes.len != 1us { __pragma!panic (); }
            for index in indexes {
                result:.push (index._1);
                if (index._0 < rest.len) { // the inserted parameters is not a default param, thus we need to remove it from the list
                    rest = rest [0us .. index._0] ~ rest [(index._0 + 1us) .. $];
                }
            }
        }

        (result[], rest)
    }

    /**
     * Validate the type of the parameters
     * @params: 
     *   - context: the context of the validation
     *   - loc: the location of the call
     *   - arguments: the list of arguments of the prototype
     *   - parameters: the list of parameters passed to the prototype
     *   - verifType: verify the equality of the types
     *   - verifMemory: verify that the memory const, alias, etc are respected
     *   - isLambda: the prototype is a lambda prototype
     * @returns: 
     *   - .0: the list of types of the parameters
     *   - .1: the score of the call
     */
    def validateTypeParameterList (self, dmut context : &Validator, loc : &Word, arguments : [&ProtoVarValue], parameters : [&Value], verifType : bool = true, verifMemory : bool = true, isLambda : bool = false)-> ([&Type], u32)
        throws &ErrorMsg
    {
        let dmut types = Vec!{&Type}::new ();
        let dmut errors = Vec!{&ErrorMsg}::new ();
        let mut score = 0u32;

        for i in 0us .. arguments.len {
            let argType = arguments[i].getType ();
            let paramType = parameters [i].getType ();
            
            if (isLambda && argType.isOf!{&NoneType} ()) {
                types:.push (parameters [i].getType ().clone (isMutable-> false));
            } else {
                {
                    if (verifType) {
                        context:.verifyCompatibleTypeWithValue (parameters [i].getLoc (), argType, parameters [i]);
                    }

                    if (verifMemory) {
                        context:.verifyMemoryOwner (parameters [i].getLoc (), argType, parameters [i], construct-> true, checkTypes-> false);
                    }
                    
                    score += Scores::TYPE;
                    let llevel = paramType.mutabilityLevel ();
                    let rlevel = argType.mutabilityLevel () + 1u32;
                    if (rlevel > llevel) {
                        score += rlevel - llevel;
                    }
                } catch {
                    err : &ErrorMsg => {
                        errors:.push (err.withNote ([ErrorMsg::note (loc, format (ValidateErrorMessage::PARAMETER_NAME, arguments [i].getName ()), oneLine-> true)]));
                    }
                }
            }
        }

        if (errors.len () != 0us) throw ErrorMsg::list (errors[]);

        (types[], score)
    }


    /**
     * Find the parameter in the list that is associated to the var
     * @params: 
     *   - parameters: a list of value that are passed to the call
     *   - var: the protovar that is called
     * @returns: a array composed of : (it's an array because in case of Variadic/tuple var, multiple values can be consumed)
     *    - .0: the index of the value to use
     *    - .1: the value to use
     */
    def findParameter (self, parameters : [&Value], var : &ProtoVarValue)-> [(usize, &Value)] {
        if (var.getNbConsume () == 1us) { // non template validation        
            let (i, v) = self.findSingleParameter (parameters, var);
            match v {
                NoneValue () => { [] }
                _ => { [(i, v)] }
            }
        } else {
            __pragma!panic ();
        }
    }
    
    /**
     * Find the paremeter in the list that is associated to the var
     * @params: 
     *    - parameters: the list of parameters
     *    - var: the protovar that is called
     * @returns: 
     *    - .0: the index of the value to use
     *    - .1: the value to use
     */
    def findSingleParameter (self, parameters : [&Value], var : &ProtoVarValue, canBeNamed : bool = true)-> (usize, &Value) {
        let mut toRet = parameters.len, mut pos = true;
        for i, p in parameters {
            match p {
                n : &NamedValue => {
                    if (n.getName () == var.getName () && canBeNamed) {
                        toRet = i;
                        pos = false;
                        break {}
                    }
                }
                _ => {
                    if (toRet == parameters.len) {
                        toRet = i;
                    }
                }
            }
        }

        if (toRet == parameters.len || pos) {
            if (!var.getDefaultValue ().isOf!{&NoneValue} ()) {
                return (parameters.len, var.getDefaultValue ());
            }
        }

        if (toRet != parameters.len) {
            (toRet, parameters [toRet])
        } else {
            (parameters.len, NONE_VALUE)
        }
    }
    
    
    /**
     * ================================================================================
     * ================================================================================
     * =========================      FPTR AND DELEGATE       =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a function pointer call
     * @params: 
     *    - context: the context of the validation
     *    - loc: the location of the call
     *    - left: the left operand
     *    - rights: the right operands
     *    - candidate: add the candidate_are not in case of failure ?
     * @returns: 
     *   - .0: the call
     *   - .1: the score of the call
     * @throws: &ErrorMsg, if the call is not possible
     */
    def validateFuncPtrType (self, dmut context : &Validator, loc : &Word, left : &Value, rights : [&Value], candidate : bool = false)-> (&Value, u32)
        throws &ErrorMsg
    {
        context;
        loc;
        left;
        rights;
        candidate;
        __pragma!fake_throw (&ErrorMsg);
        __pragma!panic ();
    }
    
    /**
     * Validate a delegate call
     * @params: 
     *    - context: the context of the validation
     *    - loc: the location of the call
     *    - left: the left operand
     *    - rights: the right operands
     *    - candidate: add the candidate_are not in case of failure ?
     * @returns: 
     *   - .0: the call
     *   - .1: the score of the call
     * @throws: &ErrorMsg, if the call is not possible
     */
    def validateDelegateType (self, dmut context : &Validator, loc : &Word, left : &Value, rights : [&Value], candidate : bool = false)-> (&Value, u32)
        throws &ErrorMsg
    {
        context;
        loc;
        left;
        rights;
        candidate;
        __pragma!fake_throw (&ErrorMsg);
        __pragma!panic ();
    }


    /**
     * ================================================================================
     * ================================================================================
     * =========================            CTORS             =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate the call of a ctor of a class
     * @params: 
     *    - context: the context of the validation
     *    - loc: the location of the call
     *    - ctor: the ctor to call
     *    - rights: the right operands
     *    - candidate: add the candidate_are error in case of failure ?
     * @returns: 
     *   - .0: the call
     *   - .1: the score of the call
     * @throws: &ErrorMsg, if the call is not possible
     */
    def validateCtorDelegateCall (self, dmut context : &Validator, loc : &Word, ctor : &CtorDelegateValue, rights : [&Value], candidate : bool = false)-> (&Value, u32)
        throws &ErrorMsg
    {        
        let (call, score) = self.validatePrototype (alias context, loc, ctor.getPrototype (), rights, candidate-> candidate);
        match call {
            c : &CallValue => { // It should be a call, otherwise an error has been thrown
                (CtorCallValue::new (c.getLoc (), ctor.getType (), ctor, c.getParameters (), addParams-> c.getAddParameters ()), score) // replace the prototype by the delegate
            }
            _ => { __pragma!panic (); }
        }
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================          TEMPLATES           =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a call where left value is a template, and thus needs a specialization
     * @params: 
     *    - context: the context of the validation
     *    - loc: the location of the call
     *    - left: the template value
     *    - rights: the list of values used to call the template value
     *    - candidate: if true add the candidate_are error in case of failure (for multsym error handling)
     * @returns:
     *    - .0: the call
     *    - .1: the score of the call
     * @throws: 
     *    - &ErrorMsg: if the call if not possible
     */
    def validateTemplateCall (self, dmut context : &Validator, loc : &Word, left : &TemplateRefValue, rights : [&Value], _ : bool = false)-> &TemplateRewriter
        throws &ErrorMsg
    {
        context:.getTemplateSolver ().validateImplicitValue (alias context, loc, left, rights)
    }
    
    /**
     * ================================================================================
     * ================================================================================
     * =========================             MISC             =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Transform a value into a printable string, with correct debug informations
     * @params: 
     *    - v: the value 
     * @returns: a string, that can be put in an error message
     */
    def prettyName (self, v : &Value)-> [c8] {
        match v {
            vdecl : &VarDeclValue => {
                match v.getType () {
                    LambdaType () => {
                        return format ("%", vdecl.getValue ());
                    }
                }
            }
            vref : &VarRefValue => {
                match v.getType () {
                    LambdaType () => {
                        return format ("%", vref.getValue ());
                    }
                }
            }
        }
        
        format ("%", v)
    }

    
}
