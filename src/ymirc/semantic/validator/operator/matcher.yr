mod ymirc::semantic::validator::operator::matcher;

import std::io;
import std::collection::vec;

import ymirc::semantic::validator::visitor;
import ymirc::semantic::validator::errors;
import ymirc::errors::_;
import ymirc::utils::format;
import ymirc::semantic::generator::value::_;
import ymirc::syntax::expression::_;
import ymirc::syntax::keys;

import ymirc::lexing::tokens;
import ymirc::lexing::word;


import ymirc::semantic::generator::type::_;

/**
 * The match validator used to validate MatcherExpr
 * It is a class validator because match expression are complex
 */
pub class MatcherValidator {

    /**
     * Create an empty validator
     */
    pub self () {}


    /**
     * Validate a match expression
     * @params: 
     *    - context: the context of the validation
     *    - m: the matcher to validate
     * @returns: a value
     * @throws: 
     *    - &ErrorsMsg: if the validation failed
     */
    pub fn validate (self, dmut context : &Validator, m : &MatcherExpr)-> &Value
        throws &ErrorMsg
    {
        let mValue = context:.getValueValidator ().validate (alias context, m.getContent (), canBeRef-> true);
        let matchers = m.getMatchers ();
        let (canInnerMutRef, fVal) = match mValue {
            r : &ReferencerValue => { (r.isMutable (), r.getValue ()) }
            _ => { (false, mValue) }
        };

        let (conds, values, errors, type, complete) = self.validateMatchers (alias context, m.getLoc (), fVal, matchers, canInnerMutRef);

        if (errors.len != 0us) {
            throw ErrorMsg::fatal (m.getLoc (), format (ValidateErrorMessage::MATCH_VALIDATION, fVal, mValue.getType ()), notes-> errors);
        }

        if (conds.len > 0us) {
            let finType = self.verifyComplete (m.getLoc (), fVal, complete, type, values);
            let mut current : &Value = UNIT_VALUE;
            for i in conds.len .. 0us {
                current = self.createConditional (conds [i - 1us], values [i - 1us], else_-> current, finType, isComplete-> complete);
            }

            match current {
                UnitValue () => { return BlockValue::new (m.getLoc (), VoidType::new (m.getLoc ()), []); }
            }

            return current;
        }

        return BlockValue::new (m.getLoc (), VoidType::new (m.getLoc ()), []);
    }

    /**
     * Validate the list of matchers from the pattern matching
     * @params:
     *    - context: the context of the validation
     *    - value: the value being matched
     *    - matchers: the list of matchers
     * @returns:
     *    - .0: the list of conditions
     *    - .1: the list of validated values if conditions are true
     *    - .2: the list of errors during the validation
     *    - .3: the type result of the matcher (@warning: before checking completness)
     *    - .4: true if the matcher is complete
     * */
    fn validateMatchers (self, dmut context : &Validator, loc : &Word, value : &Value, matchers : [(&Expression, &Expression)], canInnerMutRef : bool)-> ([&Value], [&Value], [&ErrorMsg], &Type, bool) {
        let mut finType : &Type = NoneType::new (loc);
        let mut complete = false;
        let mut currentTautCond : &Value = UNIT_VALUE;

        let dmut conds = Vec!{&Value}::new ();
        let dmut values = Vec!{&Value}::new ();
        let dmut errors = Vec!{&ErrorMsg}::new ();

        for mtch in matchers {
            let mut succeed = true;
            context:.enterBlock ();
            {
                if (complete) {
                    throw ErrorMsg::fatal (mtch.0.getLoc (), ValidateErrorMessage::UNREACHABLE_MATCHER);
                }

                let dmut vars = Vec!{&Value}::new ();
                let cond = self.validateMatcher (alias context, value, mtch.0, alias vars, canInnerMutRef);
                conds:.push (cond);

                let mut val = context:.validateValue (mtch.1);
                let (t, v) = context:.inferTypeBranchingWithValue (finType.getLoc (), finType, val);
                vars:.push (v);

                values:.push (BlockValue::new (mtch.1.getLoc (), v.getType (), vars[]));
                finType = t;

                currentTautCond = match currentTautCond {
                    UnitValue () => { cond }
                    _ => {
                        cast!{&Value} (LogicalBinBoolOperatorValue::new (cond.getLoc (), BinaryOperators::DPIPE, cond, currentTautCond))
                    }
                }

                complete = self.isTautology (alias context, currentTautCond);
            } catch {
                err : &ErrorMsg => {
                    errors:.push (err);
                    succeed = false;
                }
            }

            {
                context:.quitBlock (warnUnused-> succeed);
            } catch {
                err : &ErrorMsg => errors:.push (err);
            }
        }

        (conds[], values[], errors[], finType, complete)
    }



    /**
     * Create a conditional value for a given pattern match
     * @params:
     *    - cond: the condition
     *    - val: the value to evaluate if the condition is true
     *    - else_: the value to evaluate if the condition is false
     * */
    fn createConditional (self, cond : &Value, val : &Value, else_ : &Value, type : &Type, isComplete : bool)-> &Value {
        match cond {
            b : &BoolValue => {
                return if b.isTrue () { val } else { else_ };
            }
        }

        ConditionalValue::new (cond.getLoc (), type, cond, val, elsev-> else_, isComplete-> isComplete)
    }


    /**
     * ================================================================================
     * ================================================================================
     * ==========================         VALIDATION         ==========================
     * ================================================================================
     * ================================================================================
     */


    /**
     * Validate a matcher
     * @params:
     *   - context: the context of the validation
     *   - value: the value to match
     *   - mtch: the matcher expression
     * @returns: the condition to evaluate at runtime
     * */
    pub fn validateMatcher (self, dmut context : &Validator, value : &Value, mtch : &Expression, dmut vars : &Vec!{&Value}, canInnerMutRef : bool)-> &Value
        throws &ErrorMsg
    {
        return match mtch {
            v : &VarDeclExpr => {
                self.validateVarDeclMatcher (alias context, value, v, alias vars, canInnerMutRef)
            }
            o : &OptionMatcherExpr => {
                self.validateOptionMatcher (alias context, value, o, alias vars, canInnerMutRef)
            }
            m : &MultOperatorExpr => {
                self.validateCallOpMatcher (alias context, value, m, alias vars, canInnerMutRef)
            }
            l : &ListMatcherExpr => {
                if (l.isTuple ()) {
                    self.validateTupleMatcher (alias context, value, l, alias vars, canInnerMutRef)
                } else {
                    self.validateArrayMatcher (alias context, value, l, alias vars, canInnerMutRef)
                }
            }
            _ => {
                self.validateValueEqualMatcher (alias context, value, mtch)
            }
        };
    }

    /**
     * Validate a var declaration matcher
     * @params:
     *    - context: the context of the validation
     *    - value: the value to match
     *    - vdecl: the variable declaration
     * @returns: the condition to evaluate at runtime
     * */
    fn validateVarDeclMatcher (self, dmut context : &Validator, value : &Value, vdecl : &VarDeclExpr, dmut vars : &Vec!{&Value}, canInnerMutRef : bool)-> &Value
        throws &ErrorMsg
    {
        if (vdecl.getLoc () != Keys::UNDER) context:.verifyShadow (vdecl.getLoc ()); // variable declaration, so no shadows are allowed

        let isPure = context.findDecos (vdecl.getDecos (), [Decorators::PURE]);
        let isRef = context.findDecos (vdecl.getDecos (), [Decorators::REF]);
        let isMutable = context.findDecos (vdecl.getDecos (), [Decorators::MUT, Decorators::DMUT]);

        let (typeCond, finalType, castedValue) = if (!vdecl.getType ().isOf!{&EmptyExpression} ()) { // not '_'
            let (_, t) = context:.validateType (vdecl.getType (), decos-> vdecl.getDecos (), canBeRef-> isRef);
            let type = if (isPure) { t.clone (0u32) } else { t };

            let (typeTest, castedValue) = match (value.getType (), type) {
                (ClassPtrType (), inner : &ClassPtrType) => { // a class reverse casting: Base -> Derived can only be known at cte (
                                                              // unless it is a Derived -> Base, but that is already managed by the binary operator validator
                    let typeTest = context:.getBinOpValidator ().validateClassTypeTestOp (alias context, vdecl.getType ().getLoc (), BinaryOperators::OF, value, inner.getInner ());

                    // we clone the derived type to match the base type mutability
                    let resType = type.clone (pattern-> value.getType ());
                    (typeTest, cast!{&Value} (CastValue::new (type.getLoc (), resType, value, isLvalue-> value.isLvalue ()))) // transform the value into the derived type
                }
                _ => { // Any other type test is cte evaluated
                    context.verifyCompatibleType (value.getLoc (), type.getLoc (), value.getType (), type);
                    (cast!{&Value} (BoolValue::new (vdecl.getType ().getLoc (), true)), value)
                }
            };

            (typeTest, t, castedValue)
        } else { // create a type for mutability checking
            let (_, t) = context:.validateType (TypeWrapperExpr::new (value.getLoc (), value.getType ()), decos-> vdecl.getDecos (), canBeRef-> isRef);
            (cast!{&Value} (BoolValue::new (vdecl.getLoc (), true)), t, value) // type test is always true
        };

        match finalType { // only values with a real type can be used to create a variable
            NoneType () => throw ErrorMsg::fatal (vdecl.getLoc (), format (ValidateErrorMessage::DECLARE_VOID_VAR, finalType));
            VoidType () => throw ErrorMsg::fatal (vdecl.getLoc (), format (ValidateErrorMessage::DECLARE_VOID_VAR, finalType));
            o : &OptionType => {
                if (o.getInners ()[0].isOf!{&NoneType} ()) {
                    throw ErrorMsg::fatal (vdecl.getLoc (), format (ValidateErrorMessage::DECLARE_VOID_VAR, finalType));
                }
            }
        }

        let valueCond = if (!vdecl.getValue ().isOf!{&EmptyExpression} ()) { // x : T = V =>
            // inner pattern matching on V using /cast!T (value)/ (since the type test was true)
            self.validateMatcher (alias context, castedValue, vdecl.getValue (), alias vars, canInnerMutRef && isRef)
        } else {
            cast!{&Value} (BoolValue::new (vdecl.getLoc (), true)) // necessarily pass
        };

        // reduce non reference value
        let mut finVal = if (!isRef) { context:.getCompileTimeInterpreter ().reduce (value) } else { value };
        finVal = if (isRef && finVal.isLvalue ()) {
            ReferencerValue::new (finVal.getLoc (), finVal.getType (), finVal, isMutable-> (canInnerMutRef && finalType.isMutable ())) // if it is passed by const ref we need to transform the lvalue to an implicit ref lvalue
        } else {
            finVal
        };

        context:.verifyMemoryOwner (vdecl.getLoc (), finalType, finVal, construct-> true, byReference-> isRef);
        if (vdecl.getLoc () != Keys::UNDER) { // if the variable is not '_' we insert it in the current block
            let var = VarDeclValue::new (vdecl.getLoc (), finalType, finVal, isReference-> isRef, isMutable-> isMutable, isPure-> isPure);
            context:.insertLocal (vdecl.getLoc ().str (), var);

            vars:.push (var); // add the declaration in the pattern matching success block
        }

        // test type && test value to be a successful pattern matcher
        LogicalBinBoolOperatorValue::new (vdecl.getLoc (), BinaryOperators::DAND, typeCond, valueCond)
    }

    /**
     * Validate a call operator matcher
     * @params:
     *    - context: the context of the validation
     *    - value: the value to match
     *    - cl: the call operator
     * @returns: the condition to evaluate at runtime
     * */
    fn validateCallOpMatcher (self, dmut context : &Validator, value : &Value, cl : &MultOperatorExpr, dmut vars : &Vec!{&Value}, canInnerMutRef : bool)-> &Value
        throws &ErrorMsg
    {
        let validateL = match cl.getLeft () { // don't validate _ ()
            v : &VarExpr => {
                v.getLoc () != Keys::UNDER
            }
            _ => { true }
        };

        let (typeCond, castedValue) = if (validateL) {
            let type = context:.validateType (cl.getLeft ());
            let (typeTest, castedValue) = match (value.getType (), type) {
                (ClassPtrType (), inner : &ClassPtrType) => { // a class reverse casting: Base -> Derived can only be known at cte (
                                                              // unless it is a Derived -> Base, but that is already managed by the binary operator validator
                    let typeTest = context:.getBinOpValidator ().validateClassTypeTestOp (alias context, type.getLoc (), BinaryOperators::OF, value, inner.getInner ());

                    // we clone the derived type to match the base type mutability
                    let resType = type.clone (pattern-> value.getType ());
                    (typeTest, cast!{&Value} (CastValue::new (type.getLoc (), resType, value, isLvalue-> value.isLvalue ()))) // transform the value into the derived type
                }
                (ClassPtrType (), inner : &ClassRefType) => { // Same as class ptr, but in MultOp a class ref can be used directly (Derived () => ) to match &Base
                    let typeTest = context:.getBinOpValidator ().validateClassTypeTestOp (alias context, type.getLoc (), BinaryOperators::OF, value, inner);

                    // we clone the derived type to match the base type mutability
                    let resType = ClassPtrType::new (type.getLoc (), inner).clone (pattern-> value.getType ());
                    (typeTest, cast!{&Value} (CastValue::new (type.getLoc (), resType, value, isLvalue-> value.isLvalue ())))
                }
                _ => { // Any other type test is cte evaluated
                    context.verifyCompatibleType (value.getLoc (), type.getLoc (), value.getType (), type);
                    (cast!{&Value} (BoolValue::new (type.getLoc (), true)), value)
                }
            };

            (typeTest, castedValue)
        } else {
            (cast!{&Value} (BoolValue::new (cl.getLeft ().getLoc (), true)), value)
        };

        let mut curValueTest : &Value = BoolValue::new (cl.getLoc (), true);
        for p in cl.getRights () match p {
            n : &NamedExpr => {
                let val = context:.getBinOpValidator ().validateFieldOperation (alias context, n.getLoc (), BinaryOperators::DOT, castedValue, VarExpr::new (n.getLoc ()));
                let innerTest = self.validateMatcher (alias context, val, n.getContent (), alias vars, canInnerMutRef);

                curValueTest = LogicalBinBoolOperatorValue::new (n.getLoc (), BinaryOperators::DAND, curValueTest, innerTest);
            }
            _ => __pragma!panic ();
        }

        LogicalBinBoolOperatorValue::new (cl.getLoc (), BinaryOperators::DAND, typeCond, curValueTest)
    }

    /**
     * Validate an option matcher
     * @params:
     *     - context: the context of the validation
     *     - value: the value being matched
     *     - opt: the option matcher to validate
     *     - vars:
     * */
    fn validateOptionMatcher (self, dmut context : &Validator, value : &Value, opt : &OptionMatcherExpr, dmut vars : &Vec!{&Value}, canInnerMutRef : bool)-> &Value
        throws &ErrorMsg
    {
        let loc = opt.getLoc ();
        if (!value.getType ().isOf!{&OptionType} ()) {
            throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::OPTION_MATCHER, loc, value.getType ()));
        }

        let optType = value.getType ().asOf!{&OptionType} ();
        let isSet = StructFieldAccessValue::new (loc, BoolType::new (loc), value, OptionKeys::SET);
        if (loc == OptionKeys::MATCH_SOME) match opt.getInner () {
            EmptyExpression () => return isSet;
            exp : &Expression => {
                let innerVal = OptionFieldAccessValue::new (loc, optType.getInners ()[0], value, OptionKeys::VALUE);
                let innerTest = self.validateMatcher (alias context, innerVal, exp, alias vars, canInnerMutRef);

                return LogicalBinBoolOperatorValue::new (loc, BinaryOperators::DAND, isSet, innerTest);
            }
        } else match opt.getInner () {
            EmptyExpression () => {
                return UnaryBoolOperatorValue::new (loc, UnaryOperators::NOT, isSet);
            }
            exp : &Expression => {
                let ptrType = PointerType::new (loc, VoidType::new (loc));
                let hasError = CmpPointerOperatorValue::new (loc, BinaryOperators::NOT_EQUAL,
                                                             OptionFieldAccessValue::new (loc, ptrType, value, OptionKeys::ERROR),
                                                             NullValue::new (loc, ptrType));

                let notSet = UnaryBoolOperatorValue::new (loc, UnaryOperators::NOT, isSet);
                let finTest = LogicalBinBoolOperatorValue::new (loc, BinaryOperators::DAND, notSet, hasError);
                let innerType = context:.getExceptionType (loc-> loc);
                let err = OptionFieldAccessValue::new (loc, innerType, value, OptionKeys::ERROR);
                let innerTest = self.validateMatcher (alias context, err, exp, alias vars, canInnerMutRef);

                return LogicalBinBoolOperatorValue::new (loc, BinaryOperators::DAND, finTest, innerTest);
            }
        }
    }

    /**
     * Validate a tuple matcher
     * @params:
     *    - context: the context of the validation
     *    - value: the value to match
     *    - tu: the tuple list
     * @returns: the condition to evaluate at runtime
     * */
    fn validateTupleMatcher (self, dmut context : &Validator, value : &Value, tu : &ListMatcherExpr, dmut vars : &Vec!{&Value}, canInnerMutRef : bool)-> &Value
        throws &ErrorMsg
    {
        let loc = tu.getLoc ();
        let values = self.expandTupleValues (alias context, loc, value);
        if (tu.isVariadic () && tu.getParameters ().len - 1us > values.len) { // (x,z...) = (1,) is ok, x <- 1, z <- (), but (x,z...) = () is not there is nothing for x
            throw ErrorMsg::fatal (tu.getLoc (), format (ValidateErrorMessage::TUPLE_ARITY_OVERFLOW, tu.getParameters ().len, values.len));
        } else if (!tu.isVariadic () && tu.getParameters ().len != values.len) { // (x,) = (1,2) or (x, y) = (1,) are not ok
            throw ErrorMsg::fatal (tu.getLoc (), format (ValidateErrorMessage::TUPLE_ARITY_OVERFLOW, tu.getParameters ().len, values.len));
        }

        // pattern match inner values
        let mut curValueTest : &Value = BoolValue::new (loc, true);
        for i, p in tu.getParameters () {
            let assocValue : &Value = if (i != tu.getParameters ().len - 1us || !tu.isVariadic ()) {
                values [i]
            } else {
                let rest = values [i .. $];
                let dmut tupleTypes = Vec!{&Type}::new ();
                for j in i .. values.len {
                    tupleTypes:.push (values [j].getType ());
                }

                let tupleType = TupleType::new (value.getLoc (), tupleTypes[], isMutable-> true);
                cast!{&Value} (TupleValue::new (value.getLoc (), tupleType, rest))
            };

            let innerTest = self.validateMatcher (alias context, assocValue, p, alias vars, canInnerMutRef);
            curValueTest = LogicalBinBoolOperatorValue::new (loc, BinaryOperators::DAND, curValueTest, innerTest);
        }

        curValueTest
    }

    /**
     * Expand the tuple values (unlike expand from intrinsic, this expand allows for mutable)
     * */
    fn expandTupleValues (self, dmut context : &Validator, loc : &Word, value : &Value)-> [&Value]
        throws &ErrorMsg
    {
        let dmut tyValues = Vec!{&Value}::new ();
        match value.getType () {
            ty : &TupleType => {
                // expand the tuple, so it can be easily read
                for it in 0us .. ty.getInners ().len {
                    let access = context:.getBinOpValidator ().createTupleFieldAccess (loc, ty.getInners ()[it], value, it);
                    tyValues:.push (context.getCompileTimeInterpreter ().reduce (access));
                }
            }
            _ => {
                tyValues:.push (value);
            }
        }

        tyValues[]
    }

    /**
     * Validate an array matcher
     * @params:
     *    - context: the context of the validation
     *    - value: the value to match
     *    - arr: the array list
     * @returns: the condition to evaluate at runtime
     * */
    fn validateArrayMatcher (self, dmut context : &Validator, value : &Value, arr : &ListMatcherExpr, dmut vars : &Vec!{&Value}, canInnerMutRef : bool)-> &Value
        throws &ErrorMsg
    {
        context;
        value;
        arr;
        vars;
        canInnerMutRef;
        __pragma!fake_throw (&ErrorMsg);
        __pragma!panic ();
    }

    /**
     * Validate a matcher using a value
     * @info: from there, no variable can be created anymore just value equality
     * @params:
     *    - context: the context of the validation
     *    - value: the value to match
     *    - mtch: the matcher value
     * @returns: the condition to evaluate at runtime
     * */
    fn validateValueEqualMatcher (self, dmut context : &Validator, value : &Value, mtch : &Expression)-> &Value
        throws &ErrorMsg
    {
        match mtch {
            b : &BinaryExpr => {
                if b.getLoc () == BinaryOperators::PIPE {
                    let left = self.validateValueEqualMatcher (alias context, value, b.getLeft ());
                    let right = self.validateValueEqualMatcher (alias context, value, b.getRight ());

                    return LogicalBinBoolOperatorValue::new (mtch.getLoc (), BinaryOperators::DPIPE, left, right);
                }
            }
            t : &VarExpr => {
                if (t.getLoc () == Keys::UNDER) return BoolValue::new (mtch.getLoc (), true);
            }
        }

        let eqVal = context:.validateValue (mtch);
        context:.getBinOpValidator ().validateComparisonOperation (alias context, mtch.getLoc (), BinaryOperators::DEQUAL, value, eqVal)
    }


    /**
     * ================================================================================
     * ================================================================================
     * =========================         VERIFICATION         =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * @returns: true if the list condition is a tautology
     * */
    fn isTautology (self, dmut context : &Validator, cond : &Value)-> bool
        throws &ErrorMsg
    {
        let red = context.getCompileTimeInterpreter ().reduce (cond);
        match red {
            b : &BoolValue => return b.isTrue ();
        }

        false
    }

    /**
     * Verify that the match is complete
     * If it is note, then branch values must be void
     * @returns: the final type of the match
     * @throws:
     *    - &ErrorMsg: if the match is not complete, but branch values are not void
     * */
    fn verifyComplete (self, loc : &Word, value : &Value, complete : bool, type : &Type, values : [&Value])-> &Type
        throws &ErrorMsg
    {
        let retType = if (!complete) { cast!{&Type} (VoidType::new (loc)) } else { type };

        if (!complete) {
            let dmut errors = Vec!{&ErrorMsg}::new ();
            for i in values {
                if (!i.getType ().isOf!{&VoidType} ()) {
                    errors:.push (ErrorMsg::fatal (i.getLoc (), format (ValidateErrorMessage::MATCH_NOT_COMPLETE, i.getType ())));
                }
            }

            if (errors.len () != 0us) {
                throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::MATCH_VALIDATION, value, value.getType ()), notes-> errors []);
            }
        }

        retType
    }

}
