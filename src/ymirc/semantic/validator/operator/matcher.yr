mod ymirc::semantic::validator::operator::matcher;

import std::io;
import std::collection::vec;

import ymirc::semantic::validator::visitor;
import ymirc::semantic::validator::errors;
import ymirc::errors::_;
import ymirc::utils::format;
import ymirc::semantic::generator::value::_;
import ymirc::syntax::expression::_;
import ymirc::syntax::keys;

import ymirc::lexing::tokens;
import ymirc::lexing::word;


import ymirc::semantic::generator::type::_;

/**
 * The match validator used to validate MatcherExpr
 * It is a class validator because match expression are complex
 */
pub class MatcherValidator {

    /**
     * Create an empty validator
     */
    pub self () {}


    /**
     * Validate a match expression
     * @params: 
     *    - context: the context of the validation
     *    - m: the matcher to validate
     * @returns: a value
     * @throws: 
     *    - &ErrorsMsg: if the validation failed
     */
    pub fn validate (self, dmut context : &Validator, m : &MatcherExpr)-> &Value
        throws &ErrorMsg
    {
        let mValue = context:.getValueValidator ().validate (alias context, m.getContent (), canBeRef-> true);
        let matchers = m.getMatchers ();
        let (byMutRef, byAlias, fVal) = match mValue {
            r : &ReferencerValue => { (r.isMutable (), false, r.getValue ()) }
            a : &AliaserValue => { (false, true, a.getValue ()) }
            _ => { (false, false, mValue) }
        };

        let (conds, values, errors, type, complete, innerUseRef, innerUseAlias) = self.validateMatchers (alias context, m.getLoc (), fVal, matchers, byMutRef, byAlias);
        if (errors.len != 0us) {
            throw ErrorMsg::fatal (m.getLoc (), format (ValidateErrorMessage::MATCH_VALIDATION, fVal, mValue.getType ()), notes-> errors);
        }

        if (!innerUseRef && byMutRef) {
            throw ErrorMsg::fatal (mValue.getLoc (), ValidateErrorMessage::UNECESSARY_REFERENCE,
                                   notes-> [ErrorMsg::note (m.getLoc (), ValidateErrorMessage::NO_REFERENCE_PATTERN)]);
        } else if (!innerUseAlias && byAlias) {
            throw ErrorMsg::fatal (mValue.getLoc (), format (ValidateErrorMessage::UNECESSARY_ALIAS, mValue.getType ()),
                                   notes-> [ErrorMsg::note (m.getLoc (), format (ValidateErrorMessage::NO_ALIAS_PATTERN, ""s8))]);
        }

        if (conds.len > 0us) {
            let finType = self.verifyComplete (m.getLoc (), fVal, complete, type, values);
            let mut current : &Value = UNIT_VALUE;
            for i in conds.len .. 0us {
                current = self.createConditional (conds [i - 1us], values [i - 1us], else_-> current, finType, isComplete-> complete);
            }

            match current {
                UnitValue () => { return BlockValue::new (m.getLoc (), VoidType::new (m.getLoc ()), []); }
            }

            return current;
        }

        return BlockValue::new (m.getLoc (), VoidType::new (m.getLoc ()), []);
    }

    /**
     * Validate a catcher pattern matching
     * @params
     *    - context : the context of the validation
     *    - m: the pattern matching to validate
     *    - tryType: the type of the try part that is caught
     *    - catchVar : the var reference to the variable taking the thrown exception
     *    - throwers: the list of exception that the catchVar can take
     * @returns:
     *    - .0: the list of actions
     *    - .1: the type of catch actions
     * */
    pub fn validateCatcher (self, dmut context : &Validator, m : &MatcherExpr, tryType : &Type, catchVar : &Value, throwers : [(&Word, &Type)])-> (&Value, &Type)
        throws &ErrorMsg
    {
        context;
        m;
        tryType;
        catchVar;
        throwers;
        __pragma!fake_throw (&ErrorMsg);
        __pragma!panic ();
    }

    /**
     * Validate the list of matchers from the pattern matching
     * @params:
     *    - context: the context of the validation
     *    - value: the value being matched
     *    - matchers: the list of matchers
     *    - byMutRef: true if the value was passed by mutable reference
     *    - byAlias: true if the value was passed by alias
     * @returns:
     *    - .0: the list of conditions
     *    - .1: the list of validated values if conditions are true
     *    - .2: the list of errors during the validation
     *    - .3: the type result of the matcher (@warning: before checking completness)
     *    - .4: true if the matcher is complete
     *    - .5: byMutRef was used
     *    - .6: byAlias was used
     * */
    fn validateMatchers (self, dmut context : &Validator, loc : &Word, value : &Value, matchers : [(&Expression, &Expression, &Expression)], byMutRef : bool, byAlias : bool)-> ([&Value], [&Value], [&ErrorMsg], &Type, bool, bool, bool) {
        let mut finType : &Type = NoneType::new (loc);
        let mut complete = false;
        let mut currentTautCond : &Value = UNIT_VALUE;

        let dmut conds = Vec!{&Value}::new ();
        let dmut values = Vec!{&Value}::new ();
        let dmut errors = Vec!{&ErrorMsg}::new ();
        let mut innerRef = false, mut innerAlias = false;

        for mtch in matchers {
            let mut succeed = true;
            context:.enterBlock ();
            {
                if (complete) {
                    throw ErrorMsg::fatal (mtch.0.getLoc (), ValidateErrorMessage::UNREACHABLE_MATCHER);
                }

                let dmut vars = Vec!{([c8], &Value)}::new ();

                // Validate the pattern
                let (cond_, innerRef_, innerAlias_) = self.validateMatcher (alias context, value, mtch.0, alias vars, byMutRef, byAlias);
                innerRef = innerRef || innerRef_;
                innerAlias = innerAlias || innerAlias_;

                let (cond, taut) = self.validateConditionGuard (alias context, vars[], mtch.1, cond_);
                conds:.push (cond);

                // Validate the value associated with successful pattern match
                let mut val = context:.validateValue (mtch.2);
                let (t, v) = context:.inferTypeBranchingWithValue (finType.getLoc (), finType, val);

                values:.push (BlockValue::new (mtch.2.getLoc (), v.getType (), [v]));
                finType = t;

                currentTautCond = match currentTautCond {
                    UnitValue () => { taut }
                    _ => {
                        cast!{&Value} (LogicalBinBoolOperatorValue::new (cond.getLoc (), BinaryOperators::DPIPE, taut, currentTautCond))
                    }
                }

                complete = self.isTautology (alias context, currentTautCond);
            } catch {
                err : &ErrorMsg => {
                    errors:.push (err);
                    succeed = false;
                }
            }

            {
                context:.quitBlock (warnUnused-> succeed);
            } catch {
                err : &ErrorMsg => errors:.push (err);
            }
        }

        (conds[], values[], errors[], finType, complete, innerRef, innerAlias)
    }



    /**
     * Create a conditional value for a given pattern match
     * @params:
     *    - cond: the condition
     *    - val: the value to evaluate if the condition is true
     *    - else_: the value to evaluate if the condition is false
     * */
    fn createConditional (self, cond : &Value, val : &Value, else_ : &Value, type : &Type, isComplete : bool)-> &Value {
        match cond {
            b : &BoolValue => {
                return if b.isTrue () { val } else { else_ };
            }
        }

        ConditionalValue::new (cond.getLoc (), type, cond, val, elsev-> else_, isComplete-> isComplete)
    }

    /*!
     * ================================================================================
     * ================================================================================
     * ==========================         ERROR DECL         ==========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Declare the variables with error type
     * @throws: if there are shadowing variable found
     * */
    pub fn declareErrorVariables (self, dmut context : &Validator, mtch : &Expression, dmut vars : &Vec!{([c8], &Value)} = Vec!{([c8], &Value)}::new ())-> [([c8], &Value)]
        throws &ErrorMsg
    {
        match mtch {
            vdecl : &VarDeclExpr => {
                if (vdecl.getLoc () != Keys::UNDER) {
                    context:.verifyShadow (vdecl.getLoc ());
                    self.verifyShadowPattern (vdecl.getLoc (), vars[]);

                    let var = VarDeclValue::new (vdecl.getLoc (), ErrorType::new (vdecl.getLoc ()), UNIT_VALUE, isMutable-> false, isPure-> false);
                    vars:.push ((vdecl.getLoc ().str (), var));
                }

                self.declareErrorVariables (alias context, vdecl.getValue (), vars-> alias vars);
            }
            o : &OptionMatcherExpr => {
                self.declareErrorVariables (alias context, o.getInner (), vars-> alias vars);
            }
            cl : &MultOperatorExpr => {
                for m in cl.getRights () {
                    self.declareErrorVariables (alias context, m, vars-> alias vars);
                }
            }
            l : &ListMatcherExpr => {
                for m in l.getParameters () {
                    self.declareErrorVariables (alias context, m, vars-> alias vars);
                }
            }
        }

        vars[]
    }

    /*!
     * ================================================================================
     * ================================================================================
     * ==========================         VALIDATION         ==========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate the conditional guard
     * @warning: the block of the pre test has to be already entered, variables from /vars/ are insert in local block
     * @returns:
     *    - .0: the actual test with var decls
     *    - .1: the tautology test
     * */
    pub fn validateConditionGuard (self, dmut context : &Validator, vars : [([c8], &Value)], guard : &Expression, currentCond : &Value)-> (&Value, &Value)
        throws &ErrorMsg
    {
        let dmut testBlk = Vec!{&Value}::new ();
        for v in vars {
            if (v.0 != Keys::UNDER) {
                context:.insertLocal (v.0, v.1);
            }

            testBlk:.push (v.1);
        }

        match guard {
            EmptyExpression () => {
                testBlk:.push (BoolValue::new (guard.getLoc (), true));
                let res : &Value = LogicalBinBoolOperatorValue::new (currentCond.getLoc (), BinaryOperators::DAND, currentCond,
                                                            BlockValue::new (currentCond.getLoc (), BoolType::new (currentCond.getLoc ()), testBlk[], isSet-> true));
                (res, currentCond)
            }
            _ => {
                let r = context:.validateValue (guard);
                if (!r.getType ().isOf!{&BoolType} ()) {
                    throw ErrorMsg::fatal (r.getLoc (), format (ValidateErrorMessage::INCOMPATIBLE_TYPE, r.getType (), BoolType::new (r.getLoc ())));
                }

                testBlk:.push (r);
                let res : &Value = LogicalBinBoolOperatorValue::new (currentCond.getLoc (), BinaryOperators::DAND, currentCond,
                                                            BlockValue::new (currentCond.getLoc (), BoolType::new (currentCond.getLoc ()), testBlk[], isSet-> true));

                let taut : &Value = LogicalBinBoolOperatorValue::new (currentCond.getLoc (), BinaryOperators::DAND, currentCond, r);
                (res, taut)
            }
        }
    }
    

    /**
     * Validate the matcher from a single pattern (var declaration, if let, etc.)
     * @params:
     *    - context: the context of the validation
     *    - value: the value passed to the matcher
     *    - mtch: the pattern
     * @returns:
     *    - .0: the validate value passed to the pattern
     *    - .1: the runtime test (a true bool value if cte and irrefutable)
     *    - .2: the list of variable to declare (.0-> name, .1-> var decl value)
     *    - .3: the error if any, in that case the variables have an error type in .1 but they can still be inserted in local block if needed
     * @warning: variables are not inserted in any block, they have to be after the function call
     * */
    pub fn validateMatcher (self, dmut context : &Validator, value : &Expression, mtch : &Expression)-> (&Value, &Value, [([c8], &Value)], (&ErrorMsg)?) {
        {
            let mValue = context:.getValueValidator ().validate (alias context, value, canBeRef-> true);
            let dmut vars = Vec!{([c8], &Value)}::new ();

            let (byMutRef, byAlias, fVal) = match mValue {
                r : &ReferencerValue => { (r.isMutable (), false, r.getValue ()) }
                a : &AliaserValue => { (false, true, a.getValue ()) }
                _ => { (false, false, mValue) }
            };

            let (cond, useRef, useAlias) = self.validateMatcher (alias context, fVal, mtch, alias vars, byMutRef, byAlias);
            if (!useRef && byMutRef) {
                throw ErrorMsg::fatal (mValue.getLoc (), ValidateErrorMessage::UNECESSARY_REFERENCE,
                                       notes-> [ErrorMsg::note (mtch.getLoc (), ValidateErrorMessage::NO_REFERENCE_PATTERN)]);
            } else if (!useAlias && byAlias) {
                throw ErrorMsg::fatal (mValue.getLoc (), format (ValidateErrorMessage::UNECESSARY_ALIAS, mValue.getType ()),
                                       notes-> [ErrorMsg::note (mtch.getLoc (), format (ValidateErrorMessage::NO_ALIAS_PATTERN, ""s8))]);
            }

            (mValue, cond, vars[], ((&ErrorMsg)?)::__err__)
        } catch {
            err : &ErrorMsg => { // insert error variables to avoid future undefined symbol errors
                {
                    let vars = context:.getMatcherValidator ().declareErrorVariables (alias context, mtch);
                    return (UNIT_VALUE, UNIT_VALUE, vars, err?);
                } catch {
                    _ => return (UNIT_VALUE, UNIT_VALUE, [], err?);
                }
            }
        }
    }

    /**
     * Validate a matcher
     * @params:
     *   - context: the context of the validation
     *   - value: the value to match
     *   - mtch: the matcher expression
     * @returns: the condition to evaluate at runtime
     * */
    fn validateMatcher (self, dmut context : &Validator, value : &Value, mtch : &Expression, dmut vars : &Vec!{([c8], &Value)}, byMutRef : bool, byAlias : bool)-> (&Value, bool, bool)
        throws &ErrorMsg
    {
        return match mtch {
            v : &VarDeclExpr => {
                self.validateVarDeclMatcher (alias context, value, v, alias vars, byMutRef, byAlias)
            }
            o : &OptionMatcherExpr => {
                self.validateOptionMatcher (alias context, value, o, alias vars, byMutRef, byAlias)
            }
            m : &MultOperatorExpr => {
                self.validateCallOpMatcher (alias context, value, m, alias vars, byMutRef, byAlias)
            }
            l : &ListMatcherExpr => {
                if (l.isTuple ()) {
                    self.validateTupleMatcher (alias context, value, l, alias vars, byMutRef, byAlias)
                } else {
                    self.validateArrayMatcher (alias context, value, l, alias vars, byMutRef, byAlias)
                }
            }
            _ => {
                (self.validateValueEqualMatcher (alias context, value, mtch), false, false)
            }
        };
    }

    /**
     * Validate a var declaration matcher
     * @params:
     *    - context: the context of the validation
     *    - value: the value to match
     *    - vdecl: the variable declaration
     * @returns: the condition to evaluate at runtime
     * */
    fn validateVarDeclMatcher (self, dmut context : &Validator, value : &Value, vdecl : &VarDeclExpr, dmut vars : &Vec!{([c8], &Value)}, byMutRef : bool, byAlias : bool)-> (&Value, bool, bool)
        throws &ErrorMsg
    {
        if (vdecl.getLoc () != Keys::UNDER) {
            context:.verifyShadow (vdecl.getLoc ()); // variable declaration, so no shadows are allowed
            self.verifyShadowPattern (vdecl.getLoc (), vars[]); // verify that no variable declared within the pattern are shadowing each other
        }

        let isPure = context.findDecos (vdecl.getDecos (), [Decorators::PURE]);
        let isRef = context.findDecos (vdecl.getDecos (), [Decorators::REF]);
        let isMutable = context.findDecos (vdecl.getDecos (), [Decorators::MUT, Decorators::DMUT]);

        {
            // Transform the value into something assignable to the var decl, and retreive the runtime test if any and some other stuff for further matching and validation
            let (typeCond, finalType, valToAffect, castedValue, useRef, useAlias) = self.validateVarDeclMatcherValue (alias context, value, vdecl, isRef, isPure, byMutRef, byAlias);
            match finalType { // only values with a real type can be used to create a variable
                NoneType () => throw ErrorMsg::fatal (vdecl.getLoc (), format (ValidateErrorMessage::DECLARE_VOID_VAR, finalType));
                VoidType () => throw ErrorMsg::fatal (vdecl.getLoc (), format (ValidateErrorMessage::DECLARE_VOID_VAR, finalType));
                o : &OptionType => {
                    if (o.getInners ()[0].isOf!{&NoneType} ()) {
                        throw ErrorMsg::fatal (vdecl.getLoc (), format (ValidateErrorMessage::DECLARE_VOID_VAR, finalType));
                    }
                }
            }

            let var = VarDeclValue::new (vdecl.getLoc (), finalType, valToAffect, isReference-> isRef, isMutable-> isMutable, isPure-> isPure);
            vars:.push ((vdecl.getLoc ().str (), var)); // add the declaration in the pattern matching success block

            let (valueCond, innerUseRef, innerUseAlias) = if (!vdecl.getValue ().isOf!{&EmptyExpression} ()) { // x : T = V =>
                // inner pattern matching on V using /cast!T (value)/ (since the type test was true)
                self.validateMatcher (alias context, castedValue, vdecl.getValue (), alias vars, byMutRef, byAlias)
            } else {
                (cast!{&Value} (BoolValue::new (vdecl.getLoc (), true)), false, false) // necessarily pass
            };

            // test type && test value to be a successful pattern matcher
            (LogicalBinBoolOperatorValue::new (vdecl.getLoc (), BinaryOperators::DAND, typeCond, valueCond), useRef || innerUseRef, useAlias || innerUseAlias)
        } catch {
            err : &ErrorMsg => { // insert error variable to avoid undefined symbol errors
                if (vdecl.getLoc () != Keys::UNDER) {
                    let var = VarDeclValue::new (vdecl.getLoc (), ErrorType::new (vdecl.getLoc ()), UNIT_VALUE, isReference-> isRef, isMutable-> isMutable, isPure-> isPure);
                    vars:.push ((vdecl.getLoc ().str (), var));
                }

                throw err;
            }
        }
    }

    /**
     * Validate the casting of the matching value to the type of the variable
     * @params:
     *    - context: the context of the validation
     *    - value: the value (reference or not)
     *    - vdecl: the pattern
     *    - isRef: true if the vdecl has /ref/ deco
     *    - isPure: true if the vdecl has /pure/ deco
     *    - byMutRef: true if the root value of the matcher was by mutable reference
     *    - byAlias: true if the root value of the matcher was by alias
     * @returns:
     *    - .0: the test (a true bool value if the test is irrefutable)
     *    - .1: the type of the vdecl
     *    - .2: the value to affect in the vdecl
     *    - .3: the value to pass for further matching (already cleaned of reference/aliaser by casted to the correct type)
     *    - .4: true iif the byMutRef was used
     *    - .5: true iif the byAlias was used
     * */
    fn validateVarDeclMatcherValue (self, dmut context : &Validator, value : &Value, vdecl : &VarDeclExpr, isRef : bool, isPure : bool, byMutRef : bool, byAlias : bool)-> (&Value, &Type, &Value, &Value, bool, bool)
        throws &ErrorMsg
    {
        let (test, type, castedValue) = if (!vdecl.getType ().isOf!{&EmptyExpression} ()) { // not '_'
            let (_, t) = context:.validateType (vdecl.getType (), decos-> vdecl.getDecos (), canBeRef-> isRef);
            let type = if (isPure) { t.clone (0u32) } else { t };

            let (typeTest, castedValue) = match (value.getType (), type) {
                (valueType : &ClassPtrType, declType : &ClassPtrType) => { // a class reverse casting: Base -> Derived can only be known at cte (
                    // inner == derived, so the test is cte and no need to cast anything
                    if (declType.isCompatible (valueType)) {
                        (cast!{&Value} (BoolValue::new (vdecl.getType ().getLoc (), true)), value)
                    }

                    // value is a Derived of derived, or derived is a Derived of value, both are allowed but one has to be runtime evaluated (Derived <- Base)
                    else {
                        // unless it is a Derived -> Base, but that is already managed by the binary operator validator
                        if (isRef && context.isAncestor (declType, valueType)) { // ref mut x : &Base = ref y : Derived is not allowed, because x = Base::new () will result in undefined behavior
                            throw ErrorMsg::fatal (vdecl.getLoc (), end-> value.getLoc (), format (ValidateErrorMessage::CANNOT_CASTTO_BASE_CLASS, valueType, declType),
                                                   notes-> [ErrorMsg::note (context.getDecosLoc (vdecl.getDecos (), Decorators::REF), ""s8)]);
                        }
                        // However, ref mut x : Derived = ref y : Base, is allowed we can only put a Derived into x, thus y will always contain a Base so no problem

                        // Create the runtime test to check wether the value is containing an instance of the type of the variable decl
                        let typeTest = context:.getBinOpValidator ().validateClassTypeTestOp (alias context, vdecl.getType ().getLoc (), BinaryOperators::OF, value, declType.getInner ());

                        // we clone the derived type to match the base type mutability
                        let resType = declType.clone (pattern-> valueType);

                        //  cast the value into the type of the variable decl
                        let ctdValue = CastValue::new (type.getLoc (), resType, value, isLvalue-> value.isLvalue ());
                        (typeTest, ctdValue)
                    }
                }
                _ => { // Any other type test is cte evaluated
                    (cast!{&Value} (BoolValue::new (vdecl.getType ().getLoc (), true)), value)
                }
            };

            (typeTest, t, castedValue)
        } else { // create a type for mutability checking
            let (_, t) = context:.validateType (TypeWrapperExpr::new (value.getLoc (), value.getType ()), decos-> vdecl.getDecos (), canBeRef-> isRef);
            let type = if (isPure) { t.clone (0u32) } else { t };
            (cast!{&Value} (BoolValue::new (vdecl.getLoc (), true)), type, value) // type test is always true
        };

        // Reducing the value is it not to be passed by reference
        let reducedVal = if (!byMutRef && !isRef) { context:.getCompileTimeInterpreter ().reduce (castedValue) } else { castedValue };

        // Transform the value to be implicit casted to the type
        let ctdValue = context:.verifyCompatibleTypeWithValue (vdecl.getLoc (), type, reducedVal, byReference-> isRef);

        // transform the value into a ref or an alias if the root value was passed by ref or alias
        let (postCtdValue, useRef, useAlias) = if (byMutRef && isRef && ctdValue.isLvalue () && ctdValue.getType ().isMutable ()) {
            (cast!{&Value} (ReferencerValue::new (reducedVal.getLoc (), ctdValue.getType (), ctdValue, isMutable-> true)), true, false)
        } else if (!isRef && (byAlias || byMutRef) && type.isMutable () && type.needExplicitAlias ()) {
            (AliaserValue::new (value.getLoc (), ctdValue.getType (), ctdValue), false, true) // if we mix pattern using ref and alias, then ref has priority and can be used as alias
        } else if (isRef && !byMutRef && ctdValue.isLvalue ()) {
            (cast!{&Value} (ReferencerValue::new (reducedVal.getLoc (), ctdValue.getType (), ctdValue, isMutable-> false)), false, false)
        } else { (ctdValue, false, false) };

        // Verify memory implicit alias/ref and mutability
        context:.verifyMemoryOwner (vdecl.getLoc (), type, postCtdValue, construct-> true, byReference-> isRef);
        (test, type, postCtdValue, castedValue, useRef, useAlias)
    }


    /**
     * Validate a call operator matcher
     * @params:
     *    - context: the context of the validation
     *    - value: the value to match
     *    - cl: the call operator
     *    - vars: the list of variables to be declared the matching
     *    - byMutRef: true iif the root value was passed by mutable reference
     *    - byAlias: true iif the root value was pass by alias
     * @returns:
     *    - .0: the condition to evaluate at runtime
     *    - .1: true iif byMutRef was useful
     *    - .2: true iif byAlias was useful
     * */
    fn validateCallOpMatcher (self, dmut context : &Validator, value : &Value, cl : &MultOperatorExpr, dmut vars : &Vec!{([c8], &Value)}, byMutRef : bool, byAlias : bool)-> (&Value, bool, bool)
        throws &ErrorMsg
    {
        let validateL = match cl.getLeft () { // don't validate _ ()
            v : &VarExpr => {
                v.getLoc () != Keys::UNDER
            }
            _ => { true }
        };

        let (typeCond, castedValue) = if (validateL) { // Validate the type X in /X (fields-> ...)/
            let type = context:.validateType (cl.getLeft ());
            let (typeTest, castedValue) = match (value.getType (), type) {
                (ClassPtrType (), inner : &ClassPtrType) => { // a class reverse casting: Base -> Derived can only be known at cte (
                                                              // unless it is a Derived -> Base, but that is already managed by the binary operator validator
                    let typeTest = context:.getBinOpValidator ().validateClassTypeTestOp (alias context, type.getLoc (), BinaryOperators::OF, value, inner.getInner ());

                    // we clone the derived type to match the base type mutability
                    let resType = type.clone (pattern-> value.getType ());
                    (typeTest, cast!{&Value} (CastValue::new (type.getLoc (), resType, value, isLvalue-> value.isLvalue ()))) // transform the value into the derived type
                }
                (ClassPtrType (), inner : &ClassRefType) => { // Same as class ptr, but in MultOp a class ref can be used directly (Derived () => ) to match &Base
                    let typeTest = context:.getBinOpValidator ().validateClassTypeTestOp (alias context, type.getLoc (), BinaryOperators::OF, value, inner);

                    // we clone the derived type to match the base type mutability
                    let resType = ClassPtrType::new (type.getLoc (), inner).clone (pattern-> value.getType ());
                    (typeTest, cast!{&Value} (CastValue::new (type.getLoc (), resType, value, isLvalue-> value.isLvalue ())))
                }
                _ => { // Any other type test is cte evaluated
                    context.verifyCompatibleType (value.getLoc (), type.getLoc (), value.getType (), type);
                    (cast!{&Value} (BoolValue::new (type.getLoc (), true)), value)
                }
            };

            (typeTest, castedValue)
        } else {
            (cast!{&Value} (BoolValue::new (cl.getLeft ().getLoc (), true)), value)
        };

        let mut curValueTest : &Value = BoolValue::new (cl.getLoc (), true);
        let mut innerUseRef = false, mut innerUseAlias = false;
        for p in cl.getRights () match p {
            n : &NamedExpr => {
                let val = context:.getBinOpValidator ().validateFieldOperation (alias context, n.getLoc (), BinaryOperators::DOT, castedValue, VarExpr::new (n.getLoc ()));
                let (innerTest, innerUseRef_, innerUseAlias_) = {
                    self.validateMatcher (alias context, val, n.getContent (), alias vars, byMutRef, byAlias)
                } catch {
                    error : &ErrorMsg => {
                        throw error.withNote ([ErrorMsg::note (n.getLoc (), format (ValidateErrorMessage::FOR_PATTERN_FIELD, n.getLoc ().str (), castedValue.getType ()))]);
                    }
                }

                curValueTest = LogicalBinBoolOperatorValue::new (n.getLoc (), BinaryOperators::DAND, curValueTest, innerTest);
                innerUseRef = innerUseRef_ || innerUseRef;
                innerUseAlias = innerUseAlias_ || innerUseAlias;
            }
            _ => __pragma!panic ();
        }

        (LogicalBinBoolOperatorValue::new (cl.getLoc (), BinaryOperators::DAND, typeCond, curValueTest), innerUseRef, innerUseAlias)
    }

    /**
     * Validate an option matcher
     * @params:
     *     - context: the context of the validation
     *     - value: the value being matched
     *     - opt: the option matcher to validate
     *     - vars: the list of variables to be declared the matching
     *     - byMutRef: true iif the root value was passed by mutable reference
     *     - byAlias: true iif the root value was pass by alias
     * @returns:
     *    - .0: the runtime test
     *    - .1: true iif byMutRef was useful
     *    - .2: true iif byAlias was useful
     * */
    fn validateOptionMatcher (self, dmut context : &Validator, value : &Value, opt : &OptionMatcherExpr, dmut vars : &Vec!{([c8], &Value)}, byMutRef : bool, byAlias : bool)-> (&Value, bool, bool)
        throws &ErrorMsg
    {
        let loc = opt.getLoc ();
        if (!value.getType ().isOf!{&OptionType} ()) { // only option values can be passed to option pattern
            throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::OPTION_MATCHER, loc, value.getType ()));
        }

        let optType = value.getType ().asOf!{&OptionType} ();
        let isSet = StructFieldAccessValue::new (loc, BoolType::new (loc), value, OptionKeys::SET);
        if (loc == OptionKeys::MATCH_SOME) match opt.getInner () { // /Ok/
            EmptyExpression () => return (isSet, false, false);
            exp : &Expression => { // e.g. /Ok (x : _)/
                let innerVal = OptionFieldAccessValue::new (loc, optType.getInners ()[0], value, OptionKeys::VALUE);
                // Validate the pattern on the value of the option
                let (innerTest, innerUseRef, innerUseAlias) = self.validateMatcher (alias context, innerVal, exp, alias vars, byMutRef, byAlias);

                return (LogicalBinBoolOperatorValue::new (loc, BinaryOperators::DAND, isSet, innerTest), innerUseRef, innerUseAlias);
            }
        } else match opt.getInner () { // /Err/
            EmptyExpression () => {
                return (UnaryBoolOperatorValue::new (loc, UnaryOperators::NOT, isSet), false, false);
            }
            exp : &Expression => { // e.g. /Err (x : _)/
                let ptrType = PointerType::new (loc, VoidType::new (loc));

                // all none option don't have an error, they may be completely empty, so we need to check that
                let hasError = CmpPointerOperatorValue::new (loc, BinaryOperators::NOT_EQUAL,
                                                             OptionFieldAccessValue::new (loc, ptrType, value, OptionKeys::ERROR),
                                                             NullValue::new (loc, ptrType));

                let notSet = UnaryBoolOperatorValue::new (loc, UnaryOperators::NOT, isSet);
                let finTest = LogicalBinBoolOperatorValue::new (loc, BinaryOperators::DAND, notSet, hasError); // !isSet && error != null


                let innerType = context:.getExceptionType (loc-> loc);
                let err = OptionFieldAccessValue::new (loc, innerType, value, OptionKeys::ERROR);

                // Validate the pattern on the error of the option
                let (innerTest, innerUseRef, innerUseAlias) = self.validateMatcher (alias context, err, exp, alias vars, byMutRef, byAlias);

                return (LogicalBinBoolOperatorValue::new (loc, BinaryOperators::DAND, finTest, innerTest), innerUseRef, innerUseAlias);
            }
        }
    }

    /**
     * Validate a tuple matcher
     * @params:
     *    - context: the context of the validation
     *    - value: the value to match
     *    - tu: the tuple list
     *    - vars: the list of variables to be declared the matching
     *    - byMutRef: true iif the root value was passed by mutable reference
     *    - byAlias: true iif the root value was pass by alias
     * @returns:
     *    - .0: the runtime test
     *    - .1: true iif byMutRef was useful
     *    - .2: true iif byAlias was useful
     * */
    fn validateTupleMatcher (self, dmut context : &Validator, value : &Value, tu : &ListMatcherExpr, dmut vars : &Vec!{([c8], &Value)}, byMutRef : bool, byAlias : bool)-> (&Value, bool, bool)
        throws &ErrorMsg
    {
        let loc = tu.getLoc ();
        let values = self.expandTupleValues (alias context, loc, tu, value); // transform the tuple into a list of values so the rest of the validation gets easier
        if (tu.isVariadic () && tu.getParameters ().len - 1us > values.len) { // (x,z...) = (1,) is ok, x <- 1, z <- (), but (x,z...) = () is not there is nothing for x
            throw ErrorMsg::fatal (tu.getLoc (), format (ValidateErrorMessage::TUPLE_ARITY_OVERFLOW, tu.getParameters ().len, values.len));
        } else if (!tu.isVariadic () && tu.getParameters ().len != values.len) { // (x,) = (1,2) or (x, y) = (1,) are not ok
            throw ErrorMsg::fatal (tu.getLoc (), format (ValidateErrorMessage::TUPLE_ARITY_OVERFLOW, tu.getParameters ().len, values.len));
        }

        // pattern match inner values
        let mut curValueTest : &Value = BoolValue::new (loc, true);
        let mut innerUseRef = false, mut innerUseAlias = false;
        for i, p in tu.getParameters () {
            // currField is used for clearer errors
            let (assocValue, currField) = if (i != tu.getParameters ().len - 1us || !tu.isVariadic ()) {
                (values [i], format ("%",i)) // one value by one value
            } else { // e.g. (x, y...) = (1, 2, 3), y <- (2, 3)
                let rest = values [i .. $];
                let dmut tupleTypes = Vec!{&Type}::new ();
                for j in i .. values.len { // create a tuple type to get all last values
                    tupleTypes:.push (values [j].getType ());
                }

                let tupleType = TupleType::new (value.getLoc (), tupleTypes[], isMutable-> value.getType ().isMutable ());

                // declare a tuple literal containing the values
                (cast!{&Value} (TupleValue::new (value.getLoc (), tupleType, rest)), format ("%..%", i, values.len))
            };

            let (innerTest, innerUseRef_, innerUseAlias_) = {
                self.validateMatcher (alias context, assocValue, p, alias vars, byMutRef, byAlias)
            } catch {
                err : &ErrorMsg => { // add a note to the error so its easier to get the value responsible for the error
                    throw err.withNote ([ErrorMsg::note (tu.getLoc (), format (ValidateErrorMessage::FOR_PATTERN_FIELD, currField, value.getType ()))]);
                }
            };

            curValueTest = LogicalBinBoolOperatorValue::new (loc, BinaryOperators::DAND, curValueTest, innerTest);
            innerUseRef = innerUseRef || innerUseRef_;
            innerUseAlias = innerUseAlias || innerUseAlias_;
        }

        (curValueTest, innerUseRef, innerUseAlias)
    }

    /**
     * Expand the tuple values (unlike expand from intrinsic, this expand allows for mutable)
     * @warning: only tuple typed value can be used here (value.getType () of TupleType)
     * @returns: a list of values (tuple field accessed)
     * */
    fn expandTupleValues (self, dmut context : &Validator, loc : &Word, tu : &ListMatcherExpr, value : &Value)-> [&Value]
        throws &ErrorMsg
    {
        let dmut tyValues = Vec!{&Value}::new ();
        match value.getType () {
            ty : &TupleType => {
                // expand the tuple, so it can be easily read
                for it in 0us .. ty.getInners ().len {
                    let access = context:.getBinOpValidator ().createTupleFieldAccess (loc, ty.getInners ()[it], value, it, reduce-> false);
                    tyValues:.push (access); // context.getCompileTimeInterpreter ().reduce (access));
                }
            }
            _ => { //
                throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::TUPLE_PATTERN, tu, value.getType ()));
            }
        }

        tyValues[]
    }

    /**
     * Validate an array matcher
     * @params:
     *    - context: the context of the validation
     *    - value: the value to match
     *    - arr: the array list
     *    - vars: the list of variables to be declared the matching
     *    - byMutRef: true iif the root value was passed by mutable reference
     *    - byAlias: true iif the root value was pass by alias
     * @returns:
     *    - .0: the runtime test
     *    - .1: true iif byMutRef was useful
     *    - .2: true iif byAlias was useful
     * */
    fn validateArrayMatcher (self, dmut context : &Validator, value : &Value, arr : &ListMatcherExpr, dmut vars : &Vec!{([c8], &Value)}, byMutRef : bool, byAlias : bool)-> (&Value, bool, bool)
        throws &ErrorMsg
    {
        let loc = arr.getLoc ();
        let len = { // retreive the length of the value
            context:.getBinOpValidator ().validateFieldOperation (alias context, value.getLoc (), BinaryOperators::DOT, value, VarExpr::new (Word::new (SliceKeys::LEN, value.getLoc ())))
        } catch {
            err : &ErrorMsg => { // the value does not have a LEN field (TODO maybe make a test for class object to implement a specific traits?)
                throw err.withNote ([ErrorMsg::note (loc, ValidateErrorMessage::HERE)]);
            }
        }

        // Runtime check of the len of the value
        let (lenTest, ex) = if (arr.isVariadic ()) {
            let ex = makeIntValue (arr.getParameters ().len - 1us); // if it is variadic, then the value should contain at least N - 1 elements (e.g. [x, y...] = [1] is ok, with N = 2, [y...] = [] is ok with N = 1)
            (cast!{&Value} (CmpIntOperatorValue::new (loc, BinaryOperators::SUP_EQUAL, len, ex)), ex)
        } else {
            let ex = makeIntValue (arr.getParameters ().len); // not variadic, thus the value has to contain the same number of elements as in the pattern (e.g. [x, y] = [1, 2] is ok, but not [x, y] = [1])
            (cast!{&Value} (CmpIntOperatorValue::new (loc, BinaryOperators::DEQUAL, len, ex)), ex)
        };

        match context:.getCompileTimeInterpreter ().reduce (lenTest) {
            b : &BoolValue => { // if the len test is CTE we can send an error if it is not valid (e.g. for array values)
                if (!b.isTrue ()) throw ErrorMsg::fatal (arr.getLoc (), format (ValidateErrorMessage::ARRAY_PATTERN_SIZE, ex, len));
            }
        }

        // these tokens are used in index access syntax at each iteration, we construct them once to avoid overusing memory for nothing
        let lcro = Word::new (Tokens::LCRO, loc), rcro = Word::new (Tokens::RCRO, loc);

        let mut curValueTest : &Value = BoolValue::new (loc, true);
        let mut innerUseRef = false, mut innerUseAlias = false;
        for i, p in arr.getParameters () {
            // currField is used for clearer errors
            let (assocValue, currField) = { // access elements indexed in the value
                context:.enterUnsafeContext (arr.getLoc ()); // entering unsafe context to avoid slice of array len checking that would be useless
                if (i != arr.getParameters ().len - 1us || !arr.isVariadic ()) { // one by one
                    let index = makeIntValue (i);
                    let acc = context:.getIndexOpValidator ().validate (alias context, MultOperatorExpr::new (lcro, rcro, ValueWrapperExpr::new (value.getLoc (), value), [ValueWrapperExpr::new (loc, index)])); // /value [i]/
                    (acc, format ("%", i))
                } else { // variadic, we access the rest of the elements in the value
                    let index = makeIntValue (i);
                    let rng = RangeValue::new (loc, RangeType::new (loc, index.getType ().asOf!{&IntType} (), IntType::new (loc, size-> 0u16, signed-> true), false), index, len);
                    let acc = context:.getIndexOpValidator ().validate (alias context, MultOperatorExpr::new (lcro, rcro, ValueWrapperExpr::new (value.getLoc (), value), [ValueWrapperExpr::new (loc, rng)])); // /value [i .. $]/
                    (acc, format ("%..$", i))
                }
            } exit {
                context:.exitUnsafeContext ()?;
            };

            let (innerTest, innerUseRef_, innerUseAlias_) = {
                self.validateMatcher (alias context, assocValue, p, alias vars, byMutRef, byAlias)
            } catch {
                err : &ErrorMsg => { // note the error for clearer errors
                    throw err.withNote ([ErrorMsg::note (loc, format (ValidateErrorMessage::FOR_PATTERN_FIELD, currField, value.getType ()))]);
                }
            }

            curValueTest = LogicalBinBoolOperatorValue::new (loc, BinaryOperators::DAND, curValueTest, innerTest);
            innerUseRef = innerUseRef || innerUseRef_;
            innerUseAlias = innerUseAlias || innerUseAlias_;
        }

        (LogicalBinBoolOperatorValue::new (loc, BinaryOperators::DAND, lenTest, curValueTest), innerUseRef, innerUseAlias)
    }

    /**
     * Validate a matcher using a value
     * @info: from there, no variable can be created anymore just value equality (thus no need for vars, byMutRef and byAlias)
     * @params:
     *    - context: the context of the validation
     *    - value: the value to match
     *    - mtch: the matcher value
     * @returns: the condition to evaluate at runtime
     * */
    fn validateValueEqualMatcher (self, dmut context : &Validator, value : &Value, mtch : &Expression)-> &Value
        throws &ErrorMsg
    {
        match mtch {
            b : &BinaryExpr => {
                if b.getLoc () == BinaryOperators::PIPE { // e.g. /x | y | 12/, means either x or y or 12
                    let left = self.validateValueEqualMatcher (alias context, value, b.getLeft ());
                    let right = self.validateValueEqualMatcher (alias context, value, b.getRight ());

                    return LogicalBinBoolOperatorValue::new (mtch.getLoc (), BinaryOperators::DPIPE, left, right); // left || right
                }
            }
            t : &VarExpr => { // ignoring value when encoutering the var reference expr /_/
                if (t.getLoc () == Keys::UNDER) return BoolValue::new (mtch.getLoc (), true);
            }
        }

        let eqVal = context:.validateValue (mtch); // otherwise making a strong equality test (value == mtch), where mtch is constructed inside the test
        context:.getBinOpValidator ().validateComparisonOperation (alias context, mtch.getLoc (), BinaryOperators::DEQUAL, value, eqVal)
    }


    /*!
     * ================================================================================
     * ================================================================================
     * =========================         VERIFICATION         =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * @returns: true if the list condition is a tautology
     * @warning: could clearly be enhanced, for example if the test is checking for all the values of an enum, or a list of base types of exceptions are tested TODO
     * */
    fn isTautology (self, dmut context : &Validator, cond : &Value)-> bool
        throws &ErrorMsg
    {
        let red = context.getCompileTimeInterpreter ().reduce (cond);
        match red {
            b : &BoolValue => return b.isTrue ();
        }

        false
    }

    /**
     * Verify that all the branches have the correct type, i.e. if the match is not complete, then branch values must be void
     * @returns: the final type of the match<
     * @throws:
     *    - &ErrorMsg: if the match is not complete, but branch values are not void
     * */
    fn verifyComplete (self, loc : &Word, value : &Value, complete : bool, type : &Type, values : [&Value])-> &Type
        throws &ErrorMsg
    {
        let retType = if (!complete) { cast!{&Type} (VoidType::new (loc)) } else { type };

        if (!complete) {
            let dmut errors = Vec!{&ErrorMsg}::new ();
            for i in values {
                if (!i.getType ().isOf!{&VoidType} ()) {
                    errors:.push (ErrorMsg::fatal (i.getLoc (), format (ValidateErrorMessage::MATCH_NOT_COMPLETE, i.getType ())));
                }
            }

            if (errors.len () != 0us) {
                throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::MATCH_VALIDATION, value, value.getType ()), notes-> errors []);
            }
        }

        retType
    }

    /**
     * Variables declared within pattern are not inserted in local block
     * Thus we need to verify that they are not shadowing each other within the same pattern
     * */
    fn verifyShadowPattern (self, loc : &Word, vars : [([c8], &Value)])
        throws &ErrorMsg
    {
        for v in vars match v.1 {
            vd : &VarDeclValue => {
                if (vd.getLoc ().str () == loc.str ()) {
                    throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::SHADOWING_DECL, loc.str ()),
                                           notes-> [ErrorMsg::note (vd.getLoc (), ValidateErrorMessage::FIRST_DEFINED)]
                                       );
                }
            }
            _ => __pragma!panic ();
        }
    }
}
