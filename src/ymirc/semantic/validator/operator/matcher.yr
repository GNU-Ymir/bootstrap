mod ymirc::semantic::validator::operator::matcher;

import std::io;
import std::collection::vec;

import ymirc::semantic::validator::visitor;
import ymirc::semantic::validator::errors;
import ymirc::errors::_;
import ymirc::utils::format;
import ymirc::semantic::generator::value::_;
import ymirc::syntax::expression::_;
import ymirc::syntax::keys;

import ymirc::lexing::tokens;
import ymirc::lexing::word;


import ymirc::semantic::generator::type::_;

/**
 * The match validator used to validate MatcherExpr
 * It is a class validator because match expression are complex
 */
pub class MatcherValidator {

    /**
     * Create an empty validator
     */
    pub self () {}


    /**
     * Validate a match expression
     * @params: 
     *    - context: the context of the validation
     *    - m: the matcher to validate
     * @returns: a value
     * @throws: 
     *    - &ErrorsMsg: if the validation failed
     */
    pub fn validate (self, dmut context : &Validator, m : &MatcherExpr)-> &Value
        throws &ErrorMsg
    {
        let mValue = context:.validateValue (m.getContent ());
        let matchers = m.getMatchers ();
        let (conds, values, errors, type, complete) = self.validateMatchers (alias context, m.getLoc (), mValue, matchers);

        if (errors.len != 0us) {
            throw ErrorMsg::fatal (m.getLoc (), format (ValidateErrorMessage::MATCH_VALIDATION, mValue, mValue.getType ()), notes-> errors);
        }

        if (conds.len > 0us) {
            let finType = self.verifyComplete (m.getLoc (), mValue, complete, type, values);
            let mut current : &Value = UNIT_VALUE;
            for i in conds.len .. 0us {
                current = self.createConditional (conds [i - 1us], values [i - 1us], else_-> current, finType, isComplete-> complete);
            }

            match current {
                UnitValue () => { return BlockValue::new (m.getLoc (), VoidType::new (m.getLoc ()), []); }
            }

            return current;
        }

        return BlockValue::new (m.getLoc (), VoidType::new (m.getLoc ()), []);
    }

    /**
     * Validate the list of matchers from the pattern matching
     * @params:
     *    - context: the context of the validation
     *    - value: the value being matched
     *    - matchers: the list of matchers
     * @returns:
     *    - .0: the list of conditions
     *    - .1: the list of validated values if conditions are true
     *    - .2: the list of errors during the validation
     *    - .3: the type result of the matcher (@warning: before checking completness)
     *    - .4: true if the matcher is complete
     * */
    fn validateMatchers (self, dmut context : &Validator, loc : &Word, value : &Value, matchers : [(&Expression, &Expression)])-> ([&Value], [&Value], [&ErrorMsg], &Type, bool) {
        let mut finType : &Type = NoneType::new (loc);
        let mut complete = false;
        let mut currentTautCond : &Value = UNIT_VALUE;

        let dmut conds = Vec!{&Value}::new ();
        let dmut values = Vec!{&Value}::new ();
        let dmut errors = Vec!{&ErrorMsg}::new ();

        for mtch in matchers {
            let mut succeed = true;
            context:.enterBlock ();
            {
                if (complete) {
                    throw ErrorMsg::fatal (mtch.0.getLoc (), ValidateErrorMessage::UNREACHABLE_MATCHER);
                }

                let cond = self.validateMatcher (alias context, value, mtch.0);
                conds:.push (cond);

                let mut val = context:.validateValue (mtch.1);
                let (t, v) = context:.inferTypeBranchingWithValue (finType.getLoc (), finType, val);
                values:.push (v);
                finType = t;

                currentTautCond = match currentTautCond {
                    UnitValue () => { cond }
                    _ => {
                        cast!{&Value} (LogicalBinBoolOperatorValue::new (cond.getLoc (), BinaryOperators::DPIPE, cond, currentTautCond))
                    }
                }

                complete = self.isTautology (alias context, currentTautCond);
            } catch {
                err : &ErrorMsg => {
                    errors:.push (err);
                    succeed = false;
                }
            }

            {
                context:.quitBlock (warnUnused-> succeed);
            } catch {
                err : &ErrorMsg => errors:.push (err);
            }
        }

        (conds[], values[], errors[], finType, complete)
    }



    /**
     * Create a conditional value for a given pattern match
     * @params:
     *    - cond: the condition
     *    - val: the value to evaluate if the condition is true
     *    - else_: the value to evaluate if the condition is false
     * */
    fn createConditional (self, cond : &Value, val : &Value, else_ : &Value, type : &Type, isComplete : bool)-> &Value {
        match cond {
            b : &BoolValue => {
                return if b.isTrue () { val } else { else_ };
            }
        }

        ConditionalValue::new (cond.getLoc (), type, cond, val, elsev-> else_, isComplete-> isComplete)
    }


    /**
     * ================================================================================
     * ================================================================================
     * ==========================         VALIDATION         ==========================
     * ================================================================================
     * ================================================================================
     */


    /**
     * Validate a matcher
     * @params:
     *   - context: the context of the validation
     *   - value: the value to match
     *   - mtch: the matcher expression
     * @returns: the condition to evaluate at runtime
     * */
    fn validateMatcher (self, dmut context : &Validator, value : &Value, mtch : &Expression)-> &Value
        throws &ErrorMsg
    {
        return match mtch {
            v : &VarDeclExpr => {
                self.validateVarDeclMatcher (alias context, value, v)
            }
            m : &MultOperatorExpr => {
                self.validateCallOpMatcher (alias context, value, m)
            }
            l : &ListExpr => {
                if (l.getLoc () == Tokens::LPAR) {
                    self.validateTupleMatcher (alias context, value, l)
                } else {
                    self.validateArrayMatcher (alias context, value, l)
                }
            }
            _ => {
                self.validateValueEqualMatcher (alias context, value, mtch)
            }
        };
    }

    /**
     * Validate a var declaration matcher
     * @params:
     *    - context: the context of the validation
     *    - value: the value to match
     *    - vdecl: the variable declaration
     * @returns: the condition to evaluate at runtime
     * */
    fn validateVarDeclMatcher (self, dmut context : &Validator, value : &Value, vdecl : &VarDeclExpr)-> &Value
        throws &ErrorMsg
    {
        context;
        value;
        vdecl;
        __pragma!fake_throw (&ErrorMsg);
        __pragma!panic ();

        // let dmut errors = Vec!{&ErrorMsg}::new ();
        // if (vdecl.getLoc () != Keys::UNDER) context:.verifyShadow (vdecl.getLoc ());

        // let isPure = context.findDecos (v.getDecos (), [Decorators::PURE]);
        // let isRef = context.findDecos (v.getDecos (), [Decorators::REF]);
        // let isMutable = context.findDecos (v.getDecos (), [Decorators::MUT, Decorators::DMUT]);

        // let typeCond = if (!vdecl.getType ().isOf!{&EmptyExpression} ()) { // not '_'
        //     let (_, t) = context:.validateType (vdecl.getType (), decos-> vdecl.getDecos (), canBeRef-> isRef);
        //     let type = if (isPure) { t.clone (0u32) } else { t };

        //     if (type.isCompatible (value.getType ())) {
        //         BoolValue::new (t.getLoc (), true)
        //     } else {
        //         if (context.isAncestor (value.getType (), type)) {

        //         }
        //     }
        // }

    }

    /**
     * Validate a call operator matcher
     * @params:
     *    - context: the context of the validation
     *    - value: the value to match
     *    - cl: the call operator
     * @returns: the condition to evaluate at runtime
     * */
    fn validateCallOpMatcher (self, dmut context : &Validator, value : &Value, cl : &MultOperatorExpr)-> &Value
        throws &ErrorMsg
    {
        context;
        value;
        cl;
        __pragma!fake_throw (&ErrorMsg);
        __pragma!panic ();
    }

    /**
     * Validate a tuple matcher
     * @params:
     *    - context: the context of the validation
     *    - value: the value to match
     *    - tu: the tuple list
     * @returns: the condition to evaluate at runtime
     * */
    fn validateTupleMatcher (self, dmut context : &Validator, value : &Value, tu : &ListExpr)-> &Value
        throws &ErrorMsg
    {
        context;
        value;
        tu;
        __pragma!fake_throw (&ErrorMsg);
        __pragma!panic ();
    }

    /**
     * Validate an array matcher
     * @params:
     *    - context: the context of the validation
     *    - value: the value to match
     *    - arr: the array list
     * @returns: the condition to evaluate at runtime
     * */
    fn validateArrayMatcher (self, dmut context : &Validator, value : &Value, arr : &ListExpr)-> &Value
        throws &ErrorMsg
    {
        context;
        value;
        arr;
        __pragma!fake_throw (&ErrorMsg);
        __pragma!panic ();
    }

    /**
     * Validate a matcher using a value
     * @info: from there, no variable can be created anymore just value equality
     * @params:
     *    - context: the context of the validation
     *    - value: the value to match
     *    - mtch: the matcher value
     * @returns: the condition to evaluate at runtime
     * */
    fn validateValueEqualMatcher (self, dmut context : &Validator, value : &Value, mtch : &Expression)-> &Value
        throws &ErrorMsg
    {
        match mtch {
            b : &BinaryExpr => {
                if b.getLoc () == BinaryOperators::PIPE {
                    let left = self.validateValueEqualMatcher (alias context, value, b.getLeft ());
                    let right = self.validateValueEqualMatcher (alias context, value, b.getRight ());

                    return LogicalBinBoolOperatorValue::new (mtch.getLoc (), BinaryOperators::DPIPE, left, right);
                }
            }
            t : &VarExpr => {
                if (t.getLoc () == Keys::UNDER) return BoolValue::new (mtch.getLoc (), true);
            }
        }

        let eqVal = context:.validateValue (mtch);
        context:.getBinOpValidator ().validateComparisonOperation (alias context, mtch.getLoc (), BinaryOperators::DEQUAL, value, eqVal)
    }


    /**
     * ================================================================================
     * ================================================================================
     * =========================         VERIFICATION         =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * @returns: true if the list condition is a tautology
     * */
    fn isTautology (self, dmut context : &Validator, cond : &Value)-> bool
        throws &ErrorMsg
    {
        let red = context.getCompileTimeInterpreter ().reduce (cond);
        match red {
            b : &BoolValue => return b.isTrue ();
        }

        false
    }

    /**
     * Verify that the match is complete
     * If it is note, then branch values must be void
     * @returns: the final type of the match
     * @throws:
     *    - &ErrorMsg: if the match is not complete, but branch values are not void
     * */
    fn verifyComplete (self, loc : &Word, value : &Value, complete : bool, type : &Type, values : [&Value])-> &Type
        throws &ErrorMsg
    {
        let retType = if (!complete) { cast!{&Type} (VoidType::new (loc)) } else { type };

        if (!complete) {
            let dmut errors = Vec!{&ErrorMsg}::new ();
            for i in values {
                if (!i.getType ().isOf!{&VoidType} ()) {
                    errors:.push (ErrorMsg::fatal (i.getLoc (), format (ValidateErrorMessage::MATCH_NOT_COMPLETE, i.getType ())));
                }
            }

            if (errors.len () != 0us) {
                throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::MATCH_VALIDATION, value, value.getType ()), notes-> errors []);
            }
        }

        retType
    }

}
