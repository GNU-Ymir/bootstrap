in matcher;

use ymirc::semantic::validator::{visitor, errors, template::_};

use ymirc::errors::_;
use ymirc::utils::format;
use ymirc::semantic::generator::{value::_, type::_};
use ymirc::syntax::{_,
                    declaration::_,
                    expression::{_, literal::_, macro_::_, operator::_, template::_}};

use ymirc::lexing::{word, tokens};
use ymirc::global::core_;

use ymirc::semantic::generator::type::{_,
                                       syntax::_,
                                       custom::_,
                                       native::{_, scalar::_, compound::_},
                                       temporary::_};

use ymirc::semantic::generator::value::{_,
                                        syntax::_,
                                        construct::{_, delegate::_},
                                        literal::_,
                                        memory::_,
                                        operator::{_, binary::_, call::_, fields::_, map::_, slice::_, unary::_},
                                        operator::binary::{bool_::_, char_::_, float_::_, int_::_, pointer_::_},
                                        operator::map::iteration::_,
                                        prototypes::_,
                                        scope::_,
                                        syntax::_,
                                        template::_};

pub record MemoryInfo {
    pub let byAlias : bool;
    pub let byMutRef : bool;
    pub let byMove : bool;
    pub let byLazy : bool;

    pub self (byAlias : bool = false, byMutRef : bool = false, byMove : bool =  false, byLazy : bool = false)
        with byAlias = byAlias
        , byMutRef = byMutRef
        , byMove = byMove
        , byLazy = byLazy
    {}
}

fn or (left : MemoryInfo, right : MemoryInfo)-> MemoryInfo {
    MemoryInfo (byAlias-> left.byAlias || right.byAlias,
                byMutRef-> left.byMutRef || right.byMutRef,
                byMove-> left.byMove || right.byMove,
                byLazy-> left.byLazy || right.byLazy)
}

/**
 * The match validator used to validate MatcherExpr
 * It is a class validator because match expression are complex
 */
pub record MatcherValidator {

    /**
     * Create an empty validator
     */
    pub self () {}


    /**
     * Validate a match expression
     * @params: 
     *    - context: the context of the validation
     *    - m: the matcher to validate
     * @returns: a value
     * @throws: 
     *    - &ErrorsMsg: if the validation failed
     */
    pub fn validate (self, dmut context : &Validator, m : &MatcherExpr)-> &Value
        throws ErrorMsg
    {
        let mValue = context:.getValueValidator ().validate (alias context, m.getContent (), canBeRef-> true);
        context.verifyNoBreaking (m.getLoc (), mValue);
        context.verifyCompleteTypeWithValue (m.getContent ().getLoc (), mValue.getType (), mValue, construct-> true);

        let matchers = m.getMatchers ();
        let (memInfo, isRef) = match mValue {
            r : &ReferencerValue => { (MemoryInfo (byMutRef-> r.isMutable ()), true) }
            AliaserValue () => { (MemoryInfo (byAlias-> true), false) }
            _ => { (MemoryInfo (byMove-> !context.needExplicitMove (mValue)), false) } // is explicit move, if there is no need for a move to move
        };

        // Ensure the value is constructed (and only once) for each branch checks
        let uniqDecl = copy VarDeclValue (copy Word ("#_value", mValue.getLoc ()), mValue.getType (), mValue, isMutable-> true, isReference-> isRef, isLazy-> false);
        let uniq = copy VarRefValue (uniqDecl.getLoc (), uniqDecl.getLoc (), mValue.getType (), uniqDecl.getUniqId (), isSelf-> false, canCte-> false);

        let (conds, values, errors, type, complete, retInfo) = self.validateMatchers (alias context, m.getLoc (), uniq, matchers, memInfo);
        if (errors.len != 0us) {
            throw copy ErrorMsg::fatal (m.getLoc (), format (ValidateErrorMessage::MATCH_VALIDATION, mValue, mValue.getType ()), notes-> errors);
        }

        if (!retInfo.byMutRef && memInfo.byMutRef) {
            throw copy ErrorMsg::fatal (mValue.getLoc (), ValidateErrorMessage::UNECESSARY_REFERENCE,
                                        notes-> copy [copy ErrorMsg::note (m.getLoc (), ValidateErrorMessage::NO_REFERENCE_PATTERN)]);
        } else if (!retInfo.byAlias && memInfo.byAlias) {
            throw copy ErrorMsg::fatal (mValue.getLoc (), format (ValidateErrorMessage::UNECESSARY_ALIAS, mValue.getType ()),
                                        notes-> copy [copy ErrorMsg::note (m.getLoc (), format (ValidateErrorMessage::NO_ALIAS_PATTERN, ""))]);
        }

        if (conds.len > 0us) {
            let finType = self.verifyComplete (m.getLoc (), uniq, complete, type, values);
            let mut current : &Value = UNIT_VALUE;
            for i in conds.len .. 0us {
                current = self.createConditional (m.getLoc (), conds [i - 1us], values [i - 1us], else_-> current, finType, isComplete-> complete);
            }

            match current {
                UnitValue () => { return copy BlockValue (m.getLoc (), copy VoidType (m.getLoc ()), copy [uniqDecl]); }
            }

            return copy BlockValue (m.getLoc (), current.getType (), copy [uniqDecl, current]);
        }

        return copy BlockValue (m.getLoc (), copy VoidType (m.getLoc ()), copy [uniqDecl]);
    }

    /**
     * Validate a catcher pattern matching
     * @params
     *    - context : the context of the validation
     *    - m: the pattern matching to validate
     *    - tryType: the type of the try part that is caught
     *    - catchVar : the var reference to the variable taking the thrown exception
     *    - throwers: the list of exception that the catchVar can take
     * @returns:
     *    - .0: the list of actions
     *    - .1: the type of catch actions
     * */
    pub fn validateCatcher (self, dmut context : &Validator, m : &MatcherExpr, tryType : &Type, catchVar : &Value, throwers : [(&Word, &Type)])-> (&Value, &Type)
        throws ErrorMsg
    {
        let (conds, values, errors, type, rests) = self.validateMatchersForCatch (alias context, m.getLoc (), tryType, catchVar, m.getMatchers (), throwers);
        if (errors.len != 0us) {
            throw copy ErrorMsg::fatal (m.getLoc (), format (ValidateErrorMessage::CATCH_VALIDATION, catchVar.getType ()), notes-> errors);
        }

        if (rests.len != 0us) {
            let mut errorRest : [&ErrorMsg] = copy [copy ErrorMsg::fatal (m.getLoc (), end-> i._0, format (ValidateErrorMessage::EXCEPTION_NOT_CAUGHT, i._1))
                                                    for i in rests];
            throw copy ErrorMsg::list (errorRest);
        }

        let mut current : &Value = UNIT_VALUE;
        for i in conds.len .. 0us {
            current = self.createConditional (m.getLoc (), conds [i - 1us], values [i - 1us], else_-> current, type, isComplete-> true);
        }

        (current, type)
    }

    /**
     * Validate the list of matchers from the pattern matching
     * @params:
     *    - context: the context of the validation
     *    - value: the value being matched
     *    - matchers: the list of matchers
     * @returns:
     *    - .0: the list of conditions
     *    - .1: the list of validated values if conditions are true
     *    - .2: the list of errors during the validation
     *    - .3: the type result of the matcher (@warning: before checking completness)
     *    - .4: true if the matcher is complete
     * */
    fn validateMatchers (self, dmut context : &Validator, loc : &Word, value : &Value, matchers : [(&Expression, &Expression, &Expression)], memInfo : MemoryInfo)-> ([&Value], [&Value], [&ErrorMsg], &Type, bool, MemoryInfo) {
        let mut finType : &Type = copy NoneType (loc);
        let mut complete = false;
        let mut currentTautCond : &Value = UNIT_VALUE;

        let mut conds : [&Value] = [];
        let mut values : [&Value] = [];
        let mut errors : [&ErrorMsg] = [];
        let mut innerRetInfo = MemoryInfo ();

        for mtch in matchers {
            let mut succeed = true;
            context:.enterBlock ();
            {
                if (complete) {
                    throw copy ErrorMsg::fatal (mtch.0.getLoc (), ValidateErrorMessage::UNREACHABLE_MATCHER);
                }

                let mut vars : [([c8], &Value)] = [];

                // Validate the pattern
                let (cond_, retInfo) = self.validateMatcher (alias context, value, mtch.0, ref vars, memInfo);
                innerRetInfo = innerRetInfo.or (retInfo);

                let (cond, taut, _) = self.validateConditionGuard (alias context, vars, mtch.1, cond_);
                conds ~= [cond];

                // Validate the value associated with successful pattern match
                let mut val = context:.validateValue (mtch.2);
                let (t, v) = if (!val.isBreaker () && !val.isReturner ()) {
                    context:.inferTypeBranchingWithValue (finType.getLoc (), finType, val)
                } else {
                    (finType, val)
                };

                values ~= [copy BlockValue (mtch.2.getLoc (), v.getType (), copy [v])];
                finType = t;

                currentTautCond = match currentTautCond {
                    UnitValue () => { taut }
                    _ => {
                        copy LogicalBinBoolOperatorValue (cond.getLoc (), BinaryOperators::DPIPE, taut, currentTautCond)
                    }
                };

                complete = self.isTautology (alias context, currentTautCond);
            } catch {
                err : &ErrorMsg => {
                    errors ~= [err];
                    succeed = false;
                }
            }

            {
                context:.quitBlock (warnUnused-> succeed);
            } catch {
                err : &ErrorMsg => { errors ~= [err]; }
            }
        }

        if finType of NoneType {
            finType = copy VoidType (loc);
        }

        (conds, values, errors, finType, complete, innerRetInfo)
    }

    /**
     * Validate the list of matchers from a catch scope guard
     * @params:
     *   - context: the context of the validation
     *   - loc: the location of the catch scope guard
     *   - tryType: the type of the block that is caught
     *   - value: the variable that contains the caught exception
     *   - matchers: the list of matcher in the pattern matching
     *   - throwers: the list of exceptions that can be thrown
     * @returns:
     *   - .0: the list of conditions
     *   - .1: the list of values to evaluate in case the conditions are true
     *   - .2: the list of errors that occurs during validation
     *   - .3: the type of the scope
     *   - .4: the list of types that were not caught
     * */
    fn validateMatchersForCatch (self, dmut context : &Validator, loc : &Word, tryType : &Type, value : &Value, matchers : [(&Expression, &Expression, &Expression)], throwers : [(&Word, &Type)])-> ([&Value], [&Value], [&ErrorMsg], &Type, [(&Word, &Type)]) {
        let mut finType : &Type = tryType;

        let mut used : [(&Word, &Type)] = [];
        let mut conds : [&Value] = [];
        let mut values : [&Value] = [];
        let mut errors : [&ErrorMsg] = [];
        let mut rest : [(&Word, &Type)] = throwers;

        for mtch in matchers {
            let mut succeed = true;
            context:.enterBlock ();
            {
                if (rest.len == 0us) { // everything was caught, so further patterns are useless
                    throw copy ErrorMsg::fatal (mtch.0.getLoc (), ValidateErrorMessage::UNREACHABLE_MATCHER);
                }

                let mut vars : [([c8], &Value)] = [];
                let (cond_, used_, subTests) = self.validateMatcherForCatch (alias context, value, mtch.0, rest, used, ref vars);
                let (cond, _, guardTest) = self.validateConditionGuard (alias context, vars, mtch.1, cond_);

                conds ~= [cond];

                let mut val = context:.validateValue (mtch.2);
                let (t, v) = if (!val.isBreaker () && !val.isReturner ()) {
                    context:.inferTypeBranchingWithValue (finType.getLoc (), finType, val)
                } else {
                    (finType, val)
                };

                values ~= [copy BlockValue (mtch.2.getLoc (), v.getType (), copy [v])];

                finType = t;
                if (self.isTautology (alias context, guardTest) && !subTests) { // the guard is always true, and there is no other tests than type equality
                    used ~= [(mtch.0.getLoc (), used_)]; // so the type is caught
                    rest = self.listNonCaughtThrowers (alias context, used, throwers); // list the types that are not yet caught
                }
            } catch {
                err : &ErrorMsg => {
                    errors ~= [err];
                    succeed = false;
                }
            }

            {
                context:.quitBlock (warnUnused-> succeed);
            } catch {
                err : &ErrorMsg => { errors ~= [err]; }
            }
        }

        if finType of NoneType {
            finType = copy VoidType (loc);
        }

        (conds, values, errors, finType, rest)
    }


    /**
     * Create a conditional value for a given pattern match
     * @params:
     *    - cond: the condition
     *    - val: the value to evaluate if the condition is true
     *    - else_: the value to evaluate if the condition is false
     * */
    fn createConditional (self, loc : &Word, cond : &Value, val : &Value, else_ : &Value, type : &Type, isComplete : bool)-> &Value {
        match cond {
            b : &BoolValue => {
                return if b.isTrue () { val } else { else_ };
            }
        }

        copy ConditionalValue (loc, type, cond, val, elsev-> else_, isComplete-> isComplete)
    }

    /*!
     * ================================================================================
     * ================================================================================
     * ==========================         ERROR DECL         ==========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Declare the variables with error type
     * @throws: if there are shadowing variable found
     * */
    pub fn declareErrorVariables (self, dmut context : &Validator, mtch : &Expression, ref mut vars : [([c8], &Value)])
        throws ErrorMsg
    {
        match mtch {
            vdecl : &VarDeclExpr => {
                if (vdecl.getLoc () != Keys::UNDER) {
                    context.verifyShadow (vdecl.getLoc ());
                    self.verifyShadowPattern (vdecl.getLoc (), vars);

                    let var = copy VarDeclValue (vdecl.getLoc (), copy ErrorType (vdecl.getLoc ()), UNIT_VALUE, isMutable-> false);
                    vars ~= [(vdecl.getLoc ().str, var)];
                }

                self.declareErrorVariables (alias context, vdecl.getValue (), vars-> ref vars);
            }
            o : &OptionMatcherExpr => {
                self.declareErrorVariables (alias context, o.getInner (), vars-> ref vars);
            }
            cl : &MultOperatorExpr => {
                for m in cl.getRights () {
                    self.declareErrorVariables (alias context, m, vars-> ref vars);
                }
            }
            l : &ListMatcherExpr => {
                for m in l.getParameters () {
                    self.declareErrorVariables (alias context, m, vars-> ref vars);
                }
            }
        }
    }

    /*!
     * ================================================================================
     * ================================================================================
     * ==========================         VALIDATION         ==========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate the conditional guard
     * @warning: the block of the pre test has to be already entered, variables from /vars/ are insert in local block
     * @returns:
     *    - .0: the actual test with var decls
     *    - .1: the tautology test
     *    - .2: the guard test
     * @info: the return.1 contains the return.2, both have their purpose .1 is for basic pattern matching tautology checking, and .2 for scope guards as the currentCondition might contains type checking
     * */
    pub fn validateConditionGuard (self, dmut context : &Validator, vars : [([c8], &Value)], guard : &Expression, currentCond : &Value)-> (&Value, &Value, &Value)
        throws ErrorMsg
    {
        let mut testBlk : [&Value] = copy [v.1 for v in vars];
        for v in vars {
            if (v.0 != Keys::UNDER) {
                context:.insertLocal (guard.getLoc (), v.0, v.1, canShadow-> false);
            }
        }

        match guard {
            EmptyExpression () => {
                testBlk ~= [TRUE_BOOL_VALUE];
                let res : &Value = copy LogicalBinBoolOperatorValue (currentCond.getLoc (), BinaryOperators::DAND, currentCond,
                                                                     copy BlockValue (currentCond.getLoc (), copy BoolType (currentCond.getLoc ()), testBlk, isSet-> true));
                (res, currentCond, TRUE_BOOL_VALUE)
            }
            _ => {
                let r = context:.validateValue (guard);
                if (r.getType () !of BoolType) {
                    throw copy ErrorMsg::fatal (r.getLoc (), format (ValidateErrorMessage::INCOMPATIBLE_TYPE, r.getType (), copy BoolType (r.getLoc ())));
                }

                testBlk ~= [r];
                let res : &Value = copy LogicalBinBoolOperatorValue (currentCond.getLoc (), BinaryOperators::DAND, currentCond,
                                                                     copy BlockValue (currentCond.getLoc (), copy BoolType (currentCond.getLoc ()), testBlk, isSet-> true));

                let taut : &Value = copy LogicalBinBoolOperatorValue (currentCond.getLoc (), BinaryOperators::DAND, currentCond, r);
                (res, taut, r)
            }
        }
    }
    

    /**
     * Validate the matcher from a single pattern (var declaration, if let, etc.)
     * @params:
     *    - context: the context of the validation
     *    - value: the value passed to the matcher
     *    - mtch: the pattern
     * @returns:
     *    - .0: the validate value passed to the pattern
     *    - .1: the runtime test (a true bool value if cte and irrefutable)
     *    - .2: the list of variable to declare (.0-> name, .1-> var decl value)
     *    - .3: the error if any, in that case the variables have an error type in .1 but they can still be inserted in local block if needed
     * @warning: variables are not inserted in any block, they have to be after the function call
     * */
    pub fn validateMatcher (self, dmut context : &Validator, value : &Expression, mtch : &Expression, canBeLazy : bool = false)-> (&Value, &Value, [([c8], &Value)], (&ErrorMsg)?) {
        {
            let mValue = context:.getValueValidator ().validate (alias context, value, canBeRef-> true, canBeLazy-> canBeLazy);
            context.verifyNoBreaking (mtch.getLoc (), mValue);
            context.verifyCompleteTypeWithValue (value.getLoc (), mValue.getType (), mValue, construct-> true);

            let mut vars : [([c8], &Value)] = [];

            let (mut memInfo, fVal) = match mValue {
                r : &ReferencerValue => { (MemoryInfo (byMutRef-> true), r.getValue ()) }
                a : &AliaserValue => { (MemoryInfo (byAlias-> true), a.getValue ()) }
                l : &LazyValue => { (MemoryInfo (byLazy-> l.byAlias ()), l) }
                _ => { (MemoryInfo (byMove-> !context.needExplicitMove (mValue)), mValue) } // explicit move if there is no need for a move to move
            };

            let (cond, retInfo) = self.validateMatcher (alias context, fVal, mtch, ref vars, memInfo, canBeLazy-> canBeLazy);
            if (!retInfo.byMutRef && memInfo.byMutRef) {
                throw copy ErrorMsg::fatal (mValue.getLoc (), ValidateErrorMessage::UNECESSARY_REFERENCE,
                                            notes-> copy [copy ErrorMsg::note (mtch.getLoc (), ValidateErrorMessage::NO_REFERENCE_PATTERN)]);
            } else if (!retInfo.byAlias && memInfo.byAlias) {
                throw copy ErrorMsg::fatal (mValue.getLoc (), format (ValidateErrorMessage::UNECESSARY_ALIAS, mValue.getType ()),
                                            notes-> copy [copy ErrorMsg::note (mtch.getLoc (), format (ValidateErrorMessage::NO_ALIAS_PATTERN, ""))]);
            } else if (!retInfo.byLazy && memInfo.byLazy) {
                throw copy ErrorMsg::fatal (mValue.getLoc (), format (ValidateErrorMessage::UNECESSARY_LAZY, mValue.getType ()),
                                            notes-> copy [copy ErrorMsg::note (mtch.getLoc (), format (ValidateErrorMessage::NO_LAZY_PATTERN, ""))]);
            }

            (mValue, cond, vars, cast!{&ErrorMsg?} (none))
        } catch {
            err : &ErrorMsg => { // insert error variables to avoid future undefined symbol errors
                {
                    let mut vars : [([c8], &Value)] = [];
                    context:.getMatcherValidator ().declareErrorVariables (alias context, mtch, ref vars);
                    return (UNIT_VALUE, UNIT_VALUE, vars, err?);
                } catch {
                    _ => return (UNIT_VALUE, UNIT_VALUE, [], err?);
                }
            }
        }
    }

    /**
     * Validate a matcher inside a catcher scope guard
     * @params:
     *    - context: the context of the validation
     *    - value: the variable containing the thrown exception
     *    - mtch: the pattern
     *    - throwers: the list of types that can be thrown that are not caught yet
     *    - allThrowers: the list of types that can be thrown by the try part
     * @returns:
     *    - .0: the condition to check
     *    - .1: the type that is caught
     *    - .2: if there is other conditions that just type equality
     *    - vars: the list of variable declared within this pattern matcher
     * */
    fn validateMatcherForCatch (self, dmut context : &Validator, value : &Value, mtch : &Expression, throwers : [(&Word, &Type)], caught : [(&Word, &Type)], ref mut vars : [([c8], &Value)])-> (&Value, &Type, bool)
        throws ErrorMsg
    {
        return match mtch {
            v : &VarDeclExpr => {
                self.validateVarDeclMatcherForCatch (alias context, value, v, throwers, caught, ref vars)
            }
            m : &MultOperatorExpr => {
                self.validateCallOpMatcherForCatch (alias context, value, m, throwers, caught, ref vars)
            }
            _ => {
                throw copy ErrorMsg::fatal (mtch.getLoc (), format (ValidateErrorMessage::CATCH_PATTERN_MULT_OR_VDECL));
            }
        };
    }


    /**
     * Validate a matcher
     * @params:
     *   - context: the context of the validation
     *   - value: the value to match
     *   - mtch: the matcher expression
     * @returns: the condition to evaluate at runtime
     * */
    fn validateMatcher (self, dmut context : &Validator, value : &Value, mtch : &Expression, ref mut vars : [([c8], &Value)], memInfo : MemoryInfo, canBeLazy : bool = false)-> (&Value, MemoryInfo)
        throws ErrorMsg
    {
        return match mtch {
            v : &VarDeclExpr => {
                self.validateVarDeclMatcher (alias context, value, v, ref vars, memInfo, canBeLazy-> canBeLazy)
            }
            o : &OptionMatcherExpr => {
                self.validateOptionMatcher (alias context, value, o, ref vars, memInfo)
            }
            m : &MultOperatorExpr => {
                self.validateCallOpMatcher (alias context, value, m, ref vars, memInfo)
            }
            l : &ListMatcherExpr => {
                if (l.isTuple ()) {
                    self.validateTupleMatcher (alias context, value, l, ref vars, memInfo)
                } else {
                    self.validateArrayMatcher (alias context, value, l, ref vars, memInfo)
                }
            }
            _ => {
                (self.validateValueEqualMatcher (alias context, value, mtch), MemoryInfo ())
            }
        };
    }

    /**
     * validate a var declaration matcher for a catch scope guard
     * @params:
     *    - context: the context of the validation
     *    - value: the value that is caught
     *    - vdecl: the variable declaration
     * @returns:
     *    - .0: the condition
     *    - .1: the type that is caught
     *    - .2: has also value checking ? (that might fail even if the type is caught)
     * */
    fn validateVarDeclMatcherForCatch (self, dmut context : &Validator, value : &Value, vdecl : &VarDeclExpr, throwers : [(&Word, &Type)], caught : [(&Word, &Type)], ref mut vars : [([c8], &Value)])-> (&Value, &Type, bool)
        throws ErrorMsg
    {
        context.verifyShadow (vdecl.getLoc ()); // variable declaration, so no shadows are allowed
        self.verifyShadowPattern (vdecl.getLoc (), vars);  // verify that no variable declared within the pattern are shadowing each other

        {
            let (typeCond, finalType, valToAffect, castedValue, _) = self.validateVarDeclMatcherValue (alias context, value, vdecl, false, MemoryInfo ());
            self.verifyIsThrown (alias context, vdecl.getLoc (), finalType, throwers, caught);

            let var = copy VarDeclValue (vdecl.getLoc (), finalType, valToAffect, isReference-> false, isMutable-> false);
            vars ~= [(vdecl.getLoc ().str, var)]; // add the declaration in the pattern matching success block

            let (valueCond, _) = if (vdecl.getValue () !of EmptyExpression) { // x : T = V =>
                // inner pattern matching on V using /cast!T (value)/ (since the type test was true)
                self.validateMatcher (alias context, castedValue, vdecl.getValue (), ref vars, MemoryInfo ())
            } else {
                (TRUE_BOOL_VALUE, MemoryInfo ()) // necessarily pass
            };

            let subTest = !self.isTautology (alias context, valueCond);

            // test type && test value to be a successful pattern matcher
            (copy LogicalBinBoolOperatorValue (vdecl.getLoc (), BinaryOperators::DAND, typeCond, valueCond), finalType, subTest)
        } catch {
            err : &ErrorMsg => { // insert error variable to avoid undefined symbol errors
                if (vdecl.getLoc () != Keys::UNDER) {
                    let var = copy VarDeclValue (vdecl.getLoc (), copy ErrorType (vdecl.getLoc ()), UNIT_VALUE, isReference-> false, isMutable-> false);
                    vars ~= [(vdecl.getLoc ().str, var)];
                }

                throw err;
            }
        }
    }

    /**
     * Validate a var declaration matcher
     * @params:
     *    - context: the context of the validation
     *    - value: the value to match
     *    - vdecl: the variable declaration
     * @returns: the condition to evaluate at runtime
     * */
    fn validateVarDeclMatcher (self, dmut context : &Validator, value : &Value, vdecl : &VarDeclExpr, ref mut vars : [([c8], &Value)], memInfo : MemoryInfo, canBeLazy : bool)-> (&Value, MemoryInfo)
        throws ErrorMsg
    {
        context.verifyShadow (vdecl.getLoc ()); // variable declaration, so no shadows are allowed
        self.verifyShadowPattern (vdecl.getLoc (), vars); // verify that no variable declared within the pattern are shadowing each other

        {
            // Transform the value into something assignable to the var decl, and retreive the runtime test if any and some other stuff for further matching and validation
            let (typeCond, finalType, valToAffect, castedValue, retInfo) = self.validateVarDeclMatcherValue (alias context, value, vdecl, vdecl.isRef (), memInfo, isLazy-> vdecl.isLazy (), canBeLazy-> canBeLazy);
            let tLoc = if (vdecl.getType () of EmptyExpression) { vdecl.getLoc () } else { vdecl.getType ().getLoc () };
            context.verifyNonVoidType (tLoc, finalType, true);

            // if the variable is lazy it cannot be mutable unless it borrows mutable data
            if (finalType.isMutable () && !finalType.needExplicitAlias () && vdecl.isLazy ()) {
                throw copy ErrorMsg::fatal (vdecl.getMutOrDmutLocation (), format (ValidateErrorMessage::MUTABLE_LAZY_VAR));
            }

            if ((vdecl.isMutable () || vdecl.isDeeplyMutable ()) && finalType of LambdaType) {
                throw copy ErrorMsg::fatal (vdecl.getMutOrDmutLocation (), format (ValidateErrorMessage::MUTABLE_LAMBDA_VAR));
            }

            let var = copy VarDeclValue (vdecl.getLoc (), finalType, valToAffect, isReference-> vdecl.isRef (), isLazy-> vdecl.isLazy (), isMutable-> finalType.isMutable ());
            vars ~= [(vdecl.getLoc ().str, var)]; // add the declaration in the pattern matching success block

            let (valueCond, innerMemInfo) = if (vdecl.getValue () !of EmptyExpression) { // x : T = V =>
                // inner pattern matching on V using /cast!T (value)/ (since the type test was true)
                self.validateMatcher (alias context, castedValue, vdecl.getValue (), ref vars, memInfo)
            } else {
                (TRUE_BOOL_VALUE, MemoryInfo ()) // necessarily pass
            };

            // test type && test value to be a successful pattern matcher
            (copy LogicalBinBoolOperatorValue (vdecl.getLoc (), BinaryOperators::DAND, typeCond, valueCond), retInfo.or (innerMemInfo))
        } catch {
            err : &ErrorMsg => { // insert error variable to avoid undefined symbol errors
                if (vdecl.getLoc () != Keys::UNDER) {
                    let var = copy VarDeclValue (vdecl.getLoc (), copy ErrorType (vdecl.getLoc ()), UNIT_VALUE, isReference-> vdecl.isRef (), isLazy-> vdecl.isLazy (), isMutable-> (vdecl.isMutable () || vdecl.isDeeplyMutable ()));
                    vars ~= [(vdecl.getLoc ().str, var)];
                }

                throw err;
            }
        }
    }

    /**
     * Validate the casting of the matching value to the type of the variable
     * @params:
     *    - context: the context of the validation
     *    - value: the value (reference or not)
     *    - vdecl: the pattern
     *    - isRef: true if the vdecl has /ref/ deco
     * @returns:
     *    - .0: the test (a true bool value if the test is irrefutable)
     *    - .1: the type of the vdecl
     *    - .2: the value to affect in the vdecl
     *    - .3: the value to pass for further matching (already cleaned of reference/aliaser by casted to the correct type)
     * */
    fn validateVarDeclMatcherValue (self, dmut context : &Validator, value : &Value, vdecl : &VarDeclExpr, isRef : bool, memInfo : MemoryInfo, isLazy : bool = false, canBeLazy : bool = false)-> (&Value, &Type, &Value, &Value, MemoryInfo)
        throws ErrorMsg
    {
        let (test, type, castedValue) = if (vdecl.getType () !of EmptyExpression) { // not '_'
            let type = context:.validateTypeForVarDecl (vdecl.getType (), vdecl, canBeRef-> true, canBeLazy-> canBeLazy);
            let (typeTest, castedValue) = match (value.getType (), type) {
                (valueType : &ClassPtrType, declType : &ClassPtrType) => { // a class reverse casting: Base -> Derived can only be known at cte (
                    // inner == derived, so the test is cte and no need to cast anything
                    if (declType.isCompatible (valueType)) {
                        (TRUE_BOOL_VALUE, value)
                    }

                    // value is a Derived of derived, or derived is a Derived of value, both are allowed but one has to be runtime evaluated (Derived <- Base)
                    else {
                        // unless it is a Derived -> Base, but that is already managed by the binary operator validator
                        if (isRef && context.isAncestor (declType, valueType)) { // ref mut x : &Base = ref y : Derived is not allowed, because x = copy Base () will result in undefined behavior
                            throw copy ErrorMsg::fatal (vdecl.getLoc (), end-> value.getLoc (), format (ValidateErrorMessage::CANNOT_CASTTO_BASE_CLASS, valueType, declType),
                                                        notes-> copy [copy ErrorMsg::note (vdecl.getRefLocation (), "")]);
                        }
                        // However, ref mut x : Derived = ref y : Base, is allowed we can only put a Derived into x, thus y will always contain a Base so no problem

                        // Create the runtime test to check wether the value is containing an instance of the type of the variable decl
                        let typeTest = context:.getBinOpValidator ().validateClassTypeTestOp (alias context, vdecl.getType ().getLoc (), BinaryOperators::OF, value, declType.getInner ());

                        // we clone the derived type to match the base type mutability
                        let resType = declType.clone (pattern-> valueType);

                        //  cast the value into the type of the variable decl
                        let ctdValue = copy CastValue (type.getLoc (), resType, value, isLvalue-> value.isLvalue ());
                        (typeTest, ctdValue)
                    }
                }
                _ => { // Any other type test is cte evaluated
                    (TRUE_BOOL_VALUE, value)
                }
            };

            (typeTest, type, castedValue)
        } else { // create a type for mutability checking
            let type = context:.validateTypeForVarDecl (copy TypeWrapperExpr (value.getLoc (), value.getType ()), vdecl, canBeRef-> true, canBeLazy-> canBeLazy);
            (TRUE_BOOL_VALUE, type, value) // type test is always true
        };

        // Reducing the value if it's not by reference
        let reducedVal = context:.getCompileTimeInterpreter (forRef-> (memInfo.byMutRef || isRef)):.reduce (castedValue);

        // Transform the value to be implicit casted to the type
        let ctdValue = context:.verifyCompatibleTypeWithValue (vdecl.getLoc (), type, reducedVal, byReference-> isRef);

        // transform the value into a ref or an alias if the root value was passed by ref or alias
        let (postCtdValue, retInfo) = // if (isLazy && byLazy) {
        //     (ctdValue, false, false, true)
        // } else
            if (memInfo.byMutRef && isRef && ctdValue.isLvalue () && ctdValue.getType ().isMutable ()) {
                (copy ReferencerValue (reducedVal.getLoc (), ctdValue.getType (), ctdValue, isMutable-> true), MemoryInfo (byMutRef-> true))
            } else if (!isRef && (memInfo.byAlias || memInfo.byMutRef) && type.isMutable () && type.needExplicitAlias ()) {
                (copy AliaserValue (value.getLoc (), ctdValue.getType (), ctdValue), MemoryInfo (byAlias-> true, byLazy-> (isLazy && memInfo.byLazy))) // if we mix pattern using ref and alias, then ref has priority and can be used as alias
            } else if (isRef && !memInfo.byMutRef && ctdValue.isLvalue ()) {
                (copy ReferencerValue (reducedVal.getLoc (), ctdValue.getType (), ctdValue, isMutable-> false), MemoryInfo ())
            } else { (ctdValue, MemoryInfo (byLazy-> (isLazy && memInfo.byLazy))) };

        // Verify memory implicit alias/ref and mutability
        context.verifyMemoryOwner (vdecl.getLoc (), type, postCtdValue, construct-> true, byReference-> isRef, byLazy-> isLazy, byMove-> memInfo.byMove);
        (test, type, postCtdValue, castedValue, retInfo)
    }


    /**
     * Validate a call operator matcher for a catch scope guard
     * @params:
     *    - context: the context of the validation
     *    - value: the value that is caught
     *    - cl: the call op
     * @returns:
     *    - .0: the condition
     *    - .1: the type that is caught
     *    - .2: has also value checking ? (that might fail even if the type is caught)
     * */
    fn validateCallOpMatcherForCatch (self, dmut context : &Validator, value : &Value, cl : &MultOperatorExpr, throwers : [(&Word, &Type)], caught : [(&Word, &Type)], ref mut vars : [([c8], &Value)])-> (&Value, &Type, bool)
        throws ErrorMsg
    {
        let (cond, innerCond, finalType, _) = self.validateCallOpMatcherValue (alias context, value, cl, ref vars, MemoryInfo ());
        self.verifyIsThrown (alias context, cl.getLoc (), finalType, throwers, caught);

        let subTest = !self.isTautology (alias context, innerCond);
        (cond, finalType, subTest)
    }

    /**
     * Validate a call operator matcher
     * @params:
     *    - context: the context of the validation
     *    - value: the value to match
     *    - cl: the call operator
     *    - vars: the list of variables to be declared the matching
     * @returns:
     *    - .0: the condition to evaluate at runtime
     * */
    fn validateCallOpMatcher (self, dmut context :  &Validator, value : &Value, cl : &MultOperatorExpr, ref mut vars : [([c8], &Value)], memInfo : MemoryInfo)-> (&Value, MemoryInfo)
        throws ErrorMsg
    {
        let (cond, _, _, retInfo) = self.validateCallOpMatcherValue (alias context, value, cl, ref vars, memInfo);
        (cond, retInfo)
    }

    /**
     * Validate a call operator matcher
     * @params:
     *    - context: the context of the validation
     *    - value: the value to match
     *    - cl: the call operator
     *    - vars: the list of variables to be declared the matching
     * @returns:
     *    - .0: the condition to evaluate at runtime
     *    - .1: the test on inner values (fields)
     *    - .2: the type to which the type is casted
     * */
    fn validateCallOpMatcherValue (self, dmut context : &Validator, value : &Value, cl : &MultOperatorExpr, ref mut vars : [([c8], &Value)], memInfo : MemoryInfo)-> (&Value, &Value, &Type, MemoryInfo)
        throws ErrorMsg
    {
        let validateL = match cl.getLeft () { // don't validate _ ()
            v : &VarExpr => {
                v.getLoc () != Keys::UNDER
            }
            _ => { true }
        };

        let (typeCond, castedValue, resType) = if (validateL) { // Validate the type X in /X (fields-> ...)/
            let type = context:.validateType (cl.getLeft ());
            let (typeTest, castedValue) = match (value.getType (), type) {
                (ClassPtrType (), inner : &ClassPtrType) => { // a class reverse casting: Base -> Derived can only be known at cte (
                    // unless it is a Derived -> Base, but that is already managed by the binary operator validator
                    let typeTest = context:.getBinOpValidator ().validateClassTypeTestOp (alias context, type.getLoc (), BinaryOperators::OF, value, inner.getInner ());

                    // we clone the derived type to match the base type mutability
                    if (inner.isStruct ()) {
                        (TRUE_BOOL_VALUE, value)
                    } else {
                        let resType = type.clone (pattern-> value.getType ());
                        (typeTest, copy CastValue (type.getLoc (), resType, value, isLvalue-> value.isLvalue ())) // transform the value into the derived type
                    }
                }
                (vtype : &ClassPtrType, inner : &ClassRefType) => { // Same as class ptr, but in MultOp a class ref can be used directly (Derived () => ) to match &Base
                    let typeTest = context:.getBinOpValidator ().validateClassTypeTestOp (alias context, type.getLoc (), BinaryOperators::OF, value, inner);

                    if inner.isStruct () {
                        (TRUE_BOOL_VALUE, value)
                    } else {
                        // we clone the derived type to match the base type mutability
                        let resType = inner.createInstance (loc-> type.getLoc (), vtype.isMutable (), vtype.isDeeplyMutable ());
                        (typeTest, copy CastValue (type.getLoc (), resType, value, isLvalue-> value.isLvalue ()))
                    }
                }
                _ => { // Any other type test is cte evaluated
                    context.verifyCompatibleType (value.getLoc (), type.getLoc (), value.getType (), type);
                    (TRUE_BOOL_VALUE, value)
                }
            };

            (typeTest, castedValue, type)
        } else {
            let t = context:.validateType (copy TypeWrapperExpr (value.getLoc (), value.getType ()));
            (TRUE_BOOL_VALUE, value, t)
        };

        let mut errors : [&ErrorMsg] = [];
        let mut curValueTest : &Value = TRUE_BOOL_VALUE;
        let mut innerRetInfo = MemoryInfo ();
        for p in cl.getRights () match p {
            n : &NamedExpr => {
                let val = context:.getBinOpValidator ().validateFieldOperation (alias context, n.getLoc (), BinaryOperators::DOT, castedValue, copy VarExpr (n.getLoc ()), inCall-> false);
                let (innerTest, innerRetInfo_) = {
                    self.validateMatcher (alias context, val, n.getContent (), ref vars, memInfo)
                } catch {
                    error : &ErrorMsg => {
                        throw error.withNote (copy [copy ErrorMsg::note (n.getLoc (), format (ValidateErrorMessage::FOR_PATTERN_FIELD, n.getLoc ().str, castedValue.getType ()))]);
                    }
                }

                curValueTest = copy LogicalBinBoolOperatorValue (n.getLoc (), BinaryOperators::DAND, curValueTest, innerTest);
                innerRetInfo = innerRetInfo.or (innerRetInfo_);
            }
            _ => {
                errors ~= [copy ErrorMsg::fatal (p.getLoc (), format (ValidateErrorMessage::FIELD_MATCHER_NO_NAME))];
            }
        }

        if (errors.len != 0us) throw copy ErrorMsg::list (errors);
        (copy LogicalBinBoolOperatorValue (cl.getLoc (), BinaryOperators::DAND, typeCond, curValueTest), curValueTest, resType, innerRetInfo)
    }

    /**
     * Validate an option matcher
     * @params:
     *     - context: the context of the validation
     *     - value: the value being matched
     *     - opt: the option matcher to validate
     *     - vars: the list of variables to be declared the matching
     * @returns:
     *    - .0: the runtime test
     * */
    fn validateOptionMatcher (self, dmut context : &Validator, value : &Value, opt : &OptionMatcherExpr, ref mut vars : [([c8], &Value)], memInfo : MemoryInfo)-> (&Value, MemoryInfo)
        throws ErrorMsg
    {
        let loc = opt.getLoc ();
        if (value.getType () !of OptionType) { // only option values can be passed to option pattern
            throw copy ErrorMsg::fatal (loc, format (ValidateErrorMessage::OPTION_MATCHER, loc, value.getType ()));
        }

        let optType = value.getType ().asOf!{&OptionType} ();
        let isSet = copy StructFieldAccessValue (loc, copy BoolType (loc), value, OptionKeys::SET);
        if (loc == OptionKeys::MATCH_SOME) match opt.getInner () { // /Ok/
            EmptyExpression () => return (isSet, MemoryInfo ());
            exp : &Expression => { // e.g. /Ok (x : _)/
                let innerVal = copy OptionFieldAccessValue (loc, optType.getInners ()[0], value, OptionKeys::VALUE);
                // Validate the pattern on the value of the option
                let (innerTest, innerMemInfo) = self.validateMatcher (alias context, innerVal, exp, ref vars, memInfo);

                return (copy LogicalBinBoolOperatorValue (loc, BinaryOperators::DAND, isSet, innerTest), innerMemInfo);
            }
        } else match opt.getInner () { // /Err/
            EmptyExpression () => {
                return (copy UnaryBoolOperatorValue (loc, UnaryOperators::NOT, isSet), MemoryInfo ());
            }
            exp : &Expression => { // e.g. /Err (x : _)/
                let ptrType = copy PointerType (loc, copy VoidType (loc));

                // all none option don't have an error, they may be completely empty, so we need to check that
                let hasError = copy CmpPointerOperatorValue (loc, BinaryOperators::NOT_EQUAL,
                                                             copy OptionFieldAccessValue (loc, ptrType, value, OptionKeys::ERROR),
                                                             copy NullValue (loc, ptrType));

                let notSet = copy UnaryBoolOperatorValue (loc, UnaryOperators::NOT, isSet);
                let finTest = copy LogicalBinBoolOperatorValue (loc, BinaryOperators::DAND, notSet, hasError); // !isSet && error != null


                let innerType = context:.getExceptionType (loc-> loc);
                let err = copy OptionFieldAccessValue (loc, innerType, value, OptionKeys::ERROR);

                // Validate the pattern on the error of the option
                let (innerTest, innerMemInfo) = self.validateMatcher (alias context, err, exp, ref vars, memInfo);

                return (copy LogicalBinBoolOperatorValue (loc, BinaryOperators::DAND, finTest, innerTest), innerMemInfo);
            }
        }
    }

    /**
     * Validate a tuple matcher
     * @params:
     *    - context: the context of the validation
     *    - value: the value to match
     *    - tu: the tuple list
     *    - vars: the list of variables to be declared the matching
     * @returns:
     *    - .0: the runtime test
     * */
    fn validateTupleMatcher (self, dmut context : &Validator, value : &Value, tu : &ListMatcherExpr, ref mut vars : [([c8], &Value)], memInfo : MemoryInfo)-> (&Value, MemoryInfo)
        throws ErrorMsg
    {
        let loc = tu.getLoc ();
        let values = self.expandTupleValues (alias context, loc, tu, value); // transform the tuple into a list of values so the rest of the validation gets easier
        if (tu.isVariadic () && tu.getParameters ().len - 1us > values.len) { // (x,z...) = (1,) is ok, x <- 1, z <- (), but (x,z...) = () is not there is nothing for x
            throw copy ErrorMsg::fatal (tu.getLoc (), format (ValidateErrorMessage::TUPLE_ARITY_OVERFLOW, tu.getParameters ().len, values.len));
        } else if (!tu.isVariadic () && tu.getParameters ().len != values.len) { // (x,) = (1,2) or (x, y) = (1,) are not ok
            throw copy ErrorMsg::fatal (tu.getLoc (), format (ValidateErrorMessage::TUPLE_ARITY_OVERFLOW, tu.getParameters ().len, values.len));
        }

        // pattern match inner values
        let mut curValueTest : &Value = TRUE_BOOL_VALUE;
        let mut innerRetInfo = MemoryInfo ();
        for i, p in tu.getParameters () {
            // currField is used for clearer errors
            let (assocValue, currField) = if (i != tu.getParameters ().len - 1us || !tu.isVariadic ()) {
                (values [i], format ("%",i)) // one value by one value
            } else { // e.g. (x, y...) = (1, 2, 3), y <- (2, 3)
                let rest = values [i .. $];
                let mut tupleTypes : [&Type] = [];
                for j in i .. values.len { // create a tuple type to get all last values
                    tupleTypes ~= [values [j].getType ()];
                    if (values [j].getType ().isMovable ()) {
                        throw copy ErrorMsg::fatal (values [j].getLoc (), end-> values [j].getType ().getLoc (), format (ValidateErrorMessage::CONTAIN_MOVABLE_TYPE, values [j].getType ()),
                                                    notes-> copy [copy ErrorMsg::note (value.getLoc (), format (ValidateErrorMessage::CONTAIN_MOVABLE_TYPE_NOTE), oneLine-> true)]);
                    }
                }

                let tupleType = copy TupleType (value.getLoc (), tupleTypes, isMutable-> value.getType ().isMutable ());

                // declare a tuple literal containing the values
                (copy TupleValue (value.getLoc (), tupleType, rest), format ("%..%", i, values.len))
            };

            let (innerTest, innerMemInfo) = {
                self.validateMatcher (alias context, assocValue, p, ref vars, memInfo)
            } catch {
                err : &ErrorMsg => { // add a note to the error so its easier to get the value responsible for the error
                    throw err.withNote (copy [copy ErrorMsg::note (tu.getLoc (), format (ValidateErrorMessage::FOR_PATTERN_FIELD, currField, value.getType ()))]);
                }
            };

            curValueTest = copy LogicalBinBoolOperatorValue (loc, BinaryOperators::DAND, curValueTest, innerTest);
            innerRetInfo = innerRetInfo.or (innerMemInfo);
        }

        (curValueTest, innerRetInfo)
    }

    /**
     * Expand the tuple values (unlike expand from intrinsic, this expand allows for mutable)
     * @warning: only tuple typed value can be used here (value.getType () of TupleType)
     * @returns: a list of values (tuple field accessed)
     * */
    fn expandTupleValues (self, dmut context : &Validator, loc : &Word, tu : &ListMatcherExpr, value : &Value)-> [&Value]
        throws ErrorMsg
    {
        match value.getType () {
            ty : &TupleType => {
                // expand the tuple, so it can be easily read
                return copy [context:.getBinOpValidator ().createTupleFieldAccess (loc, ty.getInners ()[it], value, it, reduce-> false)
                             for it in 0us .. ty.getInners ().len];
            }
            _ => { //
                throw copy ErrorMsg::fatal (loc, format (ValidateErrorMessage::TUPLE_PATTERN, tu, value.getType ()));
            }
        }
    }

    /**
     * Validate an array matcher
     * @params:
     *    - context: the context of the validation
     *    - value: the value to match
     *    - arr: the array list
     *    - vars: the list of variables to be declared the matching
     * @returns:
     *    - .0: the runtime test
     * */
    fn validateArrayMatcher (self, dmut context : &Validator, value : &Value, arr : &ListMatcherExpr, ref mut vars : [([c8], &Value)], memInfo : MemoryInfo)-> (&Value, MemoryInfo)
        throws ErrorMsg
    {
        let loc = arr.getLoc ();
        let len = { // retreive the length of the value
            context:.getBinOpValidator ().validateFieldOperation (alias context, value.getLoc (), BinaryOperators::DOT, value, copy VarExpr (copy Word (SliceKeys::LEN, value.getLoc ())), inCall-> false)
        } catch {
            err : &ErrorMsg => { // the value does not have a LEN field (TODO maybe make a test for class object to implement a specific traits?)
                throw err.withNote (copy [copy ErrorMsg::note (loc, ValidateErrorMessage::HERE)]);
            }
        }

        // Runtime check of the len of the value
        let (lenTest, ex) = if (arr.isVariadic ()) {
            let ex = makeIntValue (arr.getParameters ().len - 1us); // if it is variadic, then the value should contain at least N - 1 elements (e.g. [x, y...] = [1] is ok, with N = 2, [y...] = [] is ok with N = 1)
            (copy CmpIntOperatorValue (loc, BinaryOperators::SUP_EQUAL, len, ex), ex)
        } else {
            let ex = makeIntValue (arr.getParameters ().len); // not variadic, thus the value has to contain the same number of elements as in the pattern (e.g. [x, y] = [1, 2] is ok, but not [x, y] = [1])
            (copy CmpIntOperatorValue (loc, BinaryOperators::DEQUAL, len, ex), ex)
        };

        match context:.getCompileTimeInterpreter ():.reduce (lenTest) {
            b : &BoolValue => { // if the len test is CTE we can send an error if it is not valid (e.g. for array values)
                if (!b.isTrue ()) throw copy ErrorMsg::fatal (arr.getLoc (), format (ValidateErrorMessage::ARRAY_PATTERN_SIZE, ex, len));
            }
        }

        // these tokens are used in index access syntax at each iteration, we construct them once to avoid overusing memory for nothing
        let lcro = copy Word (Tokens::LCRO, loc), rcro = copy Word (Tokens::RCRO, loc);

        let mut curValueTest : &Value = TRUE_BOOL_VALUE;
        let mut innerRetInfo = MemoryInfo ();
        for i, p in arr.getParameters () {
            // currField is used for clearer errors
            let (assocValue, currField) = { // access elements indexed in the value
                context:.enterUnsafeContext (arr.getLoc ()); // entering unsafe context to avoid slice of array len checking that would be useless
                if (i != arr.getParameters ().len - 1us || !arr.isVariadic ()) { // one by one
                    let index = makeIntValue (i);
                    let acc = context:.getIndexOpValidator ().validate (alias context, copy MultOperatorExpr (lcro, rcro, copy ValueWrapperExpr (value.getLoc (), value), copy [copy ValueWrapperExpr (loc, index)])); // /value [i]/
                    (acc, format ("%", i))
                } else { // variadic, we access the rest of the elements in the value
                    let index = makeIntValue (i);
                    let rng = copy RangeValue (loc, copy RangeType (loc, index.getType ().asOf!{&IntType} (), copy IntType (loc, size-> 0u16, signed-> true), false), index, len);
                    let acc = context:.getIndexOpValidator ().validate (alias context, copy MultOperatorExpr (lcro, rcro, copy ValueWrapperExpr (value.getLoc (), value), copy [copy ValueWrapperExpr (loc, rng)])); // /value [i .. $]/
                    (acc, format ("%..$", i))
                }
            } exit {
                context:.exitUnsafeContext ()?;
            };

            let (innerTest, innerMemInfo) = {
                self.validateMatcher (alias context, assocValue, p, ref vars, memInfo)
            } catch {
                err : &ErrorMsg => { // note the error for clearer errors
                    throw err.withNote (copy [copy ErrorMsg::note (loc, format (ValidateErrorMessage::FOR_PATTERN_FIELD, currField, value.getType ()))]);
                }
            }

            curValueTest = copy LogicalBinBoolOperatorValue (loc, BinaryOperators::DAND, curValueTest, innerTest);
            innerRetInfo = innerRetInfo.or (innerMemInfo);
        }

        (copy LogicalBinBoolOperatorValue (loc, BinaryOperators::DAND, lenTest, curValueTest), innerRetInfo)
    }

    /**
     * Validate a matcher using a value
     * @info: from there, no variable can be created anymore just value equality (thus no need for vars, byMutRef and byAlias)
     * @params:
     *    - context: the context of the validation
     *    - value: the value to match
     *    - mtch: the matcher value
     * @returns: the condition to evaluate at runtime
     * */
    fn validateValueEqualMatcher (self, dmut context : &Validator, value : &Value, mtch : &Expression)-> &Value
        throws ErrorMsg
    {
        match mtch {
            b : &BinaryExpr => {
                if b.getLoc () == BinaryOperators::PIPE { // e.g. /x | y | 12/, means either x or y or 12
                    let left = self.validateValueEqualMatcher (alias context, value, b.getLeft ());
                    let right = self.validateValueEqualMatcher (alias context, value, b.getRight ());

                    return copy LogicalBinBoolOperatorValue (mtch.getLoc (), BinaryOperators::DPIPE, left, right); // left || right
                }
            }
            t : &VarExpr => { // ignoring value when encoutering the var reference expr /_/
                if (t.getLoc () == Keys::UNDER) return TRUE_BOOL_VALUE;
            }
        }

        let eqVal = context:.validateValue (mtch); // otherwise making a strong equality test (value == mtch), where mtch is constructed inside the test
        if (eqVal.getType () of RangeType && value.getType () of IntType) { // 12 in (0 .. 87)
            return context:.getBinOpValidator ().validateRangeContainOp (alias context, mtch.getLoc (), BinaryOperators::IN, value, eqVal);
        }

        context:.getBinOpValidator ().validateComparisonOperation (alias context, mtch.getLoc (), BinaryOperators::DEQUAL, value, eqVal)
    }


    /*!
     * ================================================================================
     * ================================================================================
     * =========================         VERIFICATION         =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * @returns: true if the list condition is a tautology
     * @warning: could clearly be enhanced, for example if the test is checking for all the values of an enum, or a list of base types of exceptions are tested TODO
     * */
    fn isTautology (self, dmut context : &Validator, cond : &Value)-> bool
        throws ErrorMsg
    {
        let red = context:.getCompileTimeInterpreter ():.reduce (cond);
        match red {
            b : &BoolValue => return b.isTrue ();
        }

        false
    }

    /**
     * @returns: the list of types that are not caught by the catcher
     * @params:
     *    - context: the context of the validation
     *    - used: the list of types that are caught by the catcher
     *    - throwers: the list of tyep that can by thrown in the try part
     * */
    fn listNonCaughtThrowers (self, dmut context : &Validator, used : [(&Word, &Type)], throwers : [(&Word, &Type)])-> [(&Word, &Type)]
        throws ErrorMsg
    {
        let mut res : [(&Word, &Type)] = [];
        for i in throwers {
            let mut found = false;
            for j in used {
                if context.isDirectInstance (i._1, j._1) || context.isAncestor (j._1, i._1) {
                    found = true;
                    break;
                }
            }

            if (!found) {
                res ~= [i];
            }
        }

        res
    }

    /**
     * Verify that the catching pattern catch is useful and catch an exception
     * @params:
     *    - loc: the location of the pattern
     *    - type: the type being caught
     *    - throwers: the list of exception that have to be caught
     *    - caught: the list of exception that are already caught inside other patterns
     * */
    fn verifyIsThrown (self, dmut context : &Validator, loc : &Word, type : &Type, throwers : [(&Word, &Type)], caught : [(&Word, &Type)])
        throws ErrorMsg
    {
        for i in caught {
            if (context.isDirectInstance (type, i._1) || context.isAncestor (i._1, type)) {
                throw copy ErrorMsg::fatal (loc, end-> i._0, format (ValidateErrorMessage::ALREADY_CAUGHT, type, i._1));
            }
        }

        for i in throwers {
            if (context.isDirectInstance (type, i._1)) return;
            if (context.isAncestor (type, i._1)) return;
            if (context.isAncestor (i._1, type)) return;
        }

        throw copy ErrorMsg::fatal (loc, format (ValidateErrorMessage::CATCH_NOTHING, type));
    }

    /**
     * Verify that all the branches have the correct type, i.e. if the match is not complete, then branch values must be void
     * @returns: the final type of the match<
     * @throws:
     *    - &ErrorMsg: if the match is not complete, but branch values are not void
     * */
    fn verifyComplete (self, loc : &Word, value : &Value, complete : bool, type : &Type, values : [&Value])-> &Type
        throws ErrorMsg
    {
        let retType = if (!complete) { VOID_TYPE } else { type };
        if (!complete) {
            let mut errors : [&ErrorMsg] = [];
            for i in values {
                if (i.getType () !of VoidType) {
                    errors ~= [copy ErrorMsg::fatal (i.getLoc (), format (ValidateErrorMessage::MATCH_NOT_COMPLETE, i.getType ()))];
                }
            }

            if (errors.len != 0us) {
                throw copy ErrorMsg::fatal (loc, format (ValidateErrorMessage::MATCH_VALIDATION, value, value.getType ()), notes-> errors);
            }
        }

        retType
    }

    /**
     * Variables declared within pattern are not inserted in local block
     * Thus we need to verify that they are not shadowing each other within the same pattern
     * */
    fn verifyShadowPattern (self, loc : &Word, vars : [([c8], &Value)])
        throws ErrorMsg
    {
        if (loc.str == Keys::UNDER) return {}
        for v in vars match v.1 {
            vd : &VarDeclValue => {
                if (vd.getLoc ().str == loc.str) {
                    throw copy ErrorMsg::fatal (loc, format (ValidateErrorMessage::SHADOWING_DECL, loc.str),
                                                notes-> copy [copy ErrorMsg::note (vd.getLoc (), ValidateErrorMessage::FIRST_DEFINED)]);
                }
            }
            _ => panic;
        }
    }
}
