mod ymirc::semantic::validator::operator::matcher;

import std::io;
import std::collection::vec;

import ymirc::semantic::validator::visitor;
import ymirc::semantic::validator::errors;
import ymirc::errors::_;
import ymirc::utils::format;
import ymirc::semantic::generator::value::_;
import ymirc::syntax::expression::_;
import ymirc::syntax::keys;

import ymirc::lexing::tokens;
import ymirc::lexing::word;


import ymirc::semantic::generator::type::_;


struct
| byAlias : bool = false
| byMutRef : bool = false
| byMove : bool = false
| byLazy : bool = false
 -> MemoryInfo;

fn or (left : MemoryInfo, right : MemoryInfo)-> MemoryInfo {
    MemoryInfo (byAlias-> left.byAlias || right.byAlias,
                byMutRef-> left.byMutRef || right.byMutRef,
                byMove-> left.byMove || right.byMove,
                byLazy-> left.byLazy || right.byLazy)
}

/**
 * The match validator used to validate MatcherExpr
 * It is a class validator because match expression are complex
 */
pub class MatcherValidator {

    /**
     * Create an empty validator
     */
    pub self () {}


    /**
     * Validate a match expression
     * @params: 
     *    - context: the context of the validation
     *    - m: the matcher to validate
     * @returns: a value
     * @throws: 
     *    - &ErrorsMsg: if the validation failed
     */
    pub fn validate (self, dmut context : &Validator, m : &MatcherExpr)-> &Value
        throws &ErrorMsg
    {
        let mValue = context:.getValueValidator ().validate (alias context, m.getContent (), canBeRef-> true);
        context.verifyNoBreaking (m.getLoc (), mValue);
        context.verifyCompleteTypeWithValue (m.getContent ().getLoc (), mValue.getType (), mValue, construct-> true);

        let matchers = m.getMatchers ();
        let (memInfo, fVal) = match mValue {
            r : &ReferencerValue => { (MemoryInfo (byMutRef-> r.isMutable ()), r.getValue ()) }
            a : &AliaserValue => { (MemoryInfo (byAlias-> true), a.getValue ()) }
            _ => { (MemoryInfo (byMove-> !context.needExplicitMove (mValue)), mValue) } // is explicit move, if there is no need for a move to move
        };

        let (conds, values, errors, type, complete, retInfo) = self.validateMatchers (alias context, m.getLoc (), fVal, matchers, memInfo);
        if (errors.len != 0us) {
            throw ErrorMsg::fatal (m.getLoc (), format (ValidateErrorMessage::MATCH_VALIDATION, fVal, mValue.getType ()), notes-> errors);
        }

        if (!retInfo.byMutRef && memInfo.byMutRef) {
            throw ErrorMsg::fatal (mValue.getLoc (), ValidateErrorMessage::UNECESSARY_REFERENCE,
                                   notes-> [ErrorMsg::note (m.getLoc (), ValidateErrorMessage::NO_REFERENCE_PATTERN)]);
        } else if (!retInfo.byAlias && memInfo.byAlias) {
            throw ErrorMsg::fatal (mValue.getLoc (), format (ValidateErrorMessage::UNECESSARY_ALIAS, mValue.getType ()),
                                   notes-> [ErrorMsg::note (m.getLoc (), format (ValidateErrorMessage::NO_ALIAS_PATTERN, ""s8))]);
        }

        if (conds.len > 0us) {
            let finType = self.verifyComplete (m.getLoc (), fVal, complete, type, values);
            let mut current : &Value = UNIT_VALUE;
            for i in conds.len .. 0us {
                current = self.createConditional (m.getLoc (), conds [i - 1us], values [i - 1us], else_-> current, finType, isComplete-> complete);
            }

            match current {
                UnitValue () => { return BlockValue::new (m.getLoc (), VoidType::new (m.getLoc ()), []); }
            }

            return current;
        }

        return BlockValue::new (m.getLoc (), VoidType::new (m.getLoc ()), []);
    }

    /**
     * Validate a catcher pattern matching
     * @params
     *    - context : the context of the validation
     *    - m: the pattern matching to validate
     *    - tryType: the type of the try part that is caught
     *    - catchVar : the var reference to the variable taking the thrown exception
     *    - throwers: the list of exception that the catchVar can take
     * @returns:
     *    - .0: the list of actions
     *    - .1: the type of catch actions
     * */
    pub fn validateCatcher (self, dmut context : &Validator, m : &MatcherExpr, tryType : &Type, catchVar : &Value, throwers : [(&Word, &Type)])-> (&Value, &Type)
        throws &ErrorMsg
    {
        let (conds, values, errors, type, rests) = self.validateMatchersForCatch (alias context, tryType, catchVar, m.getMatchers (), throwers);
        if (errors.len != 0us) {
            throw ErrorMsg::fatal (m.getLoc (), format (ValidateErrorMessage::CATCH_VALIDATION, catchVar.getType ()), notes-> errors);
        }

        if (rests.len != 0us) {
            let dmut errorRest = Vec!{&ErrorMsg}::new ();
            for i in rests {
                errorRest:.push (ErrorMsg::fatal (m.getLoc (), end-> i._0, format (ValidateErrorMessage::EXCEPTION_NOT_CAUGHT, i._1)));
            }

            throw ErrorMsg::list (errorRest[]);
        }

        let mut current : &Value = UNIT_VALUE;
        for i in conds.len .. 0us {
            current = self.createConditional (m.getLoc (), conds [i - 1us], values [i - 1us], else_-> current, type, isComplete-> true);
        }

        (current, type)
    }

    /**
     * Validate the list of matchers from the pattern matching
     * @params:
     *    - context: the context of the validation
     *    - value: the value being matched
     *    - matchers: the list of matchers
     * @returns:
     *    - .0: the list of conditions
     *    - .1: the list of validated values if conditions are true
     *    - .2: the list of errors during the validation
     *    - .3: the type result of the matcher (@warning: before checking completness)
     *    - .4: true if the matcher is complete
     * */
    fn validateMatchers (self, dmut context : &Validator, loc : &Word, value : &Value, matchers : [(&Expression, &Expression, &Expression)], memInfo : MemoryInfo)-> ([&Value], [&Value], [&ErrorMsg], &Type, bool, MemoryInfo) {
        let mut finType : &Type = NoneType::new (loc);
        let mut complete = false;
        let mut currentTautCond : &Value = UNIT_VALUE;

        let dmut conds = Vec!{&Value}::new ();
        let dmut values = Vec!{&Value}::new ();
        let dmut errors = Vec!{&ErrorMsg}::new ();
        let mut innerRetInfo = MemoryInfo ();

        for mtch in matchers {
            let mut succeed = true;
            context:.enterBlock ();
            {
                if (complete) {
                    throw ErrorMsg::fatal (mtch.0.getLoc (), ValidateErrorMessage::UNREACHABLE_MATCHER);
                }

                let dmut vars = Vec!{([c8], &Value)}::new ();

                // Validate the pattern
                let (cond_, retInfo) = self.validateMatcher (alias context, value, mtch.0, alias vars, memInfo);
                innerRetInfo = innerRetInfo.or (retInfo);

                let (cond, taut, _) = self.validateConditionGuard (alias context, vars[], mtch.1, cond_);
                conds:.push (cond);

                // Validate the value associated with successful pattern match
                let mut val = context:.validateValue (mtch.2);
                let (t, v) = context:.inferTypeBranchingWithValue (finType.getLoc (), finType, val);

                values:.push (BlockValue::new (mtch.2.getLoc (), v.getType (), [v]));
                finType = t;

                currentTautCond = match currentTautCond {
                    UnitValue () => { taut }
                    _ => {
                        cast!{&Value} (LogicalBinBoolOperatorValue::new (cond.getLoc (), BinaryOperators::DPIPE, taut, currentTautCond))
                    }
                }

                complete = self.isTautology (alias context, currentTautCond);
            } catch {
                err : &ErrorMsg => {
                    errors:.push (err);
                    succeed = false;
                }
            }

            {
                context:.quitBlock (warnUnused-> succeed);
            } catch {
                err : &ErrorMsg => errors:.push (err);
            }
        }

        (conds[], values[], errors[], finType, complete, innerRetInfo)
    }

    /**
     * Validate the list of matchers from a catch scope guard
     * @params:
     *   - context: the context of the validation
     *   - loc: the location of the catch scope guard
     *   - tryType: the type of the block that is caught
     *   - value: the variable that contains the caught exception
     *   - matchers: the list of matcher in the pattern matching
     *   - throwers: the list of exceptions that can be thrown
     * @returns:
     *   - .0: the list of conditions
     *   - .1: the list of values to evaluate in case the conditions are true
     *   - .2: the list of errors that occurs during validation
     *   - .3: the type of the scope
     *   - .4: the list of types that were not caught
     * */
    fn validateMatchersForCatch (self, dmut context : &Validator, tryType : &Type, value : &Value, matchers : [(&Expression, &Expression, &Expression)], throwers : [(&Word, &Type)])-> ([&Value], [&Value], [&ErrorMsg], &Type, [(&Word, &Type)]) {
        let mut finType : &Type = tryType;

        let dmut used = Vec!{(&Word, &Type)}::new ();
        let dmut conds = Vec!{&Value}::new ();
        let dmut values = Vec!{&Value}::new ();
        let dmut errors = Vec!{&ErrorMsg}::new ();
        let mut rest : [(&Word, &Type)] = throwers;

        for mtch in matchers {
            let mut succeed = true;
            context:.enterBlock ();
            {
                if (rest.len == 0us) { // everything was caught, so further patterns are useless
                    throw ErrorMsg::fatal (mtch.0.getLoc (), ValidateErrorMessage::UNREACHABLE_MATCHER);
                }

                let dmut vars = Vec!{([c8], &Value)}::new ();
                let (cond_, used_, subTests) = self.validateMatcherForCatch (alias context, value, mtch.0, rest, used[], alias vars);
                let (cond, _, guardTest) = self.validateConditionGuard (alias context, vars[], mtch.1, cond_);

                conds:.push (cond);

                let mut val = context:.validateValue (mtch.2);
                let (t, v) = if (!val.isBreaker () && !val.isReturner ()) {
                    context:.inferTypeBranchingWithValue (finType.getLoc (), finType, val)
                } else {
                    (finType, val)
                };

                values:.push (BlockValue::new (mtch.2.getLoc (), v.getType (), [v]));

                finType = t;
                if (self.isTautology (alias context, guardTest) && !subTests) { // the guard is always true, and there is no other tests than type equality
                    used:.push ((mtch.0.getLoc (), used_)); // so the type is caught
                    rest = self.listNonCaughtThrowers (alias context, used[], throwers); // list the types that are not yet caught
                }
            } catch {
                err : &ErrorMsg => {
                    errors:.push (err);
                    succeed = false;
                }
            }

            {
                context:.quitBlock (warnUnused-> succeed);
            } catch {
                err : &ErrorMsg => errors:.push (err);
            }
        }

        (conds[], values[], errors[], finType, rest)
    }


    /**
     * Create a conditional value for a given pattern match
     * @params:
     *    - cond: the condition
     *    - val: the value to evaluate if the condition is true
     *    - else_: the value to evaluate if the condition is false
     * */
    fn createConditional (self, loc : &Word, cond : &Value, val : &Value, else_ : &Value, type : &Type, isComplete : bool)-> &Value {
        match cond {
            b : &BoolValue => {
                return if b.isTrue () { val } else { else_ };
            }
        }

        ConditionalValue::new (loc, type, cond, val, elsev-> else_, isComplete-> isComplete)
    }

    /*!
     * ================================================================================
     * ================================================================================
     * ==========================         ERROR DECL         ==========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Declare the variables with error type
     * @throws: if there are shadowing variable found
     * */
    pub fn declareErrorVariables (self, dmut context : &Validator, mtch : &Expression, dmut vars : &Vec!{([c8], &Value)} = Vec!{([c8], &Value)}::new ())-> [([c8], &Value)]
        throws &ErrorMsg
    {
        match mtch {
            vdecl : &VarDeclExpr => {
                if (vdecl.getLoc () != Keys::UNDER) {
                    context:.verifyShadow (vdecl.getLoc ());
                    self.verifyShadowPattern (vdecl.getLoc (), vars[]);

                    let var = VarDeclValue::new (vdecl.getLoc (), ErrorType::new (vdecl.getLoc ()), UNIT_VALUE, isMutable-> false);
                    vars:.push ((vdecl.getLoc ().str (), var));
                }

                self.declareErrorVariables (alias context, vdecl.getValue (), vars-> alias vars);
            }
            o : &OptionMatcherExpr => {
                self.declareErrorVariables (alias context, o.getInner (), vars-> alias vars);
            }
            cl : &MultOperatorExpr => {
                for m in cl.getRights () {
                    self.declareErrorVariables (alias context, m, vars-> alias vars);
                }
            }
            l : &ListMatcherExpr => {
                for m in l.getParameters () {
                    self.declareErrorVariables (alias context, m, vars-> alias vars);
                }
            }
        }

        vars[]
    }

    /*!
     * ================================================================================
     * ================================================================================
     * ==========================         VALIDATION         ==========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate the conditional guard
     * @warning: the block of the pre test has to be already entered, variables from /vars/ are insert in local block
     * @returns:
     *    - .0: the actual test with var decls
     *    - .1: the tautology test
     *    - .2: the guard test
     * @info: the return.1 contains the return.2, both have their purpose .1 is for basic pattern matching tautology checking, and .2 for scope guards as the currentCondition might contains type checking
     * */
    pub fn validateConditionGuard (self, dmut context : &Validator, vars : [([c8], &Value)], guard : &Expression, currentCond : &Value)-> (&Value, &Value, &Value)
        throws &ErrorMsg
    {
        let dmut testBlk = Vec!{&Value}::new ();
        for v in vars {
            if (v.0 != Keys::UNDER) {
                context:.insertLocal (v.0, v.1);
            }

            testBlk:.push (v.1);
        }

        match guard {
            EmptyExpression () => {
                testBlk:.push (BoolValue::new (guard.getLoc (), true));
                let res : &Value = LogicalBinBoolOperatorValue::new (currentCond.getLoc (), BinaryOperators::DAND, currentCond,
                                                            BlockValue::new (currentCond.getLoc (), BoolType::new (currentCond.getLoc ()), testBlk[], isSet-> true));
                (res, currentCond, BoolValue::new (currentCond.getLoc (), true))
            }
            _ => {
                let r = context:.validateValue (guard);
                if (!r.getType ().isOf!{&BoolType} ()) {
                    throw ErrorMsg::fatal (r.getLoc (), format (ValidateErrorMessage::INCOMPATIBLE_TYPE, r.getType (), BoolType::new (r.getLoc ())));
                }

                testBlk:.push (r);
                let res : &Value = LogicalBinBoolOperatorValue::new (currentCond.getLoc (), BinaryOperators::DAND, currentCond,
                                                            BlockValue::new (currentCond.getLoc (), BoolType::new (currentCond.getLoc ()), testBlk[], isSet-> true));

                let taut : &Value = LogicalBinBoolOperatorValue::new (currentCond.getLoc (), BinaryOperators::DAND, currentCond, r);
                (res, taut, r)
            }
        }
    }
    

    /**
     * Validate the matcher from a single pattern (var declaration, if let, etc.)
     * @params:
     *    - context: the context of the validation
     *    - value: the value passed to the matcher
     *    - mtch: the pattern
     * @returns:
     *    - .0: the validate value passed to the pattern
     *    - .1: the runtime test (a true bool value if cte and irrefutable)
     *    - .2: the list of variable to declare (.0-> name, .1-> var decl value)
     *    - .3: the error if any, in that case the variables have an error type in .1 but they can still be inserted in local block if needed
     * @warning: variables are not inserted in any block, they have to be after the function call
     * */
    pub fn validateMatcher (self, dmut context : &Validator, value : &Expression, mtch : &Expression, canBeLazy : bool = false)-> (&Value, &Value, [([c8], &Value)], (&ErrorMsg)?) {
        {
            let mValue = context:.getValueValidator ().validate (alias context, value, canBeRef-> true, canBeLazy-> canBeLazy);
            context.verifyNoBreaking (mtch.getLoc (), mValue);
            context.verifyCompleteTypeWithValue (value.getLoc (), mValue.getType (), mValue, construct-> true);

            let dmut vars = Vec!{([c8], &Value)}::new ();

            let (mut memInfo, fVal) = match mValue {
                r : &ReferencerValue => { (MemoryInfo (byMutRef-> true), r.getValue ()) }
                a : &AliaserValue => { (MemoryInfo (byAlias-> true), a.getValue ()) }
                l : &LazyValue => { (MemoryInfo (byLazy-> l.byAlias ()), l) }
                _ => { (MemoryInfo (byMove-> !context.needExplicitMove (mValue)), mValue) } // explicit move if there is no need for a move to move
            };

            let (cond, retInfo) = self.validateMatcher (alias context, fVal, mtch, alias vars, memInfo, canBeLazy-> canBeLazy);
            if (!retInfo.byMutRef && memInfo.byMutRef) {
                throw ErrorMsg::fatal (mValue.getLoc (), ValidateErrorMessage::UNECESSARY_REFERENCE,
                                       notes-> [ErrorMsg::note (mtch.getLoc (), ValidateErrorMessage::NO_REFERENCE_PATTERN)]);
            } else if (!retInfo.byAlias && memInfo.byAlias) {
                throw ErrorMsg::fatal (mValue.getLoc (), format (ValidateErrorMessage::UNECESSARY_ALIAS, mValue.getType ()),
                                       notes-> [ErrorMsg::note (mtch.getLoc (), format (ValidateErrorMessage::NO_ALIAS_PATTERN, ""s8))]);
            } else if (!retInfo.byLazy && memInfo.byLazy) {
                throw ErrorMsg::fatal (mValue.getLoc (), format (ValidateErrorMessage::UNECESSARY_LAZY, mValue.getType ()),
                                       notes-> [ErrorMsg::note (mtch.getLoc (), format (ValidateErrorMessage::NO_LAZY_PATTERN, ""s8))]);
            }

            (mValue, cond, vars[], ((&ErrorMsg)?)::__err__)
        } catch {
            err : &ErrorMsg => { // insert error variables to avoid future undefined symbol errors
                {
                    let vars = context:.getMatcherValidator ().declareErrorVariables (alias context, mtch);
                    return (UNIT_VALUE, UNIT_VALUE, vars, err?);
                } catch {
                    _ => return (UNIT_VALUE, UNIT_VALUE, [], err?);
                }
            }
        }
    }

    /**
     * Validate a matcher inside a catcher scope guard
     * @params:
     *    - context: the context of the validation
     *    - value: the variable containing the thrown exception
     *    - mtch: the pattern
     *    - throwers: the list of types that can be thrown that are not caught yet
     *    - allThrowers: the list of types that can be thrown by the try part
     * @returns:
     *    - .0: the condition to check
     *    - .1: the type that is caught
     *    - .2: if there is other conditions that just type equality
     *    - vars: the list of variable declared within this pattern matcher
     * */
    fn validateMatcherForCatch (self, dmut context : &Validator, value : &Value, mtch : &Expression, throwers : [(&Word, &Type)], caught : [(&Word, &Type)], dmut vars : &Vec!{([c8], &Value)})-> (&Value, &Type, bool)
        throws &ErrorMsg
    {
        return match mtch {
            v : &VarDeclExpr => {
                self.validateVarDeclMatcherForCatch (alias context, value, v, throwers, caught, alias vars)
            }
            m : &MultOperatorExpr => {
                self.validateCallOpMatcherForCatch (alias context, value, m, throwers, caught, alias vars)
            }
            _ => {
                throw ErrorMsg::fatal (mtch.getLoc (), format (ValidateErrorMessage::CATCH_PATTERN_MULT_OR_VDECL));
            }
        };
    }


    /**
     * Validate a matcher
     * @params:
     *   - context: the context of the validation
     *   - value: the value to match
     *   - mtch: the matcher expression
     * @returns: the condition to evaluate at runtime
     * */
    fn validateMatcher (self, dmut context : &Validator, value : &Value, mtch : &Expression, dmut vars : &Vec!{([c8], &Value)}, memInfo : MemoryInfo, canBeLazy : bool = false)-> (&Value, MemoryInfo)
        throws &ErrorMsg
    {
        return match mtch {
            v : &VarDeclExpr => {
                self.validateVarDeclMatcher (alias context, value, v, alias vars, memInfo, canBeLazy-> canBeLazy)
            }
            o : &OptionMatcherExpr => {
                self.validateOptionMatcher (alias context, value, o, alias vars, memInfo)
            }
            m : &MultOperatorExpr => {
                self.validateCallOpMatcher (alias context, value, m, alias vars, memInfo)
            }
            l : &ListMatcherExpr => {
                if (l.isTuple ()) {
                    self.validateTupleMatcher (alias context, value, l, alias vars, memInfo)
                } else {
                    self.validateArrayMatcher (alias context, value, l, alias vars, memInfo)
                }
            }
            _ => {
                (self.validateValueEqualMatcher (alias context, value, mtch), MemoryInfo ())
            }
        };
    }

    /**
     * validate a var declaration matcher for a catch scope guard
     * @params:
     *    - context: the context of the validation
     *    - value: the value that is caught
     *    - vdecl: the variable declaration
     * @returns:
     *    - .0: the condition
     *    - .1: the type that is caught
     *    - .2: has also value checking ? (that might fail even if the type is caught)
     * */
    fn validateVarDeclMatcherForCatch (self, dmut context : &Validator, value : &Value, vdecl : &VarDeclExpr, throwers : [(&Word, &Type)], caught : [(&Word, &Type)], dmut vars : &Vec!{([c8], &Value)})-> (&Value, &Type, bool)
        throws &ErrorMsg
    {
        if (vdecl.getLoc () != Keys::UNDER) {
            context:.verifyShadow (vdecl.getLoc ()); // variable declaration, so no shadows are allowed
            self.verifyShadowPattern (vdecl.getLoc (), vars[]);  // verify that no variable declared within the pattern are shadowing each other
        }

        {
            let (typeCond, finalType, valToAffect, castedValue, _) = self.validateVarDeclMatcherValue (alias context, value, vdecl, false, MemoryInfo ());
            self.verifyIsThrown (alias context, vdecl.getLoc (), finalType, throwers, caught);

            let var = VarDeclValue::new (vdecl.getLoc (), finalType, valToAffect, isReference-> false, isMutable-> false);
            vars:.push ((vdecl.getLoc ().str (), var)); // add the declaration in the pattern matching success block

            let (valueCond, _) = if (!vdecl.getValue ().isOf!{&EmptyExpression} ()) { // x : T = V =>
                // inner pattern matching on V using /cast!T (value)/ (since the type test was true)
                self.validateMatcher (alias context, castedValue, vdecl.getValue (), alias vars, MemoryInfo ())
            } else {
                (cast!{&Value} (BoolValue::new (vdecl.getLoc (), true)), MemoryInfo ()) // necessarily pass
            };

            let subTest = !self.isTautology (alias context, valueCond);

            // test type && test value to be a successful pattern matcher
            (LogicalBinBoolOperatorValue::new (vdecl.getLoc (), BinaryOperators::DAND, typeCond, valueCond), finalType, subTest)
        } catch {
            err : &ErrorMsg => { // insert error variable to avoid undefined symbol errors
                if (vdecl.getLoc () != Keys::UNDER) {
                    let var = VarDeclValue::new (vdecl.getLoc (), ErrorType::new (vdecl.getLoc ()), UNIT_VALUE, isReference-> false, isMutable-> false);
                    vars:.push ((vdecl.getLoc ().str (), var));
                }

                throw err;
            }
        }
    }

    /**
     * Validate a var declaration matcher
     * @params:
     *    - context: the context of the validation
     *    - value: the value to match
     *    - vdecl: the variable declaration
     * @returns: the condition to evaluate at runtime
     * */
    fn validateVarDeclMatcher (self, dmut context : &Validator, value : &Value, vdecl : &VarDeclExpr, dmut vars : &Vec!{([c8], &Value)}, memInfo : MemoryInfo, canBeLazy : bool)-> (&Value, MemoryInfo)
        throws &ErrorMsg
    {
        if (vdecl.getLoc () != Keys::UNDER) {
            context:.verifyShadow (vdecl.getLoc ()); // variable declaration, so no shadows are allowed
            self.verifyShadowPattern (vdecl.getLoc (), vars[]); // verify that no variable declared within the pattern are shadowing each other
        }

        {
            // Transform the value into something assignable to the var decl, and retreive the runtime test if any and some other stuff for further matching and validation
            let (typeCond, finalType, valToAffect, castedValue, retInfo) = self.validateVarDeclMatcherValue (alias context, value, vdecl, vdecl.isRef (), memInfo, isLazy-> vdecl.isLazy (), canBeLazy-> canBeLazy);
            let tLoc = if (vdecl.getType ().isOf!{&EmptyExpression} ()) { vdecl.getLoc () } else { vdecl.getType ().getLoc () };
            context.verifyNonVoidType (tLoc, finalType, true);

            // if the variable is lazy it cannot be mutable unless it borrows mutable data
            if (finalType.isMutable () && !finalType.needExplicitAlias () && vdecl.isLazy ()) {
                throw ErrorMsg::fatal (vdecl.getMutOrDmutLocation (), ValidateErrorMessage::MUTABLE_LAZY_VAR);
            }

            let var = VarDeclValue::new (vdecl.getLoc (), finalType, valToAffect, isReference-> vdecl.isRef (), isLazy-> vdecl.isLazy (), isMutable-> finalType.isMutable ());
            vars:.push ((vdecl.getLoc ().str (), var)); // add the declaration in the pattern matching success block

            let (valueCond, innerMemInfo) = if (!vdecl.getValue ().isOf!{&EmptyExpression} ()) { // x : T = V =>
                // inner pattern matching on V using /cast!T (value)/ (since the type test was true)
                self.validateMatcher (alias context, castedValue, vdecl.getValue (), alias vars, memInfo)
            } else {
                (cast!{&Value} (BoolValue::new (vdecl.getLoc (), true)), MemoryInfo ()) // necessarily pass
            };

            // test type && test value to be a successful pattern matcher
            (LogicalBinBoolOperatorValue::new (vdecl.getLoc (), BinaryOperators::DAND, typeCond, valueCond), retInfo.or (innerMemInfo))
        } catch {
            err : &ErrorMsg => { // insert error variable to avoid undefined symbol errors
                if (vdecl.getLoc () != Keys::UNDER) {
                    let var = VarDeclValue::new (vdecl.getLoc (), ErrorType::new (vdecl.getLoc ()), UNIT_VALUE, isReference-> vdecl.isRef (), isLazy-> vdecl.isLazy (), isMutable-> (vdecl.isMutable () || vdecl.isDeeplyMutable ()));
                    vars:.push ((vdecl.getLoc ().str (), var));
                }

                throw err;
            }
        }
    }

    /**
     * Validate the casting of the matching value to the type of the variable
     * @params:
     *    - context: the context of the validation
     *    - value: the value (reference or not)
     *    - vdecl: the pattern
     *    - isRef: true if the vdecl has /ref/ deco
     * @returns:
     *    - .0: the test (a true bool value if the test is irrefutable)
     *    - .1: the type of the vdecl
     *    - .2: the value to affect in the vdecl
     *    - .3: the value to pass for further matching (already cleaned of reference/aliaser by casted to the correct type)
     * */
    fn validateVarDeclMatcherValue (self, dmut context : &Validator, value : &Value, vdecl : &VarDeclExpr, isRef : bool, memInfo : MemoryInfo, isLazy : bool = false, canBeLazy : bool = false)-> (&Value, &Type, &Value, &Value, MemoryInfo)
        throws &ErrorMsg
    {
        let (test, type, castedValue) = if (!vdecl.getType ().isOf!{&EmptyExpression} ()) { // not '_'
            let type = context:.validateTypeForVarDecl (vdecl.getType (), vdecl, canBeRef-> true, canBeLazy-> canBeLazy);
            let (typeTest, castedValue) = match (value.getType (), type) {
                (valueType : &ClassPtrType, declType : &ClassPtrType) => { // a class reverse casting: Base -> Derived can only be known at cte (
                    // inner == derived, so the test is cte and no need to cast anything
                    if (declType.isCompatible (valueType)) {
                        (cast!{&Value} (BoolValue::new (vdecl.getType ().getLoc (), true)), value)
                    }

                    // value is a Derived of derived, or derived is a Derived of value, both are allowed but one has to be runtime evaluated (Derived <- Base)
                    else {
                        // unless it is a Derived -> Base, but that is already managed by the binary operator validator
                        if (isRef && context.isAncestor (declType, valueType)) { // ref mut x : &Base = ref y : Derived is not allowed, because x = Base::new () will result in undefined behavior
                            throw ErrorMsg::fatal (vdecl.getLoc (), end-> value.getLoc (), format (ValidateErrorMessage::CANNOT_CASTTO_BASE_CLASS, valueType, declType),
                                                   notes-> [ErrorMsg::note (vdecl.getRefLocation (), ""s8)]);
                        }
                        // However, ref mut x : Derived = ref y : Base, is allowed we can only put a Derived into x, thus y will always contain a Base so no problem

                        // Create the runtime test to check wether the value is containing an instance of the type of the variable decl
                        let typeTest = context:.getBinOpValidator ().validateClassTypeTestOp (alias context, vdecl.getType ().getLoc (), BinaryOperators::OF, value, declType.getInner ());

                        // we clone the derived type to match the base type mutability
                        let resType = declType.clone (pattern-> valueType);

                        //  cast the value into the type of the variable decl
                        let ctdValue = CastValue::new (type.getLoc (), resType, value, isLvalue-> value.isLvalue ());
                        (typeTest, ctdValue)
                    }
                }
                _ => { // Any other type test is cte evaluated
                    (cast!{&Value} (BoolValue::new (vdecl.getType ().getLoc (), true)), value)
                }
            };

            (typeTest, type, castedValue)
        } else { // create a type for mutability checking
            let type = context:.validateTypeForVarDecl (TypeWrapperExpr::new (value.getLoc (), value.getType ()), vdecl, canBeRef-> true, canBeLazy-> canBeLazy);
            (cast!{&Value} (BoolValue::new (vdecl.getLoc (), true)), type, value) // type test is always true
        };

        // Reducing the value if it's not by reference
        let reducedVal = context:.getCompileTimeInterpreter (forRef-> (memInfo.byMutRef || isRef)).reduce (castedValue);

        // Transform the value to be implicit casted to the type
        let ctdValue = context:.verifyCompatibleTypeWithValue (vdecl.getLoc (), type, reducedVal, byReference-> isRef);

        // transform the value into a ref or an alias if the root value was passed by ref or alias
        let (postCtdValue, retInfo) = // if (isLazy && byLazy) {
        //     (ctdValue, false, false, true)
        // } else
            if (memInfo.byMutRef && isRef && ctdValue.isLvalue () && ctdValue.getType ().isMutable ()) {
                (cast!{&Value} (ReferencerValue::new (reducedVal.getLoc (), ctdValue.getType (), ctdValue, isMutable-> true)), MemoryInfo (byMutRef-> true))
            } else if (!isRef && (memInfo.byAlias || memInfo.byMutRef) && type.isMutable () && type.needExplicitAlias ()) {
                (AliaserValue::new (value.getLoc (), ctdValue.getType (), ctdValue), MemoryInfo (byAlias-> true, byLazy-> (isLazy && memInfo.byLazy))) // if we mix pattern using ref and alias, then ref has priority and can be used as alias
            } else if (isRef && !memInfo.byMutRef && ctdValue.isLvalue ()) {
                (cast!{&Value} (ReferencerValue::new (reducedVal.getLoc (), ctdValue.getType (), ctdValue, isMutable-> false)), MemoryInfo ())
            } else { (ctdValue, MemoryInfo (byLazy-> (isLazy && memInfo.byLazy))) };

        // Verify memory implicit alias/ref and mutability
        context:.verifyMemoryOwner (vdecl.getLoc (), type, postCtdValue, construct-> true, byReference-> isRef, byLazy-> isLazy, byMove-> memInfo.byMove);
        (test, type, postCtdValue, castedValue, retInfo)
    }


    /**
     * Validate a call operator matcher for a catch scope guard
     * @params:
     *    - context: the context of the validation
     *    - value: the value that is caught
     *    - cl: the call op
     * @returns:
     *    - .0: the condition
     *    - .1: the type that is caught
     *    - .2: has also value checking ? (that might fail even if the type is caught)
     * */
    fn validateCallOpMatcherForCatch (self, dmut context : &Validator, value : &Value, cl : &MultOperatorExpr, throwers : [(&Word, &Type)], caught : [(&Word, &Type)], dmut vars : &Vec!{([c8], &Value)})-> (&Value, &Type, bool)
        throws &ErrorMsg
    {
        let (cond, innerCond, finalType, _) = self.validateCallOpMatcherValue (alias context, value, cl, alias vars, MemoryInfo ());
        self.verifyIsThrown (alias context, cl.getLoc (), finalType, throwers, caught);

        let subTest = !self.isTautology (alias context, innerCond);
        (cond, finalType, subTest)
    }

    /**
     * Validate a call operator matcher
     * @params:
     *    - context: the context of the validation
     *    - value: the value to match
     *    - cl: the call operator
     *    - vars: the list of variables to be declared the matching
     * @returns:
     *    - .0: the condition to evaluate at runtime
     * */
    fn validateCallOpMatcher (self, dmut context :  &Validator, value : &Value, cl : &MultOperatorExpr, dmut vars : &Vec!{([c8], &Value)}, memInfo : MemoryInfo)-> (&Value, MemoryInfo)
        throws &ErrorMsg
    {
        let (cond, _, _, retInfo) = self.validateCallOpMatcherValue (alias context, value, cl, alias vars, memInfo);
        (cond, retInfo)
    }

    /**
     * Validate a call operator matcher
     * @params:
     *    - context: the context of the validation
     *    - value: the value to match
     *    - cl: the call operator
     *    - vars: the list of variables to be declared the matching
     * @returns:
     *    - .0: the condition to evaluate at runtime
     *    - .1: the test on inner values (fields)
     *    - .2: the type to which the type is casted
     * */
    fn validateCallOpMatcherValue (self, dmut context : &Validator, value : &Value, cl : &MultOperatorExpr, dmut vars : &Vec!{([c8], &Value)}, memInfo : MemoryInfo)-> (&Value, &Value, &Type, MemoryInfo)
        throws &ErrorMsg
    {
        let validateL = match cl.getLeft () { // don't validate _ ()
            v : &VarExpr => {
                v.getLoc () != Keys::UNDER
            }
            _ => { true }
        };

        let (typeCond, castedValue, resType) = if (validateL) { // Validate the type X in /X (fields-> ...)/
            let type = context:.validateType (cl.getLeft ());
            let (typeTest, castedValue) = match (value.getType (), type) {
                (ClassPtrType (), inner : &ClassPtrType) => { // a class reverse casting: Base -> Derived can only be known at cte (
                                                              // unless it is a Derived -> Base, but that is already managed by the binary operator validator
                    let typeTest = context:.getBinOpValidator ().validateClassTypeTestOp (alias context, type.getLoc (), BinaryOperators::OF, value, inner.getInner ());

                    // we clone the derived type to match the base type mutability
                    if (inner.isStruct ()) {
                        (cast!{&Value} (BoolValue::new (type.getLoc (), true)), value)
                    } else {
                        let resType = type.clone (pattern-> value.getType ());
                        (typeTest, cast!{&Value} (CastValue::new (type.getLoc (), resType, value, isLvalue-> value.isLvalue ()))) // transform the value into the derived type
                    }
                }
                (vtype : &ClassPtrType, inner : &ClassRefType) => { // Same as class ptr, but in MultOp a class ref can be used directly (Derived () => ) to match &Base
                    let typeTest = context:.getBinOpValidator ().validateClassTypeTestOp (alias context, type.getLoc (), BinaryOperators::OF, value, inner);

                    if inner.isStruct () {
                        (cast!{&Value} (BoolValue::new (type.getLoc (), true)), value)
                    } else {
                        // we clone the derived type to match the base type mutability
                        let resType = inner.createInstance (loc-> type.getLoc (), vtype.isMutable (), vtype.isDeeplyMutable ());
                        (typeTest, cast!{&Value} (CastValue::new (type.getLoc (), resType, value, isLvalue-> value.isLvalue ())))
                    }
                }
                _ => { // Any other type test is cte evaluated
                    context.verifyCompatibleType (value.getLoc (), type.getLoc (), value.getType (), type);
                    (cast!{&Value} (BoolValue::new (type.getLoc (), true)), value)
                }
            };

            (typeTest, castedValue, type)
        } else {
            let t = context:.validateType (TypeWrapperExpr::new (value.getLoc (), value.getType ()));
            (cast!{&Value} (BoolValue::new (cl.getLeft ().getLoc (), true)), value, t)
        };

        let dmut errors = Vec!{&ErrorMsg}::new ();
        let mut curValueTest : &Value = BoolValue::new (cl.getLoc (), true);
        let mut innerRetInfo = MemoryInfo ();
        for p in cl.getRights () match p {
            n : &NamedExpr => {
                let val = context:.getBinOpValidator ().validateFieldOperation (alias context, n.getLoc (), BinaryOperators::DOT, castedValue, VarExpr::new (n.getLoc ()));
                let (innerTest, innerRetInfo_) = {
                    self.validateMatcher (alias context, val, n.getContent (), alias vars, memInfo)
                } catch {
                    error : &ErrorMsg => {
                        throw error.withNote ([ErrorMsg::note (n.getLoc (), format (ValidateErrorMessage::FOR_PATTERN_FIELD, n.getLoc ().str (), castedValue.getType ()))]);
                    }
                }

                curValueTest = LogicalBinBoolOperatorValue::new (n.getLoc (), BinaryOperators::DAND, curValueTest, innerTest);
                innerRetInfo = innerRetInfo.or (innerRetInfo_);
            }
            _ => {
                errors:.push (ErrorMsg::fatal (p.getLoc (), format (ValidateErrorMessage::FIELD_MATCHER_NO_NAME)));
            }
        }

        if (errors.len () != 0us) throw ErrorMsg::list (errors[]);
        (LogicalBinBoolOperatorValue::new (cl.getLoc (), BinaryOperators::DAND, typeCond, curValueTest), curValueTest, resType, innerRetInfo)
    }

    /**
     * Validate an option matcher
     * @params:
     *     - context: the context of the validation
     *     - value: the value being matched
     *     - opt: the option matcher to validate
     *     - vars: the list of variables to be declared the matching
     * @returns:
     *    - .0: the runtime test
     * */
    fn validateOptionMatcher (self, dmut context : &Validator, value : &Value, opt : &OptionMatcherExpr, dmut vars : &Vec!{([c8], &Value)}, memInfo : MemoryInfo)-> (&Value, MemoryInfo)
        throws &ErrorMsg
    {
        let loc = opt.getLoc ();
        if (!value.getType ().isOf!{&OptionType} ()) { // only option values can be passed to option pattern
            throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::OPTION_MATCHER, loc, value.getType ()));
        }

        let optType = value.getType ().asOf!{&OptionType} ();
        let isSet = StructFieldAccessValue::new (loc, BoolType::new (loc), value, OptionKeys::SET);
        if (loc == OptionKeys::MATCH_SOME) match opt.getInner () { // /Ok/
            EmptyExpression () => return (isSet, MemoryInfo ());
            exp : &Expression => { // e.g. /Ok (x : _)/
                let innerVal = OptionFieldAccessValue::new (loc, optType.getInners ()[0], value, OptionKeys::VALUE);
                // Validate the pattern on the value of the option
                let (innerTest, innerMemInfo) = self.validateMatcher (alias context, innerVal, exp, alias vars, memInfo);

                return (LogicalBinBoolOperatorValue::new (loc, BinaryOperators::DAND, isSet, innerTest), innerMemInfo);
            }
        } else match opt.getInner () { // /Err/
            EmptyExpression () => {
                return (UnaryBoolOperatorValue::new (loc, UnaryOperators::NOT, isSet), MemoryInfo ());
            }
            exp : &Expression => { // e.g. /Err (x : _)/
                let ptrType = PointerType::new (loc, VoidType::new (loc));

                // all none option don't have an error, they may be completely empty, so we need to check that
                let hasError = CmpPointerOperatorValue::new (loc, BinaryOperators::NOT_EQUAL,
                                                             OptionFieldAccessValue::new (loc, ptrType, value, OptionKeys::ERROR),
                                                             NullValue::new (loc, ptrType));

                let notSet = UnaryBoolOperatorValue::new (loc, UnaryOperators::NOT, isSet);
                let finTest = LogicalBinBoolOperatorValue::new (loc, BinaryOperators::DAND, notSet, hasError); // !isSet && error != null


                let innerType = context:.getExceptionType (loc-> loc);
                let err = OptionFieldAccessValue::new (loc, innerType, value, OptionKeys::ERROR);

                // Validate the pattern on the error of the option
                let (innerTest, innerMemInfo) = self.validateMatcher (alias context, err, exp, alias vars, memInfo);

                return (LogicalBinBoolOperatorValue::new (loc, BinaryOperators::DAND, finTest, innerTest), innerMemInfo);
            }
        }
    }

    /**
     * Validate a tuple matcher
     * @params:
     *    - context: the context of the validation
     *    - value: the value to match
     *    - tu: the tuple list
     *    - vars: the list of variables to be declared the matching
     * @returns:
     *    - .0: the runtime test
     * */
    fn validateTupleMatcher (self, dmut context : &Validator, value : &Value, tu : &ListMatcherExpr, dmut vars : &Vec!{([c8], &Value)}, memInfo : MemoryInfo)-> (&Value, MemoryInfo)
        throws &ErrorMsg
    {
        let loc = tu.getLoc ();
        let values = self.expandTupleValues (alias context, loc, tu, value); // transform the tuple into a list of values so the rest of the validation gets easier
        if (tu.isVariadic () && tu.getParameters ().len - 1us > values.len) { // (x,z...) = (1,) is ok, x <- 1, z <- (), but (x,z...) = () is not there is nothing for x
            throw ErrorMsg::fatal (tu.getLoc (), format (ValidateErrorMessage::TUPLE_ARITY_OVERFLOW, tu.getParameters ().len, values.len));
        } else if (!tu.isVariadic () && tu.getParameters ().len != values.len) { // (x,) = (1,2) or (x, y) = (1,) are not ok
            throw ErrorMsg::fatal (tu.getLoc (), format (ValidateErrorMessage::TUPLE_ARITY_OVERFLOW, tu.getParameters ().len, values.len));
        }

        // pattern match inner values
        let mut curValueTest : &Value = BoolValue::new (loc, true);
        let mut innerRetInfo = MemoryInfo ();
        for i, p in tu.getParameters () {
            // currField is used for clearer errors
            let (assocValue, currField) = if (i != tu.getParameters ().len - 1us || !tu.isVariadic ()) {
                (values [i], format ("%",i)) // one value by one value
            } else { // e.g. (x, y...) = (1, 2, 3), y <- (2, 3)
                let rest = values [i .. $];
                let dmut tupleTypes = Vec!{&Type}::new ();
                for j in i .. values.len { // create a tuple type to get all last values
                    tupleTypes:.push (values [j].getType ());
                    if (values [j].getType ().isMovable ()) {
                        throw ErrorMsg::fatal (values [j].getLoc (), end-> values [j].getType ().getLoc (), format (ValidateErrorMessage::CONTAIN_MOVABLE_TYPE, values [j].getType ()),
                                               notes-> [ErrorMsg::note (value.getLoc (), format (ValidateErrorMessage::CONTAIN_MOVABLE_TYPE_NOTE), oneLine-> true)]);
                    }
                }

                let tupleType = TupleType::new (value.getLoc (), tupleTypes[], isMutable-> value.getType ().isMutable ());

                // declare a tuple literal containing the values
                (cast!{&Value} (TupleValue::new (value.getLoc (), tupleType, rest)), format ("%..%", i, values.len))
            };

            let (innerTest, innerMemInfo) = {
                self.validateMatcher (alias context, assocValue, p, alias vars, memInfo)
            } catch {
                err : &ErrorMsg => { // add a note to the error so its easier to get the value responsible for the error
                    throw err.withNote ([ErrorMsg::note (tu.getLoc (), format (ValidateErrorMessage::FOR_PATTERN_FIELD, currField, value.getType ()))]);
                }
            };

            curValueTest = LogicalBinBoolOperatorValue::new (loc, BinaryOperators::DAND, curValueTest, innerTest);
            innerRetInfo = innerRetInfo.or (innerMemInfo);
        }

        (curValueTest, innerRetInfo)
    }

    /**
     * Expand the tuple values (unlike expand from intrinsic, this expand allows for mutable)
     * @warning: only tuple typed value can be used here (value.getType () of TupleType)
     * @returns: a list of values (tuple field accessed)
     * */
    fn expandTupleValues (self, dmut context : &Validator, loc : &Word, tu : &ListMatcherExpr, value : &Value)-> [&Value]
        throws &ErrorMsg
    {
        let dmut tyValues = Vec!{&Value}::new ();
        match value.getType () {
            ty : &TupleType => {
                // expand the tuple, so it can be easily read
                for it in 0us .. ty.getInners ().len {
                    let access = context:.getBinOpValidator ().createTupleFieldAccess (loc, ty.getInners ()[it], value, it, reduce-> false);
                    tyValues:.push (access); // context.getCompileTimeInterpreter ().reduce (access));
                }
            }
            _ => { //
                throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::TUPLE_PATTERN, tu, value.getType ()));
            }
        }

        tyValues[]
    }

    /**
     * Validate an array matcher
     * @params:
     *    - context: the context of the validation
     *    - value: the value to match
     *    - arr: the array list
     *    - vars: the list of variables to be declared the matching
     * @returns:
     *    - .0: the runtime test
     * */
    fn validateArrayMatcher (self, dmut context : &Validator, value : &Value, arr : &ListMatcherExpr, dmut vars : &Vec!{([c8], &Value)}, memInfo : MemoryInfo)-> (&Value, MemoryInfo)
        throws &ErrorMsg
    {
        let loc = arr.getLoc ();
        let len = { // retreive the length of the value
            context:.getBinOpValidator ().validateFieldOperation (alias context, value.getLoc (), BinaryOperators::DOT, value, VarExpr::new (Word::new (SliceKeys::LEN, value.getLoc ())))
        } catch {
            err : &ErrorMsg => { // the value does not have a LEN field (TODO maybe make a test for class object to implement a specific traits?)
                throw err.withNote ([ErrorMsg::note (loc, ValidateErrorMessage::HERE)]);
            }
        }

        // Runtime check of the len of the value
        let (lenTest, ex) = if (arr.isVariadic ()) {
            let ex = makeIntValue (arr.getParameters ().len - 1us); // if it is variadic, then the value should contain at least N - 1 elements (e.g. [x, y...] = [1] is ok, with N = 2, [y...] = [] is ok with N = 1)
            (cast!{&Value} (CmpIntOperatorValue::new (loc, BinaryOperators::SUP_EQUAL, len, ex)), ex)
        } else {
            let ex = makeIntValue (arr.getParameters ().len); // not variadic, thus the value has to contain the same number of elements as in the pattern (e.g. [x, y] = [1, 2] is ok, but not [x, y] = [1])
            (cast!{&Value} (CmpIntOperatorValue::new (loc, BinaryOperators::DEQUAL, len, ex)), ex)
        };

        match context:.getCompileTimeInterpreter ().reduce (lenTest) {
            b : &BoolValue => { // if the len test is CTE we can send an error if it is not valid (e.g. for array values)
                if (!b.isTrue ()) throw ErrorMsg::fatal (arr.getLoc (), format (ValidateErrorMessage::ARRAY_PATTERN_SIZE, ex, len));
            }
        }

        // these tokens are used in index access syntax at each iteration, we construct them once to avoid overusing memory for nothing
        let lcro = Word::new (Tokens::LCRO, loc), rcro = Word::new (Tokens::RCRO, loc);

        let mut curValueTest : &Value = BoolValue::new (loc, true);
        let mut innerRetInfo = MemoryInfo ();
        for i, p in arr.getParameters () {
            // currField is used for clearer errors
            let (assocValue, currField) = { // access elements indexed in the value
                context:.enterUnsafeContext (arr.getLoc ()); // entering unsafe context to avoid slice of array len checking that would be useless
                if (i != arr.getParameters ().len - 1us || !arr.isVariadic ()) { // one by one
                    let index = makeIntValue (i);
                    let acc = context:.getIndexOpValidator ().validate (alias context, MultOperatorExpr::new (lcro, rcro, ValueWrapperExpr::new (value.getLoc (), value), [ValueWrapperExpr::new (loc, index)])); // /value [i]/
                    (acc, format ("%", i))
                } else { // variadic, we access the rest of the elements in the value
                    let index = makeIntValue (i);
                    let rng = RangeValue::new (loc, RangeType::new (loc, index.getType ().asOf!{&IntType} (), IntType::new (loc, size-> 0u16, signed-> true), false), index, len);
                    let acc = context:.getIndexOpValidator ().validate (alias context, MultOperatorExpr::new (lcro, rcro, ValueWrapperExpr::new (value.getLoc (), value), [ValueWrapperExpr::new (loc, rng)])); // /value [i .. $]/
                    (acc, format ("%..$", i))
                }
            } exit {
                context:.exitUnsafeContext ()?;
            };

            let (innerTest, innerMemInfo) = {
                self.validateMatcher (alias context, assocValue, p, alias vars, memInfo)
            } catch {
                err : &ErrorMsg => { // note the error for clearer errors
                    throw err.withNote ([ErrorMsg::note (loc, format (ValidateErrorMessage::FOR_PATTERN_FIELD, currField, value.getType ()))]);
                }
            }

            curValueTest = LogicalBinBoolOperatorValue::new (loc, BinaryOperators::DAND, curValueTest, innerTest);
            innerRetInfo = innerRetInfo.or (innerMemInfo);
        }

        (LogicalBinBoolOperatorValue::new (loc, BinaryOperators::DAND, lenTest, curValueTest), innerRetInfo)
    }

    /**
     * Validate a matcher using a value
     * @info: from there, no variable can be created anymore just value equality (thus no need for vars, byMutRef and byAlias)
     * @params:
     *    - context: the context of the validation
     *    - value: the value to match
     *    - mtch: the matcher value
     * @returns: the condition to evaluate at runtime
     * */
    fn validateValueEqualMatcher (self, dmut context : &Validator, value : &Value, mtch : &Expression)-> &Value
        throws &ErrorMsg
    {
        match mtch {
            b : &BinaryExpr => {
                if b.getLoc () == BinaryOperators::PIPE { // e.g. /x | y | 12/, means either x or y or 12
                    let left = self.validateValueEqualMatcher (alias context, value, b.getLeft ());
                    let right = self.validateValueEqualMatcher (alias context, value, b.getRight ());

                    return LogicalBinBoolOperatorValue::new (mtch.getLoc (), BinaryOperators::DPIPE, left, right); // left || right
                }
            }
            t : &VarExpr => { // ignoring value when encoutering the var reference expr /_/
                if (t.getLoc () == Keys::UNDER) return BoolValue::new (mtch.getLoc (), true);
            }
        }

        let eqVal = context:.validateValue (mtch); // otherwise making a strong equality test (value == mtch), where mtch is constructed inside the test
        context:.getBinOpValidator ().validateComparisonOperation (alias context, mtch.getLoc (), BinaryOperators::DEQUAL, value, eqVal)
    }


    /*!
     * ================================================================================
     * ================================================================================
     * =========================         VERIFICATION         =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * @returns: true if the list condition is a tautology
     * @warning: could clearly be enhanced, for example if the test is checking for all the values of an enum, or a list of base types of exceptions are tested TODO
     * */
    fn isTautology (self, dmut context : &Validator, cond : &Value)-> bool
        throws &ErrorMsg
    {
        let red = context.getCompileTimeInterpreter ().reduce (cond);
        match red {
            b : &BoolValue => return b.isTrue ();
        }

        false
    }

    /**
     * @returns: the list of types that are not caught by the catcher
     * @params:
     *    - context: the context of the validation
     *    - used: the list of types that are caught by the catcher
     *    - throwers: the list of tyep that can by thrown in the try part
     * */
    fn listNonCaughtThrowers (self, dmut context : &Validator, used : [(&Word, &Type)], throwers : [(&Word, &Type)])-> [(&Word, &Type)]
        throws &ErrorMsg
    {
        let dmut res = Vec!{(&Word, &Type)}::new ();
        for i in throwers {
            let mut found = false;
            for j in used {
                if context.isDirectInstance (i._1, j._1) || context.isAncestor (j._1, i._1) {
                    found = true;
                    break {}
                }
            }

            if (!found) {
                res:.push (i);
            }
        }

        res[]
    }

    /**
     * Verify that the catching pattern catch is useful and catch an exception
     * @params:
     *    - loc: the location of the pattern
     *    - type: the type being caught
     *    - throwers: the list of exception that have to be caught
     *    - caught: the list of exception that are already caught inside other patterns
     * */
    fn verifyIsThrown (self, dmut context : &Validator, loc : &Word, type : &Type, throwers : [(&Word, &Type)], caught : [(&Word, &Type)])
        throws &ErrorMsg
    {
        for i in throwers {
            if (context.isDirectInstance (type, i._1) || context.isAncestor (type, i._1)) return {}
        }

        for i in caught {
            if (context.isDirectInstance (type, i._1) || context.isAncestor (i._1, type)) {
                throw ErrorMsg::fatal (loc, end-> i._0, format (ValidateErrorMessage::ALREADY_CAUGHT, type, i._1));
            }
        }

        throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::CATCH_NOTHING, type));
    }

    /**
     * Verify that all the branches have the correct type, i.e. if the match is not complete, then branch values must be void
     * @returns: the final type of the match<
     * @throws:
     *    - &ErrorMsg: if the match is not complete, but branch values are not void
     * */
    fn verifyComplete (self, loc : &Word, value : &Value, complete : bool, type : &Type, values : [&Value])-> &Type
        throws &ErrorMsg
    {
        let retType = if (!complete) { cast!{&Type} (VoidType::new (loc)) } else { type };

        if (!complete) {
            let dmut errors = Vec!{&ErrorMsg}::new ();
            for i in values {
                if (!i.getType ().isOf!{&VoidType} ()) {
                    errors:.push (ErrorMsg::fatal (i.getLoc (), format (ValidateErrorMessage::MATCH_NOT_COMPLETE, i.getType ())));
                }
            }

            if (errors.len () != 0us) {
                throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::MATCH_VALIDATION, value, value.getType ()), notes-> errors []);
            }
        }

        retType
    }

    /**
     * Variables declared within pattern are not inserted in local block
     * Thus we need to verify that they are not shadowing each other within the same pattern
     * */
    fn verifyShadowPattern (self, loc : &Word, vars : [([c8], &Value)])
        throws &ErrorMsg
    {
        for v in vars match v.1 {
            vd : &VarDeclValue => {
                if (vd.getLoc ().str () == loc.str ()) {
                    throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::SHADOWING_DECL, loc.str ()),
                                           notes-> [ErrorMsg::note (vd.getLoc (), ValidateErrorMessage::FIRST_DEFINED)]
                                       );
                }
            }
            _ => __pragma!panic ();
        }
    }
}
