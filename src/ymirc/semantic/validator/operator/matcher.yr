mod ymirc::semantic::validator::operator::matcher;

import std::io;
import std::collection::vec;

import ymirc::semantic::validator::visitor;
import ymirc::semantic::validator::errors;
import ymirc::errors::_;
import ymirc::utils::format;
import ymirc::semantic::generator::value::_;
import ymirc::syntax::expression::_;
import ymirc::syntax::keys;

import ymirc::lexing::tokens;
import ymirc::lexing::word;


import ymirc::semantic::generator::type::_;

/**
 * The match validator used to validate MatcherExpr
 * It is a class validator because match expression are complex
 */
pub class MatcherValidator {

    /**
     * Create an empty validator
     */
    pub self () {}


    /**
     * Validate a match expression
     * @params: 
     *    - context: the context of the validation
     *    - m: the matcher to validate
     * @returns: a value
     * @throws: 
     *    - &ErrorsMsg: if the validation failed
     */
    pub fn validate (self, dmut context : &Validator, m : &MatcherExpr)-> &Value
        throws &ErrorMsg
    {
        let mValue = context:.getValueValidator ().validate (alias context, m.getContent (), canBeRef-> true);
        let matchers = m.getMatchers ();
        let (conds, values, errors, type, complete) = self.validateMatchers (alias context, m.getLoc (), mValue, matchers);

        if (errors.len != 0us) {
            throw ErrorMsg::fatal (m.getLoc (), format (ValidateErrorMessage::MATCH_VALIDATION, mValue, mValue.getType ()), notes-> errors);
        }

        if (conds.len > 0us) {
            let finType = self.verifyComplete (m.getLoc (), mValue, complete, type, values);
            let mut current : &Value = UNIT_VALUE;
            for i in conds.len .. 0us {
                current = self.createConditional (conds [i - 1us], values [i - 1us], else_-> current, finType, isComplete-> complete);
            }

            match current {
                UnitValue () => { return BlockValue::new (m.getLoc (), VoidType::new (m.getLoc ()), []); }
            }

            return current;
        }

        return BlockValue::new (m.getLoc (), VoidType::new (m.getLoc ()), []);
    }

    /**
     * Validate the list of matchers from the pattern matching
     * @params:
     *    - context: the context of the validation
     *    - value: the value being matched
     *    - matchers: the list of matchers
     * @returns:
     *    - .0: the list of conditions
     *    - .1: the list of validated values if conditions are true
     *    - .2: the list of errors during the validation
     *    - .3: the type result of the matcher (@warning: before checking completness)
     *    - .4: true if the matcher is complete
     * */
    fn validateMatchers (self, dmut context : &Validator, loc : &Word, value : &Value, matchers : [(&Expression, &Expression)])-> ([&Value], [&Value], [&ErrorMsg], &Type, bool) {
        let mut finType : &Type = NoneType::new (loc);
        let mut complete = false;
        let mut currentTautCond : &Value = UNIT_VALUE;

        let dmut conds = Vec!{&Value}::new ();
        let dmut values = Vec!{&Value}::new ();
        let dmut errors = Vec!{&ErrorMsg}::new ();

        for mtch in matchers {
            let mut succeed = true;
            context:.enterBlock ();
            {
                if (complete) {
                    throw ErrorMsg::fatal (mtch.0.getLoc (), ValidateErrorMessage::UNREACHABLE_MATCHER);
                }

                let dmut vars = Vec!{&Value}::new ();
                let cond = self.validateMatcher (alias context, value, mtch.0, alias vars);
                conds:.push (cond);

                let mut val = context:.validateValue (mtch.1);
                let (t, v) = context:.inferTypeBranchingWithValue (finType.getLoc (), finType, val);
                vars:.push (v);

                values:.push (BlockValue::new (mtch.1.getLoc (), v.getType (), vars[]));
                finType = t;

                currentTautCond = match currentTautCond {
                    UnitValue () => { cond }
                    _ => {
                        cast!{&Value} (LogicalBinBoolOperatorValue::new (cond.getLoc (), BinaryOperators::DPIPE, cond, currentTautCond))
                    }
                }

                complete = self.isTautology (alias context, currentTautCond);
            } catch {
                err : &ErrorMsg => {
                    errors:.push (err);
                    succeed = false;
                }
            }

            {
                context:.quitBlock (warnUnused-> succeed);
            } catch {
                err : &ErrorMsg => errors:.push (err);
            }
        }

        (conds[], values[], errors[], finType, complete)
    }



    /**
     * Create a conditional value for a given pattern match
     * @params:
     *    - cond: the condition
     *    - val: the value to evaluate if the condition is true
     *    - else_: the value to evaluate if the condition is false
     * */
    fn createConditional (self, cond : &Value, val : &Value, else_ : &Value, type : &Type, isComplete : bool)-> &Value {
        match cond {
            b : &BoolValue => {
                return if b.isTrue () { val } else { else_ };
            }
        }

        ConditionalValue::new (cond.getLoc (), type, cond, val, elsev-> else_, isComplete-> isComplete)
    }


    /**
     * ================================================================================
     * ================================================================================
     * ==========================         VALIDATION         ==========================
     * ================================================================================
     * ================================================================================
     */


    /**
     * Validate a matcher
     * @params:
     *   - context: the context of the validation
     *   - value: the value to match
     *   - mtch: the matcher expression
     * @returns: the condition to evaluate at runtime
     * */
    fn validateMatcher (self, dmut context : &Validator, value : &Value, mtch : &Expression, dmut vars : &Vec!{&Value})-> &Value
        throws &ErrorMsg
    {
        return match mtch {
            v : &VarDeclExpr => {
                self.validateVarDeclMatcher (alias context, value, v, alias vars)
            }
            o : &OptionMatcherExpr => {
                self.validateOptionMatcher (alias context, value, o, alias vars)
            }
            m : &MultOperatorExpr => {
                self.validateCallOpMatcher (alias context, value, m, alias vars)
            }
            l : &ListExpr => {
                if (l.getLoc () == Tokens::LPAR) {
                    self.validateTupleMatcher (alias context, value, l, alias vars)
                } else {
                    self.validateArrayMatcher (alias context, value, l, alias vars)
                }
            }
            _ => {
                self.validateValueEqualMatcher (alias context, value, mtch)
            }
        };
    }

    /**
     * Validate a var declaration matcher
     * @params:
     *    - context: the context of the validation
     *    - value: the value to match
     *    - vdecl: the variable declaration
     * @returns: the condition to evaluate at runtime
     * */
    fn validateVarDeclMatcher (self, dmut context : &Validator, value : &Value, vdecl : &VarDeclExpr, dmut vars : &Vec!{&Value})-> &Value
        throws &ErrorMsg
    {
        if (vdecl.getLoc () != Keys::UNDER) context:.verifyShadow (vdecl.getLoc ()); // variable declaration, so no shadows are allowed

        let isPure = context.findDecos (vdecl.getDecos (), [Decorators::PURE]);
        let isRef = context.findDecos (vdecl.getDecos (), [Decorators::REF]);
        let isMutable = context.findDecos (vdecl.getDecos (), [Decorators::MUT, Decorators::DMUT]);

        let (typeCond, finalType) = if (!vdecl.getType ().isOf!{&EmptyExpression} ()) { // not '_'
            let (_, t) = context:.validateType (vdecl.getType (), decos-> vdecl.getDecos (), canBeRef-> isRef);
            let type = if (isPure) { t.clone (0u32) } else { t };

            let typeTest = match (value.getType (), type) {
                (ClassPtrType (), inner : &ClassPtrType) => { // a class reverse casting: Base -> Derived can only be known at cte (
                                                              // unless it is a Derived -> Base, but that is already managed by the binary operator validator
                    context:.getBinOpValidator ().validateClassTypeTestOp (alias context, vdecl.getType ().getLoc (), BinaryOperators::OF, value, inner.getInner ())
                }
                _ => { // Any other type test is cte evaluated
                    context.verifyCompatibleType (value.getLoc (), type.getLoc (), value.getType (), type);
                    cast!{&Value} (BoolValue::new (vdecl.getType ().getLoc (), true))
                }
            };

            (typeTest, t)
        } else { // create a type for mutability checking
            let (_, t) = context:.validateType (TypeWrapperExpr::new (value.getLoc (), value.getType ()), decos-> vdecl.getDecos (), canBeRef-> isRef);
            (cast!{&Value} (BoolValue::new (vdecl.getLoc (), true)), t) // type test is always true
        };

        match finalType { // only values with a real type can be used to create a variable
            NoneType () => throw ErrorMsg::fatal (vdecl.getLoc (), format (ValidateErrorMessage::DECLARE_VOID_VAR, finalType));
            VoidType () => throw ErrorMsg::fatal (vdecl.getLoc (), format (ValidateErrorMessage::DECLARE_VOID_VAR, finalType));
            o : &OptionType => {
                if (o.getInners ()[0].isOf!{&NoneType} ()) {
                    throw ErrorMsg::fatal (vdecl.getLoc (), format (ValidateErrorMessage::DECLARE_VOID_VAR, finalType));
                }
            }
        }

        let valueCond = if (!vdecl.getValue ().isOf!{&EmptyExpression} ()) { // not x : T =>
            self.validateMatcher (alias context, value, vdecl.getValue (), alias vars) // inner pattern matching
        } else {
            cast!{&Value} (BoolValue::new (vdecl.getLoc (), true)) // necessarily pass
        };

        // reduce non refrence value
        let mut finVal = if (!isRef) { context:.getCompileTimeInterpreter ().reduce (value) } else { value };
        finVal = if (isRef && !finVal.isOf!{&ReferencerValue} () && !finalType.isMutable () && finVal.isLvalue ()) {
            ReferencerValue::new (finVal.getLoc (), finVal.getType (), finVal, isMutable-> false) // if it is passed by const ref we need to transform the lvalue to an implicit ref lvalue
        } else {
            finVal
        };

        context:.verifyMemoryOwner (vdecl.getLoc (), finalType, finVal, construct-> true, byReference-> isRef);

        if (vdecl.getLoc () != Keys::UNDER) { // if the variable is not '_' we insert it in the current block
            let var = VarDeclValue::new (vdecl.getLoc (), finalType, finVal, isReference-> isRef, isMutable-> isMutable, isPure-> isPure);
            context:.insertLocal (vdecl.getLoc ().str (), var);

            vars:.push (var); // add the declaration in the pattern matching success block
        }

        // test type && test value to be a successful pattern matcher
        LogicalBinBoolOperatorValue::new (vdecl.getLoc (), BinaryOperators::DAND, typeCond, valueCond)
    }

    /**
     * Validate a call operator matcher
     * @params:
     *    - context: the context of the validation
     *    - value: the value to match
     *    - cl: the call operator
     * @returns: the condition to evaluate at runtime
     * */
    fn validateCallOpMatcher (self, dmut context : &Validator, value : &Value, cl : &MultOperatorExpr, dmut vars : &Vec!{&Value})-> &Value
        throws &ErrorMsg
    {
        let validateL = match cl.getLeft () { // don't validate _ ()
            v : &VarExpr => {
                v.getLoc () != Keys::UNDER
            }
            _ => { true }
        };

        let typeCond = if (validateL) {
            let type = context:.validateType (cl.getLeft ());
            let typeTest = match (value.getType (), type) {
                (ClassPtrType (), inner : &ClassPtrType) => { // a class reverse casting: Base -> Derived can only be known at cte (
                                                              // unless it is a Derived -> Base, but that is already managed by the binary operator validator
                    context:.getBinOpValidator ().validateClassTypeTestOp (alias context, type.getLoc (), BinaryOperators::OF, value, inner.getInner ())
                }
                (ClassPtrType (), inner : &ClassRefType) => { // Same as class ptr, but in MultOp a class ref can be used directly (Derived () => ) to match &Base
                    context:.getBinOpValidator ().validateClassTypeTestOp (alias context, type.getLoc (), BinaryOperators::OF, value, inner)
                }
                _ => { // Any other type test is cte evaluated
                    context.verifyCompatibleType (value.getLoc (), type.getLoc (), value.getType (), type);
                    cast!{&Value} (BoolValue::new (type.getLoc (), true))
                }
            };

            typeTest
        } else {
            cast!{&Value} (BoolValue::new (cl.getLeft ().getLoc (), true))
        };

        vars;

        typeCond
    }

    /**
     * Validate an option matcher
     * @params:
     *     - context: the context of the validation
     *     - value: the value being matched
     *     - opt: the option matcher to validate
     *     - vars:
     * */
    fn validateOptionMatcher (self, dmut context : &Validator, value : &Value, opt : &OptionMatcherExpr, dmut vars : &Vec!{&Value})-> &Value
        throws &ErrorMsg
    {
        context;
        value;
        opt;
        vars;
        __pragma!fake_throw (&ErrorMsg);
        __pragma!panic ();
    }

    /**
     * Validate a tuple matcher
     * @params:
     *    - context: the context of the validation
     *    - value: the value to match
     *    - tu: the tuple list
     * @returns: the condition to evaluate at runtime
     * */
    fn validateTupleMatcher (self, dmut context : &Validator, value : &Value, tu : &ListExpr, dmut vars : &Vec!{&Value})-> &Value
        throws &ErrorMsg
    {
        context;
        value;
        tu;
        vars;
        __pragma!fake_throw (&ErrorMsg);
        __pragma!panic ();
    }

    /**
     * Validate an array matcher
     * @params:
     *    - context: the context of the validation
     *    - value: the value to match
     *    - arr: the array list
     * @returns: the condition to evaluate at runtime
     * */
    fn validateArrayMatcher (self, dmut context : &Validator, value : &Value, arr : &ListExpr, dmut vars : &Vec!{&Value})-> &Value
        throws &ErrorMsg
    {
        context;
        value;
        arr;
        vars;
        __pragma!fake_throw (&ErrorMsg);
        __pragma!panic ();
    }

    /**
     * Validate a matcher using a value
     * @info: from there, no variable can be created anymore just value equality
     * @params:
     *    - context: the context of the validation
     *    - value: the value to match
     *    - mtch: the matcher value
     * @returns: the condition to evaluate at runtime
     * */
    fn validateValueEqualMatcher (self, dmut context : &Validator, value : &Value, mtch : &Expression)-> &Value
        throws &ErrorMsg
    {
        match mtch {
            b : &BinaryExpr => {
                if b.getLoc () == BinaryOperators::PIPE {
                    let left = self.validateValueEqualMatcher (alias context, value, b.getLeft ());
                    let right = self.validateValueEqualMatcher (alias context, value, b.getRight ());

                    return LogicalBinBoolOperatorValue::new (mtch.getLoc (), BinaryOperators::DPIPE, left, right);
                }
            }
            t : &VarExpr => {
                if (t.getLoc () == Keys::UNDER) return BoolValue::new (mtch.getLoc (), true);
            }
        }

        let eqVal = context:.validateValue (mtch);
        context:.getBinOpValidator ().validateComparisonOperation (alias context, mtch.getLoc (), BinaryOperators::DEQUAL, value, eqVal)
    }


    /**
     * ================================================================================
     * ================================================================================
     * =========================         VERIFICATION         =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * @returns: true if the list condition is a tautology
     * */
    fn isTautology (self, dmut context : &Validator, cond : &Value)-> bool
        throws &ErrorMsg
    {
        let red = context.getCompileTimeInterpreter ().reduce (cond);
        match red {
            b : &BoolValue => return b.isTrue ();
        }

        false
    }

    /**
     * Verify that the match is complete
     * If it is note, then branch values must be void
     * @returns: the final type of the match
     * @throws:
     *    - &ErrorMsg: if the match is not complete, but branch values are not void
     * */
    fn verifyComplete (self, loc : &Word, value : &Value, complete : bool, type : &Type, values : [&Value])-> &Type
        throws &ErrorMsg
    {
        let retType = if (!complete) { cast!{&Type} (VoidType::new (loc)) } else { type };

        if (!complete) {
            let dmut errors = Vec!{&ErrorMsg}::new ();
            for i in values {
                if (!i.getType ().isOf!{&VoidType} ()) {
                    errors:.push (ErrorMsg::fatal (i.getLoc (), format (ValidateErrorMessage::MATCH_NOT_COMPLETE, i.getType ())));
                }
            }

            if (errors.len () != 0us) {
                throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::MATCH_VALIDATION, value, value.getType ()), notes-> errors []);
            }
        }

        retType
    }

}
