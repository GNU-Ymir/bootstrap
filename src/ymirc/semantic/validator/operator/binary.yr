mod ymirc::semantic::validator::operator::binary;

import ymirc::semantic::validator::visitor;
import ymirc::semantic::validator::errors;
import ymirc::semantic::declarator::errors;
import ymirc::errors::_;
import ymirc::utils::format;
import ymirc::utils::bigint;
import ymirc::utils::bigfloat;
import ymirc::utils::math;
import ymirc::syntax::expression::operator::binary;
import ymirc::syntax::declaration::protection;
import ymirc::global::core_;


import ymirc::semantic::symbol::_;
import ymirc::semantic::generator::_;

import ymirc::lexing::word;
import ymirc::lexing::tokens;
import ymirc::syntax::keys;
import ymirc::syntax::expression::_;

import std::algorithm::comparison;
import std::collection::vec;
import std::io;

pub enum 
| MATH = 1u32
| BITWISE = 2u32
| LOGICAL = 3u32
| COMPARISON = 4u32
| RANGE = 5u32
| POINTER = 6u32
| SET = 7u32
| TYPE = 8u32
| FIELD = 9u32
| MODULE = 10u32
| FLOAT_COMPARISON = 11u32
| NONE = 12u32
 -> OperatorType;

/**
 * The binary validator is used to validate BinaryOpExpr
 * It is a class validator because binary operation are complex
 */
pub class BinaryOpValidator {

    /**
     * Create an empty validator     
     */
    pub self () {}

    /**
     * Validate a binary expression that must return a value (some operation can return a type, i.e. '::' on some types)
     * @params: 
     *  - context: the context of the validation
     *  - bin: the binary operator to validate
     * @returns: a value
     * @throws: 
     *    - &ErrorMsg, if the validation failed
     */
    pub fn validateValue (self, dmut context : &Validator, bin : &BinaryExpr) -> &Value
        throws &ErrorMsg
    {
        let (op, isAff, type) = self.toOperator (bin.getLoc ());
        
        match (type, isAff) {
            (OperatorType::MATH, false) => { 
                return self.validateMathOperation (alias context, op, bin);
            }
            (OperatorType::BITWISE, false) => { // |, &, ^, <<, >>, applicable only on ints
                return self.validateBitwiseOperation (alias context, op, bin);
            }
            (OperatorType::COMPARISON, false) => { // all comparison operators, <=, >=, >, etc.., cannot be an affectation
                return self.validateComparisonOperation (alias context, op, bin);
            }
            (OperatorType::FLOAT_COMPARISON, false) => {
                return self.validateFloatComparisonOperation (alias context, op, bin);
            }
            (OperatorType::LOGICAL, false) => { // all boolean operators, cannot be an affectation
                return self.validateLogicalOperation (alias context, op, bin);
            }
            (OperatorType::RANGE, false) => { // .. and ..., cannot be an affectation
                return self.validateRangeOperation (alias context, op, bin);
            }
            (OperatorType::POINTER, false) => { // is and !is, cannot be an affectation
                return self.validatePointerOperation (alias context, op, bin);
            }
            (OperatorType::SET, false) => { // ~, in, and !in, might be an affectation for ~
                return self.validateSetOperation (alias context, op, bin);
            }
            (OperatorType::TYPE, false) => { // of and !of, cannot be an affectation
                return self.validateTypeOperation (alias context, op, bin);
            }
            (OperatorType::FIELD, false) => { // . and :., cannot be an affectation
                return self.validateFieldOperation (alias context, op, bin);
            }
            (OperatorType::MODULE, false) => { // ::, cannot be an affectation                
                return self.validateModuleOperation (alias context, op, bin);
            }
            (_, true) => { // =, +=, -=, ~=, etc., affectation operators
                return self.validateAffectOperation (alias context, op, bin);
            }
            _ => { // All case should be handled.                
                __pragma!panic ();
            }
        }
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================             MATH             =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a binary operation involving math operator
     * @params: 
     *   - context: the context of the validation
     *   - op: the operator (assuming it's a math operator)
     *   - bin: the binary expression to validate
     * @returns: the validated value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    fn validateMathOperation (self, dmut context : &Validator, op : BinaryOperators, bin : &BinaryExpr)-> &Value
        throws &ErrorMsg
    {
        let left = context:.implicitEnumUnwrap (context:.validateValue (bin.getLeft ()));
        let right = context:.implicitEnumUnwrap (context:.validateValue (bin.getRight ()));
        
        let dmut errors = Vec!{&ErrorMsg}::new ();        
        {
            match left.getType () { // First we try the operation as a left side operation (asking for left operand to be the master of the operation, i.e. left.opBinary!{op} (right)
                IntType () => return self.validateIntMathOp (alias context, bin.getLoc (), op, left, right);
                CharType () => return self.validateCharMathOp (alias context, bin.getLoc (), op, left, right);
                FloatType () => return self.validateFloatMathOp (alias context, bin.getLoc (), op, left, right);
                PointerType () => return self.validatePointerMathOp (alias context, bin.getLoc (), op, left, right);
                StructType () => return self.validateStructOpLeft (alias context, bin.getLoc (), op, left, right);
                ClassPtrType () => return self.validateClassOpLeft (alias context, bin.getLoc (), op, left, right);
            };
            
            errors:.push (ErrorMsg::fatal (bin.getLoc (), format (ValidateErrorMessage::UNDEFINED_BIN_OP, op, left.getType (), right.getType ())));
        } catch {
            err : &ErrorMsg => { errors:.push (err); }
        } 

        { // if we are here the validation as a left operand validation failed, so we need to try it as a right operation (right.opBinaryRight!{op} (left))
            match right.getType () { // it is working only for two kind of type structs and classes
                StructType () => return self.validateStructOpRight (alias context, bin.getLoc (), op, left, right);
                ClassPtrType () => return self.validateClassOpRight (alias context, bin.getLoc (), op, left, right);
            } // We can quit without testing the other types, there is already an error in the errors vec
        } catch {
            err : &ErrorMsg => { errors:.push (err); } // No we still fail
        }

        throw ErrorMsg::list (errors[]); // there is no valid math operation for left and right
    }


    /**
     * Validate a math operation where the left operand is a int type operand
     * @params: 
     *   - context: the context of the validation
     *   - op: the operator
     *   - left: the left operand (assumed of type int)
     *   - right: the right operand
     * @returns: The result value
     * @throws: 
     *   - &ErrorMsg: if the operation is not valid
     */
    fn validateIntMathOp (self, dmut context : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Value)-> &Value
        throws &ErrorMsg
    {
        match left.getType () {
            li : &IntType => {            
                match right.getType () {
                    ri : &IntType => {
                        if (op == BinaryOperators::DXOR) {
                            return self.validateIntOrFloatPowerOp (alias context, loc, left, right);
                        }

                        if (li.isSigned () == ri.isSigned () && li.getSize () == ri.getSize ()) {
                            let type = IntType::new (loc, signed-> li.isSigned (), size-> li.getSize ());
                            return BinaryMathIntOperatorValue::new (loc, type, op, left, right);
                        }

                        {
                            let compatibleRight = context:.verifyCompatibleTypeWithValue (loc, li, right, byReference-> false);
                            let type = IntType::new (loc, signed-> li.isSigned (), size-> li.getSize ());
                            return BinaryMathIntOperatorValue::new (loc, type, op, left, compatibleRight);
                        } catch {
                            leErr : &ErrorMsg => {
                                let compatibleLeft = context:.verifyCompatibleTypeWithValue (loc, ri, left, byReference-> false);
                                let type = IntType::new (loc, signed-> ri.isSigned (), size-> ri.getSize ());
                                return BinaryMathIntOperatorValue::new (loc, type, op, compatibleLeft, right);
                            } catch {
                                riErr : &ErrorMsg => {
                                    throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_BIN_OP, op, li, ri), notes-> [leErr, riErr]);
                                }
                            }
                        }
                    }
                    rc : &CharType => { // char values as right operands, 12u8 + 'a'c8 == 'm'c8
                        if (!li.isSigned () && rc.getSize () == li.getSize ()) {
                            let type = CharType::new (loc, size-> rc.getSize ());
                            let l = context:.getCastValidator ().validateCast (alias context, left, type);
                            return BinaryMathCharOperatorValue::new (loc, type, op, l, right);
                        }
                    }
                }                
            }
            _ => __pragma!panic ()
        }

        throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_BIN_OP, op, left.getType (), right.getType ()));
    }   

    /**
     * Validate the power operation
     * @info: This operation is not performed by the language itself (hardware) but by a core function (core::math::pow)
     * @example:
     * ====================
     * 12 ^^ 98
     * // rewritten into => 'core::math::iipow!{typeof(12)} (12, 98)-> typeof (12)
     * 12.f ^^ 0.5f
     * // rewritten into => 'core::math::ffpow!{typeof(12.f)} (12.0f, 0.5f)-> typeof (12.0f)
     * ====================
     * @params:
     *   - context: the context of the validation
     *   - op: the operator
     *   - left: the left operand (assumed of type int)
     *   - right: the right operand
     * @returns: The result value
     * @throws: 
     *   - &ErrorMsg: if the operation is not valid
     */
    fn validateIntOrFloatPowerOp (self, dmut context : &Validator, loc : &Word, left : &Value, right : &Value)-> &Value
        throws &ErrorMsg
    {
        let leftSynt = ValueWrapperExpr::new (left.getLoc (), left);
        let rightSynt = ValueWrapperExpr::new (right.getLoc (), right);

        let funcName = if (left.getType ().isOf!{&IntType} ()) {
            CoreNames::IPOW_FUNCTION
        } else if (right.getType ().isOf!{&IntType} ()) {
            CoreNames::FIPOW_FUNCTION
        } else { CoreNames::FFPOW_FUNCTION };

        // Create a var path to the core function core::math::pow
        let syntVar = context.createSyntaxVarFromPath (loc, [CoreNames::CORE_MODULE, CoreNames::MATH_MODULE, funcName]);

        // Create the syntax call of the function => core::math::pow (left, right)
        let syntCall = MultOperatorExpr::new (Word::new (Tokens::LPAR, loc), Word::new (Tokens::RPAR, loc),
                                              syntVar,
                                              [leftSynt, rightSynt], canBeDotCall-> false);

        {
            // Validate the final rewritten value
            let ret = context:.validateValue (syntCall);
            match ret.getType () {
                IntType () => { return SpecialMathIntOperatorValue::new (loc, ret.getType (), BinaryOperators::DXOR, left, right, ret); }
                FloatType () => {  return SpecialMathFloatOperatorValue::new (loc, ret.getType (), BinaryOperators::DXOR, left, right, ret); }
                _ => __pragma!panic ();
            }
        } catch {
            err : &ErrorMsg => {
                throw ErrorMsg::note (loc, ValidateErrorMessage::VALIDATING, notes-> [err]);
            }
        }
    }

    /**
     * Validate the fmod operation
     * @info: this operation is not performed by the language itself (hardware) but by a core function (core::math::fmod)
     * @example:
     * ====================
     * 12.f % 0.5f
     * // rewritten into => 'core::math::ffmod!{typeof(12.f)} (12.0f, 0.5f)-> typeof (12.0f)
     * ====================
     * */
    fn validateFloatModOp (self, dmut context : &Validator, loc : &Word, left : &Value, right : &Value)-> &Value
        throws &ErrorMsg
    {
        let leftSynt = ValueWrapperExpr::new (left.getLoc (), left);
        let rightSynt = ValueWrapperExpr::new (right.getLoc (), right);

        // Create a var path to the core function core::math::pow
        let syntVar = context.createSyntaxVarFromPath (loc, [CoreNames::CORE_MODULE, CoreNames::MATH_MODULE, CoreNames::FFMOD_FUNCTION]);

        // Create the syntax call of the function => core::math::pow (left, right)
        let syntCall = MultOperatorExpr::new (Word::new (Tokens::LPAR, loc), Word::new (Tokens::RPAR, loc),
                                              syntVar,
                                              [leftSynt, rightSynt], canBeDotCall-> false);

        {
            // Validate the final rewritten value
            let ret = context:.validateValue (syntCall);
            match ret.getType () {
                FloatType () => {  return SpecialMathFloatOperatorValue::new (loc, ret.getType (), BinaryOperators::PERCENT, left, right, ret); }
                _ => __pragma!panic ();
            }
        } catch {
            err : &ErrorMsg => {
                throw ErrorMsg::note (loc, ValidateErrorMessage::VALIDATING, notes-> [err]);
            }
        }

    }

    /**
     * Validate a math operation where the left operand is a char type operand
     * @params: 
     *   - _: the context of the validation
     *   - op: the operator
     *   - left: the left operand (assumed of type char)
     *   - right: the right operand
     * @returns: The result value
     * @throws: 
     *   - &ErrorMsg: if the operation is not valid
     */
    fn validateCharMathOp (self, dmut context : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Value)-> &Value
        throws &ErrorMsg
    {
        if (op != BinaryOperators::PLUS && op != BinaryOperators::MINUS) {
            throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_BIN_OP, op, left.getType (), right.getType ()));
        }
        
        match left.getType () {
            lc : &CharType => {
                match right.getType () {
                    ri : &IntType => { // only int values can be added, substracted to char values
                        if (!ri.isSigned () && ri.getSize () == lc.getSize ()) {
                            let type = CharType::new (loc, size-> lc.getSize ());
                            let r = context:.getCastValidator ().validateCast (alias context, right, type);
                            return BinaryMathCharOperatorValue::new (loc, type, op, left, r);
                        }
                    }
                }
            }
            _ => __pragma!panic ();   
        }

        throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_BIN_OP, op, left.getType (), right.getType ()));             
    }


    /**
     * Validate a math operation where the left operand is a float type operand
     * @params: 
     *   - context: the context of the validation
     *   - op: the operator
     *   - left: the left operand (assumed of type float)
     *   - right: the right operand
     * @returns: The result value
     * @throws: 
     *   - &ErrorMsg: if the operation is not valid
     */
    fn validateFloatMathOp (self, dmut context : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Value)-> &Value
        throws &ErrorMsg
    {        
        match left.getType () {
            lf : &FloatType => {
                match right.getType () {
                    _ : &IntType => {
                        if (op == BinaryOperators::DXOR) {
                            return self.validateIntOrFloatPowerOp (alias context, loc, left, right);
                        }
                    }
                    rf : &FloatType => {
                        if (op == BinaryOperators::DXOR) {
                            return self.validateIntOrFloatPowerOp (alias context, loc, left, right);
                        } else if (op == BinaryOperators::PERCENT) {
                            return self.validateFloatModOp (alias context, loc, left, right);
                        }

                        if (lf.getSize () == rf.getSize ()) {
                            let type = FloatType::new (loc, size-> lf.getSize ());
                            return BinaryMathFloatOperatorValue::new (loc, type, op, left, right);
                        }

                        {
                            let compatibleRight = context:.verifyCompatibleTypeWithValue (loc, lf, right, byReference-> false);
                            let type = FloatType::new (loc, size-> lf.getSize ());
                            return BinaryMathFloatOperatorValue::new (loc, type, op, left, compatibleRight);
                        } catch {
                            leErr : &ErrorMsg => {
                                let compatibleLeft = context:.verifyCompatibleTypeWithValue (loc, rf, left, byReference-> false);
                                let type = FloatType::new (loc, size-> rf.getSize ());
                                return BinaryMathFloatOperatorValue::new (loc, type, op, compatibleLeft, right);
                            } catch {
                                riErr : &ErrorMsg => {
                                    throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_BIN_OP, op, lf, rf), notes-> [leErr, riErr]);
                                }
                            }
                        }

                    }
                }
            }
            _ => __pragma!panic ();   
        }

        throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_BIN_OP, op, left.getType (), right.getType ()));
    }

    /**
     * Validate a math operation where the left operand is a pointer type operand
     * @params: 
     *   - _: the context of the validation
     *   - op: the operator
     *   - left: the left operand (assumed of type pointer)
     *   - right: the right operand
     * @returns: The result value
     * @throws: 
     *   - &ErrorMsg: if the operation is not valid
     */
    fn validatePointerMathOp (self, dmut _ : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Value)-> &Value
        throws &ErrorMsg
    {
        if (op != BinaryOperators::PLUS && op != BinaryOperators::MINUS) {
            throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_BIN_OP, op, left.getType (), right.getType ()));
        }
        
        match left.getType () {
            lp : &PointerType => {
                match right.getType () {
                    ri : &IntType => {
                        if (!ri.isSigned () && ri.getSize () == 0us) {
                            return BinaryMathPointerOperatorValue::new (loc, lp, op, left, right);
                        }
                    }
                    rp : &PointerType => {
                        if (rp.getInners ()[0] == lp.getInners ()[0] || rp.getInners ()[0].isOf!{&VoidType} ()) {
                            return BinaryMathPointerOperatorValue::new (loc, lp, op, left, right);
                        }
                    }
                }
            }
            _ => __pragma!panic ();
        }
        
        throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_BIN_OP, op, left.getType (), right.getType ()));
    }


    /*!
     * ================================================================================
     * ================================================================================
     * =========================           BITWISE            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a binary operation involving bitwise operators (|, &, <<, etc.)
     * @params: 
     *   - context: the context of the validation
     *   - op: the operator (assuming it's a logical operator)
     *   - bin: the binary expression to validate
     * @returns: the validated value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    fn validateBitwiseOperation (self, dmut context : &Validator, op : BinaryOperators, bin : &BinaryExpr)-> &Value
        throws &ErrorMsg
    {
        let left = context:.implicitEnumUnwrap (context:.validateValue (bin.getLeft ()));
        let right = context:.implicitEnumUnwrap (context:.validateValue (bin.getRight ()));

        let dmut errors = Vec!{&ErrorMsg}::new ();
        {
            // First we try the operation as a left side operation (asking for left operand to be the master of the operation, i.e. left.opBinary!{op} (right)
            match left.getType () { 
                IntType () => return self.validateIntBitwiseOp (alias context, bin.getLoc (), op, left, right);
                StructType () => return self.validateStructOpLeft (alias context, bin.getLoc (), op, left, right);
                ClassPtrType () => return self.validateClassOpLeft (alias context, bin.getLoc (), op, left, right);
            };
            
            errors:.push (ErrorMsg::fatal (bin.getLoc (), format (ValidateErrorMessage::UNDEFINED_BIN_OP, op, left.getType (), right.getType ())));
        } catch {
            err : &ErrorMsg => { errors:.push (err); }
        }

        { // if we are here the validation as a left operand validation failed, so we need to try it as a right operation (right.opBinaryRight!{op} (left))
            match right.getType () { // it is working only for two kind of type structs and classes
                StructType () => return self.validateStructOpRight (alias context, bin.getLoc (), op, left, right);
                ClassPtrType () => return self.validateClassOpRight (alias context, bin.getLoc (), op, left, right);
            } // We can quit without testing the other types, there is already an error in the errors vec
        } catch {
            err : &ErrorMsg => { errors:.push (err); } // No we still fail
        }

        throw ErrorMsg::list (errors[]); // there is no valid math operation for left and right        
    }

    /**
     * Validate a binary operation involving bitwise operators, and assuming that left operand is a int typed value
     * @params: 
     *   - context: the context of the validation
     *   - loc: the location of the operation
     *   - op: the operator
     *   - left: the left operand of the operation (assumed to be a int typed value)
     *   - right: the right operand of the operation
     * @returns: the result value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    fn validateIntBitwiseOp (self, dmut context : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Value)-> &Value
        throws &ErrorMsg
    {
        match left.getType () {
            li : &IntType => {
                match right.getType () {
                    ri : &IntType => {
                        if (li.isSigned () == ri.isSigned () && li.getSize () == ri.getSize ()) {
                            let type = IntType::new (loc, signed-> li.isSigned (), size-> li.getSize ());
                            return BitwiseIntOperatorValue::new (loc, type, op, left, right);
                        }

                        {
                            let compatibleRight = context:.verifyCompatibleTypeWithValue (loc, li, right, byReference-> false);
                            let type = IntType::new (loc, signed-> li.isSigned (), size-> li.getSize ());
                            return BitwiseIntOperatorValue::new (loc, type, op, left, compatibleRight);
                        } catch {
                            leErr : &ErrorMsg => {
                                let compatibleLeft = context:.verifyCompatibleTypeWithValue (loc, ri, left, byReference-> false);
                                let type = IntType::new (loc, signed-> ri.isSigned (), size-> ri.getSize ());
                                return BitwiseIntOperatorValue::new (loc, type, op, compatibleLeft, right);
                            } catch {
                                riErr : &ErrorMsg => {
                                    throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_BIN_OP, op, li, ri), notes-> [leErr, riErr]);
                                }
                            }
                        }
                    }
                }               
            }
            _ => __pragma!panic ();
        }

        throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_BIN_OP, op, left.getType (), right.getType ()));                       
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================          COMPARISON          =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a binary operation involving comparison operators (<=, >=, <, >, ==, etc..)
     * @params:
     *   - context: the context of the validation
     *   - op: the operator (assuming it's a logical operator)
     *   - bin: the binary expression to validate
     * @returns: the validated value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    fn validateComparisonOperation (self, dmut context : &Validator, op : BinaryOperators, bin : &BinaryExpr)-> &Value
        throws &ErrorMsg
    {
        let left = context:.implicitEnumUnwrap (context:.validateValue (bin.getLeft ()));
        let right = context:.implicitEnumUnwrap (context:.validateValue (bin.getRight ()));

        self.validateComparisonOperation (alias context, bin.getLoc (), op, left, right)
    }

    /**
     * Validate a binary operation involving comparison operators (<=, >=, <, >, ==, etc..)
     * @params:
     *   - context: the context of the validation
     *   - op: the operator (assuming it's a logical operator)
     *   - left: the left operand
     *   - right: the right operand
     * @returns: the validated value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    pub fn validateComparisonOperation (self, dmut context : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Value)-> &Value
        throws &ErrorMsg
    {
        let dmut errors = Vec!{&ErrorMsg}::new ();
        {
            // First we try the operation as a left side operation (asking for left operand to be the master of the operation, i.e. left.opBinary!{op} (right)
            match left.getType () {
                IntType () => return self.validateIntCmpOp (alias context, loc, op, left, right);
                FloatType () => return self.validateFloatCmpOp (alias context, loc, op, left, right);
                CharType () => return self.validateCharCmpOp (alias context, loc, op, left, right);
                BoolType () => return self.validateBoolCmpOp (alias context, loc, op, left, right);
                PointerType () => return self.validatePointerCmpOp (alias context, loc, op, left, right);
                ArrayType () => return self.validateSliceOrArrayCmpOp (alias context, loc, op, left, right);
                SliceType () => return self.validateSliceOrArrayCmpOp (alias context, loc, op, left, right);
                TupleType () => return self.validateTupleCmpOp (alias context, loc, op, left, right);
                RangeType () => return self.validateRangeCmpOp (alias context, loc, op, left, right);
                StructType () => return self.validateStructCmpOpLeft (alias context, loc, op, left, right);
                ClassPtrType () => return self.validateClassCmpOpLeft (alias context, loc, op, left, right);
                OptionType () => return self.validateOptionCmpOp (alias context, loc, op, left, right);
            };

            errors:.push (ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_BIN_OP, op, left.getType (), right.getType ())));
        } catch {
            err : &ErrorMsg => { errors:.push (err); }
        }

        { // if we are here the validation as a left operand validation failed, so we need to try it as a right operation (right.opBinaryRight!{op} (left))
            match right.getType () { // it is working only for two kind of type structs and classes
                StructType () => return self.validateStructCmpOpRight (alias context, loc, op, left, right);
                ClassPtrType () => return self.validateClassCmpOpRight (alias context, loc, op, left, right);
            } // We can quit without testing the other types, there is already an error in the errors vec
        } catch {
            err : &ErrorMsg => { errors:.push (err); } // No we still fail
        }

        throw ErrorMsg::list (errors[]); // there is no valid math operation for left and right

    }

    /**
     * Validate a binary operation involving float comparison operators (<=>, <!>)
     * @params:
     *   - context: the context of the validation
     *   - op: the operator (assuming it's a logical operator)
     *   - bin: the binary expression to validate
     * @returns: the validated value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    fn validateFloatComparisonOperation (self, dmut context : &Validator, op : BinaryOperators, bin : &BinaryExpr)-> &Value
        throws &ErrorMsg
    {
        let left = context:.implicitEnumUnwrap (context:.validateValue (bin.getLeft ()));
        let right = context:.implicitEnumUnwrap (context:.validateValue (bin.getRight ()));

        let dmut errors = Vec!{&ErrorMsg}::new ();
        {
            // First we try the operation as a left side operation (asking for left operand to be the master of the operation, i.e. left.opBinary!{op} (right)
            match left.getType () {
                FloatType () => return self.validateFloatSpecialCmpOp (alias context, bin.getLoc (), op, left, right);
            };

            errors:.push (ErrorMsg::fatal (bin.getLoc (), format (ValidateErrorMessage::UNDEFINED_BIN_OP, op, left.getType (), right.getType ())));
        } catch {
            err : &ErrorMsg => { errors:.push (err); }
        }

        throw ErrorMsg::list (errors[]); // there is no valid math operation for left and right
    }

    /**
     * Validate a binary comparison operator, assuming that the left operand is a int
     * @params: 
     *   - context: the context of the operator
     *   - loc: the location of the operator
     *   - left: the left operand (assume to be a int typed value)
     *   - right: the right operand
     * @returns: the result value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    fn validateIntCmpOp (self, dmut context : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Value)-> &Value
        throws &ErrorMsg
    {
        match left.getType () {
            li : &IntType => {
                match right.getType () {
                    ri : &IntType => {
                        if (li.isSigned () == ri.isSigned ()) {
                            return CmpIntOperatorValue::new (loc, op, left, right);
                        }

                        {
                            let compatibleRight = context:.verifyCompatibleTypeWithValue (loc, li, right, byReference-> false);
                            return CmpIntOperatorValue::new (loc, op, left, compatibleRight);
                        } catch {
                            leErr : &ErrorMsg => {
                                let compatibleLeft = context:.verifyCompatibleTypeWithValue (loc, ri, left, byReference-> false);
                                return CmpIntOperatorValue::new (loc, op, compatibleLeft, right);
                            } catch {
                                riErr : &ErrorMsg => {
                                    throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_BIN_OP, op, li, ri), notes-> [leErr, riErr]);
                                }
                            }
                        }
                    }
                }
            }
            _ => __pragma!panic ();
        }
        
        throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_BIN_OP, op, left.getType (), right.getType ()));
    }

    /**
     * Validate a binary comparison operator, assuming left is an option value
     * @params:
     *    - context: the context of the operator
     *    - loc: the location of the operator
     *    - left: the left operand (assuming to be a option typed value)
     *    - right: the right operand
     * @returns: the result value
     * @throws:
     *    - &ErrorMsg: if the operation is not valid
     * */
    fn validateOptionCmpOp (self, dmut context : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Value)-> &Value
        throws &ErrorMsg
    {
        let (lVal, rVal) = if (left.getType ().asOf!{&OptionType} ().getInners ()[0].isOf!{&NoneType} ()) {
            (context:.verifyCompatibleTypeWithValue (loc, right.getType (), left, byReference-> false), right)
        } else { (left, context:.verifyCompatibleTypeWithValue (loc, left.getType (), right, byReference-> false)) };

        let innerLType = lVal.getType ().asOf!{&OptionType} ().getInners ()[0];
        let innerRType = rVal.getType ().asOf!{&OptionType} ().getInners ()[0];

        if (innerRType.isOf!{&NoneType} () && innerLType.isOf!{&NoneType} ()) {
            return CmpIntOperatorValue::new (loc, op, makeIntValue (loc, 0is), makeIntValue (loc, 0is)); // none op none
        }

        let boolType = BoolType::new (loc);
        let lSet = StructFieldAccessValue::new (loc, boolType, lVal, OptionKeys::SET);
        let rSet = StructFieldAccessValue::new (loc, boolType, rVal, OptionKeys::SET);

        let lInnerVal = OptionFieldAccessValue::new (loc, innerLType, lVal, OptionKeys::VALUE);
        let rInnerVal = OptionFieldAccessValue::new (loc, innerRType, rVal, OptionKeys::VALUE);

        let bothSet = LogicalBinBoolOperatorValue::new (loc, BinaryOperators::DAND, lSet, rSet);
        let bothSetRes = self.validateComparisonOperation (alias context, loc, op, lInnerVal, rInnerVal);

        let onlyRightSetRes = CmpIntOperatorValue::new (loc, op, makeIntValue (loc, -1is), makeIntValue (loc, 0is));
        let onlyLeftSetRes = CmpIntOperatorValue::new (loc, op, makeIntValue (loc, 1is), makeIntValue (loc, 0is));
        let noneSetRes = CmpIntOperatorValue::new (loc, op, makeIntValue (loc, 0is), makeIntValue (loc, 0is));

        let finalCond = ConditionalValue::new (loc, boolType, lSet, onlyLeftSetRes, noneSetRes);
        let preCond = ConditionalValue::new (loc, boolType, rSet, onlyRightSetRes, finalCond);

        context.getCompileTimeInterpreter ().reduce (ConditionalValue::new (loc, boolType, bothSet, bothSetRes, preCond))
    }

    /**
     * Validate a binary comparison operator, assuming that the left operand is a float
     * @params:
     *   - context: the context of the operator
     *   - loc: the location of the operator
     *   - left: the left operand (assume to be a float typed value)
     *   - right: the right operand
     * @returns: the result value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    fn validateFloatCmpOp (self, dmut context : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Value)-> &Value
        throws &ErrorMsg
    {
        match left.getType () {
            li : &FloatType => {
                match right.getType () {
                    ri : &FloatType => {
                        if (li.getSize () == ri.getSize ()) {
                            return CmpFloatOperatorValue::new (loc, op, left, right);
                        }

                        {
                            let compatibleRight = context:.verifyCompatibleTypeWithValue (loc, li, right, byReference-> false);
                            return CmpFloatOperatorValue::new (loc, op, left, compatibleRight);
                        } catch {
                            leErr : &ErrorMsg => {
                                let compatibleLeft = context:.verifyCompatibleTypeWithValue (loc, ri, left, byReference-> false);
                                return CmpFloatOperatorValue::new (loc, op, compatibleLeft, right);
                            } catch {
                                riErr : &ErrorMsg => {
                                    throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_BIN_OP, op, li, ri), notes-> [leErr, riErr]);
                                }
                            }
                        }
                    }
                }
            }
            _ => __pragma!panic ();
        }

        throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_BIN_OP, op, left.getType (), right.getType ()));
    }


    /**
     * Validate a binary float comparison operator (<=>, <!>), assuming that the left operand is a float
     * @params:
     *   - context: the context of the operator
     *   - loc: the location of the operator
     *   - left: the left operand (assume to be a float typed value)
     *   - right: the right operand
     * @returns: the result value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    fn validateFloatSpecialCmpOp (self, dmut context : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Value)-> &Value
        throws &ErrorMsg
    {
        if (!right.getType ().isOf!{&FloatType} ()) {
            throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_BIN_OP, op, left.getType (), right.getType ()));
        }

        let leftSynt  = ValueWrapperExpr::new (left.getLoc (), left);
        let rightSynt = ValueWrapperExpr::new (right.getLoc (), right);

        // Create a var path to the core function core::math::float_compare
        let syntVar = context.createSyntaxVarFromPath (loc, [CoreNames::CORE_MODULE, CoreNames::MATH_MODULE, CoreNames::FLOAT_CMP]);

        // Create the syntax call of the function to compare two slices => core::array::opCmp (left, right)-> usize
        let mut syntCall : &Expression = MultOperatorExpr::new (Word::new (Tokens::LPAR, loc), Word::new (Tokens::RPAR, loc),
                                                                syntVar,
                                                                [leftSynt, rightSynt], canBeDotCall-> false);

        if (op == BinaryOperators::UNCONGRUENT) {
            syntCall = UnaryExpr::new (Word::new (Tokens::NOT, loc), syntCall);
        }

        {
            context:.validateValue (syntCall)
        } catch {
            err : &ErrorMsg => {
                throw ErrorMsg::note (loc, ValidateErrorMessage::VALIDATING, notes-> [err]);
            }
        }
    }


    /**
     * Validate a binary comparison operator, assuming that the left operand is a char
     * @params: 
     *   - context: the context of the operator
     *   - loc: the location of the operator
     *   - left: the left operand (assume to be a char typed value)
     *   - right: the right operand
     * @returns: the result value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    fn validateCharCmpOp (self, dmut context : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Value)-> &Value
        throws &ErrorMsg
    {
        match left.getType () {
            li : &CharType => {
                match right.getType () {
                    ri : &CharType => {
                        if (li.getSize () == ri.getSize ()) {
                            return CmpCharOperatorValue::new (loc, op, left, right);
                        }

                        {
                            let compatibleRight = context:.verifyCompatibleTypeWithValue (loc, li, right, byReference-> false);
                            return CmpCharOperatorValue::new (loc, op, left, compatibleRight);
                        } catch {
                            leErr : &ErrorMsg => {
                                let compatibleLeft = context:.verifyCompatibleTypeWithValue (loc, ri, left, byReference-> false);
                                return CmpCharOperatorValue::new (loc, op, compatibleLeft, right);
                            } catch {
                                riErr : &ErrorMsg => {
                                    throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_BIN_OP, op, li, ri), notes-> [leErr, riErr]);
                                }
                            }
                        }
                    }
                }
            }
            _ => __pragma!panic ();
        }
        
        throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_BIN_OP, op, left.getType (), right.getType ()));
    }


    /**
     * Validate a binary comparison operator, assuming that the left operand is a bool
     * @params:
     *   - context: the context of the operator
     *   - loc: the location of the operator
     *   - left: the left operand (assume to be a bool typed value)
     *   - right: the right operand
     * @returns: the result value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    fn validateBoolCmpOp (self, dmut _ : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Value)-> &Value
        throws &ErrorMsg
    {
        if (op == BinaryOperators::DEQUAL || op == BinaryOperators::NOT_EQUAL) {
            match left.getType () {
                BoolType () => {
                    match right.getType () {
                        BoolType () => {
                            return CmpBoolOperatorValue::new (loc, op, left, right);
                        }
                    }
                }
                _ => __pragma!panic ();
            }

        }
        throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_BIN_OP, op, left.getType (), right.getType ()));
    }

    /**
     * Validate a binary comparison operator, assuming that the left operand is a pointer type
     * @params:
     *   - context: the context of the operator
     *   - loc: the location of the operator
     *   - left: the left operand (assume to be a pointer type value)
     *   - right: the right operand
     * @returns: the result value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    fn validatePointerCmpOp (self, dmut context : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Value)-> &Value
        throws &ErrorMsg
    {
        match left.getType () {
            li : &PointerType => {
                match right.getType () {
                    ri : &PointerType => {
                        if (li == ri) {
                            return CmpPointerOperatorValue::new (loc, op, left, right);
                        }

                        {
                            let compatibleRight = context:.verifyCompatibleTypeWithValue (loc, li, right, byReference-> false);
                            return CmpPointerOperatorValue::new (loc, op, left, compatibleRight);
                        } catch {
                            leErr : &ErrorMsg => {
                                let compatibleLeft = context:.verifyCompatibleTypeWithValue (loc, ri, left, byReference-> false);
                                return CmpPointerOperatorValue::new (loc, op, compatibleLeft, right);
                            } catch {
                                riErr : &ErrorMsg => {
                                    throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_BIN_OP, op, li, ri), notes-> [leErr, riErr]);
                                }
                            }
                        }
                    }
                }
            }
            _ => __pragma!panic ();
        }

        throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_BIN_OP, op, left.getType (), right.getType ()));
    }

    /**
     * Validate a binary comparison operator, assuming that the left operand is a tuple type
     * @params:
     *   - context: the context of the operator
     *   - loc: the location of the operator
     *   - left: the left operand (assume to be a tuple type value)
     *   - right: the right operand
     * @returns: the result value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     * */
    fn validateTupleCmpOp (self, dmut context : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Value)-> &Value
        throws &ErrorMsg
    {
        match (left.getType (), right.getType ()) {
            (l : &TupleType, r : &TupleType) => {
                if (l.getInners ().len == r.getInners ().len) {
                    {
                        let mut res : &Value = UNIT_VALUE;
                        for i in l.getInners ().len .. 0us {
                            let fieldL = self.createTupleFieldAccess (loc, l.getInners ()[i - 1us], left, i - 1us);
                            let fieldR = self.createTupleFieldAccess (loc, l.getInners ()[i - 1us], right, i - 1us);

                            let cmp = self.validateComparisonOperation (alias context, loc, op, fieldL, fieldR);
                            res = match res {
                                UnitValue () => {
                                    cmp
                                }
                                old : _ => {
                                    cast!{&Value} (if (op == BinaryOperators::DEQUAL) {
                                        LogicalBinBoolOperatorValue::new (loc, BinaryOperators::DAND, cmp, old)
                                    } else {
                                        LogicalBinBoolOperatorValue::new (loc, BinaryOperators::DPIPE, cmp, old)
                                    })
                                }
                            };
                        }
                        return res;
                    } catch {
                        err : &ErrorMsg => {
                            throw err.withNote ([ErrorMsg::note (loc, format (ValidateErrorMessage::UNDEFINED_BIN_OP, op, left.getType (), right.getType ()))]);
                        }
                    }
                }
            }
        }

        throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_BIN_OP, op, left.getType (), right.getType ()));
    }

    /**
     * Validate a binary comparison operator, assuming that left operand is a range type
     * @params:
     *   - context: the context of the operator
     *   - loc: the location of the operator
     *   - left: the left operand (assume to be a range type value)
     *   - right: the right operand
     * @returns: the result value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     * */
    fn validateRangeCmpOp (self, dmut context : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Value)-> &Value
        throws &ErrorMsg
    {
        if (op == BinaryOperators::DEQUAL || op == BinaryOperators::NOT_EQUAL) {
            match (left.getType (), right.getType ()) {
                (l : &RangeType, r : &RangeType) => {
                    {
                        context:.verifyCompatibleType (loc, right.getLoc (), l, r);
                    } catch {
                        _ => {
                            throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_BIN_OP, op, left.getType (), right.getType ()));
                        }
                    }

                    let uniqL = left;
                    let uniqR = right;
                    let inType = l.getInners ()[0];
                    let stType = l.getInners ()[1];
                    let bType = BoolType::new (loc);

                    let fstL = ValueWrapperExpr::new (loc, StructFieldAccessValue::new (loc, inType, uniqL, RangeKeys::FST));
                    let fstR = ValueWrapperExpr::new (loc, StructFieldAccessValue::new (loc, inType, uniqR, RangeKeys::FST));

                    let scdL = ValueWrapperExpr::new (loc, StructFieldAccessValue::new (loc, inType, uniqL, RangeKeys::SCD));
                    let scdR = ValueWrapperExpr::new (loc, StructFieldAccessValue::new (loc, inType, uniqR, RangeKeys::SCD));

                    let stepL = ValueWrapperExpr::new (loc, StructFieldAccessValue::new (loc, stType, uniqL, RangeKeys::STEP));
                    let stepR = ValueWrapperExpr::new (loc, StructFieldAccessValue::new (loc, stType, uniqR, RangeKeys::STEP));

                    let containL = ValueWrapperExpr::new (loc, StructFieldAccessValue::new (loc, bType, uniqL, RangeKeys::CONTAIN));
                    let containR = ValueWrapperExpr::new (loc, StructFieldAccessValue::new (loc, bType, uniqR, RangeKeys::CONTAIN));

                    let fstEq = context:.validateValue (BinaryExpr::new (Word::new (BinaryOperators::DEQUAL, loc), fstL, fstR));
                    let scdEq = context:.validateValue (BinaryExpr::new (Word::new (BinaryOperators::DEQUAL, loc), scdL, scdR));
                    let stepEq = context:.validateValue (BinaryExpr::new (Word::new (BinaryOperators::DEQUAL, loc), stepL, stepR));
                    let cntEq = context:.validateValue (BinaryExpr::new (Word::new (BinaryOperators::DEQUAL, loc), containL, containR));

                    let retA = LogicalBinBoolOperatorValue::new (loc, BinaryOperators::DAND, fstEq, scdEq);
                    let retB = LogicalBinBoolOperatorValue::new (loc, BinaryOperators::DAND, stepEq, cntEq);
                    let mut ret : &Value = LogicalBinBoolOperatorValue::new (loc, BinaryOperators::DAND, retA, retB);

                    if (op == BinaryOperators::NOT_EQUAL) {
                        ret = UnaryBoolOperatorValue::new (loc, UnaryOperators::NOT, ret);
                    }

                    return ret;
                }
            }
        }

        throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_BIN_OP, op, left.getType (), right.getType ()));
    }

    /**
     * Validate the comparison operator of two slice  (it is almost the same for array and slice, so it is factorized in this function)
     * @info: This comparison is not provided by the language itself, but by core files, so this binary operator is rewritten into a syntax element
     * @example: 
     * ======================
     * [1, 2, 3] < [0, 8, 0]
     * // is rewritten into => 'core::array::opCmp ([1, 2, 3], [0, 8, 0]) < 0'
     *
     * [1, 2, 3] >= [0, 8, 0]
     * // is rewritten into => 'core::array::opCmp ([1, 2, 3], [0, 8, 0]) >= 0'
     * ======================
     * @params: 
     *   - context: the context of the operator
     *   - loc: the location of the operator
     *   - left: the left operand
     *   - right: the right operand
     * @returns: the result value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    fn validateSliceOrArrayCmpOp (self, dmut context : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Value)-> &Value
        throws &ErrorMsg
    {        
        // The left element is a slice or an array (otherwise the function is not called)
        let leftSynt = match left.getType () {
            SliceType () => { ValueWrapperExpr::new (left.getLoc (), left) }
            a : &ArrayType => {
                ValueWrapperExpr::new (left.getLoc (), context.createSliceAliasFromArray (loc, a, left))
            }
            _ => {
                throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_BIN_OP, op, left.getType (), right.getType ()));
            }
        };
        
        // The comparison can be made only with an element of the same type, that is to say a slice or an array
        let rightSynt = match right.getType () {
            SliceType () => { ValueWrapperExpr::new (right.getLoc (), right) }
            a : &ArrayType => {
                ValueWrapperExpr::new (right.getLoc (), context.createSliceAliasFromArray (loc, a, right))
            }
            _ => {
                throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_BIN_OP, op, left.getType (), right.getType ()));
            }
        };

        let dmut errors = Vec!{&ErrorMsg}::new ();

        // There is another function for equality that is faster than comparison, so we call it if we can
        // And unlike class and struct, we know that this operator is defined in core files, so no need to check its existence 
        if (op == BinaryOperators::DEQUAL || op == BinaryOperators::NOT_EQUAL) {
            return self.validateSliceOrArrayEqualOp (alias context, loc, op, leftSynt, rightSynt);
        } catch {
            err : &ErrorMsg => {
                errors:.push (err);
            }
        }
        
        // Create a var path to the core function core::array::opCmp
        let syntVar = context.createSyntaxVarFromPath (loc, [CoreNames::CORE_MODULE, CoreNames::ARRAY_MODULE, CoreNames::CMP_OP_OVERRIDE]);

        // Create the syntax call of the function to compare two slices => core::array::opCmp (left, right)-> usize
        let syntCall = MultOperatorExpr::new (Word::new (Tokens::LPAR, loc), Word::new (Tokens::RPAR, loc),
                                              syntVar,
                                              [leftSynt, rightSynt], canBeDotCall-> false);
        {            
            // Validate the value to get the return type
            let valueCall = context:.validateValue (syntCall);
            let result = match valueCall {
                c : &CallValue => {
                    cast!{&Value} (SpecialArrayOperatorValue::new (loc, valueCall.getType (), op, c.getParameters ()[0], c.getParameters ()[1], c))
                }
                _ => { valueCall }
            };

            // Cast the value 0 to the type of the return type of the core function (it can change from one implementation to another and does not really have an impact)
            // The only thing that is necessary is that it returns a signed int value no matter the size
            let syntCast = CastExpr::new (loc,
                                          TypeWrapperExpr::new (loc, result.getType ()),
                                          ValueWrapperExpr::new (loc, makeIntValue (loc, 0is)));

            // Compare the value of the call to 0 using the operator provided by the source code ('op')
            let syntTest = BinaryExpr::new (Word::new (op, loc), ValueWrapperExpr::new (loc, result), syntCast);

            // Validate the final rewritten value
            context:.validateValue (syntTest)
        } catch {
            err : &ErrorMsg => {
                errors:.push (err);
                throw ErrorMsg::note (loc, ValidateErrorMessage::VALIDATING, notes-> errors[]);
            }
        }
    }

    /**
     * Validate the equality operator of two slice  (it is almost the same for array and slice, so it is factorized in this function)
     * @info: This comparison is not provided by the language itself, but by core files, so this binary operator is rewritten into a syntax element
     * @example: 
     * ======================
     * [1, 2, 3] != [0, 8, 0]
     * // is rewritten into => '!core::array::opEquals ([1, 2, 3], [0, 8, 0])'
     *
     * [1, 2, 3] == [0, 8, 0]
     * // is rewritten into => 'core::array::opEquals ([1, 2, 3], [0, 8, 0])'
     * ======================
     * @params: 
     *   - context: the context of the operator
     *   - loc: the location of the operator
     *   - left: the left operand 
     *   - right: the right operand
     * @returns: the result value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */

    fn validateSliceOrArrayEqualOp (self, dmut context : &Validator, loc : &Word, op : BinaryOperators, leftSynt : &Expression, rightSynt : &Expression)-> &Value
        throws &ErrorMsg
    {
        // Create a var path to the core function core::array::opEquals
        let syntVar = context.createSyntaxVarFromPath (loc, [CoreNames::CORE_MODULE, CoreNames::ARRAY_MODULE, CoreNames::EQUAL_OP_OVERRIDE]);

        // Create the syntax call of the function to compare two slices => core::array::opCmp (left, right)-> usize
        let syntCall = MultOperatorExpr::new (Word::new (Tokens::LPAR, loc), Word::new (Tokens::RPAR, loc),
                                              syntVar,
                                              [leftSynt, rightSynt], canBeDotCall-> false);

        return {
            // Validate the value to get the return type
            let valueCall = context:.validateValue (syntCall);
            let result = match valueCall {
                c : &CallValue => {
                    cast!{&Value} (SpecialArrayOperatorValue::new (loc, valueCall.getType (), BinaryOperators::DEQUAL, c.getParameters ()[0], c.getParameters ()[1], c))
                }
                _ => { valueCall }
            };

            if (op == BinaryOperators::NOT_EQUAL) { // We need to inverse the equality, the operator returns '=='
                let syntTest = UnaryExpr::new (Word::new (UnaryOperators::NOT, loc), ValueWrapperExpr::new (loc, result));
                context:.validateValue (syntTest)
            } else {
                result
            }
        } catch {
            err : &ErrorMsg => {
                throw ErrorMsg::note (loc, ValidateErrorMessage::VALIDATING, notes-> [err]);
            }
        };
    }
    
    /*!
     * ================================================================================
     * ================================================================================
     * =========================           LOGICAL            =========================
     * ================================================================================
     * ================================================================================
     */


    /**
     * Validate a binary operation involving logical operator (&&, ||)
     * @info: these operators have a meaning only on bool values
     * @params: 
     *   - context: the context of the validation
     *   - op: the operator (assuming it's a logical operator)
     *   - bin: the binary expression to validate
     * @returns: the validated value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    fn validateLogicalOperation (self, dmut context : &Validator, op : BinaryOperators, bin : &BinaryExpr)-> &Value
        throws &ErrorMsg
    {
        let left = context:.implicitEnumUnwrap (context:.validateValue (bin.getLeft ()));
        let right = context:.implicitEnumUnwrap (context:.validateValue (bin.getRight ()));

        match left.getType () {
            BoolType () => {
                match right.getType () {
                    BoolType () => {
                        return LogicalBinBoolOperatorValue::new (bin.getLoc (), op, left, right);
                    }
                }
            }
        }

        throw ErrorMsg::fatal (bin.getLoc (), format (ValidateErrorMessage::UNDEFINED_BIN_OP, op, left.getType (), right.getType ()));
    }


    /*!
     * ================================================================================
     * ================================================================================
     * =========================            RANGE             =========================
     * ================================================================================
     * ================================================================================
     */


    /**
     * Validate a binary operation involving a range operator
     * @params: 
     *   - context: the context of the validation
     *   - op: the operator (assuming it's a range operator)
     *   - bin: the binary expression to validate
     * @returns: the validated value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    fn validateRangeOperation (self, dmut context : &Validator, op : BinaryOperators, bin : &BinaryExpr)-> &Value
        throws &ErrorMsg
    {
        let left = context:.implicitEnumUnwrap (context:.validateValue (bin.getLeft ()));
        let right = context:.implicitEnumUnwrap (context:.validateValue (bin.getRight ()));

        let dmut errors = Vec!{&ErrorMsg}::new ();        
        {
            match left.getType () { // First we try the operation as a left side operation (asking for left operand to be the master of the operation, i.e. left.opBinary!{op} (right)
                IntType () => return self.validateIntRangeOp (alias context, bin.getLoc (), op, left, right);
                StructType () => return self.validateStructRangeOpLeft (alias context, bin.getLoc (), op, left, right);
                ClassPtrType () => return self.validateClassRangeOpLeft (alias context, bin.getLoc (), op, left, right);
            };
            
            errors:.push (ErrorMsg::fatal (bin.getLoc (), format (ValidateErrorMessage::UNDEFINED_BIN_OP, op, left.getType (), right.getType ())));
        } catch {
            err : &ErrorMsg => { errors:.push (err); }
        } 

        { // if we are here the validation as a left operand validation failed, so we need to try it as a right operation (right.opBinaryRight!{op} (left))
            match right.getType () { // it is working only for two kind of type structs and classes
                StructType () => return self.validateStructRangeOpRight (alias context, bin.getLoc (), op, left, right);
                ClassPtrType () => return self.validateClassRangeOpRight (alias context, bin.getLoc (), op, left, right);
            } // We can quit without testing the other types, there is already an error in the errors vec
        } catch {
            err : &ErrorMsg => { errors:.push (err); } // No we still fail
        }

        throw ErrorMsg::list (errors[]); // there is no valid math operation for left and right        
    }

    /**
     * Validate a range operator assuming that the left operand is a int value
     * @params: 
     *   - context: the context of the validation
     *   - loc: the location of the operation
     *   - op: the range operator
     *   - left: the left operand
     *   - right: the right operand
     * @returns: the result value
     * @throws:
     *    - &ErrorMsg: if the operation is not valid
     */
    fn validateIntRangeOp (self, dmut context : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Value)-> &Value
        throws &ErrorMsg
    {
        match left.getType () {
            li : &IntType => {
                match right.getType () {
                    ri : &IntType => {
                        // The type of the range takes the biggest of the two elements
                        let bI = if (self.isMax (li.getSize (), ri.getSize ())) { li } else { ri };

                        let (lvalue, rvalue) = { // We try implicit casting of operands (e.g. 1 .. 2us is Ok and create a ..usize value)
                            let lvalue = context:.verifyCompatibleTypeWithValue (left.getLoc (), bI, left, byReference-> false);
                            let rvalue = context:.verifyCompatibleTypeWithValue (right.getLoc (), bI, right, byReference-> false);
                            (lvalue, rvalue)
                        } catch {
                            err : &ErrorMsg => { // If implicit cast didn't work we throw a more explicit error
                                throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_BIN_OP, op, left.getType (), right.getType ()),
                                                       notes-> [err]);
                            }
                        }

                        let stepType = IntType::new (loc, signed-> true, size-> bI.getSize ()); // Step is always signed
                        let type = RangeType::new (loc, bI, stepType, isMutable-> false); // Inner type is the biggest of the two operands
                        let include = BoolValue::new (loc, (op == BinaryOperators::TDOT)); // include the last value depending on the operator used

                        let cmp = CmpIntOperatorValue::new (loc, BinaryOperators::INF_EQUAL, lvalue, rvalue); // Range can be decreasing if scd < fst
                        let condStep = ConditionalValue::new (loc, stepType, cmp,
                                                              IntValue::new (loc, stepType, 1us),
                                                              IntValue::new (loc, stepType, BigInt::new (-1))); // Then the step is set accordingly

                        let step = context.getCompileTimeInterpreter ().reduce (condStep); // Try to get the step value as cte
                        return RangeValue::new (loc, type, lvalue, rvalue, step-> step, full-> include);
                    }
                }
            }
            _ => __pragma!panic (); // We entered this function assuming left operand is of type int
        }

        // Right op is not an int value
        throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_BIN_OP, op, left.getType (), right.getType ()));
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================           POINTER            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a binary operation involving a pointer operator
     * @params: 
     *   - context: the context of the validation
     *   - op: the operator (assuming it's a pointer operator)
     *   - bin: the binary expression to validate
     * @returns: the validated value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    fn validatePointerOperation (self, dmut context : &Validator, op : BinaryOperators, bin : &BinaryExpr)-> &Value
        throws &ErrorMsg
    {
        let left = context:.implicitEnumUnwrap (context:.validateValue (bin.getLeft ()));
        let right = context:.implicitEnumUnwrap (context:.validateValue (bin.getRight ()));

        match left.getType () {
            ClassPtrType () =>
                return self.validateClassPointerOp (alias context, bin.getLoc (), op, left, right);
        };

        throw ErrorMsg::fatal (bin.getLoc (), format (ValidateErrorMessage::UNDEFINED_BIN_OP, op, left.getType (), right.getType ()));
    }

    /**
     * Validate a pointer operator (is and !is) assuming that the left operand is a class value
     * @params: 
     *   - context: the context of the validation
     *   - loc: the location of the operation
     *   - op: the operator
     *   - left: the left operand
     *   - right: the right operand
     * @returns: the result value
     * @throws:
     *    - &ErrorMsg: if the operation is not valid
     */
    fn validateClassPointerOp (self, dmut context : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Value)-> &Value
        throws &ErrorMsg
    {
        match left.getType () {
            lp : &ClassPtrType => {
                match right.getType () {
                    rp : &ClassPtrType => {
                        context.verifyCompatibleType (left.getLoc (), right.getLoc (), lp, rp);

                        // We are using a pointer cmp, because classptr are basically just pointers, and the result is just a bool, so there is no need to be much specific here
                        return CmpPointerOperatorValue::new (loc, op, left, right); 
                    }
                }
            }
            _ => __pragma!panic ();
        }

        throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_BIN_OP, op, left.getType (), right.getType ()));
    }


    /*!
     * ================================================================================
     * ================================================================================
     * =========================             SET              =========================
     * ================================================================================
     * ================================================================================
     */


    /**
     * Validate a binary operation involving a set operator
     * @params: 
     *   - context: the context of the validation
     *   - op: the operator (assuming it's a set operator)
     *   - bin: the binary expression to validate
     * @returns: the validated value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    fn validateSetOperation (self, dmut context : &Validator, op : BinaryOperators, bin : &BinaryExpr)-> &Value
        throws &ErrorMsg
    {
        if (op == BinaryOperators::NOT_IN || op == BinaryOperators::IN) {
            return self.validateContainOperation (alias context, op, bin);
        } else {
            return self.validateConcatOperation (alias context, op, bin);
        }
    }

    /**
     * Validate a contain operation (in or !in)
     * @params: 
     *   - context: the context of the validation
     *   - op: the operator (assuming it's a set operator)
     *   - bin: the binary expression to validate
     * @returns: the validated value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    fn validateContainOperation (self, dmut context : &Validator, op : BinaryOperators, bin : &BinaryExpr)-> &Value
        throws &ErrorMsg
    {
        let right = context:.implicitEnumUnwrap (context:.validateValue (bin.getRight ()));
        match right.getType () {
            ClassPtrType () => {
                return self.validateClassContainOp (alias context, op, bin, right);
            }
            SliceType () => { return self.validateSliceOrArrayContainOp (alias context, op, bin, right); }
            ArrayType () => { return self.validateSliceOrArrayContainOp (alias context, op, bin, right); }
            StructType () => { return self.validateStructContainOp (alias context, op, bin, right); }
            RangeType () => { return self.validateRangeContainOp (alias context, op, bin, right); }
            // Other types (native, or stuff like that) cannot override the opContains
        }

        let left = context:.validateValue (bin.getLeft ());
        throw ErrorMsg::fatal (bin.getLoc (), format (ValidateErrorMessage::UNDEFINED_BIN_OP, op, left.getType (), right.getType ()));
    }

    /**
     * Validate a contain operation (in or !in) for a class type value as right operand
     * @params: 
     *   - context: the context of the validation
     *   - op: the operator (assuming it's a set operator)
     *   - bin: the binary expression to validate
     *   - right: the right operand
     * @returns: the validated value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    fn validateClassContainOp (self, dmut context : &Validator, op : BinaryOperators, bin : &BinaryExpr, right : &Value)-> &Value
        throws &ErrorMsg
    {
        let dotOp = BinaryExpr::new (Word::new (Tokens::DOT, bin.getLoc ()),
                                     ValueWrapperExpr::new (right.getLoc (), right),
                                     VarExpr::new (Word::new (CoreNames::CONTAIN_OP_OVERRIDE, bin.getLoc ())));

        // The call is right.opContains (left)-> any, maybe check if it is really a bool ?
        let mut callOp : &Expression = MultOperatorExpr::new (Word::new (Tokens::LPAR, bin.getLoc ()),
                                                              Word::new (Tokens::RPAR, bin.getLoc ()),
                                                              dotOp,
                                                              [bin.getLeft ()], canBeDotCall-> false);
        
        if (op == BinaryOperators::NOT_IN) { // !in is rewritten into '!(right.opContains (left))'
            callOp = UnaryExpr::new (Word::new (UnaryOperators::NOT, bin.getLoc ()), callOp);
        }

        {
            return context:.validateValue (callOp);                    
        } catch {
            err : &ErrorMsg => { // We add a note, because it can be a bit obscur why opContains is called
                throw ErrorMsg::note (bin.getLoc (), ValidateErrorMessage::VALIDATING, notes-> [err]);
            }
        }                
    }

    /**
     * Validate a contain operation (in or !in) for a slice or array type value as right operand
     * @params: 
     *   - context: the context of the validation
     *   - op: the operator (assuming it's a set operator)
     *   - bin: the binary expression to validate
     *   - right: the right operand
     * @returns: the validated value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    fn validateSliceOrArrayContainOp (self, dmut context : &Validator, op : BinaryOperators, bin : &BinaryExpr, right : &Value)-> &Value
        throws &ErrorMsg
    {
        let left = context:.implicitEnumUnwrap (context:.validateValue (bin.getLeft ()));
        
        // The right operand can be a slice or an array the operation is the same
        let rightSynt = match right.getType () {
            SliceType () => { ValueWrapperExpr::new (right.getLoc (), right) }
            ArrayType () => { ValueWrapperExpr::new (right.getLoc (), right) }
            _ => {
                throw ErrorMsg::fatal (bin.getLoc (), format (ValidateErrorMessage::UNDEFINED_BIN_OP, op, left.getType (), right.getType ()));
            }
        };

        // Create the var path to the core function core::array::opContains
        let syntVar = context.createSyntaxVarFromPath (bin.getLoc (), [CoreNames::CORE_MODULE, CoreNames::ARRAY_MODULE, CoreNames::CONTAIN_OP_OVERRIDE]);

        // Create the syntax call of the function to check the contains => core::array::opContains (right, left)-> bool
        let mut syntCall : &Expression = MultOperatorExpr::new (Word::new (Tokens::LPAR, bin.getLoc ()), Word::new (Tokens::RPAR, bin.getLoc ()),
                                                                syntVar,
                                                                [rightSynt, ValueWrapperExpr::new (left.getLoc (), left)],
                                                                canBeDotCall-> false);

        if (op == BinaryOperators::NOT_IN) { // !in is rewritten into '!(opContains (right, left))'
            syntCall = UnaryExpr::new (Word::new (UnaryOperators::NOT, bin.getLoc ()), syntCall);
        }

        {

            context:.validateValue (syntCall)
        } catch {
            err : &ErrorMsg => { // Show the location of the rewrite for better error handling
                throw ErrorMsg::note (bin.getLoc (), ValidateErrorMessage::VALIDATING, notes-> [err]);
            }
        }
    }

    /**
     * Validate a contain operation (in or !in) for a range value as right operand
     * @params:
     *     - context: the context of the operation
     *     - op: the operator (assuming it's a set operator)
     *     - bin: the binary expression to validate
     *     - right: the right operand (already validated)
     * @returns: the validated value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     * */
    fn validateRangeContainOp (self, dmut context : &Validator, op : BinaryOperators, bin : &BinaryExpr, right : &Value)-> &Value
        throws &ErrorMsg
    {
        let left = context:.implicitEnumUnwrap (context:.validateValue (bin.getLeft ()));
        let rngType = right.getType ().asOf!{&RangeType} ();

        context.verifyCompatibleType (left.getLoc (), right.getLoc (), left.getType (), rngType.getInners ()[0]);

        let rightSynt = ValueWrapperExpr::new (right.getLoc (), right);
        let leftSynt = ValueWrapperExpr::new (left.getLoc (), left);

        let syntVar = context.createSyntaxVarFromPath (bin.getLoc (), [CoreNames::CORE_MODULE, CoreNames::RANGE_MODULE, CoreNames::CONTAIN_OP_OVERRIDE]);

        // Create the syntax call of the function to check the contains => core::range::opContains (right, left)-> bool
        let mut syntCall : &Expression = MultOperatorExpr::new (Word::new (Tokens::LPAR, bin.getLoc ()), Word::new (Tokens::RPAR, bin.getLoc ()),
                                                                syntVar,
                                                                [rightSynt, leftSynt],
                                                                canBeDotCall-> false);

        if (op == BinaryOperators::NOT_IN) { // !in is rewritten into '!(opContains (right, left))'
            syntCall = UnaryExpr::new (Word::new (UnaryOperators::NOT, bin.getLoc ()), syntCall);
        }

        let res = {
            context:.validateValue (syntCall)
        } catch {
            err : &ErrorMsg => { // Show the location of the rewrite for better error handling
                throw ErrorMsg::note (bin.getLoc (), ValidateErrorMessage::VALIDATING, notes-> [err]);
            }
        };

        RangeContainValue::new (bin.getLoc (), res.getType (), op, left, right, res)
    }

    /**
     * Validate a contain operation (in or !in) for a struct typed value as right operand
     * @params: 
     *   - context: the context of the validation
     *   - op: the operator (assuming it's a set operator)
     *   - bin: the binary expression to validate
     *   - right: the right operand
     * @returns: the validated value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid 
     */
    fn validateStructContainOp (self, dmut context : &Validator, op : BinaryOperators, bin : &BinaryExpr, right : &Value)-> &Value
        throws &ErrorMsg
    {
        // Struct opContains override is a simple function that has to be defined (does not matter where), opContains (right, left)-> bool
        let mut syntCall : &Expression = MultOperatorExpr::new (Word::new (Tokens::LPAR, bin.getLoc ()), Word::new (Tokens::RPAR, bin.getLoc ()),
                                                                VarExpr::new (Word::new (CoreNames::CONTAIN_OP_OVERRIDE, bin.getLoc ())),
                                                                [ValueWrapperExpr::new (right.getLoc (), right), bin.getLeft ()],
                                                                canBeDotCall-> false);

        if (op == BinaryOperators::NOT_IN) { // !in is rewritten into '!(opContains (right, left)-> bool)'
            syntCall = UnaryExpr::new (Word::new (UnaryOperators::NOT, bin.getLoc ()), syntCall);
        }
        
        {

            context:.validateValue (syntCall)
        } catch {
            err : &ErrorMsg => { // Show the location of the rewrite for better error handling
                throw ErrorMsg::note (bin.getLoc (), ValidateErrorMessage::VALIDATING, notes-> [err]);
            }
        }        
   
    }
    
    /**
     * Validate a concatenation operation (~)
     * @params: 
     *   - context: the context of the validation
     *   - op: the operator (assuming it's a set operator)
     *   - bin: the binary expression to validate
     * @returns: the validated value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    fn validateConcatOperation (self, dmut context : &Validator, op : BinaryOperators, bin : &BinaryExpr)-> &Value
        throws &ErrorMsg
    {
        let mut left = context:.implicitEnumUnwrap (context:.validateValue (bin.getLeft ()));
        let mut right = context:.implicitEnumUnwrap (context:.validateValue (bin.getRight ()));

        let dmut errors = Vec!{&ErrorMsg}::new ();
        {
            match left.getType () { // We first try to validate the operation as a left operation
                ClassPtrType () => { return self.validateClassOpLeft (alias context, bin.getLoc (), op, left, right); }
                StructType () => { return self.validateStructOpLeft (alias context, bin.getLoc (), op, left, right); }
                SliceType () => { return self.validateSliceOrArrayConcatOp (alias context, bin.getLoc (), op, left, right); }
                ArrayType () => { return self.validateArrayConcatOp (alias context, bin.getLoc (), op, left, right); }
            };

            // Left operand is not a concatenable operand, but we need at least one error to display if the right operand is not concatenable as well
            errors:.push (ErrorMsg::fatal (bin.getLoc (), format (ValidateErrorMessage::UNDEFINED_BIN_OP, op, left.getType (), right.getType ())));
        } catch {
            err : &ErrorMsg => {
                errors:.push (err);
            }
        }

        { // The concat operator works as a math operator for class and structs (opBinary!{"~"} (left, right))
            match right.getType () { // Now we try to validate the operation as a right operation (opBinaryRight!{"~"}(right, left))
                ClassPtrType () => { return self.validateClassOpRight (alias context, bin.getLoc (), op, left, right); }
                StructType () => { return self.validateStructOpRight (alias context, bin.getLoc (), op, left, right); }
            };
            
            // If the right operand is not a class nor struct, we don't add any error because there is already an error for the 'as left' operation
        } catch {
            err : &ErrorMsg => {
                errors:.push (err);
            }
        }

        throw ErrorMsg::list (errors[]); // 'as left' and 'as right' failed, no other choice than throwing the errors

    }

    /**
     * Validate a concatenation operation (~), where the left operand is an array
     * @params:
     *     - context: the context of the validation
     *     - loc: the location of the operation
     *     - op: the operator
     *     - left: the left operand (with an array type)
     *     - right: the right operand
     *  @returns: the validated value
     *  @throws:
     *     - &ErrorMsg: if the operation is not valid
     * */
    fn validateArrayConcatOp (self, dmut context : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Value)-> &Value
        throws &ErrorMsg
    {
        match right.getType () {
            SliceType () => { return self.validateSliceOrArrayConcatOp (alias context, loc, op, left, right); }
            ArrayType () => {}
            _ => {
                throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_BIN_OP, op, left.getType (), right.getType ()));
            }
        }

        let uniqL = left;
        let uniqR = right;

        let leArrType = left.getType ().asOf!{&ArrayType} ();
        let riArrType = right.getType ().asOf!{&ArrayType} ();

        {
            context:.verifyCompatibleType (left.getLoc (), right.getLoc (), leArrType.getInners ()[0], riArrType.getInners ()[0]);
        } catch {
            err : &ErrorMsg => {
                throw ErrorMsg::note (loc, ValidateErrorMessage::VALIDATING, notes-> [err]);
            }
        }

        let mut inner : &Type = NoneType::new (loc);
        let dmut finParams = Vec!{&Value}::new ();
        for it in 0us .. leArrType.getLen () {
            let val = context:.getIndexOpValidator ().createArrayAccess (loc, leArrType.getInners ()[0], uniqL, makeIntValue (loc, it));
            inner = context:.getValueValidator ().addArrayType (alias context, val, alias finParams, inner);
        }

        for it in 0us .. riArrType.getLen () {
            let val = context:.getIndexOpValidator ().createArrayAccess (loc, leArrType.getInners ()[0], uniqR, makeIntValue (loc, it));
            inner = context:.getValueValidator ().addArrayType (alias context, val, alias finParams, inner);
        }

        // Concatenation of two void arrays
        if (finParams.len () == 0us) inner = VoidType::new (loc);
        if (!inner.isMutable ()) {
            inner = inner.clone (1u32);
        }

        let arrType = ArrayType::new (loc, inner, finParams.len (), isMutable-> true);
        ArrayValue::new (loc, arrType, finParams [])
    }
    
    /**
     * Validate a concatenation operation (~), where left operand is a slice
     * @params: 
     *   - context: the context of the validation
     *   - loc: the location of the operation
     *   - op: the operator (assuming it's a set operator)
     *   - left: the left operand of the operation
     *   - right: the right operand of the operation
     * @returns: the validated value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    fn validateSliceOrArrayConcatOp (self, dmut context : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Value)-> &Value
        throws &ErrorMsg
    {        
        // Slice and arrays are almost the same type, (slice being pointer to arrays), but we first need to transform the arrays into slices
        // The left element has to be a slice or an array
        let finLeft = match left.getType () {
            SliceType () => { left }
            a : &ArrayType => {
                context.createSliceAliasFromArray (loc, a, left)
            }
            _ => {
                __pragma!panic ();
            }
        };
        
        // The concatenation can be made only with an element of the same type, that is to say a slice or an array
        let finRight = match right.getType () {
            SliceType () => { right }
            a : &ArrayType => {
                context.createSliceAliasFromArray (loc, a, right)
            }
            _ => {
                throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_BIN_OP, op, left.getType (), right.getType ()));
            }
        };

        {
            context:.verifyCompatibleType (finLeft.getLoc (), finRight.getLoc (), finLeft.getType (), finRight.getType ()); // Evidently the concat is made only with slices of the same kind            
        } catch {
            err : &ErrorMsg => {
                throw ErrorMsg::note (loc, ValidateErrorMessage::VALIDATING, notes-> [err]);
            }
        }

        let mut retType = if (finLeft.getType ().mutabilityFit (finRight.getType ())) { // the mutability of the result is the same mutability as the type with the lowest mutability level
            finRight.getType ()
        } else {
            finLeft.getType ()
        };

        // If the type of left or right operands is const, we still can modify
        // the inner values, without modifying the inner borrowed datas
        if (!retType.asOf!{&SliceType} ().getInners ()[0].isMutable ()) {
            retType = retType.clone (2u32);
        }

        SliceConcatValue::new (loc, retType, finLeft, finRight)
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================             TYPE             =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a binary operation involving a type operator
     * @params: 
     *   - context: the context of the validation
     *   - op: the operator (assuming it's a type operator)
     *   - bin: the binary expression to validate
     * @returns: the validated value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    fn validateTypeOperation (self, dmut context : &Validator, op : BinaryOperators, bin : &BinaryExpr)-> &Value
        throws &ErrorMsg
    {
        let left = context:.implicitEnumUnwrap (context:.validateValue (bin.getLeft ()));
        let right = context:.validateType (bin.getRight ());

        match left.getType () {
            ClassPtrType () =>
                return self.validateClassTypeTestOp (alias context, bin.getLoc (), op, left, right);
        };

        throw ErrorMsg::fatal (bin.getLoc (), format (ValidateErrorMessage::UNDEFINED_BIN_OP, op, left.getType ()));
    }

    /**
     * Validate a type test operator (of and !of) assuming the left operand is a class value
     * @params:
     *    - context: the context of the validation
     *    - loc: the location of the operation
     *    - op: the operator
     *    - left: the left operand
     *    - right: the right operand
     * @returns: the result value of type bool
     * @throws:
     *     - &ErrorMsg: if the operation is not valid
     * */
    pub fn validateClassTypeTestOp (self, dmut context : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Type)-> &Value
        throws &ErrorMsg
    {
        let clRef = left.getType ().asOf!{&ClassPtrType} ().getInner ();
        match right {
            rp : &ClassRefType => {
                if (clRef.isCompatible (rp)) { // typeof (left) == right
                    return BoolValue::new (loc, op == BinaryOperators::OF);
                } else if (context.isAncestor (rp, clRef)) { // typeof (left) over right, so /left/ is of /right/
                    return BoolValue::new (loc, op == BinaryOperators::OF);
                } else if (context.isAncestor (clRef, rp)) { // right over typeof (left), so /left/ can contain an instance of /right/
                    return CmpClassTypeOperatorValue::new (loc, op, left, rp);
                }
            }
        }

        throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_BIN_OP, op, left.getType (), right));
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================            FIELD             =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a binary operation involving a field operator
     * @params: 
     *   - context: the context of the validation
     *   - op: the operator (assuming it's a field operator)
     *   - bin: the binary expression to validate
     * @returns: the validated value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    fn validateFieldOperation (self, dmut context : &Validator, op : BinaryOperators, bin : &BinaryExpr)-> &Value
        throws &ErrorMsg
    {
        let left = if (op == BinaryOperators::DOT_AND) {
            let innerLeft = IntrinsicExpr::new (bin.getLoc (), IntrinsicKeys::ALIAS, bin.getLeft ()); // rewritte (a:. into (alias a).)
            context:.validateValue (innerLeft)
        } else {
            context:.implicitEnumUnwrap (context:.validateValue (bin.getLeft ()))
        };

        self.validateFieldOperation (alias context, bin.getLoc (), op, left, bin.getRight ())
    }


    /**
     * Validate a field operation
     * @params:
     *    - context: the context of the validation
     *    - loc: the location of the access
     *    - op: the operator
     *    - left: the left operand
     *    - right: the field being accessed
     * @returns: the validated value
     * @throws:
     *    - &ErrorMsg: if the operation is not valid
     * */
    pub fn validateFieldOperation (self, dmut context : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Expression)-> &Value
        throws &ErrorMsg
    {
        match left.getType () {
            cptr : &ClassPtrType => {
                return self.validateClassFieldVtableOperation (alias context, loc, cptr, left, right);
            }
            tuple : &TupleType => {
                return self.validateTupleFieldOperation (alias context, loc, op, tuple, left, right);
            }
            range : &RangeType => {
                return self.validateRangeFieldOperation (alias context, loc, op, range, left, right);
            }
            sl : &SliceType => {
                return self.validateSliceFieldOperation (alias context, loc, op, sl, left, right);
            }
            arr : &ArrayType => {
                return self.validateArrayFieldOperation (alias context, loc, op, arr, left, right);
            }
            o : &OptionType => {
                return self.validateOptionFieldOperation (alias context, loc, op, o, left, right);
            }
        }

        throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_BIN_OP, op, left.getType (), right));
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================      CLASS FIELD VTABLE      =========================
     * ================================================================================
     * ================================================================================
     */
    
    /**
     * Validate a field or vtable access operation on a class instance value
     * @params: 
     *    - context: the context of the validation
     *    - op: the operator
     *    - left: the instance value
     *    - right: the right operand
     */
    fn validateClassFieldVtableOperation (self, dmut context : &Validator, _ : &Word, cptr : &ClassPtrType, left : &Value, right : &Expression)-> &Value
        throws &ErrorMsg
    {
        let (inPrv, inProt) = context:.getCurrentClassContextProtections (cptr.getInner ());
        {                    
            return self.validateClassFieldAccess (alias context, left, right, cptr.getInner (), inProt, inPrv);
        } catch {
            err : &ErrorMsg => {
                {
                    match self.validateClassVtableAccess (alias context, left, right, cptr.getInner (), inProt, inPrv) {
                        UnitValue () => throw err;
                        v : _ => return v;
                    };
                } catch {
                    vtableErr : &ErrorMsg => {
                        match self.validateClassBasicFieldAccess (alias context, left, right, cptr.getInner ()) {
                            UnitValue () => throw vtableErr;
                            v : _ => return v;
                        }
                    }
                }
            }
        }        
    }

    /**
     * Validate a field access operation on a class instance value
     * @params: 
     *    - context: the context of the validation
     *    - left: the instance of the class
     *    - right: the field to access
     *    - clRef: the type of the class
     *    - inProt: true iif current context has access to protected fields
     *    - inPrv: true iif current context has access to private fields
     */
    pub fn validateClassFieldAccess (self, dmut context : &Validator, left : &Value, right : &Expression, clRef : &ClassRefType, inProt : bool, inPrv : bool, verifyValidation : bool = true, withAncestor : bool = true)-> &Value
        throws &ErrorMsg
    {
        match right {
            field : &VarExpr => { // Only work with varexpr
                for it in clRef.getLocalFields () match it {
                    v : &VarDeclValue => {
                        if (v.getLoc ().str () == field.getLoc ().str ()) {
                            if (clRef.getSymbol ().isFieldPrivate (field.getLoc ().str ()) && !inPrv) { // The field exists but is private, and we don't have access to private fields (outside class, or ancestor)
                                throw ErrorMsg::fatal (right.getLoc (), format (DeclareErrorMessage::PRIVATE_IN_THIS_CONTEXT, right.getLoc ().str ()),
                                                       notes-> [ErrorMsg::note (v.getLoc (), ValidateErrorMessage::DECLARED_HERE)]);
                            } else if (clRef.getSymbol ().isFieldProtected (field.getLoc ().str ()) && !inPrv && !inProt) { // The field exists but we are outside the class definition
                                throw ErrorMsg::fatal (right.getLoc (), format (DeclareErrorMessage::PRIVATE_IN_THIS_CONTEXT, right.getLoc ().str ()),
                                                       notes-> [ErrorMsg::note (v.getLoc (), ValidateErrorMessage::DECLARED_HERE)]);
                            }
                            
                            if (verifyValidation) { // Verify that the field is initialized and ready to be used (for pre constructor context)
                                if (context.isInFieldConstruction () && context.getFieldConstructionType () == clRef) { // it is a local field of the class being constructed
                                    if (field.getLoc ().str () !in context.getFieldValidated ()) { // And the field is not init yet
                                        throw ErrorMsg::fatal (right.getLoc (), format (ValidateErrorMessage::CLASS_FIELD_NOT_INIT_YET, right.getLoc ().str ()),
                                                               notes-> [ErrorMsg::note (v.getLoc (), ValidateErrorMessage::DECLARED_HERE)]);
                                    }
                                }
                            }
                            
                            // If the class is immutable, the field cannot be mutable
                            let type = if (clRef.isMutable ()) { v.getVarType () } else { v.getVarType ().clone (0u32) };
                            
                            // The field is public in this context, we return the access
                            return ClassFieldAccessValue::new (right.getLoc (), type, left, field.getLoc ().str ());
                        }
                    }
                    _ => __pragma!panic ();
                }

                if (withAncestor) {
                    match clRef.getAncestor () {
                        ancRef : &ClassRefType => { // Maybe the field is a field of an ancestor
                            return self.validateClassFieldAccess (alias context, left, right, ancRef, inProt || inPrv, false);
                        }
                    }
                }
            }
        };

        
        throw ErrorMsg::fatal (right.getLoc (), format (ValidateErrorMessage::CLASS_NO_FIELD, left.getType (), right));
    }

    /**
     * Validate a vtable access operation on a class instance value
     * @params:
     *     - context: the context of the validation
     *     - left: the instance of the class
     *     - right: the field to access
     *     - clRef: the type of the class
     *     - inProt: true iif current context has access to protected vtable
     *     - inPrv: true iif current context has access to private vtable
     */
    fn validateClassVtableAccess (self, dmut context : &Validator, left : &Value, right : &Expression, clRef : &ClassRefType, inProt : bool, inPrv : bool)-> &Value
        throws &ErrorMsg
    {
        left;
        context;
        let dmut errors = Vec!{&ErrorMsg}::new ();
        let dmut values = Vec!{&Value}::new ();
        let dmut isFields = Vec!{bool}::new ();

        match right {
            meth : &VarExpr => {
                for i, v in clRef.getVtable () {
                    if (v.getSymbol ().getPath ().file () == meth.getLoc ().str ()) {
                        if (v.getSymbol ().getProtection () == Protection::PRIVATE && !inPrv) {
                            errors:.push (ErrorMsg::fatal (right.getLoc (), format (DeclareErrorMessage::PRIVATE_IN_THIS_CONTEXT, right.getLoc ().str ()),
                                                   notes-> [ErrorMsg::note (v.getSymbol ().getLoc (), ValidateErrorMessage::DECLARED_HERE)]));
                        } else if (v.getSymbol ().getProtection () == Protection::PROTECTED && !inPrv && !inProt) {
                            errors:.push (ErrorMsg::fatal (right.getLoc (), format (DeclareErrorMessage::PRIVATE_IN_THIS_CONTEXT, right.getLoc ().str ()),
                                                   notes-> [ErrorMsg::note (v.getSymbol ().getLoc (), ValidateErrorMessage::DECLARED_HERE)]));
                        } else {
                            let isFinal = match (clRef.getAncestor (), v.getSymbol ()) {
                                (NoneType (), f : &FunctionSymbol) => { f.isFinal () || clRef.getSymbol ().isFinal () }
                                _ => { false }
                            };

                            let isField = v.isField ();

                            if (v.isMutable () && !left.isOf!{&AliaserValue} ()) {
                                errors:.push (ErrorMsg::fatal (v.getLoc (), format (ValidateErrorMessage::MUTABLE_METHOD, v.getSymbol ().getPath ().toStr ()),
                                                               notes-> [ErrorMsg::note (left.getLoc (), format (ValidateErrorMessage::IMPLICIT_ALIAS, left.getType ()))]));
                            } else if (!v.isMutable () && left.isOf!{&AliaserValue} ()) {
                                errors:.push (ErrorMsg::fatal (v.getLoc (), format (ValidateErrorMessage::CONST_METHOD, v.getSymbol ().getPath ().toStr ()),
                                                               notes-> [ErrorMsg::note (left.getLoc (), format (ValidateErrorMessage::UNECESSARY_ALIAS, left.getType ()))]));
                            } else if (v.isMutable () && !left.getType ().isDeeplyMutable ()) {
                                errors:.push (ErrorMsg::fatal (v.getLoc (), format (ValidateErrorMessage::MUTABLE_METHOD, v.getSymbol ().getPath ().toStr ()),
                                                               notes-> [ErrorMsg::note (left.getLoc (), ValidateErrorMessage::DISCARD_CONST)]));
                            } else {
                                isFields:.push (isField);
                                values:.push (MethodDelegateValue::new (v.getLoc (), v, closure-> left, direct-> isFinal, vtableIndex-> i));
                            }
                        }
                    }
                }
            }
            // _ => {
            // We don't throw an error, assuming that validateClassFieldAccess is always called before, thus the error would be replicated
            // }
        };

        if (values.len () == 0us) {
            if (errors.len () != 0us) throw ErrorMsg::list (errors[]);
            UNIT_VALUE // the class has no method named right
        } else if (values.len () == 1us) {
            if (isFields[][0us]) {
                return context:.getCallOpValidator ().validate (alias context, right.getLoc (), values[][0us], []);
            }

            values[][0us]
        } else {
            // for v, i in values {
            //     if (isFields[i]) {
            //         (alias values) [i] = context:.getCallOpValidator ().validate (alias context, right.getLoc (), v, []);
            //     }
            // }

            MultSymValue::new (right.getLoc (), values[], prettyStr-> format ("%", right))
        }
    }

    /**
     * Basic fields are fields that are inside the object instance, but are not user defined (i.e. __typeinfo__, __typeid__, __monitor__)
     * @params:
     *     - context: the context of the validation
     *     - left: the object value
     *     - right: the field accessed
     * @returns: UnitValue if the access is wrong, a value otherwise
     * */
    fn validateClassBasicFieldAccess (self, dmut context : &Validator, left : &Value, right : &Expression, clRef : &ClassRefType)-> &Value {
        match right {
            v : &VarExpr => {
                let indent = context.getSubTypeValidator ().removeUnders (v.getLoc ().str ());
                if (indent == Keys::TYPEINFO) {
                    let typeinfoT = clRef.getTypeInfo ().asOf!{&Value} ().getType ();
                    return ClassTypeInfoAccessValue::new (v.getLoc (), typeinfoT, str-> left);
                }

                if (indent == Keys::TYPEID) {
                    let typeinfoV = clRef.getTypeInfo ().asOf!{&TypeInfoValue} ();
                    let nameT = typeinfoV.getName ().getType ();

                    let typeinfo = ClassTypeInfoAccessValue::new (v.getLoc (), typeinfoV.getType (), str-> left);
                    return StructFieldAccessValue::new (v.getLoc (), nameT, typeinfo, TypeInfoKeys::NAME);
                }
            }
        }

        UNIT_VALUE
    }
    
    /*!
     * ================================================================================
     * ================================================================================
     * =========================         TUPLE FIELD          =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a field access on a tuple value
     * @params: 
     *    - context: the context of the validation
     *    - loc: the location of the access
     *    - tuple: the type of the value whose field is accessed
     *    - left: the value whose content is accessed
     *    - right: the right operand of the operation
     * @returns: the result value of the access
     * @throws:
     *    - &ErrorMsg: if the access is invalid
     */
    fn validateTupleFieldOperation (self, dmut context : &Validator, loc : &Word, _ : BinaryOperators, tuple : &TupleType, left : &Value, right : &Expression)-> &Value
        throws &ErrorMsg
    {
        let rightVal = {
            context:.enterDollar (left);
            {
                context:.implicitEnumUnwrap (context:.validateValue (right))
            } exit {
                context:.exitDollar ();
            }
        } catch {
            err : &ErrorMsg => {
                throw err.withNote ([ErrorMsg::fatal (right.getLoc (), format (ValidateErrorMessage::TYPE_NO_FIELD, left.getType (), right))]);
            }
        };

        let val = context:.getCompileTimeInterpreter ().computeInt (rightVal, signed-> false);
        let arity = tuple.getInners ().len;
        
        {
            let acc = if (val < 0) {
                let _abs : usize = cast!usize (val.to!isize ().abs ());
                if (arity < _abs) throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::TUPLE_ARITY_OVERFLOW, _abs, arity));
                arity - _abs                    
            } else {
                if (arity <= val.to!usize ()) throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::TUPLE_ARITY_OVERFLOW, val, arity));
                val.to!usize ()
            };

            let innerType = tuple.getInners ()[acc];
            
            let retType = if (left.isLvalue () && tuple.isMutable ()) {
                innerType
            } else {
                innerType.clone (0u32)
            }

            return self.createTupleFieldAccess (loc, retType, left, acc);
        } catch {
            x : &ErrorMsg => throw x;
            _ => throw ErrorMsg::fatal (rightVal.getLoc (), format (ValidateErrorMessage::OVERFLOW_CAPACITY, IntType::new (rightVal.getLoc (), size-> 0u16, signed-> false), val, u64::max));
        }
    }

    /**
     * Create a tuple field access value
     * @info: optimize a bit the access if it is done on a tuple construction
     * @params:
     *    - loc: the location of the access
     *    - type: the return type
     *    - value: the left operand of the access
     *    - index: the index of the access (assumed to be overflow checked before hand)
     * */
    pub fn createTupleFieldAccess (self, loc : &Word, type : &Type, value : &Value, index : usize, reduce : bool = true)-> &Value {
        match (value, reduce) {
            (tu : &TupleValue, true) => {
                return tu.getValues ()[index]
            }
            _ => {
                cast!{&Value} (TupleFieldAccessValue::new (loc, type, value, index))
            }
        }
    }


    /*!
     * ================================================================================
     * ================================================================================
     * =========================         RANGE FIELD          =========================
     * ================================================================================
     * ================================================================================
     */


    /**
     * Validate a field operation on a range value
     * @params: 
     *    - context: the context of the validation
     *    - loc: the location of the access
     *    - op: the operator used to perform the access
     *    - range: the type of the left operand
     *    - left: the value of the left operand
     *    - right: the expression of the access (right operand)
     * @returns: a value containing the field access on the range
     * @throws:
     *    - &ErrorMsg: if the access is invalid
     */
    fn validateRangeFieldOperation (self, dmut _ : &Validator, loc : &Word, _ : BinaryOperators, range : &RangeType, left : &Value, right : &Expression)-> &Value
        throws &ErrorMsg
    {
        match right {
            field : &VarExpr => {
                match field.getLoc ().str () {
                    RangeKeys::FST | RangeKeys::SCD => {
                        let type = range.getInners ()[0];
                        return StructFieldAccessValue::new (loc, type, left, field.getLoc ().str ());
                    }
                    RangeKeys::STEP => {
                        let type = range.getInners ()[1];
                        return StructFieldAccessValue::new (loc, type, left, field.getLoc ().str ());
                    }
                    RangeKeys::CONTAIN => {
                        let type = BoolType::new (loc, isMutable-> range.isMutable ());
                        return StructFieldAccessValue::new (loc, type, left, field.getLoc ().str ());
                    }
                }
            }
        }

        throw ErrorMsg::fatal (right.getLoc (), format (ValidateErrorMessage::TYPE_NO_FIELD, left.getType (), right));
    }
    

    /*!
     * ================================================================================
     * ================================================================================
     * =======================         SLICE/ARRAY FIELD          =====================
     * ================================================================================
     * ================================================================================
     */
    
    /**
     * Validate a field operation on a slice value
     * @params:
     *    - context: the context of the validation
     *    - loc: the location of the access
     *    - slice: the type of the slice being accessed
     *    - left: the left value of the left operand
     *    - right: the expression of the access (right operand)
     * @returns: a value containing the field access on the slice
     * @throws: 
     *    - &ErrorMsg: if the access is invalid
     */
    fn validateSliceFieldOperation (self, dmut _ : &Validator, loc : &Word, _ : BinaryOperators, slice : &SliceType, left : &Value, right : &Expression)-> &Value
        throws &ErrorMsg
    {
        match right {
            field : &VarExpr => {
                match field.getLoc ().str () {
                    SliceKeys::LEN => {
                        let type = IntType::new (loc, size-> 0u16, signed-> false, isMutable-> false);
                        return StructFieldAccessValue::new (loc, type, left, field.getLoc ().str ());
                    }
                    SliceKeys::PTR => {
                        let inner = slice.getInners ()[0];
                        let ptr = PointerType::new (loc, inner, isMutable-> inner.isMutable ());
                        return StructFieldAccessValue::new (loc, ptr, left, field.getLoc ().str ());
                    }
                }
            }
        }

        throw ErrorMsg::fatal (right.getLoc (), format (ValidateErrorMessage::TYPE_NO_FIELD, left.getType (), right));
    }

    /**
     * Validate a field operation on an array value
     * @params:
     *    - context: the context of the validation
     *    - loc: the location of the access
     *    - slice: the type of the slice being accessed
     *    - left: the left value of the left operand
     *    - right: the expression of the access (right operand)
     * @returns: a value containing the field access on the slice
     * @throws: 
     *    - &ErrorMsg: if the access is invalid
     */
    fn validateArrayFieldOperation (self, dmut _ : &Validator, loc : &Word, _ : BinaryOperators, array : &ArrayType, left : &Value, right : &Expression)-> &Value
        throws &ErrorMsg
    {
        match right {
            field : &VarExpr => {
                match field.getLoc ().str () {
                    SliceKeys::LEN => {
                        return makeIntValue (loc, array.getLen ());
                    }
                    SliceKeys::PTR => {
                        let inner = array.getInners ()[0];
                        let ptr = PointerType::new (loc, inner, isMutable-> inner.isMutable ());
                        return AddressValue::new (loc, ptr, left);
                    }
                }
            }
        }
        
        throw ErrorMsg::fatal (right.getLoc (), format (ValidateErrorMessage::TYPE_NO_FIELD, left.getType (), right));
    }    

    /**
     * Validate a field operation on a option value
     * @params:
     *    - context: the context of the validation
     *    - loc: the location of the access
     *    - o: the option type being accessed
     *    - left: the left operand
     *    - right: the right operand
     * @returns: a value containins the field access on the option value
     * @throws:
     *    - &ErrorMsg: if the access is invalid
     * */
    fn validateOptionFieldOperation (self, dmut context : &Validator, loc : &Word, _ : BinaryOperators, otype : &OptionType, left : &Value, right : &Expression)-> &Value
        throws &ErrorMsg
    {
        match right {
            field : &VarExpr => {
                match field.getLoc ().str () {
                    OptionKeys::SET => {
                        let type = BoolType::new (loc);
                        return StructFieldAccessValue::new (loc, type, left, OptionKeys::SET);
                    }
                    OptionKeys::HAS_ERROR => {
                        let type = BoolType::new (loc), ptrType = PointerType::new (loc, VoidType::new (loc));
                        let isSet = UnaryBoolOperatorValue::new (loc, UnaryOperators::NOT, StructFieldAccessValue::new (loc, type, left, OptionKeys::SET));
                        let hasErr = CmpPointerOperatorValue::new (loc, BinaryOperators::NOT_EQUAL,
                                                                   OptionFieldAccessValue::new (loc, ptrType, left, OptionKeys::ERROR),
                                                                   NullValue::new (loc, ptrType));

                        return LogicalBinBoolOperatorValue::new (loc, BinaryOperators::DAND, isSet, hasErr);
                    }
                    OptionKeys::VALUE => {
                        let interpret = context.getCompileTimeInterpreter ();

                        let innerType = otype.getInners ()[0];
                        let boolType = BoolType::new (loc);
                        let isSet = interpret.reduce (UnaryBoolOperatorValue::new (loc, UnaryOperators::NOT, StructFieldAccessValue::new (loc, boolType, left, OptionKeys::SET)));
                        let value = OptionFieldAccessValue::new (loc, innerType, left, OptionKeys::VALUE);

                        match isSet { // we know at cte if the option has a value or not
                            b : &BoolValue => {
                                if (b.isTrue ()) throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::OPTION_HAS_NO_VALUE, otype)); // !x.hasValue
                                return value; // x.hasValue, thus return the value
                            }
                        }

                        let errType = context:.getExceptionFromName (loc-> loc, CoreNames::EMPTY_VAL_OPTION_EXCEPTION);
                        let errInstance = context:.constructObjectInstance (loc, errType, []);
                        let throwVal = ThrowValue::new (loc, errInstance);

                        let cond = ConditionalValue::new (loc, VOID_TYPE, isSet, throwVal, elsev-> UNIT_VALUE, isComplete-> false);

                        return BlockValue::new (loc, innerType, [cond, value], isSet-> true);
                    }
                    OptionKeys::ERROR => {
                        let type = BoolType::new (loc), ptrType = PointerType::new (loc, VoidType::new (loc));
                        let isSet = StructFieldAccessValue::new (loc, type, left, OptionKeys::SET);
                        let notHasErr = CmpPointerOperatorValue::new (loc, BinaryOperators::DEQUAL,
                                                                   OptionFieldAccessValue::new (loc, ptrType, left, OptionKeys::ERROR),
                                                                   NullValue::new (loc, ptrType));

                        let setOrNotHasError = context.getCompileTimeInterpreter ().reduce (LogicalBinBoolOperatorValue::new (loc, BinaryOperators::DPIPE, isSet, notHasErr));
                        let innerType = context:.getExceptionType (loc-> loc);

                        let value = OptionFieldAccessValue::new (loc, innerType, left, OptionKeys::ERROR);
                        match setOrNotHasError {
                            b : &BoolValue => {
                                if (b.isTrue ()) throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::OPTION_HAS_NO_ERROR, otype));
                                return value;
                            }
                        }

                        let errType = context:.getExceptionFromName (loc-> loc, CoreNames::EMPTY_ERR_OPTION_EXCEPTION);
                        let errInstance = context:.constructObjectInstance (loc, errType, []);
                        let throwVal = ThrowValue::new (loc, errInstance);

                        let cond = ConditionalValue::new (loc, VOID_TYPE, setOrNotHasError, throwVal, elsev-> UNIT_VALUE, isComplete-> false);

                        return BlockValue::new (loc, errType, [cond, value], isSet-> true);
                    }
                }
            }
        }

        throw ErrorMsg::fatal (right.getLoc (), format (ValidateErrorMessage::TYPE_NO_FIELD, left.getType (), right));
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================            MODULE            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a binary operation involving a module operator (left operand can be a type or a value)
     * @params: 
     *   - context: the context of the validation
     *   - bin: the binary expression to validate
     * @returns: the validated value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    pub fn validateModuleOperation (self, dmut context : &Validator, _ : BinaryOperators, bin : &BinaryExpr)-> &Value
        throws &ErrorMsg
    {
        let left = { // we catch that because it may not be a value, but still valid
            context:.implicitEnumUnwrap (context:.validateValue (bin.getLeft ()))
        } catch {
            err : &ErrorMsg => {
                let ltype = { // We try to validate the left operand as a type, (e.g. 'i32::init' is a value, but left operand is a type)
                    context:.validateType (bin.getLeft ())
                } catch {
                    _ => {
                        throw err;
                    }
                }

                // If the left operand is a type, there is another specific validator for that
                return context:.getSubTypeValidator ().validateValueFromType (alias context, bin.getLoc (), ltype, bin.getRight ()); 
            }
        }

        self.validateModuleOperation (alias context, bin.getLoc (), left, bin.getRight ())                                                                                                     
    }
    
    /**
     * Validate a binary operation involving a module operator (the left operand has to be a value)
     * @params: 
     *   - context: the context of the validation
     *   - bin: the binary expression to validate
     * @returns: the validated value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    pub fn validateModuleOperation (self, dmut context : &Validator, bin : &PathExpr)-> &Value
        throws & ErrorMsg
    {
        let left = context:.implicitEnumUnwrap (context:.validateValue (bin.getLeft ()));
        self.validateModuleOperation (alias context, bin.getLoc (), left, bin.getRight ())
    }

    /**
     * Validate a binary module operation 
     * @params: 
     *   - context: the context of the validation
     *   - loc: the location of the operation
     *   - left: the left operand 
     *   - right: the right operand 
     * @returns: the validated value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    fn validateModuleOperation (self, dmut context : &Validator, loc : &Word, left : &Value, right : &Expression)-> &Value
        throws &ErrorMsg
    {
        let mut errorNotes : [&ErrorMsg] = [];
        match right {
            v : &VarExpr => { // Access of submodule is only made by var names
                match left {
                    md : &ModuleRefValue => { // If it is a module that's simple
                        let dmut res = context:.getLocalFromMod (md, v.getLoc ().str ());
                        if (res.len != 0us) { // There are symbols whose name are 'v.getLoc ().str ()'
                            return context:.getLiteralValidator ().validateMultSymbols (loc, alias context, alias res);
                        }

                        errorNotes = context:.createLocalVarError (v.getLoc (), md, v.getLoc ().str ());
                    }
                    ms : &MultSymValue => { // The left operand returned multiple symbols
                        let dmut all = Vec!{dmut &Symbol}::new ();
                        let dmut errors = Vec!{&ErrorMsg}::new ();
                        for c in ms.getValues () {
                            match c {
                                md : &ModuleRefValue => { // Some of them are modules, so we can sub access them using var 'v'
                                    let dmut res = context:.getLocalFromMod (md, v.getLoc ().str ());
                                    for i in 0us .. res.len { all:.push (alias res[i]); }
                                    if (res.len == 0us) {
                                        let lerr = context:.createLocalVarError (v.getLoc (), md, v.getLoc ().str ());
                                        for l in lerr { errors:.push (l); }
                                    }
                                }
                            }
                        }
                        
                        if (all.len () != 0us) { // There are symbols whose name are 'v.getLoc ().str ()'
                            return context:.getLiteralValidator ().validateMultSymbols (loc, alias context, alias (alias all)[]);
                        }

                        errorNotes = errors[];
                    }
                }
            }
        }

        throw ErrorMsg::fatal (loc,
                               format (ValidateErrorMessage::UNDEFINED_BIN_MOD_OP, loc.str (), left, right),
                               notes-> errorNotes);
    }
    
    /*!
     * ================================================================================
     * ================================================================================
     * =========================         AFFECTATION          =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate an affectation operation, where the operator can be anything the result being stored in the left operatand of the operation
     * @params: 
     *   - context: the context of the validation
     *   - op: the operator (can be a None operator, i.e. just a simple affectation)
     *   - bin: the binary expression to validate
     * @returns: the validated value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    fn validateAffectOperation (self, dmut context : &Validator, op : BinaryOperators, bin : &BinaryExpr)-> &Value
        throws &ErrorMsg
    {
        let dmut errors = Vec!{&ErrorMsg}::new ();
        match bin.getLeft () { // Affection can be an index assign operation
            m : &MultOperatorExpr => { // in that case left operand is an index operation
                if (m.getLoc () == Tokens::LCRO && m.getEndLocation () == Tokens::RCRO) {
                    {
                        // We try the operation rewrite
                        return self.validateIndexAssignOperation (alias context, op, m, bin);
                    } catch { // if it fails we store the error, in case simple affectation also fails, to show precise error
                        err : &ErrorMsg => errors:.push (err);
                    }
                }
            }
        };

        let left = context:.validateValue (bin.getLeft (), noReduce-> true);
        context.verifyLeftOperandMove (bin.getLoc (), left);

        // We validate right only now, because it is not needed if the left value is immutable, or not a lvalue
        let right = self.validateAffectRight (alias context, op, left, bin);

        // Important part, now we verify memory movement
        context:.verifyMemoryOwner (bin.getLoc (), left.getType (), right, construct-> false, byReference-> false);

        // simply returns an affectation value, the affectation is possible
        AffectValue::new (bin.getLoc (), left.getType (), left, right)
    }

    /**
     * @returns: true iif the right operand in a bin affectation can change due to implicit casting (e.g. i(i8) += 1;)
     * */
    fn canImplicitCastBinAffect (self, type : &Type)-> bool {
        match type {
            IntType () => { true }
            FloatType () => { true }
            _ => { false }
        }
    }

    /**
     * Validate an op index assign operation
     * @params: 
     *    - context: the context of the validation
     *    - op: the math operator associated with the operation (if any, BinaryOperators::EQUAL if none)
     *    - bin: the binary operation to validate
     * @returns: a value containing the rewrite
     * @throws:
     *    - &ErrorMsg: if the operator cannot be rewritten, or there is an error in the validation of the operands
     */
    fn validateIndexAssignOperation (self, dmut context : &Validator, op : BinaryOperators, leftExpr : &MultOperatorExpr, bin : &BinaryExpr)-> &Value
        throws &ErrorMsg
    {
        let leftIndex = context:.validateValue (leftExpr.getLeft (), noReduce-> true);

        // Index assign can be overriden for classes
        if (op == BinaryOperators::EQUAL && leftIndex.getType ().isOf!{&ClassPtrType} ()) {
            // TODO
            __pragma!panic ();
            // return context:.getIndexOpValidator ().validateIndexAssign (alias context, op, leftIndex, bin);
        }

        // Otherwise it is just an affectation of a slice/array access
        let rewriteLeft = MultOperatorExpr::new (leftExpr.getLoc (), leftExpr.getEndLocation (), ValueWrapperExpr::new (leftIndex.getLoc (), leftIndex), leftExpr.getRights (), canBeDotCall-> false);
        let left = context:.getIndexOpValidator ().validate (alias context, rewriteLeft);
        context.verifyLeftOperandMove (bin.getLoc (), left);

        // We validate right only now, because it is not needed if the left value is immutable, or not a lvalue
        let right = self.validateAffectRight (alias context, op, left, bin);

        // Important part, now we verify memory movement
        context:.verifyMemoryOwner (bin.getLoc (), left.getType (), right, construct-> false, byReference-> false);

        // return an index affect value, because left operand is a index operation
        AffectValue::new (bin.getLoc (), left.getType (), left, right)
    }

    /**
     * Validate the right operand of an affectation
     * @params:
     *    - context: the context of the validation
     *    - op: the operator used in the operation
     *    - left: the left value
     *    - bin: the binary expression
     * @returns: the validated right operand (already transformed if the op is special, e.g. for 'a += 1' returns 'a + 1')
     * */
    fn validateAffectRight (self, dmut context : &Validator, op : BinaryOperators, left : &Value, bin : &BinaryExpr)-> &Value
        throws &ErrorMsg
    {
        // The right operand can be a math operation (e.g. a += 1, b /= 98)
        if (op != BinaryOperators::EQUAL) {
            let realRight = context:.validateValue (bin.getRight ());
            let castedRight = if self.canImplicitCastBinAffect (left.getType ()) { // we want to be able to validate: { let i : i8 = 1i8; i += 1; }, only valid for a few types, (float, int)
                context:.verifyCompatibleTypeWithValue (bin.getLoc (), left.getType (), realRight, byReference-> false) // so we need to take that into account immediately, because (i + 1) is of type i32, and not cte
            } else {
                realRight
            };

            let rewrittenBin = BinaryExpr::new (bin.getLoc (), ValueWrapperExpr::new (left.getLoc (), left), ValueWrapperExpr::new (castedRight.getLoc (), castedRight));
            let res = self.validateMathOperation (alias context, op, rewrittenBin);
            context:.verifyCompatibleTypeWithValue (bin.getLoc (), left.getType (), res, byReference-> false)
        } else { // else it is just a standard affectation, so right is directly right
            let right = context:.validateValue (bin.getRight ());
            context:.verifyCompatibleTypeWithValue (bin.getLoc (), left.getType (), right, byReference-> false) // verify the type compatibility, and return the casted value if needed
        }
    }


    /*!
     * ================================================================================
     * ================================================================================
     * =========================       STRUCT / CLASS         =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a binary operator (math, set, range or bitwise) assuming that the left operand is a struct
     * @params: 
     *   - context: the context of the validation
     *   - loc: the location of the operation
     *   - op: the operator
     *   - left: the left operand (assumed to be a struct type operand)
     *   - right: the right operand
     * @returns: the result value (generally a call value)
     * @throws: 
     *   - &ErrorMsg: if the operation is invalid
     */
    fn validateStructOpLeft (self, dmut context : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Value)-> &Value
        throws &ErrorMsg
    {
        // Transform the operator into a string expression 
        let strExpr = StringExpr::new (loc, loc, op);
        
        // The template to put the operator as the first template parameter (opBinary!{op})
        let templCall = TemplateCallExpr::new (loc,
                                               VarExpr::new (Word::new (CoreNames::BIN_OP_OVERRIDE, loc)),
                                               [strExpr]);

        // Call the template with the correct parameters (opBinary!{op} (left, right))
        let syntCall = MultOperatorExpr::new (Word::new (Tokens::LPAR, loc), Word::new (Tokens::RPAR, loc),
                                              templCall,
                                              [ValueWrapperExpr::new (left.getLoc (), left),
                                               ValueWrapperExpr::new (right.getLoc (), right)], canBeDotCall-> false);

        {
            context:.validateValue (syntCall)
        } catch {
            err : &ErrorMsg => { // In case of error show the location of the rewritte for clearer errors 
                throw ErrorMsg::note (loc, ValidateErrorMessage::VALIDATING, notes-> [err]);
            }
        }
    }

    /**
     * Validate a binary operator (math, set, range or bitwise) assuming that the right operand is a struct
     * @params: 
     *   - context: the context of the validation
     *   - loc: the location of the operation
     *   - op: the operator
     *   - left: the left operand 
     *   - right: the right operand (assumed to be a struct type operand)
     * @returns: the result value (generally a call value)
     * @throws: 
     *   - &ErrorMsg: if the operation is invalid
     */    
    fn validateStructOpRight (self, dmut context : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Value)-> &Value
        throws &ErrorMsg
    {
        // Transform the operator into a string expression 
        let strExpr = StringExpr::new (loc, loc, op);
        
        // The template to put the operator as the first template parameter (opBinaryRight!{op})
        let templCall = TemplateCallExpr::new (loc,
                                               VarExpr::new (Word::new (CoreNames::BIN_OP_RIGHT_OVERRIDE, loc)),
                                               [strExpr]);

        // Call the template with the correct parameters (opBinaryRight!{op} (right, left))
        let syntCall = MultOperatorExpr::new (Word::new (Tokens::LPAR, loc), Word::new (Tokens::RPAR, loc),
                                              templCall,
                                              [ValueWrapperExpr::new (right.getLoc (), right),
                                               ValueWrapperExpr::new (left.getLoc (), left)], canBeDotCall-> false);

        context:.validateValue (syntCall) // We don't catch the error, we assume that if we are here then 'as left' was tried
    }    
    
    /**
     * Validate a binary operator (math, set, range or bitwise) assuming that the left operand is a class ptr
     * @params: 
     *   - context: the context of the validation
     *   - loc: the location of the operation
     *   - op: the operator
     *   - left: the left operand (assumed to be a class ptr type operand)
     *   - right: the right operand
     * @returns: the result value (generally a call value)
     * @throws: 
     *   - &ErrorMsg: if the operation is invalid
     */
    fn validateClassOpLeft (self, dmut context : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Value)-> &Value
        throws &ErrorMsg
    {
        // Transform the operator into a string expression 
        let strExpr = StringExpr::new (loc, loc, op);
        
        // Unlike structure, the function is called as a method (left.opBinary);
        let dotOp = BinaryExpr::new (Word::new (Tokens::DOT, loc),
                                     ValueWrapperExpr::new (left.getLoc (), left),
                                     VarExpr::new (Word::new (CoreNames::BIN_OP_OVERRIDE, loc)));

        // The template to put the operator as the first template parameter (left.opBinary!{op})
        let templCall = TemplateCallExpr::new (loc,
                                               dotOp,
                                               [strExpr]);
        
        // Call the template with the correct parameters (left.opBinary!{op} (right))
        let syntCall = MultOperatorExpr::new (Word::new (Tokens::LPAR, loc), Word::new (Tokens::RPAR, loc),
                                              templCall,
                                              [ValueWrapperExpr::new (right.getLoc (), right)], canBeDotCall-> false);

        {
            context:.validateValue (syntCall)
        } catch {
            err : &ErrorMsg => { // In case of error show the location of the rewritte for clearer errors 
                throw ErrorMsg::note (loc, ValidateErrorMessage::VALIDATING, notes-> [err]);
            }
        }
    }

    /**
     * Validate a binary operator (math, set, range or bitwise) assuming that the right operand is a class ptr
     * @params: 
     *   - context: the context of the validation
     *   - loc: the location of the operation
     *   - op: the operator
     *   - left: the left operand 
     *   - right: the right operand (assumed to be a class ptr type operand)
     * @returns: the result value (generally a call value)
     * @throws: 
     *   - &ErrorMsg: if the operation is invalid
     */    
    fn validateClassOpRight (self, dmut context : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Value)-> &Value
        throws &ErrorMsg
    {
        // Transform the operator into a string expression 
        let strExpr = StringExpr::new (loc, loc, op);

        // Unlike structure, the function is called as a method (right.opBinaryRight);
        let dotOp = BinaryExpr::new (Word::new (Tokens::DOT, loc),
                                     ValueWrapperExpr::new (right.getLoc (), right),
                                     VarExpr::new (Word::new (CoreNames::BIN_OP_RIGHT_OVERRIDE, loc)));
        
        // The template to put the operator as the first template parameter (right.opBinaryRight!{op})
        let templCall = TemplateCallExpr::new (loc,
                                               dotOp,
                                               [strExpr]);

        // Call the template with the correct parameters (right.opBinaryRight!{op} (left))
        let syntCall = MultOperatorExpr::new (Word::new (Tokens::LPAR, loc), Word::new (Tokens::RPAR, loc),
                                              templCall,
                                              [ValueWrapperExpr::new (left.getLoc (), left)], canBeDotCall-> false);

        context:.validateValue (syntCall) // We don't catch the error, we assume that if we are here then 'as left' was tried
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================     STRUCT / CLASS (CMP)     =========================
     * ================================================================================
     * ================================================================================
     */
    
    /**
     * Validate a binary comparison operator assuming that the left operand is a struct
     * @params: 
     *   - context: the context of the validation
     *   - loc: the location of the operation
     *   - op: the operator
     *   - left: the left operand (assumed to be a struct type operand)
     *   - right: the right operand
     * @returns: the result value (generally a call value)
     * @throws: 
     *   - &ErrorMsg: if the operation is invalid
     */
    fn validateStructCmpOpLeft (self, dmut context : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Value)-> &Value
        throws &ErrorMsg
    {        
        // Call the template with the correct parameters (opCmp (left, right))
        let syntCall = MultOperatorExpr::new (Word::new (Tokens::LPAR, loc), Word::new (Tokens::RPAR, loc),
                                              VarExpr::new (Word::new (CoreNames::CMP_OP_OVERRIDE, loc)),
                                              [ValueWrapperExpr::new (left.getLoc (), left),
                                               ValueWrapperExpr::new (right.getLoc (), right)], canBeDotCall-> false);
        
        {
            let valueCall = context:.validateValue (syntCall);
            
            // Cast the value 0 to the type of the return type of the function
            // The only thing that is necessary is that it returns a signed int value no matter the size
            let syntCast = CastExpr::new (loc,
                                          TypeWrapperExpr::new (loc, valueCall.getType ()),
                                          ValueWrapperExpr::new (loc, makeIntValue (loc, 0is)));

            // Compare the value of the call to 0 using the operator provided by the source code ('op')
            let syntTest = BinaryExpr::new (Word::new (op, loc), ValueWrapperExpr::new (loc, valueCall), syntCast);
            
            // Validate the final rewritten value
            context:.validateValue (syntTest)
        } catch {
            err : &ErrorMsg => { // In case of error show the location of the rewritte for clearer errors 
                throw ErrorMsg::note (loc, ValidateErrorMessage::VALIDATING, notes-> [err]);
            }
        }
    }

    /**
     * Validate a binary comparison operator assuming that the right operand is a struct
     * @params: 
     *   - context: the context of the validation
     *   - loc: the location of the operation
     *   - op: the operator
     *   - left: the left operand 
     *   - right: the right operand (assumed to be a struct type operand)
     * @returns: the result value (generally a call value)
     * @throws: 
     *   - &ErrorMsg: if the operation is invalid
     */    
    fn validateStructCmpOpRight (self, dmut context : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Value)-> &Value
        throws &ErrorMsg
    {
        // Call the template with the correct parameters (opCmp (left, right))
        let syntCall = MultOperatorExpr::new (Word::new (Tokens::LPAR, loc), Word::new (Tokens::RPAR, loc),
                                              VarExpr::new (Word::new (CoreNames::CMP_OP_OVERRIDE, loc)),
                                              [ValueWrapperExpr::new (right.getLoc (), right),
                                               ValueWrapperExpr::new (left.getLoc (), left)], canBeDotCall-> false);
        
        let valueCall = context:.validateValue (syntCall);
        
        // Cast the value 0 to the type of the return type of the function
        // The only thing that is necessary is that it returns a signed int value no matter the size
        let syntCast = CastExpr::new (loc,
                                      TypeWrapperExpr::new (loc, valueCall.getType ()),
                                      ValueWrapperExpr::new (loc, makeIntValue (loc, 0is)));
        
        // Compare the value of the call to 0 using the operator provided by the source code ('op')
        let syntTest = BinaryExpr::new (Word::new (self.inverseCmpOp (op), loc), ValueWrapperExpr::new (loc, valueCall), syntCast);
        
        // Validate the final rewritten value
        context:.validateValue (syntTest) // We don't catch the error, we assume that if we are here then 'as left' was tried
    }

    
    /**
     * Validate a binary comparison operator assuming that the left operand is a class ptr
     * @params: 
     *   - context: the context of the validation
     *   - loc: the location of the operation
     *   - op: the operator
     *   - left: the left operand (assumed to be a class ptr type operand)
     *   - right: the right operand
     * @returns: the result value (generally a call value)
     * @throws: 
     *   - &ErrorMsg: if the operation is invalid
     */
    fn validateClassCmpOpLeft (self, dmut context : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Value)-> &Value
        throws &ErrorMsg
    {        
        // Unlike structure, the function is called as a method (left.opCmp);
        let dotOp = BinaryExpr::new (Word::new (Tokens::DOT, loc),
                                     ValueWrapperExpr::new (left.getLoc (), left),
                                     VarExpr::new (Word::new (CoreNames::CMP_OP_OVERRIDE, loc)));
        
        // Call the template with the correct parameters (left.opCmp (right))
        let syntCall = MultOperatorExpr::new (Word::new (Tokens::LPAR, loc), Word::new (Tokens::RPAR, loc),
                                              dotOp,
                                              [ValueWrapperExpr::new (right.getLoc (), right)], canBeDotCall-> false);

        {
            let valueCall = context:.validateValue (syntCall);
            
            // Cast the value 0 to the type of the return type of the function
            // The only thing that is necessary is that it returns a signed int value no matter the size
            let syntCast = CastExpr::new (loc,
                                          TypeWrapperExpr::new (loc, valueCall.getType ()),
                                          ValueWrapperExpr::new (loc, makeIntValue (loc, 0is)));

            // Compare the value of the call to 0 using the operator provided by the source code ('op')
            let syntTest = BinaryExpr::new (Word::new (op, loc), ValueWrapperExpr::new (loc, valueCall), syntCast);
            
            // Validate the final rewritten value
            context:.validateValue (syntTest)
        } catch {
            err : &ErrorMsg => { // In case of error show the location of the rewritte for clearer errors 
                throw ErrorMsg::note (loc, ValidateErrorMessage::VALIDATING, notes-> [err]);
            }
        }
    }

    /**
     * Validate a binary comparison operator assuming that the right operand is a class ptr
     * @params: 
     *   - context: the context of the validation
     *   - loc: the location of the operation
     *   - op: the operator
     *   - left: the left operand 
     *   - right: the right operand (assumed to be a class ptr type operand)
     * @returns: the result value (generally a call value)
     * @throws: 
     *   - &ErrorMsg: if the operation is invalid
     */    
    fn validateClassCmpOpRight (self, dmut context : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Value)-> &Value
        throws &ErrorMsg
    {
        // Unlike structure, the function is called as a method (left.opCmp);
        let dotOp = BinaryExpr::new (Word::new (Tokens::DOT, loc),
                                     ValueWrapperExpr::new (right.getLoc (), right),
                                     VarExpr::new (Word::new (CoreNames::CMP_OP_OVERRIDE, loc)));
        
        // Call the template with the correct parameters (left.opCmp (right))
        let syntCall = MultOperatorExpr::new (Word::new (Tokens::LPAR, loc), Word::new (Tokens::RPAR, loc),
                                              dotOp,
                                              [ValueWrapperExpr::new (left.getLoc (), left)], canBeDotCall-> false);

        
        let valueCall = context:.validateValue (syntCall);
        
        // Cast the value 0 to the type of the return type of the function
        // The only thing that is necessary is that it returns a signed int value no matter the size
        let syntCast = CastExpr::new (loc,
                                      TypeWrapperExpr::new (loc, valueCall.getType ()),
                                      ValueWrapperExpr::new (loc, makeIntValue (loc, 0is)));

        // Compare the value of the call to 0 using the operator provided by the source code ('op')
        let syntTest = BinaryExpr::new (Word::new (self.inverseCmpOp (op), loc), ValueWrapperExpr::new (loc, valueCall), syntCast);
        
        // Validate the final rewritten value
        context:.validateValue (syntTest) // We don't catch the error, we assume that if we are here then 'as left' was tried
    }

    /**
     * Inverse the comparison operator such that 'a op b', is equivalent to 'b inverse(op) a'
     * @example:
     * ==================
     * a > b // b < a
     * a >= b // b <= a
     * ==================
     * @panic: if op is not a compare operator 
     * @params: 
     *   - op: the operator to inverse 
     * @returns: the inversed operator
     */
    fn inverseCmpOp (self, op : BinaryOperators)-> BinaryOperators {
        match op {
            BinaryOperators::INF => { BinaryOperators::SUP } 
            BinaryOperators::SUP => { BinaryOperators::INF }
            BinaryOperators::INF_EQUAL => { BinaryOperators::SUP_EQUAL }
            BinaryOperators::SUP_EQUAL => { BinaryOperators::INF_EQUAL }
            BinaryOperators::NOT_EQUAL => { BinaryOperators::NOT_EQUAL }
            BinaryOperators::DEQUAL => { BinaryOperators::DEQUAL }
            _ => {
                __pragma!panic ();
            }
        }
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================    STRUCT / CLASS (RANGE)    =========================
     * ================================================================================
     * ================================================================================
     */
    
    /**
     * Validate a binary range operator assuming that the left operand is a struct
     * @params: 
     *   - context: the context of the validation
     *   - loc: the location of the operation
     *   - op: the operator
     *   - left: the left operand (assumed to be a struct type operand)
     *   - right: the right operand
     * @returns: the result value (generally a call value)
     * @throws: 
     *   - &ErrorMsg: if the operation is invalid
     */
    fn validateStructRangeOpLeft (self, dmut context : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Value)-> &Value
        throws &ErrorMsg
    {
        // Template call of the range operator (opRange!{op == BinaryOperators::TDOT})
        let templCall = TemplateCallExpr::new (loc, 
                                               VarExpr::new (Word::new (CoreNames::RANGE_OP_OVERRIDE, loc)),
                                               [ValueWrapperExpr::new (loc, BoolValue::new (loc, op == BinaryOperators::TDOT))]);
        
        // Call the template with the correct parameters (opRange!{op == BinaryOperators::TDOT} (left, right))
        let syntCall = MultOperatorExpr::new (Word::new (Tokens::LPAR, loc), Word::new (Tokens::RPAR, loc),
                                              templCall,
                                              [ValueWrapperExpr::new (left.getLoc (), left),
                                               ValueWrapperExpr::new (right.getLoc (), right)], canBeDotCall-> false);

        {
            context:.validateValue (syntCall)
        } catch {
            err : &ErrorMsg => { // In case of error show the location of the rewritte for clearer errors 
                throw ErrorMsg::note (loc, ValidateErrorMessage::VALIDATING, notes-> [err]);
            }
        }
    }

    /**
     * Validate a binary range operator assuming that the right operand is a struct
     * @params: 
     *   - context: the context of the validation
     *   - loc: the location of the operation
     *   - op: the operator
     *   - left: the left operand 
     *   - right: the right operand (assumed to be a struct type operand)
     * @returns: the result value (generally a call value)
     * @throws: 
     *   - &ErrorMsg: if the operation is invalid
     */    
    fn validateStructRangeOpRight (self, dmut context : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Value)-> &Value
        throws &ErrorMsg
    {
        // Template call of the range operator (opRangeRight!{op == BinaryOperators::TDOT})
        let templCall = TemplateCallExpr::new (loc, 
                                               VarExpr::new (Word::new (CoreNames::RANGE_OP_RIGHT_OVERRIDE, loc)),
                                               [ValueWrapperExpr::new (loc, BoolValue::new (loc, op == BinaryOperators::TDOT))]);
            
        // Call the template with the correct parameters (opRangeRight!{op == BinaryOperators::TDOT} (right, left))
        let syntCall = MultOperatorExpr::new (Word::new (Tokens::LPAR, loc), Word::new (Tokens::RPAR, loc),
                                              templCall,
                                              [ValueWrapperExpr::new (right.getLoc (), right),
                                               ValueWrapperExpr::new (left.getLoc (), left)], canBeDotCall-> false);
        
        
        context:.validateValue (syntCall) // We don't catch the error, we assume that if we are here then 'as left' was tried       
    }

    
    /**
     * Validate a binary range operator assuming that the left operand is a class ptr
     * @params: 
     *   - context: the context of the validation
     *   - loc: the location of the operation
     *   - op: the operator
     *   - left: the left operand (assumed to be a class ptr type operand)
     *   - right: the right operand
     * @returns: the result value (generally a call value)
     * @throws: 
     *   - &ErrorMsg: if the operation is invalid
     */
    fn validateClassRangeOpLeft (self, dmut context : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Value)-> &Value
        throws &ErrorMsg
    {        
        // Unlike structure, the function is called as a method (left.opRange);
        let dotOp = BinaryExpr::new (Word::new (Tokens::DOT, loc),
                                     ValueWrapperExpr::new (left.getLoc (), left),
                                     VarExpr::new (Word::new (CoreNames::RANGE_OP_OVERRIDE, loc)));

        // Template call of the range operator (left.opRange!{op == BinaryOperators::TDOT})
        let templCall = TemplateCallExpr::new (loc, 
                                               dotOp,
                                               [ValueWrapperExpr::new (loc, BoolValue::new (loc, op == BinaryOperators::TDOT))]);
        
        // Call the function with the correct parameters (left.opRange!{op == BinaryOperators::TDOT} (right))
        let syntCall = MultOperatorExpr::new (Word::new (Tokens::LPAR, loc), Word::new (Tokens::RPAR, loc),
                                              templCall,
                                              [ValueWrapperExpr::new (right.getLoc (), right)], canBeDotCall-> true);
        
        {
            context:.validateValue (syntCall)
        } catch {
            err : &ErrorMsg => { // In case of error show the location of the rewritte for clearer errors 
                throw ErrorMsg::note (loc, ValidateErrorMessage::VALIDATING, notes-> [err]);
            }
        }
    }

    /**
     * Validate a binary range operator assuming that the right operand is a class ptr
     * @params: 
     *   - context: the context of the validation
     *   - loc: the location of the operation
     *   - op: the operator
     *   - left: the left operand 
     *   - right: the right operand (assumed to be a class ptr type operand)
     * @returns: the result value (generally a call value)
     * @throws: 
     *   - &ErrorMsg: if the operation is invalid
     */    
    fn validateClassRangeOpRight (self, dmut context : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Value)-> &Value
        throws &ErrorMsg
    {
        // Unlike structure, the function is called as a method (right.opRangeRight);
        let dotOp = BinaryExpr::new (Word::new (Tokens::DOT, loc),
                                     ValueWrapperExpr::new (right.getLoc (), right),
                                     VarExpr::new (Word::new (CoreNames::RANGE_OP_RIGHT_OVERRIDE, loc)));

        // Template call of the range operator (right.opRangeRight!{op == BinaryOperators::TDOT})
        let templCall = TemplateCallExpr::new (loc, 
                                               dotOp,
                                               [ValueWrapperExpr::new (loc, BoolValue::new (loc, op == BinaryOperators::TDOT))]);
        
        // Call the function with the correct parameters (right.opRangeRight!{op == BinaryOperators::TDOT} (left))
        let syntCall = MultOperatorExpr::new (Word::new (Tokens::LPAR, loc), Word::new (Tokens::RPAR, loc),
                                              templCall,
                                              [ValueWrapperExpr::new (left.getLoc (), left)], canBeDotCall-> false);
                
        context:.validateValue (syntCall) // We don't catch the error, we assume that if we are here then 'as left' was tried              
    }

    
    /*!
     * ================================================================================
     * ================================================================================
     * =========================            COMMON            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Get the max size between two sizeof types (0 being the biggest)
     * */
    fn getMaxSize (self, left : u16, right : u16)-> u16 {
        if (left == 0u16 || right == 0u16) { 0u16 }
        else comparison::max (left, right)
    }

    /**
     * @returns: true if the size of left is bigger than right (0 being the biggest)
     * */
    fn isMax (self, left : u16, right : u16) -> bool {
        if (left == 0u16) return true;
        else if (right == 0u16) return false;
        return left >= right;
    }
    
    /**
     * Transform the word into a valid operator
     * @assume: the operator is valid
     * @params: 
     *   - op: the operator
     * @returns: 
     *   - .0: the operator
     *   - .1: true iif the operator is an affectation operator (e.g. +=, -=)
     *   - .2: true iif the operator is a math operator (e.g. +, -)
     *   - .3: true iif the operator is a logical operator (e.g. >=, <=, ==)
     *   - .4: true iif the operator is a range operator (.., ...)
     */
    fn toOperator (self, op : &Word)-> (BinaryOperators, bool, OperatorType)
        throws &ErrorMsg
    {
        match op.str () {
            BinaryOperators::EQUAL => { (BinaryOperators::EQUAL, true, OperatorType::NONE) }
            
            BinaryOperators::DIV_AFF => { (BinaryOperators::DIV, true, OperatorType::MATH) }
            BinaryOperators::MINUS_AFF => { (BinaryOperators::MINUS, true, OperatorType::MATH) }
            BinaryOperators::PLUS_AFF => { (BinaryOperators::PLUS, true, OperatorType::MATH) }
            BinaryOperators::STAR_AFF => { (BinaryOperators::STAR, true, OperatorType::MATH) }
            BinaryOperators::PERCENT_AFF => { (BinaryOperators::PERCENT, true, OperatorType::MATH) }
            
            BinaryOperators::TILDE_AFF => { (BinaryOperators::TILDE, true, OperatorType::SET) }
            
            BinaryOperators::LEFTD_AFF => { (BinaryOperators::LEFTD, true, OperatorType::BITWISE) }
            BinaryOperators::RIGHTD_AFF => { (BinaryOperators::RIGHTD, true, OperatorType::BITWISE) }
            
            BinaryOperators::DPIPE => { (BinaryOperators::DPIPE, false, OperatorType::LOGICAL) }
            BinaryOperators::DAND => { (BinaryOperators::DAND, false, OperatorType::LOGICAL) }
            
            BinaryOperators::INF => { (BinaryOperators::INF, false, OperatorType::COMPARISON) } 
            BinaryOperators::SUP => { (BinaryOperators::SUP, false, OperatorType::COMPARISON) }
            BinaryOperators::INF_EQUAL => { (BinaryOperators::INF_EQUAL, false, OperatorType::COMPARISON)  }
            BinaryOperators::SUP_EQUAL => { (BinaryOperators::SUP_EQUAL, false, OperatorType::COMPARISON) }
            BinaryOperators::NOT_EQUAL => { (BinaryOperators::NOT_EQUAL, false, OperatorType::COMPARISON) }
            BinaryOperators::DEQUAL => { (BinaryOperators::DEQUAL, false, OperatorType::COMPARISON) }
            BinaryOperators::CONGRUENT => { (BinaryOperators::CONGRUENT, false, OperatorType::FLOAT_COMPARISON) }
            BinaryOperators::UNCONGRUENT => { (BinaryOperators::UNCONGRUENT, false, OperatorType::FLOAT_COMPARISON) }


            BinaryOperators::OF => { (BinaryOperators::OF, false, OperatorType::TYPE) }
            BinaryOperators::NOT_OF => { (BinaryOperators::NOT_OF, false, OperatorType::TYPE) }
            
            BinaryOperators::IS => { (BinaryOperators::IS, false, OperatorType::POINTER) }
            BinaryOperators::NOT_IS => { (BinaryOperators::NOT_IS, false, OperatorType::POINTER) }

            BinaryOperators::TDOT => { (BinaryOperators::TDOT, false, OperatorType::RANGE) }
            BinaryOperators::DDOT => { (BinaryOperators::DDOT, false, OperatorType::RANGE) }
            
            BinaryOperators::LEFTD => { (BinaryOperators::LEFTD, false, OperatorType::BITWISE) }
            BinaryOperators::RIGHTD => { (BinaryOperators::RIGHTD, false, OperatorType::BITWISE) }
            BinaryOperators::PIPE => { (BinaryOperators::PIPE, false, OperatorType::BITWISE) }  
            BinaryOperators::XOR => { (BinaryOperators::XOR, false, OperatorType::BITWISE) } 
            BinaryOperators::AND => { (BinaryOperators::AND, false, OperatorType::BITWISE) }

            BinaryOperators::IN => { (BinaryOperators::IN, false, OperatorType::SET) }
            BinaryOperators::NOT_IN => { (BinaryOperators::NOT_IN, false, OperatorType::SET) }
            BinaryOperators::TILDE => { (BinaryOperators::TILDE, false, OperatorType::SET) }
            
            BinaryOperators::PLUS => { (BinaryOperators::PLUS, false, OperatorType::MATH) }
            BinaryOperators::MINUS => { (BinaryOperators::MINUS, false, OperatorType::MATH) }
            BinaryOperators::STAR => { (BinaryOperators::STAR, false, OperatorType::MATH) } 
            BinaryOperators::PERCENT => { (BinaryOperators::PERCENT, false, OperatorType::MATH) }
            BinaryOperators::DIV => { (BinaryOperators::DIV, false, OperatorType::MATH) }
            BinaryOperators::DXOR => { (BinaryOperators::DXOR, false, OperatorType::MATH) }
            
            BinaryOperators::DOT => { (BinaryOperators::DOT, false, OperatorType::FIELD) }
            BinaryOperators::DOT_AND => { (BinaryOperators::DOT_AND, false, OperatorType::FIELD) }
            
            BinaryOperators::DCOLON => { (BinaryOperators::DCOLON, false, OperatorType::MODULE) }
            _ => {
                throw ErrorMsg::fatal (op, format (ValidateErrorMessage::UNDEFINED_BIN_OP_TOK, op.str ()));
            }        
        }
    }
    
}
