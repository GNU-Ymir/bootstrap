mod ymirc::semantic::validator::operator::binary;

import ymirc::semantic::validator::visitor;
import ymirc::semantic::validator::errors;
import ymirc::semantic::declarator::errors;
import ymirc::errors::_;
import ymirc::utils::format;
import ymirc::utils::bigint;
import ymirc::utils::bigfloat;
import ymirc::utils::math;
import ymirc::syntax::expression::operator::binary;
import ymirc::syntax::declaration::protection;
import ymirc::global::core_;


import ymirc::semantic::symbol::_;
import ymirc::semantic::generator::_;

import ymirc::lexing::word;
import ymirc::lexing::tokens;
import ymirc::syntax::keys;
import ymirc::syntax::expression::_;

import std::algorithm::comparison;
import std::collection::vec;
import std::io;

pub enum 
| MATH = 1u32
| BITWISE = 2u32
| LOGICAL = 3u32
| COMPARISON = 4u32
| RANGE = 5u32
| POINTER = 6u32
| SET = 7u32
| TYPE = 8u32
| FIELD = 9u32
| MODULE = 10u32
| FLOAT_COMPARISON = 11u32
| NONE = 12u32
 -> OperatorType;

/**
 * The binary validator is used to validate BinaryOpExpr
 * It is a class validator because binary operation are complex
 */
pub class BinaryOpValidator {

    /**
     * Create an empty validator     
     */
    pub self () {}

    /**
     * Validate a binary expression that must return a value (some operation can return a type, i.e. '::' on some types)
     * @params: 
     *  - context: the context of the validation
     *  - bin: the binary operator to validate
     * @returns: a value
     * @throws: 
     *    - &ErrorMsg, if the validation failed
     */
    pub fn validateValue (self, dmut context : &Validator, bin : &BinaryExpr) -> &Value
        throws &ErrorMsg
    {
        let (op, isAff, type) = self.toOperator (bin.getLoc ());
        
        match (type, isAff) {
            (OperatorType::MATH, false) => { 
                return self.validateMathOperation (alias context, op, bin);
            }
            (OperatorType::BITWISE, false) => { // |, &, ^, <<, >>, applicable only on ints
                return self.validateBitwiseOperation (alias context, op, bin);
            }
            (OperatorType::COMPARISON, false) => { // all comparison operators, <=, >=, >, etc.., cannot be an affectation
                return self.validateComparisonOperation (alias context, op, bin);
            }
            (OperatorType::FLOAT_COMPARISON, false) => {
                return self.validateFloatComparisonOperation (alias context, op, bin);
            }
            (OperatorType::LOGICAL, false) => { // all boolean operators, cannot be an affectation
                return self.validateLogicalOperation (alias context, op, bin);
            }
            (OperatorType::RANGE, false) => { // .. and ..., cannot be an affectation
                return self.validateRangeOperation (alias context, op, bin);
            }
            (OperatorType::POINTER, false) => { // is and !is, cannot be an affectation
                return self.validatePointerOperation (alias context, op, bin);
            }
            (OperatorType::SET, false) => { // ~, in, and !in, might be an affectation for ~
                return self.validateSetOperation (alias context, op, bin);
            }
            (OperatorType::TYPE, false) => { // of and !of, cannot be an affectation
                return self.validateTypeOperation (alias context, op, bin);
            }
            (OperatorType::FIELD, false) => { // . and :., cannot be an affectation
                return self.validateFieldOperation (alias context, op, bin);
            }
            (OperatorType::MODULE, false) => { // ::, cannot be an affectation                
                return self.validateModuleOperation (alias context, op, bin);
            }
            (_, true) => { // =, +=, -=, ~=, etc., affectation operators
                return self.validateAffectOperation (alias context, op, bin);
            }
            _ => { // All case should be handled.                
                __pragma!panic ();
            }
        }
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================             MATH             =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a binary operation involving math operator
     * @params: 
     *   - context: the context of the validation
     *   - op: the operator (assuming it's a math operator)
     *   - bin: the binary expression to validate
     * @returns: the validated value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    fn validateMathOperation (self, dmut context : &Validator, op : BinaryOperators, bin : &BinaryExpr)-> &Value
        throws &ErrorMsg
    {
        let left = context:.implicitEnumUnwrap (context:.validateValue (bin.getLeft ()));
        let right = context:.implicitEnumUnwrap (context:.validateValue (bin.getRight ()));

        self.validateMathOperation (alias context, bin.getLoc (), op, left, right)
    }

    /**
     * Validate a binary operation
     * @params:
     *    - context: the context of the validation
     *    - loc: the location of the operation
     *    - op: the operator
     *    - left: the left operand
     *    - right: the right operand
     * @returns: the validated value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     * */
    pub fn validateMathOperation (self, dmut context : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Value)-> &Value
        throws &ErrorMsg
    {
        let dmut errors = Vec!{&ErrorMsg}::new ();
        {
            match left.getType () { // First we try the operation as a left side operation (asking for left operand to be the master of the operation, i.e. left.opBinary!{op} (right)
                IntType () => return self.validateIntMathOp (alias context, loc, op, left, right);
                CharType () => return self.validateCharMathOp (alias context, loc, op, left, right);
                FloatType () => return self.validateFloatMathOp (alias context, loc, op, left, right);
                PointerType () => return self.validatePointerMathOp (alias context, loc, op, left, right);
                c : &ClassPtrType => return self.validateClassOpLeft (alias context, loc, op, c, left, right);
            };
        } catch {
            err : &ErrorMsg => { errors:.push (err); }
        } 

        { // if we are here the validation as a left operand validation failed, so we need to try it as a right operation (right.opBinaryRight!{op} (left))
            match right.getType () { // it is working only for two kind of type structs and classes
                c : &ClassPtrType => return self.validateClassOpRight (alias context, loc, op, c, left, right);
            } // We can quit without testing the other types, there is already an error in the errors vec
        } catch {
            err : &ErrorMsg => { errors:.push (err); } // No we still fail
        }

        // there is no valid math operation for left and right
        throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_BIN_OP, op, left.getType (), right.getType ()), notes-> errors[]);
    }


    /**
     * Validate a math operation where the left operand is a int type operand
     * @params: 
     *   - context: the context of the validation
     *   - op: the operator
     *   - left: the left operand (assumed of type int)
     *   - right: the right operand
     * @returns: The result value
     * @throws: 
     *   - &ErrorMsg: if the operation is not valid
     */
    fn validateIntMathOp (self, dmut context : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Value)-> &Value
        throws &ErrorMsg
    {
        match left.getType () {
            li : &IntType => {            
                match right.getType () {
                    ri : &IntType => {
                        if (op == BinaryOperators::DXOR) {
                            return self.validateIntOrFloatPowerOp (alias context, loc, op, left, right);
                        }

                        if (li.isSigned () == ri.isSigned () && li.getSize () == ri.getSize ()) {
                            let type = IntType::new (loc, signed-> li.isSigned (), size-> li.getSize ());
                            return BinaryMathIntOperatorValue::new (loc, type, op, left, right);
                        }

                        {
                            let compatibleRight = context:.verifyCompatibleTypeWithValue (loc, li, right, byReference-> false);
                            let type = IntType::new (loc, signed-> li.isSigned (), size-> li.getSize ());
                            return BinaryMathIntOperatorValue::new (loc, type, op, left, compatibleRight);
                        } catch {
                            leErr : &ErrorMsg => {
                                let compatibleLeft = context:.verifyCompatibleTypeWithValue (loc, ri, left, byReference-> false);
                                let type = IntType::new (loc, signed-> ri.isSigned (), size-> ri.getSize ());
                                return BinaryMathIntOperatorValue::new (loc, type, op, compatibleLeft, right);
                            } catch {
                                riErr : &ErrorMsg => {
                                    throw ErrorMsg::list ([leErr, riErr]);
                                }
                            }
                        }
                    }
                    rc : &CharType => { // char values as right operands, 12u8 + 'a'c8 == 'm'c8
                        if (!li.isSigned () && rc.getSize () == li.getSize ()) {
                            let type = CharType::new (loc, size-> rc.getSize ());
                            let l = context:.getCastValidator ().validateCast (alias context, left, type);
                            return BinaryMathCharOperatorValue::new (loc, type, op, l, right);
                        }
                    }
                }                
            }
            _ => __pragma!panic ()
        }

        throw ErrorMsg::list ([]);
    }   

    /**
     * Validate the power operation
     * @info: This operation is not performed by the language itself (hardware) but by a core function (core::math::pow)
     * @example:
     * ====================
     * 12 ^^ 98
     * // rewritten into => 'core::math::iipow!{typeof(12)} (12, 98)-> typeof (12)
     * 12.f ^^ 0.5f
     * // rewritten into => 'core::math::ffpow!{typeof(12.f)} (12.0f, 0.5f)-> typeof (12.0f)
     * ====================
     * @params:
     *   - context: the context of the validation
     *   - op: the operator
     *   - left: the left operand (assumed of type int)
     *   - right: the right operand
     * @returns: The result value
     * @throws: 
     *   - &ErrorMsg: if the operation is not valid
     */
    fn validateIntOrFloatPowerOp (self, dmut context : &Validator, loc : &Word, _ : BinaryOperators, left : &Value, right : &Value)-> &Value
        throws &ErrorMsg
    {
        let funcName = if (left.getType ().isOf!{&IntType} ()) {
            CoreNames::IPOW_FUNCTION
        } else if (right.getType ().isOf!{&IntType} ()) {
            CoreNames::FIPOW_FUNCTION
        } else { CoreNames::FFPOW_FUNCTION };

        // Create a var path to the core function core::math::pow
        let syntVar = context.createSyntaxVarFromPath (loc, [CoreNames::CORE_MODULE, CoreNames::MATH_MODULE, funcName]);
        let func = context:.validateValue (syntVar);
        let call = context:.getCallOpValidator ().validate (alias context, loc, func, [left, right]);

        match call.getType () {
            IntType () => { return SpecialMathIntOperatorValue::new (loc, call.getType (), BinaryOperators::DXOR, left, right, call); }
            FloatType () => {  return SpecialMathFloatOperatorValue::new (loc, call.getType (), BinaryOperators::DXOR, left, right, call); }
            _ => throw ErrorMsg::fatal (func.getLoc (), ValidateErrorMessage::MALFORMED_CORE);
        }
    }

    /**
     * Validate the fmod operation
     * @info: this operation is not performed by the language itself (hardware) but by a core function (core::math::fmod)
     * @example:
     * ====================
     * 12.f % 0.5f
     * // rewritten into => 'core::math::ffmod!{typeof(12.f)} (12.0f, 0.5f)-> typeof (12.0f)
     * ====================
     * */
    fn validateFloatModOp (self, dmut context : &Validator, loc : &Word, _ : BinaryOperators, left : &Value, right : &Value)-> &Value
        throws &ErrorMsg
    {
        // Create a var path to the core function core::math::pow
        let syntVar = context.createSyntaxVarFromPath (loc, [CoreNames::CORE_MODULE, CoreNames::MATH_MODULE, CoreNames::FFMOD_FUNCTION]);
        let func = context:.validateValue (syntVar);
        let call = context:.getCallOpValidator ().validate (alias context, loc, func, [left, right]);

        match call.getType () {
            FloatType () => {  return SpecialMathFloatOperatorValue::new (loc, call.getType (), BinaryOperators::PERCENT, left, right, call); }
            _ => throw ErrorMsg::fatal (func.getLoc (), ValidateErrorMessage::MALFORMED_CORE);
        }
    }

    /**
     * Validate a math operation where the left operand is a char type operand
     * @params: 
     *   - _: the context of the validation
     *   - op: the operator
     *   - left: the left operand (assumed of type char)
     *   - right: the right operand
     * @returns: The result value
     * @throws: 
     *   - &ErrorMsg: if the operation is not valid
     */
    fn validateCharMathOp (self, dmut context : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Value)-> &Value
        throws &ErrorMsg
    {
        if (op != BinaryOperators::PLUS && op != BinaryOperators::MINUS) {
            throw ErrorMsg::list ([]);
        }
        
        match left.getType () {
            lc : &CharType => {
                match right.getType () {
                    ri : &IntType => { // only int values can be added, substracted to char values
                        if (!ri.isSigned () && ri.getSize () == lc.getSize ()) {
                            let type = CharType::new (loc, size-> lc.getSize ());
                            let r = context:.getCastValidator ().validateCast (alias context, right, type);
                            return BinaryMathCharOperatorValue::new (loc, type, op, left, r);
                        }
                    }
                }
            }
        }

        throw ErrorMsg::list ([]);
    }


    /**
     * Validate a math operation where the left operand is a float type operand
     * @params: 
     *   - context: the context of the validation
     *   - op: the operator
     *   - left: the left operand (assumed of type float)
     *   - right: the right operand
     * @returns: The result value
     * @throws: 
     *   - &ErrorMsg: if the operation is not valid
     */
    fn validateFloatMathOp (self, dmut context : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Value)-> &Value
        throws &ErrorMsg
    {        
        match left.getType () {
            lf : &FloatType => {
                match right.getType () {
                    _ : &IntType => {
                        if (op == BinaryOperators::DXOR) {
                            return self.validateIntOrFloatPowerOp (alias context, loc, op, left, right);
                        }
                    }
                    rf : &FloatType => {
                        if (op == BinaryOperators::DXOR) {
                            return self.validateIntOrFloatPowerOp (alias context, loc, op, left, right);
                        } else if (op == BinaryOperators::PERCENT) {
                            return self.validateFloatModOp (alias context, loc, op, left, right);
                        }

                        if (lf.getSize () == rf.getSize ()) {
                            let type = FloatType::new (loc, size-> lf.getSize ());
                            return BinaryMathFloatOperatorValue::new (loc, type, op, left, right);
                        }

                        {
                            let compatibleRight = context:.verifyCompatibleTypeWithValue (loc, lf, right, byReference-> false);
                            let type = FloatType::new (loc, size-> lf.getSize ());
                            return BinaryMathFloatOperatorValue::new (loc, type, op, left, compatibleRight);
                        } catch {
                            leErr : &ErrorMsg => {
                                let compatibleLeft = context:.verifyCompatibleTypeWithValue (loc, rf, left, byReference-> false);
                                let type = FloatType::new (loc, size-> rf.getSize ());
                                return BinaryMathFloatOperatorValue::new (loc, type, op, compatibleLeft, right);
                            } catch {
                                riErr : &ErrorMsg => {
                                    throw ErrorMsg::list ([leErr, riErr]);
                                }
                            }
                        }

                    }
                }
            }
        }

        throw ErrorMsg::list ([]);
    }

    /**
     * Validate a math operation where the left operand is a pointer type operand
     * @params: 
     *   - _: the context of the validation
     *   - op: the operator
     *   - left: the left operand (assumed of type pointer)
     *   - right: the right operand
     * @returns: The result value
     * @throws: 
     *   - &ErrorMsg: if the operation is not valid
     */
    fn validatePointerMathOp (self, dmut _ : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Value)-> &Value
        throws &ErrorMsg
    {
        if (op != BinaryOperators::PLUS && op != BinaryOperators::MINUS) {
            throw ErrorMsg::list ([]);
        }
        
        match left.getType () {
            lp : &PointerType => {
                match right.getType () {
                    ri : &IntType => {
                        if (!ri.isSigned () && ri.getSize () == 0us) {
                            return BinaryMathPointerOperatorValue::new (loc, lp, op, left, right);
                        }
                    }
                    rp : &PointerType => {
                        if (rp.getInners ()[0] == lp.getInners ()[0] || rp.getInners ()[0].isOf!{&VoidType} ()) {
                            return BinaryMathPointerOperatorValue::new (loc, lp, op, left, right);
                        }
                    }
                }
            }
        }

        throw ErrorMsg::list ([]);
    }


    /*!
     * ================================================================================
     * ================================================================================
     * =========================           BITWISE            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a binary operation involving bitwise operators (|, &, <<, etc.)
     * @params: 
     *   - context: the context of the validation
     *   - op: the operator (assuming it's a logical operator)
     *   - bin: the binary expression to validate
     * @returns: the validated value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    fn validateBitwiseOperation (self, dmut context : &Validator, op : BinaryOperators, bin : &BinaryExpr)-> &Value
        throws &ErrorMsg
    {
        let left = context:.implicitEnumUnwrap (context:.validateValue (bin.getLeft ()));
        let right = context:.implicitEnumUnwrap (context:.validateValue (bin.getRight ()));

        let dmut errors = Vec!{&ErrorMsg}::new ();
        {
            // First we try the operation as a left side operation (asking for left operand to be the master of the operation, i.e. left.opBinary!{op} (right)
            match left.getType () { 
                IntType () => return self.validateIntBitwiseOp (alias context, bin.getLoc (), op, left, right);
                c : &ClassPtrType => return self.validateClassOpLeft (alias context, bin.getLoc (), op, c, left, right);
            };
        } catch {
            err : &ErrorMsg => { errors:.push (err); }
        }

        { // if we are here the validation as a left operand validation failed, so we need to try it as a right operation (right.opBinaryRight!{op} (left))
            match right.getType () { // it is working only for two kind of type structs and classes
                c : &ClassPtrType => return self.validateClassOpRight (alias context, bin.getLoc (), op, c, left, right);
            } // We can quit without testing the other types, there is already an error in the errors vec
        } catch {
            err : &ErrorMsg => { errors:.push (err); } // No we still fail
        }

        throw ErrorMsg::fatal (bin.getLoc (), format (ValidateErrorMessage::UNDEFINED_BIN_OP, op, left.getType (), right.getType ()), notes-> errors[]);
    }

    /**
     * Validate a binary operation involving bitwise operators, and assuming that left operand is a int typed value
     * @params: 
     *   - context: the context of the validation
     *   - loc: the location of the operation
     *   - op: the operator
     *   - left: the left operand of the operation (assumed to be a int typed value)
     *   - right: the right operand of the operation
     * @returns: the result value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    fn validateIntBitwiseOp (self, dmut context : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Value)-> &Value
        throws &ErrorMsg
    {
        match left.getType () {
            li : &IntType => {
                match right.getType () {
                    ri : &IntType => {
                        if (li.isSigned () == ri.isSigned () && li.getSize () == ri.getSize ()) {
                            let type = IntType::new (loc, signed-> li.isSigned (), size-> li.getSize ());
                            return BitwiseIntOperatorValue::new (loc, type, op, left, right);
                        }

                        {
                            let compatibleRight = context:.verifyCompatibleTypeWithValue (loc, li, right, byReference-> false);
                            let type = IntType::new (loc, signed-> li.isSigned (), size-> li.getSize ());
                            return BitwiseIntOperatorValue::new (loc, type, op, left, compatibleRight);
                        } catch {
                            leErr : &ErrorMsg => {
                                let compatibleLeft = context:.verifyCompatibleTypeWithValue (loc, ri, left, byReference-> false);
                                let type = IntType::new (loc, signed-> ri.isSigned (), size-> ri.getSize ());
                                return BitwiseIntOperatorValue::new (loc, type, op, compatibleLeft, right);
                            } catch {
                                riErr : &ErrorMsg => {
                                    throw ErrorMsg::list ([leErr, riErr]);
                                }
                            }
                        }
                    }
                }               
            }
        }

        throw ErrorMsg::list ([]);
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================          COMPARISON          =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a binary operation involving comparison operators (<=, >=, <, >, ==, etc..)
     * @params:
     *   - context: the context of the validation
     *   - op: the operator (assuming it's a logical operator)
     *   - bin: the binary expression to validate
     * @returns: the validated value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    fn validateComparisonOperation (self, dmut context : &Validator, op : BinaryOperators, bin : &BinaryExpr)-> &Value
        throws &ErrorMsg
    {
        let left = context:.implicitEnumUnwrap (context:.validateValue (bin.getLeft ()));
        let right = context:.implicitEnumUnwrap (context:.validateValue (bin.getRight ()));

        self.validateComparisonOperationImpl (alias context, bin.getLoc (), op, left, right)
    }

    /**
     * Validate a binary operation involving comparison operators (<=, >=, <, >, ==, etc..)
     * @params:
     *   - context: the context of the validation
     *   - op: the operator (assuming it's a logical operator)
     *   - left: the left operand
     *   - right: the right operand
     * @returns: the validated value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    pub fn validateComparisonOperation (self, dmut context : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Value)-> &Value
        throws &ErrorMsg
    {
        let uLeft = context:.implicitEnumUnwrap (left);
        let uRight = context:.implicitEnumUnwrap (right);

        self.validateComparisonOperationImpl (alias context, loc, op, uLeft, uRight)
    }

    /**
     * Validate a binary operation involving comparison operators (<=, >=, <, >, ==, etc..)
     * @params:
     *   - context: the context of the validation
     *   - op: the operator (assuming it's a logical operator)
     *   - left: the left operand
     *   - right: the right operand
     * @returns: the validated value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    fn validateComparisonOperationImpl (self, dmut context : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Value)-> &Value
        throws &ErrorMsg
    {
        let dmut errors = Vec!{&ErrorMsg}::new ();
        {
            // First we try the operation as a left side operation (asking for left operand to be the master of the operation, i.e. left.opBinary!{op} (right)
            match left.getType () {
                IntType () => return self.validateIntCmpOp (alias context, loc, op, left, right);
                FloatType () => return self.validateFloatCmpOp (alias context, loc, op, left, right);
                CharType () => return self.validateCharCmpOp (alias context, loc, op, left, right);
                BoolType () => return self.validateBoolCmpOp (alias context, loc, op, left, right);
                PointerType () => return self.validatePointerCmpOp (alias context, loc, op, left, right);
                ArrayType () => return self.validateSliceOrArrayCmpOp (alias context, loc, op, left, right);
                SliceType () => return self.validateSliceOrArrayCmpOp (alias context, loc, op, left, right);
                TupleType () => return self.validateTupleCmpOp (alias context, loc, op, left, right);
                RangeType () => return self.validateRangeCmpOp (alias context, loc, op, left, right);
                c : &ClassPtrType => return self.validateClassCmpOp (alias context, loc, op, c, left, right);
                OptionType () => return self.validateOptionCmpOp (alias context, loc, op, left, right);
            };
        } catch {
            err : &ErrorMsg => { errors:.push (err); }
        }

        { // if we are here the validation as a left operand validation failed, so we need to try it as a right operation (right.opBinaryRight!{op} (left))
            match right.getType () { // it is working only for two kind of type structs and classes
                c : &ClassPtrType => return self.validateClassCmpOp (alias context, loc, op, c, left, right, inv-> true);
            } // We can quit without testing the other types, there is already an error in the errors vec
        } catch {
            err : &ErrorMsg => { errors:.push (err); } // No we still fail
        }

        // there is no valid math operation for left and right
        throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_BIN_OP, op, left.getType (), right.getType ()), notes-> errors[]);

    }

    /**
     * Validate a binary operation involving float comparison operators (<=>, <!>)
     * @params:
     *   - context: the context of the validation
     *   - op: the operator (assuming it's a logical operator)
     *   - bin: the binary expression to validate
     * @returns: the validated value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    fn validateFloatComparisonOperation (self, dmut context : &Validator, op : BinaryOperators, bin : &BinaryExpr)-> &Value
        throws &ErrorMsg
    {
        let left = context:.implicitEnumUnwrap (context:.validateValue (bin.getLeft ()));
        let right = context:.implicitEnumUnwrap (context:.validateValue (bin.getRight ()));

        let dmut errors = Vec!{&ErrorMsg}::new ();
        {
            // First we try the operation as a left side operation (asking for left operand to be the master of the operation, i.e. left.opBinary!{op} (right)
            match left.getType () {
                FloatType () => return self.validateFloatSpecialCmpOp (alias context, bin.getLoc (), op, left, right);
            };
        } catch {
            err : &ErrorMsg => { errors:.push (err); }
        }

        throw ErrorMsg::fatal (bin.getLoc (), format (ValidateErrorMessage::UNDEFINED_BIN_OP, op, left.getType (), right.getType ()), notes-> errors[])
    }

    /**
     * Validate a binary comparison operator, assuming that the left operand is a int
     * @params: 
     *   - context: the context of the operator
     *   - loc: the location of the operator
     *   - left: the left operand (assume to be a int typed value)
     *   - right: the right operand
     * @returns: the result value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    fn validateIntCmpOp (self, dmut context : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Value)-> &Value
        throws &ErrorMsg
    {
        match left.getType () {
            li : &IntType => {
                match right.getType () {
                    ri : &IntType => {
                        if (li.isSigned () == ri.isSigned ()) {
                            return CmpIntOperatorValue::new (loc, op, left, right);
                        }

                        {
                            let compatibleRight = context:.verifyCompatibleTypeWithValue (loc, li, right, byReference-> false);
                            return CmpIntOperatorValue::new (loc, op, left, compatibleRight);
                        } catch {
                            leErr : &ErrorMsg => {
                                let compatibleLeft = context:.verifyCompatibleTypeWithValue (loc, ri, left, byReference-> false);
                                return CmpIntOperatorValue::new (loc, op, compatibleLeft, right);
                            } catch {
                                riErr : &ErrorMsg => {
                                    throw ErrorMsg::list ([leErr, riErr]);
                                }
                            }
                        }
                    }
                }
            }
        }
        
        throw ErrorMsg::list ([])
    }

    /**
     * Validate a binary comparison operator, assuming left is an option value
     * @params:
     *    - context: the context of the operator
     *    - loc: the location of the operator
     *    - left: the left operand (assuming to be a option typed value)
     *    - right: the right operand
     * @returns: the result value
     * @throws:
     *    - &ErrorMsg: if the operation is not valid
     * */
    fn validateOptionCmpOp (self, dmut context : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Value)-> &Value
        throws &ErrorMsg
    {
        let (lVal, rVal) = if (left.getType ().asOf!{&OptionType} ().getInners ()[0].isOf!{&NoneType} ()) {
            (context:.verifyCompatibleTypeWithValue (loc, right.getType (), left, byReference-> false), right)
        } else { (left, context:.verifyCompatibleTypeWithValue (loc, left.getType (), right, byReference-> false)) };

        let innerLType = lVal.getType ().asOf!{&OptionType} ().getInners ()[0];
        let innerRType = rVal.getType ().asOf!{&OptionType} ().getInners ()[0];

        if (innerRType.isOf!{&NoneType} () && innerLType.isOf!{&NoneType} ()) {
            return CmpIntOperatorValue::new (loc, op, makeIntValue (loc, 0is), makeIntValue (loc, 0is)); // none op none
        }

        let boolType = BoolType::new (loc);
        let lSet = StructFieldAccessValue::new (loc, boolType, lVal, OptionKeys::SET);
        let rSet = StructFieldAccessValue::new (loc, boolType, rVal, OptionKeys::SET);

        let lInnerVal = OptionFieldAccessValue::new (loc, innerLType, lVal, OptionKeys::VALUE);
        let rInnerVal = OptionFieldAccessValue::new (loc, innerRType, rVal, OptionKeys::VALUE);

        let bothSet = LogicalBinBoolOperatorValue::new (loc, BinaryOperators::DAND, lSet, rSet);
        let bothSetRes = self.validateComparisonOperationImpl (alias context, loc, op, lInnerVal, rInnerVal);

        let onlyRightSetRes = CmpIntOperatorValue::new (loc, op, makeIntValue (loc, -1is), makeIntValue (loc, 0is));
        let onlyLeftSetRes = CmpIntOperatorValue::new (loc, op, makeIntValue (loc, 1is), makeIntValue (loc, 0is));
        let noneSetRes = CmpIntOperatorValue::new (loc, op, makeIntValue (loc, 0is), makeIntValue (loc, 0is));

        let finalCond = ConditionalValue::new (loc, boolType, lSet, onlyLeftSetRes, noneSetRes);
        let preCond = ConditionalValue::new (loc, boolType, rSet, onlyRightSetRes, finalCond);

        context.getCompileTimeInterpreter ().reduce (ConditionalValue::new (loc, boolType, bothSet, bothSetRes, preCond))
    }

    /**
     * Validate a binary comparison operator, assuming that the left operand is a float
     * @params:
     *   - context: the context of the operator
     *   - loc: the location of the operator
     *   - left: the left operand (assume to be a float typed value)
     *   - right: the right operand
     * @returns: the result value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    fn validateFloatCmpOp (self, dmut context : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Value)-> &Value
        throws &ErrorMsg
    {
        match left.getType () {
            li : &FloatType => {
                match right.getType () {
                    ri : &FloatType => {
                        if (li.getSize () == ri.getSize ()) {
                            return CmpFloatOperatorValue::new (loc, op, left, right);
                        }

                        {
                            let compatibleRight = context:.verifyCompatibleTypeWithValue (loc, li, right, byReference-> false);
                            return CmpFloatOperatorValue::new (loc, op, left, compatibleRight);
                        } catch {
                            leErr : &ErrorMsg => {
                                let compatibleLeft = context:.verifyCompatibleTypeWithValue (loc, ri, left, byReference-> false);
                                return CmpFloatOperatorValue::new (loc, op, compatibleLeft, right);
                            } catch {
                                riErr : &ErrorMsg => {
                                    throw ErrorMsg::list ([leErr, riErr]);
                                }
                            }
                        }
                    }
                }
            }
        }

        throw ErrorMsg::list ([]);
    }


    /**
     * Validate a binary float comparison operator (<=>, <!>), assuming that the left operand is a float
     * @params:
     *   - context: the context of the operator
     *   - loc: the location of the operator
     *   - left: the left operand (assume to be a float typed value)
     *   - right: the right operand
     * @returns: the result value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    fn validateFloatSpecialCmpOp (self, dmut context : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Value)-> &Value
        throws &ErrorMsg
    {
        if (!right.getType ().isOf!{&FloatType} ()) {
            throw ErrorMsg::list ([]);
        }

        // Create a var path to the core function core::math::float_compare
        let syntVar = context.createSyntaxVarFromPath (loc, [CoreNames::CORE_MODULE, CoreNames::MATH_MODULE, CoreNames::FLOAT_CMP]);
        let func = context:.validateValue (syntVar);
        let call = context:.getCallOpValidator ().validate (alias context, loc, func, [left, right]);

        if (op == BinaryOperators::UNCONGRUENT) {
            context:.getUnOpValidator ().validateNotOperator (alias context, loc, call)
        } else {
            call
        }
    }


    /**
     * Validate a binary comparison operator, assuming that the left operand is a char
     * @params: 
     *   - context: the context of the operator
     *   - loc: the location of the operator
     *   - left: the left operand (assume to be a char typed value)
     *   - right: the right operand
     * @returns: the result value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    fn validateCharCmpOp (self, dmut context : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Value)-> &Value
        throws &ErrorMsg
    {
        match left.getType () {
            li : &CharType => {
                match right.getType () {
                    ri : &CharType => {
                        if (li.getSize () == ri.getSize ()) {
                            return CmpCharOperatorValue::new (loc, op, left, right);
                        }

                        {
                            let compatibleRight = context:.verifyCompatibleTypeWithValue (loc, li, right, byReference-> false);
                            return CmpCharOperatorValue::new (loc, op, left, compatibleRight);
                        } catch {
                            leErr : &ErrorMsg => {
                                let compatibleLeft = context:.verifyCompatibleTypeWithValue (loc, ri, left, byReference-> false);
                                return CmpCharOperatorValue::new (loc, op, compatibleLeft, right);
                            } catch {
                                riErr : &ErrorMsg => {
                                    throw ErrorMsg::list ([leErr, riErr]);
                                }
                            }
                        }
                    }
                }
            }
        }
        
        throw ErrorMsg::list ([]);
    }


    /**
     * Validate a binary comparison operator, assuming that the left operand is a bool
     * @params:
     *   - context: the context of the operator
     *   - loc: the location of the operator
     *   - left: the left operand (assume to be a bool typed value)
     *   - right: the right operand
     * @returns: the result value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    fn validateBoolCmpOp (self, dmut _ : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Value)-> &Value
        throws &ErrorMsg
    {
        if (op == BinaryOperators::DEQUAL || op == BinaryOperators::NOT_EQUAL) {
            match left.getType () {
                BoolType () => {
                    match right.getType () {
                        BoolType () => {
                            return CmpBoolOperatorValue::new (loc, op, left, right);
                        }
                    }
                }
            }
        }

        throw ErrorMsg::list ([]);
    }

    /**
     * Validate a binary comparison operator, assuming that the left operand is a pointer type
     * @params:
     *   - context: the context of the operator
     *   - loc: the location of the operator
     *   - left: the left operand (assume to be a pointer type value)
     *   - right: the right operand
     * @returns: the result value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    fn validatePointerCmpOp (self, dmut context : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Value)-> &Value
        throws &ErrorMsg
    {
        match left.getType () {
            li : &PointerType => {
                match right.getType () {
                    ri : &PointerType => {
                        if (li == ri) {
                            return CmpPointerOperatorValue::new (loc, op, left, right);
                        }

                        {
                            let compatibleRight = context:.verifyCompatibleTypeWithValue (loc, li, right, byReference-> false);
                            return CmpPointerOperatorValue::new (loc, op, left, compatibleRight);
                        } catch {
                            leErr : &ErrorMsg => {
                                let compatibleLeft = context:.verifyCompatibleTypeWithValue (loc, ri, left, byReference-> false);
                                return CmpPointerOperatorValue::new (loc, op, compatibleLeft, right);
                            } catch {
                                riErr : &ErrorMsg => {
                                    throw ErrorMsg::list ([leErr, riErr]);
                                }
                            }
                        }
                    }
                }
            }
        }

        throw ErrorMsg::list ([]);
    }

    /**
     * Validate a binary comparison operator, assuming that the left operand is a tuple type
     * @params:
     *   - context: the context of the operator
     *   - loc: the location of the operator
     *   - left: the left operand (assume to be a tuple type value)
     *   - right: the right operand
     * @returns: the result value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     * */
    fn validateTupleCmpOp (self, dmut context : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Value)-> &Value
        throws &ErrorMsg
    {
        match (left.getType (), right.getType ()) {
            (l : &TupleType, r : &TupleType) => {
                if (l.getInners ().len == r.getInners ().len) {

                    let mut res : &Value = UNIT_VALUE;
                    for i in l.getInners ().len .. 0us {
                        let fieldL = self.createTupleFieldAccess (loc, l.getInners ()[i - 1us], left, i - 1us);
                        let fieldR = self.createTupleFieldAccess (loc, l.getInners ()[i - 1us], right, i - 1us);

                        let cmp = self.validateComparisonOperationImpl (alias context, loc, op, fieldL, fieldR);
                        res = match res {
                            UnitValue () => {
                                cmp
                            }
                            old : _ => {
                                cast!{&Value} (if (op == BinaryOperators::DEQUAL) {
                                    LogicalBinBoolOperatorValue::new (loc, BinaryOperators::DAND, cmp, old)
                                } else {
                                    LogicalBinBoolOperatorValue::new (loc, BinaryOperators::DPIPE, cmp, old)
                                })
                            }
                        };
                    }
                    return res;
                }
            }
        }

        throw ErrorMsg::list ([]);
    }

    /**
     * Validate a binary comparison operator, assuming that left operand is a range type
     * @params:
     *   - context: the context of the operator
     *   - loc: the location of the operator
     *   - left: the left operand (assume to be a range type value)
     *   - right: the right operand
     * @returns: the result value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     * */
    fn validateRangeCmpOp (self, dmut context : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Value)-> &Value
        throws &ErrorMsg
    {
        if (op == BinaryOperators::DEQUAL || op == BinaryOperators::NOT_EQUAL) {
            match (left.getType (), right.getType ()) {
                (l : &RangeType, r : &RangeType) => {
                    context:.verifyCompatibleType (loc, right.getLoc (), l, r);

                    let uniqL = left;
                    let uniqR = right;
                    let inType = l.getInners ()[0];
                    let stType = l.getInners ()[1];
                    let bType = BoolType::new (loc);

                    let fstL = ValueWrapperExpr::new (loc, StructFieldAccessValue::new (loc, inType, uniqL, RangeKeys::FST));
                    let fstR = ValueWrapperExpr::new (loc, StructFieldAccessValue::new (loc, inType, uniqR, RangeKeys::FST));

                    let scdL = ValueWrapperExpr::new (loc, StructFieldAccessValue::new (loc, inType, uniqL, RangeKeys::SCD));
                    let scdR = ValueWrapperExpr::new (loc, StructFieldAccessValue::new (loc, inType, uniqR, RangeKeys::SCD));

                    let stepL = ValueWrapperExpr::new (loc, StructFieldAccessValue::new (loc, stType, uniqL, RangeKeys::STEP));
                    let stepR = ValueWrapperExpr::new (loc, StructFieldAccessValue::new (loc, stType, uniqR, RangeKeys::STEP));

                    let containL = ValueWrapperExpr::new (loc, StructFieldAccessValue::new (loc, bType, uniqL, RangeKeys::CONTAIN));
                    let containR = ValueWrapperExpr::new (loc, StructFieldAccessValue::new (loc, bType, uniqR, RangeKeys::CONTAIN));

                    let fstEq = context:.validateValue (BinaryExpr::new (Word::new (BinaryOperators::DEQUAL, loc), fstL, fstR));
                    let scdEq = context:.validateValue (BinaryExpr::new (Word::new (BinaryOperators::DEQUAL, loc), scdL, scdR));
                    let stepEq = context:.validateValue (BinaryExpr::new (Word::new (BinaryOperators::DEQUAL, loc), stepL, stepR));
                    let cntEq = context:.validateValue (BinaryExpr::new (Word::new (BinaryOperators::DEQUAL, loc), containL, containR));

                    let retA = LogicalBinBoolOperatorValue::new (loc, BinaryOperators::DAND, fstEq, scdEq);
                    let retB = LogicalBinBoolOperatorValue::new (loc, BinaryOperators::DAND, stepEq, cntEq);
                    let mut ret : &Value = LogicalBinBoolOperatorValue::new (loc, BinaryOperators::DAND, retA, retB);

                    if (op == BinaryOperators::NOT_EQUAL) {
                        ret = UnaryBoolOperatorValue::new (loc, UnaryOperators::NOT, ret);
                    }

                    return ret;
                }
            }
        }

        throw ErrorMsg::list ([]);
    }

    /**
     * Validate the comparison operator of two slice  (it is almost the same for array and slice, so it is factorized in this function)
     * @info: This comparison is not provided by the language itself, but by core files, so this binary operator is rewritten into a syntax element
     * @example: 
     * ======================
     * [1, 2, 3] < [0, 8, 0]
     * // is rewritten into => 'core::array::opCmp ([1, 2, 3], [0, 8, 0]) < 0'
     *
     * [1, 2, 3] >= [0, 8, 0]
     * // is rewritten into => 'core::array::opCmp ([1, 2, 3], [0, 8, 0]) >= 0'
     * ======================
     * @params: 
     *   - context: the context of the operator
     *   - loc: the location of the operator
     *   - left: the left operand
     *   - right: the right operand
     * @returns: the result value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    fn validateSliceOrArrayCmpOp (self, dmut context : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Value)-> &Value
        throws &ErrorMsg
    {
        let finLeft = match left.getType () {
            SliceType () => { left }
            a : &ArrayType => { context.createSliceAliasFromArray (loc, a, left) }
            _ => {
                throw ErrorMsg::list ([]);
            }
        };

        // The comparison can be made only with an element of the same type, that is to say a slice or an array
        let finRight = match right.getType () {
            SliceType () => { right }
            a : &ArrayType => { context.createSliceAliasFromArray (loc, a, right) }
            _ => {
                throw ErrorMsg::list ([]);
            }
        };

        let dmut errors = Vec!{&ErrorMsg}::new ();

        // There is another function for equality that is faster than comparison, so we call it if we can
        // And unlike class and struct, we know that this operator is defined in core files, so no need to check its existence 
        if (op == BinaryOperators::DEQUAL || op == BinaryOperators::NOT_EQUAL) {
            return self.validateSliceOrArrayEqualOp (alias context, loc, op, finLeft, finRight);
        } catch {
            err : &ErrorMsg => {
                errors:.push (err);
            }
        }

        {
            // Create a var path to the core function core::array::opCmp
            let syntVar = context.createSyntaxVarFromPath (loc, [CoreNames::CORE_MODULE, CoreNames::ARRAY_MODULE, OpOverrideNames::CMP_OP_OVERRIDE]);
            let func = context:.validateValue (syntVar);
            let valueCall = context:.getCallOpValidator ().validate (alias context, loc, func, [finLeft, finRight]);

            // Validate the value to get the return type
            let call = match valueCall {
                c : &CallValue => {
                    cast!{&Value} (SpecialArrayOperatorValue::new (loc, valueCall.getType (), op, c.getParameters ()[0], c.getParameters ()[1], c))
                }
                _ => { valueCall }
            };

            let casted = context:.getCastValidator ().validateCast (alias context, makeIntValue (loc, 0is), call.getType ());
            return self.validateComparisonOperationImpl (alias context, loc, op, call, casted);
        } catch {
            err : &ErrorMsg => {
                errors:.push (err);
            }
        }

        throw ErrorMsg::list (errors[]);
    }

    /**
     * Validate the equality operator of two slice  (it is almost the same for array and slice, so it is factorized in this function)
     * @info: This comparison is not provided by the language itself, but by core files, so this binary operator is rewritten into a syntax element
     * @example: 
     * ======================
     * [1, 2, 3] != [0, 8, 0]
     * // is rewritten into => '!core::array::opEquals ([1, 2, 3], [0, 8, 0])'
     *
     * [1, 2, 3] == [0, 8, 0]
     * // is rewritten into => 'core::array::opEquals ([1, 2, 3], [0, 8, 0])'
     * ======================
     * @params: 
     *   - context: the context of the operator
     *   - loc: the location of the operator
     *   - left: the left operand 
     *   - right: the right operand
     * @returns: the result value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */

    fn validateSliceOrArrayEqualOp (self, dmut context : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Value)-> &Value
        throws &ErrorMsg
    {

        let syntVar = context.createSyntaxVarFromPath (loc, [CoreNames::CORE_MODULE, CoreNames::ARRAY_MODULE, OpOverrideNames::EQUAL_OP_OVERRIDE]);
        let func = context:.validateValue (syntVar);

        // Validate the value to get the return type
        let valueCall = context:.getCallOpValidator ().validate (alias context, loc, func, [left, right]);
        let call = match valueCall {
            c : &CallValue => {
                cast!{&Value} (SpecialArrayOperatorValue::new (loc, valueCall.getType (), BinaryOperators::DEQUAL, c.getParameters ()[0], c.getParameters ()[1], c))
            }
            _ => { valueCall }
        };

        if (op == BinaryOperators::NOT_EQUAL) { // We need to inverse the equality, the operator returns '=='
            context:.getUnOpValidator ().validateNotOperator (alias context, loc, call)
        } else {
            call
        }
    }
    
    /*!
     * ================================================================================
     * ================================================================================
     * =========================           LOGICAL            =========================
     * ================================================================================
     * ================================================================================
     */


    /**
     * Validate a binary operation involving logical operator (&&, ||)
     * @info: these operators have a meaning only on bool values
     * @params: 
     *   - context: the context of the validation
     *   - op: the operator (assuming it's a logical operator)
     *   - bin: the binary expression to validate
     * @returns: the validated value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    fn validateLogicalOperation (self, dmut context : &Validator, op : BinaryOperators, bin : &BinaryExpr)-> &Value
        throws &ErrorMsg
    {
        let left = context:.implicitEnumUnwrap (context:.validateValue (bin.getLeft ()));
        let right = context:.implicitEnumUnwrap (context:.validateValue (bin.getRight ()));

        match left.getType () {
            BoolType () => {
                match right.getType () {
                    BoolType () => {
                        return LogicalBinBoolOperatorValue::new (bin.getLoc (), op, left, right);
                    }
                }
            }
        }

        throw ErrorMsg::fatal (bin.getLoc (), format (ValidateErrorMessage::UNDEFINED_BIN_OP, op, left.getType (), right.getType ()));
    }


    /*!
     * ================================================================================
     * ================================================================================
     * =========================            RANGE             =========================
     * ================================================================================
     * ================================================================================
     */


    /**
     * Validate a binary operation involving a range operator
     * @params: 
     *   - context: the context of the validation
     *   - op: the operator (assuming it's a range operator)
     *   - bin: the binary expression to validate
     * @returns: the validated value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    fn validateRangeOperation (self, dmut context : &Validator, op : BinaryOperators, bin : &BinaryExpr)-> &Value
        throws &ErrorMsg
    {
        let left = context:.implicitEnumUnwrap (context:.validateValue (bin.getLeft ()));
        let right = context:.implicitEnumUnwrap (context:.validateValue (bin.getRight ()));

        let dmut errors = Vec!{&ErrorMsg}::new ();        
        {
            match left.getType () { // First we try the operation as a left side operation (asking for left operand to be the master of the operation, i.e. left.opBinary!{op} (right)
                IntType () => return self.validateIntRangeOp (alias context, bin.getLoc (), op, left, right);
                c : &ClassPtrType => return self.validateClassRangeOpLeft (alias context, bin.getLoc (), op, c, left, right);
            };
        } catch {
            err : &ErrorMsg => { errors:.push (err); }
        } 

        { // if we are here the validation as a left operand validation failed, so we need to try it as a right operation (right.opBinaryRight!{op} (left))
            match right.getType () { // it is working only for two kind of type structs and classes
                c : &ClassPtrType => return self.validateClassRangeOpRight (alias context, bin.getLoc (), op, c, left, right);
            } // We can quit without testing the other types, there is already an error in the errors vec
        } catch {
            err : &ErrorMsg => { errors:.push (err); } // No we still fail
        }

        throw ErrorMsg::fatal (bin.getLoc (), format (ValidateErrorMessage::UNDEFINED_BIN_OP, op, left.getType (), right.getType ()), notes-> errors[]);
    }

    /**
     * Validate a range operator assuming that the left operand is a int value
     * @params: 
     *   - context: the context of the validation
     *   - loc: the location of the operation
     *   - op: the range operator
     *   - left: the left operand
     *   - right: the right operand
     * @returns: the result value
     * @throws:
     *    - &ErrorMsg: if the operation is not valid
     */
    fn validateIntRangeOp (self, dmut context : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Value)-> &Value
        throws &ErrorMsg
    {
        match left.getType () {
            li : &IntType => {
                match right.getType () {
                    ri : &IntType => {
                        // The type of the range takes the biggest of the two elements
                        let bI = if (self.isMax (li.getSize (), ri.getSize ())) { li } else { ri };

                        let lvalue = context:.verifyCompatibleTypeWithValue (left.getLoc (), bI, left, byReference-> false);
                        let rvalue = context:.verifyCompatibleTypeWithValue (right.getLoc (), bI, right, byReference-> false);

                        let stepType = IntType::new (loc, signed-> true, size-> bI.getSize ()); // Step is always signed
                        let type = RangeType::new (loc, bI, stepType, isMutable-> false); // Inner type is the biggest of the two operands
                        let include = BoolValue::new (loc, (op == BinaryOperators::TDOT)); // include the last value depending on the operator used

                        let cmp = CmpIntOperatorValue::new (loc, BinaryOperators::INF_EQUAL, lvalue, rvalue); // Range can be decreasing if scd < fst
                        let condStep = ConditionalValue::new (loc, stepType, cmp,
                                                              IntValue::new (loc, stepType, 1us),
                                                              IntValue::new (loc, stepType, BigInt::new (-1))); // Then the step is set accordingly

                        let step = context.getCompileTimeInterpreter ().reduce (condStep); // Try to get the step value as cte
                        return RangeValue::new (loc, type, lvalue, rvalue, step-> step, full-> include);
                    }
                }
            }
        }

        // Right op is not an int value
        throw ErrorMsg::list ([]);
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================           POINTER            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a binary operation involving a pointer operator
     * @params: 
     *   - context: the context of the validation
     *   - op: the operator (assuming it's a pointer operator)
     *   - bin: the binary expression to validate
     * @returns: the validated value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    fn validatePointerOperation (self, dmut context : &Validator, op : BinaryOperators, bin : &BinaryExpr)-> &Value
        throws &ErrorMsg
    {
        let left = context:.implicitEnumUnwrap (context:.validateValue (bin.getLeft ()));
        let right = context:.implicitEnumUnwrap (context:.validateValue (bin.getRight ()));

        let dmut errors = Vec!{&ErrorMsg}::new ();
        {
            match left.getType () {
                ClassPtrType () =>
                    return self.validateClassPointerOp (alias context, bin.getLoc (), op, left, right);
            };
        } catch {
            err : &ErrorMsg => {
                errors:.push (err);
            }
        }

        throw ErrorMsg::fatal (bin.getLoc (), format (ValidateErrorMessage::UNDEFINED_BIN_OP, op, left.getType (), right.getType ()), notes-> errors[]);
    }

    /**
     * Validate a pointer operator (is and !is) assuming that the left operand is a class value
     * @params: 
     *   - context: the context of the validation
     *   - loc: the location of the operation
     *   - op: the operator
     *   - left: the left operand
     *   - right: the right operand
     * @returns: the result value
     * @throws:
     *    - &ErrorMsg: if the operation is not valid
     */
    fn validateClassPointerOp (self, dmut context : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Value)-> &Value
        throws &ErrorMsg
    {
        match left.getType () {
            lp : &ClassPtrType => {
                match right.getType () {
                    rp : &ClassPtrType => {
                        context.verifyCompatibleType (left.getLoc (), right.getLoc (), lp, rp);

                        // We are using a pointer cmp, because classptr are basically just pointers, and the result is just a bool, so there is no need to be much specific here
                        return CmpPointerOperatorValue::new (loc, op, left, right); 
                    }
                }
            }
        }

        throw ErrorMsg::list ([]);
    }


    /*!
     * ================================================================================
     * ================================================================================
     * =========================             SET              =========================
     * ================================================================================
     * ================================================================================
     */


    /**
     * Validate a binary operation involving a set operator
     * @params: 
     *   - context: the context of the validation
     *   - op: the operator (assuming it's a set operator)
     *   - bin: the binary expression to validate
     * @returns: the validated value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    fn validateSetOperation (self, dmut context : &Validator, op : BinaryOperators, bin : &BinaryExpr)-> &Value
        throws &ErrorMsg
    {
        if (op == BinaryOperators::NOT_IN || op == BinaryOperators::IN) {
            return self.validateContainOperation (alias context, op, bin);
        } else {
            return self.validateConcatOperation (alias context, op, bin);
        }
    }

    /**
     * Validate a contain operation (in or !in)
     * @params: 
     *   - context: the context of the validation
     *   - op: the operator (assuming it's a set operator)
     *   - bin: the binary expression to validate
     * @returns: the validated value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    fn validateContainOperation (self, dmut context : &Validator, op : BinaryOperators, bin : &BinaryExpr)-> &Value
        throws &ErrorMsg
    {
        let right = context:.implicitEnumUnwrap (context:.validateValue (bin.getRight ()));
        let dmut errors = Vec!{&ErrorMsg}::new ();
        {
            match right.getType () {
                c : &ClassPtrType => {
                    return self.validateClassContainOp (alias context, op, c, bin, right);
                }
                SliceType () => { return self.validateSliceOrArrayContainOp (alias context, op, bin, right); }
                a : &ArrayType => {
                    return self.validateSliceOrArrayContainOp (alias context, op, bin, context.createSliceAliasFromArray (bin.getLoc (), a, right));
                }
                RangeType () => { return self.validateRangeContainOp (alias context, op, bin, right); }
                // Other types (native, or stuff like that) cannot override the opContains
            }
        } catch {
            err : &ErrorMsg => {
                errors:.push (err);
            }
        }

        let left = context:.validateValue (bin.getLeft ());
        throw ErrorMsg::fatal (bin.getLoc (), format (ValidateErrorMessage::UNDEFINED_BIN_OP, op, left.getType (), right.getType ()), notes-> errors[]);
    }

    /**
     * Validate a contain operation (in or !in) for a class type value as right operand
     * @params: 
     *   - context: the context of the validation
     *   - op: the operator (assuming it's a set operator)
     *   - bin: the binary expression to validate
     *   - right: the right operand
     * @returns: the validated value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    fn validateClassContainOp (self, dmut context : &Validator, op : BinaryOperators, cptr : &ClassPtrType, bin : &BinaryExpr, right : &Value)-> &Value
        throws &ErrorMsg
    {
        let leftOperand = context:.validateValue (bin.getLeft ());
        let meth = context:.constructObjectMethodAcc (bin.getLoc (), cptr, right, OpOverrideNames::CONTAIN_OP_OVERRIDE);
        let call = context:.getCallOpValidator ().validate (alias context, bin.getLoc (), meth, [leftOperand]);

        if (op == BinaryOperators::NOT_IN) { // !in is rewritten into '!(right.opContains (left))'
            context:.getUnOpValidator ().validateNotOperator (alias context, bin.getLoc (), call)
        } else {
            call
        }
    }                

    /**
     * Validate a contain operation (in or !in) for a slice or array type value as right operand
     * @params:
     *   - context: the context of the validation
     *   - op: the operator (assuming it's a set operator)
     *   - bin: the binary expression to validate
     *   - right: the right operand
     * @returns: the validated value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    fn validateSliceOrArrayContainOp (self, dmut context : &Validator, op : BinaryOperators, bin : &BinaryExpr, right : &Value)-> &Value
        throws &ErrorMsg
    {
        let left = context:.validateValue (bin.getLeft ());

        // Create the var path to the core function core::array::opContains
        let syntVar = context.createSyntaxVarFromPath (bin.getLoc (), [CoreNames::CORE_MODULE, CoreNames::ARRAY_MODULE, OpOverrideNames::CONTAIN_OP_OVERRIDE]);
        let func = context:.validateValue (syntVar);
        let call = context:.getCallOpValidator ().validate (alias context, bin.getLoc (), func, [right, left]);

        if (op == BinaryOperators::NOT_IN) { // !in is rewritten into '!(opContains (right, left))'
            context:.getUnOpValidator ().validateNotOperator (alias context, bin.getLoc (), call)
        } else {
            call
        }
    }

    /**
     * Validate a contain operation (in or !in) for a range value as right operand
     * @params:
     *     - context: the context of the operation
     *     - op: the operator (assuming it's a set operator)
     *     - bin: the binary expression to validate
     *     - right: the right operand (already validated)
     * @returns: the validated value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     * */
    fn validateRangeContainOp (self, dmut context : &Validator, op : BinaryOperators, bin : &BinaryExpr, right : &Value)-> &Value
        throws &ErrorMsg
    {
        let left = context:.validateValue (bin.getLeft ());

        let syntVar = context.createSyntaxVarFromPath (bin.getLoc (), [CoreNames::CORE_MODULE, CoreNames::RANGE_MODULE, OpOverrideNames::CONTAIN_OP_OVERRIDE]);
        let func = context:.validateValue (syntVar);
        let call = context:.getCallOpValidator ().validate (alias context, bin.getLoc (), func, [right, left]);

        let res = if (op == BinaryOperators::NOT_IN) { // !in is rewritten into '!(opContains (right, left))'
            context:.getUnOpValidator ().validateNotOperator (alias context, bin.getLoc (), call)
        } else {
            call
        };

        RangeContainValue::new (bin.getLoc (), res.getType (), op, left, right, res)
    }

    /**
     * Validate a contain operation (in or !in) for a struct typed value as right operand
     * @params: 
     *   - context: the context of the validation
     *   - op: the operator (assuming it's a set operator)
     *   - bin: the binary expression to validate
     *   - right: the right operand
     * @returns: the validated value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid 
     */
    fn validateStructContainOp (self, dmut context : &Validator, op : BinaryOperators, bin : &BinaryExpr, right : &Value)-> &Value
        throws &ErrorMsg
    {
        let left = context:.validateValue (bin.getLeft ());

        let syntVar = VarExpr::new (Word::new (OpOverrideNames::CONTAIN_OP_OVERRIDE, bin.getLoc ()));
        let func = context:.validateValue (syntVar);
        let call = context:.getCallOpValidator ().validate (alias context, bin.getLoc (), func, [right, left]);

        let res = if (op == BinaryOperators::NOT_IN) { // !in is rewritten into '!(opContains (right, left))'
            context:.getUnOpValidator ().validateNotOperator (alias context, bin.getLoc (), call)
        } else {
            call
        };

        res
    }
    
    /**
     * Validate a concatenation operation (~)
     * @params: 
     *   - context: the context of the validation
     *   - op: the operator (assuming it's a set operator)
     *   - bin: the binary expression to validate
     * @returns: the validated value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    fn validateConcatOperation (self, dmut context : &Validator, op : BinaryOperators, bin : &BinaryExpr)-> &Value
        throws &ErrorMsg
    {
        let mut left = context:.implicitEnumUnwrap (context:.validateValue (bin.getLeft ()));
        let mut right = context:.implicitEnumUnwrap (context:.validateValue (bin.getRight ()));

        let dmut errors = Vec!{&ErrorMsg}::new ();
        {
            match left.getType () { // We first try to validate the operation as a left operation
                c : &ClassPtrType => { return self.validateClassOpLeft (alias context, bin.getLoc (), op, c, left, right); }
                SliceType () => { return self.validateSliceOrArrayConcatOp (alias context, bin.getLoc (), op, left, right); }
                ArrayType () => { return self.validateArrayConcatOp (alias context, bin.getLoc (), op, left, right); }
            };
        } catch {
            err : &ErrorMsg => {
                errors:.push (err);
            }
        }

        { // The concat operator works as a math operator for class and structs (opBinary!{"~"} (left, right))
            match right.getType () { // Now we try to validate the operation as a right operation (opBinaryRight!{"~"}(right, left))
                c : &ClassPtrType => { return self.validateClassOpRight (alias context, bin.getLoc (), op, c, left, right); }
            };
            // If the right operand is not a class nor struct, we don't add any error because there is already an error for the 'as left' operation
        } catch {
            err : &ErrorMsg => {
                errors:.push (err);
            }
        }

        throw ErrorMsg::fatal (bin.getLoc (), format (ValidateErrorMessage::UNDEFINED_BIN_OP, op, left.getType (), right.getType ()), notes-> errors[]);
    }

    /**
     * Validate a concatenation operation (~), where the left operand is an array
     * @params:
     *     - context: the context of the validation
     *     - loc: the location of the operation
     *     - op: the operator
     *     - left: the left operand (with an array type)
     *     - right: the right operand
     *  @returns: the validated value
     *  @throws:
     *     - &ErrorMsg: if the operation is not valid
     * */
    fn validateArrayConcatOp (self, dmut context : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Value)-> &Value
        throws &ErrorMsg
    {
        match right.getType () {
            SliceType () => { return self.validateSliceOrArrayConcatOp (alias context, loc, op, left, right); }
            ArrayType () => {}
            _ => {
                throw ErrorMsg::list ([]);
            }
        }

        let uniqL = left;
        let uniqR = right;

        let leArrType = left.getType ().asOf!{&ArrayType} ();
        let riArrType = right.getType ().asOf!{&ArrayType} ();

        context:.verifyCompatibleType (left.getLoc (), right.getLoc (), leArrType.getInners ()[0], riArrType.getInners ()[0]);

        let mut inner : &Type = NoneType::new (loc);
        let dmut finParams = Vec!{&Value}::new ();
        for it in 0us .. leArrType.getLen () {
            let val = context:.getIndexOpValidator ().createArrayAccess (loc, leArrType.getInners ()[0], uniqL, makeIntValue (loc, it));
            inner = context:.getLiteralValidator ().addArrayType (alias context, val, alias finParams, inner);
        }

        for it in 0us .. riArrType.getLen () {
            let val = context:.getIndexOpValidator ().createArrayAccess (loc, leArrType.getInners ()[0], uniqR, makeIntValue (loc, it));
            inner = context:.getLiteralValidator ().addArrayType (alias context, val, alias finParams, inner);
        }

        // Concatenation of two void arrays
        if (finParams.len () == 0us) inner = VoidType::new (loc);

        let arrType = ArrayType::new (loc, inner, finParams.len (), isMutable-> true);
        ArrayValue::new (loc, arrType, finParams [])
    }
    
    /**
     * Validate a concatenation operation (~), where left operand is a slice
     * @params: 
     *   - context: the context of the validation
     *   - loc: the location of the operation
     *   - op: the operator (assuming it's a set operator)
     *   - left: the left operand of the operation
     *   - right: the right operand of the operation
     * @returns: the validated value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    fn validateSliceOrArrayConcatOp (self, dmut context : &Validator, loc : &Word, _ : BinaryOperators, left : &Value, right : &Value)-> &Value
        throws &ErrorMsg
    {        
        // Slice and arrays are almost the same type, (slice being pointer to arrays), but we first need to transform the arrays into slices
        // The left element has to be a slice or an array
        let finLeft = match left.getType () {
            SliceType () => { left }
            a : &ArrayType => {
                context.createSliceAliasFromArray (loc, a, left)
            }
            _ => { throw ErrorMsg::list ([]); }
        };
        
        // The concatenation can be made only with an element of the same type, that is to say a slice or an array
        let finRight = match right.getType () {
            SliceType () => { right }
            a : &ArrayType => {
                context.createSliceAliasFromArray (loc, a, right)
            }
            _ => { throw ErrorMsg::list ([]); }
        };

        context:.verifyCompatibleType (finLeft.getLoc (), finRight.getLoc (), finLeft.getType (), finRight.getType ()); // Evidently the concat is made only with slices of the same kind
        let mut retType = if (finLeft.getType ().mutabilityFit (finRight.getType ())) { // the mutability of the result is the same mutability as the type with the lowest mutability level
            finRight.getType ()
        } else {
            finLeft.getType ()
        };

        // If the type of left or right operands is const, we still can modify
        // the inner values, without modifying the inner borrowed datas
        if (!retType.asOf!{&SliceType} ().getInners ()[0].isMutable ()) {
            retType = retType.clone (2u32);
        }

        SliceConcatValue::new (loc, retType, finLeft, finRight)
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================             TYPE             =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a binary operation involving a type operator
     * @params: 
     *   - context: the context of the validation
     *   - op: the operator (assuming it's a type operator)
     *   - bin: the binary expression to validate
     * @returns: the validated value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    fn validateTypeOperation (self, dmut context : &Validator, op : BinaryOperators, bin : &BinaryExpr)-> &Value
        throws &ErrorMsg
    {
        let left = context:.implicitEnumUnwrap (context:.validateValue (bin.getLeft ()));
        let right = context:.validateType (bin.getRight ());

        let dmut errors = Vec!{&ErrorMsg}::new ();
        {
            match left.getType () {
                ClassPtrType () =>
                    return self.validateClassTypeTestOp (alias context, bin.getLoc (), op, left, right, candidate-> false);
            };
        } catch {
            err : &ErrorMsg => {
                errors:.push (err);
            }
        }

        throw ErrorMsg::fatal (bin.getLoc (), format (ValidateErrorMessage::UNDEFINED_BIN_OP, op, left.getType ()), notes-> errors[]);
    }

    /**
     * Validate a type test operator (of and !of) assuming the left operand is a class value
     * @params:
     *    - context: the context of the validation
     *    - loc: the location of the operation
     *    - op: the operator
     *    - left: the left operand
     *    - right: the right operand
     * @returns: the result value of type bool
     * @throws:
     *     - &ErrorMsg: if the operation is not valid
     * */
    pub fn validateClassTypeTestOp (self, dmut context : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Type, candidate : bool = true)-> &Value
        throws &ErrorMsg
    {
        let clRef = left.getType ().asOf!{&ClassPtrType} ().getInner ();
        match right {
            rp : &ClassRefType => {
                if (clRef.isCompatible (rp)) { // typeof (left) == right
                    return BoolValue::new (loc, op == BinaryOperators::OF);
                } else if (context.isAncestor (rp, clRef)) { // typeof (left) over right, so /left/ is of /right/
                    return BoolValue::new (loc, op == BinaryOperators::OF);
                } else if (context.isAncestor (clRef, rp)) { // right over typeof (left), so /left/ can contain an instance of /right/
                    return CmpClassTypeOperatorValue::new (loc, op, left, rp);
                }
            }
        }

        if (candidate) {
            throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_BIN_OP, op, left.getType ()));
        } else {
            throw ErrorMsg::list ([]);
        }
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================            FIELD             =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a binary operation involving a field operator
     * @params: 
     *   - context: the context of the validation
     *   - op: the operator (assuming it's a field operator)
     *   - bin: the binary expression to validate
     * @returns: the validated value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    fn validateFieldOperation (self, dmut context : &Validator, op : BinaryOperators, bin : &BinaryExpr)-> &Value
        throws &ErrorMsg
    {
        let left = if (op == BinaryOperators::DOT_AND) {
            context:.getValueValidator ().validateAlias (alias context, bin.getLoc (), bin.getLeft (), isClass-> true)
        } else {
            context:.implicitEnumUnwrap (context:.validateValue (bin.getLeft ()))
        };

        self.validateFieldOperation (alias context, bin.getLoc (), op, left, bin.getRight ())
    }


    /**
     * Validate a field operation
     * @params:
     *    - context: the context of the validation
     *    - loc: the location of the access
     *    - op: the operator
     *    - left: the left operand
     *    - right: the field being accessed
     * @returns: the validated value
     * @throws:
     *    - &ErrorMsg: if the operation is not valid
     * */
    pub fn validateFieldOperation (self, dmut context : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Expression)-> &Value
        throws &ErrorMsg
    {
        match left.getType () {
            cptr : &ClassPtrType => {
                return self.validateClassFieldVtableOperation (alias context, loc, cptr, left, right);
            }
            tuple : &TupleType => {
                return self.validateTupleFieldOperation (alias context, loc, op, tuple, left, right);
            }
            range : &RangeType => {
                return self.validateRangeFieldOperation (alias context, loc, op, range, left, right);
            }
            sl : &SliceType => {
                return self.validateSliceFieldOperation (alias context, loc, op, sl, left, right);
            }
            arr : &ArrayType => {
                return self.validateArrayFieldOperation (alias context, loc, op, arr, left, right);
            }
            o : &OptionType => {
                return self.validateOptionFieldOperation (alias context, loc, op, o, left, right);
            }
        }

        throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_BIN_OP, op, left.getType (), right));
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================      CLASS FIELD VTABLE      =========================
     * ================================================================================
     * ================================================================================
     */
    
    /**
     * Validate a field or vtable access operation on a class instance value
     * @params: 
     *    - context: the context of the validation
     *    - op: the operator
     *    - left: the instance value
     *    - right: the right operand
     */
    fn validateClassFieldVtableOperation (self, dmut context : &Validator, loc : &Word, cptr : &ClassPtrType, left : &Value, right : &Expression)-> &Value
        throws &ErrorMsg
    {
        let (inPrv, inProt) = context:.getCurrentClassContextProtections (cptr.getInner ());
        {                    
            return self.validateClassFieldAccess (alias context, loc, left, right, cptr.getInner (), inProt, inPrv);
        } catch {
            err : &ErrorMsg => {
                {
                    match self.validateClassVtableAccess (alias context, left, right, cptr.getInner (), left.isOf!{&SuperProxyValue} (), inProt, inPrv) {
                        UnitValue () => throw err;
                        v : _ => return v;
                    };
                } catch {
                    vtableErr : &ErrorMsg => {
                        match self.validateClassBasicFieldAccess (alias context, left, right, cptr) {
                            UnitValue () => throw vtableErr;
                            v : _ => return v;
                        }
                    }
                }
            }
        }        
    }

    /**
     * Validate a field access operation on a class instance value
     * @params: 
     *    - context: the context of the validation
     *    - left: the instance of the class
     *    - right: the field to access
     *    - clRef: the type of the class
     *    - inProt: true iif current context has access to protected fields
     *    - inPrv: true iif current context has access to private fields
     */
    pub fn validateClassFieldAccess (self, dmut context : &Validator, loc : &Word, left : &Value, right : &Expression, clRef : &ClassRefType, inProt : bool, inPrv : bool, verifyValidation : bool = true, withAncestor : bool = true)-> &Value
        throws &ErrorMsg
    {
        match right {
            field : &VarExpr => { // Only work with varexpr
                for it in clRef.getLocalFields () match it {
                    v : &VarDeclValue => {
                        if (v.getLoc ().str () == field.getLoc ().str ()) {
                            if (clRef.getSymbol ().isFieldPrivate (field.getLoc ().str ()) && !inPrv) { // The field exists but is private, and we don't have access to private fields (outside class, or ancestor)
                                throw ErrorMsg::fatal (right.getLoc (), format (DeclareErrorMessage::PRIVATE_IN_THIS_CONTEXT, right.getLoc ().str ()),
                                                       notes-> [ErrorMsg::note (v.getLoc (), ValidateErrorMessage::DECLARED_HERE)]);
                            } else if (clRef.getSymbol ().isFieldProtected (field.getLoc ().str ()) && !inPrv && !inProt) { // The field exists but we are outside the class definition
                                throw ErrorMsg::fatal (right.getLoc (), format (DeclareErrorMessage::PRIVATE_IN_THIS_CONTEXT, right.getLoc ().str ()),
                                                       notes-> [ErrorMsg::note (v.getLoc (), ValidateErrorMessage::DECLARED_HERE)]);
                            }
                            
                            if (verifyValidation) { // Verify that the field is initialized and ready to be used (for pre constructor context)
                                if (context.isInFieldConstruction () && context.getFieldConstructionType () == clRef) { // it is a local field of the class being constructed
                                    let isSelf = match left {
                                        zself : &VarRefValue => { zself.isSelf () }
                                        _ => { false }
                                    };

                                    if (isSelf && field.getLoc ().str () !in context.getFieldValidated ()) { // And the field is not init yet on self
                                        throw ErrorMsg::fatal (right.getLoc (), format (ValidateErrorMessage::CLASS_FIELD_NOT_INIT_YET, right.getLoc ().str ()),
                                                               notes-> [ErrorMsg::note (v.getLoc (), ValidateErrorMessage::DECLARED_HERE)]);
                                    }
                                }
                            }

                            // If the class is immutable, the field cannot be mutable
                            let type = if (left.getType ().isDeeplyMutable ()) { v.getVarType () } else { v.getVarType ().clone (0u32) };

                            if (left.isOf!{&ClassAliaserValue} ()) {
                                throw ErrorMsg::fatal (loc, end-> right.getLoc (), format (ValidateErrorMessage::CLASS_ALIAS_FIELD));
                            }

                            // The field is public in this context, we return the access
                            if (clRef.getSymbol ().isStruct ()) {
                                return StructFieldAccessValue::new (right.getLoc (), type, left, field.getLoc ().str ());
                            } else {
                                return ClassFieldAccessValue::new (right.getLoc (), type, left, field.getLoc ().str ());
                            }
                        }
                    }
                    _ => __pragma!panic ();
                }

                if (withAncestor) {
                    match clRef.getAncestor () {
                        ancRef : &ClassRefType => { // Maybe the field is a field of an ancestor
                            return self.validateClassFieldAccess (alias context, loc, left, right, ancRef, inProt || inPrv, false);
                        }
                    }
                }
            }
        };

        
        throw ErrorMsg::fatal (right.getLoc (), format (ValidateErrorMessage::CLASS_NO_FIELD, left.getType (), right));
    }

    /**
     * Validate a vtable access operation on a class instance value
     * @params:
     *     - context: the context of the validation
     *     - left: the instance of the class
     *     - right: the field to access
     *     - clRef: the type of the class
     *     - inProt: true iif current context has access to protected vtable
     *     - inPrv: true iif current context has access to private vtable
     *     - allowImmut: true iif an alias can be used to access a const method
     */
    pub fn validateClassVtableAccess (self, dmut context : &Validator, left : &Value, right : &Expression, clRef : &ClassRefType, isProxy : bool, inProt : bool, inPrv : bool, allowImmut : bool = false)-> &Value
        throws &ErrorMsg
    {
        let dmut errors = Vec!{&ErrorMsg}::new ();
        let dmut values = Vec!{&Value}::new ();
        let dmut isFields = Vec!{bool}::new ();

        self.validateMethodClassAccess (alias context, left, right, clRef, isProxy, inProt, inPrv, alias values, alias isFields, alias errors, allowImmut);
        self.validateTemplateMethodClassAccess (alias context, left, right, clRef, inProt, inPrv, alias values, alias isFields, alias errors, allowImmut);

        if (values.len () == 0us) {
            if (errors.len () != 0us) throw ErrorMsg::list (errors[]);
            UNIT_VALUE // the class has no method named right
        } else if (values.len () == 1us) {
            if (isFields[][0us]) {
                return context:.getCallOpValidator ().validate (alias context, right.getLoc (), values[][0us], []);
            }

            values[][0us]
        } else {
            // for v, i in values {
            //     if (isFields[i]) {
            //         (alias values) [i] = context:.getCallOpValidator ().validate (alias context, right.getLoc (), v, []);
            //     }
            // }

            MultSymValue::new (right.getLoc (), values[], prettyStr-> format ("%", right))
        }
    }

    /**
     * Basic fields are fields that are inside the object instance, but are not user defined (i.e. __typeinfo__, __typeid__, __monitor__)
     * @params:
     *     - context: the context of the validation
     *     - left: the object value
     *     - right: the field accessed
     * @returns: UnitValue if the access is wrong, a value otherwise
     * */
    fn validateClassBasicFieldAccess (self, dmut context : &Validator, left : &Value, right : &Expression, cptr : &ClassPtrType)-> &Value
        throws &ErrorMsg
    {
        let clRef = cptr.getInner ();
        match right {
            v : &VarExpr => {
                let indent = context.getSubTypeValidator ().removeUnders (v.getLoc ().str ());
                if (indent == Keys::TYPEINFO) {
                    if (cptr.isStruct ()) {
                        return context:.getTypeInfoValidator ():.validate (alias context, left.getLoc (), cptr);
                    } else {
                        let typeinfoT = clRef.getTypeInfo ().asOf!{&Value} ().getType ();
                        return ClassTypeInfoAccessValue::new (v.getLoc (), typeinfoT, str-> left);
                    }
                }

                if (indent == Keys::TYPEID) {
                    if (cptr.isStruct ()) {
                        let content = format ("%", cptr);
                        return makeStringSliceValue (left.getLoc (), content)
                    } else {
                        let typeinfoV = clRef.getTypeInfo ().asOf!{&TypeInfoValue} ();
                        let nameT = typeinfoV.getName ().getType ();

                        let typeinfo = ClassTypeInfoAccessValue::new (v.getLoc (), typeinfoV.getType (), str-> left);
                        return StructFieldAccessValue::new (v.getLoc (), nameT, typeinfo, TypeInfoKeys::NAME);
                    }
                }

                if (indent == Keys::SUPER && !cptr.isStruct ()) {
                    if (!context.isSelf (left)) throw ErrorMsg::fatal (v.getLoc (), end-> left.getLoc (), format (ValidateErrorMessage::SUPER_NO_SELF_CLASS, cptr));
                    match clRef.getAncestor () {
                        c : &ClassRefType => {
                            return SuperProxyValue::new (v.getLoc (),
                                                         c.createInstance (isMutable-> cptr.isMutable (), isInnerMutable-> cptr.isDeeplyMutable ()),
                                                         left);
                        }
                        _ => {
                            throw ErrorMsg::fatal (v.getLoc (), end-> left.getLoc (), format (ValidateErrorMessage::NO_SUPER_CLASS, cptr));
                        }
                    }
                }
            }
        }

        UNIT_VALUE
    }

    /**
     * Validate the access to the non template methods from the vtable of a class value
     * * @params:
     *    - context: the context of the validation
     *    - left: the object value
     *    - right: the field accessed
     *    - clRef: the reference to the class type
     *    - inProt: true if in protected context
     *    - inPrv: true if in private context
     * @returns:
     *    - values: insert all method delegate values
     * */
    fn validateMethodClassAccess (self, dmut _ : &Validator, left : &Value, right : &Expression, clRef : &ClassRefType, isProxy : bool, inProt : bool, inPrv : bool, dmut values : &Vec!{&Value}, dmut isFields : &Vec!{bool}, dmut errors : &Vec!{&ErrorMsg}, allowImmut : bool) {
        match right {
            meth : &VarExpr => {
                for i, v in clRef.getVtable () {
                    if (v.getSymbol ().getPath ().file () == meth.getLoc ().str ()) {
                        if (v.getSymbol ().getProtection () == Protection::PRIVATE && !inPrv) {
                            errors:.push (ErrorMsg::fatal (right.getLoc (), format (DeclareErrorMessage::PRIVATE_IN_THIS_CONTEXT, v, withTags-> ["withParams"s8]),
                                                   notes-> [ErrorMsg::note (v.getSymbol ().getLoc (), ValidateErrorMessage::DECLARED_HERE)]));
                        } else if (v.getSymbol ().getProtection () == Protection::PROTECTED && !inPrv && !inProt) {
                            errors:.push (ErrorMsg::fatal (right.getLoc (), format (DeclareErrorMessage::PRIVATE_IN_THIS_CONTEXT, v, withTags-> ["withParams"s8]),
                                                   notes-> [ErrorMsg::note (v.getSymbol ().getLoc (), ValidateErrorMessage::DECLARED_HERE)]));
                        } else {
                            let isDirect = isProxy || match clRef.getAncestor () {
                                NoneType () => { !v.isVirtual () || clRef.getSymbol ().isFinal () || clRef.getSymbol ().isStruct () } // final class with no ancestor does not need vtable
                                _ =>  { !v.isVirtual () } // method that are not over and are final are not virtual
                            };

                            let isField = v.isField ();

                            if (v.isMutable () && !left.isOf!{&ClassAliaserValue} ()) {
                                let mut notes = [ErrorMsg::note (left.getLoc (), format (ValidateErrorMessage::IMPLICIT_ALIAS, left.getType ()))];
                                if (left.isOf!{&AliaserValue} ()) notes = notes ~ [ErrorMsg::note (left.getLoc (), end-> v.getLoc (), format (ValidateErrorMessage::SIMPLE_ALIAS_NOT_CLASS), oneLine-> true)];

                                errors:.push (ErrorMsg::fatal (v.getLoc (), format (ValidateErrorMessage::MUTABLE_METHOD, v, withTags-> ["withParams"s8]),
                                                               notes-> notes));
                            } else if (!v.isMutable () && (left.isOf!{&ClassAliaserValue} () || left.isOf!{&AliaserValue} ()) && !allowImmut) {
                                errors:.push (ErrorMsg::fatal (v.getLoc (), format (ValidateErrorMessage::CONST_METHOD, v, withTags-> ["withParams"s8]),
                                                               notes-> [ErrorMsg::note (left.getLoc (), format (ValidateErrorMessage::UNECESSARY_ALIAS, left.getType ()))]));
                            } else {
                                isFields:.push (isField);
                                values:.push (MethodDelegateValue::new (v.getLoc (), v, closure-> left, direct-> isDirect, vtableIndex-> i, isStruct-> clRef.isStruct ()));
                            }
                        }
                    }
                }
            }
            // _ => {
            // We don't throw an error, assuming that validateClassFieldAccess is always called before, thus the error would be replicated
            // }
        };

    }

    /**
     * Validate the access to the template methods defined within the class symbol
     * @params:
     *    - context: the context of the validation
     *    - left: the object value
     *    - right: the field accessed
     *    - clRef: the reference to the class type
     *    - inProt: true if in protected context
     *    - inPrv: true if in private context
     * @returns:
     *    - values: insert all template values
     * */
    fn validateTemplateMethodClassAccess (self, dmut _ : &Validator, left : &Value, right : &Expression, clRef : &ClassRefType, inProt : bool, inPrv : bool, dmut values : &Vec!{&Value}, dmut isFields : &Vec!{bool}, dmut errors : &Vec!{&ErrorMsg}, allowImmut : bool) {
        match right {
            meth : &VarExpr => {
                let prots = clRef.getTemplateMethodProtections ();
                for i, v in clRef.getTemplateMethods () {
                    if (v.getFunctionName () == meth.getLoc ().str ()) {
                        if (prots [i] <= MethodProtection::PRV && !inPrv) {
                            errors:.push (ErrorMsg::fatal (right.getLoc (), format (DeclareErrorMessage::PRIVATE_IN_THIS_CONTEXT, v, withTags-> ["withParams"s8]),
                                                           notes-> [ErrorMsg::note (v.getSymbol ().getLoc (), ValidateErrorMessage::DECLARED_HERE)]));
                        } else if (prots [i] == MethodProtection::PROT && !inPrv && !inProt) {
                            errors:.push (ErrorMsg::fatal (right.getLoc (), format (DeclareErrorMessage::PRIVATE_IN_THIS_CONTEXT, v, withTags-> ["withParams"s8]),
                                                           notes-> [ErrorMsg::note (v.getSymbol ().getLoc (), ValidateErrorMessage::DECLARED_HERE)]));
                        } else {
                            if (v.isMutable () && !left.isOf!{&ClassAliaserValue} ()) {
                                let mut notes = [ErrorMsg::note (left.getLoc (), format (ValidateErrorMessage::IMPLICIT_ALIAS, left.getType ()))];
                                if (left.isOf!{&AliaserValue} ()) notes = notes ~ [ErrorMsg::note (left.getLoc (), end-> v.getLoc (), format (ValidateErrorMessage::SIMPLE_ALIAS_NOT_CLASS), oneLine-> true)];

                                errors:.push (ErrorMsg::fatal (v.getLoc (), format (ValidateErrorMessage::MUTABLE_METHOD, v, withTags-> ["withParams"s8]),
                                                               notes-> notes));
                            } else if (!v.isMutable () && (left.isOf!{&ClassAliaserValue} () || left.isOf!{&AliaserValue} ()) && !allowImmut) {
                                errors:.push (ErrorMsg::fatal (v.getLoc (), format (ValidateErrorMessage::CONST_METHOD, v, withTags-> ["withParams"s8]),
                                                               notes-> [ErrorMsg::note (left.getLoc (), format (ValidateErrorMessage::UNECESSARY_ALIAS, left.getType ()))]));
                            } else {
                                isFields:.push (false);
                                values:.push (MethodDelegateTemplateValue::new (v.getLoc (), v, closure-> left, isStruct-> clRef.isStruct ()));
                            }
                        }
                    }
                }
            }
        }
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================         TUPLE FIELD          =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a field access on a tuple value
     * @params: 
     *    - context: the context of the validation
     *    - loc: the location of the access
     *    - tuple: the type of the value whose field is accessed
     *    - left: the value whose content is accessed
     *    - right: the right operand of the operation
     * @returns: the result value of the access
     * @throws:
     *    - &ErrorMsg: if the access is invalid
     */
    fn validateTupleFieldOperation (self, dmut context : &Validator, loc : &Word, _ : BinaryOperators, tuple : &TupleType, left : &Value, right : &Expression)-> &Value
        throws &ErrorMsg
    {
        let rightVal = {
            context:.enterDollar (left);
            {
                context:.implicitEnumUnwrap (context:.validateValue (right))
            } exit {
                context:.exitDollar ();
            }
        } catch {
            err : &ErrorMsg => {
                throw err.withNote ([ErrorMsg::fatal (right.getLoc (), format (ValidateErrorMessage::TYPE_NO_FIELD, left.getType (), right))]);
            }
        };

        let val = context:.getCompileTimeInterpreter ().computeInt (rightVal, signed-> false);
        let arity = tuple.getInners ().len;
        
        {
            let acc = if (val < 0) {
                let _abs : usize = cast!usize (val.to!isize ().abs ());
                if (arity < _abs) throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::TUPLE_ARITY_OVERFLOW, _abs, arity));
                arity - _abs                    
            } else {
                if (arity <= val.to!usize ()) throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::TUPLE_ARITY_OVERFLOW, val, arity));
                val.to!usize ()
            };

            let innerType = tuple.getInners ()[acc];
            
            let retType = if (left.isLvalue () && tuple.isMutable ()) {
                innerType
            } else {
                innerType.clone (0u32)
            }

            return self.createTupleFieldAccess (loc, retType, left, acc);
        } catch {
            x : &ErrorMsg => throw x;
            _ => throw ErrorMsg::fatal (rightVal.getLoc (), format (ValidateErrorMessage::OVERFLOW_CAPACITY, IntType::new (rightVal.getLoc (), size-> 0u16, signed-> false), val, u64::max));
        }
    }

    /**
     * Create a tuple field access value
     * @info: optimize a bit the access if it is done on a tuple construction
     * @params:
     *    - loc: the location of the access
     *    - type: the return type
     *    - value: the left operand of the access
     *    - index: the index of the access (assumed to be overflow checked before hand)
     * */
    pub fn createTupleFieldAccess (self, loc : &Word, type : &Type, value : &Value, index : usize, reduce : bool = true)-> &Value {
        match (value, reduce) {
            (tu : &TupleValue, true) => {
                return tu.getValues ()[index]
            }
            _ => {
                cast!{&Value} (TupleFieldAccessValue::new (loc, type, value, index))
            }
        }
    }


    /*!
     * ================================================================================
     * ================================================================================
     * =========================         RANGE FIELD          =========================
     * ================================================================================
     * ================================================================================
     */


    /**
     * Validate a field operation on a range value
     * @params: 
     *    - context: the context of the validation
     *    - loc: the location of the access
     *    - op: the operator used to perform the access
     *    - range: the type of the left operand
     *    - left: the value of the left operand
     *    - right: the expression of the access (right operand)
     * @returns: a value containing the field access on the range
     * @throws:
     *    - &ErrorMsg: if the access is invalid
     */
    fn validateRangeFieldOperation (self, dmut _ : &Validator, loc : &Word, _ : BinaryOperators, range : &RangeType, left : &Value, right : &Expression)-> &Value
        throws &ErrorMsg
    {
        match right {
            field : &VarExpr => {
                match field.getLoc ().str () {
                    RangeKeys::FST | RangeKeys::SCD => {
                        let type = range.getInners ()[0];
                        return StructFieldAccessValue::new (loc, type, left, field.getLoc ().str ());
                    }
                    RangeKeys::STEP => {
                        let type = range.getInners ()[1];
                        return StructFieldAccessValue::new (loc, type, left, field.getLoc ().str ());
                    }
                    RangeKeys::CONTAIN => {
                        let type = BoolType::new (loc, isMutable-> range.isMutable ());
                        return StructFieldAccessValue::new (loc, type, left, field.getLoc ().str ());
                    }
                }
            }
        }

        throw ErrorMsg::fatal (right.getLoc (), format (ValidateErrorMessage::TYPE_NO_FIELD, left.getType (), right));
    }
    

    /*!
     * ================================================================================
     * ================================================================================
     * =======================         SLICE/ARRAY FIELD          =====================
     * ================================================================================
     * ================================================================================
     */
    
    /**
     * Validate a field operation on a slice value
     * @params:
     *    - context: the context of the validation
     *    - loc: the location of the access
     *    - slice: the type of the slice being accessed
     *    - left: the left value of the left operand
     *    - right: the expression of the access (right operand)
     * @returns: a value containing the field access on the slice
     * @throws: 
     *    - &ErrorMsg: if the access is invalid
     */
    fn validateSliceFieldOperation (self, dmut _ : &Validator, loc : &Word, _ : BinaryOperators, slice : &SliceType, left : &Value, right : &Expression)-> &Value
        throws &ErrorMsg
    {
        match right {
            field : &VarExpr => {
                match field.getLoc ().str () {
                    SliceKeys::LEN => {
                        let type = IntType::new (loc, size-> 0u16, signed-> false, isMutable-> false);
                        return StructFieldAccessValue::new (loc, type, left, field.getLoc ().str ());
                    }
                    SliceKeys::PTR => {
                        let inner = slice.getInners ()[0];
                        let ptr = PointerType::new (loc, inner, isMutable-> inner.isMutable ());
                        return StructFieldAccessValue::new (loc, ptr, left, field.getLoc ().str ());
                    }
                }
            }
        }

        throw ErrorMsg::fatal (right.getLoc (), format (ValidateErrorMessage::TYPE_NO_FIELD, left.getType (), right));
    }

    /**
     * Validate a field operation on an array value
     * @params:
     *    - context: the context of the validation
     *    - loc: the location of the access
     *    - slice: the type of the slice being accessed
     *    - left: the left value of the left operand
     *    - right: the expression of the access (right operand)
     * @returns: a value containing the field access on the slice
     * @throws: 
     *    - &ErrorMsg: if the access is invalid
     */
    fn validateArrayFieldOperation (self, dmut _ : &Validator, loc : &Word, _ : BinaryOperators, array : &ArrayType, left : &Value, right : &Expression)-> &Value
        throws &ErrorMsg
    {
        match right {
            field : &VarExpr => {
                match field.getLoc ().str () {
                    SliceKeys::LEN => {
                        return makeIntValue (loc, array.getLen ());
                    }
                    SliceKeys::PTR => {
                        let inner = array.getInners ()[0];
                        let ptr = PointerType::new (loc, inner, isMutable-> inner.isMutable ());
                        return AddressValue::new (loc, ptr, left);
                    }
                }
            }
        }
        
        throw ErrorMsg::fatal (right.getLoc (), format (ValidateErrorMessage::TYPE_NO_FIELD, left.getType (), right));
    }    

    /**
     * Validate a field operation on a option value
     * @params:
     *    - context: the context of the validation
     *    - loc: the location of the access
     *    - o: the option type being accessed
     *    - left: the left operand
     *    - right: the right operand
     * @returns: a value containins the field access on the option value
     * @throws:
     *    - &ErrorMsg: if the access is invalid
     * */
    fn validateOptionFieldOperation (self, dmut context : &Validator, loc : &Word, _ : BinaryOperators, otype : &OptionType, left : &Value, right : &Expression)-> &Value
        throws &ErrorMsg
    {
        match right {
            field : &VarExpr => {
                match field.getLoc ().str () {
                    OptionKeys::SET => {
                        let type = BoolType::new (loc);
                        return StructFieldAccessValue::new (loc, type, left, OptionKeys::SET);
                    }
                    OptionKeys::HAS_ERROR => {
                        let type = BoolType::new (loc), ptrType = PointerType::new (loc, VoidType::new (loc));
                        let isSet = UnaryBoolOperatorValue::new (loc, UnaryOperators::NOT, StructFieldAccessValue::new (loc, type, left, OptionKeys::SET));
                        let hasErr = CmpPointerOperatorValue::new (loc, BinaryOperators::NOT_EQUAL,
                                                                   OptionFieldAccessValue::new (loc, ptrType, left, OptionKeys::ERROR),
                                                                   NullValue::new (loc, ptrType));

                        return LogicalBinBoolOperatorValue::new (loc, BinaryOperators::DAND, isSet, hasErr);
                    }
                    OptionKeys::VALUE => {
                        let interpret = context.getCompileTimeInterpreter ();

                        let innerType = otype.getInners ()[0];
                        let boolType = BoolType::new (loc);
                        let isSet = interpret.reduce (UnaryBoolOperatorValue::new (loc, UnaryOperators::NOT, StructFieldAccessValue::new (loc, boolType, left, OptionKeys::SET)));
                        let value = OptionFieldAccessValue::new (loc, innerType, left, OptionKeys::VALUE);

                        match isSet { // we know at cte if the option has a value or not
                            b : &BoolValue => {
                                if (b.isTrue ()) throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::OPTION_HAS_NO_VALUE, otype)); // !x.hasValue
                                return value; // x.hasValue, thus return the value
                            }
                        }

                        let errType = context:.getExceptionFromName (loc-> loc, CoreNames::EMPTY_VAL_OPTION_EXCEPTION);
                        let errInstance = context:.constructObjectInstance (loc, errType, []);
                        let throwVal = ThrowValue::new (loc, errInstance);

                        let cond = ConditionalValue::new (loc, VOID_TYPE, isSet, throwVal, elsev-> UNIT_VALUE, isComplete-> false);

                        return BlockValue::new (loc, innerType, [cond, value], isSet-> true);
                    }
                    OptionKeys::ERROR => {
                        let type = BoolType::new (loc), ptrType = PointerType::new (loc, VoidType::new (loc));
                        let isSet = StructFieldAccessValue::new (loc, type, left, OptionKeys::SET);
                        let notHasErr = CmpPointerOperatorValue::new (loc, BinaryOperators::DEQUAL,
                                                                   OptionFieldAccessValue::new (loc, ptrType, left, OptionKeys::ERROR),
                                                                   NullValue::new (loc, ptrType));

                        let setOrNotHasError = context.getCompileTimeInterpreter ().reduce (LogicalBinBoolOperatorValue::new (loc, BinaryOperators::DPIPE, isSet, notHasErr));
                        let innerType = context:.getExceptionType (loc-> loc);

                        let value = OptionFieldAccessValue::new (loc, innerType, left, OptionKeys::ERROR);
                        match setOrNotHasError {
                            b : &BoolValue => {
                                if (b.isTrue ()) throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::OPTION_HAS_NO_ERROR, otype));
                                return value;
                            }
                        }

                        let errType = context:.getExceptionFromName (loc-> loc, CoreNames::EMPTY_ERR_OPTION_EXCEPTION);
                        let errInstance = context:.constructObjectInstance (loc, errType, []);
                        let throwVal = ThrowValue::new (loc, errInstance);

                        let cond = ConditionalValue::new (loc, VOID_TYPE, setOrNotHasError, throwVal, elsev-> UNIT_VALUE, isComplete-> false);

                        return BlockValue::new (loc, errType, [cond, value], isSet-> true);
                    }
                }
            }
        }

        throw ErrorMsg::fatal (right.getLoc (), format (ValidateErrorMessage::TYPE_NO_FIELD, left.getType (), right));
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================            MODULE            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a binary operation involving a module operator (left operand can be a type or a value)
     * @params: 
     *   - context: the context of the validation
     *   - bin: the binary expression to validate
     * @returns: the validated value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    pub fn validateModuleOperation (self, dmut context : &Validator, _ : BinaryOperators, bin : &BinaryExpr)-> &Value
        throws &ErrorMsg
    {
        let dmut errorTypes = Vec!{&ErrorMsg}::new ();
        let dmut errorFoll = Vec!{&ErrorMsg}::new ();
        let dmut finalVals = Vec!{&Value}::new ();

        let (asValue, okValue) = { // try to validate the left part as a value
            (context:.implicitEnumUnwrap (context:.validateValue (bin.getLeft ())), true)
        } catch {
            err : &ErrorMsg => {
                errorTypes:.push (err);
                (UNIT_VALUE, false) // failed, maybe its a type
            }
        };


        let (asType, okType) = { // try to validate the left part as a type
            (context:.validateType (bin.getLeft ()), true)
        } catch {
            err : &ErrorMsg => {
                errorTypes:.push (err);
                (NONE_TYPE, false) // failed maybe its a value
            }
        };

        if (!okValue && !okType) throw ErrorMsg::list (errorTypes[]); // it is neither a type nor a value
        if (okValue) { // it is a value
            self.validateModuleOperationValue (alias context, bin.getLoc (), asValue, bin.getRight (), alias finalVals, alias errorFoll);
        }

        if (okType) { // it is a type
            self.validateModuleOperationType (alias context, bin.getLoc (), asType, bin.getRight (), alias finalVals, alias errorFoll);
        }

        // actually it can be both a type and a value (for example, a class and a module can have the same name)
        if (finalVals.len () == 0us) throw ErrorMsg::list (errorFoll[]);
        if (finalVals.len () == 1us) return finalVals [0us]; // only one result
        else {
            return MultSymValue::new (bin.getLoc (), finalVals[], prettyStr-> format ("%", bin.getRight ())); // multiple symbols
        }
    }

    /**
     * Validate a module operation where the left part is a valid value
     * @params:
     *    - context: the context of the validation
     *    - loc: the location of the bin expr
     *    - value: the left operand
     *    - right: the right operand
     * @returns:
     *    - finalVals: the list of validated values
     *    - errors: inserted errors if the validation fails
     * */
    fn validateModuleOperationValue (self, dmut context : &Validator, loc : &Word, value : &Value, right : &Expression, dmut finalVals : &Vec!{&Value}, dmut errors : &Vec!{&ErrorMsg}) {
        {
            let inval = self.validateModuleOperation (alias context, loc, value, right);
            match inval {
                m : &MultSymValue => {
                    for v in m.getValues () {
                        finalVals:.push (v);
                    }
                }
                _ => finalVals:.push (inval);
            }
        } catch {
            err : &ErrorMsg => {
                errors:.push (err);
            }
        }
    }

    /**
     * Validate a module operation where the left part is a valid type
     * @params:
     *    - context: the context of the validation
     *    - loc: the location of the bin expr
     *    - type: the left operand
     *    - right: the right operand
     * @returns:
     *    - finalVals: the list of validated values
     *    - errors: inserted errors if the validation fails
     * */
    fn validateModuleOperationType (self, dmut context : &Validator, loc : &Word, type : &Type, right : &Expression, dmut finalVals : &Vec!{&Value}, dmut errors : &Vec!{&ErrorMsg}) {
        {
            let inval = context:.getSubTypeValidator ().validateValueFromType (alias context, loc, type, right);
            match inval {
                m : &MultSymValue => {
                    for v in m.getValues () {
                        finalVals:.push (v);
                    }
                }
                _ => finalVals:.push (inval);
            }
        } catch {
            err : &ErrorMsg => {
                errors:.push (err);
            }
        }
    }
    
    /**
     * Validate a binary operation involving a module operator (the left operand has to be a value)
     * @params: 
     *   - context: the context of the validation
     *   - bin: the binary expression to validate
     * @returns: the validated value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    pub fn validateModuleOperation (self, dmut context : &Validator, bin : &PathExpr)-> &Value
        throws & ErrorMsg
    {
        let left = context:.implicitEnumUnwrap (context:.validateValue (bin.getLeft ()));
        self.validateModuleOperation (alias context, bin.getLoc (), left, bin.getRight ())
    }

    /**
     * Validate a binary module operation 
     * @params: 
     *   - context: the context of the validation
     *   - loc: the location of the operation
     *   - left: the left operand 
     *   - right: the right operand 
     * @returns: the validated value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    fn validateModuleOperation (self, dmut context : &Validator, loc : &Word, left : &Value, right : &Expression)-> &Value
        throws &ErrorMsg
    {
        let mut errorNotes : [&ErrorMsg] = [];
        match right {
            v : &VarExpr => { // Access of submodule is only made by var names
                match left {
                    md : &ModuleRefValue => { // If it is a module that's simple
                        let dmut res = context:.getLocalFromMod (md, v.getLoc ().str ());
                        if (res.len != 0us) { // There are symbols whose name are 'v.getLoc ().str ()'
                            {
                                return context:.getLiteralValidator ().validateMultSymbols (loc, alias context, alias res);
                            } catch {
                                err : &ErrorMsg => {
                                    throw ErrorMsg::fatal (loc,
                                                           format (ValidateErrorMessage::UNDEFINED_BIN_MOD_OP, loc.str (), left, right),
                                                           notes-> [err]);
                                }
                            }
                        }

                        errorNotes = context:.createLocalVarError (v.getLoc (), md, v.getLoc ().str ());
                    }
                    ms : &MultSymValue => { // The left operand returned multiple symbols
                        let dmut all = Vec!{dmut &Symbol}::new ();
                        let dmut errors = Vec!{&ErrorMsg}::new ();
                        for c in ms.getValues () {
                            match c {
                                md : &ModuleRefValue => { // Some of them are modules, so we can sub access them using var 'v'
                                    let dmut res = context:.getLocalFromMod (md, v.getLoc ().str ());
                                    for i in 0us .. res.len { all:.push (alias res[i]); }
                                    if (res.len == 0us) {
                                        let lerr = context:.createLocalVarError (v.getLoc (), md, v.getLoc ().str ());
                                        for l in lerr { errors:.push (l); }
                                    }
                                }
                            }
                        }
                        
                        if (all.len () != 0us) { // There are symbols whose name are 'v.getLoc ().str ()'
                            {
                                return context:.getLiteralValidator ().validateMultSymbols (loc, alias context, alias (alias all)[]);
                            } catch {
                                err : &ErrorMsg => {
                                    throw ErrorMsg::fatal (loc,
                                                           format (ValidateErrorMessage::UNDEFINED_BIN_MOD_OP, loc.str (), left, right),
                                                           notes-> [err]);
                                }
                            }
                        }

                        errorNotes = errors[];
                    }
                }
            }
        }

        throw ErrorMsg::fatal (loc,
                               format (ValidateErrorMessage::UNDEFINED_BIN_MOD_OP, loc.str (), left, right),
                               notes-> errorNotes);
    }
    
    /*!
     * ================================================================================
     * ================================================================================
     * =========================         AFFECTATION          =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate an affectation operation, where the operator can be anything the result being stored in the left operatand of the operation
     * @params: 
     *   - context: the context of the validation
     *   - op: the operator (can be a None operator, i.e. just a simple affectation)
     *   - bin: the binary expression to validate
     * @returns: the validated value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    fn validateAffectOperation (self, dmut context : &Validator, op : BinaryOperators, bin : &BinaryExpr)-> &Value
        throws &ErrorMsg
    {
        match bin.getLeft () { // Affection can be an index assign operation
            m : &MultOperatorExpr => { // in that case left operand is an index operation
                if (m.isIndex ()) {
                    // We try the operation rewrite
                    return self.validateIndexAssignOperation (alias context, op, m, bin);
                }
            }
        }

        let left = context:.validateValue (bin.getLeft (), noReduce-> true);
        self.validateAffectOperation (alias context, bin.getLoc (), op, left, bin.getRight ())
    }

    /**
     * Validate an affection operation
     * @params:
     *    - context: the context of the validation
     *    - loc: the location of the operation
     *    - left: the left operand
     *    - rightExp: the right operand
     * @returns: the validated value
     * @throws:
     *    - &ErrorMsg: if the operation is not valid
     * */
    fn validateAffectOperation (self, dmut context : &Validator, loc : &Word, op : BinaryOperators, left : &Value, rightExp : &Expression)-> &Value
        throws &ErrorMsg
    {
        context.verifyLeftOperandMove (loc, left);

        // We validate right only now, because it is not needed if the left value is immutable, or not a lvalue
        let right = self.validateAffectRight (alias context, loc, op, left, rightExp);

        // Important part, now we verify memory movement
        context:.verifyMemoryOwner (loc, left.getType (), right, construct-> false, byReference-> false);

        // simply returns an affectation value, the affectation is possible
        AffectValue::new (loc, left.getType (), left, right)
    }

    /**
     * @returns: true iif the right operand in a bin affectation can change due to implicit casting (e.g. i(i8) += 1;)
     * */
    fn canImplicitCastBinAffect (self, type : &Type)-> bool {
        match type {
            IntType () => { true }
            FloatType () => { true }
            _ => { false }
        }
    }

    /**
     * Validate an op index assign operation
     * @params: 
     *    - context: the context of the validation
     *    - op: the math operator associated with the operation (if any, BinaryOperators::EQUAL if none)
     *    - bin: the binary operation to validate
     * @returns: a value containing the rewrite
     * @throws:
     *    - &ErrorMsg: if the operator cannot be rewritten, or there is an error in the validation of the operands
     */
    fn validateIndexAssignOperation (self, dmut context : &Validator, op : BinaryOperators, leftExpr : &MultOperatorExpr, bin : &BinaryExpr)-> &Value
        throws &ErrorMsg
    {
        let leftIndex = if (leftExpr.getLoc () == Tokens::LCRO_AND) {
            context:.getValueValidator ().validateAlias (alias context, leftExpr.getLoc (), leftExpr.getLeft (), isClass-> true)
        } else {
            context:.implicitEnumUnwrap (context:.validateValue (leftExpr.getLeft ()))
        };

        // Index assign can be overriden for classes
        if (leftIndex.getType ().isOf!{&ClassPtrType} ()) {
            return context:.getIndexOpValidator ().validateClassIndexAssign (alias context, leftExpr.getLoc (),
                                                                             op,
                                                                             leftIndex.getType ().asOf!{&ClassPtrType} (),
                                                                             leftIndex,
                                                                             leftExpr, bin.getRight ());
        }

        // Otherwise it is just an affectation of a slice/array access
        let left = context:.getIndexOpValidator ().validate (alias context, leftExpr.getLoc (), leftIndex, leftExpr.getRights (), inCopy-> false);
        self.validateAffectOperation (alias context, bin.getLoc (), op, left, bin.getRight ())
    }

    /**
     * Validate the right operand of an affectation
     * @params:
     *    - context: the context of the validation
     *    - op: the operator used in the operation
     *    - left: the left value
     *    - bin: the binary expression
     * @returns: the validated right operand (already transformed if the op is special, e.g. for 'a += 1' returns 'a + 1')
     * */
    fn validateAffectRight (self, dmut context : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Expression)-> &Value
        throws &ErrorMsg
    {
        // The right operand can be a math operation (e.g. a += 1, b /= 98)
        if (op != BinaryOperators::EQUAL) {
            let realRight = context:.validateValue (right);
            let castedRight = if self.canImplicitCastBinAffect (left.getType ()) { // we want to be able to validate: { let i : i8 = 1i8; i += 1; }, only valid for a few types, (float, int)
                context:.verifyCompatibleTypeWithValue (loc, left.getType (), realRight, byReference-> false) // so we need to take that into account immediately, because (i + 1) is of type i32, and not cte
            } else {
                realRight
            };

            let res = self.validateMathOperation (alias context, loc, op, left, castedRight);
            context:.verifyCompatibleTypeWithValue (loc, left.getType (), res, byReference-> false)
        } else { // else it is just a standard affectation, so right is directly right
            let rightV = context:.validateValue (right);
            context:.verifyCompatibleTypeWithValue (loc, left.getType (), rightV, byReference-> false) // verify the type compatibility, and return the casted value if needed
        }
    }


    /*!
     * ================================================================================
     * ================================================================================
     * =========================       STRUCT / CLASS         =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a binary operator (math, set, range or bitwise) assuming that the left operand is a class ptr
     * @params: 
     *   - context: the context of the validation
     *   - loc: the location of the operation
     *   - op: the operator
     *   - left: the left operand (assumed to be a class ptr type operand)
     *   - right: the right operand
     * @returns: the result value (generally a call value)
     * @throws: 
     *   - &ErrorMsg: if the operation is invalid
     */
    fn validateClassOpLeft (self, dmut context : &Validator, loc : &Word, op : BinaryOperators, cptr : &ClassPtrType, left : &Value, right : &Value)-> &Value
        throws &ErrorMsg
    {
        let str = makeStringSliceValue (loc, op);
        let meth = context:.constructObjectMethodAcc (loc, cptr, left, OpOverrideNames::BIN_OP_OVERRIDE);
        let templ = context:.getValueValidator ().validateTemplateCall (alias context, loc, meth, [str]);

        context:.getCallOpValidator ().validate (alias context, loc, templ, [right])
    }

    /**
     * Validate a binary operator (math, set, range or bitwise) assuming that the right operand is a class ptr
     * @params: 
     *   - context: the context of the validation
     *   - loc: the location of the operation
     *   - op: the operator
     *   - left: the left operand 
     *   - right: the right operand (assumed to be a class ptr type operand)
     * @returns: the result value (generally a call value)
     * @throws: 
     *   - &ErrorMsg: if the operation is invalid
     */    
    fn validateClassOpRight (self, dmut context : &Validator, loc : &Word, op : BinaryOperators, cptr : &ClassPtrType, left : &Value, right : &Value)-> &Value
        throws &ErrorMsg
    {
        let str = makeStringSliceValue (loc, op);
        let meth = context:.constructObjectMethodAcc (loc, cptr, right, OpOverrideNames::BIN_OP_RIGHT_OVERRIDE);
        let templ = context:.getValueValidator ().validateTemplateCall (alias context, loc, meth, [str]);

        context:.getCallOpValidator ().validate (alias context, loc, templ, [left])
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================     STRUCT / CLASS (CMP)     =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a binary comparison operator assuming that the left operand is a class ptr
     * @params: 
     *   - context: the context of the validation
     *   - loc: the location of the operation
     *   - op: the operator
     *   - left: the left operand (assumed to be a class ptr type operand)
     *   - right: the right operand
     * @returns: the result value (generally a call value)
     * @throws: 
     *   - &ErrorMsg: if the operation is invalid
     */
    fn validateClassCmpOp (self, dmut context : &Validator, loc : &Word, op : BinaryOperators, cptr : &ClassPtrType, left : &Value, right : &Value, inv : bool = false)-> &Value
        throws &ErrorMsg
    {
        let (cl, aux, correctOp) = if (inv) { (right, left, self.inverseCmpOp (op)) } else { (left, right, op) };

        {
            let meth = context:.constructObjectMethodAcc (loc, cptr, cl, OpOverrideNames::CMP_OP_OVERRIDE);
            let call = context:.getCallOpValidator ().validate (alias context, loc, meth, [aux]);
            let casted = context:.getCastValidator ().validateCast (alias context, makeIntValue (loc, 0is), call.getType ());

            self.validateComparisonOperationImpl (alias context, loc, correctOp, call, casted)
        } catch {
            err : &ErrorMsg => { // In case of error show the location of the rewrite for clearer errors
                {
                    if (op == BinaryOperators::DEQUAL || op == BinaryOperators::NOT_EQUAL) {
                        let meth = context:.constructObjectMethodAcc (loc, cptr, cl, OpOverrideNames::EQUAL_OP_OVERRIDE);
                        let call = context:.getCallOpValidator ().validate (alias context, loc, meth, [aux]);

                        return if (op == BinaryOperators::NOT_EQUAL) {
                            context:.getUnOpValidator ().validateNotOperator (alias context, loc, call)
                        } else {
                            call
                        };
                    }
                } catch {
                    eqErr : &ErrorMsg => {
                        throw ErrorMsg::list ([err, eqErr]);
                    }
                }

                throw err;
            }
        }
    }

    /**
     * Inverse the comparison operator such that 'a op b', is equivalent to 'b inverse(op) a'
     * @example:
     * ==================
     * a > b // b < a
     * a >= b // b <= a
     * ==================
     * @panic: if op is not a compare operator 
     * @params: 
     *   - op: the operator to inverse 
     * @returns: the inversed operator
     */
    fn inverseCmpOp (self, op : BinaryOperators)-> BinaryOperators {
        match op {
            BinaryOperators::INF => { BinaryOperators::SUP } 
            BinaryOperators::SUP => { BinaryOperators::INF }
            BinaryOperators::INF_EQUAL => { BinaryOperators::SUP_EQUAL }
            BinaryOperators::SUP_EQUAL => { BinaryOperators::INF_EQUAL }
            BinaryOperators::NOT_EQUAL => { BinaryOperators::NOT_EQUAL }
            BinaryOperators::DEQUAL => { BinaryOperators::DEQUAL }
            _ => {
                __pragma!panic ();
            }
        }
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================    STRUCT / CLASS (RANGE)    =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a binary range operator assuming that the left operand is a class ptr
     * @params: 
     *   - context: the context of the validation
     *   - loc: the location of the operation
     *   - op: the operator
     *   - left: the left operand (assumed to be a class ptr type operand)
     *   - right: the right operand
     * @returns: the result value (generally a call value)
     * @throws: 
     *   - &ErrorMsg: if the operation is invalid
     */
    fn validateClassRangeOpLeft (self, dmut context : &Validator, loc : &Word, op : BinaryOperators, cptr : &ClassPtrType, left : &Value, right : &Value)-> &Value
        throws &ErrorMsg
    {
        let contains = BoolValue::new (loc, op == BinaryOperators::TDOT);
        let meth = context:.constructObjectMethodAcc (loc, cptr, left, OpOverrideNames::RANGE_OP_OVERRIDE);
        let templ = context:.getValueValidator ().validateTemplateCall (alias context, loc, meth, [contains]);

        context:.getCallOpValidator ().validate (alias context, loc, templ, [right])
    }

    /**
     * Validate a binary range operator assuming that the right operand is a class ptr
     * @params: 
     *   - context: the context of the validation
     *   - loc: the location of the operation
     *   - op: the operator
     *   - left: the left operand 
     *   - right: the right operand (assumed to be a class ptr type operand)
     * @returns: the result value (generally a call value)
     * @throws: 
     *   - &ErrorMsg: if the operation is invalid
     */    
    fn validateClassRangeOpRight (self, dmut context : &Validator, loc : &Word, op : BinaryOperators, cptr : &ClassPtrType, left : &Value, right : &Value)-> &Value
        throws &ErrorMsg
    {
        let contains = BoolValue::new (loc, op == BinaryOperators::TDOT);
        let meth = context:.constructObjectMethodAcc (loc, cptr, right, OpOverrideNames::RANGE_OP_RIGHT_OVERRIDE);
        let templ = context:.getValueValidator ().validateTemplateCall (alias context, loc, meth, [contains]);

        context:.getCallOpValidator ().validate (alias context, loc, templ, [left])
    }
    
    /*!
     * ================================================================================
     * ================================================================================
     * =========================            COMMON            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Get the max size between two sizeof types (0 being the biggest)
     * */
    fn getMaxSize (self, left : u16, right : u16)-> u16 {
        if (left == 0u16 || right == 0u16) { 0u16 }
        else comparison::max (left, right)
    }

    /**
     * @returns: true if the size of left is bigger than right (0 being the biggest)
     * */
    fn isMax (self, left : u16, right : u16) -> bool {
        if (left == 0u16) return true;
        else if (right == 0u16) return false;
        return left >= right;
    }
    
    /**
     * Transform the word into a valid operator
     * @assume: the operator is valid
     * @params: 
     *   - op: the operator
     * @returns: 
     *   - .0: the operator
     *   - .1: true iif the operator is an affectation operator (e.g. +=, -=)
     *   - .2: true iif the operator is a math operator (e.g. +, -)
     *   - .3: true iif the operator is a logical operator (e.g. >=, <=, ==)
     *   - .4: true iif the operator is a range operator (.., ...)
     */
    fn toOperator (self, op : &Word)-> (BinaryOperators, bool, OperatorType)
        throws &ErrorMsg
    {
        match op.str () {
            BinaryOperators::EQUAL => { (BinaryOperators::EQUAL, true, OperatorType::NONE) }
            
            BinaryOperators::DIV_AFF => { (BinaryOperators::DIV, true, OperatorType::MATH) }
            BinaryOperators::MINUS_AFF => { (BinaryOperators::MINUS, true, OperatorType::MATH) }
            BinaryOperators::PLUS_AFF => { (BinaryOperators::PLUS, true, OperatorType::MATH) }
            BinaryOperators::STAR_AFF => { (BinaryOperators::STAR, true, OperatorType::MATH) }
            BinaryOperators::PERCENT_AFF => { (BinaryOperators::PERCENT, true, OperatorType::MATH) }
            
            BinaryOperators::TILDE_AFF => { (BinaryOperators::TILDE, true, OperatorType::SET) }
            
            BinaryOperators::LEFTD_AFF => { (BinaryOperators::LEFTD, true, OperatorType::BITWISE) }
            BinaryOperators::RIGHTD_AFF => { (BinaryOperators::RIGHTD, true, OperatorType::BITWISE) }
            
            BinaryOperators::DPIPE => { (BinaryOperators::DPIPE, false, OperatorType::LOGICAL) }
            BinaryOperators::DAND => { (BinaryOperators::DAND, false, OperatorType::LOGICAL) }
            
            BinaryOperators::INF => { (BinaryOperators::INF, false, OperatorType::COMPARISON) } 
            BinaryOperators::SUP => { (BinaryOperators::SUP, false, OperatorType::COMPARISON) }
            BinaryOperators::INF_EQUAL => { (BinaryOperators::INF_EQUAL, false, OperatorType::COMPARISON)  }
            BinaryOperators::SUP_EQUAL => { (BinaryOperators::SUP_EQUAL, false, OperatorType::COMPARISON) }
            BinaryOperators::NOT_EQUAL => { (BinaryOperators::NOT_EQUAL, false, OperatorType::COMPARISON) }
            BinaryOperators::DEQUAL => { (BinaryOperators::DEQUAL, false, OperatorType::COMPARISON) }
            BinaryOperators::CONGRUENT => { (BinaryOperators::CONGRUENT, false, OperatorType::FLOAT_COMPARISON) }
            BinaryOperators::UNCONGRUENT => { (BinaryOperators::UNCONGRUENT, false, OperatorType::FLOAT_COMPARISON) }


            BinaryOperators::OF => { (BinaryOperators::OF, false, OperatorType::TYPE) }
            BinaryOperators::NOT_OF => { (BinaryOperators::NOT_OF, false, OperatorType::TYPE) }
            
            BinaryOperators::IS => { (BinaryOperators::IS, false, OperatorType::POINTER) }
            BinaryOperators::NOT_IS => { (BinaryOperators::NOT_IS, false, OperatorType::POINTER) }

            BinaryOperators::TDOT => { (BinaryOperators::TDOT, false, OperatorType::RANGE) }
            BinaryOperators::DDOT => { (BinaryOperators::DDOT, false, OperatorType::RANGE) }
            
            BinaryOperators::LEFTD => { (BinaryOperators::LEFTD, false, OperatorType::BITWISE) }
            BinaryOperators::RIGHTD => { (BinaryOperators::RIGHTD, false, OperatorType::BITWISE) }
            BinaryOperators::PIPE => { (BinaryOperators::PIPE, false, OperatorType::BITWISE) }  
            BinaryOperators::XOR => { (BinaryOperators::XOR, false, OperatorType::BITWISE) } 
            BinaryOperators::AND => { (BinaryOperators::AND, false, OperatorType::BITWISE) }

            BinaryOperators::IN => { (BinaryOperators::IN, false, OperatorType::SET) }
            BinaryOperators::NOT_IN => { (BinaryOperators::NOT_IN, false, OperatorType::SET) }
            BinaryOperators::TILDE => { (BinaryOperators::TILDE, false, OperatorType::SET) }
            
            BinaryOperators::PLUS => { (BinaryOperators::PLUS, false, OperatorType::MATH) }
            BinaryOperators::MINUS => { (BinaryOperators::MINUS, false, OperatorType::MATH) }
            BinaryOperators::STAR => { (BinaryOperators::STAR, false, OperatorType::MATH) } 
            BinaryOperators::PERCENT => { (BinaryOperators::PERCENT, false, OperatorType::MATH) }
            BinaryOperators::DIV => { (BinaryOperators::DIV, false, OperatorType::MATH) }
            BinaryOperators::DXOR => { (BinaryOperators::DXOR, false, OperatorType::MATH) }
            
            BinaryOperators::DOT => { (BinaryOperators::DOT, false, OperatorType::FIELD) }
            BinaryOperators::DOT_AND => { (BinaryOperators::DOT_AND, false, OperatorType::FIELD) }
            
            BinaryOperators::DCOLON => { (BinaryOperators::DCOLON, false, OperatorType::MODULE) }
            _ => {
                throw ErrorMsg::fatal (op, format (ValidateErrorMessage::UNDEFINED_BIN_OP_TOK, op.str ()));
            }        
        }
    }
    
}
