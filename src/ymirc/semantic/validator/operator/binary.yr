mod ymirc::semantic::validator::operator::binary;

import ymirc::semantic::validator::visitor;
import ymirc::semantic::validator::errors;
import ymirc::errors::_;
import ymirc::utils::format;
import ymirc::syntax::expression::operator::binary;
import ymirc::global::core_;

import ymirc::semantic::symbol::_;
import ymirc::semantic::generator::_;

import ymirc::lexing::word;
import ymirc::lexing::tokens;
import ymirc::syntax::keys;
import ymirc::syntax::expression::_;

import std::algorithm::comparison;
import std::collection::vec;
import std::io;

pub enum 
| MATH = 1u32
| BITWISE = 2u32
| LOGICAL = 3u32
| COMPARISON = 4u32
| RANGE = 5u32
| POINTER = 6u32
| SET = 7u32
| TYPE = 8u32
| FIELD = 9u32
| MODULE = 10u32
| NONE = 11u32
 -> OperatorType;

/**
 * The binary validator is used to validate BinaryOpExpr
 * It is a class validator because binary operation are complex
 */
pub class BinaryOpValidator {

    /**
     * Create an empty validator     
     */
    pub self () {}

    /**
     * Validate a binary expression
     * @params: 
     *  - context: the context of the validation
     *  - bin: the binary operator to validate
     * @returns: a value
     * @throws: &ErrorMsg, if the validation failed
     */
    pub def validate (self, dmut context : &Validator, bin : &BinaryExpr) -> &Value
        throws &ErrorMsg
    {
        let (op, isAff, type) = self.toOperator (bin.getLoc ());
        
        match (type, isAff) {
            (OperatorType::MATH, false) => { 
                return self.validateMathOperation (alias context, op, bin);
            }
            (OperatorType::BITWISE, false) => { // |, &, ^, <<, >>, applicable only on ints
                return self.validateBitwiseOperation (alias context, op, bin);
            }
            (OperatorType::COMPARISON, false) => { // all comparison operators, <=, >=, >, etc.., cannot be an affectation
                return self.validateComparisonOperation (alias context, op, bin);
            }
            (OperatorType::LOGICAL, false) => { // all boolean operators, cannot be an affectation
                return self.validateLogicalOperation (alias context, op, bin);
            }
            (OperatorType::RANGE, false) => { // .. and ..., cannot be an affectation
                return self.validateRangeOperation (alias context, op, bin);
            }
            (OperatorType::POINTER, false) => { // is and !is, cannot be an affectation
                return self.validatePointerOperation (alias context, op, bin);
            }
            (OperatorType::SET, false) => { // ~, in, and !in, might be an affectation for ~
                return self.validateSetOperation (alias context, op, bin);
            }
            (OperatorType::TYPE, false) => { // of and !of, cannot be an affectation
                return self.validateTypeOperation (alias context, op, bin);
            }
            (OperatorType::FIELD, false) => { // . and :., cannot be an affectation
                return self.validateFieldOperation (alias context, op, bin);
            }
            (OperatorType::MODULE, false) => { // ::, cannot be an affectation                
                __pragma!panic ();
            }
            (_, true) => { // =, +=, -=, ~=, etc., affectation operators
                return self.validateAffectOperation (alias context, op, bin);
            }
            _ => { // All case should be handled.
                __pragma!panic ();
            }
        }
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================             MATH             =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a binary operation involving math operator
     * @params: 
     *   - context: the context of the validation
     *   - op: the operator (assuming it's a math operator)
     *   - bin: the binary expression to validate
     * @returns: the validated value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    def validateMathOperation (self, dmut context : &Validator, op : BinaryOperators, bin : &BinaryExpr)-> &Value
        throws &ErrorMsg
    {
        let left = context:.validateValue (bin.getLeft ());
        let right = context:.validateValue (bin.getRight ());
        
        let dmut errors = Vec!{&ErrorMsg}::new ();        
        {
            match left.getType () { // First we try the operation as a left side operation (asking for left operand to be the master of the operation, i.e. left.opBinary!{op} (right)
                IntType () => return self.validateIntMathOp (alias context, bin.getLoc (), op, left, right);
                CharType () => return self.validateCharMathOp (alias context, bin.getLoc (), op, left, right);
                FloatType () => return self.validateFloatMathOp (alias context, bin.getLoc (), op, left, right);
                PointerType () => return self.validatePointerMathOp (alias context, bin.getLoc (), op, left, right);
                StructType () => return self.validateStructOpLeft (alias context, bin.getLoc (), op, left, right);
                ClassPtrType () => return self.validateClassOpLeft (alias context, bin.getLoc (), op, left, right);
            };
            
            errors:.push (ErrorMsg::fatal (bin.getLoc (), format (ValidateErrorMessage::UNDEFINED_BIN_OP, op, left.getType (), right.getType ())));
        } catch {
            err : &ErrorMsg => { errors:.push (err); }
        } 

        { // if we are here the validation as a left operand validation failed, so we need to try it as a right operation (right.opBinaryRight!{op} (left))
            match right.getType () { // it is working only for two kind of type structs and classes
                StructType () => return self.validateStructOpRight (alias context, bin.getLoc (), op, left, right);
                ClassPtrType () => return self.validateClassOpRight (alias context, bin.getLoc (), op, left, right);
            } // We can quit without testing the other types, there is already an error in the errors vec
        } catch {
            err : &ErrorMsg => { errors:.push (err); } // No we still fail
        }

        throw ErrorMsg::list (errors[]); // there is no valid math operation for left and right
    }


    /**
     * Validate a math operation where the left operand is a int type operand
     * @params: 
     *   - context: the context of the validation
     *   - op: the operator
     *   - left: the left operand (assumed of type int)
     *   - right: the right operand
     * @returns: The result value
     * @throws: 
     *   - &ErrorMsg: if the operation is not valid
     */
    def validateIntMathOp (self, dmut context : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Value)-> &Value
        throws &ErrorMsg
    {
        match left.getType () {
            li : &IntType => {            
                match right.getType () {
                    ri : &IntType => {
                        if (li.isSigned () == ri.isSigned ()) {
                            if (op == BinaryOperators::DXOR) {
                                if (li.getSize () == ri.getSize ()) {
                                    return self.validateIntOrFloatPowerOp (alias context, loc, left, right);
                                }
                            } else {                            
                                let maxSize = comparison::max (li.getSize (), ri.getSize ());
                                let type = IntType::new (loc, signed-> li.isSigned (), size-> maxSize);
                                return BinaryMathIntOperatorValue::new (loc, type, op, left, right);
                            }
                        }
                    }                  
                }                
            }
            _ => __pragma!panic ()
        }

        throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_BIN_OP, op, left.getType (), right.getType ()));
    }   

    /**
     * Validate the power operation
     * @info: This operation is not performed by the language itself but by a core function (core::math::pow)
     * @example: 
     * ====================
     * 12 ^^ 98
     * // rewritten into => 'core::math::pow!{typeof(12)} (12, 98)-> typeof (12)
     * 12.f ^^ 0.5f
     * // rewritten into => 'core::math::pow!{typeof(12.f)} (12.0f, 0.5f)-> typeof (12.0f)
     * ====================
     * @params:
     *   - context: the context of the validation
     *   - op: the operator
     *   - left: the left operand (assumed of type int)
     *   - right: the right operand
     * @returns: The result value
     * @throws: 
     *   - &ErrorMsg: if the operation is not valid
     */
    def validateIntOrFloatPowerOp (self, dmut context : &Validator, loc : &Word, left : &Value, right : &Value)-> &Value
        throws &ErrorMsg
    {
        let leftSynt = ValueWrapperExpr::new (left.getLoc (), left);
        let rightSynt = ValueWrapperExpr::new (right.getLoc (), right);
        
        // Create a var path to the core function core::math::pow
        let syntVar = context.createSyntaxVarFromPath (loc, [CoreNames::CORE_MODULE, CoreNames::MATH_MODULE, CoreNames::POW_FUNCTION]);

        // Create the syntax call of the function => core::math::pow (left, right)
        let syntCall = MultOperatorExpr::new (Word::new (Tokens::LPAR, loc), Word::new (Tokens::RPAR, loc),
                                              syntVar,
                                              [leftSynt, rightSynt], canBeDotCall-> false);

        // Validate the final rewritten value
        context:.validateValue (syntCall)
    }
    
    /**
     * Validate a math operation where the left operand is a char type operand
     * @params: 
     *   - _: the context of the validation
     *   - op: the operator
     *   - left: the left operand (assumed of type char)
     *   - right: the right operand
     * @returns: The result value
     * @throws: 
     *   - &ErrorMsg: if the operation is not valid
     */
    def validateCharMathOp (self, dmut _ : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Value)-> &Value
        throws &ErrorMsg
    {
        if (op != BinaryOperators::PLUS && op != BinaryOperators::MINUS) {
            throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_BIN_OP, op, left.getType (), right.getType ()));
        }
        
        match left.getType () {
            lc : &CharType => {
                match right.getType () {
                    rc : &CharType => {
                        if (lc.getSize () == rc.getSize ()) {
                            let type = CharType::new (loc, size-> lc.getSize ());
                            return BinaryMathCharOperatorValue::new (loc, type, op, left, right);
                        }
                    }   
                }
            }
            _ => __pragma!panic ();   
        }

        throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_BIN_OP, op, left.getType (), right.getType ()));             
    }


    /**
     * Validate a math operation where the left operand is a float type operand
     * @params: 
     *   - context: the context of the validation
     *   - op: the operator
     *   - left: the left operand (assumed of type float)
     *   - right: the right operand
     * @returns: The result value
     * @throws: 
     *   - &ErrorMsg: if the operation is not valid
     */
    def validateFloatMathOp (self, dmut context : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Value)-> &Value
        throws &ErrorMsg
    {        
        match left.getType () {
            lf : &FloatType => {
                match right.getType () {
                    rf : &FloatType => {
                        if (op == BinaryOperators::DXOR) {
                            if (lf.getSize () == rf.getSize ()) {
                                return self.validateIntOrFloatPowerOp (alias context, loc, left, right);
                            }
                        } else {                            
                            let maxSize = comparison::max (lf.getSize (), rf.getSize ());
                            let type = FloatType::new (loc, size-> maxSize);
                            return BinaryMathFloatOperatorValue::new (loc, type, op, left, right);
                        }
                    }
                }
            }
            _ => __pragma!panic ();   
        }

        throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_BIN_OP, op, left.getType (), right.getType ()));
    }

    /**
     * Validate a math operation where the left operand is a pointer type operand
     * @params: 
     *   - _: the context of the validation
     *   - op: the operator
     *   - left: the left operand (assumed of type pointer)
     *   - right: the right operand
     * @returns: The result value
     * @throws: 
     *   - &ErrorMsg: if the operation is not valid
     */
    def validatePointerMathOp (self, dmut _ : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Value)-> &Value
        throws &ErrorMsg
    {
        if (op != BinaryOperators::PLUS && op != BinaryOperators::MINUS) {
            throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_BIN_OP, op, left.getType (), right.getType ()));
        }
        
        match left.getType () {
            lp : &PointerType => {
                match right.getType () {
                    ri : &IntType => {
                        if (!ri.isSigned ()) {                            
                            return BinaryMathPointerOperatorValue::new (loc, lp, op, left, right);
                        }
                    }
                    rp : &PointerType => {
                        if (rp.getInners ()[0] == lp.getInners ()[0] || rp.getInners ()[0].isOf!{&VoidType} ()) {
                            return BinaryMathPointerOperatorValue::new (loc, lp, op, left, right);
                        }
                    }
                }
            }
            _ => __pragma!panic ();
        }
        
        throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_BIN_OP, op, left.getType (), right.getType ()));
    }


    /**
     * ================================================================================
     * ================================================================================
     * =========================           BITWISE            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a binary operation involving bitwise operators (|, &, <<, etc.)
     * @params: 
     *   - context: the context of the validation
     *   - op: the operator (assuming it's a logical operator)
     *   - bin: the binary expression to validate
     * @returns: the validated value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    def validateBitwiseOperation (self, dmut context : &Validator, op : BinaryOperators, bin : &BinaryExpr)-> &Value
        throws &ErrorMsg
    {
        let left = context:.validateValue (bin.getLeft ());
        let right = context:.validateValue (bin.getRight ());

        let dmut errors = Vec!{&ErrorMsg}::new ();
        {
            // First we try the operation as a left side operation (asking for left operand to be the master of the operation, i.e. left.opBinary!{op} (right)
            match left.getType () { 
                IntType () => return self.validateIntBitwiseOp (alias context, bin.getLoc (), op, left, right);
                StructType () => return self.validateStructOpLeft (alias context, bin.getLoc (), op, left, right);
                ClassPtrType () => return self.validateClassOpLeft (alias context, bin.getLoc (), op, left, right);
            };
            
            errors:.push (ErrorMsg::fatal (bin.getLoc (), format (ValidateErrorMessage::UNDEFINED_BIN_OP, op, left.getType (), right.getType ())));
        } catch {
            err : &ErrorMsg => { errors:.push (err); }
        }

        { // if we are here the validation as a left operand validation failed, so we need to try it as a right operation (right.opBinaryRight!{op} (left))
            match right.getType () { // it is working only for two kind of type structs and classes
                StructType () => return self.validateStructOpRight (alias context, bin.getLoc (), op, left, right);
                ClassPtrType () => return self.validateClassOpRight (alias context, bin.getLoc (), op, left, right);
            } // We can quit without testing the other types, there is already an error in the errors vec
        } catch {
            err : &ErrorMsg => { errors:.push (err); } // No we still fail
        }

        throw ErrorMsg::list (errors[]); // there is no valid math operation for left and right        
    }

    /**
     * Validate a binary operation involving bitwise operators, and assuming that left operand is a int typed value
     * @params: 
     *   - context: the context of the validation
     *   - loc: the location of the operation
     *   - op: the operator
     *   - left: the left operand of the operation (assumed to be a int typed value)
     *   - right: the right operand of the operation
     * @returns: the result value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    def validateIntBitwiseOp (self, dmut _ : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Value)-> &Value
        throws &ErrorMsg
    {
        match left.getType () {
            li : &IntType => {
                match right.getType () {
                    ri : &IntType => {
                        if (li.isSigned () == ri.isSigned () && li.getSize () == ri.getSize ()) {
                            let type = IntType::new (loc, signed-> li.isSigned (), size-> li.getSize ());
                            return BitwiseIntOperatorValue::new (loc, type, op, left, right);
                        }
                    }
                }               
            }
            _ => __pragma!panic ();
        }

        throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_BIN_OP, op, left.getType (), right.getType ()));                       
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================          COMPARISON          =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a binary operation involving comparison operators (<=, >=, <, >, ==, etc..)
     * @params: 
     *   - context: the context of the validation
     *   - op: the operator (assuming it's a logical operator)
     *   - bin: the binary expression to validate
     * @returns: the validated value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    def validateComparisonOperation (self, dmut context : &Validator, op : BinaryOperators, bin : &BinaryExpr)-> &Value
        throws &ErrorMsg
    {
        let left = context:.validateValue (bin.getLeft ());
        let right = context:.validateValue (bin.getRight ());

        let dmut errors = Vec!{&ErrorMsg}::new ();
        {
            // First we try the operation as a left side operation (asking for left operand to be the master of the operation, i.e. left.opBinary!{op} (right)
            match left.getType () { 
                IntType () => return self.validateIntCmpOp (alias context, bin.getLoc (), op, left, right);
                FloatType () => return self.validateFloatCmpOp (alias context, bin.getLoc (), op, left, right);
                CharType () => return self.validateCharCmpOp (alias context, bin.getLoc (), op, left, right);
                BoolType () => return self.validateBoolCmpOp (alias context, bin.getLoc (), op, left, right);
                ArrayType () => return self.validateSliceOrArrayCmpOp (alias context, bin.getLoc (), op, left, right);
                SliceType () => return self.validateSliceOrArrayCmpOp (alias context, bin.getLoc (), op, left, right);
                StructType () => return self.validateStructCmpOpLeft (alias context, bin.getLoc (), op, left, right);
                ClassPtrType () => return self.validateClassCmpOpLeft (alias context, bin.getLoc (), op, left, right);
            };
            
            errors:.push (ErrorMsg::fatal (bin.getLoc (), format (ValidateErrorMessage::UNDEFINED_BIN_OP, op, left.getType (), right.getType ())));
        } catch {
            err : &ErrorMsg => { errors:.push (err); }
        }

        { // if we are here the validation as a left operand validation failed, so we need to try it as a right operation (right.opBinaryRight!{op} (left))
            match right.getType () { // it is working only for two kind of type structs and classes
                StructType () => return self.validateStructCmpOpRight (alias context, bin.getLoc (), op, left, right);
                ClassPtrType () => return self.validateClassCmpOpRight (alias context, bin.getLoc (), op, left, right);
            } // We can quit without testing the other types, there is already an error in the errors vec
        } catch {
            err : &ErrorMsg => { errors:.push (err); } // No we still fail
        }

        throw ErrorMsg::list (errors[]); // there is no valid math operation for left and right        

    }

    /**
     * Validate a binary comparison operator, assuming that the left operand is a int
     * @params: 
     *   - context: the context of the operator
     *   - loc: the location of the operator
     *   - left: the left operand (assume to be a int typed value)
     *   - right: the right operand
     * @returns: the result value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    def validateIntCmpOp (self, dmut _ : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Value)-> &Value
        throws &ErrorMsg
    {
        match left.getType () {
            li : &IntType => {
                match right.getType () {
                    ri : &IntType => {
                        if (li.isSigned () == ri.isSigned ()) {
                            return CmpIntOperatorValue::new (loc, op, left, right);
                        }
                    }
                }
            }
            _ => __pragma!panic ();
        }
        
        throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_BIN_OP, op, left.getType (), right.getType ()));
    }

    /**
     * Validate a binary comparison operator, assuming that the left operand is a float
     * @params: 
     *   - context: the context of the operator
     *   - loc: the location of the operator
     *   - left: the left operand (assume to be a float typed value)
     *   - right: the right operand
     * @returns: the result value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    def validateFloatCmpOp (self, dmut _ : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Value)-> &Value
        throws &ErrorMsg
    {
        match left.getType () {
            FloatType () => {
                match right.getType () {
                    FloatType () => {
                        return CmpFloatOperatorValue::new (loc, op, left, right);                        
                    }
                }
            }
            _ => __pragma!panic ();
        }
        
        throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_BIN_OP, op, left.getType (), right.getType ()));
    }


    /**
     * Validate a binary comparison operator, assuming that the left operand is a char
     * @params: 
     *   - context: the context of the operator
     *   - loc: the location of the operator
     *   - left: the left operand (assume to be a char typed value)
     *   - right: the right operand
     * @returns: the result value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    def validateCharCmpOp (self, dmut _ : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Value)-> &Value
        throws &ErrorMsg
    {
        match left.getType () {
            CharType () => {
                match right.getType () {
                    CharType () => {
                        return CmpCharOperatorValue::new (loc, op, left, right);                        
                    }
                }
            }
            _ => __pragma!panic ();
        }
        
        throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_BIN_OP, op, left.getType (), right.getType ()));
    }


    /**
     * Validate a binary comparison operator, assuming that the left operand is a bool
     * @params: 
     *   - context: the context of the operator
     *   - loc: the location of the operator
     *   - left: the left operand (assume to be a bool typed value)
     *   - right: the right operand
     * @returns: the result value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    def validateBoolCmpOp (self, dmut _ : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Value)-> &Value
        throws &ErrorMsg
    {
        if (op == BinaryOperators::EQUAL || op == BinaryOperators::NOT_EQUAL) {
            match left.getType () {
                CharType () => {
                    match right.getType () {
                        CharType () => {
                            return CmpBoolOperatorValue::new (loc, op, left, right);                        
                        }
                    }
                }
                _ => __pragma!panic ();
            }

        }
        throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_BIN_OP, op, left.getType (), right.getType ()));
    }
    
    /**
     * Validate the comparison operator of two slice  (it is almost the same for array and slice, so it is factorized in this function)
     * @info: This comparison is not provided by the language itself, but by core files, so this binary operator is rewritten into a syntax element
     * @example: 
     * ======================
     * [1, 2, 3] < [0, 8, 0]
     * // is rewritten into => 'core::array::opCmp ([1, 2, 3], [0, 8, 0]) < 0'
     *
     * [1, 2, 3] >= [0, 8, 0]
     * // is rewritten into => 'core::array::opCmp ([1, 2, 3], [0, 8, 0]) >= 0'
     * ======================
     * @params: 
     *   - context: the context of the operator
     *   - loc: the location of the operator
     *   - left: the left operand
     *   - right: the right operand
     * @returns: the result value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    def validateSliceOrArrayCmpOp (self, dmut context : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Value)-> &Value
        throws &ErrorMsg
    {        
        // The left element is a slice or an array (otherwise the function is not called)
        let leftSynt = match left.getType () {
            SliceType () => { ValueWrapperExpr::new (left.getLoc (), left) }
            ArrayType () => { IntrinsicExpr::new (left.getLoc (), IntrinsicKeys::ALIAS, ValueWrapperExpr::new (left.getLoc (), left)) }
            _ => {
                throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_BIN_OP, op, left.getType (), right.getType ()));
            }
        };
        
        // The comparison can be made only with an element of the same type, that is to say a slice or an array
        let rightSynt = match right.getType () {
            SliceType () => { ValueWrapperExpr::new (right.getLoc (), right) }
            ArrayType () => { IntrinsicExpr::new (right.getLoc (), IntrinsicKeys::ALIAS, ValueWrapperExpr::new (right.getLoc (), right)) }
            _ => {
                throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_BIN_OP, op, left.getType (), right.getType ()));
            }
        };

        // There is another function for equality that is faster than comparison, so we call it if we can
        // And unlike class and struct, we know that this operator is defined in core files, so no need to check its existence 
        if (op == BinaryOperators::EQUAL || op == BinaryOperators::NOT_EQUAL)
            return self.validateSliceOrArrayEqualOp (alias context, loc, op, leftSynt, rightSynt);
        
        // Create a var path to the core function core::array::opCmp
        let syntVar = context.createSyntaxVarFromPath (loc, [CoreNames::CORE_MODULE, CoreNames::ARRAY_MODULE, CoreNames::CMP_OP_OVERRIDE]);

        // Create the syntax call of the function to compare two slices => core::array::opCmp (left, right)-> usize
        let syntCall = MultOperatorExpr::new (Word::new (Tokens::LPAR, loc), Word::new (Tokens::RPAR, loc),
                                              syntVar,
                                              [leftSynt, rightSynt], canBeDotCall-> false);

        // Validate the value to get the return type
        let valueCall = context:.validateValue (syntCall);

        // Cast the value 0 to the type of the return type of the core function (it can change from one implementation to another and does not really have an impact)
        // The only thing that is necessary is that it returns a signed int value no matter the size
        let syntCast = CastExpr::new (loc,
                                      TypeWrapperExpr::new (loc, valueCall.getType ()),
                                      ValueWrapperExpr::new (loc, usize (loc, 0us)));

        // Compare the value of the call to 0 using the operator provided by the source code ('op')
        let syntTest = BinaryExpr::new (Word::new (op, loc), ValueWrapperExpr::new (loc, valueCall), syntCast);

        // Validate the final rewritten value
        context:.validateValue (syntTest)
    }

    /**
     * Validate the equality operator of two slice  (it is almost the same for array and slice, so it is factorized in this function)
     * @info: This comparison is not provided by the language itself, but by core files, so this binary operator is rewritten into a syntax element
     * @example: 
     * ======================
     * [1, 2, 3] != [0, 8, 0]
     * // is rewritten into => '!core::array::opEquals ([1, 2, 3], [0, 8, 0])'
     *
     * [1, 2, 3] == [0, 8, 0]
     * // is rewritten into => 'core::array::opEquals ([1, 2, 3], [0, 8, 0])'
     * ======================
     * @params: 
     *   - context: the context of the operator
     *   - loc: the location of the operator
     *   - left: the left operand 
     *   - right: the right operand
     * @returns: the result value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */

    def validateSliceOrArrayEqualOp (self, dmut context : &Validator, loc : &Word, op : BinaryOperators, leftSynt : &Expression, rightSynt : &Expression)-> &Value
        throws &ErrorMsg
    {
        // Create a var path to the core function core::array::opEquals
        let syntVar = context.createSyntaxVarFromPath (loc, [CoreNames::CORE_MODULE, CoreNames::ARRAY_MODULE, CoreNames::EQUAL_OP_OVERRIDE]);

        // Create the syntax call of the function to compare two slices => core::array::opCmp (left, right)-> usize
        let syntCall = MultOperatorExpr::new (Word::new (Tokens::LPAR, loc), Word::new (Tokens::RPAR, loc),
                                              syntVar,
                                              [leftSynt, rightSynt], canBeDotCall-> false);

        // Validate the value to get the return type
        let valueCall = context:.validateValue (syntCall);
        if (op == BinaryOperators::NOT_EQUAL) { // We need to inverse the equality, the operator returns '=='
            let syntTest = UnaryExpr::new (Word::new (UnaryOperators::NOT, loc), ValueWrapperExpr::new (loc, valueCall));
            context:.validateValue (syntTest)
        } else {
            valueCall
        }
    }
    
    /**
     * ================================================================================
     * ================================================================================
     * =========================           LOGICAL            =========================
     * ================================================================================
     * ================================================================================
     */


    /**
     * Validate a binary operation involving logical operator (&&, ||)
     * @info: these operators have a meaning only on bool values
     * @params: 
     *   - context: the context of the validation
     *   - op: the operator (assuming it's a logical operator)
     *   - bin: the binary expression to validate
     * @returns: the validated value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    def validateLogicalOperation (self, dmut context : &Validator, op : BinaryOperators, bin : &BinaryExpr)-> &Value
        throws &ErrorMsg
    {
        let left = context:.validateValue (bin.getLeft ());
        let right = context:.validateValue (bin.getRight ());

        match left.getType () {
            BoolType () => {
                match right.getType () {
                    BoolType () => {
                        return LogicalBinBoolOperatorValue::new (bin.getLoc (), op, left, right);
                    }
                }
            }
        }

        throw ErrorMsg::fatal (bin.getLoc (), format (ValidateErrorMessage::UNDEFINED_BIN_OP, op, left.getType (), right.getType ()));
    }


    /**
     * ================================================================================
     * ================================================================================
     * =========================            RANGE             =========================
     * ================================================================================
     * ================================================================================
     */


    /**
     * Validate a binary operation involving a range operator
     * @params: 
     *   - context: the context of the validation
     *   - op: the operator (assuming it's a range operator)
     *   - bin: the binary expression to validate
     * @returns: the validated value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    def validateRangeOperation (self, dmut context : &Validator, op : BinaryOperators, bin : &BinaryExpr)-> &Value
        throws &ErrorMsg
    {
        let left = context:.validateValue (bin.getLeft ());
        let right = context:.validateValue (bin.getRight ());

        let dmut errors = Vec!{&ErrorMsg}::new ();        
        {
            match left.getType () { // First we try the operation as a left side operation (asking for left operand to be the master of the operation, i.e. left.opBinary!{op} (right)
                IntType () => return self.validateIntRangeOp (alias context, bin.getLoc (), op, left, right);
                CharType () => return self.validateCharRangeOp (alias context, bin.getLoc (), op, left, right);
                FloatType () => return self.validateFloatRangeOp (alias context, bin.getLoc (), op, left, right);
                StructType () => return self.validateStructRangeOpLeft (alias context, bin.getLoc (), op, left, right);
                ClassPtrType () => return self.validateClassRangeOpLeft (alias context, bin.getLoc (), op, left, right);
            };
            
            errors:.push (ErrorMsg::fatal (bin.getLoc (), format (ValidateErrorMessage::UNDEFINED_BIN_OP, op, left.getType (), right.getType ())));
        } catch {
            err : &ErrorMsg => { errors:.push (err); }
        } 

        { // if we are here the validation as a left operand validation failed, so we need to try it as a right operation (right.opBinaryRight!{op} (left))
            match right.getType () { // it is working only for two kind of type structs and classes
                StructType () => return self.validateStructRangeOpRight (alias context, bin.getLoc (), op, left, right);
                ClassPtrType () => return self.validateClassRangeOpRight (alias context, bin.getLoc (), op, left, right);
            } // We can quit without testing the other types, there is already an error in the errors vec
        } catch {
            err : &ErrorMsg => { errors:.push (err); } // No we still fail
        }

        throw ErrorMsg::list (errors[]); // there is no valid math operation for left and right        
    }

    /**
     * Validate a range operator assuming that the left operand is a int value
     * @params: 
     *   - context: the context of the validation
     *   - loc: the location of the operation
     *   - op: the range operator
     *   - left: the left operand
     *   - right: the right operand
     * @returns: the result value
     * @throws:
     *    - &ErrorMsg: if the operation is not valid
     */
    def validateIntRangeOp (self, dmut _ : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Value)-> &Value
        throws &ErrorMsg
    {
        match left.getType () {
            li : &IntType => {
                match right.getType () {
                    ri : &IntType => {
                        if (ri.isSigned () == li.isSigned ()) {
                            let maxSize = comparison::max (li.getSize (), ri.getSize ());
                            let inner = IntType::new (loc, signed-> li.isSigned (), size-> maxSize);
                            let type = RangeType::new (loc, inner);
                            return RangeIntOperatorValue::new (loc, type, op, left, right, include-> (op == BinaryOperators::TDOT));
                        }
                    }
                }
            }
            _ => __pragma!panic ();
        }

        throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_BIN_OP, op, left.getType (), right.getType ()));
    }

    /**
     * Validate a range operator assuming that the left operand is a float value
     * @params: 
     *   - context: the context of the validation
     *   - loc: the location of the operation
     *   - op: the range operator
     *   - left: the left operand
     *   - right: the right operand
     * @returns: the result value
     * @throws:
     *    - &ErrorMsg: if the operation is not valid
     */
    def validateFloatRangeOp (self, dmut _ : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Value)-> &Value
        throws &ErrorMsg
    {
        match left.getType () {
            li : &FloatType => {
                match right.getType () {
                    ri : &FloatType => {
                        let maxSize = comparison::max (li.getSize (), ri.getSize ());
                        let inner = FloatType::new (loc, size-> maxSize);
                        let type = RangeType::new (loc, inner);
                        return RangeFloatOperatorValue::new (loc, type, op, left, right, include-> (op == BinaryOperators::TDOT));                    
                    }
                }
            }
            _ => __pragma!panic ();
        }

        throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_BIN_OP, op, left.getType (), right.getType ()));
    }

    /**
     * Validate a range operator assuming that the left operand is a char value
     * @params: 
     *   - context: the context of the validation
     *   - loc: the location of the operation
     *   - op: the range operator
     *   - left: the left operand
     *   - right: the right operand
     * @returns: the result value
     * @throws:
     *    - &ErrorMsg: if the operation is not valid
     */
    def validateCharRangeOp (self, dmut _ : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Value)-> &Value
        throws &ErrorMsg
    {
        match left.getType () {
            li : &CharType => {
                match right.getType () {
                    ri : &CharType => {
                        let maxSize = comparison::max (li.getSize (), ri.getSize ());
                        let inner = CharType::new (loc, size-> maxSize);
                        let type = RangeType::new (loc, inner);
                        return RangeCharOperatorValue::new (loc, type, op, left, right, include-> (op == BinaryOperators::TDOT));                    
                    }
                }
            }
            _ => __pragma!panic ();
        }

        throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_BIN_OP, op, left.getType (), right.getType ()));
    }
    
    /**
     * ================================================================================
     * ================================================================================
     * =========================           POINTER            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a binary operation involving a pointer operator
     * @params: 
     *   - context: the context of the validation
     *   - op: the operator (assuming it's a pointer operator)
     *   - bin: the binary expression to validate
     * @returns: the validated value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    def validatePointerOperation (self, dmut context : &Validator, op : BinaryOperators, bin : &BinaryExpr)-> &Value
        throws &ErrorMsg
    {

        let left = context:.validateValue (bin.getLeft ());
        let right = context:.validateValue (bin.getRight ());
        
        match left.getType () { // First we try the operation as a left side operation (asking for left operand to be the master of the operation, i.e. left.opBinary!{op} (right)
            PointerType () => return self.validatePointerPointerOp (alias context, bin.getLoc (), op, left, right);
            ClassPtrType () => return self.validateClassPointerOp (alias context, bin.getLoc (), op, left, right);
        };
            
        throw ErrorMsg::fatal (bin.getLoc (), format (ValidateErrorMessage::UNDEFINED_BIN_OP, op, left.getType (), right.getType ()));
    }
    
    /**
     * Validate a pointer operator (is and !is) assuming that the left operand is a pointer value
     * @params: 
     *   - context: the context of the validation
     *   - loc: the location of the operation
     *   - op: the range operator
     *   - left: the left operand
     *   - right: the right operand
     * @returns: the result value
     * @throws:
     *    - &ErrorMsg: if the operation is not valid
     */
    def validatePointerPointerOp (self, dmut context : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Value)-> &Value
        throws &ErrorMsg
    {
        match left.getType () {
            lp : &PointerType => {
                match right.getType () {
                    rp : &PointerType => {
                        context.verifyCompatibleType (left.getLoc (), right.getLoc (), lp, rp);
                        return CmpPointerOperatorValue::new (loc, op, left, right);
                    }
                }
            }
            _ => __pragma!panic ();
        }

        throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_BIN_OP, op, left.getType (), right.getType ()));
    }

    /**
     * Validate a pointer operator (is and !is) assuming that the left operand is a class value
     * @params: 
     *   - context: the context of the validation
     *   - loc: the location of the operation
     *   - op: the range operator
     *   - left: the left operand
     *   - right: the right operand
     * @returns: the result value
     * @throws:
     *    - &ErrorMsg: if the operation is not valid
     */
    def validateClassPointerOp (self, dmut context : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Value)-> &Value
        throws &ErrorMsg
    {
        match left.getType () {
            lp : &ClassPtrType => {
                match right.getType () {
                    rp : &ClassPtrType => {
                        context.verifyCompatibleType (left.getLoc (), right.getLoc (), lp, rp);
                        // We are using a pointer cmp, because classptr are basically just pointers, and the result is just a bool, so there is no need to be much specific here
                        return CmpPointerOperatorValue::new (loc, op, left, right); 
                    }
                }
            }
            _ => __pragma!panic ();
        }

        throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_BIN_OP, op, left.getType (), right.getType ()));
   
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================             SET              =========================
     * ================================================================================
     * ================================================================================
     */


    /**
     * Validate a binary operation involving a set operator
     * @params: 
     *   - context: the context of the validation
     *   - op: the operator (assuming it's a set operator)
     *   - bin: the binary expression to validate
     * @returns: the validated value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    def validateSetOperation (self, dmut context : &Validator, op : BinaryOperators, bin : &BinaryExpr)-> &Value
        throws &ErrorMsg
    {
        context;
        op;
        bin;
        __pragma!fake_throw (&ErrorMsg);
        __pragma!panic ();
    }

    
    /**
     * ================================================================================
     * ================================================================================
     * =========================             TYPE             =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a binary operation involving a type operator
     * @params: 
     *   - context: the context of the validation
     *   - op: the operator (assuming it's a type operator)
     *   - bin: the binary expression to validate
     * @returns: the validated value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    def validateTypeOperation (self, dmut context : &Validator, op : BinaryOperators, bin : &BinaryExpr)-> &Value
        throws &ErrorMsg
    {
        context;
        op;
        bin;
        __pragma!fake_throw (&ErrorMsg);
        __pragma!panic ();
    }


    /**
     * ================================================================================
     * ================================================================================
     * =========================            FIELD             =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a binary operation involving a field operator
     * @params: 
     *   - context: the context of the validation
     *   - op: the operator (assuming it's a field operator)
     *   - bin: the binary expression to validate
     * @returns: the validated value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    def validateFieldOperation (self, dmut context : &Validator, op : BinaryOperators, bin : &BinaryExpr)-> &Value
        throws &ErrorMsg
    {
        context;
        op;
        bin;
        __pragma!fake_throw (&ErrorMsg);
        __pragma!panic ();
    }

    

    /**
     * ================================================================================
     * ================================================================================
     * =========================            MODULE            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a binary operation involving a module operator
     * @params: 
     *   - context: the context of the validation
     *   - bin: the binary expression to validate
     * @returns: the validated value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    pub def validateModuleOperation (self, dmut context : &Validator, bin : &PathExpr)-> &Value
        throws & ErrorMsg
    {
        let left = context:.validateValue (bin.getLeft ());
        match bin.getRight () {
            v : &VarExpr => {
                match left {
                    md : &ModuleRefValue => {
                        let dmut module = context:.getModuleFromRef (md);
                        let dmut res = alias (alias module:.getSymbols (v.getLoc ().str ()))[];
                        if (res.len != 0us) {
                            return context:.getLiteralValidator ().validateMultSymbols (bin.getLoc (), alias context, alias res);
                        }
                    }
                    ms : &MultSymValue => {
                        let dmut all = Vec!{dmut &Symbol}::new ();
                        for c in ms.getValues () {
                            match c {
                                md : &ModuleRefValue => {
                                    let dmut module = context:.getModuleFromRef (md);
                                    let dmut res = alias (alias module:.getSymbols (v.getLoc ().str ()))[];
                                    for i in 0us .. res.len { all:.push (alias res[i]); }
                                }
                            }
                        }
                        
                        if (all.len () != 0us) {
                            return context:.getLiteralValidator ().validateMultSymbols (bin.getLoc (), alias context, alias (alias all)[]);
                        }
                    }
                }
            }
        };

        throw ErrorMsg::fatal (bin.getLoc (), format (ValidateErrorMessage::UNDEFINED_BIN_OP, bin.getLoc ().str (), left, bin.getRight ()));
    }

    
    /**
     * ================================================================================
     * ================================================================================
     * =========================         AFFECTATION          =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate an affectation operation, where the operator can be anything the result being stored in the left operatand of the operation
     * @params: 
     *   - context: the context of the validation
     *   - op: the operator (can be a None operator, i.e. just a simple affectation)
     *   - bin: the binary expression to validate
     * @returns: the validated value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    def validateAffectOperation (self, dmut context : &Validator, op : BinaryOperators, bin : &BinaryExpr)-> &Value
        throws &ErrorMsg
    {
        context;
        op;
        bin;
        __pragma!fake_throw (&ErrorMsg);
        __pragma!panic ();
    }


    /**
     * ================================================================================
     * ================================================================================
     * =========================       STRUCT / CLASS         =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a binary operator (math, set, range or bitwise) assuming that the left operand is a struct
     * @params: 
     *   - context: the context of the validation
     *   - loc: the location of the operation
     *   - op: the operator
     *   - left: the left operand (assumed to be a struct type operand)
     *   - right: the right operand
     * @returns: the result value (generally a call value)
     * @throws: 
     *   - &ErrorMsg: if the operation is invalid
     */
    def validateStructOpLeft (self, dmut context : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Value)-> &Value
        throws &ErrorMsg
    {
        context;
        loc;
        op;
        left;
        right;
        __pragma!fake_throw (&ErrorMsg);
        __pragma!panic ();
    }

    /**
     * Validate a binary operator (math, set, range or bitwise) assuming that the right operand is a struct
     * @params: 
     *   - context: the context of the validation
     *   - loc: the location of the operation
     *   - op: the operator
     *   - left: the left operand 
     *   - right: the right operand (assumed to be a struct type operand)
     * @returns: the result value (generally a call value)
     * @throws: 
     *   - &ErrorMsg: if the operation is invalid
     */    
    def validateStructOpRight (self, dmut context : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Value)-> &Value
        throws &ErrorMsg
    {
        context;
        loc;
        op;
        left;
        right;
        __pragma!fake_throw (&ErrorMsg);
        __pragma!panic ();
    }    
    
    /**
     * Validate a binary operator (math, set, range or bitwise) assuming that the left operand is a class ptr
     * @params: 
     *   - context: the context of the validation
     *   - loc: the location of the operation
     *   - op: the operator
     *   - left: the left operand (assumed to be a class ptr type operand)
     *   - right: the right operand
     * @returns: the result value (generally a call value)
     * @throws: 
     *   - &ErrorMsg: if the operation is invalid
     */
    def validateClassOpLeft (self, dmut context : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Value)-> &Value
        throws &ErrorMsg
    {
        context;
        loc;
        op;
        left;
        right;
        __pragma!fake_throw (&ErrorMsg);
        __pragma!panic ();
    }

    /**
     * Validate a binary operator (math, set, range or bitwise) assuming that the right operand is a class ptr
     * @params: 
     *   - context: the context of the validation
     *   - loc: the location of the operation
     *   - op: the operator
     *   - left: the left operand 
     *   - right: the right operand (assumed to be a class ptr type operand)
     * @returns: the result value (generally a call value)
     * @throws: 
     *   - &ErrorMsg: if the operation is invalid
     */    
    def validateClassOpRight (self, dmut context : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Value)-> &Value
        throws &ErrorMsg
    {
        context;
        loc;
        op;
        left;
        right;
        __pragma!fake_throw (&ErrorMsg);
        __pragma!panic ();
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================     STRUCT / CLASS (CMP)     =========================
     * ================================================================================
     * ================================================================================
     */
    
    /**
     * Validate a binary comparison operator assuming that the left operand is a struct
     * @params: 
     *   - context: the context of the validation
     *   - loc: the location of the operation
     *   - op: the operator
     *   - left: the left operand (assumed to be a struct type operand)
     *   - right: the right operand
     * @returns: the result value (generally a call value)
     * @throws: 
     *   - &ErrorMsg: if the operation is invalid
     */
    def validateStructCmpOpLeft (self, dmut context : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Value)-> &Value
        throws &ErrorMsg
    {
        context;
        loc;
        op;
        left;
        right;
        __pragma!fake_throw (&ErrorMsg);
        __pragma!panic ();
    }

    /**
     * Validate a binary comparison operator assuming that the right operand is a struct
     * @params: 
     *   - context: the context of the validation
     *   - loc: the location of the operation
     *   - op: the operator
     *   - left: the left operand 
     *   - right: the right operand (assumed to be a struct type operand)
     * @returns: the result value (generally a call value)
     * @throws: 
     *   - &ErrorMsg: if the operation is invalid
     */    
    def validateStructCmpOpRight (self, dmut context : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Value)-> &Value
        throws &ErrorMsg
    {
        context;
        loc;
        op;
        left;
        right;
        __pragma!fake_throw (&ErrorMsg);
        __pragma!panic ();
    }

    
    /**
     * Validate a binary comparison operator assuming that the left operand is a class ptr
     * @params: 
     *   - context: the context of the validation
     *   - loc: the location of the operation
     *   - op: the operator
     *   - left: the left operand (assumed to be a class ptr type operand)
     *   - right: the right operand
     * @returns: the result value (generally a call value)
     * @throws: 
     *   - &ErrorMsg: if the operation is invalid
     */
    def validateClassCmpOpLeft (self, dmut context : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Value)-> &Value
        throws &ErrorMsg
    {
        context;
        loc;
        op;
        left;
        right;
        __pragma!fake_throw (&ErrorMsg);
        __pragma!panic ();
    }

    /**
     * Validate a binary comparison operator assuming that the right operand is a class ptr
     * @params: 
     *   - context: the context of the validation
     *   - loc: the location of the operation
     *   - op: the operator
     *   - left: the left operand 
     *   - right: the right operand (assumed to be a class ptr type operand)
     * @returns: the result value (generally a call value)
     * @throws: 
     *   - &ErrorMsg: if the operation is invalid
     */    
    def validateClassCmpOpRight (self, dmut context : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Value)-> &Value
        throws &ErrorMsg
    {
        context;
        loc;
        op;
        left;
        right;
        __pragma!fake_throw (&ErrorMsg);
        __pragma!panic ();
    }


    /**
     * ================================================================================
     * ================================================================================
     * =========================    STRUCT / CLASS (RANGE)    =========================
     * ================================================================================
     * ================================================================================
     */


    
    /**
     * Validate a binary range operator assuming that the left operand is a struct
     * @params: 
     *   - context: the context of the validation
     *   - loc: the location of the operation
     *   - op: the operator
     *   - left: the left operand (assumed to be a struct type operand)
     *   - right: the right operand
     * @returns: the result value (generally a call value)
     * @throws: 
     *   - &ErrorMsg: if the operation is invalid
     */
    def validateStructRangeOpLeft (self, dmut context : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Value)-> &Value
        throws &ErrorMsg
    {
        context;
        loc;
        op;
        left;
        right;
        __pragma!fake_throw (&ErrorMsg);
        __pragma!panic ();
    }

    /**
     * Validate a binary range operator assuming that the right operand is a struct
     * @params: 
     *   - context: the context of the validation
     *   - loc: the location of the operation
     *   - op: the operator
     *   - left: the left operand 
     *   - right: the right operand (assumed to be a struct type operand)
     * @returns: the result value (generally a call value)
     * @throws: 
     *   - &ErrorMsg: if the operation is invalid
     */    
    def validateStructRangeOpRight (self, dmut context : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Value)-> &Value
        throws &ErrorMsg
    {
        context;
        loc;
        op;
        left;
        right;
        __pragma!fake_throw (&ErrorMsg);
        __pragma!panic ();
    }

    
    /**
     * Validate a binary range operator assuming that the left operand is a class ptr
     * @params: 
     *   - context: the context of the validation
     *   - loc: the location of the operation
     *   - op: the operator
     *   - left: the left operand (assumed to be a class ptr type operand)
     *   - right: the right operand
     * @returns: the result value (generally a call value)
     * @throws: 
     *   - &ErrorMsg: if the operation is invalid
     */
    def validateClassRangeOpLeft (self, dmut context : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Value)-> &Value
        throws &ErrorMsg
    {
        context;
        loc;
        op;
        left;
        right;
        __pragma!fake_throw (&ErrorMsg);
        __pragma!panic ();
    }

    /**
     * Validate a binary range operator assuming that the right operand is a class ptr
     * @params: 
     *   - context: the context of the validation
     *   - loc: the location of the operation
     *   - op: the operator
     *   - left: the left operand 
     *   - right: the right operand (assumed to be a class ptr type operand)
     * @returns: the result value (generally a call value)
     * @throws: 
     *   - &ErrorMsg: if the operation is invalid
     */    
    def validateClassRangeOpRight (self, dmut context : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Value)-> &Value
        throws &ErrorMsg
    {
        context;
        loc;
        op;
        left;
        right;
        __pragma!fake_throw (&ErrorMsg);
        __pragma!panic ();
    }

    
    /**
     * ================================================================================
     * ================================================================================
     * =========================            COMMON            =========================
     * ================================================================================
     * ================================================================================
     */
    
    /**
     * Transform the word into a valid operator
     * @assume: the operator is valid
     * @params: 
     *   - op: the operator
     * @returns: 
     *   - .0: the operator
     *   - .1: true iif the operator is an affectation operator (e.g. +=, -=)
     *   - .2: true iif the operator is a math operator (e.g. +, -)
     *   - .3: true iif the operator is a logical operator (e.g. >=, <=, ==)
     *   - .4: true iif the operator is a range operator (.., ...)
     */
    def toOperator (self, op : &Word)-> (BinaryOperators, bool, OperatorType) {
        match op.str () {
            BinaryOperators::EQUAL => { (BinaryOperators::EQUAL, true, OperatorType::NONE) }
            
            BinaryOperators::DIV_AFF => { (BinaryOperators::DIV, true, OperatorType::MATH) }
            BinaryOperators::MINUS_AFF => { (BinaryOperators::MINUS, true, OperatorType::MATH) }
            BinaryOperators::PLUS_AFF => { (BinaryOperators::PLUS, true, OperatorType::MATH) }
            BinaryOperators::STAR_AFF => { (BinaryOperators::STAR, true, OperatorType::MATH) }
            BinaryOperators::PERCENT_AFF => { (BinaryOperators::PERCENT, true, OperatorType::MATH) }
            
            BinaryOperators::TILDE_AFF => { (BinaryOperators::TILDE, true, OperatorType::SET) }
            
            BinaryOperators::LEFTD_AFF => { (BinaryOperators::LEFTD, true, OperatorType::BITWISE) }
            BinaryOperators::RIGHTD_AFF => { (BinaryOperators::RIGHTD, true, OperatorType::BITWISE) }
            
            BinaryOperators::DPIPE => { (BinaryOperators::DPIPE, false, OperatorType::LOGICAL) }
            BinaryOperators::DAND => { (BinaryOperators::DAND, false, OperatorType::LOGICAL) }
            
            BinaryOperators::INF => { (BinaryOperators::INF, false, OperatorType::COMPARISON) } 
            BinaryOperators::SUP => { (BinaryOperators::SUP, false, OperatorType::COMPARISON) }
            BinaryOperators::INF_EQUAL => { (BinaryOperators::INF_EQUAL, false, OperatorType::COMPARISON)  }
            BinaryOperators::SUP_EQUAL => { (BinaryOperators::SUP_EQUAL, false, OperatorType::COMPARISON) }
            BinaryOperators::NOT_EQUAL => { (BinaryOperators::NOT_EQUAL, false, OperatorType::COMPARISON) }
            BinaryOperators::DEQUAL => { (BinaryOperators::DEQUAL, false, OperatorType::COMPARISON) }
            
            BinaryOperators::OF => { (BinaryOperators::OF, false, OperatorType::TYPE) }
            BinaryOperators::NOT_OF => { (BinaryOperators::NOT_OF, false, OperatorType::TYPE) }
            
            BinaryOperators::IS => { (BinaryOperators::IS, false, OperatorType::POINTER) }
            BinaryOperators::NOT_IS => { (BinaryOperators::NOT_IS, false, OperatorType::POINTER) }
                       
            BinaryOperators::TDOT => { (BinaryOperators::TDOT, false, OperatorType::RANGE) }
            BinaryOperators::DDOT => { (BinaryOperators::DDOT, false, OperatorType::RANGE) }
            
            BinaryOperators::LEFTD => { (BinaryOperators::LEFTD, false, OperatorType::BITWISE) }
            BinaryOperators::RIGHTD => { (BinaryOperators::RIGHTD, false, OperatorType::BITWISE) }
            BinaryOperators::PIPE => { (BinaryOperators::PIPE, false, OperatorType::BITWISE) }  
            BinaryOperators::XOR => { (BinaryOperators::XOR, false, OperatorType::BITWISE) } 
            BinaryOperators::AND => { (BinaryOperators::AND, false, OperatorType::BITWISE) }

            BinaryOperators::IN => { (BinaryOperators::IN, false, OperatorType::SET) }
            BinaryOperators::NOT_IN => { (BinaryOperators::NOT_IN, false, OperatorType::SET) }
            BinaryOperators::TILDE => { (BinaryOperators::TILDE, false, OperatorType::SET) }
            
            BinaryOperators::PLUS => { (BinaryOperators::PLUS, false, OperatorType::MATH) }
            BinaryOperators::MINUS => { (BinaryOperators::MINUS, false, OperatorType::MATH) }
            BinaryOperators::STAR => { (BinaryOperators::STAR, false, OperatorType::MATH) } 
            BinaryOperators::PERCENT => { (BinaryOperators::PERCENT, false, OperatorType::MATH) }
            BinaryOperators::DIV => { (BinaryOperators::DIV, false, OperatorType::MATH) }
            BinaryOperators::DXOR => { (BinaryOperators::DXOR, false, OperatorType::MATH) }
            
            BinaryOperators::DOT => { (BinaryOperators::DOT, false, OperatorType::FIELD) }
            BinaryOperators::DOT_AND => { (BinaryOperators::DOT_AND, false, OperatorType::FIELD) }
            
            BinaryOperators::DCOLON => { (BinaryOperators::DCOLON, false, OperatorType::MODULE) }
            _ => {
                __pragma!panic ();
            }        
        }
    }
    
}
