mod ymirc::semantic::validator::operator::binary;

import ymirc::semantic::validator::visitor;
import ymirc::semantic::validator::errors;
import ymirc::errors::_;
import ymirc::utils::format;
import ymirc::syntax::expression::operator::binary;

import ymirc::semantic::generator::_;

import ymirc::lexing::word;
import ymirc::syntax::keys;

import std::algorithm::comparison;
import std::io;

pub enum 
| MATH = 2u32
| LOGICAL = 3u32
| RANGE = 7u32
| POINTER = 4u32
| SET = 3u32
| TYPE = 5u32
| FIELD = 8u32
| MODULE = 9u32
| NONE = 1u32
 -> OperatorType;

/**
 * The binary validator is used to validate BinaryOpExpr
 * It is a class validator because binary operation are complex
 */
pub class BinaryOpValidator {

    /**
     * Create an empty validator     
     */
    pub self () {}

    /**
     * Validate a binary expression
     * @params: 
     *  - context: the context of the validation
     *  - bin: the binary operator to validate
     * @returns: a value
     * @throws: &ErrorMsg, if the validation failed
     */
    pub def validate (self, dmut context : &Validator, bin : &BinaryExpr) -> &Value
        throws &ErrorMsg
    {
        let (op, isAff, type) = self.toOperator (bin.getLoc ());
        
        match (type, isAff) {
            (OperatorType::MATH, false) => { 
                return self.validateMathOperation (alias context, op, bin);
            }
            (OperatorType::LOGICAL, false) => { // all boolean operators, cannot be an affectation
                return self.validateLogicalOperation (alias context, op, bin);
            }
            (OperatorType::RANGE, false) => { // .. and ..., cannot be an affectation
                return self.validateRangeOperation (alias context, op, bin);
            }
            (OperatorType::POINTER, false) => { // is and !is, cannot be an affectation
                return self.validatePointerOperation (alias context, op, bin);
            }
            (OperatorType::SET, false) => { // ~, in, and !in, might be an affectation for ~
                return self.validateSetOperation (alias context, op, bin);
            }
            (OperatorType::TYPE, false) => { // of and !of, cannot be an affectation
                return self.validateTypeOperation (alias context, op, bin);
            }
            (OperatorType::FIELD, false) => { // . and :., cannot be an affectation
                return self.validateFieldOperation (alias context, op, bin);
            }
            (OperatorType::MODULE, false) => { // ::, cannot be an affectation
                return self.validateModuleOperation (alias context, op, bin);
            }
            (_, true) => { // =, +=, -=, ~=, etc., affectation operators
                return self.validateAffectOperation (alias context, op, bin);
            }
            _ => { // All case should be handled.
                __pragma!panic ();
            }
        }
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================             MATH             =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a binary operation involving math operator
     * @params: 
     *   - context: the context of the validation
     *   - op: the operator (assuming it's a math operator)
     *   - bin: the binary expression to validate
     * @returns: the validated value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    def validateMathOperation (self, dmut context : &Validator, op : BinaryOperators, bin : &BinaryExpr)-> &Value
        throws &ErrorMsg
    {
        let left = context:.validateValue (bin.getLeft ());
        let right = context:.validateValue (bin.getRight ());
        match left.getType () {
            IntType () => return self.validateIntMathOp (alias context, bin.getLoc (), op, left, right);
            CharType () => return self.validateCharMathOp (alias context, bin.getLoc (), op, left, right);
            FloatType () => return self.validateFloatMathOp (alias context, bin.getLoc (), op, left, right);
        };

        __pragma!panic ();
    }


    /**
     * Validate a math operation where the left operand is a int type operand
     * @params: 
     *   - _: the context of the validation
     *   - op: the operator
     *   - left: the left operand (assumed of type int)
     *   - right: the right operand
     * @returns: The result value
     * @throws: 
     *   - &ErrorMsg: if the operation is not valid
     */
    def validateIntMathOp (self, dmut _ : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Value)-> &Value
        throws &ErrorMsg
    {
        match left.getType () {
            li : &IntType => {            
                match right.getType () {
                    ri : &IntType => {
                        if (li.isSigned () == ri.isSigned ()) {
                            let maxSize = comparison::max (li.getSize (), ri.getSize ());
                            let type = IntType::new (loc, signed-> li.isSigned (), size-> maxSize);
                            return BinaryOperatorValue::new (loc, type, op, left, right);
                        } else {
                            throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_BIN_OP, op, left.getType (), right.getType ()));
                        }
                    }
                    _ => {
                        throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_BIN_OP, op, left.getType (), right.getType ()));
                    }
                }
            }
            _ => __pragma!panic ()
        }
    }   

    /**
     * Validate a math operation where the left operand is a char type operand
     * @params: 
     *   - _: the context of the validation
     *   - op: the operator
     *   - left: the left operand (assumed of type char)
     *   - right: the right operand
     * @returns: The result value
     * @throws: 
     *   - &ErrorMsg: if the operation is not valid
     */
    def validateCharMathOp (self, dmut _ : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Value)-> &Value
        throws &ErrorMsg
    {
        if (op != BinaryOperators::PLUS && op != BinaryOperators::MINUS) {
            throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_BIN_OP, op, left.getType (), right.getType ()));
        }
        
        match left.getType () {
            lc : &CharType => {
                match right.getType () {
                    rc : &CharType => {
                        if (lc.getSize () == rc.getSize ()) {
                            let type = CharType::new (loc, size-> lc.getSize ());
                            return BinaryOperatorValue::new (loc, type, op, left, right);
                        } else {
                            throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_BIN_OP, op, left.getType (), right.getType ()));
                        }
                    }
                    _ => {
                        throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_BIN_OP, op, left.getType (), right.getType ()));
                    }
                }
            }
            _ => __pragma!panic ();   
        }
    }


    /**
     * Validate a math operation where the left operand is a float type operand
     * @params: 
     *   - _: the context of the validation
     *   - op: the operator
     *   - left: the left operand (assumed of type float)
     *   - right: the right operand
     * @returns: The result value
     * @throws: 
     *   - &ErrorMsg: if the operation is not valid
     */
    def validateFloatMathOp (self, dmut _ : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Value)-> &Value
        throws &ErrorMsg
    {
        match left.getType () {
            lf : &FloatType => {
                match right.getType () {
                    rf : &FloatType => {
                        let maxSize = comparison::max (lf.getSize (), rf.getSize ());
                        let type = FloatType::new (loc, size-> maxSize);
                        return BinaryOperatorValue::new (loc, type, op, left, right);
                    }
                    _ => {
                        throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_BIN_OP, op, left.getType (), right.getType ()));
                    }
                }
            }
            _ => __pragma!panic ();   
        }
    }
    
    /**
     * ================================================================================
     * ================================================================================
     * =========================           LOGICAL            =========================
     * ================================================================================
     * ================================================================================
     */


    /**
     * Validate a binary operation involving comparison operator
     * @params: 
     *   - context: the context of the validation
     *   - op: the operator (assuming it's a logical operator)
     *   - bin: the binary expression to validate
     * @returns: the validated value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    def validateLogicalOperation (self, dmut context : &Validator, op : BinaryOperators, bin : &BinaryExpr)-> &Value
        throws &ErrorMsg
    {
        context;
        op;
        bin;
        __pragma!fake_throw (&ErrorMsg);
        __pragma!panic ();
    }


    /**
     * ================================================================================
     * ================================================================================
     * =========================            RANGE             =========================
     * ================================================================================
     * ================================================================================
     */


    /**
     * Validate a binary operation involving a range operator
     * @params: 
     *   - context: the context of the validation
     *   - op: the operator (assuming it's a range operator)
     *   - bin: the binary expression to validate
     * @returns: the validated value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    def validateRangeOperation (self, dmut context : &Validator, op : BinaryOperators, bin : &BinaryExpr)-> &Value
        throws &ErrorMsg
    {
        context;
        op;
        bin;
        __pragma!fake_throw (&ErrorMsg);
        __pragma!panic ();
    }

    
    /**
     * ================================================================================
     * ================================================================================
     * =========================           POINTER            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a binary operation involving a pointer operator
     * @params: 
     *   - context: the context of the validation
     *   - op: the operator (assuming it's a pointer operator)
     *   - bin: the binary expression to validate
     * @returns: the validated value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    def validatePointerOperation (self, dmut context : &Validator, op : BinaryOperators, bin : &BinaryExpr)-> &Value
        throws &ErrorMsg
    {
        context;
        op;
        bin;
        __pragma!fake_throw (&ErrorMsg);
        __pragma!panic ();
    }

    
    /**
     * ================================================================================
     * ================================================================================
     * =========================             SET              =========================
     * ================================================================================
     * ================================================================================
     */


    /**
     * Validate a binary operation involving a set operator
     * @params: 
     *   - context: the context of the validation
     *   - op: the operator (assuming it's a set operator)
     *   - bin: the binary expression to validate
     * @returns: the validated value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    def validateSetOperation (self, dmut context : &Validator, op : BinaryOperators, bin : &BinaryExpr)-> &Value
        throws &ErrorMsg
    {
        context;
        op;
        bin;
        __pragma!fake_throw (&ErrorMsg);
        __pragma!panic ();
    }

    
    /**
     * ================================================================================
     * ================================================================================
     * =========================             TYPE             =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a binary operation involving a type operator
     * @params: 
     *   - context: the context of the validation
     *   - op: the operator (assuming it's a type operator)
     *   - bin: the binary expression to validate
     * @returns: the validated value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    def validateTypeOperation (self, dmut context : &Validator, op : BinaryOperators, bin : &BinaryExpr)-> &Value
        throws &ErrorMsg
    {
        context;
        op;
        bin;
        __pragma!fake_throw (&ErrorMsg);
        __pragma!panic ();
    }


    /**
     * ================================================================================
     * ================================================================================
     * =========================            FIELD             =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a binary operation involving a field operator
     * @params: 
     *   - context: the context of the validation
     *   - op: the operator (assuming it's a field operator)
     *   - bin: the binary expression to validate
     * @returns: the validated value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    def validateFieldOperation (self, dmut context : &Validator, op : BinaryOperators, bin : &BinaryExpr)-> &Value
        throws &ErrorMsg
    {
        context;
        op;
        bin;
        __pragma!fake_throw (&ErrorMsg);
        __pragma!panic ();
    }

    

    /**
     * ================================================================================
     * ================================================================================
     * =========================            MODULE            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a binary operation involving a module operator
     * @params: 
     *   - context: the context of the validation
     *   - op: the operator (assuming it's a module operator)
     *   - bin: the binary expression to validate
     * @returns: the validated value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    def validateModuleOperation (self, dmut context : &Validator, op : BinaryOperators, bin : &BinaryExpr)-> &Value
        throws &ErrorMsg
    {
        context;
        op;
        bin;
        __pragma!fake_throw (&ErrorMsg);
        __pragma!panic ();
    }

    
    /**
     * ================================================================================
     * ================================================================================
     * =========================         AFFECTATION          =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate an affectation operation, where the operator can be anything the result being stored in the left operatand of the operation
     * @params: 
     *   - context: the context of the validation
     *   - op: the operator (can be a None operator, i.e. just a simple affectation)
     *   - bin: the binary expression to validate
     * @returns: the validated value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    def validateAffectOperation (self, dmut context : &Validator, op : BinaryOperators, bin : &BinaryExpr)-> &Value
        throws &ErrorMsg
    {
        context;
        op;
        bin;
        __pragma!fake_throw (&ErrorMsg);
        __pragma!panic ();
    }

    
    /**
     * ================================================================================
     * ================================================================================
     * =========================            COMMON            =========================
     * ================================================================================
     * ================================================================================
     */
    
    /**
     * Transform the word into a valid operator
     * @assume: the operator is valid
     * @params: 
     *   - op: the operator
     * @returns: 
     *   - .0: the operator
     *   - .1: true iif the operator is an affectation operator (e.g. +=, -=)
     *   - .2: true iif the operator is a math operator (e.g. +, -)
     *   - .3: true iif the operator is a logical operator (e.g. >=, <=, ==)
     *   - .4: true iif the operator is a range operator (.., ...)
     */
    def toOperator (self, op : &Word)-> (BinaryOperators, bool, OperatorType) {
        match op.str () {
            BinaryOperators::EQUAL => { (BinaryOperators::EQUAL, true, OperatorType::NONE) }
            BinaryOperators::DIV_AFF => { (BinaryOperators::DIV, true, OperatorType::MATH) }
            BinaryOperators::MINUS_AFF => { (BinaryOperators::MINUS, true, OperatorType::MATH) }
            BinaryOperators::PLUS_AFF => { (BinaryOperators::PLUS, true, OperatorType::MATH) }
            BinaryOperators::STAR_AFF => { (BinaryOperators::STAR, true, OperatorType::MATH) }
            BinaryOperators::TILDE_AFF => { (BinaryOperators::TILDE, true, OperatorType::SET) }
            BinaryOperators::PERCENT_AFF => { (BinaryOperators::PERCENT, true, OperatorType::MATH) }
            BinaryOperators::LEFTD_AFF => { (BinaryOperators::LEFTD, true, OperatorType::MATH) }
            BinaryOperators::RIGHTD_AFF => { (BinaryOperators::RIGHTD, true, OperatorType::MATH) }
            
            BinaryOperators::DPIPE => { (BinaryOperators::DPIPE, false, OperatorType::LOGICAL) }
            BinaryOperators::DAND => { (BinaryOperators::DAND, false, OperatorType::LOGICAL) }
            BinaryOperators::INF => { (BinaryOperators::INF, false, OperatorType::LOGICAL) } 
            BinaryOperators::SUP => { (BinaryOperators::SUP, false, OperatorType::LOGICAL) }
            BinaryOperators::INF_EQUAL => { (BinaryOperators::INF_EQUAL, false, OperatorType::LOGICAL)  }
            BinaryOperators::SUP_EQUAL => { (BinaryOperators::SUP_EQUAL, false, OperatorType::LOGICAL) }
            BinaryOperators::NOT_EQUAL => { (BinaryOperators::NOT_EQUAL, false, OperatorType::LOGICAL) }
            BinaryOperators::DEQUAL => { (BinaryOperators::DEQUAL, false, OperatorType::LOGICAL) }
            
            BinaryOperators::OF => { (BinaryOperators::OF, false, OperatorType::TYPE) }
            BinaryOperators::IS => { (BinaryOperators::IS, false, OperatorType::POINTER) }
            BinaryOperators::IN => { (BinaryOperators::IN, false, OperatorType::SET) }
            BinaryOperators::NOT_OF => { (BinaryOperators::NOT_OF, false, OperatorType::TYPE) }
            BinaryOperators::NOT_IS => { (BinaryOperators::NOT_IS, false, OperatorType::POINTER) } 
            BinaryOperators::NOT_IN => { (BinaryOperators::NOT_IN, false, OperatorType::SET) }
            
            BinaryOperators::TDOT => { (BinaryOperators::TDOT, false, OperatorType::RANGE) }
            BinaryOperators::DDOT => { (BinaryOperators::DDOT, false, OperatorType::RANGE) }
            
            BinaryOperators::LEFTD => { (BinaryOperators::LEFTD, false, OperatorType::MATH) }
            BinaryOperators::RIGHTD => { (BinaryOperators::RIGHTD, false, OperatorType::MATH) }
            BinaryOperators::PIPE => { (BinaryOperators::PIPE, false, OperatorType::MATH) }  
            BinaryOperators::XOR => { (BinaryOperators::XOR, false, OperatorType::MATH) } 
            BinaryOperators::AND => { (BinaryOperators::AND, false, OperatorType::MATH) }
            
            BinaryOperators::PLUS => { (BinaryOperators::PLUS, false, OperatorType::MATH) }
            BinaryOperators::TILDE => { (BinaryOperators::TILDE, false, OperatorType::SET) }
            BinaryOperators::MINUS => { (BinaryOperators::MINUS, false, OperatorType::MATH) }
            BinaryOperators::STAR => { (BinaryOperators::STAR, false, OperatorType::MATH) } 
            BinaryOperators::PERCENT => { (BinaryOperators::PERCENT, false, OperatorType::MATH) }
            BinaryOperators::DIV => { (BinaryOperators::DIV, false, OperatorType::MATH) }
            BinaryOperators::DXOR => { (BinaryOperators::DXOR, false, OperatorType::MATH) }
            BinaryOperators::DOT => { (BinaryOperators::DOT, false, OperatorType::FIELD) }
            BinaryOperators::DOT_AND => { (BinaryOperators::DOT_AND, false, OperatorType::FIELD) }
            BinaryOperators::DCOLON => { (BinaryOperators::DCOLON, false, OperatorType::MODULE) }
            _ => {
                __pragma!panic ();
            }        
        }
    }
    
}
