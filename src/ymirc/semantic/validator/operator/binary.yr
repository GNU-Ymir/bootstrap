in binary;

use ymirc::semantic::validator::{visitor, errors};
use ymirc::semantic::declarator::errors;
use ymirc::errors::_;
use ymirc::utils::{format, bigint, bigfloat, math};

use ymirc::syntax::{_,
                    declaration::_,
                    expression::{_, literal::_, macro_::_, operator::_, template::_}};

use ymirc::global::core_;
use ymirc::semantic::{generator::_, symbol::_};
use ymirc::lexing::{word, tokens};

use std::{io, stream, algorithm::comparison};
use ymirc::semantic::generator::type::{_,
                                       custom::_,
                                       native::{_, scalar::_, compound::_},
                                       temporary::_};

use ymirc::semantic::generator::value::{_,
                                        construct::{_, delegate::_},
                                        literal::_,
                                        memory::_,
                                        operator::{_, binary::_, call::_, fields::_, map::_, slice::_, unary::_},
                                        operator::binary::{bool_::_, char_::_, float_::_, int_::_, pointer_::_},
                                        operator::map::iteration::_,
                                        prototypes::_,
                                        scope::_,
                                        syntax::_,
                                        template::_};

pub enum 
| MATH             = 1u32
| BITWISE          = 2u32
| LOGICAL          = 3u32
| COMPARISON       = 4u32
| RANGE            = 5u32
| POINTER          = 6u32
| SET              = 7u32
| TYPE             = 8u32
| FIELD            = 9u32
| MODULE           = 10u32
| FLOAT_COMPARISON = 11u32
| NONE             = 12u32
 -> OperatorType;

/**
 * The binary validator is used to validate BinaryOpExpr
 * It is a class validator because binary operation are complex
 */
pub record BinaryOpValidator {

    /**
     * Create an empty validator
     */
    pub self () {}

    /**
     * Validate a binary expression that must return a value (some operation can return a type, i.e. '::' on some types)
     * @params:
     *  - context: the context of the validation
     *  - bin: the binary operator to validate
     * @returns: a value
     * @throws:
     *    - &ErrorMsg, if the validation failed
     */
    pub fn validateValue (self, dmut context : &Validator, bin : &BinaryExpr) -> &Value
        throws ErrorMsg
    {
        let (op, isAff, type) = self.toOperator (bin.getLoc ());

        match (type, isAff) {
            (OperatorType::MATH, false) => {
                return self.validateMathOperation (alias context, op, bin);
            }
            (OperatorType::BITWISE, false) => { // |, &, ^, <<, >>, applicable only on ints
                return self.validateBitwiseOperation (alias context, op, bin);
            }
            (OperatorType::COMPARISON, false) => { // all comparison operators, <=, >=, >, etc.., cannot be an affectation
                return self.validateComparisonOperation (alias context, op, bin);
            }
            (OperatorType::FLOAT_COMPARISON, false) => {
                return self.validateFloatComparisonOperation (alias context, op, bin);
            }
            (OperatorType::LOGICAL, false) => { // all boolean operators, cannot be an affectation
                return self.validateLogicalOperation (alias context, op, bin);
            }
            (OperatorType::RANGE, false) => { // .. and ..., cannot be an affectation
                return self.validateRangeOperation (alias context, op, bin);
            }
            (OperatorType::POINTER, false) => { // is and !is, cannot be an affectation
                return self.validatePointerOperation (alias context, op, bin);
            }
            (OperatorType::SET, false) => { // ~, in, and !in, might be an affectation for ~
                return self.validateSetOperation (alias context, op, bin);
            }
            (OperatorType::TYPE, false) => { // of and !of, cannot be an affectation
                return self.validateTypeOperation (alias context, op, bin);
            }
            (OperatorType::FIELD, false) => { // . and :., cannot be an affectation
                return self.validateFieldOperation (alias context, op, bin);
            }
            (OperatorType::MODULE, false) => { // ::, cannot be an affectation
                return self.validateModuleOperation (alias context, op, bin);
            }
            (_, true) => { // =, +=, -=, ~=, etc., affectation operators
                return self.validateAffectOperation (alias context, op, bin);
            }
            _ => { // All case should be handled.
                panic;
            }
        }
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================             MATH             =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a binary operation involving math operator
     * @params:
     *   - context: the context of the validation
     *   - op: the operator (assuming it's a math operator)
     *   - bin: the binary expression to validate
     * @returns: the validated value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    fn validateMathOperation (self, dmut context : &Validator, op : BinaryOperators, bin : &BinaryExpr)-> &Value
        throws ErrorMsg
    {
        let left = context.implicitEnumUnwrap (context:.validateValue (bin.getLeft ()));
        let right = context.implicitEnumUnwrap (context:.validateValue (bin.getRight ()));

        self.validateMathOperation (alias context, bin.getLoc (), op, left, right)
    }

    /**
     * Validate a binary operation
     * @params:
     *    - context: the context of the validation
     *    - loc: the location of the operation
     *    - op: the operator
     *    - left: the left operand
     *    - right: the right operand
     * @returns: the validated value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     * */
    pub fn validateMathOperation (self, dmut context : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Value)-> &Value
        throws ErrorMsg
    {
        let mut errors : [&ErrorMsg] = [];
        {
            match left.getType () { // First we try the operation as a left side operation (asking for left operand to be the master of the operation, i.e. left.opBinary!{op} (right)
                IntType () => return self.validateIntMathOp (alias context, loc, op, left, right);
                CharType () => return self.validateCharMathOp (alias context, loc, op, left, right);
                FloatType () => return self.validateFloatMathOp (alias context, loc, op, left, right);
                PointerType () => return self.validatePointerMathOp (alias context, loc, op, left, right);
                c : &ClassPtrType => return self.validateClassOpLeft (alias context, loc, op, c, left, right);
            };
        } catch {
            err : &ErrorMsg => { errors ~= [err]; }
        }

        { // if we are here the validation as a left operand validation failed, so we need to try it as a right operation (right.opBinaryRight!{op} (left))
            match right.getType () { // it is working only for two kind of type structs and classes
                c : &ClassPtrType => return self.validateClassOpRight (alias context, loc, op, c, left, right);
            } // We can quit without testing the other types, there is already an error in the errors vec
        } catch {
            err : &ErrorMsg => { errors ~= [err]; } // No we still fail
        }

        // there is no valid math operation for left and right
        throw copy ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_BIN_OP, op, left.getType (), right.getType ()), notes-> errors);
    }


    /**
     * Validate a math operation where the left operand is a int type operand
     * @params:
     *   - context: the context of the validation
     *   - op: the operator
     *   - left: the left operand (assumed of type int)
     *   - right: the right operand
     * @returns: The result value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    fn validateIntMathOp (self, dmut context : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Value)-> &Value
        throws ErrorMsg
    {
        match left.getType () {
            li : &IntType => {
                match right.getType () {
                    ri : &IntType => {
                        if (op == BinaryOperators::DXOR) {
                            return self.validateIntOrFloatPowerOp (alias context, loc, op, left, right);
                        }

                        if (li.isSigned () == ri.isSigned () && li.getSize () == ri.getSize ()) {
                            let type = copy IntType (loc, signed-> li.isSigned (), size-> li.getSize ());
                            return copy BinaryMathIntOperatorValue (loc, type, op, left, right);
                        }

                        {
                            let compatibleRight = context:.verifyCompatibleTypeWithValue (loc, li, right, byReference-> false);
                            let type = copy IntType (loc, signed-> li.isSigned (), size-> li.getSize ());
                            return copy BinaryMathIntOperatorValue (loc, type, op, left, compatibleRight);
                        } catch {
                            leErr : &ErrorMsg => {
                                let compatibleLeft = context:.verifyCompatibleTypeWithValue (loc, ri, left, byReference-> false);
                                let type = copy IntType (loc, signed-> ri.isSigned (), size-> ri.getSize ());
                                return copy BinaryMathIntOperatorValue (loc, type, op, compatibleLeft, right);
                            } catch {
                                riErr : &ErrorMsg => {
                                    throw copy ErrorMsg::list (copy [leErr, riErr]);
                                }
                            }
                        }
                    }
                    rc : &CharType => { // char values as right operands, 12u8 + 'a'c8 == 'm'c8
                        if (!li.isSigned () && rc.getSize () == li.getSize ()) {
                            let type = copy CharType (loc, size-> rc.getSize ());
                            let l = context:.getCastValidator ().validateCast (alias context, left, type);
                            return copy BinaryMathCharOperatorValue (loc, type, op, l, right);
                        }
                    }
                }
            }
            _ => panic
        }

        throw copy ErrorMsg::list ([]);
    }

    /**
     * Validate the power operation
     * @info: This operation is not performed by the language itself (hardware) but by a core function (core::math::pow)
     * @example:
     * ====================
     * 12 ^^ 98
     * // rewritten into => 'core::math::iipow!{typeof(12)} (12, 98)-> typeof (12)
     * 12.f ^^ 0.5f
     * // rewritten into => 'core::math::ffpow!{typeof(12.f)} (12.0f, 0.5f)-> typeof (12.0f)
     * ====================
     * @params:
     *   - context: the context of the validation
     *   - op: the operator
     *   - left: the left operand (assumed of type int)
     *   - right: the right operand
     * @returns: The result value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    fn validateIntOrFloatPowerOp (self, dmut context : &Validator, loc : &Word, _ : BinaryOperators, left : &Value, right : &Value)-> &Value
        throws ErrorMsg
    {
        let funcPath = if (left.getType () of IntType) {
            MathUtils::IPOW_FUNC
        } else if (right.getType () of IntType) {
            MathUtils::FIPOW_FUNC
        } else { MathUtils::FFPOW_FUNC };

        // Create a var path to the core function core::math::pow
        let syntVar = context.createSyntaxVarFromPath (loc, funcPath);
        let func = context:.validateValue (syntVar);
        let call = context:.getCallOpValidator ().validate (alias context, loc, func, copy [left, right]);

        match call.getType () {
            IntType () => { return copy SpecialMathIntOperatorValue (loc, call.getType (), BinaryOperators::DXOR, left, right, call); }
            FloatType () => {  return copy SpecialMathFloatOperatorValue (loc, call.getType (), BinaryOperators::DXOR, left, right, call); }
            _ => throw copy ErrorMsg::fatal (func.getLoc (), ValidateErrorMessage::MALFORMED_CORE);
        }
    }

    /**
     * Validate the fmod operation
     * @info: this operation is not performed by the language itself (hardware) but by a core function (core::math::fmod)
     * @example:
     * ====================
     * 12.f % 0.5f
     * // rewritten into => 'core::math::ffmod!{typeof(12.f)} (12.0f, 0.5f)-> typeof (12.0f)
     * ====================
     * */
    fn validateFloatModOp (self, dmut context : &Validator, loc : &Word, _ : BinaryOperators, left : &Value, right : &Value)-> &Value
        throws ErrorMsg
    {
        // Create a var path to the core function core::math::pow
        let syntVar = context.createSyntaxVarFromPath (loc, MathUtils::FFMOD_FUNC);
        let func = context:.validateValue (syntVar);
        let call = context:.getCallOpValidator ().validate (alias context, loc, func, copy [left, right]);

        match call.getType () {
            FloatType () => {  return copy SpecialMathFloatOperatorValue (loc, call.getType (), BinaryOperators::PERCENT, left, right, call); }
            _ => throw copy ErrorMsg::fatal (func.getLoc (), ValidateErrorMessage::MALFORMED_CORE);
        }
    }

    /**
     * Validate a math operation where the left operand is a char type operand
     * @params:
     *   - _: the context of the validation
     *   - op: the operator
     *   - left: the left operand (assumed of type char)
     *   - right: the right operand
     * @returns: The result value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    fn validateCharMathOp (self, dmut context : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Value)-> &Value
        throws ErrorMsg
    {
        if (op != BinaryOperators::PLUS && op != BinaryOperators::MINUS) {
            throw copy ErrorMsg::list ([]);
        }

        match left.getType () {
            lc : &CharType => {
                match right.getType () {
                    ri : &IntType => { // only int values can be added, substracted to char values
                        if (!ri.isSigned () && ri.getSize () == lc.getSize ()) {
                            let type = copy CharType (loc, size-> lc.getSize ());
                            let r = context:.getCastValidator ().validateCast (alias context, right, type);
                            return copy BinaryMathCharOperatorValue (loc, type, op, left, r);
                        }
                    }
                }
            }
        }

        throw copy ErrorMsg::list ([]);
    }


    /**
     * Validate a math operation where the left operand is a float type operand
     * @params:
     *   - context: the context of the validation
     *   - op: the operator
     *   - left: the left operand (assumed of type float)
     *   - right: the right operand
     * @returns: The result value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    fn validateFloatMathOp (self, dmut context : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Value)-> &Value
        throws ErrorMsg
    {
        match left.getType () {
            lf : &FloatType => {
                match right.getType () {
                    _ : &IntType => {
                        if (op == BinaryOperators::DXOR) {
                            return self.validateIntOrFloatPowerOp (alias context, loc, op, left, right);
                        }
                    }
                    rf : &FloatType => {
                        if (op == BinaryOperators::DXOR) {
                            return self.validateIntOrFloatPowerOp (alias context, loc, op, left, right);
                        } else if (op == BinaryOperators::PERCENT) {
                            return self.validateFloatModOp (alias context, loc, op, left, right);
                        }

                        if (lf.getSize () == rf.getSize ()) {
                            let type = copy FloatType (loc, size-> lf.getSize ());
                            return copy BinaryMathFloatOperatorValue (loc, type, op, left, right);
                        }

                        {
                            let compatibleRight = context:.verifyCompatibleTypeWithValue (loc, lf, right, byReference-> false);
                            let type = copy FloatType (loc, size-> lf.getSize ());
                            return copy BinaryMathFloatOperatorValue (loc, type, op, left, compatibleRight);
                        } catch {
                            leErr : &ErrorMsg => {
                                let compatibleLeft = context:.verifyCompatibleTypeWithValue (loc, rf, left, byReference-> false);
                                let type = copy FloatType (loc, size-> rf.getSize ());
                                return copy BinaryMathFloatOperatorValue (loc, type, op, compatibleLeft, right);
                            } catch {
                                riErr : &ErrorMsg => {
                                    throw copy ErrorMsg::list (copy [leErr, riErr]);
                                }
                            }
                        }

                    }
                }
            }
        }

        throw copy ErrorMsg::list ([]);
    }

    /**
     * Validate a math operation where the left operand is a pointer type operand
     * @params:
     *   - _: the context of the validation
     *   - op: the operator
     *   - left: the left operand (assumed of type pointer)
     *   - right: the right operand
     * @returns: The result value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    fn validatePointerMathOp (self, dmut _ : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Value)-> &Value
        throws ErrorMsg
    {
        if (op != BinaryOperators::PLUS && op != BinaryOperators::MINUS) {
            throw copy ErrorMsg::list ([]);
        }

        match left.getType () {
            lp : &PointerType => {
                match right.getType () {
                    ri : &IntType => {
                        if (!ri.isSigned () && ri.getSize () == 0us) {
                            return copy BinaryMathPointerOperatorValue (loc, lp, op, left, right);
                        }
                    }
                    rp : &PointerType => {
                        if (rp.getInners ()[0] == lp.getInners ()[0] || rp.getInners ()[0] of VoidType) {
                            return copy BinaryMathPointerOperatorValue (loc, lp, op, left, right);
                        }
                    }
                }
            }
        }

        throw copy ErrorMsg::list ([]);
    }


    /*!
     * ================================================================================
     * ================================================================================
     * =========================           BITWISE            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a binary operation involving bitwise operators (|, &, <<, etc.)
     * @params:
     *   - context: the context of the validation
     *   - op: the operator (assuming it's a logical operator)
     *   - bin: the binary expression to validate
     * @returns: the validated value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    fn validateBitwiseOperation (self, dmut context : &Validator, op : BinaryOperators, bin : &BinaryExpr)-> &Value
        throws ErrorMsg
    {
        let left = context.implicitEnumUnwrap (context:.validateValue (bin.getLeft ()));
        let right = context.implicitEnumUnwrap (context:.validateValue (bin.getRight ()));

        let mut errors : [&ErrorMsg]  = [];
        {
            // First we try the operation as a left side operation (asking for left operand to be the master of the operation, i.e. left.opBinary!{op} (right)
            match left.getType () {
                IntType () => return self.validateIntBitwiseOp (alias context, bin.getLoc (), op, left, right);
                c : &ClassPtrType => return self.validateClassOpLeft (alias context, bin.getLoc (), op, c, left, right);
            };
        } catch {
            err : &ErrorMsg => { errors ~= [err]; }
        }

        { // if we are here the validation as a left operand validation failed, so we need to try it as a right operation (right.opBinaryRight!{op} (left))
            match right.getType () { // it is working only for two kind of type structs and classes
                c : &ClassPtrType => return self.validateClassOpRight (alias context, bin.getLoc (), op, c, left, right);
            } // We can quit without testing the other types, there is already an error in the errors vec
        } catch {
            err : &ErrorMsg => { errors ~= [err]; } // No we still fail
        }

        throw copy ErrorMsg::fatal (bin.getLoc (), format (ValidateErrorMessage::UNDEFINED_BIN_OP, op, left.getType (), right.getType ()), notes-> errors);
    }

    /**
     * Validate a binary operation involving bitwise operators, and assuming that left operand is a int typed value
     * @params:
     *   - context: the context of the validation
     *   - loc: the location of the operation
     *   - op: the operator
     *   - left: the left operand of the operation (assumed to be a int typed value)
     *   - right: the right operand of the operation
     * @returns: the result value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    fn validateIntBitwiseOp (self, dmut context : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Value)-> &Value
        throws ErrorMsg
    {
        match left.getType () {
            li : &IntType => {
                match right.getType () {
                    ri : &IntType => {
                        if (li.isSigned () == ri.isSigned () && li.getSize () == ri.getSize ()) {
                            let type = copy IntType (loc, signed-> li.isSigned (), size-> li.getSize ());
                            return copy BitwiseIntOperatorValue (loc, type, op, left, right);
                        }

                        {
                            let compatibleRight = context:.verifyCompatibleTypeWithValue (loc, li, right, byReference-> false);
                            let type = copy IntType (loc, signed-> li.isSigned (), size-> li.getSize ());
                            return copy BitwiseIntOperatorValue (loc, type, op, left, compatibleRight);
                        } catch {
                            leErr : &ErrorMsg => {
                                let compatibleLeft = context:.verifyCompatibleTypeWithValue (loc, ri, left, byReference-> false);
                                let type = copy IntType (loc, signed-> ri.isSigned (), size-> ri.getSize ());
                                return copy BitwiseIntOperatorValue (loc, type, op, compatibleLeft, right);
                            } catch {
                                riErr : &ErrorMsg => {
                                    throw copy ErrorMsg::list (copy [leErr, riErr]);
                                }
                            }
                        }
                    }
                }
            }
        }

        throw copy ErrorMsg::list ([]);
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================          COMPARISON          =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a binary operation involving comparison operators (<=, >=, <, >, ==, etc..)
     * @params:
     *   - context: the context of the validation
     *   - op: the operator (assuming it's a logical operator)
     *   - bin: the binary expression to validate
     * @returns: the validated value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    fn validateComparisonOperation (self, dmut context : &Validator, op : BinaryOperators, bin : &BinaryExpr)-> &Value
        throws ErrorMsg
    {
        let left = context.implicitEnumUnwrap (context:.validateValue (bin.getLeft ()));
        let right = context.implicitEnumUnwrap (context:.validateValue (bin.getRight ()));

        self.validateComparisonOperationImpl (alias context, bin.getLoc (), op, left, right)
    }

    /**
     * Validate a binary operation involving comparison operators (<=, >=, <, >, ==, etc..)
     * @params:
     *   - context: the context of the validation
     *   - op: the operator (assuming it's a logical operator)
     *   - left: the left operand
     *   - right: the right operand
     * @returns: the validated value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    pub fn validateComparisonOperation (self, dmut context : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Value)-> &Value
        throws ErrorMsg
    {
        let uLeft = context.implicitEnumUnwrap (left);
        let uRight = context.implicitEnumUnwrap (right);

        self.validateComparisonOperationImpl (alias context, loc, op, uLeft, uRight)
    }

    /**
     * Validate a binary operation involving comparison operators (<=, >=, <, >, ==, etc..)
     * @params:
     *   - context: the context of the validation
     *   - op: the operator (assuming it's a logical operator)
     *   - left: the left operand
     *   - right: the right operand
     * @returns: the validated value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    fn validateComparisonOperationImpl (self, dmut context : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Value)-> &Value
        throws ErrorMsg
    {
        let mut errors : [&ErrorMsg] = [];
        {
            // First we try the operation as a left side operation (asking for left operand to be the master of the operation, i.e. left.opBinary!{op} (right)
            match left.getType () {
                IntType () => return self.validateIntCmpOp (alias context, loc, op, left, right);
                FloatType () => return self.validateFloatCmpOp (alias context, loc, op, left, right);
                CharType () => return self.validateCharCmpOp (alias context, loc, op, left, right);
                BoolType () => return self.validateBoolCmpOp (alias context, loc, op, left, right);
                PointerType () => return self.validatePointerCmpOp (alias context, loc, op, left, right);
                ArrayType () => return self.validateSliceOrArrayCmpOp (alias context, loc, op, left, right);
                SliceType () => return self.validateSliceOrArrayCmpOp (alias context, loc, op, left, right);
                TupleType () => return self.validateTupleCmpOp (alias context, loc, op, left, right);
                RangeType () => return self.validateRangeCmpOp (alias context, loc, op, left, right);
                c : &ClassPtrType => return self.validateClassCmpOp (alias context, loc, op, c, left, right);
                OptionType () => return self.validateOptionCmpOp (alias context, loc, op, left, right);
                FuncPtrType () => return self.validateFuncPtrCmpOp (alias context, loc, op, left, right);
                DelegateType () => return self.validateDGPtrCmpOp (alias context, loc, op, left, right);
            };
        } catch {
            err : &ErrorMsg => { errors ~= [err]; }
        }

        { // if we are here the validation as a left operand validation failed, so we need to try it as a right operation (right.opBinaryRight!{op} (left))
            match right.getType () { // it is working only for two kind of type structs and classes
                c : &ClassPtrType => return self.validateClassCmpOp (alias context, loc, op, c, left, right, inv-> true);
            } // We can quit without testing the other types, there is already an error in the errors vec
        } catch {
            err : &ErrorMsg => { errors ~= [err]; } // No we still fail
        }

        // there is no valid math operation for left and right
        throw copy ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_BIN_OP, op, left.getType (), right.getType ()), notes-> errors);

    }

    /**
     * Validate a binary operation involving float comparison operators (<=>, <!>)
     * @params:
     *   - context: the context of the validation
     *   - op: the operator (assuming it's a logical operator)
     *   - bin: the binary expression to validate
     * @returns: the validated value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    fn validateFloatComparisonOperation (self, dmut context : &Validator, op : BinaryOperators, bin : &BinaryExpr)-> &Value
        throws ErrorMsg
    {
        let left = context.implicitEnumUnwrap (context:.validateValue (bin.getLeft ()));
        let right = context.implicitEnumUnwrap (context:.validateValue (bin.getRight ()));

        let mut errors : [&ErrorMsg] = [];
        {
            // First we try the operation as a left side operation (asking for left operand to be the master of the operation, i.e. left.opBinary!{op} (right)
            match left.getType () {
                FloatType () => return self.validateFloatSpecialCmpOp (alias context, bin.getLoc (), op, left, right);
            };
        } catch {
            err : &ErrorMsg => { errors ~= [err]; }
        }

        throw copy ErrorMsg::fatal (bin.getLoc (), format (ValidateErrorMessage::UNDEFINED_BIN_OP, op, left.getType (), right.getType ()), notes-> errors)
    }

    /**
     * Validate a binary comparison operator, assuming that the left operand is a int
     * @params:
     *   - context: the context of the operator
     *   - loc: the location of the operator
     *   - left: the left operand (assume to be a int typed value)
     *   - right: the right operand
     * @returns: the result value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    fn validateIntCmpOp (self, dmut context : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Value)-> &Value
        throws ErrorMsg
    {
        match left.getType () {
            li : &IntType => {
                match right.getType () {
                    ri : &IntType => {
                        if (li.isSigned () == ri.isSigned ()) {
                            return copy CmpIntOperatorValue (loc, op, left, right);
                        }

                        {
                            let compatibleRight = context:.verifyCompatibleTypeWithValue (loc, li, right, byReference-> false);
                            return copy CmpIntOperatorValue (loc, op, left, compatibleRight);
                        } catch {
                            leErr : &ErrorMsg => {
                                let compatibleLeft = context:.verifyCompatibleTypeWithValue (loc, ri, left, byReference-> false);
                                return copy CmpIntOperatorValue (loc, op, compatibleLeft, right);
                            } catch {
                                riErr : &ErrorMsg => {
                                    throw copy ErrorMsg::list (copy [leErr, riErr]);
                                }
                            }
                        }
                    }
                }
            }
        }

        throw copy ErrorMsg::list ([])
    }

    /**
     * Validate a binary comparison operator, assuming left is an option value
     * @params:
     *    - context: the context of the operator
     *    - loc: the location of the operator
     *    - left: the left operand (assuming to be a option typed value)
     *    - right: the right operand
     * @returns: the result value
     * @throws:
     *    - &ErrorMsg: if the operation is not valid
     * */
    fn validateOptionCmpOp (self, dmut context : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Value)-> &Value
        throws ErrorMsg
    {
        let (lVal, rVal) = if (left.getType ().asOf!{&OptionType} ().getInners ()[0] of NoneType) {
            (context:.verifyCompatibleTypeWithValue (loc, right.getType (), left, byReference-> false), right)
        } else { (left, context:.verifyCompatibleTypeWithValue (loc, left.getType (), right, byReference-> false)) };

        let innerLType = lVal.getType ().asOf!{&OptionType} ().getInners ()[0];
        let innerRType = rVal.getType ().asOf!{&OptionType} ().getInners ()[0];

        if (innerRType of NoneType && innerLType of NoneType) {
            return copy CmpIntOperatorValue (loc, op, makeIntValue (loc, 0is), makeIntValue (loc, 0is)); // none op none
        }

        let boolType = copy BoolType (loc);
        let lSet = copy StructFieldAccessValue (loc, boolType, lVal, OptionKeys::SET);
        let rSet = copy StructFieldAccessValue (loc, boolType, rVal, OptionKeys::SET);

        let lInnerVal = copy OptionFieldAccessValue (loc, innerLType, lVal, OptionKeys::VALUE);
        let rInnerVal = copy OptionFieldAccessValue (loc, innerRType, rVal, OptionKeys::VALUE);

        let bothSet = copy LogicalBinBoolOperatorValue (loc, BinaryOperators::DAND, lSet, rSet);
        let bothSetRes = self.validateComparisonOperation (alias context, loc, op, lInnerVal, rInnerVal);

        let onlyRightSetRes = copy CmpIntOperatorValue (loc, op, makeIntValue (loc, -1is), makeIntValue (loc, 0is));
        let onlyLeftSetRes = copy CmpIntOperatorValue (loc, op, makeIntValue (loc, 1is), makeIntValue (loc, 0is));
        let noneSetRes = copy CmpIntOperatorValue (loc, op, makeIntValue (loc, 0is), makeIntValue (loc, 0is));

        let finalCond = copy ConditionalValue (loc, boolType, lSet, onlyLeftSetRes, noneSetRes);
        let preCond = copy ConditionalValue (loc, boolType, rSet, onlyRightSetRes, finalCond);

        context:.getCompileTimeInterpreter ():.reduce (copy ConditionalValue (loc, boolType, bothSet, bothSetRes, preCond))
    }

    /**
     * Validate a binary comparison operator, assuming that the left operand is a float
     * @params:
     *   - context: the context of the operator
     *   - loc: the location of the operator
     *   - left: the left operand (assume to be a float typed value)
     *   - right: the right operand
     * @returns: the result value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    fn validateFloatCmpOp (self, dmut context : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Value)-> &Value
        throws ErrorMsg
    {
        match left.getType () {
            li : &FloatType => {
                match right.getType () {
                    ri : &FloatType => {
                        if (li.getSize () == ri.getSize ()) {
                            return copy CmpFloatOperatorValue (loc, op, left, right);
                        }

                        {
                            let compatibleRight = context:.verifyCompatibleTypeWithValue (loc, li, right, byReference-> false);
                            return copy CmpFloatOperatorValue (loc, op, left, compatibleRight);
                        } catch {
                            leErr : &ErrorMsg => {
                                let compatibleLeft = context:.verifyCompatibleTypeWithValue (loc, ri, left, byReference-> false);
                                return copy CmpFloatOperatorValue (loc, op, compatibleLeft, right);
                            } catch {
                                riErr : &ErrorMsg => {
                                    throw copy ErrorMsg::list (copy [leErr, riErr]);
                                }
                            }
                        }
                    }
                }
            }
        }

        throw copy ErrorMsg::list ([]);
    }


    /**
     * Validate a binary float comparison operator (<=>, <!>), assuming that the left operand is a float
     * @params:
     *   - context: the context of the operator
     *   - loc: the location of the operator
     *   - left: the left operand (assume to be a float typed value)
     *   - right: the right operand
     * @returns: the result value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    fn validateFloatSpecialCmpOp (self, dmut context : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Value)-> &Value
        throws ErrorMsg
    {
        if (right.getType () !of FloatType) {
            throw copy ErrorMsg::list ([]);
        }

        // Create a var path to the core function core::math::float_compare
        let syntVar = context.createSyntaxVarFromPath (loc, MathUtils::FLOAT_CMP_FUNC);
        let func = context:.validateValue (syntVar);
        let call = context:.getCallOpValidator ().validate (alias context, loc, func, copy [left, right]);

        if (op == BinaryOperators::UNCONGRUENT) {
            context:.getUnOpValidator ().validateNotOperator (alias context, loc, call)
        } else {
            call
        }
    }


    /**
     * Validate a binary comparison operator, assuming that the left operand is a char
     * @params:
     *   - context: the context of the operator
     *   - loc: the location of the operator
     *   - left: the left operand (assume to be a char typed value)
     *   - right: the right operand
     * @returns: the result value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    fn validateCharCmpOp (self, dmut context : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Value)-> &Value
        throws ErrorMsg
    {
        match left.getType () {
            li : &CharType => {
                match right.getType () {
                    ri : &CharType => {
                        if (li.getSize () == ri.getSize ()) {
                            return copy CmpCharOperatorValue (loc, op, left, right);
                        }

                        {
                            let compatibleRight = context:.verifyCompatibleTypeWithValue (loc, li, right, byReference-> false);
                            return copy CmpCharOperatorValue (loc, op, left, compatibleRight);
                        } catch {
                            leErr : &ErrorMsg => {
                                let compatibleLeft = context:.verifyCompatibleTypeWithValue (loc, ri, left, byReference-> false);
                                return copy CmpCharOperatorValue (loc, op, compatibleLeft, right);
                            } catch {
                                riErr : &ErrorMsg => {
                                    throw copy ErrorMsg::list (copy [leErr, riErr]);
                                }
                            }
                        }
                    }
                }
            }
        }

        throw copy ErrorMsg::list ([]);
    }


    /**
     * Validate a binary comparison operator, assuming that the left operand is a bool
     * @params:
     *   - context: the context of the operator
     *   - loc: the location of the operator
     *   - left: the left operand (assume to be a bool typed value)
     *   - right: the right operand
     * @returns: the result value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    fn validateBoolCmpOp (self, dmut _ : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Value)-> &Value
        throws ErrorMsg
    {
        if (op == BinaryOperators::DEQUAL || op == BinaryOperators::NOT_EQUAL) {
            match left.getType () {
                BoolType () => {
                    match right.getType () {
                        BoolType () => {
                            return copy CmpBoolOperatorValue (loc, op, left, right);
                        }
                    }
                }
            }
        }

        throw copy ErrorMsg::list ([]);
    }

    /**
     * Validate a binary comparison operator, assuming that the left operand is a pointer type
     * @params:
     *   - context: the context of the operator
     *   - loc: the location of the operator
     *   - left: the left operand (assume to be a pointer type value)
     *   - right: the right operand
     * @returns: the result value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    fn validatePointerCmpOp (self, dmut context : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Value)-> &Value
        throws ErrorMsg
    {
        match left.getType () {
            li : &PointerType => {
                match right.getType () {
                    ri : &PointerType => {
                        if (li == ri) {
                            return copy CmpPointerOperatorValue (loc, op, left, right);
                        }

                        {
                            let compatibleRight = context:.verifyCompatibleTypeWithValue (loc, li, right, byReference-> false);
                            return copy CmpPointerOperatorValue (loc, op, left, compatibleRight);
                        } catch {
                            leErr : &ErrorMsg => {
                                let compatibleLeft = context:.verifyCompatibleTypeWithValue (loc, ri, left, byReference-> false);
                                return copy CmpPointerOperatorValue (loc, op, compatibleLeft, right);
                            } catch {
                                riErr : &ErrorMsg => {
                                    throw copy ErrorMsg::list (copy [leErr, riErr]);
                                }
                            }
                        }
                    }
                }
            }
        }

        throw copy ErrorMsg::list ([]);
    }

    /**
     * Validate a binary comparison operator, assuming that the left operand is a function pointer type
     * @params:
     *   - context: the context of the operator
     *   - loc: the location of the operator
     *   - left: the left operand (assume to be a function pointer value)
     *   - right: the right operand
     * @returns: the result value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     * */
    fn validateFuncPtrCmpOp (self, dmut context : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Value)-> &Value
        throws ErrorMsg
    {
        if (op == BinaryOperators::DEQUAL || op == BinaryOperators::NOT_EQUAL) {
            let li = left.getType ().asOf!{&FuncPtrType} ();
            let compatibleRight = context:.verifyCompatibleTypeWithValue (loc, li, right, byReference-> false);

            return copy CmpPointerOperatorValue (loc, op, left, compatibleRight);
        }

        throw copy ErrorMsg::list ([]);
    }

    /**
     * Validate a binary comparison operator, assuming that the left operand is a delegate pointer type
     * @params:
     *   - context: the context of the operator
     *   - loc: the location of the operator
     *   - left: the left operand (assume to be a function pointer value)
     *   - right: the right operand
     * @returns: the result value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     * */
    fn validateDGPtrCmpOp (self, dmut context : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Value)-> &Value
        throws ErrorMsg
    {
        if (op == BinaryOperators::DEQUAL || op == BinaryOperators::NOT_EQUAL) {
            let li = left.getType ().asOf!{&DelegateType} ();
            let compatibleRight = context:.verifyCompatibleTypeWithValue (loc, li, right, byReference-> false);

            let clPtr = copy PointerType (loc, copy VoidType (loc));

            let leftCl  : &Value = copy StructFieldAccessValue (loc, clPtr, left, DelegateKeys::CLOSURE);
            let rightCl : &Value = copy StructFieldAccessValue (loc, clPtr, compatibleRight, DelegateKeys::CLOSURE);

            let fptr = copy FuncPtrType (loc, li.getReferences (), li.getLazys (), li.getParameters (), li.getRetType ());
            let leftPtr  : &Value = copy StructFieldAccessValue (loc, fptr, left, DelegateKeys::FUNC);
            let rightPtr : &Value = copy StructFieldAccessValue (loc, fptr, compatibleRight, DelegateKeys::FUNC);

            let clTest = copy CmpPointerOperatorValue (loc, op, leftCl, rightCl);
            let fpTest = copy CmpPointerOperatorValue (loc, op, leftPtr, rightPtr);

            return if (op == Tokens::DEQUAL) {
                copy LogicalBinBoolOperatorValue (loc, BinaryOperators::DAND, clTest, fpTest)
            } else {
                copy LogicalBinBoolOperatorValue (loc, BinaryOperators::DPIPE, clTest, fpTest)
            };
        }

        throw copy ErrorMsg::list ([]);
    }

    /**
     * Validate a binary comparison operator, assuming that the left operand is a tuple type
     * @params:
     *   - context: the context of the operator
     *   - loc: the location of the operator
     *   - left: the left operand (assume to be a tuple type value)
     *   - right: the right operand
     * @returns: the result value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     * */
    fn validateTupleCmpOp (self, dmut context : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Value)-> &Value
        throws ErrorMsg
    {
        if (op == BinaryOperators::DEQUAL || op == BinaryOperators::NOT_EQUAL) {
        match (left.getType (), right.getType ()) {
            (l : &TupleType, r : &TupleType) => {
                if (l.getInners ().len == r.getInners ().len) {

                    let mut res : &Value = UNIT_VALUE;
                    for i in l.getInners ().len .. 0us {
                        let fieldL = self.createTupleFieldAccess (loc, l.getInners ()[i - 1us], left, i - 1us);
                        let fieldR = self.createTupleFieldAccess (loc, l.getInners ()[i - 1us], right, i - 1us);

                        let cmp = self.validateComparisonOperation (alias context, loc, op, fieldL, fieldR);
                        res = match res {
                            UnitValue () => {
                                cmp
                            }
                            old : _ => {
                                cast!{&Value} (if (op == BinaryOperators::DEQUAL) {
                                    copy LogicalBinBoolOperatorValue (loc, BinaryOperators::DAND, cmp, old)
                                } else {
                                    copy LogicalBinBoolOperatorValue (loc, BinaryOperators::DPIPE, cmp, old)
                                })
                            }
                        };
                    }
                    return res;
                }
            }
        }
        }

        throw copy ErrorMsg::list ([]);
    }

    /**
     * Validate a binary comparison operator, assuming that left operand is a range type
     * @params:
     *   - context: the context of the operator
     *   - loc: the location of the operator
     *   - left: the left operand (assume to be a range type value)
     *   - right: the right operand
     * @returns: the result value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     * */
    fn validateRangeCmpOp (self, dmut context : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Value)-> &Value
        throws ErrorMsg
    {
        if (op == BinaryOperators::DEQUAL || op == BinaryOperators::NOT_EQUAL) {
            match (left.getType (), right.getType ()) {
                (l : &RangeType, r : &RangeType) => {
                    context.verifyCompatibleType (loc, right.getLoc (), l, r);

                    let uniqL = left;
                    let uniqR = right;
                    let inType = l.getInners ()[0];
                    let stType = l.getInners ()[1];
                    let bType = copy BoolType (loc);

                    let fstL = copy ValueWrapperExpr (loc, copy StructFieldAccessValue (loc, inType, uniqL, RangeKeys::FST));
                    let fstR = copy ValueWrapperExpr (loc, copy StructFieldAccessValue (loc, inType, uniqR, RangeKeys::FST));

                    let scdL = copy ValueWrapperExpr (loc, copy StructFieldAccessValue (loc, inType, uniqL, RangeKeys::SCD));
                    let scdR = copy ValueWrapperExpr (loc, copy StructFieldAccessValue (loc, inType, uniqR, RangeKeys::SCD));

                    let stepL = copy ValueWrapperExpr (loc, copy StructFieldAccessValue (loc, stType, uniqL, RangeKeys::STEP));
                    let stepR = copy ValueWrapperExpr (loc, copy StructFieldAccessValue (loc, stType, uniqR, RangeKeys::STEP));

                    let containL = copy ValueWrapperExpr (loc, copy StructFieldAccessValue (loc, bType, uniqL, RangeKeys::CONTAINS));
                    let containR = copy ValueWrapperExpr (loc, copy StructFieldAccessValue (loc, bType, uniqR, RangeKeys::CONTAINS));

                    let fstEq = context:.validateValue (copy BinaryExpr (copy Word (BinaryOperators::DEQUAL, loc), fstL, fstR));
                    let scdEq = context:.validateValue (copy BinaryExpr (copy Word (BinaryOperators::DEQUAL, loc), scdL, scdR));
                    let stepEq = context:.validateValue (copy BinaryExpr (copy Word (BinaryOperators::DEQUAL, loc), stepL, stepR));
                    let cntEq = context:.validateValue (copy BinaryExpr (copy Word (BinaryOperators::DEQUAL, loc), containL, containR));

                    let retA = copy LogicalBinBoolOperatorValue (loc, BinaryOperators::DAND, fstEq, scdEq);
                    let retB = copy LogicalBinBoolOperatorValue (loc, BinaryOperators::DAND, stepEq, cntEq);
                    let mut ret : &Value = copy LogicalBinBoolOperatorValue (loc, BinaryOperators::DAND, retA, retB);

                    if (op == BinaryOperators::NOT_EQUAL) {
                        ret = copy UnaryBoolOperatorValue (loc, UnaryOperators::NOT, ret);
                    }

                    return ret;
                }
            }
        }

        throw copy ErrorMsg::list ([]);
    }

    /**
     * Validate the comparison operator of two slice  (it is almost the same for array and slice, so it is factorized in this function)
     * @info: This comparison is not provided by the language itself, but by core files, so this binary operator is rewritten into a syntax element
     * @example:
     * ======================
     * [1, 2, 3] < [0, 8, 0]
     * // is rewritten into => 'core::array::opCmp ([1, 2, 3], [0, 8, 0]) < 0'
     *
     * [1, 2, 3] >= [0, 8, 0]
     * // is rewritten into => 'core::array::opCmp ([1, 2, 3], [0, 8, 0]) >= 0'
     * ======================
     * @params:
     *   - context: the context of the operator
     *   - loc: the location of the operator
     *   - left: the left operand
     *   - right: the right operand
     * @returns: the result value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    fn validateSliceOrArrayCmpOp (self, dmut context : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Value)-> &Value
        throws ErrorMsg
    {
        let finLeft = match left.getType () {
            SliceType () => { left }
            a : &ArrayType => { context.createSliceAliasFromArray (loc, a, left) }
            _ => {
                throw copy ErrorMsg::list ([]);
            }
        };

        // The comparison can be made only with an element of the same type, that is to say a slice or an array
        let finRight = match right.getType () {
            SliceType () => { right }
            a : &ArrayType => { context.createSliceAliasFromArray (loc, a, right) }
            _ => {
                throw copy ErrorMsg::list ([]);
            }
        };

        let mut errors : [&ErrorMsg] = [];

        // There is another function for equality that is faster than comparison, so we call it if we can
        // And unlike class and struct, we know that this operator is defined in core files, so no need to check its existence
        if (op == BinaryOperators::DEQUAL || op == BinaryOperators::NOT_EQUAL) {
            return self.validateSliceOrArrayEqualOp (alias context, loc, op, finLeft, finRight);
        } catch {
            err : &ErrorMsg => {
                errors ~= [err];
            }
        }

        {
            // Create a var path to the core function core::array::opCmp
            let syntVar = context.createSyntaxVarFromPath (loc, SliceUtils::OP_CMP_FUNC);
            let func = context:.validateValue (syntVar);
            let valueCall = context:.getCallOpValidator ().validate (alias context, loc, func, copy [finLeft, finRight]);

            // Validate the value to get the return type
            let call = match valueCall {
                c : &CallValue => {
                    cast!{&Value} (copy SpecialArrayOperatorValue (loc, valueCall.getType (), op, c.getParameters ()[0], c.getParameters ()[1], c))
                }
                _ => { valueCall }
            };

            let casted = context:.getCastValidator ().validateCast (alias context, makeIntValue (loc, 0is), call.getType ());
            return self.validateComparisonOperation (alias context, loc, op, call, casted);
        } catch {
            err : &ErrorMsg => {
                errors ~= [err];
            }
        }

        throw copy ErrorMsg::list (errors);
    }

    /**
     * Validate the equality operator of two slice  (it is almost the same for array and slice, so it is factorized in this function)
     * @info: This comparison is not provided by the language itself, but by core files, so this binary operator is rewritten into a syntax element
     * @example:
     * ======================
     * [1, 2, 3] != [0, 8, 0]
     * // is rewritten into => '!core::array::opEquals ([1, 2, 3], [0, 8, 0])'
     *
     * [1, 2, 3] == [0, 8, 0]
     * // is rewritten into => 'core::array::opEquals ([1, 2, 3], [0, 8, 0])'
     * ======================
     * @params:
     *   - context: the context of the operator
     *   - loc: the location of the operator
     *   - left: the left operand
     *   - right: the right operand
     * @returns: the result value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */

    fn validateSliceOrArrayEqualOp (self, dmut context : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Value)-> &Value
        throws ErrorMsg
    {
        let syntVar = context.createSyntaxVarFromPath (loc, SliceUtils::OP_EQUALS_FUNC);
        let func = context:.validateValue (syntVar);

        // Validate the value to get the return type
        let valueCall = context:.getCallOpValidator ().validate (alias context, loc, func, copy [left, right]);
        let call = match valueCall {
            c : &CallValue => {
                cast!{&Value} (copy SpecialArrayOperatorValue (loc, valueCall.getType (), BinaryOperators::DEQUAL, c.getParameters ()[0], c.getParameters ()[1], c))
            }
            _ => { valueCall }
        };

        if (op == BinaryOperators::NOT_EQUAL) { // We need to inverse the equality, the operator returns '=='
            context:.getUnOpValidator ().validateNotOperator (alias context, loc, call)
        } else {
            call
        }
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================           LOGICAL            =========================
     * ================================================================================
     * ================================================================================
     */


    /**
     * Validate a binary operation involving logical operator (&&, ||)
     * @info: these operators have a meaning only on bool values
     * @params:
     *   - context: the context of the validation
     *   - op: the operator (assuming it's a logical operator)
     *   - bin: the binary expression to validate
     * @returns: the validated value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    fn validateLogicalOperation (self, dmut context : &Validator, op : BinaryOperators, bin : &BinaryExpr)-> &Value
        throws ErrorMsg
    {
        let left = context.implicitEnumUnwrap (context:.validateValue (bin.getLeft ()));
        let right = context.implicitEnumUnwrap (context:.validateValue (bin.getRight ()));

        match left.getType () {
            BoolType () => {
                match right.getType () {
                    BoolType () => {
                        return copy LogicalBinBoolOperatorValue (bin.getLoc (), op, left, right);
                    }
                }
            }
        }

        throw copy ErrorMsg::fatal (bin.getLoc (), format (ValidateErrorMessage::UNDEFINED_BIN_OP, op, left.getType (), right.getType ()));
    }


    /*!
     * ================================================================================
     * ================================================================================
     * =========================            RANGE             =========================
     * ================================================================================
     * ================================================================================
     */


    /**
     * Validate a binary operation involving a range operator
     * @params:
     *   - context: the context of the validation
     *   - op: the operator (assuming it's a range operator)
     *   - bin: the binary expression to validate
     * @returns: the validated value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    fn validateRangeOperation (self, dmut context : &Validator, op : BinaryOperators, bin : &BinaryExpr)-> &Value
        throws ErrorMsg
    {
        let left = context.implicitEnumUnwrap (context:.validateValue (bin.getLeft ()));
        let right = context.implicitEnumUnwrap (context:.validateValue (bin.getRight ()));

        let mut errors : [&ErrorMsg] = [];
        {
            match left.getType () { // First we try the operation as a left side operation (asking for left operand to be the master of the operation, i.e. left.opBinary!{op} (right)
                IntType () => return self.validateIntRangeOp (alias context, bin.getLoc (), op, left, right);
                c : &ClassPtrType => return self.validateClassRangeOpLeft (alias context, bin.getLoc (), op, c, left, right);
            };
        } catch {
            err : &ErrorMsg => { errors ~= [err]; }
        }

        { // if we are here the validation as a left operand validation failed, so we need to try it as a right operation (right.opBinaryRight!{op} (left))
            match right.getType () { // it is working only for two kind of type structs and classes
                c : &ClassPtrType => return self.validateClassRangeOpRight (alias context, bin.getLoc (), op, c, left, right);
            } // We can quit without testing the other types, there is already an error in the errors vec
        } catch {
            err : &ErrorMsg => { errors ~= [err]; } // No we still fail
        }

        throw copy ErrorMsg::fatal (bin.getLoc (), format (ValidateErrorMessage::UNDEFINED_BIN_OP, op, left.getType (), right.getType ()), notes-> errors);
    }

    /**
     * Validate a range operator assuming that the left operand is a int value
     * @params:
     *   - context: the context of the validation
     *   - loc: the location of the operation
     *   - op: the range operator
     *   - left: the left operand
     *   - right: the right operand
     * @returns: the result value
     * @throws:
     *    - &ErrorMsg: if the operation is not valid
     */
    fn validateIntRangeOp (self, dmut context : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Value)-> &Value
        throws ErrorMsg
    {
        match (left.getType (), right.getType ()) {
            (IntType (), IntType ()) => {
                // The type of the range takes the biggest of the two elements
                let (ty, lvalue, rvalue) = context:.inferTypeBranchingWithValues (loc, left, right);
                let bI = ty.asOf!{&IntType} ();

                let stepType = copy IntType (loc, signed-> true, size-> bI.getSize ()); // Step is always signed
                let type = copy RangeType (loc, bI, stepType, isMutable-> false); // Inner type is the biggest of the two operands
                let include = copy BoolValue (loc, (op == BinaryOperators::TDOT)); // include the last value depending on the operator used

                let cmp = copy CmpIntOperatorValue (loc, BinaryOperators::INF_EQUAL, lvalue, rvalue); // Range can be decreasing if scd < fst
                let condStep = copy ConditionalValue (loc, stepType, cmp,
                                                      copy IntValue (loc, stepType, 1us),
                                                      copy IntValue (loc, stepType, copy BigInt (-1))); // Then the step is set accordingly

                let step = context:.getCompileTimeInterpreter ():.reduce (condStep); // Try to get the step value as cte
                return copy RangeValue (loc, type, lvalue, rvalue, step-> step, full-> include);
            }
        }

        // Right op is not an int value
        throw copy ErrorMsg::list ([]);
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================           POINTER            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a binary operation involving a pointer operator
     * @params:
     *   - context: the context of the validation
     *   - op: the operator (assuming it's a pointer operator)
     *   - bin: the binary expression to validate
     * @returns: the validated value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    fn validatePointerOperation (self, dmut context : &Validator, op : BinaryOperators, bin : &BinaryExpr)-> &Value
        throws ErrorMsg
    {
        let left = context.implicitEnumUnwrap (context:.validateValue (bin.getLeft ()));
        let right = context.implicitEnumUnwrap (context:.validateValue (bin.getRight ()));

        let mut errors : [&ErrorMsg] = [];
        {
            match left.getType () {
                ClassPtrType () =>
                    return self.validateClassPointerOp (alias context, bin.getLoc (), op, left, right);
            };
        } catch {
            err : &ErrorMsg => {
                errors ~= [err];
            }
        }

        throw copy ErrorMsg::fatal (bin.getLoc (), format (ValidateErrorMessage::UNDEFINED_BIN_OP, op, left.getType (), right.getType ()), notes-> errors);
    }

    /**
     * Validate a pointer operator (is and !is) assuming that the left operand is a class value
     * @params:
     *   - context: the context of the validation
     *   - loc: the location of the operation
     *   - op: the operator
     *   - left: the left operand
     *   - right: the right operand
     * @returns: the result value
     * @throws:
     *    - &ErrorMsg: if the operation is not valid
     */
    fn validateClassPointerOp (self, dmut context : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Value)-> &Value
        throws ErrorMsg
    {
        match left.getType () {
            lp : &ClassPtrType => {
                match right.getType () {
                    rp : &ClassPtrType => {
                        // a is b == b is a, so if &B over &A, the order should not have any impact on the test
                        // Thus we perform a type branching test, instead of a compatibility test, meaning we are not trying to move 'a -> b', neither 'b -> a'
                        // but, 'cast!CommonAncestor (a, b) (a) is cast!CommonAncestor (a, b) (b)'

                        let common = context.inferTypeBranching (left.getLoc (), right.getLoc (), lp, rp);

                        let lvalue = if (common == lp) { left } else { copy CastValue (left.getLoc (), common, left, isLvalue-> false) };
                        let rvalue = if (common == rp) { right } else { copy CastValue (right.getLoc (), common, right, isLvalue-> false) };

                        // We are using a pointer cmp, because classptr are basically just pointers, and the result is just a bool, so there is no need to be much specific here
                        return copy CmpPointerOperatorValue (loc, op, lvalue, rvalue);
                    }
                }
            }
        }

        throw copy ErrorMsg::list ([]);
    }


    /*!
     * ================================================================================
     * ================================================================================
     * =========================             SET              =========================
     * ================================================================================
     * ================================================================================
     */


    /**
     * Validate a binary operation involving a set operator
     * @params:
     *   - context: the context of the validation
     *   - op: the operator (assuming it's a set operator)
     *   - bin: the binary expression to validate
     * @returns: the validated value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    fn validateSetOperation (self, dmut context : &Validator, op : BinaryOperators, bin : &BinaryExpr)-> &Value
        throws ErrorMsg
    {
        if (op == BinaryOperators::NOT_IN || op == BinaryOperators::IN) {
            return self.validateContainOperation (alias context, op, bin);
        } else {
            return self.validateConcatOperation (alias context, op, bin);
        }
    }

    /**
     * Validate a contain operation (in or !in)
     * @params:
     *   - context: the context of the validation
     *   - op: the operator (assuming it's a set operator)
     *   - bin: the binary expression to validate
     * @returns: the validated value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    fn validateContainOperation (self, dmut context : &Validator, op : BinaryOperators, bin : &BinaryExpr)-> &Value
        throws ErrorMsg
    {
        let right = context.implicitEnumUnwrap (context:.validateValue (bin.getRight ()));
        let mut errors : [&ErrorMsg] = [];
        {
            match right.getType () {
                c : &ClassPtrType => {
                    return self.validateClassContainOp (alias context, op, c, bin, right);
                }
                SliceType () => { return self.validateSliceOrArrayContainOp (alias context, op, bin, right); }
                m : &MapType => { return self.validateMapContainOp (alias context, op, m, bin, right); }
                a : &ArrayType => {
                    return self.validateSliceOrArrayContainOp (alias context, op, bin, context.createSliceAliasFromArray (bin.getLoc (), a, right));
                }
                RangeType () => { return self.validateRangeContainOp (alias context, op, bin, right); }
                // Other types (native, or stuff like that) cannot override the opContains
            }
        } catch {
            err : &ErrorMsg => {
                errors ~= [err];
            }
        }

        let left = context:.validateValue (bin.getLeft ());
        throw copy ErrorMsg::fatal (bin.getLoc (), format (ValidateErrorMessage::UNDEFINED_BIN_OP, op, left.getType (), right.getType ()), notes-> errors);
    }

    /**
     * Validate a contain operation (in or !in) for a class type value as right operand
     * @params:
     *   - context: the context of the validation
     *   - op: the operator (assuming it's a set operator)
     *   - bin: the binary expression to validate
     *   - right: the right operand
     * @returns: the validated value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    fn validateClassContainOp (self, dmut context : &Validator, op : BinaryOperators, cptr : &ClassPtrType, bin : &BinaryExpr, right : &Value)-> &Value
        throws ErrorMsg
    {
        let leftOperand = context:.validateValue (bin.getLeft ());
        let meth = context:.constructObjectMethodAcc (bin.getLoc (), cptr, right, OpOverrideNames::CONTAINS);
        let call = context:.getCallOpValidator ().validate (alias context, bin.getLoc (), meth, copy [leftOperand]);

        if (op == BinaryOperators::NOT_IN) { // !in is rewritten into '!(right.opContains (left))'
            context:.getUnOpValidator ().validateNotOperator (alias context, bin.getLoc (), call)
        } else {
            call
        }
    }

    /**
     * Validate a contain operation (in or !in) for a slice or array type value as right operand
     * @params:
     *   - context: the context of the validation
     *   - op: the operator (assuming it's a set operator)
     *   - bin: the binary expression to validate
     *   - right: the right operand
     * @returns: the validated value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    fn validateSliceOrArrayContainOp (self, dmut context : &Validator, op : BinaryOperators, bin : &BinaryExpr, right : &Value)-> &Value
        throws ErrorMsg
    {
        let left = context:.validateValue (bin.getLeft ());
        let slcInnerType = right.getType ().asOf!{&SliceType} ().getInners ()[0];
        let key = context:.verifyCompatibleTypeWithValue (bin.getLoc (), slcInnerType, left, byReference-> false);

        // Create the var path to the core function core::array::opContains
        let syntVar = context.createSyntaxVarFromPath (bin.getLoc (), SliceUtils::OP_CONTAINS_FUNC);
        let func = context:.validateValue (syntVar);
        let call = context:.getCallOpValidator ().validate (alias context, bin.getLoc (), func, copy [right, key]);

        if (op == BinaryOperators::NOT_IN) { // !in is rewritten into '!(opContains (right, left))'
            context:.getUnOpValidator ().validateNotOperator (alias context, bin.getLoc (), call)
        } else {
            call
        }
    }

    /**
     * Validate a contain operation (in or !in) for a map type value as right operand
     * @params:
     *    - context: the context of the validation
     *    - op: the operator (assuming it's a set operator)
     *    - m: the map type of the right operand
     *    - bin: the binary expression to validate
     *    - right: the right operand
     * @returns: the validate value
     * @throws:
     *    - &ErrorMsg: if the operation is not valid
     * */
    fn validateMapContainOp (self, dmut context : &Validator, op : BinaryOperators, m : &MapType, bin : &BinaryExpr, right : &Value)-> &Value
        throws ErrorMsg
    {
        let left = context:.validateValue (bin.getLeft ());
        let keyType = m.getInners () [0];
        let key = context:.verifyCompatibleTypeWithValue (bin.getLoc (), keyType, left, byReference-> false);

        copy MapContainValue (bin.getLoc (), copy BoolType (bin.getLoc ()), right, key, not-> (op == BinaryOperators::NOT_IN))
    }

    /**
     * Validate a contain operation (in or !in) for a range value as right operand
     * @params:
     *     - context: the context of the operation
     *     - op: the operator (assuming it's a set operator)
     *     - bin: the binary expression to validate
     *     - right: the right operand (already validated)
     * @returns: the validated value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     * */
    fn validateRangeContainOp (self, dmut context : &Validator, op : BinaryOperators, bin : &BinaryExpr, right : &Value)-> &Value
        throws ErrorMsg
    {
        let left = context:.validateValue (bin.getLeft ());
        self.validateRangeContainOp (alias context, bin.getLoc (), op, left, right)
    }

    /**
     * Validate a contain operation (in or !in) for a range value as right operand
     * @params:
     *     - context: the context of the operation
     *     - op: the operator (assuming it's a set operator)
     *     - left: the left operand
     *     - right: the right operand
     * @returns: the validated value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     * */
    pub fn validateRangeContainOp (self, dmut context : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Value)-> &Value
        throws ErrorMsg
    {
        let rngInnerType = right.getType ().asOf!{&RangeType} ().getInners ()[0];
        let key = context:.verifyCompatibleTypeWithValue (loc, rngInnerType, left, byReference-> false);

        let syntVar = context.createSyntaxVarFromPath (loc, RangeUtils::OP_CONTAINS_FUNC);
        let func = context:.validateValue (syntVar);
        let call = context:.getCallOpValidator ().validate (alias context, loc, func, copy [right, key]);

        let res = if (op == BinaryOperators::NOT_IN) { // !in is rewritten into '!(opContains (right, left))'
            context:.getUnOpValidator ().validateNotOperator (alias context, loc, call)
        } else {
            call
        };

        copy RangeContainValue (loc, res.getType (), op, key, right, res)
    }

    /**
     * Validate a contain operation (in or !in) for a struct typed value as right operand
     * @params:
     *   - context: the context of the validation
     *   - op: the operator (assuming it's a set operator)
     *   - bin: the binary expression to validate
     *   - right: the right operand
     * @returns: the validated value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    fn validateStructContainOp (self, dmut context : &Validator, op : BinaryOperators, bin : &BinaryExpr, right : &Value)-> &Value
        throws ErrorMsg
    {
        let left = context:.validateValue (bin.getLeft ());

        let syntVar = copy VarExpr (copy Word (OpOverrideNames::CONTAINS, bin.getLoc ()));
        let func = context:.validateValue (syntVar);
        let call = context:.getCallOpValidator ().validate (alias context, bin.getLoc (), func, copy [right, left]);

        let res = if (op == BinaryOperators::NOT_IN) { // !in is rewritten into '!(opContains (right, left))'
            context:.getUnOpValidator ().validateNotOperator (alias context, bin.getLoc (), call)
        } else {
            call
        };

        res
    }

    /**
     * Validate a concatenation operation (~)
     * @params:
     *   - context: the context of the validation
     *   - op: the operator (assuming it's a set operator)
     *   - bin: the binary expression to validate
     * @returns: the validated value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    fn validateConcatOperation (self, dmut context : &Validator, op : BinaryOperators, bin : &BinaryExpr)-> &Value
        throws ErrorMsg
    {
        let mut left = context.implicitEnumUnwrap (context:.validateValue (bin.getLeft ()));
        let mut right = context.implicitEnumUnwrap (context:.validateValue (bin.getRight ()));

        self.validateConcatOperation (alias context, bin.getLoc (), op, left, right)
    }


    /**
     * Validate a concatenation operation (~)
     * @params:
     *   - context: the context of the validation
     *   - loc: the location of the operation
     *   - op: the operator (assuming it's a set operator)
     *   - left: the left operand
     *   - right: the right operand
     * @returns: the validated value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    pub fn validateConcatOperation (self, dmut context : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Value)-> &Value
        throws ErrorMsg
    {
        let mut errors : [&ErrorMsg] = [];
        {
            match left.getType () { // We first try to validate the operation as a left operation
                c : &ClassPtrType => { return self.validateClassOpLeft (alias context, loc, op, c, left, right); }
                SliceType () => { return self.validateSliceOrArrayConcatOp (alias context, loc, op, left, right); }
                ArrayType () => { return self.validateArrayConcatOp (alias context, loc, op, left, right); }
            };
        } catch {
            err : &ErrorMsg => {
                errors ~= [err];
            }
        }

        { // The concat operator works as a math operator for class and structs (opBinary!{"~"} (left, right))
            match right.getType () { // Now we try to validate the operation as a right operation (opBinaryRight!{"~"}(right, left))
                c : &ClassPtrType => { return self.validateClassOpRight (alias context, loc, op, c, left, right); }
            };
            // If the right operand is not a class nor struct, we don't add any error because there is already an error for the 'as left' operation
        } catch {
            err : &ErrorMsg => {
                errors ~= [err];
            }
        }

        throw copy ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_BIN_OP, op, left.getType (), right.getType ()), notes-> errors);
    }

    /**
     * Validate a concatenation operation (~), where the left operand is an array
     * @params:
     *     - context: the context of the validation
     *     - loc: the location of the operation
     *     - op: the operator
     *     - left: the left operand (with an array type)
     *     - right: the right operand
     *  @returns: the validated value
     *  @throws:
     *     - &ErrorMsg: if the operation is not valid
     * */
    fn validateArrayConcatOp (self, dmut context : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Value)-> &Value
        throws ErrorMsg
    {
        match right.getType () {
            SliceType () => { return self.validateSliceOrArrayConcatOp (alias context, loc, op, left, right); }
            ArrayType () => {}
            _ => {
                throw copy ErrorMsg::list ([]);
            }
        }

        let uniqL = left;
        let uniqR = right;

        let leArrType = left.getType ().asOf!{&ArrayType} ();
        let riArrType = right.getType ().asOf!{&ArrayType} ();

        context.verifyCompatibleType (left.getLoc (), right.getLoc (), leArrType.getInners ()[0], riArrType.getInners ()[0]);

        let mut inner : &Type = copy NoneType (loc);
        let mut finParams : [&Value] = [];
        for it in 0us .. leArrType.getLen () {
            let val = context:.getIndexOpValidator ().createArrayAccess (loc, leArrType.getInners ()[0], uniqL, makeIntValue (loc, it));
            inner = context:.getLiteralValidator ().addArrayType (alias context, val, ref finParams, inner);
        }

        for it in 0us .. riArrType.getLen () {
            let val = context:.getIndexOpValidator ().createArrayAccess (loc, leArrType.getInners ()[0], uniqR, makeIntValue (loc, it));
            inner = context:.getLiteralValidator ().addArrayType (alias context, val, ref finParams, inner);
        }

        // Concatenation of two void arrays
        if (finParams.len == 0us) inner = copy VoidType (loc);

        let arrType = copy ArrayType (loc, inner, finParams.len, isMutable-> true);
        copy ArrayValue (loc, arrType, finParams)
    }

    /**
     * Validate a concatenation operation (~), where left operand is a slice
     * @params:
     *   - context: the context of the validation
     *   - loc: the location of the operation
     *   - op: the operator (assuming it's a set operator)
     *   - left: the left operand of the operation
     *   - right: the right operand of the operation
     * @returns: the validated value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    fn validateSliceOrArrayConcatOp (self, dmut context : &Validator, loc : &Word, _ : BinaryOperators, left : &Value, right : &Value)-> &Value
        throws ErrorMsg
    {
        // Slice and arrays are almost the same type, (slice being pointer to arrays), but we first need to transform the arrays into slices
        // The left element has to be a slice or an array
        let finLeft = match left.getType () {
            SliceType () => { left }
            a : &ArrayType => {
                context.createSliceAliasFromArray (loc, a, left)
            }
            _ => { throw copy ErrorMsg::list ([]); }
        };

        // The concatenation can be made only with an element of the same type, that is to say a slice or an array
        let finRight = match right.getType () {
            SliceType () => { right }
            a : &ArrayType => {
                context.createSliceAliasFromArray (loc, a, right)
            }
            _ => { throw copy ErrorMsg::list ([]); }
        };

        context.verifyCompatibleType (finLeft.getLoc (), finRight.getLoc (), finLeft.getType (), finRight.getType ()); // Evidently the concat is made only with slices of the same kind
        let mut retType = if (finLeft.getType ().mutabilityFit (finRight.getType ())) { // the mutability of the result is the same mutability as the type with the lowest mutability level
            finRight.getType ()
        } else {
            finLeft.getType ()
        };

        // If the type of left or right operands is const, we still can modify
        // the inner values, without modifying the inner borrowed datas
        if (!retType.asOf!{&SliceType} ().getInners ()[0].isMutable ()) {
            retType = retType.clone (2u32);
        }

        copy SliceConcatValue (loc, retType, finLeft, finRight)
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================             TYPE             =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a binary operation involving a type operator
     * @params:
     *   - context: the context of the validation
     *   - op: the operator (assuming it's a type operator)
     *   - bin: the binary expression to validate
     * @returns: the validated value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    fn validateTypeOperation (self, dmut context : &Validator, op : BinaryOperators, bin : &BinaryExpr)-> &Value
        throws ErrorMsg
    {
        let left = context.implicitEnumUnwrap (context:.validateValue (bin.getLeft ()));
        let right = context:.validateType (bin.getRight ());

        let mut errors : [&ErrorMsg] = [];
        {
            match left.getType () {
                ClassPtrType () =>
                    return self.validateClassTypeTestOp (alias context, bin.getLoc (), op, left, right, candidate-> false);
            };
        } catch {
            err : &ErrorMsg => {
                errors ~= [err];
            }
        }

        throw copy ErrorMsg::fatal (bin.getLoc (), format (ValidateErrorMessage::UNDEFINED_BIN_OP, op, left.getType ()), notes-> errors);
    }

    /**
     * Validate a type test operator (of and !of) assuming the left operand is a class value
     * @params:
     *    - context: the context of the validation
     *    - loc: the location of the operation
     *    - op: the operator
     *    - left: the left operand
     *    - right: the right operand
     * @returns: the result value of type bool
     * @throws:
     *     - &ErrorMsg: if the operation is not valid
     * */
    pub fn validateClassTypeTestOp (self, dmut context : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Type, candidate : bool = true)-> &Value
        throws ErrorMsg
    {
        let clRef = left.getType ().asOf!{&ClassPtrType} ().getInner ();
        match right {
            rp : &ClassRefType => {
                if (clRef.isCompatible (rp)) { // typeof (left) == right
                    return copy BoolValue (loc, op == BinaryOperators::OF);
                } else if (context.isAncestor (rp, clRef)) { // typeof (left) over right, so /left/ is of /right/
                    return copy BoolValue (loc, op == BinaryOperators::OF);
                } else if (context.isAncestor (clRef, rp)) { // right over typeof (left), so /left/ can contain an instance of /right/
                    return copy CmpClassTypeOperatorValue (loc, op, left, rp);
                }
            }
        }

        if (candidate) {
            throw copy ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_BIN_OP, op, left.getType ()));
        } else {
            throw copy ErrorMsg::list ([]);
        }
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================            FIELD             =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a binary operation involving a field operator
     * @params:
     *   - context: the context of the validation
     *   - op: the operator (assuming it's a field operator)
     *   - bin: the binary expression to validate
     * @returns: the validated value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    fn validateFieldOperation (self, dmut context : &Validator, op : BinaryOperators, bin : &BinaryExpr)-> &Value
        throws ErrorMsg
    {
        let left = if (op == BinaryOperators::DOT_AND) {
            context:.getValueValidator ().validateAlias (alias context, bin.getLoc (), bin.getLeft (), isClass-> true, isField-> true)
        } else {
            context.implicitEnumUnwrap (context:.validateValue (bin.getLeft ()))
        };

        self.validateFieldOperation (alias context, bin.getLoc (), op, left, bin.getRight (), inCall-> context.isInCall (bin))
    }


    /**
     * Validate a field operation
     * @params:
     *    - context: the context of the validation
     *    - loc: the location of the access
     *    - op: the operator
     *    - left: the left operand
     *    - right: the field being accessed
     * @returns: the validated value
     * @throws:
     *    - &ErrorMsg: if the operation is not valid
     * */
    pub fn validateFieldOperation (self, dmut context : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Expression, inCall : bool)-> &Value
        throws ErrorMsg
    {
        match left.getType () {
            cptr : &ClassPtrType => {
                return self.validateClassFieldVtableOperation (alias context, loc, cptr, left, right, inCall);
            }
            tuple : &TupleType => {
                return self.validateTupleFieldOperation (alias context, loc, op, tuple, left, right);
            }
            range : &RangeType => {
                return self.validateRangeFieldOperation (alias context, loc, op, range, left, right);
            }
            sl : &SliceType => {
                return self.validateSliceFieldOperation (alias context, loc, op, sl, left, right);
            }
            arr : &ArrayType => {
                return self.validateArrayFieldOperation (alias context, loc, op, arr, left, right);
            }
            o : &OptionType => {
                return self.validateOptionFieldOperation (alias context, loc, op, o, left, right);
            }
            m : &MapType => {
                return self.validateMapFieldOperation (alias context, loc, op, m, left, right);
            }
            f : &FutureType => {
                return self.validateFutureFieldOperation (alias context, loc, op, f, left, right);
            }
        }

        throw copy ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_BIN_OP, op, left.getType (), right));
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================      CLASS FIELD VTABLE      =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a field or vtable access operation on a class instance value
     * @params:
     *    - context: the context of the validation
     *    - op: the operator
     *    - left: the instance value
     *    - right: the right operand
     */
    fn validateClassFieldVtableOperation (self, dmut context : &Validator, loc : &Word, cptr : &ClassPtrType, left : &Value, right : &Expression, assign : bool = false, inCall : bool)-> &Value
        throws ErrorMsg
    {
        if !cptr.getInner ().hasTypeInfo () {
            if let dmut sym : &ClassSymbol = context:.getClassFromRef (cptr.getInner ().getSymbol ()) {
                context:.getClassValidator ():.validateClassLayout (alias context, alias sym);
            } else panic;
        }

        let (inPrv, inProt) = context.getCurrentClassContextProtections (cptr.getInner ());

        // ====================================================================================================
        // =====================================          FIELD          ======================================
        // ====================================================================================================

        // Field have the priority
        let fieldResult = self.validateClassFieldAccess (alias context, loc, left, right, cptr.getInner (), inProt, inPrv)?;
        if let Ok (fieldAcc) = fieldResult {
            return fieldAcc;
        }

        let dmut notes : [&ErrorMsg] = [];
        let dmut startNotes : [&ErrorMsg] = [];

        // ====================================================================================================
        // =====================================          VTABLE          =====================================
        // ====================================================================================================

        // No field, maybe a method
        {
            // access to the method in vtable, using normal access (inCall -> methods, !inCall && !assign-> @field[access], !inCall && assign-> @field[assigns]), warning: (assign && inCall) has no meaning
            let fstVtAcc = self.validateClassVtableAccess (alias context, loc, left, right, cptr.getInner (), isProxy-> context.isSuperProxy (left), inProt, inPrv, assign-> (assign && !inCall), inCall-> inCall)?;
            if let Ok (vtableAcc) = fstVtAcc {
                return vtableAcc;
            }

            if let Err (err : &ErrorMsg) = fstVtAcc { // we sort out the errors, to put forward vtable, before field methods
                if inCall { startNotes ~= [err]; }
                else { notes ~= [err]; }
            }

            // Failure, no methods has the correct name
            if inCall && !assign { // but maybe a field access does even inside an inCall (e.g. '@field fn foo (self)-> (dg (i32)-> void)', can be called with 'f.foo (12)');
                let scdVtAcc = self.validateClassVtableAccess (alias context, loc, left, right, cptr.getInner (), isProxy-> context.isSuperProxy (left), inProt, inPrv, assign-> false, inCall-> false)?;
                if let Ok (vtableAcc) = fstVtAcc {
                    return vtableAcc;
                }

                if let Err (err : &ErrorMsg) = scdVtAcc { notes ~= [err]; }
            }
        }

        // No method, maybe a basic field, such as __super, __typeinfo, etc.
        if let Ok (basicAcc) = self.validateClassBasicFieldAccess (alias context, left, right, cptr) {
            return basicAcc;
        }

        // ====================================================================================================
        // =====================================          ERRORS          =====================================
        // ====================================================================================================

        {
            // no luck, last try but this time only to have a better error message
            if !inCall {
                // If we are not in call, maybe something went wrong earlier and inCall was meant
                // method access outside call are incomplete, we can already print that error
                let fstVtAcc = self.validateClassVtableAccess (alias context, loc, left, right, cptr.getInner (), isProxy-> context.isSuperProxy (left), inProt, inPrv, assign-> false, inCall-> true)?;
                if let Ok (vtableAcc) = fstVtAcc {
                    if let m : &MultSymValue = vtableAcc {
                        for v in m.getValues () if let mt : &MethodDelegateValue = v {
                            startNotes ~= [copy ErrorMsg::fatal (loc, format (ValidateErrorMessage::IMPLICIT_ADDRESS_METHOD, mt, tags-> FormatTags (withParams-> true)),
                                                                 notes-> copy [copy ErrorMsg::note (loc, format (ValidateErrorMessage::FORGET_PAR_PROTO_CALL, "()"), oneLine-> true),
                                                                               copy ErrorMsg::note (loc, format (ValidateErrorMessage::FORGET_AND_PROTO), oneLine-> true)])];
                        }
                    } else if let mt : &MethodDelegateValue = vtableAcc {
                        startNotes ~= [copy ErrorMsg::fatal (loc, format (ValidateErrorMessage::IMPLICIT_ADDRESS_METHOD, mt, tags-> FormatTags (withParams-> true)),
                                                             notes-> copy [copy ErrorMsg::note (loc, format (ValidateErrorMessage::FORGET_PAR_PROTO_CALL, "()"), oneLine-> true),
                                                                           copy ErrorMsg::note (loc, format (ValidateErrorMessage::FORGET_AND_PROTO), oneLine-> true)])];
                    }
                }

                if let Err (err : &ErrorMsg) = fstVtAcc { startNotes ~= [err]; }
            }

            else {
                // Check for field access, even not applicable printing the error message can be useful
                if let Ok (vtableAcc) = self.validateClassVtableAccess (alias context, loc, left, right, cptr.getInner (), isProxy-> context.isSuperProxy (left), inProt, inPrv, assign-> false, inCall-> false, forceCall-> false)? {
                    if let m : &MultSymValue = vtableAcc {
                        for v in m.getValues () if let mt : &MethodDelegateValue = v {
                            notes ~= [copy ErrorMsg::note (mt.getPrototype ().getLoc (), format (ValidateErrorMessage::FIELD_METHOD_ACCESS_NOT_APPLICABLE, mt, tags-> FormatTags (withParams-> true)), oneLine-> true)];
                        }
                    } else if let mt : &MethodDelegateValue = vtableAcc {
                        notes ~= [copy ErrorMsg::note (mt.getPrototype ().getLoc (), format (ValidateErrorMessage::FIELD_METHOD_ACCESS_NOT_APPLICABLE, mt, tags-> FormatTags (withParams-> true)), oneLine-> true)];
                    }
                }
            }

            // Check for field assign, even not applicable printing the error message can be useful
            if let Ok (vtableAcc) = self.validateClassVtableAccess (alias context, loc, left, right, cptr.getInner (), isProxy-> context.isSuperProxy (left), inProt, inPrv, assign-> true, inCall-> false)? {
                if let m : &MultSymValue = vtableAcc {
                    for v in m.getValues () if let mt : &MethodDelegateValue = v {
                        notes ~= [copy ErrorMsg::note (mt.getPrototype ().getLoc (), format (ValidateErrorMessage::FIELD_METHOD_ASSIGN_NOT_APPLICABLE, mt, tags-> FormatTags (withParams-> true)), oneLine-> true)];
                    }
                } else if let mt : &MethodDelegateValue = vtableAcc {
                    notes ~= [copy ErrorMsg::note (mt.getPrototype ().getLoc (), format (ValidateErrorMessage::FIELD_METHOD_ASSIGN_NOT_APPLICABLE, mt, tags-> FormatTags (withParams-> true)), oneLine-> true)];
                }
            }
        }

        // ====================================================================================================
        // =============================          FINALIZATION OF ERROR          ==============================
        // ====================================================================================================

        if let Err (msg : &ErrorMsg) = fieldResult {
            throw msg.withNote (startNotes ~ notes);
        }

        // class field access throws an error, or return something, we cannot reach this point
        panic;
    }

    /**
     * Validate a field access operation on a class instance value
     * @params:
     *    - context: the context of the validation
     *    - left: the instance of the class
     *    - right: the field to access
     *    - clRef: the type of the class
     *    - inProt: true iif current context has access to protected fields
     *    - inPrv: true iif current context has access to private fields
     */
    pub fn validateClassFieldAccess (self, dmut context : &Validator, loc : &Word, left : &Value, right : &Expression, clRef : &ClassRefType, inProt : bool, inPrv : bool, verifyValidation : bool = true, withAncestor : bool = true)-> &Value
        throws ErrorMsg
    {
        if !clRef.hasTypeInfo () {
            if let dmut sym : &ClassSymbol = context:.getClassFromRef (clRef.getSymbol ()) {
                context:.getClassValidator ():.validateClassLayout (alias context, alias sym);
            } else panic;
        }

        match right {
            field : &VarExpr => { // Only work with varexpr
                for v in clRef.getLocalFields () {
                    if (v.getLoc ().str == field.getLoc ().str) {
                        if (clRef.getSymbol ().isFieldPrivate (field.getLoc ().str) && !inPrv) { // The field exists but is private, and we don't have access to private fields (outside class, or ancestor)
                            throw copy ErrorMsg::fatal (right.getLoc (), format (DeclareErrorMessage::PRIVATE_IN_THIS_CONTEXT, right.getLoc ().str),
                                                        notes-> copy [copy ErrorMsg::note (v.getLoc (), ValidateErrorMessage::DECLARED_HERE)]);
                        } else if (clRef.getSymbol ().isFieldProtected (field.getLoc ().str) && !inPrv && !inProt) { // The field exists but we are outside the class definition
                            throw copy ErrorMsg::fatal (right.getLoc (), format (DeclareErrorMessage::PRIVATE_IN_THIS_CONTEXT, right.getLoc ().str),
                                                        notes-> copy [copy ErrorMsg::note (v.getLoc (), ValidateErrorMessage::DECLARED_HERE)]);
                        }

                        if (verifyValidation) { // Verify that the field is initialized and ready to be used (for pre constructor context)
                            if (context.isInFieldConstruction () && context.getFieldConstructionType () == clRef) { // it is a local field of the class being constructed
                                let isSelf = match left {
                                    zself : &VarRefValue => { zself.isSelf () }
                                    _ => { false }
                                };

                                if (isSelf && field.getLoc ().str !in context.getFieldValidated ()) { // And the field is not init yet on self
                                    throw copy ErrorMsg::fatal (right.getLoc (), format (ValidateErrorMessage::CLASS_FIELD_NOT_INIT_YET, right.getLoc ().str),
                                                                notes-> copy [copy ErrorMsg::note (v.getLoc (), ValidateErrorMessage::DECLARED_HERE)]);
                                }
                            }
                        }

                        if v.getVarType () of ErrorType {
                            throw copy ErrorMsg::fatal (right.getLoc (), format (ValidateErrorMessage::CLASS_FIELD_NOT_VALIDATED_YET, right.getLoc ().str),
                                                        notes-> copy [copy ErrorMsg::note (v.getLoc (), ValidateErrorMessage::FORWARD_REFERENCE_TYPE)]);
                        }

                        // If the class is immutable, the field cannot be mutable
                        let type = if (left.getType ().isDeeplyMutable ()) { v.getVarType () } else { v.getVarType ().clone (0u32) };

                        if (left of ClassAliaserValue) {
                            throw copy ErrorMsg::fatal (loc, end-> right.getLoc (), format (ValidateErrorMessage::CLASS_ALIAS_FIELD));
                        }

                        // The field is public in this context, we return the access
                        if (clRef.getSymbol ().isStruct ()) {
                            return copy StructFieldAccessValue (right.getLoc (), type, left, field.getLoc ().str);
                        } else {
                            return copy ClassFieldAccessValue (right.getLoc (), type, left, field.getLoc ().str);
                        }
                    }
                }

                if (withAncestor) {
                    match clRef.getAncestor () {
                        Ok (ancRef) => { // Maybe the field is a field of an ancestor
                            return self.validateClassFieldAccess (alias context, loc, left, right, ancRef, inProt || inPrv, false);
                        }
                    }
                }
            }
        };


        throw copy ErrorMsg::fatal (right.getLoc (), format (ValidateErrorMessage::CLASS_NO_FIELD, left.getType (), right));
    }

    /**
     * Validate a vtable access operation on a class instance value
     * @params:
     *     - context: the context of the validation
     *     - left: the instance of the class
     *     - right: the field to access
     *     - clRef: the type of the class
     *     - inProt: true iif current context has access to protected vtable
     *     - inPrv: true iif current context has access to private vtable
     *     - allowImmut: true iif an alias can be used to access a const method
     */
    pub fn validateClassVtableAccess (self, dmut context : &Validator, loc : &Word, left : &Value, right : &Expression, clRef : &ClassRefType, isProxy : bool, inProt : bool, inPrv : bool, allowImmut : bool = false, assign : bool = false, inCall : bool = false, forceCall : bool = true)-> &Value
        throws ErrorMsg
    {
        let mut errors : [&ErrorMsg] = [];
        let mut values : [&Value] = [];

        if inCall {
            self.validateMethodClassAccess (alias context, left, right, clRef, isProxy, inProt, inPrv, ref values, ref errors, allowImmut);
            self.validateTemplateMethodClassAccess (alias context, left, right, clRef, inProt, inPrv, ref values, ref errors, allowImmut);
        } else {
            self.validateMethodFieldClassAccess (alias context, loc, left, right, clRef, isProxy, inProt, inPrv, ref values, ref errors, assign);
        }

        if (values.len == 0us) {
            if (errors.len != 0us) throw copy ErrorMsg::list (errors);
            if inCall {
                throw copy ErrorMsg::note (right.getLoc (), format (ValidateErrorMessage::CLASS_NO_METHOD, left.getType (), right), oneLine-> true);
            } else if !assign {
                throw copy ErrorMsg::note (right.getLoc (), format (ValidateErrorMessage::CLASS_NO_FIELD_ACCESS_METHOD, left.getType (), right), oneLine-> true);
            } else {
                throw copy ErrorMsg::note (right.getLoc (), format (ValidateErrorMessage::CLASS_NO_FIELD_ASSIGN_METHOD, left.getType (), right), oneLine-> true);
            }
        }

        if !inCall && !assign && forceCall {
            let dmut ret = copy MultSymValue (right.getLoc (), values);
            return context:.getCallOpValidator ().validate (alias context, right.getLoc (), ret, []);
        }

        else if (values.len == 1us) {
            return values [0us];
        }

        return copy MultSymValue (right.getLoc (), values, prettyStr-> format ("%", right));
    }

    /**
     * Basic fields are fields that are inside the object instance, but are not user defined (i.e. __typeinfo__, __typeid__, __monitor__)
     * @params:
     *     - context: the context of the validation
     *     - left: the object value
     *     - right: the field accessed
     * @returns: UnitValue if the access is wrong, a value otherwise
     * */
    fn validateClassBasicFieldAccess (self, dmut context : &Validator, left : &Value, right : &Expression, cptr : &ClassPtrType)-> (&Value)?
        throws ErrorMsg
    {
        let clRef = cptr.getInner ();
        match right {
            v : &VarExpr => {
                let indent = context:.getSubTypeValidator ().removeUnders (v.getLoc ().str);
                if (indent == Keys::TYPEINFO) {
                    if (cptr.isStruct ()) {
                        return (context:.getTypeInfoValidator ().validate (alias context, left.getLoc (), cptr))?;
                    } else {
                        let typeinfoT = clRef.getTypeInfo ().asOf!{&Value} ().getType ();
                        return (copy ClassTypeInfoAccessValue (v.getLoc (), typeinfoT, str-> left))?;
                    }
                }

                if (indent == Keys::TYPEID) {
                    if (cptr.isStruct ()) {
                        let content = format ("%", cptr);
                        return (makeStringSliceValue (left.getLoc (), content))?;
                    } else {
                        let typeinfoV = clRef.getTypeInfo ().asOf!{&TypeInfoValue} ();
                        let nameT = typeinfoV.getName ().getType ();

                        let typeinfo = copy ClassTypeInfoAccessValue (v.getLoc (), typeinfoV.getType (), str-> left);
                        return (copy StructFieldAccessValue (v.getLoc (), nameT, typeinfo, TypeInfoKeys::NAME))?;
                    }
                }

                if (indent == Keys::SUPER && !cptr.isStruct ()) {
                    if (!context.isSelf (left)) throw copy ErrorMsg::fatal (v.getLoc (), end-> left.getLoc (), format (ValidateErrorMessage::SUPER_NO_SELF_CLASS, cptr));
                    match clRef.getAncestor () {
                        Ok (c) => {
                            return (copy SuperProxyValue (v.getLoc (),
                                                          c.createInstance (isMutable-> cptr.isMutable (), isInnerMutable-> cptr.isDeeplyMutable ()),
                                                          left))?;
                        }
                        _ => {
                            throw copy ErrorMsg::fatal (v.getLoc (), end-> left.getLoc (), format (ValidateErrorMessage::NO_SUPER_CLASS, cptr));
                        }
                    }
                }
            }
        }

        none
    }

    /**
     * Validate the access to the non template methods from the vtable of a class value, inside a call expression, thus ignoring @field methods
     * * @params:
     *    - context: the context of the validation
     *    - left: the object value
     *    - right: the field accessed
     *    - clRef: the reference to the class type
     *    - inProt: true if in protected context
     *    - inPrv: true if in private context
     * @returns:
     *    - values: insert all method delegate values
     * */
    fn validateMethodClassAccess (self, dmut _ : &Validator, left : &Value, right : &Expression, clRef : &ClassRefType, isProxy : bool, inProt : bool, inPrv : bool, ref mut values : [&Value], ref mut errors : [&ErrorMsg], allowImmut : bool) {
        if let meth : &VarExpr = right for i, v in clRef.getVtable () {
            if (v.getSymbol ().getPath ().file () == meth.getLoc ().str) && (!v.isFieldAssign () && !v.isField ()) {
                if (v.getSymbol ().getProtection () == Protection::PRIVATE && !inPrv) {
                    errors ~= [copy ErrorMsg::fatal (right.getLoc (), format (DeclareErrorMessage::PRIVATE_IN_THIS_CONTEXT, v, tags-> FormatTags (withParams-> true)),
                                                     notes-> copy [copy ErrorMsg::note (v.getSymbol ().getLoc (), ValidateErrorMessage::DECLARED_HERE)])];
                } else if (v.getSymbol ().getProtection () == Protection::PROTECTED && !inPrv && !inProt) {
                    errors ~= [copy ErrorMsg::fatal (right.getLoc (), format (DeclareErrorMessage::PRIVATE_IN_THIS_CONTEXT, v, tags-> FormatTags (withParams-> true)),
                                                     notes-> copy [copy ErrorMsg::note (v.getSymbol ().getLoc (), ValidateErrorMessage::DECLARED_HERE)])];
                } else {
                    let isDirect = if isProxy {
                        true
                    } else if clRef.hasAncestor () {
                        // final class with no ancestor does not need vtable
                        (!v.isVirtual () || clRef.getSymbol ().isFinal () || clRef.getSymbol ().isStruct ())
                    } else {
                        // method that are not over and are final are not virtual
                        !v.isVirtual ()
                    };

                    if (v.isMutable () && left !of ClassAliaserValue) {
                        let mut notes = copy [copy ErrorMsg::note (left.getLoc (), format (ValidateErrorMessage::IMPLICIT_ALIAS, left.getType ()))];
                        if (left of AliaserValue) notes = notes ~ copy [copy ErrorMsg::note (left.getLoc (), end-> v.getLoc (), format (ValidateErrorMessage::SIMPLE_ALIAS_NOT_CLASS), oneLine-> true)];

                        errors ~= [copy ErrorMsg::fatal (v.getLoc (), format (ValidateErrorMessage::MUTABLE_METHOD, v, tags-> FormatTags (withParams-> true)),
                                                         notes-> notes)];
                    }

                    else if (!v.isMutable () && (left of ClassAliaserValue || left of AliaserValue) && !allowImmut) {
                        errors ~= [copy ErrorMsg::fatal (v.getLoc (), format (ValidateErrorMessage::CONST_METHOD, v, tags-> FormatTags (withParams-> true)),
                                                         notes-> copy [copy ErrorMsg::note (left.getLoc (), format (ValidateErrorMessage::UNECESSARY_ALIAS, left.getType ()))])];
                    }

                    else if v.isEmpty () && isDirect {
                        errors ~= [copy ErrorMsg::fatal (v.getLoc (), format (ValidateErrorMessage::EMPTY_METHOD_CALL, v, tags-> FormatTags (withParams-> true)),
                                                         notes-> copy [copy ErrorMsg::note (left.getLoc (), format (ValidateErrorMessage::ABSTRACT_CLASS_CALL, left.getType ()))])];
                    }

                    else {
                        values ~= [copy MethodDelegateValue (v.getLoc (), v, closure-> left, direct-> isDirect, vtableIndex-> i, isStruct-> clRef.isStruct ())];
                    }
                }
            }
        }

        // _ => {
        // We don't throw an error, assuming that validateClassFieldAccess is always called before, thus the error would be replicated
        // }
    }

    /**
     * Validate the access to the template methods defined within the class symbol, inside a call expression, thus ignoring @field methods
     * @params:
     *    - context: the context of the validation
     *    - left: the object value
     *    - right: the field accessed
     *    - clRef: the reference to the class type
     *    - inProt: true if in protected context
     *    - inPrv: true if in private context
     * @returns:
     *    - values: insert all template values
     * */
    fn validateTemplateMethodClassAccess (self, dmut _ : &Validator, left : &Value, right : &Expression, clRef : &ClassRefType, inProt : bool, inPrv : bool, ref mut values : [&Value], ref mut errors : [&ErrorMsg], allowImmut : bool) {
        if let meth : &VarExpr = right {
            let prots = clRef.getTemplateMethodProtections ();
            for i, v in clRef.getTemplateMethods () {
                if (v.getFunctionName () == meth.getLoc ().str) {
                    if (prots [i] <= MethodProtection::PRV && !inPrv) {
                        errors ~= [copy ErrorMsg::fatal (right.getLoc (), format (DeclareErrorMessage::PRIVATE_IN_THIS_CONTEXT, v, tags-> FormatTags (withParams-> true)),
                                                         notes-> copy [copy ErrorMsg::note (v.getSymbol ().getLoc (), ValidateErrorMessage::DECLARED_HERE)])];
                    } else if (prots [i] == MethodProtection::PROT && !inPrv && !inProt) {
                        errors ~= [copy ErrorMsg::fatal (right.getLoc (), format (DeclareErrorMessage::PRIVATE_IN_THIS_CONTEXT, v, tags-> FormatTags (withParams-> true)),
                                                         notes-> copy [copy ErrorMsg::note (v.getSymbol ().getLoc (), ValidateErrorMessage::DECLARED_HERE)])];
                    } else {

                        if (v.isMutable () && left !of ClassAliaserValue) {
                            let mut notes = copy [copy ErrorMsg::note (left.getLoc (), format (ValidateErrorMessage::IMPLICIT_ALIAS, left.getType ()))];
                            if (left of AliaserValue) notes = notes ~ [copy ErrorMsg::note (left.getLoc (), end-> v.getLoc (), format (ValidateErrorMessage::SIMPLE_ALIAS_NOT_CLASS), oneLine-> true)];

                            errors ~= [copy ErrorMsg::fatal (v.getLoc (), format (ValidateErrorMessage::MUTABLE_METHOD, v, tags-> FormatTags (withParams-> true)),
                                                             notes-> notes)];
                        }

                        else if (!v.isMutable () && (left of ClassAliaserValue || left of AliaserValue) && !allowImmut) {
                            errors ~= [copy ErrorMsg::fatal (v.getLoc (), format (ValidateErrorMessage::CONST_METHOD, v, tags-> FormatTags (withParams-> true)),
                                                             notes-> copy [copy ErrorMsg::note (left.getLoc (), format (ValidateErrorMessage::UNECESSARY_ALIAS, left.getType ()))])];
                        }

                        else {
                            values ~= [copy MethodDelegateTemplateValue (v.getLoc (), v, closure-> left, isStruct-> clRef.isStruct ())];
                        }
                    }
                }
            }
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =================================          METHOD FIELDS          ==================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Validate an access to method of a class, but outside a call expression, thus selection only @field methods
     * */
    fn validateMethodFieldClassAccess (self, dmut context : &Validator, loc : &Word, left : &Value, right : &Expression, clRef : &ClassRefType, isProxy : bool, inProt : bool, inPrv : bool, ref mut values : [&Value], ref mut errors : [&ErrorMsg], assign : bool) {
        if let meth : &VarExpr = right for i, v in clRef.getVtable () {
            let applicable = (v.isField () && !assign) || (v.isFieldAssign () && assign);

            if (v.getSymbol ().getPath ().file () == meth.getLoc ().str) && applicable {
                if (v.getSymbol ().getProtection () == Protection::PRIVATE && !inPrv) {
                    errors ~= [copy ErrorMsg::fatal (right.getLoc (), format (DeclareErrorMessage::PRIVATE_IN_THIS_CONTEXT, v, tags-> FormatTags (withParams-> true)),
                                                     notes-> copy [copy ErrorMsg::note (v.getSymbol ().getLoc (), ValidateErrorMessage::DECLARED_HERE)])];
                } else if (v.getSymbol ().getProtection () == Protection::PROTECTED && !inPrv && !inProt) {
                    errors ~= [copy ErrorMsg::fatal (right.getLoc (), format (DeclareErrorMessage::PRIVATE_IN_THIS_CONTEXT, v, tags-> FormatTags (withParams-> true)),
                                                     notes-> copy [copy ErrorMsg::note (v.getSymbol ().getLoc (), ValidateErrorMessage::DECLARED_HERE)])];
                } else {
                    let isDirect = if isProxy {
                        true
                    } else if clRef.hasAncestor () {
                        // final class with no ancestor does not need vtable
                        (!v.isVirtual () || clRef.getSymbol ().isFinal () || clRef.getSymbol ().isStruct ())
                    } else {
                        // method that are not over and are final are not virtual
                        !v.isVirtual ()
                    };

                    let mut caller = left;
                    let mut success = true;

                    if left of ClassAliaserValue {
                        errors ~= [copy ErrorMsg::fatal (v.getLoc (), format (ValidateErrorMessage::FIELD_METHOD_ALIAS, v, tags-> FormatTags (withParams-> true)),
                                                         notes-> copy [copy ErrorMsg::note (left.getLoc (), format (ValidateErrorMessage::UNECESSARY_ALIAS_FIELD_METHOD, left.getType ()))])];
                        success = false;
                    }

                    else if v.isMutable () {
                        {
                            caller = context:.getValueValidator ().validateAlias (alias context, loc, left, isClass-> true, isField-> false);
                        } catch {
                            err => {
                                errors ~= [copy ErrorMsg::fatal (v.getLoc (), format (ValidateErrorMessage::FIELD_METHOD_MUTABLE_ALIAS, v, tags-> FormatTags (withParams-> true)),
                                                                 notes-> copy [err])];
                                success = false;
                            }
                        }
                    }

                    if success {
                        values ~= [copy MethodDelegateValue (v.getLoc (), v, closure-> caller, direct-> isDirect, vtableIndex-> i, isStruct-> clRef.isStruct ())];
                    }
                }
            }
        }
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================         TUPLE FIELD          =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a field access on a tuple value
     * @params:
     *    - context: the context of the validation
     *    - loc: the location of the access
     *    - tuple: the type of the value whose field is accessed
     *    - left: the value whose content is accessed
     *    - right: the right operand of the operation
     * @returns: the result value of the access
     * @throws:
     *    - &ErrorMsg: if the access is invalid
     */
    fn validateTupleFieldOperation (self, dmut context : &Validator, loc : &Word, _ : BinaryOperators, tuple : &TupleType, left : &Value, right : &Expression)-> &Value
        throws ErrorMsg
    {
        let rightVal = {
            context:.enterDollar (left);
            {
                context.implicitEnumUnwrap (context:.validateValue (right))
            } exit {
                context:.exitDollar ();
            }
        } catch {
            err : &ErrorMsg => {
                throw err.withNote (copy [copy ErrorMsg::fatal (right.getLoc (), format (ValidateErrorMessage::TYPE_NO_FIELD, left.getType (), right))]);
            }
        };

        let val = context:.getCompileTimeInterpreter ():.computeInt (rightVal, signed-> false);
        let arity = tuple.getInners ().len;

        {
            let acc = if (val < 0) {
                let _abs : usize = cast!usize (val.to!isize ().abs ());
                if (arity < _abs) throw copy ErrorMsg::fatal (loc, format (ValidateErrorMessage::TUPLE_ARITY_OVERFLOW, _abs, arity));
                arity - _abs
            } else {
                if (arity <= val.to!usize ()) throw copy ErrorMsg::fatal (loc, format (ValidateErrorMessage::TUPLE_ARITY_OVERFLOW, val, arity));
                val.to!usize ()
            };

            let innerType = tuple.getInners ()[acc];

            let retType = if (left.isLvalue () && tuple.isMutable ()) {
                innerType
            } else {
                innerType.clone (0u32)
            }

            return self.createTupleFieldAccess (loc, retType, left, acc);
        } catch {
            x : &ErrorMsg => throw x;
            _ => throw copy ErrorMsg::fatal (rightVal.getLoc (), format (ValidateErrorMessage::OVERFLOW_CAPACITY, copy IntType (rightVal.getLoc (), size-> 0u16, signed-> false), val, u64::max));
        }
    }

    /**
     * Create a tuple field access value
     * @info: optimize a bit the access if it is done on a tuple construction
     * @params:
     *    - loc: the location of the access
     *    - type: the return type
     *    - value: the left operand of the access
     *    - index: the index of the access (assumed to be overflow checked before hand)
     * */
    pub fn createTupleFieldAccess (self, loc : &Word, type : &Type, value : &Value, index : usize, reduce : bool = true)-> &Value {
        match (value, reduce) {
            (tu : &TupleValue, true) => {
                return tu.getValues ()[index]
            }
            _ => {
                copy TupleFieldAccessValue (loc, type, value, index)
            }
        }
    }


    /*!
     * ================================================================================
     * ================================================================================
     * =========================         RANGE FIELD          =========================
     * ================================================================================
     * ================================================================================
     */


    /**
     * Validate a field operation on a range value
     * @params:
     *    - context: the context of the validation
     *    - loc: the location of the access
     *    - op: the operator used to perform the access
     *    - range: the type of the left operand
     *    - left: the value of the left operand
     *    - right: the expression of the access (right operand)
     * @returns: a value containing the field access on the range
     * @throws:
     *    - &ErrorMsg: if the access is invalid
     */
    fn validateRangeFieldOperation (self, dmut context : &Validator, loc : &Word, _ : BinaryOperators, range : &RangeType, left : &Value, right : &Expression)-> &Value
        throws ErrorMsg
    {
        match right {
            field : &VarExpr => {
                match field.getLoc ().str {
                    RangeKeys::FST | RangeKeys::SCD => {
                        let type = range.getInners ()[0];
                        return copy StructFieldAccessValue (loc, type, left, field.getLoc ().str);
                    }
                    RangeKeys::STEP => {
                        let type = range.getInners ()[1];
                        return copy StructFieldAccessValue (loc, type, left, field.getLoc ().str);
                    }
                    RangeKeys::CONTAINS => {
                        let type = copy BoolType (loc, isMutable-> range.isMutable ());
                        return copy StructFieldAccessValue (loc, type, left, field.getLoc ().str);
                    }
                    RangeKeys::STEP_BY => {
                        return self.validateStepByRange (alias context, loc, range, left, right);
                    }
                    RangeKeys::REVERSE => {
                        return self.validateReverseRange (alias context, loc, range, left, right);
                    }
                    RangeKeys::LEN => {
                        return self.validateLenRange (alias context, loc, range, left, right);
                    }
                }
            }
        }

        throw copy ErrorMsg::fatal (right.getLoc (), format (ValidateErrorMessage::TYPE_NO_FIELD, left.getType (), right));
    }

    /**
     * Validate the access to the method 'stepBy' of a range value
     * */
    fn validateStepByRange (self, dmut context : &Validator, loc : &Word, range : &RangeType, left : &Value, right : &Expression)-> &Value
        throws ErrorMsg
    {
        {
            let methExpr = context.createSyntaxVarFromPath (loc, RangeUtils::STEP_BY_FUNC);
            let methFunc = context:.getValueValidator ().validateTemplateCall (
                alias context,
                loc,
                context:.validateValue (methExpr),
                range.getInners ());

            match methFunc {
                n : &PrototypeValue => {
                    return copy FakeMethodDelegateValue (loc, n, left, protoName-> RangeKeys::STEP_BY);
                }
                t : _ => {
                    println (t.__typeinfo__.name);
                    panic;
                }
            }
        } catch {
            err : &ErrorMsg => {
                throw copy ErrorMsg::fatal (right.getLoc (), format (ValidateErrorMessage::TYPE_NO_FIELD, left.getType (), right),
                                       notes-> copy [err]);
            }
        }
    }

    /**
     * Validate the call to the reverse function from a range value
     * */
    fn validateReverseRange (self, dmut context : &Validator, loc : &Word, range : &RangeType, left : &Value, _ : &Expression)-> &Value
        throws ErrorMsg
    {
        let dmut interpret = context:.getCompileTimeInterpreter ();
        let fst  = interpret:.reduce (copy StructFieldAccessValue (loc, range.getInners ()[0], left, RangeKeys::FST));
        let scd  = interpret:.reduce (copy StructFieldAccessValue (loc, range.getInners ()[0], left, RangeKeys::SCD));
        let step = interpret:.reduce (copy StructFieldAccessValue (loc, range.getInners ()[1], left, RangeKeys::STEP));
        let contains = interpret:.reduce (copy StructFieldAccessValue (loc, copy BoolType (loc), left, RangeKeys::CONTAINS));

        let invStep = interpret:.reduce (copy UnaryIntOperatorValue (loc, step.getType (), UnaryOperators::MINUS, step));
        interpret:.reduce (copy RangeValue (loc, range, scd, fst, step-> invStep, full-> contains))
    }

    /**
     * Compute the length of a range
     * */
    fn validateLenRange (self, dmut context : &Validator, loc : &Word, range : &RangeType, left : &Value, _ : &Expression)-> &Value
        throws ErrorMsg
    {
        let dmut interpret = context:.getCompileTimeInterpreter ();
        let fst  = interpret:.reduce (copy StructFieldAccessValue (loc, range.getInners ()[0], left, RangeKeys::FST));
        let scd  = interpret:.reduce (copy StructFieldAccessValue (loc, range.getInners ()[0], left, RangeKeys::SCD));
        let step = interpret:.reduce (copy StructFieldAccessValue (loc, range.getInners ()[1], left, RangeKeys::STEP));
        let contains = interpret:.reduce (copy StructFieldAccessValue (loc, copy BoolType (loc), left, RangeKeys::CONTAINS));

        context:.getForLoopValidator ().validateComputeNbIterations (loc, alias context, fst, scd, step, contains)
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =======================         SLICE/ARRAY FIELD          =====================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a field operation on a slice value
     * @params:
     *    - context: the context of the validation
     *    - loc: the location of the access
     *    - slice: the type of the slice being accessed
     *    - left: the left value of the left operand
     *    - right: the expression of the access (right operand)
     * @returns: a value containing the field access on the slice
     * @throws:
     *    - &ErrorMsg: if the access is invalid
     */
    fn validateSliceFieldOperation (self, dmut _ : &Validator, loc : &Word, _ : BinaryOperators, slice : &SliceType, left : &Value, right : &Expression)-> &Value
        throws ErrorMsg
    {
        match right {
            field : &VarExpr => {
                match field.getLoc ().str {
                    SliceKeys::LEN => {
                        let type = copy IntType (loc, size-> 0u16, signed-> false, isMutable-> false);
                        return copy StructFieldAccessValue (loc, type, left, field.getLoc ().str);
                    }
                    SliceKeys::PTR => {
                        let inner = slice.getInners ()[0];
                        let ptr = copy PointerType (loc, inner, isMutable-> inner.isMutable ());
                        return copy StructFieldAccessValue (loc, ptr, left, field.getLoc ().str);
                    }
                }
            }
        }

        throw copy ErrorMsg::fatal (right.getLoc (), format (ValidateErrorMessage::TYPE_NO_FIELD, left.getType (), right));
    }

    /**
     * Validate a field operation on an array value
     * @params:
     *    - context: the context of the validation
     *    - loc: the location of the access
     *    - array: the type of the array being accessed
     *    - left: the left value of the left operand
     *    - right: the expression of the access (right operand)
     * @returns: a value containing the field access on the slice
     * @throws:
     *    - &ErrorMsg: if the access is invalid
     */
    fn validateArrayFieldOperation (self, dmut _ : &Validator, loc : &Word, _ : BinaryOperators, array : &ArrayType, left : &Value, right : &Expression)-> &Value
        throws ErrorMsg
    {
        match right {
            field : &VarExpr => {
                match field.getLoc ().str {
                    SliceKeys::LEN => {
                        return makeIntValue (loc, array.getLen ());
                    }
                    SliceKeys::PTR => {
                        let inner = array.getInners ()[0];
                        let ptr = copy PointerType (loc, inner, isMutable-> inner.isMutable ());
                        return copy AddressValue (loc, ptr, left);
                    }
                }
            }
        }

        throw copy ErrorMsg::fatal (right.getLoc (), format (ValidateErrorMessage::TYPE_NO_FIELD, left.getType (), right));
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          MAP FIELD          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */


    /**
     * Validate a field operation on an map value
     * @params:
     *    - context: the context of the validation
     *    - loc: the location of the access
     *    - mp: the type of the map being accessed
     *    - left: the left value of the left operand
     *    - right: the expression of the access (right operand)
     * @returns: a value containing the field access on the slice
     * @throws:
     *    - &ErrorMsg: if the access is invalid
     * */
    fn validateMapFieldOperation (self, dmut context : &Validator, loc : &Word, _ : BinaryOperators, mapType : &MapType, left : &Value, right : &Expression)-> &Value
        throws ErrorMsg
    {
        match right {
            field : &VarExpr => {
                match field.getLoc ().str {
                    MapKeys::LEN => {
                        if (left of MapAliaserValue) {
                            throw copy ErrorMsg::fatal (loc, end-> right.getLoc (), format (ValidateErrorMessage::CLASS_ALIAS_FIELD));
                        }

                        let type = copy IntType (loc, size-> 0u16, signed-> false, isMutable-> false);
                        return copy MapLenAccessValue (loc, type, left);
                    }
                    MapKeys::REMOVE => {
                        if (left !of MapAliaserValue) {
                            let mut notes = copy [copy ErrorMsg::note (left.getLoc (), format (ValidateErrorMessage::IMPLICIT_ALIAS, mapType))];
                            if (left of AliaserValue) notes = notes ~ [copy ErrorMsg::note (left.getLoc (), format (ValidateErrorMessage::SIMPLE_ALIAS_NOT_CLASS), oneLine-> true)];

                            throw copy ErrorMsg::fatal (loc, end-> right.getLoc (), format (ValidateErrorMessage::MUTABLE_METHOD, MapKeys::REMOVE), notes-> notes);
                        }

                        return self.validateRemoveMap (alias context, loc, mapType, left, right);
                    }
                }
            }
        }

        if (left of MapAliaserValue) {
            throw copy ErrorMsg::fatal (loc, end-> right.getLoc (), format (ValidateErrorMessage::CLASS_ALIAS_FIELD),
                                   notes-> copy [copy ErrorMsg::fatal (right.getLoc (), format (ValidateErrorMessage::TYPE_NO_FIELD, left.getType (), right))]);
        }

        throw copy ErrorMsg::fatal (right.getLoc (), format (ValidateErrorMessage::TYPE_NO_FIELD, left.getType (), right));

    }

    /**
     * Validate the access to the method 'remove' of a map value
     * */
    fn validateRemoveMap (self, dmut context : &Validator, loc : &Word, mapType : &MapType, left : &Value, right : &Expression)-> &Value
        throws ErrorMsg
    {
        let methExpr = context.createSyntaxVarFromPath (loc, MapUtils::REMOVE_FUNC);
        let methFunc = context:.getValueValidator ().validateTemplateCall (
            alias context,
            loc,
            context:.validateValue (methExpr),
            mapType.getInners ()[0 .. 2]);

        match methFunc {
            n : &PrototypeValue => {
                let closure = copy ReferencerValue (loc, mapType, left, isMutable-> true);
                return copy FakeMethodDelegateValue (loc, n, closure, protoName-> MapKeys::REMOVE);
            }
            t : _ => {
                println (t.__typeinfo__.name);
                panic;
            }
        }
    } catch {
        err : &ErrorMsg => {
            throw copy ErrorMsg::fatal (right.getLoc (), format (ValidateErrorMessage::TYPE_NO_FIELD, left.getType (), right),
                                   notes-> copy [err]);
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ==================================          FUTURE FIELD          ==================================
     * ====================================================================================================
     * ====================================================================================================
     */


    /**
     * Validate a field operation on a future value
     * @params:
     *    - context: the context of the validation
     *    - loc: the location of the access
     *    - ftype: the future type
     *    - left: the left operand
     *    - right: the right operand
     * @returns: a value containing the field access on the future value
     * @throws:
     *    - &ErrorMsg: if the access is invalid
     * */
    fn validateFutureFieldOperation (self, dmut _ : &Validator, loc : &Word, _ : BinaryOperators, ftype : &FutureType, left : &Value, right : &Expression)-> &Value
        throws ErrorMsg
    {
        match right {
            field : &VarExpr => {
                match field.getLoc ().str {
                    FutureKeys::VALUE => {
                        return copy FutureFieldAccessValue (loc, ftype.getInners ()[0], left, FutureKeys::VALUE);
                    }
                    FutureKeys::FINISHED => {
                        return copy FutureFieldAccessValue (loc, copy BoolType (loc), left, FutureKeys::FINISHED);
                    }
                    FutureKeys::THREAD_ID => {
                        return copy FutureFieldAccessValue (loc, copy IntType (loc, signed-> false, size-> 0), left, FutureKeys::THREAD_ID);
                    }
                }
            }
        }

        throw copy ErrorMsg::fatal (right.getLoc (), format (ValidateErrorMessage::TYPE_NO_FIELD, left.getType (), right));
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ==================================          OPTION FIELD          ==================================
     * ====================================================================================================
     * ====================================================================================================
     */


    /**
     * Validate a field operation on a option value
     * @params:
     *    - context: the context of the validation
     *    - loc: the location of the access
     *    - o: the option type being accessed
     *    - left: the left operand
     *    - right: the right operand
     * @returns: a value containing the field access on the option value
     * @throws:
     *    - &ErrorMsg: if the access is invalid
     * */
    fn validateOptionFieldOperation (self, dmut context : &Validator, loc : &Word, _ : BinaryOperators, otype : &OptionType, left : &Value, right : &Expression)-> &Value
        throws ErrorMsg
    {
        match right {
            field : &VarExpr => {
                match field.getLoc ().str {
                    OptionKeys::SET => {
                        let type = copy BoolType (loc);
                        return copy StructFieldAccessValue (loc, type, left, OptionKeys::SET);
                    }
                    OptionKeys::HAS_ERROR => {
                        let type = copy BoolType (loc), ptrType = copy PointerType (loc, copy VoidType (loc));
                        let isSet = copy UnaryBoolOperatorValue (loc, UnaryOperators::NOT, copy StructFieldAccessValue (loc, type, left, OptionKeys::SET));
                        let hasErr = copy CmpPointerOperatorValue (loc, BinaryOperators::NOT_EQUAL,
                                                                   copy OptionFieldAccessValue (loc, ptrType, left, OptionKeys::ERROR),
                                                                   copy NullValue (loc, ptrType));

                        return copy LogicalBinBoolOperatorValue (loc, BinaryOperators::DAND, isSet, hasErr);
                    }
                    OptionKeys::VALUE => {
                        return self.validateOptionFieldValue (alias context, loc, otype, left);
                    }
                    OptionKeys::ERROR => {
                        return self.validateOptionFieldError (alias context, loc, otype, left);
                    }
                }
            }
        }

        throw copy ErrorMsg::fatal (right.getLoc (), format (ValidateErrorMessage::TYPE_NO_FIELD, left.getType (), right));
    }

    /**
     * Validate the access to the value of an option
     * @params:
     *   - context: the context of the validation
     *   - loc: the location of the access
     *   - otype: the type of the value being accessed
     *   - left: the option value being accessed
     * @returns: the value performing the access
     * */
    fn validateOptionFieldValue (self, dmut context : &Validator, loc : &Word, otype : &OptionType, left : &Value)-> &Value
        throws ErrorMsg
    {
        let dmut interpret = context:.getCompileTimeInterpreter ();

        let innerType = otype.getInners ()[0];
        let boolType = copy BoolType (loc);
        let isSet = interpret:.reduce (copy UnaryBoolOperatorValue (loc, UnaryOperators::NOT, copy StructFieldAccessValue (loc, boolType, left, OptionKeys::SET)));
        let value = copy OptionFieldAccessValue (loc, innerType, left, OptionKeys::VALUE);

        match isSet { // we know at cte if the option has a value or not
            b : &BoolValue => {
                if (b.isTrue ()) throw copy ErrorMsg::fatal (loc, format (ValidateErrorMessage::OPTION_HAS_NO_VALUE, otype)); // !x.hasValue
                return value; // x.hasValue, thus return the value
            }
        }

        let errType = context:.getExceptionFromName (loc-> loc, ExceptionUtils::EMPTY_VAL_OPTION);
        let errInstance = context:.constructObjectInstance (loc, errType, []);
        let throwVal = copy ThrowValue (loc, errInstance);

        let cond = copy ConditionalValue (loc, VOID_TYPE, isSet, throwVal, elsev-> UNIT_VALUE, isComplete-> false);

        return copy BlockValue (loc, innerType, copy [cond, value], isSet-> true);
    }

    /**
     * Validate the access to the error of an option
     * @params:
     *   - context: the context of the validation
     *   - loc: the location of the access
     *   - otype: the type of the value being accessed
     *   - left: the option value being accessed
     * @returns: the value
     * */
    fn validateOptionFieldError (self, dmut context : &Validator, loc : &Word, otype : &OptionType, left : &Value)-> &Value
        throws ErrorMsg
    {
        let type = copy BoolType (loc), ptrType = copy PointerType (loc, copy VoidType (loc));
        let isSet = copy StructFieldAccessValue (loc, type, left, OptionKeys::SET);
        let notHasErr = copy CmpPointerOperatorValue (loc, BinaryOperators::DEQUAL,
                                                      copy OptionFieldAccessValue (loc, ptrType, left, OptionKeys::ERROR),
                                                      copy NullValue (loc, ptrType));

        let setOrNotHasError = context:.getCompileTimeInterpreter ():.reduce (copy LogicalBinBoolOperatorValue (loc, BinaryOperators::DPIPE, isSet, notHasErr));
        let innerType = context:.getExceptionType (loc-> loc);

        let value = copy OptionFieldAccessValue (loc, innerType, left, OptionKeys::ERROR);
        match setOrNotHasError {
            b : &BoolValue => {
                if (b.isTrue ()) throw copy ErrorMsg::fatal (loc, format (ValidateErrorMessage::OPTION_HAS_NO_ERROR, otype));
                return value;
            }
        }

        let errType = context:.getExceptionFromName (loc-> loc, ExceptionUtils::EMPTY_ERR_OPTION);
        let errInstance = context:.constructObjectInstance (loc, errType, []);
        let throwVal = copy ThrowValue (loc, errInstance);

        let cond = copy ConditionalValue (loc, VOID_TYPE, setOrNotHasError, throwVal, elsev-> UNIT_VALUE, isComplete-> false);

        return copy BlockValue (loc, errType, copy [cond, value], isSet-> true);
    }


    /*!
     * ================================================================================
     * ================================================================================
     * =========================            MODULE            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a binary operation involving a module operator (left operand can be a type or a value)
     * @params:
     *   - context: the context of the validation
     *   - bin: the binary expression to validate
     * @returns: the validated value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    pub fn validateModuleOperation (self, dmut context : &Validator, _ : BinaryOperators, bin : &BinaryExpr)-> &Value
        throws ErrorMsg
    {
        let mut errorTypes : [&ErrorMsg] = [];
        let mut errorFoll  : [&ErrorMsg] = [];
        let mut finalVals  : [&Value] = [];

        let (asValue, okValue) = { // try to validate the left part as a value
            (context.implicitEnumUnwrap (context:.validateValue (bin.getLeft ())), true)
        } catch {
            err : &ErrorMsg => {
                errorTypes ~= [err];
                (UNIT_VALUE, false) // failed, maybe its a type
            }
        };


        let (asType, okType) = { // try to validate the left part as a type
            (context:.validateType (bin.getLeft ()), true)
        } catch {
            err : &ErrorMsg => {
                errorTypes ~= [err];
                (NONE_TYPE, false) // failed maybe its a value
            }
        };

        if (!okValue && !okType) throw copy ErrorMsg::list (errorTypes); // it is neither a type nor a value
        if (okValue) { // it is a value
            self.validateModuleOperationValue (alias context, bin.getLoc (), asValue, bin.getRight (), ref finalVals, ref errorFoll);
        }

        if (okType) { // it is a type
            self.validateModuleOperationType (alias context, bin.getLoc (), asType, bin.getRight (), ref finalVals, ref errorFoll);
        }

        // actually it can be both a type and a value (for example, a class and a module can have the same name)
        if (finalVals.len == 0us) throw copy ErrorMsg::list (errorFoll);
        if (finalVals.len == 1us) return finalVals [0us]; // only one result
        else {
            return copy MultSymValue (bin.getLoc (), finalVals, prettyStr-> format ("%", bin.getRight ())); // multiple symbols
        }
    }

    /**
     * Validate a module operation where the left part is a valid value
     * @params:
     *    - context: the context of the validation
     *    - loc: the location of the bin expr
     *    - value: the left operand
     *    - right: the right operand
     * @returns:
     *    - finalVals: the list of validated values
     *    - errors: inserted errors if the validation fails
     * */
    fn validateModuleOperationValue (self, dmut context : &Validator, loc : &Word, value : &Value, right : &Expression, ref mut finalVals : [&Value], ref mut errors : [&ErrorMsg]) {
        {
            let inval = self.validateModuleOperation (alias context, loc, value, right);
            match inval {
                m : &MultSymValue => {
                    for v in m.getValues () {
                        finalVals ~= [v];
                    }
                }
                _ => { finalVals ~= [inval]; }
            }
        } catch {
            err : &ErrorMsg => {
                errors ~= [err];
            }
        }
    }

    /**
     * Validate a module operation where the left part is a valid type
     * @params:
     *    - context: the context of the validation
     *    - loc: the location of the bin expr
     *    - type: the left operand
     *    - right: the right operand
     * @returns:
     *    - finalVals: the list of validated values
     *    - errors: inserted errors if the validation fails
     * */
    fn validateModuleOperationType (self, dmut context : &Validator, loc : &Word, type : &Type, right : &Expression, ref mut finalVals : [&Value], ref mut errors : [&ErrorMsg]) {
        {
            let inval = context:.getSubTypeValidator ().validateValueFromType (alias context, loc, type, right);
            match inval {
                m : &MultSymValue => {
                    for v in m.getValues () {
                        finalVals ~= [v];
                    }
                }
                _ => { finalVals ~= [inval]; }
            }
        } catch {
            err : &ErrorMsg => {
                errors ~= [err];
            }
        }
    }

    /**
     * Validate a binary operation involving a module operator (the left operand has to be a value)
     * @params:
     *   - context: the context of the validation
     *   - bin: the binary expression to validate
     * @returns: the validated value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    pub fn validateModuleOperation (self, dmut context : &Validator, bin : &PathExpr)-> &Value
        throws ErrorMsg
    {
        let left = context.implicitEnumUnwrap (context:.validateValue (bin.getLeft ()));
        self.validateModuleOperation (alias context, bin.getLoc (), left, bin.getRight ())
    }

    /**
     * Validate a binary module operation
     * @params:
     *   - context: the context of the validation
     *   - loc: the location of the operation
     *   - left: the left operand
     *   - right: the right operand
     * @returns: the validated value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    fn validateModuleOperation (self, dmut context : &Validator, loc : &Word, left : &Value, right : &Expression)-> &Value
        throws ErrorMsg
    {
        let mut errorNotes : [&ErrorMsg] = [];
        match right {
            v : &VarExpr => { // Access of submodule is only made by var names
                match left {
                    md : &ModuleRefValue => { // If it is a module that's simple
                        let dmut res = context:.getLocalFromMod (md, v.getLoc ().str);
                        if (res.len != 0us) { // There are symbols whose name are 'v.getLoc ().str'
                            {
                                return context:.getLiteralValidator ().validateMultSymbols (loc, alias context, alias res);
                            } catch {
                                err : &ErrorMsg => {
                                    throw copy ErrorMsg::fatal (loc,
                                                           format (ValidateErrorMessage::UNDEFINED_BIN_MOD_OP, loc.str, left, right),
                                                           notes-> copy [err]);
                                }
                            }
                        }

                        errorNotes = context:.createLocalVarError (v.getLoc (), md, v.getLoc ().str);
                    }
                    ms : &MultSymValue => { // The left operand returned multiple symbols
                        let mut all : [dmut &Symbol] = [];
                        let mut errors : [&ErrorMsg] = [];
                        for c in ms.getValues () {
                            match c {
                                md : &ModuleRefValue => { // Some of them are modules, so we can sub access them using var 'v'
                                    let dmut res = context:.getLocalFromMod (md, v.getLoc ().str);
                                    all ~= alias res;
                                    if (res.len == 0us) {
                                        let lerr = context:.createLocalVarError (v.getLoc (), md, v.getLoc ().str);
                                        errors ~= lerr;
                                    }
                                }
                            }
                        }

                        if (all.len != 0us) { // There are symbols whose name are 'v.getLoc ().str'
                            {
                                return context:.getLiteralValidator ().validateMultSymbols (loc, alias context, alias all);
                            } catch {
                                err : &ErrorMsg => {
                                    throw copy ErrorMsg::fatal (loc,
                                                           format (ValidateErrorMessage::UNDEFINED_BIN_MOD_OP, loc.str, left, right),
                                                           notes-> copy [err]);
                                }
                            }
                        }

                        errorNotes = errors;
                    }
                }
            }
        }

        throw copy ErrorMsg::fatal (loc,
                               format (ValidateErrorMessage::UNDEFINED_BIN_MOD_OP, loc.str, left, right),
                               notes-> errorNotes);
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================         AFFECTATION          =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate an affectation operation, where the operator can be anything the result being stored in the left operatand of the operation
     * @params:
     *   - context: the context of the validation
     *   - op: the operator (can be a None operator, i.e. just a simple affectation)
     *   - bin: the binary expression to validate
     * @returns: the validated value
     * @throws:
     *   - &ErrorMsg: if the operation is not valid
     */
    fn validateAffectOperation (self, dmut context : &Validator, op : BinaryOperators, bin : &BinaryExpr)-> &Value
        throws ErrorMsg
    {
        let mut notes : [&ErrorMsg] = [];
        match bin.getLeft () { // Affection can be an index assign operation
            m : &MultOperatorExpr => { // in that case left operand is an index operation
                if (m.isIndex ()) {
                    // We try the operation rewrite
                    return self.validateIndexAssignOperation (alias context, op, m, bin);
                } // we don't catch, everything is managed in the specific method
            }
            bL : &BinaryExpr => {
                let (_, _, type) = self.toOperator (bL.getLoc ());
                if type == OperatorType::FIELD {

                    // we try the operation rewrite, applicable only on class instances
                    return self.validateFieldAssignOperation (alias context, op, bL, bin);

                } // we don't catch, everything is managed in the specific method
            }
        }

        {
            let left = context:.validateValue (bin.getLeft (), noReduce-> true);
            self.validateAffectOperation (alias context, bin.getLoc (), op, left, bin.getRight ())
        } catch {
            err => { // maybe index or field assign failed
                if notes.len != 0 {
                    throw copy ErrorMsg::fatal (bin.getLoc (), ValidateErrorMessage::VALIDATING,
                                                notes-> copy [err] ~ notes);
                } else {
                    throw err;
                }
            }
        }
    }

    /**
     * Validate an affection operation
     * @params:
     *    - context: the context of the validation
     *    - loc: the location of the operation
     *    - left: the left operand
     *    - rightExp: the right operand
     * @returns: the validated value
     * @throws:
     *    - &ErrorMsg: if the operation is not valid
     * */
    pub fn validateAffectOperation (self, dmut context : &Validator, loc : &Word, op : BinaryOperators, left : &Value, rightExp : &Expression)-> &Value
        throws ErrorMsg
    {
        context.verifyLeftOperandMove (loc, left);
        if (op == Tokens::TILDE) { // append operations
            match left.getType () {
                s : &SliceType => { // a ~= [1]; where a is a slice value
                    let rightV = context:.validateValue (rightExp);
                    return self.validateSliceAppend (alias context, loc, s, left, rightV);
                }
            }
        }

        // We validate right only now, because it is not needed if the left value is immutable, or not a lvalue
        let right = self.validateAffectRight (alias context, loc, op, left, rightExp);
        match (left.getType (), right) {
            (stype : &SliceType, s : &SliceConcatValue) => { // a = a ~ [1]; where a is a slice value
                if (s.getLeft () == left) return self.validateSliceAppend (alias context, loc, stype, left, s.getRight ());
            }
        }

        // Important part, now we verify memory movement
        context.verifyMemoryOwner (loc, left.getType (), right, construct-> false, byReference-> false);

        if (left.getType ().isMovable ()) {
            return self.validateMoveAffectOperation (alias context, loc, left, right);
        } else {

            // simply returns an affectation value, the affectation is possible
            return copy AffectValue (loc, left.getType (), left, right)
        }
    }

    /**
     * Validate an affect operation where left operand is an entity (so must be destroyed before affect)
     * */
    fn validateMoveAffectOperation (self, dmut _ : &Validator, loc : &Word, left : &Value, right : &Value)-> &Value
        throws ErrorMsg
    {
        match left.getType () {
            c : &ClassPtrType => {
                if c.getInner ().getDestructor () of DtorPrototypeValue {
                    let methDg = copy MethodDelegateValue (loc,
                                                           c.getInner ().getDestructor ().asOf!{&DtorPrototypeValue} (),
                                                           closure-> left, direct-> true, vtableIndex-> 0us, isStruct-> true);

                    let boolType = copy BoolType (loc);
                    let lSet = copy StructFieldAccessValue (loc, boolType, left, ClassKeys::SET);
                    let call = copy MethodCallValue (loc, copy VoidType (loc), methDg, []);
                    // if field.#_set { __dtor (field); } .. no need to set #_set, since we reaffect the value just after

                    let cond = copy ConditionalValue (loc, VOID_TYPE, lSet, call, UNIT_VALUE);
                    // And we don't have to reset left #_set, since it is or a ctor or a mover

                    let values = copy [cond, copy AffectValue (loc, VOID_TYPE, left, right)];
                    return copy BlockValue (loc, VOID_TYPE, values);
                }
            }
        }

        // No dtor found, thus we just return the affectation
        return copy AffectValue (loc, VOID_TYPE, left, right);
    }

    /**
     * @returns: true iif the right operand in a bin affectation can change due to implicit casting (e.g. i(i8) += 1;)
     * */
    fn canImplicitCastBinAffect (self, type : &Type)-> bool {
        match type {
            IntType () => { true }
            FloatType () => { true }
            _ => { false }
        }
    }

    /**
     * Validate an op index assign operation
     * @params:
     *    - context: the context of the validation
     *    - op: the math operator associated with the operation (if any, BinaryOperators::EQUAL if none)
     *    - bin: the binary operation to validate
     * @returns: a value containing the rewrite
     * @throws:
     *    - &ErrorMsg: if the operator cannot be rewritten, or there is an error in the validation of the operands
     */
    fn validateIndexAssignOperation (self, dmut context : &Validator, op : BinaryOperators, leftExpr : &MultOperatorExpr, bin : &BinaryExpr)-> &Value
        throws ErrorMsg
    {
        let leftIndex = if (leftExpr.getLoc () == Tokens::LCRO_AND) {
            context:.getValueValidator ().validateAlias (alias context, leftExpr.getLoc (), leftExpr.getLeft (), isClass-> true, isField-> false)
        } else {
            context.implicitEnumUnwrap (context:.validateValue (leftExpr.getLeft ()))
        };

        match leftIndex.getType () {
            c : &ClassPtrType => { // Index assign can be overriden for classes
                context:.getIndexOpValidator ().validateClassIndexAssign (alias context, leftExpr.getLoc (),
                                                                          op,
                                                                          c,
                                                                          leftIndex,
                                                                          leftExpr, bin.getRight ())
            }
            m : &MapType => { // Needs a special treatment on maps
                context:.getIndexOpValidator ().validateMapIndexAssign (alias context, leftExpr.getLoc (),
                                                                        op,
                                                                        m,
                                                                        leftIndex,
                                                                        leftExpr, bin.getRight ())
            }
            _ => { // Otherwise it is just an affectation of a slice/array access
                let left = context:.getIndexOpValidator ().validate (alias context, leftExpr.getLoc (), leftIndex, leftExpr.getRights (), inCopy-> false);
                self.validateAffectOperation (alias context, bin.getLoc (), op, left, bin.getRight ())
            }
        }
    }

    /**
     * Try to validate a field assign operation (a.foo = z), where a is a class value and calling method field assign may be present
     * @returns: the assignement value, or none if just not applicable
     * @warning: returning none means the assign method don't exists, but throwing an error means they were found but not compilation failed
     * */
    fn validateFieldAssignOperation (self, dmut context : &Validator, op : BinaryOperators, leftExpr : &BinaryExpr, bin : &BinaryExpr)-> &Value
        throws ErrorMsg
    {
        let leftIndex = context.implicitEnumUnwrap (context:.validateValue (leftExpr.getLeft ()));

        // Try to find vtable assign index elements
        if let cptr : &ClassPtrType =  leftIndex.getType () {
            let mut error : (&ErrorMsg)? = none;
            let (inPrv, inProt) = context.getCurrentClassContextProtections (cptr.getInner ());

            if !cptr.getInner ().hasTypeInfo () {
                if let dmut sym : &ClassSymbol = context:.getClassFromRef (cptr.getInner ().getSymbol ()) {
                    context:.getClassValidator ():.validateClassLayout (alias context, alias sym);
                } else panic;
            }

            // 1. try to using a class access/assign methods
            {
                let leftMeth = self.validateClassVtableAccess (alias context, leftExpr.getLoc (), leftIndex, leftExpr.getRight (), cptr.getInner (), isProxy-> context.isSuperProxy (leftIndex), inProt, inPrv, assign-> true, inCall-> false);
                let right = if op != BinaryOperators::EQUAL {
                    let rightMeth = self.validateClassVtableAccess (alias context, leftExpr.getLoc (), leftIndex, leftExpr.getRight (), cptr.getInner (), isProxy-> context.isSuperProxy (leftIndex), inProt, inPrv, assign-> false, inCall-> false);
                    self.validateAffectRight (alias context, bin.getLoc (), op, rightMeth, bin.getRight ())
                } else {
                    context:.validateValue (bin.getRight ())
                };

                let ret = context:.getCallOpValidator ().validate (alias context, bin.getLoc (), leftMeth, copy [right]);
                return ret;
            } catch {
                // failed to validate field method assign
                err : &ErrorMsg => {
                    if err.isNote () {
                        error = (err.asFatal ())?;
                    } else error = (err)?;
                }
            }

            // 2. try access basic field from class object
            {
                let field = self.validateClassFieldAccess (alias context, leftExpr.getLoc (), leftIndex, leftExpr.getRight (), cptr.getInner (), inProt, inPrv);
                return self.validateAffectOperation (alias context, bin.getLoc (), op, field, bin.getRight ());
            } catch {
                err : &ErrorMsg => {
                    if let Ok (prev) = error {
                        throw copy ErrorMsg::list (copy [prev, err]);
                    }

                    throw err;
                }
            }
        }

        else { // not a class
            let left = context:.validateValue (bin.getLeft (), noReduce-> true);
            self.validateAffectOperation (alias context, bin.getLoc (), op, left, bin.getRight ())
        }
    }


    /**
     * Validate the right operand of an affectation
     * @params:
     *    - context: the context of the validation
     *    - op: the operator used in the operation
     *    - left: the left value
     *    - bin: the binary expression
     * @returns: the validated right operand (already transformed if the op is special, e.g. for 'a += 1' returns 'a + 1')
     * */
    fn validateAffectRight (self, dmut context : &Validator, loc : &Word, op : BinaryOperators, left : &Value, right : &Expression)-> &Value
        throws ErrorMsg
    {
        // The right operand can be a math operation (e.g. a += 1, b /= 98)
        if (op != BinaryOperators::EQUAL) {
            let realRight = context:.validateValue (right);
            let castedRight = if self.canImplicitCastBinAffect (left.getType ()) { // we want to be able to validate: { let i : i8 = 1i8; i += 1; }, only valid for a few types, (float, int)
                context:.verifyCompatibleTypeWithValue (loc, left.getType (), realRight, byReference-> false) // so we need to take that into account immediately, because (i + 1) is of type i32, and not cte
            } else {
                realRight
            };

            let res = self.validateMathOperation (alias context, loc, op, left, castedRight);
            context:.verifyCompatibleTypeWithValue (loc, left.getType (), res, byReference-> false)
        } else { // else it is just a standard affectation, so right is directly right
            let rightV = context:.validateValue (right);
            context:.verifyCompatibleTypeWithValue (loc, left.getType (), rightV, byReference-> false) // verify the type compatibility, and return the casted value if needed
        }
    }

    /**
     * Validate an append operation on a slice operand
     * @params:
     *    - context: the context of the validation
     *    - loc: the location of the operation
     *    - stype: the type of the slice
     *    - left: the left operand (assuming it is a slice)
     *    - right: the right operand
     * @returns: the appending operation
     * @throws:
     *    - &ErrorMsg: if an error occurs
     * */
    pub fn validateSliceAppend (self, dmut context : &Validator, loc : &Word, stype : &SliceType, left : &Value, right : &Value)-> &Value
        throws ErrorMsg
    {
        let finRight = {
            let finRight = match right.getType () {
                SliceType () => { right }
                a : &ArrayType => {
                    context.createSliceAliasFromArray (loc, a, right)
                }
                _ => { throw copy ErrorMsg::list ([]); }
            };

            context.verifyCompatibleType (left.getLoc (), finRight.getLoc (), left.getType (), finRight.getType ());
            finRight
        } catch {
            err : &ErrorMsg => {
                throw copy ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_BIN_OP, Tokens::TILDE, left.getType (), right.getType ()), notes-> copy [err]);
            }
        };

        let slc = copy SliceAppendValue (loc, stype, left, finRight);
        context.verifyMemoryOwner (loc, stype, slc, construct-> false, byReference-> false);

        copy SliceAppendValue (loc, copy VoidType (loc), left, finRight)
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================       STRUCT / CLASS         =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a binary operator (math, set, range or bitwise) assuming that the left operand is a class ptr
     * @params:
     *   - context: the context of the validation
     *   - loc: the location of the operation
     *   - op: the operator
     *   - left: the left operand (assumed to be a class ptr type operand)
     *   - right: the right operand
     * @returns: the result value (generally a call value)
     * @throws:
     *   - &ErrorMsg: if the operation is invalid
     */
    fn validateClassOpLeft (self, dmut context : &Validator, loc : &Word, op : BinaryOperators, cptr : &ClassPtrType, left : &Value, right : &Value)-> &Value
        throws ErrorMsg
    {
        let str = makeStringSliceValue (loc, op);
        let meth = context:.constructObjectMethodAcc (loc, cptr, left, OpOverrideNames::BIN);
        let templ = context:.getValueValidator ().validateTemplateCall (alias context, loc, meth, copy [str]);

        context:.getCallOpValidator ().validate (alias context, loc, templ, copy [right])
    }

    /**
     * Validate a binary operator (math, set, range or bitwise) assuming that the right operand is a class ptr
     * @params:
     *   - context: the context of the validation
     *   - loc: the location of the operation
     *   - op: the operator
     *   - left: the left operand
     *   - right: the right operand (assumed to be a class ptr type operand)
     * @returns: the result value (generally a call value)
     * @throws:
     *   - &ErrorMsg: if the operation is invalid
     */
    fn validateClassOpRight (self, dmut context : &Validator, loc : &Word, op : BinaryOperators, cptr : &ClassPtrType, left : &Value, right : &Value)-> &Value
        throws ErrorMsg
    {
        let str = makeStringSliceValue (loc, op);
        let meth = context:.constructObjectMethodAcc (loc, cptr, right, OpOverrideNames::BIN_RIGHT);
        let templ = context:.getValueValidator ().validateTemplateCall (alias context, loc, meth, copy [str]);

        context:.getCallOpValidator ().validate (alias context, loc, templ, copy [left])
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================     STRUCT / CLASS (CMP)     =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a binary comparison operator assuming that the left operand is a class ptr
     * @params:
     *   - context: the context of the validation
     *   - loc: the location of the operation
     *   - op: the operator
     *   - left: the left operand (assumed to be a class ptr type operand)
     *   - right: the right operand
     * @returns: the result value (generally a call value)
     * @throws:
     *   - &ErrorMsg: if the operation is invalid
     */
    fn validateClassCmpOp (self, dmut context : &Validator, loc : &Word, op : BinaryOperators, cptr : &ClassPtrType, left : &Value, right : &Value, inv : bool = false)-> &Value
        throws ErrorMsg
    {
        let (cl, aux, correctOp) = if (inv) { (right, left, self.inverseCmpOp (op)) } else { (left, right, op) };

        {
            let meth = context:.constructObjectMethodAcc (loc, cptr, cl, OpOverrideNames::CMP);
            let call = context:.getCallOpValidator ().validate (alias context, loc, meth, copy [aux]);
            let casted = context:.getCastValidator ().validateCast (alias context, makeIntValue (loc, 0is), call.getType ());

            self.validateComparisonOperation (alias context, loc, correctOp, call, casted)
        } catch {
            err : &ErrorMsg => { // In case of error show the location of the rewrite for clearer errors
                {
                    if (op == BinaryOperators::DEQUAL || op == BinaryOperators::NOT_EQUAL) {
                        let meth = context:.constructObjectMethodAcc (loc, cptr, cl, OpOverrideNames::EQUALS);
                        let call = context:.getCallOpValidator ().validate (alias context, loc, meth, copy [aux]);

                        return if (op == BinaryOperators::NOT_EQUAL) {
                            context:.getUnOpValidator ().validateNotOperator (alias context, loc, call)
                        } else {
                            call
                        };
                    }
                } catch {
                    eqErr : &ErrorMsg => {
                        throw copy ErrorMsg::list (copy [err, eqErr]);
                    }
                }

                throw err;
            }
        }
    }

    /**
     * Inverse the comparison operator such that 'a op b', is equivalent to 'b inverse(op) a'
     * @example:
     * ==================
     * a > b // b < a
     * a >= b // b <= a
     * ==================
     * @panic: if op is not a compare operator
     * @params:
     *   - op: the operator to inverse
     * @returns: the inversed operator
     */
    fn inverseCmpOp (self, op : BinaryOperators)-> BinaryOperators {
        match op {
            BinaryOperators::INF => { BinaryOperators::SUP }
            BinaryOperators::SUP => { BinaryOperators::INF }
            BinaryOperators::INF_EQUAL => { BinaryOperators::SUP_EQUAL }
            BinaryOperators::SUP_EQUAL => { BinaryOperators::INF_EQUAL }
            BinaryOperators::NOT_EQUAL => { BinaryOperators::NOT_EQUAL }
            BinaryOperators::DEQUAL => { BinaryOperators::DEQUAL }
            _ => {
                panic;
            }
        }
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================    STRUCT / CLASS (RANGE)    =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a binary range operator assuming that the left operand is a class ptr
     * @params:
     *   - context: the context of the validation
     *   - loc: the location of the operation
     *   - op: the operator
     *   - left: the left operand (assumed to be a class ptr type operand)
     *   - right: the right operand
     * @returns: the result value (generally a call value)
     * @throws:
     *   - &ErrorMsg: if the operation is invalid
     */
    fn validateClassRangeOpLeft (self, dmut context : &Validator, loc : &Word, op : BinaryOperators, cptr : &ClassPtrType, left : &Value, right : &Value)-> &Value
        throws ErrorMsg
    {
        let contains = copy BoolValue (loc, op == BinaryOperators::TDOT);
        let meth = context:.constructObjectMethodAcc (loc, cptr, left, OpOverrideNames::RANGE);
        let templ = context:.getValueValidator ().validateTemplateCall (alias context, loc, meth, copy [contains]);

        context:.getCallOpValidator ().validate (alias context, loc, templ, copy [right])
    }

    /**
     * Validate a binary range operator assuming that the right operand is a class ptr
     * @params:
     *   - context: the context of the validation
     *   - loc: the location of the operation
     *   - op: the operator
     *   - left: the left operand
     *   - right: the right operand (assumed to be a class ptr type operand)
     * @returns: the result value (generally a call value)
     * @throws:
     *   - &ErrorMsg: if the operation is invalid
     */
    fn validateClassRangeOpRight (self, dmut context : &Validator, loc : &Word, op : BinaryOperators, cptr : &ClassPtrType, left : &Value, right : &Value)-> &Value
        throws ErrorMsg
    {
        let contains = copy BoolValue (loc, op == BinaryOperators::TDOT);
        let meth = context:.constructObjectMethodAcc (loc, cptr, right, OpOverrideNames::RANGE_RIGHT);
        let templ = context:.getValueValidator ().validateTemplateCall (alias context, loc, meth, copy [contains]);

        context:.getCallOpValidator ().validate (alias context, loc, templ, copy [left])
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================            COMMON            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Get the max size between two sizeof types (0 being the biggest)
     * */
    fn getMaxSize (self, left : u16, right : u16)-> u16 {
        if (left == 0u16 || right == 0u16) { 0u16 }
        else comparison::max (left, right)
    }

    /**
     * @returns: true if the size of left is bigger than right (0 being the biggest)
     * */
    fn isMax (self, left : u16, right : u16) -> bool {
        if (left == 0u16) return true;
        else if (right == 0u16) return false;
        return left >= right;
    }

    /**
     * Transform the word into a valid operator
     * @assume: the operator is valid
     * @params:
     *   - op: the operator
     * @returns:
     *   - .0: the operator
     *   - .1: true iif the operator is an affectation operator (e.g. +=, -=)
     *   - .2: true iif the operator is a math operator (e.g. +, -)
     *   - .3: true iif the operator is a logical operator (e.g. >=, <=, ==)
     *   - .4: true iif the operator is a range operator (.., ...)
     */
    fn toOperator (self, op : &Word)-> (BinaryOperators, bool, OperatorType)
        throws ErrorMsg
    {
        match op.str {
            BinaryOperators::EQUAL => { (BinaryOperators::EQUAL, true, OperatorType::NONE) }

            BinaryOperators::DIV_AFF => { (BinaryOperators::DIV, true, OperatorType::MATH) }
            BinaryOperators::MINUS_AFF => { (BinaryOperators::MINUS, true, OperatorType::MATH) }
            BinaryOperators::PLUS_AFF => { (BinaryOperators::PLUS, true, OperatorType::MATH) }
            BinaryOperators::STAR_AFF => { (BinaryOperators::STAR, true, OperatorType::MATH) }
            BinaryOperators::PERCENT_AFF => { (BinaryOperators::PERCENT, true, OperatorType::MATH) }

            BinaryOperators::TILDE_AFF => { (BinaryOperators::TILDE, true, OperatorType::SET) }

            BinaryOperators::LEFTD_AFF => { (BinaryOperators::LEFTD, true, OperatorType::BITWISE) }
            BinaryOperators::RIGHTD_AFF => { (BinaryOperators::RIGHTD, true, OperatorType::BITWISE) }

            BinaryOperators::DPIPE => { (BinaryOperators::DPIPE, false, OperatorType::LOGICAL) }
            BinaryOperators::DAND => { (BinaryOperators::DAND, false, OperatorType::LOGICAL) }

            BinaryOperators::INF => { (BinaryOperators::INF, false, OperatorType::COMPARISON) }
            BinaryOperators::SUP => { (BinaryOperators::SUP, false, OperatorType::COMPARISON) }
            BinaryOperators::INF_EQUAL => { (BinaryOperators::INF_EQUAL, false, OperatorType::COMPARISON)  }
            BinaryOperators::SUP_EQUAL => { (BinaryOperators::SUP_EQUAL, false, OperatorType::COMPARISON) }
            BinaryOperators::NOT_EQUAL => { (BinaryOperators::NOT_EQUAL, false, OperatorType::COMPARISON) }
            BinaryOperators::DEQUAL => { (BinaryOperators::DEQUAL, false, OperatorType::COMPARISON) }
            BinaryOperators::CONGRUENT => { (BinaryOperators::CONGRUENT, false, OperatorType::FLOAT_COMPARISON) }
            BinaryOperators::UNCONGRUENT => { (BinaryOperators::UNCONGRUENT, false, OperatorType::FLOAT_COMPARISON) }


            BinaryOperators::OF => { (BinaryOperators::OF, false, OperatorType::TYPE) }
            BinaryOperators::NOT_OF => { (BinaryOperators::NOT_OF, false, OperatorType::TYPE) }

            BinaryOperators::IS => { (BinaryOperators::IS, false, OperatorType::POINTER) }
            BinaryOperators::NOT_IS => { (BinaryOperators::NOT_IS, false, OperatorType::POINTER) }

            BinaryOperators::TDOT => { (BinaryOperators::TDOT, false, OperatorType::RANGE) }
            BinaryOperators::DDOT => { (BinaryOperators::DDOT, false, OperatorType::RANGE) }

            BinaryOperators::LEFTD => { (BinaryOperators::LEFTD, false, OperatorType::BITWISE) }
            BinaryOperators::RIGHTD => { (BinaryOperators::RIGHTD, false, OperatorType::BITWISE) }
            BinaryOperators::PIPE => { (BinaryOperators::PIPE, false, OperatorType::BITWISE) }
            BinaryOperators::XOR => { (BinaryOperators::XOR, false, OperatorType::BITWISE) }
            BinaryOperators::AND => { (BinaryOperators::AND, false, OperatorType::BITWISE) }

            BinaryOperators::IN => { (BinaryOperators::IN, false, OperatorType::SET) }
            BinaryOperators::NOT_IN => { (BinaryOperators::NOT_IN, false, OperatorType::SET) }
            BinaryOperators::TILDE => { (BinaryOperators::TILDE, false, OperatorType::SET) }

            BinaryOperators::PLUS => { (BinaryOperators::PLUS, false, OperatorType::MATH) }
            BinaryOperators::MINUS => { (BinaryOperators::MINUS, false, OperatorType::MATH) }
            BinaryOperators::STAR => { (BinaryOperators::STAR, false, OperatorType::MATH) }
            BinaryOperators::PERCENT => { (BinaryOperators::PERCENT, false, OperatorType::MATH) }
            BinaryOperators::DIV => { (BinaryOperators::DIV, false, OperatorType::MATH) }
            BinaryOperators::DXOR => { (BinaryOperators::DXOR, false, OperatorType::MATH) }

            BinaryOperators::DOT => { (BinaryOperators::DOT, false, OperatorType::FIELD) }
            BinaryOperators::DOT_AND => { (BinaryOperators::DOT_AND, false, OperatorType::FIELD) }

            BinaryOperators::DCOLON => { (BinaryOperators::DCOLON, false, OperatorType::MODULE) }
            _ => {
                throw copy ErrorMsg::fatal (op, format (ValidateErrorMessage::UNDEFINED_BIN_OP_TOK, op.str));
            }
        }
    }

}
