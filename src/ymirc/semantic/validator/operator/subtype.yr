mod ymirc::semantic::validator::operator::subtype;

import ymirc::semantic::validator::visitor;
import ymirc::semantic::validator::errors;
import ymirc::errors::_;
import ymirc::utils::format;
import ymirc::syntax::expression::_;
import ymirc::global::core_;

import ymirc::semantic::symbol::_;
import ymirc::semantic::generator::_;

import ymirc::lexing::word;
import ymirc::lexing::tokens;
import ymirc::syntax::keys;

import ymirc::utils::bigint;
import ymirc::global::state;

import std::algorithm::comparison;
import std::collection::vec;
import std::io;

/**
 * The sub type validator validate the '::' operators with a type as left operand
 */
pub class SubTypeValidator {

    /**
     * Create an empty validator
     */
    pub self () {}

    /**
     * Validate a sub access operation on a type, that must return a value
     * @params: 
     *   - context: the context of the validation
     *   - loc: the location of the access
     *   - left: the left operand
     *   - right: the right operand
     * @returns: a value
     * @throws: 
     *  - &ErrorMsg: if the operation is not valid
     */
    pub def validateValueFromType (self, dmut context : &Validator, loc : &Word, left : &Type, right : &Expression)-> &Value
        throws &ErrorMsg
    {
        match right {
            v : &VarExpr => {
                let field = v.getLoc ().str ();
                if (self.isBasic (field)) {
                    return self.validateBasicSub (alias context, loc, left, field);
                }
            }
        }

        match left {
            clRef : &ClassRefType => {
                return self.validateClassRefType (alias context, loc, clRef, right);
            }
            i : &IntType => {
                return self.validateIntType (alias context, loc, i, right);
            }
            en : &EnumType => {
                return self.validateEnumType (alias context, loc, en, right);
            }
        }

        throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_BIN_ACC_OP, loc.str (), left, right));
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================            BASIC             =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * @returns: true if the sub element can be accessed for all kind of types
     */
    def isBasic (self, name : [c8])-> bool {
        match name {
            Keys::TYPEID => { true }
            _ => { false }
        }
    }        

    /**
     * Validate a sub access that can be used for every type
     * @params: 
     *    - context: the context of the validation
     *    - loc: the location of the operation
     *    - left: the type that is accessed
     *    - right: the name of the sub element that is accessed
     */
    def validateBasicSub (self, dmut _ : &Validator, loc : &Word, left : &Type, right : [c8])-> &Value
        //throws &ErrorMsg
    {
        match right {
            Keys::TYPEID => {
                let content = format ("%", left);
                
                let chType = CharType::new (loc, size-> 8u16);
                let arrType = ArrayType::new (loc, chType, isMutable-> false, size-> int::usize (loc, content.len));
                let slcType = SliceType::new (loc, chType, isMutable-> true);
                
                return SliceValue::new (
                    loc,
                    slcType,
                    StringValue::new (loc, arrType, c8Val-> content, content.len),
                    implicitAlias-> true);
            }
            _ => __pragma!panic ();            
        }
    }    

    /**
     * ================================================================================
     * ================================================================================
     * =========================             INT              =========================
     * ================================================================================
     * ================================================================================
     */


    /**
     * Validate a sub access on an int type
     * @params:
     *     - context: the context of the validation
     *     - loc: the location of the access
     *     - i: the int type being accessed
     *     - right: the right expression of the operation
     * @returns: the result value
     * @throws:
     *    - &ErrorMsg: if there is no valid sub access with 'right' on 'left'
     * */
    def validateIntType (self, dmut _ : &Validator, loc : &Word, i : &IntType, right : &Expression)-> &Value
        throws &ErrorMsg
    {
        match right {
            var : &VarExpr => {
                match var.getLoc ().str () {
                    NativeTypeAttribute::INIT => {
                        return IntValue::new (loc, i, 0us);
                    }
                    NativeTypeAttribute::MAX => {
                        return IntValue::new (loc, i, self.createIntMaxValue (i));
                    }
                    NativeTypeAttribute::MIN => {
                        return IntValue::new (loc, i, self.createIntMinValue (i));
                    }
                }
            }
        }

        throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_BIN_ACC_OP, loc.str (), i, right));
    }

    /**
     * Create the max value for the type 'i'
     * @params:
     *     - i: a int type
     * @returns: the maximum value the int can contain
     * */
    pub def createIntMaxValue (self, i : &IntType)-> &BigInt {
        match (i.getSize (), i.isSigned ()) {
            (0u16, false) => { BigInt::new (2us) ^^ (global::state::instance ().getSizeTypeSize ()) - 1us }
            (0u16, true)  => { (BigInt::new (2us) ^^ (global::state::instance ().getSizeTypeSize () - 1us)) - 1us }
            (size : u16, false) => { BigInt::new (2us) ^^ cast!usize (size) - 1us }
            (size : u16, true) => { (BigInt::new (2us) ^^ cast!usize (size - 1u16)) - 1us }
            _ => {
                __pragma!panic ();
            }
        }
    } catch {
        _ : &BigIntError => {
            __pragma!panic ();
        }
    }

    /**
     * Create the min value for the type 'i'
     * @params:
     *     - i: a int type
     * @returns: the maximum value the int can contain
     * */
    pub def createIntMinValue (self, i : &IntType)-> &BigInt {
        match (i.getSize (), i.isSigned ()) {
            (0u16, false) => { BigInt::new (0us) }
            (0u16, true)  => { 0us - (BigInt::new (2us) ^^ (global::state::instance ().getSizeTypeSize () - 1us)) }
            (_, false)    => { BigInt::new (0us) }
            (size : u16, true) => { 0us - (BigInt::new (2us) ^^ cast!usize (size - 1u16)) }
            _ => {
                __pragma!panic ();
            }
        }
    } catch {
        _ : &BigIntError => {
            __pragma!panic ();
        }
    }


    /**
     * ================================================================================
     * ================================================================================
     * =========================            CLASS             =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a sub access on a class ref type (basically a constructor call, typeinfo, etc.)
     * @params: 
     *     - context: the context of the validation
     *     - loc: the location of the access
     *     - left: the left operand of the operation
     *     - right: the right operand of the operation
     * @returns: the result value
     * @throws:
     *    - &ErrorMsg: if there is no valid sub access with 'right' on 'left'
     */
    def validateClassRefType (self, dmut context : &Validator, loc : &Word, clRef : &ClassRefType, right : &Expression)-> &Value
        throws &ErrorMsg
    {
        match right {
            var : &VarExpr => {
                match var.getLoc ().str () {
                    Keys::TYPEID => { return self.validateTypeId (alias context, loc, clRef); }
                    Keys::TYPEINFO => { return self.validateClassTypeInfoFromType (clRef); }
                    _ => {
                        return self.validateClassCtors (alias context, loc, clRef, name-> var.getLoc ().str ());
                    }
                }
            }            
            _ => {
                throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_BIN_ACC_OP, loc.str (), clRef, right));
            }
        }
    }

    /**
     * @params: 
     *    - clRef: the class ref type
     * @returns: the typeinfo value of the class
     */
    def validateClassTypeInfoFromType (self, clRef : &ClassRefType)-> &Value {
        match clRef.getSymbol ().getTypeInfo () {
            v : &Value => { v }
            _ => {
                __pragma!panic (); // Class is incomplete, check that class validator correctly set typeinfo of the class
            }
        }
    }

    /**
     * Retreive the list of constructors of a class
     * @params: 
     *    - context: the context of the validation
     *    - loc: the location of the access
     *    - clRef: the type of the class whose constructors are accessed
     *    - name: the name of the constructor to access (Keys::NEW or ""s8, means all of them)
     * @returns: the list of constructors (MultSymValue of CtorDelegateValue, or a single CtorDelegateValue)
     * @throws:
     *    - &ErrorMsg: if no constructor are found
     */
    def validateClassCtors (self, dmut context : &Validator, loc : &Word, clRef : &ClassRefType, name : [c8] = ""s8)-> &Value
        throws &ErrorMsg
    {
        let prots = clRef.getCtorProtections ();
        let (inPrv, inProt) = context.getCurrentClassContextProtections (clRef);
        let ptrType = clRef.createInstance (true, true);
        
        let dmut results = Vec!{&Value}::new ();
        let dmut errors = Vec!{&ErrorMsg}::new ();
        for i, ctor in clRef.getCtors () {
            match ctor {
                proto : &CtorPrototypeValue => {
                    if (inPrv || (inProt && prots[i] != MethodProtection::PROT) || prots[i] == MethodProtection::PUB) {
                        if (name == ""s8 || name == Keys::NEW || name == proto.getRename ()) {
                            results:.push (CtorDelegateValue::new (loc, ptrType, proto));
                        }
                    } else if (name == ""s8 || name == Keys::NEW || name == proto.getRename ()) {
                        errors:.push (ErrorMsg::fatal (ctor.getLoc (), format (ValidateErrorMessage::PRIVATE_IN_THIS_CONTEXT, proto)));
                    }                                        
                }
                _ => __pragma!panic ();
            }
        }

        if (results.len () == 0us) {
            if (name != ""s8) {
                throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::NO_CTOR_FOUND, clRef), notes-> errors[]);   
            } else {
                throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::NO_CTOR_FOUND_NAME, name, clRef), notes-> errors[]);
            }
        }
        
        MultSymValue::new (loc, results[], prettyStr-> if (name != ""s8) { name } else { Keys::NEW })
    }


    /**
     * ================================================================================
     * ================================================================================
     * =========================             ENUM             =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a sub access of an enum type (getting a value from the enumeration)
     * @params: 
     *    - context: the context of the validation
     *    - loc: the location of the access
     *    - left: the left operand of the operation
     *    - right: the right operand of the operation
     * @returns: the result value
     * @throws: 
     *    - &ErrorMsg: if there is no valid sub access with 'right' on 'left'
     */
    def validateEnumType (self, dmut context : &Validator, loc : &Word, en : &EnumType, right : &Expression)-> &Value
        throws &ErrorMsg
    {
        match right {
            var : &VarExpr => {
                {   // First check if there is a field with the correct name
                    return self.validateEnumField (alias context, loc, en, var.getLoc ().str ()); 
                } catch {
                    err : &ErrorMsg => { // If not, maybe it is a standard access
                        match self.removeUnders (var.getLoc ().str ()) {         // we remove the underscores 
                            Keys::TYPEID => { return self.validateTypeId (alias context, loc, en); }
                            Keys::MEMBERS => { return self.validateEnumMembers (alias context, loc, en); }
                            _ => throw err;
                        }
                    }       
                }
            }
            _ => {
                throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_BIN_ACC_OP, loc.str (), en, right));
            }
        }
    }

    /**
     * Validate a field access from a enumeration
     * @params: 
     *     - context: the context of the validation
     *     - loc: the location of the access
     *     - en: the enumeration type
     *     - field: the name of the field that is accessed
     * @returns: the result value
     * @throws: 
     *    - &ErrorMsg: if the enum has no field named 'field'
     */
    def validateEnumField (self, dmut context : &Validator, loc : &Word, en : &EnumType, field : [c8])-> &Value
        throws &ErrorMsg
    {
        context;
        let sym = en.getSymbol ();
        match sym.getField (field) {
            NoneValue () => { throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_BIN_ACC_OP, loc.str (), en, field)); }
            val : &Value => { val } 
        }
    }

    /**
     * Create a literal containing all the values of the enumeration
     * @params: 
     *    - context: the context of the validation
     *    - loc: the location of the access
     *    - en: the enumeration type
     * @returns: an slice literal (or an array depending on force type)
     * @throws: 
     *    - &ErrorMsg: if the transformation of the literal into a value did not succeed (should not be possible ?)
     */
    def validateEnumMembers (self, dmut context : &Validator, loc : &Word, en : &EnumType)-> &Value
        throws &ErrorMsg
    {
        context;
        loc;
        en;
        __pragma!fake_throw (&ErrorMsg);
        __pragma!panic ();
    }
    
    /**
     * ================================================================================
     * ================================================================================
     * =========================            COMMON            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Create a string literal containing the typeid of the type
     * @params: 
     *    - context: the context of the validation
     *    - loc: the location of the literal creation
     *    - left: the type whose typeid is returned
     * @returns: a value containing the typeid
     * @throws: 
     *    - &ErrorMsg: if the transformation of the literal into a value did not succeed (should not be possible ?)
     */
    def validateTypeId (self, dmut context : &Validator, loc : &Word, left : &Type)-> &Value
        throws &ErrorMsg
    {    
        let typeid = format ("%", left.clone (isMutable-> false)); // we don't wan't mutable information
        let stringLit = StringExpr::new (loc, end-> loc, typeid, suffix-> Word::new (StringSuffixes::UTF8, loc));

        context:.validateValue (stringLit)
    }


    /**
     * Remove the underscores around a name 
     * @params:
     *    - name: the name that will be transformed
     * @returns: the same name but stripped from '_' on left and right sides
     * @example: 
     * =======================
     * let x = "___test__"s8;
     * assert (self.removeUnders (x) == "test"s8);
     *
     * let y = "___test_2__"s8;
     * assert (self.removeUnders (y) == "test_2"s8);
     * =======================
     */
    def removeUnders (self, name : [c8])-> [c8] {
        let dmut result = StringStream::new ();
        let mut started = false, mut nb = 0us;
        for i in name {
            if (i == '_'c8) {
                nb += 1us;
            } else {
                if (started) {
                    for _ in 0us .. nb {
                        result:.write ('_'c8);
                    }
                }
                result:.write (i);
                started = true;
                nb = 0us;            
            }
        }
        
        result[]
    }
    
    
}
