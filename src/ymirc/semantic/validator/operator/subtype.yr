mod ymirc::semantic::validator::operator::subtype;

import ymirc::semantic::validator::visitor;
import ymirc::semantic::validator::errors;
import ymirc::errors::_;
import ymirc::utils::format;
import ymirc::syntax::expression::operator::binary;
import ymirc::global::core_;

import ymirc::semantic::symbol::_;
import ymirc::semantic::generator::_;

import ymirc::lexing::word;
import ymirc::lexing::tokens;
import ymirc::syntax::keys;
import ymirc::syntax::expression::_;

import std::algorithm::comparison;
import std::collection::vec;
import std::io;

/**
 * The sub type validator validate the '::' operators with a type as left operand
 */
pub class SubTypeValidator {

    /**
     * Create an empty validator
     */
    pub self () {}

    /**
     * Validate a sub access operation on a type, that must return a value
     * @params: 
     *   - context: the context of the validation
     *   - loc: the location of the access
     *   - left: the left operand
     *   - right: the right operand
     * @returns: a value
     * @throws: 
     *  - &ErrorMsg: if the operation is not valid
     */
    pub def validateValueFromType (self, dmut context : &Validator, loc : &Word, left : &Type, right : &Expression)-> &Value
        throws &ErrorMsg
    {
        match left {
            clRef : &ClassRefType => {
                return self.validateClassRefType (alias context, loc, clRef, right);
            }
        }

        throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_BIN_OP, left, right));
    }
            
    /**
     * ================================================================================
     * ================================================================================
     * =========================            CLASS             =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a sub access on a class ref type (basically a constructor call, typeinfo, etc.)
     * @params: 
     *     - context: the context of the validation
     *     - loc: the location of the access
     *     - left: the left operand of the operation
     *     - right: the right operand of the operation
     * @returns: the result value
     * @throws:
     *    - &ErrorMsg: if there is no valid sub access with 'right' on 'left'
     */
    def validateClassRefType (self, dmut context : &Validator, loc : &Word, clRef : &ClassRefType, right : &Expression)-> &Value
        throws &ErrorMsg
    {
        match right {
            var : &VarExpr => {
                match var.getLoc ().str () {
                    Keys::TYPEID => { return self.validateTypeId (alias context, loc, clRef); }
                    Keys::TYPEINFO => { return self.validateClassTypeInfoFromType (clRef); }
                    _ => {
                        return self.validateClassCtors (alias context, loc, clRef, name-> var.getLoc ().str ());
                    }
                }
            }            
            _ => {
                throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_BIN_OP, clRef, right));
            }
        }
    }

    /**
     * @params: 
     *    - clRef: the class ref type
     * @returns: the typeinfo value of the class
     */
    def validateClassTypeInfoFromType (self, clRef : &ClassRefType)-> &Value {
        match clRef.getSymbol ().getTypeInfo () {
            v : &Value => { v }
            _ => {
                __pragma!panic (); // Class is incomplete, check that class validator correctly set typeinfo of the class
            }
        }
    }

    /**
     * Retreive the list of constructors of a class
     * @params: 
     *    - context: the context of the validation
     *    - loc: the location of the access
     *    - clRef: the type of the class whose constructors are accessed
     *    - name: the name of the constructor to access (Keys::NEW or ""s8, means all of them)
     * @returns: the list of constructors (MultSymValue of CtorDelegateValue, or a single CtorDelegateValue)
     * @throws:
     *    - &ErrorMsg: if no constructor are found
     */
    def validateClassCtors (self, dmut context : &Validator, loc : &Word, clRef : &ClassRefType, name : [c8] = ""s8)-> &Value
        throws &ErrorMsg
    {
        let prots = clRef.getCtorProtections ();
        let (inPrv, inProt) = context.getCurrentClassContextProtections (clRef);
        let ptrType = clRef.createInstance (true, true);
        
        let dmut results = Vec!{&Value}::new ();
        let dmut errors = Vec!{&ErrorMsg}::new ();
        for i, ctor in clRef.getCtors () {
            match ctor {
                proto : &CtorPrototypeValue => {
                    if (inPrv || (inProt && prots[i] != MethodProtection::PROT) || prots[i] == MethodProtection::PUB) {
                        if (name == ""s8 || name == Keys::NEW || name == proto.getRename ()) {
                            results:.push (CtorDelegateValue::new (loc, ptrType, proto));
                        }
                    } else if (name == ""s8 || name == Keys::NEW || name == proto.getRename ()) {
                        errors:.push (ErrorMsg::fatal (ctor.getLoc (), format (ValidateErrorMessage::PRIVATE_IN_THIS_CONTEXT, proto)));
                    }                                        
                }
                _ => __pragma!panic ();
            }
        }

        if (results.len () == 0us) {
            if (name != ""s8) {
                throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::NO_CTOR_FOUND, clRef), notes-> errors[]);   
            } else {
                throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::NO_CTOR_FOUND_NAME, name, clRef), notes-> errors[]);
            }
        }
        
        MultSymValue::new (loc, results[], prettyStr-> if (name != ""s8) { name } else { Keys::NEW })
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================            COMMON            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Create a string literal containing the typeid of the type
     * @params: 
     *    - context: the context of the validation
     *    - loc: the location of the literal creation
     *    - left: the type whose typeid is returned
     * @returns: a value containing the typeid
     * @throws: 
     *    - &ErrorMsg: if the transformation of the literal into a value did not succeed (should not be possible ?)
     */
    def validateTypeId (self, dmut context : &Validator, loc : &Word, left : &Type)-> &Value
        throws &ErrorMsg
    {    
        let typeid = format ("%", left.clone (isMutable-> false)); // we don't wan't mutable information
        let stringLit = StringExpr::new (loc, end-> loc, typeid, suffix-> Word::new (StringSuffixes::UTF8, loc));

        context:.validateValue (stringLit)
    }
    
    
}
