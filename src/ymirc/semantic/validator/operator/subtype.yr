in subtype;

use ymirc::semantic::validator::{visitor, errors, template::_};
use ymirc::semantic::declarator::errors;

use ymirc::errors::_;
use ymirc::utils::format;

use ymirc::syntax::{_,
                    declaration::_,
                    expression::{_, literal::_, macro_::_, operator::_, template::_}};

use ymirc::lexing::{word, tokens, keys};
use ymirc::global::{core_, state};
use ymirc::utils::{bigint, bigfloat};

use ymirc::semantic::{generator::_, symbol::_};
use ymirc::semantic::generator::{value::_, type::_};
use ymirc::semantic::generator::type::{_,
                                       custom::_,
                                       native::{_, scalar::_, compound::_},
                                       temporary::_};

use ymirc::semantic::generator::value::{_,
                                        construct::{_, delegate::_},
                                        literal::_,
                                        memory::_,
                                        operator::{_, binary::_, call::_, fields::_, map::_, slice::_, unary::_},
                                        operator::map::iteration::_,
                                        prototypes::_,
                                        scope::_,
                                        syntax::_,
                                        template::_};

use std::stream;


/**
 * The sub type validator validate the '::' operators with a type as left operand
 */
pub record SubTypeValidator {

    /**
     * Create an empty validator
     */
    pub self () {}

    /**
     * Validate a sub access operation on a type, that must return a value
     * @params: 
     *   - context: the context of the validation
     *   - loc: the location of the access
     *   - left: the left operand
     *   - right: the right operand
     * @returns: a value
     * @throws: 
     *  - &ErrorMsg: if the operation is not valid
     */
    pub fn validateValueFromType (self, dmut context : &Validator, loc : &Word, left : &Type, right : &Expression)-> &Value
        throws ErrorMsg
    {
        {
            match left {
                clRef : &ClassRefType => {
                    return self.validateClassRefValue (alias context, loc, clRef, right);
                }
                cp : &ClassPtrType => {
                    return self.validateClassPtrValue (alias context, loc, cp, right);
                }
                f : &FloatType => {
                    return self.validateFloatValue (alias context, loc, f, right);
                }
                i : &IntType => {
                    return self.validateIntValue (alias context, loc, i, right);
                }
                b : &BoolType => {
                    return self.validateBoolValue (alias context, loc, b, right);
                }
                c : &CharType => {
                    return self.validateCharValue (alias context, loc, c, right);
                }
                en : &EnumType => {
                    return self.validateEnumValue (alias context, loc, en, right);
                }
                p : &PointerType => {
                    return self.validatePointerValue (alias context, loc, p, right);
                }
                t : &TupleType => {
                    return self.validateTupleValue (alias context, loc, t, right);
                }
                r : &RangeType => {
                    return self.validateRangeValue (alias context, loc, r, right);
                }
                a : &ArrayType => {
                    return self.validateArrayValue (alias context, loc, a, right);
                }
                s : &SliceType => {
                    return self.validateSliceValue (alias context, loc, s, right);
                }
                o : &OptionType => {
                    return self.validateOptionValue (alias context, loc, o, right);
                }
                m : &MapType => {
                    return self.validateMapValue (alias context, loc, m, right);
                }
                _ => {
                    throw copy ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_BIN_ACC_OP, loc.str, left, right));
                }
            }
        } catch {
            err : &ErrorMsg => {
                match right {
                    v : &VarExpr => {
                        let field = v.getLoc ().str;
                        return self.validateBasicSub (alias context, loc, left, field, err);
                    }
                }

                throw err;
            }
        }
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================            BASIC             =========================
     * ================================================================================
     * ================================================================================
     */


    /**
     * Validate a sub access that can be used for every type
     * @params: 
     *    - context: the context of the validation
     *    - loc: the location of the operation
     *    - left: the type that is accessed
     *    - right: the name of the sub element that is accessed
     */
    fn validateBasicSub (self, dmut context : &Validator, loc : &Word, left : &Type, right : [c8], err : &ErrorMsg)-> &Value
        throws ErrorMsg
    {
        {
            match self.removeUnders (right) {
                Keys::TYPEID => {
                    let content = format ("%", left);
                    return makeStringSliceValue (loc, content)
                }
                Keys::TYPEINFO => {
                    return context:.getTypeInfoValidator ().validate (alias context, loc, left);
                }
                Keys::FIELDINFO => {
                    return context:.getTypeInfoValidator ().validateFieldInfos (alias context, loc, left);
                }
                Keys::SIZEOF => {
                    return context:.getSizeofValidator ():.validate (alias context, loc, left);
                }
            }
        } catch {
            innerErr : &ErrorMsg => {
                throw err.withNote (notes-> copy [innerErr]);
            }
        }

        throw err;
    }    

    /*!
     * ================================================================================
     * ================================================================================
     * =========================             INT              =========================
     * ================================================================================
     * ================================================================================
     */


    /**
     * Validate a sub access on an int type
     * @params:
     *     - context: the context of the validation
     *     - loc: the location of the access
     *     - i: the int type being accessed
     *     - right: the right expression of the operation
     * @returns: the result value
     * @throws:
     *    - &ErrorMsg: if there is no valid sub access with 'right' on 'left'
     * */
    fn validateIntValue (self, dmut context : &Validator, loc : &Word, i : &IntType, right : &Expression)-> &Value
        throws ErrorMsg
    {
        match right {
            var : &VarExpr => {
                match self.removeUnders (var.getLoc ().str) {
                    NativeTypeAttribute::INIT => {
                        return copy IntValue (loc, i, 0us);
                    }
                    NativeTypeAttribute::MAX => {
                        return copy IntValue (loc, i, context:.getCompileTimeInterpreter ().createIntMaxValue (i));
                    }
                    NativeTypeAttribute::MIN => {
                        return copy IntValue (loc, i, context:.getCompileTimeInterpreter ().createIntMinValue (i));
                    }
                }
            }
        }

        throw copy ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_BIN_ACC_OP, loc.str, i, right));
    }


    /*!
     * ================================================================================
     * ================================================================================
     * =========================             FLOAT              =======================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a sub access on a float type
     * @params:
     *    - context: the context of the validation
     *    - loc: the location of the access
     *    - f: the floa type being accessed
     *    - right: the right expression of the operation
     * @returns: the result value
     * @throws:
     *    - &ErrorMsg: if there is no valid subaccess on 'f' with 'right'
     * */
    fn validateFloatValue (self, dmut context : &Validator, loc : &Word, f : &FloatType, right : &Expression)-> &Value
        throws ErrorMsg
    {
        match right {
            var : &VarExpr => {
                match self.removeUnders (var.getLoc ().str) {
                    NativeTypeAttribute::INIT => {
                        return copy FloatValue (loc, f, context:.getCompileTimeInterpreter ().createFloatNanValue (f));
                    }
                    NativeTypeAttribute::MAX => {
                        return copy FloatValue (loc, f, context:.getCompileTimeInterpreter ().createFloatMaxValue (f));
                    }
                    NativeTypeAttribute::MIN => {
                        return copy FloatValue (loc, f, context:.getCompileTimeInterpreter ().createFloatMinValue (f));
                    }
                    NativeTypeAttribute::NAN => {
                        return copy FloatValue (loc, f, context:.getCompileTimeInterpreter ().createFloatNanValue (f));
                    }
                    NativeTypeAttribute::INF => {
                        return copy FloatValue (loc, f, context:.getCompileTimeInterpreter ().createFloatInfValue (f));
                    }
                    NativeTypeAttribute::DIG => {
                        return copy IntValue (loc, copy IntType (loc, size-> 32u16, signed-> false), context:.getCompileTimeInterpreter ().createFloatDigValue (f));
                    }
                    NativeTypeAttribute::MANT_DIG => {
                        return copy IntValue (loc, copy IntType (loc, size-> 32u16, signed-> false), context:.getCompileTimeInterpreter ().createFloatMantDigValue (f));
                    }
                    NativeTypeAttribute::MAX_10_EXP => {
                        return copy IntValue (loc, copy IntType (loc, size-> 32u16, signed-> true), context:.getCompileTimeInterpreter ().createFloatMax10ExpValue (f));
                    }
                    NativeTypeAttribute::MIN_10_EXP => {
                        return copy IntValue (loc, copy IntType (loc, size-> 32u16, signed-> true), copy BigInt (context:.getCompileTimeInterpreter ().createFloatMin10ExpValue (f)));
                    }
                    NativeTypeAttribute::MAX_EXP => {
                        return copy IntValue (loc, copy IntType (loc, size-> 32u16, signed-> true), context:.getCompileTimeInterpreter ().createFloatMax2ExpValue (f));
                    }
                    NativeTypeAttribute::MIN_EXP => {
                        return copy IntValue (loc, copy IntType (loc, size-> 32u16, signed-> true), copy BigInt (context:.getCompileTimeInterpreter ().createFloatMin2ExpValue (f)));
                    }
                    NativeTypeAttribute::EPSILON => {
                        return copy FloatValue (loc, f, context:.getCompileTimeInterpreter ().createFloatEpsilonValue (f));
                    }
                }
            }
        }

        throw copy ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_BIN_ACC_OP, loc.str, f, right));
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================             BOOL              ========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a sub access on an bool type
     * @params:
     *     - context: the context of the validation
     *     - loc: the location of the access
     *     - b: the bool type being accessed
     *     - right: the right expression of the operation
     * @returns: the result value
     * @throws:
     *    - &ErrorMsg: if there is no valid sub access with 'right' on 'left'
     * */
    fn validateBoolValue (self, dmut _ : &Validator, loc : &Word, b : &BoolType, right : &Expression)-> &Value
        throws ErrorMsg
    {
        match right {
            var : &VarExpr => {
                match self.removeUnders (var.getLoc ().str) {
                    NativeTypeAttribute::INIT => {
                        return copy BoolValue (loc, b, false);
                    }
                }
            }
        }

        throw copy ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_BIN_ACC_OP, loc.str, b, right));
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================             CHAR              ========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a sub access on an char type
     * @params:
     *     - context: the context of the validation
     *     - loc: the location of the access
     *     - c: the char type being accessed
     *     - right: the right expression of the operation
     * @returns: the result value
     * @throws:
     *    - &ErrorMsg: if there is no valid sub access with 'right' on 'left'
     * */
    fn validateCharValue (self, dmut _ : &Validator, loc : &Word, c : &CharType, right : &Expression)-> &Value
        throws ErrorMsg
    {
        match right {
            var : &VarExpr => {
                match self.removeUnders (var.getLoc ().str) {
                    NativeTypeAttribute::INIT => {
                        return copy CharValue (loc, c, 0u32);
                    }
                }
            }
        }

        throw copy ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_BIN_ACC_OP, loc.str, c, right));
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================            CLASS             =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a sub access on a class ref type (basically a constructor call, etc..)
     * @params:
     *     - context: the context of the validation
     *     - loc: the location of the access
     *     - left: the left operand of the operation
     *     - right: the right operand of the operation
     * @returns: the result value
     * @throws:
     *    - &ErrorMsg: if there is no valid sub access with 'right' on 'left'
     */
    fn validateClassRefValue (self, dmut context : &Validator, loc : &Word, clRef : &ClassRefType, right : &Expression)-> &Value
        throws ErrorMsg
    {
        match right {
            var : &VarExpr => {
                return self.validateClassCtors (alias context, loc, clRef, name-> var.getLoc ().str);
            }
        }


        throw copy ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_BIN_ACC_OP, loc.str, clRef, right));
    }

    /**
     * Validate a sub access on a class ref type (basically a constructor call, etc..)
     * @params:
     *     - context: the context of the validation
     *     - loc: the location of the access
     *     - left: the left operand of the operation
     *     - right: the right operand of the operation
     * @returns: the result value
     * @throws:
     *    - &ErrorMsg: if there is no valid sub access with 'right' on 'left'
     */
    fn validateClassPtrValue (self, dmut context : &Validator, loc : &Word, cl : &ClassPtrType, right : &Expression)-> &Value
        throws ErrorMsg
    {
        if (cl.isStruct ()) {
            match right {
                var : &VarExpr => {
                    return self.validateClassCtors (alias context, loc, cl.getInner (), name-> var.getLoc ().str);
                }
            }
        }

        throw copy ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_BIN_ACC_OP, loc.str, cl, right));
    }

    /**
     * Retreive the list of constructors of a class
     * @params: 
     *    - context: the context of the validation
     *    - loc: the location of the access
     *    - clRef: the type of the class whose constructors are accessed
     *    - name: the name of the constructor to access (Keys::NEW or "", means all of them)
     * @returns: the list of constructors (MultSymValue of CtorDelegateValue, or a single CtorDelegateValue)
     * @throws:
     *    - &ErrorMsg: if no constructor are found
     */
    pub fn validateClassCtors (self, dmut context : &Validator, loc : &Word, clRef : &ClassRefType, name : [c8] = "", selfParam : &Value = UNIT_VALUE, nextDg : &Value = UNIT_VALUE, fromSubType : bool = false)-> &Value
        throws ErrorMsg
    {
        if !clRef.hasTypeInfo () {
            if let dmut sym : &ClassSymbol = context:.getClassFromRef (clRef.getSymbol ()) {
                context:.getClassValidator ():.validateClassLayout (alias context, alias sym);
            } else panic;
        }

        let isBasicCtor = (name == "");
        let prots = clRef.getCtorProtections ();
        let tmpProts = clRef.getTemplateCtorProtections ();
        let (inPrv, inProt) = context.getCurrentClassContextProtections (clRef);
        let ptrType = clRef.createInstance (true, true);

        let mut results : [&Value] = [];
        let mut errors : [&ErrorMsg] = [];
        for i, ctor in clRef.getCtors () {
            match ctor {
                proto : &CtorPrototypeValue => {
                    if (inPrv || (inProt && prots[i] == MethodProtection::PROT) || prots[i] == MethodProtection::PUB) {
                        if (isBasicCtor || name == proto.getRename ()) {
                            results ~= [copy CtorDelegateValue (loc, ptrType, proto, instance-> selfParam, nextCtor-> nextDg)];
                        }
                    } else if (isBasicCtor || name == proto.getRename ()) {
                        errors ~= [copy ErrorMsg::fatal (ctor.getLoc (), format (DeclareErrorMessage::PRIVATE_IN_THIS_CONTEXT, proto))];
                    }
                }
                _ => panic;
            }
        }

        for i, ctor in clRef.getTemplateCtors () {
            if (inPrv || (inProt && tmpProts [i] == MethodProtection::PROT) || tmpProts [i] == MethodProtection::PUB) {
                if (isBasicCtor || name == ctor.getRename ()) {
                    results ~= [copy CtorDelegateTemplateValue (loc, ptrType, ctor, instance-> selfParam, nextCtor-> nextDg)];
                }
            } else if (isBasicCtor || name == ctor.getRename ()) {
                errors ~= [copy ErrorMsg::fatal (ctor.getLoc (), format (DeclareErrorMessage::PRIVATE_IN_THIS_CONTEXT, ctor))];
            }
        }

        if (results.len == 0us) {
            if (name == "") {
                throw copy ErrorMsg::fatal (loc, format (ValidateErrorMessage::NO_CTOR_FOUND, clRef), notes-> errors);
            } else {
                throw copy ErrorMsg::fatal (loc, format (ValidateErrorMessage::NO_CTOR_FOUND_NAME, name, clRef), notes-> errors);
            }
        }

        if (!fromSubType && clRef.getSymbol ().isAbstract ()) {
            throw copy ErrorMsg::fatal (loc, format (ValidateErrorMessage::CONSTRUCT_ABSTRACT_CLASS, clRef));
        }

        copy MultSymValue (loc, results, prettyStr-> if (name != "") { name } else { Keys::NEW })
    }


    /*!
     * ================================================================================
     * ================================================================================
     * =========================             ENUM             =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a sub access of an enum type (getting a value from the enumeration)
     * @params: 
     *    - context: the context of the validation
     *    - loc: the location of the access
     *    - left: the left operand of the operation
     *    - right: the right operand of the operation
     * @returns: the result value
     * @throws: 
     *    - &ErrorMsg: if there is no valid sub access with 'right' on 'left'
     */
    fn validateEnumValue (self, dmut context : &Validator, loc : &Word, en : &EnumType, right : &Expression)-> &Value
        throws ErrorMsg
    {
        match right {
            var : &VarExpr => {
                {   // First check if there is a field with the correct name
                    return self.validateEnumField (alias context, loc, en, var.getLoc ().str);
                } catch {
                    err : &ErrorMsg => { // If not, maybe it is a standard access
                        match self.removeUnders (var.getLoc ().str) {         // we remove the underscores
                            Keys::MEMBERS => { return self.validateEnumMembers (alias context, loc, en); }
                            _ => throw err;
                        }
                    }       
                }
            }
            _ => {
                throw copy ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_BIN_ACC_OP, loc.str, en, right));
            }
        }
    }

    /**
     * Validate a field access from a enumeration
     * @params: 
     *     - context: the context of the validation
     *     - loc: the location of the access
     *     - en: the enumeration type
     *     - field: the name of the field that is accessed
     * @returns: the result value
     * @throws: 
     *    - &ErrorMsg: if the enum has no field named 'field'
     */
    pub fn validateEnumField (self, dmut context : &Validator, loc : &Word, en : &EnumType, field : [c8])-> &Value
        throws ErrorMsg
    {
        context;
        let sym = en.getSymbol ();
        match sym.getField (field) {
            UnitValue () => { throw copy ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_BIN_ACC_OP, loc.str, en, field)); }
            val : &Value => { copy EnumFieldAccessValue (loc, en, value-> val.clone (), fieldName-> field) }
        }
    }

    /**
     * Create a literal containing all the values of the enumeration
     * @params: 
     *    - context: the context of the validation
     *    - loc: the location of the access
     *    - en: the enumeration type
     * @returns: an slice literal (or an array depending on force type)
     * @throws: 
     *    - &ErrorMsg: if the transformation of the literal into a value did not succeed (should not be possible ?)
     */
    fn validateEnumMembers (self, dmut context : &Validator, loc : &Word, en : &EnumType)-> &Value
        throws ErrorMsg
    {
        let mut parameters : [&Value] = [];
        let mut inner : &Type = en;
        let sym = en.getSymbol ();

        for f in sym.getAllFields () {
            let val = copy EnumFieldAccessValue (loc, en, value-> f._1.clone (), fieldName-> f._0);
            inner = context:.getLiteralValidator ().addArrayType (alias context, val, ref parameters, inner);
        }

        let arrType = copy ArrayType (loc, inner, parameters.len, isMutable-> true);
        copy ArrayValue (loc, arrType, parameters)
    }

    /*!
     * ================================================================================
     * ================================================================================
     * ========================             POINTER             =======================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a sub access of a pointer type that generates a value
     * @params:
     *     - context: the context of the validation
     *     - loc: the locaiton of the access
     *     - left: the left operand of the operation
     *     - right: the right operand of the operation
     * @returns: a value
     * @throws:
     *     - &ErrorMsg: if the access is not valid
     * */
    fn validatePointerValue (self, dmut _ : &Validator, loc : &Word, p : &PointerType, right : &Expression)-> &Value
        throws ErrorMsg
    {
        match right {
            var : &VarExpr => {
                match self.removeUnders (var.getLoc ().str) {
                    NativeTypeAttribute::INIT => { return copy NullValue (loc, p); }
                }
            }
        }

        throw copy ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_BIN_ACC_OP, loc.str, p, right));
    }

    /*!
     * ================================================================================
     * ================================================================================
     * ==========================            TUPLE            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a sub access on a tuple type that generates a value
     * @params:
     *     - context: the context of the validation
     *     - loc: the location of the access
     *     - left: the tuple type, left operand
     *     - right: the right operand
     * @returns: a value
     * */
    fn validateTupleValue (self, dmut context : &Validator, loc : &Word, p : &TupleType, right : &Expression)-> &Value
        throws ErrorMsg
    {
        match right {
            var : &VarExpr => {
                match self.removeUnders (var.getLoc ().str) {
                    NativeTypeAttribute::INIT => {
                        let mut v : [&Value] = [];
                        {
                            for i in p.getInners () match i {
                                c : &ClassRefType => {
                                    let ctor = self.validateClassCtors (alias context, loc, c);
                                    v ~= [context:.getCallOpValidator ().validate (alias context, loc, ctor, [])];
                                }
                                c : &ClassPtrType => {
                                    let ctor = self.validateClassCtors (alias context, loc, c.getInner ());
                                    v ~= [context:.getCallOpValidator ().validate (alias context, loc, ctor, [])];
                                }
                                _ => {
                                    let val = self.validateValueFromType (alias context, loc, i, right);
                                    v ~= [val];
                                }
                            }
                        } catch {
                            err : &ErrorMsg => {
                                throw err.withNote (copy [copy ErrorMsg::note (loc, format (ValidateErrorMessage::FOR_TYPE, p))]);
                            }
                        }

                        return copy TupleValue (loc, p, v);
                    }
                    NativeTypeAttribute::ARITY => {
                        return makeIntValue (loc, p.getInners ().len);
                    }
                }
            }
        }

        throw copy ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_BIN_ACC_OP, loc.str, p, right));
    }

    /*!
     * ================================================================================
     * ================================================================================
     * ==========================            RANGE            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a sub access on a range type that generates a value
     * @params:
     *    - context: the context of the validation
     *    - loc: the location of the access
     *    - r: the range type
     *    - right: the right operand
     * @returns: a value
     * */
    fn validateRangeValue (self, dmut context : &Validator, loc : &Word, r : &RangeType, right : &Expression)-> &Value
        throws ErrorMsg
    {
        match right {
            var : &VarExpr => {
                match self.removeUnders (var.getLoc ().str) {
                    NativeTypeAttribute::INIT => {
                        let val = self.validateValueFromType (alias context, loc, r.getInners ()[0], right);
                        let bin = copy BinaryExpr (loc.locate (Tokens::DDOT),
                                                   copy ValueWrapperExpr (loc, val),
                                                   copy ValueWrapperExpr (loc, val));

                        return context:.validateValue (bin);
                    }
                }
            }
        }

        throw copy ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_BIN_ACC_OP, loc.str, r, right));
    }

    /*!
     * ================================================================================
     * ================================================================================
     * ==========================            ARRAY            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a sub type access on an array type
     * @params:
     *    - loc: the location of the access
     *    - a: the array type being accessed
     *    - right: the right operand of the access
     * */
    fn validateArrayValue (self, dmut context : &Validator, loc : &Word, a : &ArrayType, right : &Expression)-> &Value
        throws ErrorMsg
    {
        match right {
            var : &VarExpr => {
                match self.removeUnders (var.getLoc ().str) {
                    NativeTypeAttribute::INIT => {
                        let val = self.validateValueFromType (alias context, loc, a.getInners ()[0], right);
                        let tabSize = a.getLen ();

                        return copy ArrayAllocValue::stat (a.getLoc (), a, val, makeIntValue (loc, tabSize));
                    }
                    SliceKeys::LEN => {
                        return makeIntValue (loc, a.getLen ());
                    }
                }
            }
        }

        throw copy ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_BIN_ACC_OP, loc.str, a, right));
    }

    /*!
     * ================================================================================
     * ================================================================================
     * ==========================            SLICE            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a sub type access on an slice type
     * @params:
     *    - loc: the location of the access
     *    - s: the slice type being accessed
     *    - right: the right operand of the access
     * */
    fn validateSliceValue (self, dmut _ : &Validator, loc : &Word, s : &SliceType, right : &Expression)-> &Value
        throws ErrorMsg
    {
        match right {
            var : &VarExpr => {
                match self.removeUnders (var.getLoc ().str) {
                    NativeTypeAttribute::INIT => {
                        let n = copy NullValue (loc);
                        return copy SliceCtorValue (loc, s, n, n,
                                                    makeIntValue (loc, 0us), isImplicitAlias-> true);
                    }
                }
            }
        }

        throw copy ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_BIN_ACC_OP, loc.str, s, right));
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================            OPTIONS            ========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a sub type access on an option type
     * @params:
     *    - loc: the location of the access
     *    - o: the option type being accessed
     *    - right: the right operand of the access
     * */
    fn validateOptionValue (self, dmut _ : &Validator, loc : &Word, o : &OptionType, right : &Expression)-> &Value
        throws ErrorMsg
    {
        match right {
            var : &VarExpr => {
                match self.removeUnders (var.getLoc ().str) {
                    NativeTypeAttribute::INIT => {
                        return copy ErrOptionValue (loc, type-> o);
                    }
                }
            }
        }

        throw copy ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_BIN_ACC_OP, loc.str, o, right));
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ======================================          MAP          =======================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Validate a sub type access on a map type
     * @params:
     *    - loc: the location of the access
     *    - m: the map type being accessed
     *    - right: the right operand of the access
     * */
    fn validateMapValue (self, dmut _ : &Validator, loc : &Word, m : &MapType, right : &Expression)-> &Value
        throws ErrorMsg
    {
        match right {
            var : &VarExpr => {
                match self.removeUnders (var.getLoc ().str) {
                    NativeTypeAttribute::INIT => {
                        return copy MapValue (loc, type-> m, [], []);
                    }
                }
            }
        }

        throw copy ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_BIN_ACC_OP, loc.str, m, right));
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================            COMMON            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Remove the underscores around a name 
     * @params:
     *    - name: the name that will be transformed
     * @returns: the same name but stripped from '_' on left and right sides
     * @example: 
     * =======================
     * let x = "___test__";
     * assert (self.removeUnders (x) == "test");
     *
     * let y = "___test_2__";
     * assert (self.removeUnders (y) == "test_2");
     * =======================
     */
    pub fn removeUnders (self, name : [c8])-> [c8] {
        let dmut result = copy StringStream ();
        let mut started = false, mut nb = 0us;
        for i in name {
            if (i == '_'c8) {
                nb += 1us;
            } else {
                if (started) {
                    for _ in 0us .. nb {
                        result:.write ('_'c8);
                    }
                }
                result:.write (i);
                started = true;
                nb = 0us;            
            }
        }
        
        result[]
    }
    
    
}
