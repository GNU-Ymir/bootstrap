mod ymirc::semantic::validator::operator::index;

import ymirc::global::core_;
import ymirc::global::state;

import ymirc::semantic::validator::visitor;
import ymirc::semantic::validator::errors;
import ymirc::semantic::validator::scores;
import ymirc::errors::_;
import ymirc::utils::format;
import ymirc::syntax::expression::_;
import ymirc::semantic::generator::value::_;
import ymirc::semantic::generator::type::_;
import ymirc::semantic::generator::value::expandvalue;
import ymirc::lexing::word;
import ymirc::lexing::tokens;
import ymirc::syntax::keys;
import ymirc::utils::bigint;

import std::collection::vec;
import std::io;

/**
 * The index validator is used to validate MultOpExpr
 * It is a class validator because index operations are complex
 */
pub class IndexOpValidator {

    /**
     * Create an empty validator     
     */
    pub self () {}

    /**
     * Validate an index expression
     * @params: 
     *  - context: the context of the validation
     *  - mult: the mult operator to validate
     * @returns: a value
     * @throws: 
     *    - &ErrorMsg: if the validation failed
     */
    pub fn validate (self, dmut context : &Validator, mult : &MultOperatorExpr) -> &Value
        throws &ErrorMsg
    {        
        let left = UniqValue::new (mult.getLoc (), context:.validateValue (mult.getLeft ()));
        context:.enterDollar (left);
        {
            let (rights, rTypes) = self.validateRightOperands (alias context, mult.getRights ());

            match left.getType () {
                ArrayType () => { self.validateArray (alias context, mult.getLoc (), left, rights, rTypes) }
                SliceType () => { self.validateSlice (alias context, mult.getLoc (), left, rights, rTypes) }
                PointerType () => { self.validatePointer (alias context, mult.getLoc (), left, rights, rTypes) }
                _ => {
                    throw ErrorMsg::fatal (mult.getLoc (), format (ValidateErrorMessage::UNDEFINED_INDEX_OP, left.getType (), rTypes));
                }
            }
        } exit {
            context:.exitDollar ();
        }
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================            ARRAY             =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a index access on array
     * @params: 
     *   - context: the context of the validation
     *   - loc: the location of the index
     *   - left: the left operand of the operation (assumed to be of array type)
     *   - rights: the list of right operand of the operation
     * @returns: the result value
     * @throws: 
     *    - &ErrorMsg: if this operation is impossible
     */
    fn validateArray (self, dmut context : &Validator, loc : &Word, left : &Value, rights : [&Value], rTypes : [&Type])-> &Value
        throws &ErrorMsg
    {
        if (rTypes.len == 1us && rTypes [0].isOf!{&IntType} ()) {
            return self.validateArrayInteger (alias context, loc, left, rights [0]);
        }

        throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_INDEX_OP, left.getType (), rTypes));
    }

    /**
     * Validate an index access on an array value using an integer value
     * @params:
     *    - context: the context of the validation
     *    - loc: the location of the index
     *    - left: the left operand (assumed to be of type array)
     *    - right: the right operand (assumed to be of type int)
     * @returns: the access value
     * @throws:
     *    - &ErrorMsg: if this operation is impossible
     */
    fn validateArrayInteger (self, dmut context : &Validator, loc : &Word, left : &Value, right : &Value)-> &Value
        throws &ErrorMsg
    {
        let sizeType = IntType::new (loc, size-> 0u16, signed-> false);
        let innerType = left.getType ().asOf!{&ArrayType} ().getInners ()[0us];
        let arraySize = left.getType ().asOf!{&ArrayType} ().getSize ();

        // Cte verification if possible, to check wether the index is positive and does not overflow the array size
        let cteTest = self.verifyNotNegativeInt (alias context, loc, left.getType (), right, maximum-> arraySize.getValue ());

        // Index is cast into a usize (as it will have to, for pointer arithmetic)
        let index = UniqValue::new (loc, match right.getType ().asOf!{&IntType} ().getSize () {
            0us => { right }
            _ => { cast!{&Value} (CastValue::new (loc, sizeType, right)) }
        });

        let arrayAccess = ArrayAccessValue::new (loc, innerType, left, index);

        // If the test cannot be made in cte, then add a runtime check
        if (!cteTest) {
            let cmp = CmpIntOperatorValue::new (loc, BinaryOperators::INF_EQUAL, arraySize, index);
            let cond = self.createOutOfArrayTest (alias context, loc, cmp);

            BlockValue::new (loc, innerType, [cond, arrayAccess], isSet-> true)
        } else {
            arrayAccess
        }
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================            SLICE             =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate an index access on a slice value
     * @params:
     *    - context: the context of the validation
     *    - loc: the location of the validation
     *    - left: the left operand of the access (assumed to be of type slice)
     *    - rights: the right operands of the access
     *    - rTypes: the types of the right operands
     * @returns: The slice access value
     * @throws: 
     *   - &ErrorMsg: if the access is impossible
     */
    fn validateSlice (self, dmut context : &Validator, loc : &Word, left : &Value, rights : [&Value], rTypes : [&Type])-> &Value
        throws &ErrorMsg
    {
        if (rTypes.len == 1us && rTypes [0].isOf!{&IntType} ()) {
            return self.validateSliceInteger (alias context, loc, left, rights [0]);
        } else if (rTypes.len == 1us && rTypes [0].isOf!{&RangeType} ()) {
            return self.validateSliceRange (alias context, loc, left, rights [0]);
        }

        throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_INDEX_OP, left.getType (), rTypes));
    }

    /**
     * Validate a index operation on a slice using a single int value
     * @params:
     *    - context: the context of the validation
     *    - loc: the location of the access
     *    - left: the left operand (of type slice)
     *    - right: the right operand (of type int)
     * @returns: an access value
     * @throws:
     *    - &ErrorMsg: if the access is impossible
     */
    fn validateSliceInteger (self, dmut context : &Validator, loc : &Word, left : &Value, right : &Value)-> &Value
        throws &ErrorMsg
    {        
        let sizeType = IntType::new (loc, size-> 0u16, signed-> false);
        let type = left.getType ().asOf!{&SliceType} ().getInners ()[0us];

        // Cte verification if possible, to check wether the index is positive
        let cteTest = self.verifyNotNegativeInt (alias context, loc, left.getType (), right);

        // Index is cast into a usize (as it will have to, for pointer arithmetic)
        let index = UniqValue::new (loc, match right.getType ().asOf!{&IntType} ().getSize () {
            0us => { right }
            _ => { cast!{&Value} (CastValue::new (loc, sizeType, right)) }
        });

        // If the test cannot be made at cte, then add a runtime check
        if (!cteTest) {
            let len = StructFieldAccessValue::new (loc, sizeType, left, SliceKeys::LEN);
            
            let cmp = CmpIntOperatorValue::new (loc, BinaryOperators::INF_EQUAL, len, index);            
            let cond = self.createOutOfArrayTest (alias context, loc, cmp);
            let sliceAccess = SliceAccessValue::new (loc, type, left, index);
            
            BlockValue::new (loc, type, [cond, sliceAccess], isSet-> true)            
        } else {
            SliceAccessValue::new (loc, type, left, index)
        }
    }

    /**
     * Verify that the index is not negative (if CTE)
     * @returns: true, if the test is cte
     */
    fn verifyNotNegativeInt (self, dmut context : &Validator, loc : &Word, leftType : &Type, right : &Value, maximum : &BigInt = BigInt::new (u64::max))-> bool
        throws &ErrorMsg
    {
        let (isNegative, isTooBig, val) = {
            let i = context:.getCompileTimeInterpreter ().computeInt (right);
            (i < 0, i >= maximum, i)
        } catch {
            // The value is not cte
            _ => { return false; }
        };

        if (isNegative) { // The cte value is negative, that cannot happen when used as index
            throw ErrorMsg::fatal (loc, end-> right.getLoc (), format (ValidateErrorMessage::NEGATIVE_INT_INDEX, leftType, val));
        }

        if (isTooBig) { // The cte value is bigger than the array length
            throw ErrorMsg::fatal (loc, end-> right.getLoc (), format (ValidateErrorMessage::ARRAY_OVERFLOW, maximum, val));
        }

        true
    }
    
    /**
     * Validate a index operation on a slice using a single range value
     * @params:
     *    - context: the context of the validation
     *    - loc: the location of the access
     *    - left: the left operand (of type slice)
     *    - right: the right operand (of type range)
     * @returns: an access value
     * @throws:
     *    - &ErrorMsg: if the access is impossible
     */
    fn validateSliceRange (self, dmut context : &Validator, loc : &Word, slice : &Value, right : &Value)-> &Value
        throws &ErrorMsg
    {
        match right.getType ().asOf!{&RangeType} ().getInners ()[0] {
            indexType : &IntType => { // range access only works if the range is made of integers
                let sizeType = IntType::new (loc, size-> 0u16, signed-> false);
                let innerType = slice.getType ().asOf!{&SliceType} ().getInners ()[0];

                // We create uniq values, to make sure they are constructed only one time
                // They are involved multiple times in the operation
                let rng = UniqValue::new (loc, right);

                let fstIndex = StructFieldAccessValue::new (loc, indexType, rng, RangeKeys::FST);
                let scdIndex = StructFieldAccessValue::new (loc, indexType, rng, RangeKeys::SCD);

                // Cte verification if possible, to check wether the range values are correctly bounded
                let cteFst = self.verifyNotNegativeInt (alias context, loc, slice.getType (), fstIndex);
                let cteScd = self.verifyNotNegativeInt (alias context, loc, slice.getType (), scdIndex);

                // Cte verification to check wether the range is increasing or decreasing
                let cteOrder = self.verifyScdGTFst (alias context, loc, slice.getType (), fstIndex, scdIndex);

                let (fstSizeIndex, scdSizeIndex) = match indexType.getSize () {
                    0us => { (fstIndex, scdIndex) }
                    _ => { // casting index values into usize, as they will be involved in pointer arithmetics
                        (cast!{&Value}(CastValue::new (loc, sizeType, fstIndex)), cast!{&Value}(CastValue::new (loc, sizeType, scdIndex)))
                    }
                };

                // The new len is the subtraction of (range.scd - range.fst)
                let newLen = BinaryMathIntOperatorValue::new (loc, sizeType, BinaryOperators::MINUS, scdSizeIndex, fstSizeIndex);
                let ptrType = PointerType::new (loc, innerType, isMutable-> innerType.isMutable ()); // the pointer type of the slice value [ptr ; len]
                let newPtr = BinaryMathPointerOperatorValue::new (loc, ptrType, BinaryOperators::PLUS,
                                                                  StructFieldAccessValue::new (loc, ptrType, slice, SliceKeys::PTR),
                                                                  fstSizeIndex); // the new pointer is the old pointer + range.fst

                let sliceCtor = SliceCtorValue::new (loc, slice.getType (), newPtr, newLen); // Construction of the slice from pointer and length
                let sliceValue = SliceValue::new (loc, slice.getType (), sliceCtor, implicitAlias-> false);

                // If tests cannot be made at cte, then add runtime checks
                return if (!cteFst || !cteScd || !cteOrder) {
                    let len = StructFieldAccessValue::new (loc, sizeType, slice, SliceKeys::LEN);

                    // The debug test is if (len < rng.scd || rng.scd < rng.fst) throw OutOfArray ();
                    let cmpLen = CmpIntOperatorValue::new (loc, BinaryOperators::INF_EQUAL, len, scdIndex);
                    let cmpRange = CmpIntOperatorValue::new (loc, BinaryOperators::INF, scdIndex, fstIndex);
                    let cmp = LogicalBinBoolOperatorValue::new (loc, BinaryOperators::DPIPE, cmpLen, cmpRange);

                    let cond = self.createOutOfArrayTest (alias context, loc, cmp);
                    BlockValue::new (loc, slice.getType (), [cond, sliceValue], isSet-> true)
                } else {
                    sliceValue
                };
            }
        }

        throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_INDEX_OP, slice.getType (), right.getType ()));
    }

    /**
     * Verify that the range indexes are increasing
     * @returns: true if the test can be made at cte
     */
    fn verifyScdGTFst (self, dmut context : &Validator, loc : &Word, leftType : &Type, fst : &Value, scd : &Value)-> bool
        throws &ErrorMsg
    {
        let (isLower, valF, valS) = {
            let f = context:.getCompileTimeInterpreter ().computeInt (fst);
            let s = context:.getCompileTimeInterpreter ().computeInt (scd);
            (s < f, f, s)
        } catch {
            _ => {
                return false;
            }
        };

        if (isLower) {
            throw ErrorMsg::fatal (loc, end-> fst.getLoc (), format (ValidateErrorMessage::DECREASING_RANGE_ACCESS, leftType, valF, valS));
        }

        true
    }

    /**
     * Create out of array conditional based on the test 'test'
     * @params:
     *    - context: the context of the validation
     *    - loc: the location of the slice access
     *    - test: the test of the conditional (conditional being entered if true at runtime)
     * @returns: a conditional value (with no else)
     */
    fn createOutOfArrayTest (self, dmut context : &Validator, loc : &Word, test : &Value)-> &Value
        throws &ErrorMsg
    {
        let syntVar = context.createSyntaxVarFromPath (loc, [CoreNames::CORE_MODULE, CoreNames::EXCEPTION_MODULE, CoreNames::OUT_OF_ARRAY_FUNC]);
        let callExpr = MultOperatorExpr::new (Word::new (Tokens::LPAR, loc),
                                          Word::new (Tokens::RPAR, loc),
                                          left-> syntVar,
                                          rights-> [], canBeDotCall-> false);

        let call = context:.validateValue (callExpr);
        let dmut cond = ConditionalValue::new (loc, BoolType::new (loc), test, call, elsev-> NONE_VALUE, isComplete-> false);
        cond:.clearThrowers ();
        cond
    }

    /**
     * ================================================================================
     * ================================================================================
     * ========================            POINTERS             =======================
     * ================================================================================
     * ================================================================================
     */

    fn validatePointer (self, dmut context : &Validator, loc : &Word, left : &Value, rights : [&Value], rTypes : [&Type])-> &Value
        throws &ErrorMsg
    {
        if (rTypes.len == 1us && rTypes [0].isOf!{&IntType} ()) {
            return self.validatePointerInteger (alias context, loc, left, rights[0]);
        }

        throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_INDEX_OP, left.getType (), rTypes));
    }

    /**
     * Validate an index access on a pointer value using an integer value
     * @params:
     *     - context: the context of the validation
     *     - loc: the location of the index
     *     - left: the left operand
     *     - right: the right operand
     * @returns: the access value
     * @throws:
     *    - &ErrorMsg: if the operation is impossible
     * */
    fn validatePointerInteger (self, dmut context : &Validator, loc : &Word, left : &Value, right : &Value)-> &Value
        throws &ErrorMsg
    {
        context:.verifyUnsafeContext (loc);

        let ptype = left.getType ().asOf!{&PointerType} ();
        let retType =
            if (!left.isLvalue ()) {
                ptype.getInners ()[0].clone (0u32)
            } else {
                ptype.getInners ()[0]
            };

        if (retType.isOf!{&VoidType} ()) {
            throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_INDEX_OP, ptype, right.getType ()));
        }

        let sizeType = IntType::new (loc, signed-> false, size-> 0u16);
        let sizeValue = context:.getSizeofValidator ().validate (alias context, loc, retType);

        // Index is cast into a usize (as it will have to, for pointer arithmetic)
        let index = UniqValue::new (loc, match right.getType ().asOf!{&IntType} ().getSize () {
            0us => { right }
            _ => { cast!{&Value} (CastValue::new (loc, sizeType, right)) }
        });

        let shiftedIndex = BinaryMathPointerOperatorValue::new (loc, sizeType, BinaryOperators::STAR, index, sizeValue);
        let pointerValue = BinaryMathPointerOperatorValue::new (loc, ptype, BinaryOperators::PLUS, left, shiftedIndex);
        return DereferencerValue::new (loc, retType, pointerValue);
    }
    
    /**
     * ================================================================================
     * ================================================================================
     * =========================        RIGHT OPERANDS        =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate the right operands
     * @params: 
     *   - context: the context of the validation
     *   - rightOps: the list of right operands
     * @returns: the list of right operands
     */
    fn validateRightOperands (self, dmut context : &Validator, rightOps : [&Expression])-> ([&Value], [&Type])
        throws &ErrorMsg
    {
        let dmut errors = Vec!{&ErrorMsg}::new ();
        let dmut rights = Vec!{&Value}::new ();
        let dmut types = Vec!{&Type}::new ();
        
        for r in rightOps {
            {
                let v = context:.validateValue (r);
                match v {
                    e : &ExpandValue => {
                        for i_v in e.getInnerValues () {
                            rights:.push (i_v);
                            types:.push (i_v.getType ());
                        }
                    }
                    _ => {
                        rights:.push (v);
                        types:.push (v.getType ());
                    }
                }            
            } catch {
                err : &ErrorMsg => {
                    errors:.push (err);
                }
            }
        }

        if (errors.len () != 0us) throw ErrorMsg::list (errors[]);

        (rights [], types [])
    }

    
    
}
