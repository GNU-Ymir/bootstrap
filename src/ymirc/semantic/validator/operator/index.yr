mod ymirc::semantic::validator::operator::index;

import ymirc::global::core_;
import ymirc::global::state;

import ymirc::semantic::validator::visitor;
import ymirc::semantic::validator::errors;
import ymirc::semantic::validator::scores;
import ymirc::errors::_;
import ymirc::utils::format;
import ymirc::syntax::expression::_;
import ymirc::semantic::generator::value::_;
import ymirc::semantic::generator::type::_;
import ymirc::semantic::generator::value::expandvalue;
import ymirc::lexing::word;
import ymirc::lexing::tokens;
import ymirc::syntax::keys;
import ymirc::utils::bigint;

import std::collection::vec;
import std::io;

/**
 * The index validator is used to validate MultOpExpr
 * It is a class validator because index operations are complex
 */
pub class IndexOpValidator {

    /**
     * Create an empty validator     
     */
    pub self () {}

    /**
     * Validate an index expression
     * @params: 
     *  - context: the context of the validation
     *  - mult: the mult operator to validate
     * @returns: a value
     * @throws: 
     *    - &ErrorMsg: if the validation failed
     */
    pub def validate (self, dmut context : &Validator, mult : &MultOperatorExpr) -> &Value
        throws &ErrorMsg
    {        
        let left = context:.validateValue (mult.getLeft ());
        let (rights, rTypes) = self.validateRightOperands (alias context, mult.getRights ());
        
        match left.getType () {
            ArrayType () => { self.validateArray (alias context, mult.getLoc (), left, rights, rTypes) }
            SliceType () => { self.validateSlice (alias context, mult.getLoc (), left, rights, rTypes) }
            _ => {
                throw ErrorMsg::fatal (mult.getLoc (), format (ValidateErrorMessage::UNDEFINED_INDEX_OP, left.getType (), rTypes));
            }
        }
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================            ARRAY             =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a index access on array
     * @params: 
     *   - context: the context of the validation
     *   - loc: the location of the index
     *   - left: the left operand of the operation (assumed to be of array type)
     *   - rights: the list of right operand of the operation
     * @returns: the result value
     * @throws: 
     *    - &ErrorMsg: if this operation is impossible
     */
    def validateArray (self, dmut context : &Validator, loc : &Word, left : &Value, rights : [&Value], rTypes : [&Type])-> &Value
        throws &ErrorMsg
    {
        if (rights.len == 0us) return self.validateArrayToSlice (alias context, loc, left); 
        
        context;
        loc;
        rTypes;
        __pragma!fake_throw (&ErrorMsg);
        __pragma!panic ();
    
    }

    /**
     * Validate the transformation of an array into a slice
     * @params: 
     *    - context: the context of the validation
     *    - left: the left operand
     * @returns: the result of the operation
     */
    def validateArrayToSlice (self, dmut _ : &Validator, loc : &Word, left : &Value)-> &Value {
        match left.getType () {
            arr : &ArrayType => {
                let inner = arr.getInners ()[0];
                let slcType = SliceType::new (loc, inner, isMutable-> arr.isMutable ());
                
                SliceValue::new (loc, slcType, left, implicitAlias-> false)                 
            }
            _ => __pragma!panic ();
        }
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================            SLICE             =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate an index access on a slice value
     * @params:
     *    - context: the context of the validation
     *    - loc: the location of the validation
     *    - left: the left operand of the access (assumed to be of type slice)
     *    - rights: the right operands of the access
     *    - rTypes: the types of the right operands
     * @returns: The slice access value
     * @throws: 
     *   - &ErrorMsg: if the access is impossible
     */
    def validateSlice (self, dmut context : &Validator, loc : &Word, left : &Value, rights : [&Value], rTypes : [&Type])-> &Value
        throws &ErrorMsg
    {
        if (rTypes.len == 1us && rTypes [0].isOf!{&IntType} ()) {
            return self.validateSliceInteger (alias context, loc, left, rights [0]);
        } else if (rTypes.len == 1us && rTypes [0].isOf!{&RangeType} ()) {
            return self.validateSliceRange (alias context, loc, left, rights [0]);
        }

        throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_INDEX_OP, left.getType (), rTypes));
    }

    /**
     * Validate a index operation on a slice using a single int value
     * @params:
     *    - context: the context of the validation
     *    - loc: the location of the access
     *    - left: the left operand (of type slice)
     *    - right: the right operand (of type int)
     * @returns: an access value
     * @throws:
     *    - &ErrorMsg: if the access is impossible
     */
    def validateSliceInteger (self, dmut context : &Validator, loc : &Word, left : &Value, right : &Value)-> &Value
        throws &ErrorMsg
    {        
        let sizeType = IntType::new (loc, size-> 0u16, signed-> false);
        let type = left.getType ().asOf!{&SliceType} ().getInners ()[0us];

        self.verifyNotNegativeInt (alias context, loc, left.getType (), right);
        
        if (state::instance ().isDebugActive ()) {
            let index = UniqValue::new (loc, match right.getType ().asOf!{&IntType} ().getSize () {
                0us => { right }
                _ => { cast!{&Value} (CastValue::new (loc, sizeType, right)) }
            });
            
            let slice = UniqValue::new (loc, left);
            let len = StructFieldAccessValue::new (loc, sizeType, slice, SliceKeys::LEN);
            
            let cmp = CmpIntOperatorValue::new (loc, BinaryOperators::INF_EQUAL, len, index);            
            let cond = self.createOutOfArrayTest (alias context, loc, cmp);
            let sliceAccess = SliceAccessValue::new (loc, type, slice, index);
            
            BlockValue::new (loc, type, [cond, sliceAccess], isSet-> true)            
        } else {
            SliceAccessValue::new (loc, type, left, match right.getType ().asOf!{&IntType} ().getSize () {
                0us => { right }
                _ => { cast!{&Value} (CastValue::new (loc, sizeType, right)) }
            })
        }
    }

    /**
     * Verify that the index is not negative (if CTE)
     */
    def verifyNotNegativeInt (self, dmut context : &Validator, loc : &Word, leftType : &Type, right : &Value)
        throws &ErrorMsg
    {
        match right.getType ().asOf!{&IntType} ().isSigned () {
            true => {
                let (isNegative, val) = {
                    let i = context:.getCompileTimeInterpreter ().computeInt (right);
                    (i < 0, i)
                } catch {
                    _ => { (false, BigInt::new (0)) }
                };

                if (isNegative) {
                    throw ErrorMsg::fatal (loc, end-> right.getLoc (), format (ValidateErrorMessage::NEGATIVE_INT_INDEX, leftType, val));
                }                
            }
        }
    }
    
    /**
     * Validate a index operation on a slice using a single range value
     * @params:
     *    - context: the context of the validation
     *    - loc: the location of the access
     *    - left: the left operand (of type slice)
     *    - right: the right operand (of type range)
     * @returns: an access value
     * @throws:
     *    - &ErrorMsg: if the access is impossible
     */
    def validateSliceRange (self, dmut context : &Validator, loc : &Word, left : &Value, right : &Value)-> &Value
        throws &ErrorMsg
    {
        match right.getType ().asOf!{&RangeType} ().getInners ()[0] {
            indexType : &IntType => {
                let sizeType = IntType::new (loc, size-> 0u16, signed-> false);
                let innerType = left.getType ().asOf!{&SliceType} ().getInners ()[0];
                let rng = UniqValue::new (loc, right);
                let slice = UniqValue::new (loc, left);

                let fstIndex = StructFieldAccessValue::new (loc, indexType, rng, RangeKeys::FST);
                let scdIndex = StructFieldAccessValue::new (loc, indexType, rng, RangeKeys::SCD);

                self.verifyNotNegativeInt (alias context, loc, left.getType (), fstIndex);
                self.verifyNotNegativeInt (alias context, loc, left.getType (), scdIndex);

                self.verifyScdGTFst (alias context, loc, left.getType (), fstIndex, scdIndex);


                let (fstSizeIndex, scdSizeIndex) = match indexType.getSize () {
                    0us => { (fstIndex, scdIndex) }
                    _ => {
                        (cast!{&Value}(CastValue::new (loc, sizeType, fstIndex)), cast!{&Value}(CastValue::new (loc, sizeType, scdIndex)))
                    }
                };

                let newLen = BinaryMathIntOperatorValue::new (loc, sizeType, BinaryOperators::MINUS, scdSizeIndex, fstSizeIndex);
                let ptrType = PointerType::new (loc, innerType, isMutable-> innerType.isMutable ());
                let newPtr = BinaryMathPointerOperatorValue::new (loc, ptrType, BinaryOperators::PLUS,
                                                                  StructFieldAccessValue::new (loc, ptrType, slice, SliceKeys::PTR),
                                                                  fstSizeIndex);

                let sliceCtor = SliceCtorValue::new (loc, slice.getType (), newPtr, newLen);
                let sliceValue = SliceValue::new (loc, slice.getType (), sliceCtor, implicitAlias-> false);

                return if (state::instance ().isDebugActive ()) {
                    let len = StructFieldAccessValue::new (loc, sizeType, slice, SliceKeys::LEN);

                    // The debug test is if (len < rng.scd || rng.scd < rng.fst) throw OutOfArray ();
                    let cmpLen = CmpIntOperatorValue::new (loc, BinaryOperators::INF_EQUAL, len, scdIndex);
                    let cmpRange = CmpIntOperatorValue::new (loc, BinaryOperators::INF, scdIndex, fstIndex);
                    let cmp = LogicalBinBoolOperatorValue::new (loc, BinaryOperators::DPIPE, cmpLen, cmpRange);

                    let cond = self.createOutOfArrayTest (alias context, loc, cmp);
                    BlockValue::new (loc, slice.getType (), [cond, sliceValue], isSet-> true)
                } else {
                    sliceValue
                };
            }
        }

        throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_INDEX_OP, left.getType (), right.getType ()));
    }

    /**
     * Verify that the range indexes are increasing
     */
    def verifyScdGTFst (self, dmut context : &Validator, loc : &Word, leftType : &Type, fst : &Value, scd : &Value)
        throws &ErrorMsg
    {
        let (isLower, valF, valS) = {
            let f = context:.getCompileTimeInterpreter ().computeInt (fst);
            let s = context:.getCompileTimeInterpreter ().computeInt (scd);
            (s < f, f, s)
        } catch {
            _ => { (false, BigInt::new (0), BigInt::new (0)) }
        };

        if (isLower) {
            throw ErrorMsg::fatal (loc, end-> fst.getLoc (), format (ValidateErrorMessage::DECREASING_RANGE_ACCESS, leftType, valF, valS));
        }
    }

    /**
     * Create out of array conditional based on the test 'test'
     * @params:
     *    - context: the context of the validation
     *    - loc: the location of the slice access
     *    - test: the test of the conditional (conditional being entered if true at runtime)
     * @returns: a conditional value (with no else)
     */
    def createOutOfArrayTest (self, dmut context : &Validator, loc : &Word, test : &Value)-> &Value
        throws &ErrorMsg
    {
        let syntVar = context.createSyntaxVarFromPath (loc, [CoreNames::CORE_MODULE, CoreNames::EXCEPTION_MODULE, CoreNames::OUT_OF_ARRAY_FUNC]);
        let callExpr = MultOperatorExpr::new (Word::new (Tokens::LPAR, loc),
                                          Word::new (Tokens::RPAR, loc),
                                          left-> syntVar,
                                          rights-> [], canBeDotCall-> false);

        let call = context:.validateValue (callExpr);
        let dmut cond = ConditionalValue::new (loc, BoolType::new (loc), test, call, elsev-> NONE_VALUE, isComplete-> false);
        cond:.clearThrowers ();
        cond
    }       
    
    /**
     * ================================================================================
     * ================================================================================
     * =========================        RIGHT OPERANDS        =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate the right operands
     * @params: 
     *   - context: the context of the validation
     *   - rightOps: the list of right operands
     * @returns: the list of right operands
     */
    def validateRightOperands (self, dmut context : &Validator, rightOps : [&Expression])-> ([&Value], [&Type])
        throws &ErrorMsg
    {
        let dmut errors = Vec!{&ErrorMsg}::new ();
        let dmut rights = Vec!{&Value}::new ();
        let dmut types = Vec!{&Type}::new ();
        
        for r in rightOps {
            {
                let v = context:.validateValue (r);
                match v {
                    e : &ExpandValue => {
                        for i_v in e.getInnerValues () {
                            rights:.push (i_v);
                            types:.push (i_v.getType ());
                        }
                    }
                    _ => {
                        rights:.push (v);
                        types:.push (v.getType ());
                    }
                }            
            } catch {
                err : &ErrorMsg => {
                    errors:.push (err);
                }
            }
        }

        if (errors.len () != 0us) throw ErrorMsg::list (errors[]);

        (rights [], types [])
    }

    
    
}
