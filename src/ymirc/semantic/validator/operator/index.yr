mod ymirc::semantic::validator::operator::index;

import ymirc::global::core_;
import ymirc::global::state;

import ymirc::semantic::validator::visitor;
import ymirc::semantic::validator::errors;
import ymirc::semantic::validator::scores;
import ymirc::errors::_;
import ymirc::utils::format;
import ymirc::syntax::expression::_;
import ymirc::semantic::generator::value::_;
import ymirc::semantic::generator::type::_;
import ymirc::semantic::generator::value::expandvalue;
import ymirc::lexing::word;
import ymirc::lexing::tokens;
import ymirc::syntax::keys;
import ymirc::utils::bigint;

import std::collection::vec;
import std::io;

/**
 * The index validator is used to validate MultOpExpr
 * It is a class validator because index operations are complex
 */
pub class IndexOpValidator {

    /**
     * Create an empty validator     
     */
    pub self () {}

    /**
     * Validate an index expression
     * @params: 
     *  - context: the context of the validation
     *  - mult: the mult operator to validate
     * @returns: a value
     * @throws: 
     *    - &ErrorMsg: if the validation failed
     */
    pub def validate (self, dmut context : &Validator, mult : &MultOperatorExpr) -> &Value
        throws &ErrorMsg
    {        
        let left = UniqValue::new (mult.getLoc (), context:.validateValue (mult.getLeft ()));
        context:.enterDollar (left);
        {
            let (rights, rTypes) = self.validateRightOperands (alias context, mult.getRights ());

            match left.getType () {
                ArrayType () => { self.validateArray (alias context, mult.getLoc (), left, rights, rTypes) }
                SliceType () => { self.validateSlice (alias context, mult.getLoc (), left, rights, rTypes) }
                _ => {
                    throw ErrorMsg::fatal (mult.getLoc (), format (ValidateErrorMessage::UNDEFINED_INDEX_OP, left.getType (), rTypes));
                }
            }
        } exit {
            context:.exitDollar ();
        }
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================            ARRAY             =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a index access on array
     * @params: 
     *   - context: the context of the validation
     *   - loc: the location of the index
     *   - left: the left operand of the operation (assumed to be of array type)
     *   - rights: the list of right operand of the operation
     * @returns: the result value
     * @throws: 
     *    - &ErrorMsg: if this operation is impossible
     */
    def validateArray (self, dmut context : &Validator, loc : &Word, left : &Value, rights : [&Value], rTypes : [&Type])-> &Value
        throws &ErrorMsg
    {
        if (rights.len == 0us) return self.validateArrayToSlice (alias context, loc, left); // array[], => transform array in a slice
        if (rTypes.len == 1us && rTypes [0].isOf!{&IntType} ()) {
            return self.validateArrayInteger (alias context, loc, left, rights [0]);
        } else if (rTypes.len == 1us && rTypes [0].isOf!{&RangeType} ()) {
            return self.validateArrayRange (alias context, loc, left, rights [0]);
        }

        throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_INDEX_OP, left.getType (), rTypes));
    }

    /**
     * Validate the transformation of an array into a slice
     * @params: 
     *    - context: the context of the validation
     *    - left: the left operand
     * @returns: the result of the operation
     */
    def validateArrayToSlice (self, dmut _ : &Validator, loc : &Word, left : &Value)-> &Value {
        match left.getType () {
            arr : &ArrayType => {
                let inner = arr.getInners ()[0];

                // A slice value constructed from the array (we let the backend manage the transformation, but it will more than probably be alike to SliceCtorValue {array, arrayLen})
                let slcType = SliceType::new (loc, inner, isMutable-> arr.isMutable ());
                
                SliceValue::new (loc, slcType, left, implicitAlias-> false)                 
            }

            // Called by something that should not
            _ => __pragma!panic ();
        }
    }

    /**
     * Validate an index access on an array value using an integer value
     * @params:
     *    - context: the context of the validation
     *    - loc: the location of the index
     *    - left: the left operand (assumed to be of type array)
     *    - right: the right operand (assumed to be of type int)
     * @returns: the access value
     * @throws:
     *    - &ErrorMsg: if this operation is impossible
     */
    def validateArrayInteger (self, dmut context : &Validator, loc : &Word, left : &Value, right : &Value)-> &Value
        throws &ErrorMsg
    {
        let sizeType = IntType::new (loc, size-> 0u16, signed-> false);
        let innerType = left.getType ().asOf!{&ArrayType} ().getInners ()[0us];
        let arraySize = left.getType ().asOf!{&ArrayType} ().getSize ();

        // Cte verification if possible, to check wether the index is positive and does not overflow the array size
        self.verifyNotNegativeInt (alias context, loc, left.getType (), right, maximum-> arraySize.getValue ());

        // Index is cast into a usize (as it will have to, for pointer arithmetic)
        let index = UniqValue::new (loc, match right.getType ().asOf!{&IntType} ().getSize () {
            0us => { right }
            _ => { cast!{&Value} (CastValue::new (loc, sizeType, right)) }
        });

        let arrayAccess = SliceAccessValue::new (loc, innerType, left, index);

        // If debug mode is active, we add a dynamic conditional to check the slice index overflow
        if (state::instance ().isDebugActive ()) {
            let cmp = CmpIntOperatorValue::new (loc, BinaryOperators::INF_EQUAL, arraySize, index);
            let cond = self.createOutOfArrayTest (alias context, loc, cmp);

            BlockValue::new (loc, innerType, [cond, arrayAccess], isSet-> true)
        } else {
            arrayAccess
        }
    }

    /**
     * Validate an index access on an array value using a range value
     * @params:
     *    - context: the context of the validation
     *    - loc: the location of the index
     *    - left: the left operand (assumed to be of type array)
     *    - right: the right operand (assumed to be of type range)
     * @returns: the access value
     * @throws:
     *    - &ErrorMsg: if this operation is impossible
     */
    def validateArrayRange (self, dmut context : &Validator, loc : &Word, left : &Value, right : &Value)-> &Value
        throws &ErrorMsg
    {
        match right.getType ().asOf!{&RangeType} ().getInners ()[0] {
            indexType : &IntType => { // range access only works if the range is made of integers
                let sizeType = IntType::new (loc, size-> 0u16, signed-> false);
                let innerType = left.getType ().asOf!{&ArrayType} ().getInners ()[0];
                let arraySize = left.getType ().asOf!{&ArrayType} ().getSize ();

                let rng = UniqValue::new (loc, right); // uniq value to make sure the value is constructed only once, because it is involved multiple times in the operation
                let slice = self.validateArrayToSlice (alias context, loc, left); // Transforming the array into slice, to generalize pointer movements for slices only

                let fstIndex = StructFieldAccessValue::new (right.getLoc (), indexType, rng, RangeKeys::FST);
                let scdIndex = StructFieldAccessValue::new (right.getLoc (), indexType, rng, RangeKeys::SCD);

                // Cte verification if possible, to check wether the range values are correctly bounded
                self.verifyNotNegativeInt (alias context, loc, left.getType (), fstIndex, maximum-> arraySize.getValue ());
                self.verifyNotNegativeInt (alias context, loc, left.getType (), scdIndex, maximum-> arraySize.getValue ());

                // Cte verification to check wether the range is increasing or decreasing
                self.verifyScdGTFst (alias context, loc, left.getType (), fstIndex, scdIndex);

                let (fstSizeIndex, scdSizeIndex) = match indexType.getSize () {
                    0us => { (fstIndex, scdIndex) }
                    _ => { // casting index values into usize, as they will be involved in pointer arithmetics
                        (cast!{&Value}(CastValue::new (loc, sizeType, fstIndex)), cast!{&Value}(CastValue::new (loc, sizeType, scdIndex)))
                    }
                };

                // The new len is the subtraction of (range.scd - range.fst)
                let newLen = BinaryMathIntOperatorValue::new (loc, sizeType, BinaryOperators::MINUS, scdSizeIndex, fstSizeIndex);
                let ptrType = PointerType::new (loc, innerType, isMutable-> innerType.isMutable ()); // the pointer type of the slice value [ptr ; len]
                let newPtr = BinaryMathPointerOperatorValue::new (loc, ptrType, BinaryOperators::PLUS,
                                                                  StructFieldAccessValue::new (loc, ptrType, slice, SliceKeys::PTR),
                                                                  fstSizeIndex); // the new pointer is the old pointer + range.fst


                let sliceCtor = SliceCtorValue::new (loc, slice.getType (), newPtr, newLen); // Construction of the slice from pointer and length
                let sliceValue = SliceValue::new (loc, slice.getType (), sliceCtor, implicitAlias-> false); // Slicevalue from a slice construction

                return if (state::instance ().isDebugActive ()) { // if the debug mode is active we add some dynamic tests to check the length and indexes overflow
                    let len = StructFieldAccessValue::new (loc, sizeType, slice, SliceKeys::LEN);

                    // The debug test is if (len < rng.scd || rng.scd < rng.fst) throw OutOfArray ();
                    let cmpLen = CmpIntOperatorValue::new (loc, BinaryOperators::INF_EQUAL, len, scdIndex);
                    let cmpRange = CmpIntOperatorValue::new (loc, BinaryOperators::INF, scdIndex, fstIndex);
                    let cmp = LogicalBinBoolOperatorValue::new (loc, BinaryOperators::DPIPE, cmpLen, cmpRange);

                    let cond = self.createOutOfArrayTest (alias context, loc, cmp);
                    BlockValue::new (loc, slice.getType (), [cond, sliceValue], isSet-> true)
                } else {
                    sliceValue
                };
            }
        }

        throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_INDEX_OP, left.getType (), right.getType ()));
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================            SLICE             =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate an index access on a slice value
     * @params:
     *    - context: the context of the validation
     *    - loc: the location of the validation
     *    - left: the left operand of the access (assumed to be of type slice)
     *    - rights: the right operands of the access
     *    - rTypes: the types of the right operands
     * @returns: The slice access value
     * @throws: 
     *   - &ErrorMsg: if the access is impossible
     */
    def validateSlice (self, dmut context : &Validator, loc : &Word, left : &Value, rights : [&Value], rTypes : [&Type])-> &Value
        throws &ErrorMsg
    {
        if (rTypes.len == 1us && rTypes [0].isOf!{&IntType} ()) {
            return self.validateSliceInteger (alias context, loc, left, rights [0]);
        } else if (rTypes.len == 1us && rTypes [0].isOf!{&RangeType} ()) {
            return self.validateSliceRange (alias context, loc, left, rights [0]);
        }

        throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_INDEX_OP, left.getType (), rTypes));
    }

    /**
     * Validate a index operation on a slice using a single int value
     * @params:
     *    - context: the context of the validation
     *    - loc: the location of the access
     *    - left: the left operand (of type slice)
     *    - right: the right operand (of type int)
     * @returns: an access value
     * @throws:
     *    - &ErrorMsg: if the access is impossible
     */
    def validateSliceInteger (self, dmut context : &Validator, loc : &Word, left : &Value, right : &Value)-> &Value
        throws &ErrorMsg
    {        
        let sizeType = IntType::new (loc, size-> 0u16, signed-> false);
        let type = left.getType ().asOf!{&SliceType} ().getInners ()[0us];

        // Cte verification if possible, to check wether the index is positive
        self.verifyNotNegativeInt (alias context, loc, left.getType (), right);

        // Index is cast into a usize (as it will have to, for pointer arithmetic)
        let index = UniqValue::new (loc, match right.getType ().asOf!{&IntType} ().getSize () {
            0us => { right }
            _ => { cast!{&Value} (CastValue::new (loc, sizeType, right)) }
        });

        // If debug mode is active, we add a dynamic conditional to check the slice index overflow
        if (state::instance ().isDebugActive ()) {
            let len = StructFieldAccessValue::new (loc, sizeType, left, SliceKeys::LEN);
            
            let cmp = CmpIntOperatorValue::new (loc, BinaryOperators::INF_EQUAL, len, index);            
            let cond = self.createOutOfArrayTest (alias context, loc, cmp);
            let sliceAccess = SliceAccessValue::new (loc, type, left, index);
            
            BlockValue::new (loc, type, [cond, sliceAccess], isSet-> true)            
        } else {
            SliceAccessValue::new (loc, type, left, index)
        }
    }

    /**
     * Verify that the index is not negative (if CTE)
     */
    def verifyNotNegativeInt (self, dmut context : &Validator, loc : &Word, leftType : &Type, right : &Value, maximum : &BigInt = BigInt::new (u64::max))
        throws &ErrorMsg
    {
        let (isNegative, isTooBig, val) = {
            let i = context:.getCompileTimeInterpreter ().computeInt (right);
            (i < 0, i >= maximum, i)
        } catch {
            // The value is not cte
            _ => { (false, false, BigInt::new (0)) }
        };

        if (isNegative) { // The cte value is negative, that cannot happen when used as index
            throw ErrorMsg::fatal (loc, end-> right.getLoc (), format (ValidateErrorMessage::NEGATIVE_INT_INDEX, leftType, val));
        }

        if (isTooBig) { // The cte value is bigger than the array length
            throw ErrorMsg::fatal (loc, end-> right.getLoc (), format (ValidateErrorMessage::ARRAY_OVERFLOW, maximum, val));
        }
    }
    
    /**
     * Validate a index operation on a slice using a single range value
     * @params:
     *    - context: the context of the validation
     *    - loc: the location of the access
     *    - left: the left operand (of type slice)
     *    - right: the right operand (of type range)
     * @returns: an access value
     * @throws:
     *    - &ErrorMsg: if the access is impossible
     */
    def validateSliceRange (self, dmut context : &Validator, loc : &Word, slice : &Value, right : &Value)-> &Value
        throws &ErrorMsg
    {
        match right.getType ().asOf!{&RangeType} ().getInners ()[0] {
            indexType : &IntType => { // range access only works if the range is made of integers
                let sizeType = IntType::new (loc, size-> 0u16, signed-> false);
                let innerType = slice.getType ().asOf!{&SliceType} ().getInners ()[0];

                // We create uniq values, to make sure they are constructed only one time
                // They are involved multiple times in the operation
                let rng = UniqValue::new (loc, right);

                let fstIndex = StructFieldAccessValue::new (loc, indexType, rng, RangeKeys::FST);
                let scdIndex = StructFieldAccessValue::new (loc, indexType, rng, RangeKeys::SCD);

                // Cte verification if possible, to check wether the range values are correctly bounded
                self.verifyNotNegativeInt (alias context, loc, slice.getType (), fstIndex);
                self.verifyNotNegativeInt (alias context, loc, slice.getType (), scdIndex);

                // Cte verification to check wether the range is increasing or decreasing
                self.verifyScdGTFst (alias context, loc, slice.getType (), fstIndex, scdIndex);

                let (fstSizeIndex, scdSizeIndex) = match indexType.getSize () {
                    0us => { (fstIndex, scdIndex) }
                    _ => { // casting index values into usize, as they will be involved in pointer arithmetics
                        (cast!{&Value}(CastValue::new (loc, sizeType, fstIndex)), cast!{&Value}(CastValue::new (loc, sizeType, scdIndex)))
                    }
                };

                // The new len is the subtraction of (range.scd - range.fst)
                let newLen = BinaryMathIntOperatorValue::new (loc, sizeType, BinaryOperators::MINUS, scdSizeIndex, fstSizeIndex);
                let ptrType = PointerType::new (loc, innerType, isMutable-> innerType.isMutable ()); // the pointer type of the slice value [ptr ; len]
                let newPtr = BinaryMathPointerOperatorValue::new (loc, ptrType, BinaryOperators::PLUS,
                                                                  StructFieldAccessValue::new (loc, ptrType, slice, SliceKeys::PTR),
                                                                  fstSizeIndex); // the new pointer is the old pointer + range.fst

                let sliceCtor = SliceCtorValue::new (loc, slice.getType (), newPtr, newLen); // Construction of the slice from pointer and length
                let sliceValue = SliceValue::new (loc, slice.getType (), sliceCtor, implicitAlias-> false);

                return if (state::instance ().isDebugActive ()) {
                    let len = StructFieldAccessValue::new (loc, sizeType, slice, SliceKeys::LEN);

                    // The debug test is if (len < rng.scd || rng.scd < rng.fst) throw OutOfArray ();
                    let cmpLen = CmpIntOperatorValue::new (loc, BinaryOperators::INF_EQUAL, len, scdIndex);
                    let cmpRange = CmpIntOperatorValue::new (loc, BinaryOperators::INF, scdIndex, fstIndex);
                    let cmp = LogicalBinBoolOperatorValue::new (loc, BinaryOperators::DPIPE, cmpLen, cmpRange);

                    let cond = self.createOutOfArrayTest (alias context, loc, cmp);
                    BlockValue::new (loc, slice.getType (), [cond, sliceValue], isSet-> true)
                } else {
                    sliceValue
                };
            }
        }

        throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_INDEX_OP, slice.getType (), right.getType ()));
    }

    /**
     * Verify that the range indexes are increasing
     */
    def verifyScdGTFst (self, dmut context : &Validator, loc : &Word, leftType : &Type, fst : &Value, scd : &Value)
        throws &ErrorMsg
    {
        let (isLower, valF, valS) = {
            let f = context:.getCompileTimeInterpreter ().computeInt (fst);
            let s = context:.getCompileTimeInterpreter ().computeInt (scd);
            (s < f, f, s)
        } catch {
            _ => { (false, BigInt::new (0), BigInt::new (0)) }
        };

        if (isLower) {
            throw ErrorMsg::fatal (loc, end-> fst.getLoc (), format (ValidateErrorMessage::DECREASING_RANGE_ACCESS, leftType, valF, valS));
        }
    }

    /**
     * Create out of array conditional based on the test 'test'
     * @params:
     *    - context: the context of the validation
     *    - loc: the location of the slice access
     *    - test: the test of the conditional (conditional being entered if true at runtime)
     * @returns: a conditional value (with no else)
     */
    def createOutOfArrayTest (self, dmut context : &Validator, loc : &Word, test : &Value)-> &Value
        throws &ErrorMsg
    {
        let syntVar = context.createSyntaxVarFromPath (loc, [CoreNames::CORE_MODULE, CoreNames::EXCEPTION_MODULE, CoreNames::OUT_OF_ARRAY_FUNC]);
        let callExpr = MultOperatorExpr::new (Word::new (Tokens::LPAR, loc),
                                          Word::new (Tokens::RPAR, loc),
                                          left-> syntVar,
                                          rights-> [], canBeDotCall-> false);

        let call = context:.validateValue (callExpr);
        let dmut cond = ConditionalValue::new (loc, BoolType::new (loc), test, call, elsev-> NONE_VALUE, isComplete-> false);
        cond:.clearThrowers ();
        cond
    }       
    
    /**
     * ================================================================================
     * ================================================================================
     * =========================        RIGHT OPERANDS        =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate the right operands
     * @params: 
     *   - context: the context of the validation
     *   - rightOps: the list of right operands
     * @returns: the list of right operands
     */
    def validateRightOperands (self, dmut context : &Validator, rightOps : [&Expression])-> ([&Value], [&Type])
        throws &ErrorMsg
    {
        let dmut errors = Vec!{&ErrorMsg}::new ();
        let dmut rights = Vec!{&Value}::new ();
        let dmut types = Vec!{&Type}::new ();
        
        for r in rightOps {
            {
                let v = context:.validateValue (r);
                match v {
                    e : &ExpandValue => {
                        for i_v in e.getInnerValues () {
                            rights:.push (i_v);
                            types:.push (i_v.getType ());
                        }
                    }
                    _ => {
                        rights:.push (v);
                        types:.push (v.getType ());
                    }
                }            
            } catch {
                err : &ErrorMsg => {
                    errors:.push (err);
                }
            }
        }

        if (errors.len () != 0us) throw ErrorMsg::list (errors[]);

        (rights [], types [])
    }

    
    
}
