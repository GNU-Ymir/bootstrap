mod ymirc::semantic::validator::operator::index;

import ymirc::global::core_;
import ymirc::global::state;

import ymirc::semantic::validator::visitor;
import ymirc::semantic::validator::errors;
import ymirc::semantic::validator::scores;
import ymirc::errors::_;
import ymirc::utils::format;
import ymirc::syntax::expression::_;
import ymirc::semantic::generator::value::_;
import ymirc::semantic::generator::type::_;
import ymirc::semantic::generator::value::expandvalue;
import ymirc::lexing::word;
import ymirc::lexing::tokens;
import ymirc::syntax::keys;
import ymirc::utils::bigint;

import std::collection::vec;
import std::io;

/**
 * The index validator is used to validate MultOpExpr
 * It is a class validator because index operations are complex
 */
pub class IndexOpValidator {

    /**
     * Create an empty validator     
     */
    pub self () {}

    /**
     * Validate an index expression
     * @params: 
     *  - context: the context of the validation
     *  - mult: the mult operator to validate
     * @returns: a value
     * @throws: 
     *    - &ErrorMsg: if the validation failed
     */
    pub fn validate (self, dmut context : &Validator, mult : &MultOperatorExpr) -> &Value
        throws &ErrorMsg
    {
        let left = context:.validateValue (mult.getLeft ());
        context:.enterDollar (left);
        {
            let (rights, rTypes) = self.validateRightOperands (alias context, mult.getRights ());

            match left.getType () {
                ArrayType () => {
                    self.validateArray (alias context, mult.getLoc (), left, rights, rTypes, inCopy-> context.isDynamic (mult))
                }
                SliceType () => { self.validateSlice (alias context, mult.getLoc (), left, rights, rTypes) }
                PointerType () => { self.validatePointer (alias context, mult.getLoc (), left, rights, rTypes) }
                _ => {
                    throw ErrorMsg::fatal (mult.getLoc (), format (ValidateErrorMessage::UNDEFINED_INDEX_OP, left.getType (), rTypes));
                }
            }
        } exit {
            context:.exitDollar ();
        }
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================            ARRAY             =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a index access on array
     * @params: 
     *   - context: the context of the validation
     *   - loc: the location of the index
     *   - left: the left operand of the operation (assumed to be of array type)
     *   - rights: the list of right operand of the operation
     *   - inCopy: true iif the result is copied immediatly
     * @returns: the result value
     * @throws: 
     *    - &ErrorMsg: if this operation is impossible
     */
    fn validateArray (self, dmut context : &Validator, loc : &Word, left : &Value, rights : [&Value], rTypes : [&Type], inCopy : bool)-> &Value
        throws &ErrorMsg
    {
        if (rTypes.len == 1us && rTypes [0].isOf!{&IntType} ()) {
            return self.validateArrayInteger (alias context, loc, left, rights [0]);
        } else if (rTypes.len == 1us && rTypes [0].isOf!{&RangeType} ()) {
            if inCopy {
                return self.validateArrayRangeAsSlice (alias context, loc, left, rights [0]);
            } else {
                return self.validateArrayRange (alias context, loc, left, rights [0]);
            }
        }

        throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_INDEX_OP, left.getType (), rTypes));
    }

    /**
     * Validate an index access on an array value using an integer value
     * @params:
     *    - context: the context of the validation
     *    - loc: the location of the index
     *    - left: the left operand (assumed to be of type array)
     *    - right: the right operand (assumed to be of type int)
     * @returns: the access value
     * @throws:
     *    - &ErrorMsg: if this operation is impossible
     */
    fn validateArrayInteger (self, dmut context : &Validator, loc : &Word, left : &Value, right : &Value)-> &Value
        throws &ErrorMsg
    {
        let sizeType = IntType::new (loc, size-> 0u16, signed-> false);
        let innerType = left.getType ().asOf!{&ArrayType} ().getInners ()[0us];
        let arraySize = left.getType ().asOf!{&ArrayType} ().getSize ();

        // Cte verification if possible, to check wether the index is positive and does not overflow the array size
        let cteTest = self.verifyNotNegativeInt (alias context, loc, left.getType (), right, maximum-> arraySize.getValue ());

        // Index is cast into a usize (as it will have to, for pointer arithmetic)
        let index = match right.getType ().asOf!{&IntType} ().getSize () {
            0us => { right }
            _ => { context:.getCastValidator ().validateCast (alias context, right, sizeType) }
        };

        let (_, arrayAccess) = context.getCompileTimeInterpreter ().simplify (
            self.createArrayAccess (loc, innerType, left, index));


        // If the test cannot be made in cte, then add a runtime check
        if (!cteTest) {
            let cmp = CmpIntOperatorValue::new (loc, BinaryOperators::INF_EQUAL, arraySize, index);
            let cond = self.createOutOfArrayTest (alias context, loc, cmp);

            BlockValue::new (loc, innerType, [cond, arrayAccess], isSet-> true)
        } else {
            arrayAccess
        }
    }

    /**
     * Validate an index access on an array value using a range operand
     * @params:
     *    - context: the context of the validation
     *    - loc: the location of the index
     *    - left: the left operand (assumed to be of type array)
     *    - right: the right operand (assumed to be of type range)
     * @returns: the access value (of type slice)
     * @throws:
     *    - &ErrorMsg: if this operation is impossible
     * */
    fn validateArrayRangeAsSlice (self, dmut context : &Validator, loc : &Word, left : &Value, right : &Value)-> &Value
        throws &ErrorMsg
    {
        match right.getType ().asOf!{&RangeType} ().getInners ()[0] {
            indexType : &IntType => {
                let sizeType = IntType::new (loc, size-> 0u16, signed-> false);
                let innerType = left.getType ().asOf!{&ArrayType} ().getInners ()[0];
                let arraySize = left.getType ().asOf!{&ArrayType} ().getSize ();

                // We create uniq values, to make sure they are constructed only one time
                // They are involved multiple times in the operation
                let rng = right;
                let (_, fstIndex) = context:.getCompileTimeInterpreter ().simplify (StructFieldAccessValue::new (loc, indexType, rng, RangeKeys::FST));
                let (_, scdIndex) = context:.getCompileTimeInterpreter ().simplify (StructFieldAccessValue::new (loc, indexType, rng, RangeKeys::SCD));

                // Cte verification if possible, to check wether the range values are correctly bounded
                let cteFst = self.verifyNotNegativeInt (alias context, loc, left.getType (), fstIndex);
                let cteScd = self.verifyNotNegativeInt (alias context, loc, left.getType (), scdIndex, maximum-> arraySize.getValue ());

                // Cte verification to check wether the range is increasing or decreasing
                let cteOrder = self.verifyScdGTFst (alias context, loc, left.getType (), fstIndex, scdIndex);


                let (fstSizeIndex, scdSizeIndex) = match indexType.getSize () {
                    0us => { (fstIndex, scdIndex) }
                    _ => { // casting index values into usize, as they will be involved in pointer arithmetics
                        let fstSize = context:.getCastValidator ().validateCast (alias context, fstIndex, sizeType);
                        let scdSize = context:.getCastValidator ().validateCast (alias context, scdIndex, sizeType);
                        (fstSize, scdSize)
                    }
                };

                // The new len is the subtraction of (range.scd - range.fst)
                let (_, newLen) = context:.getCompileTimeInterpreter ().simplify (BinaryMathIntOperatorValue::new (loc, sizeType, BinaryOperators::MINUS, scdSizeIndex, fstSizeIndex));
                let ptrType = PointerType::new (loc, innerType, isMutable-> innerType.isMutable ()); // the pointer type of the slice value [ptr ; len]
                let arrayAddr = AddressValue::new (loc, ptrType, left);
                let newPtr = BinaryMathPointerOperatorValue::new (loc, ptrType, BinaryOperators::PLUS,
                                                                  arrayAddr,
                                                                  fstSizeIndex); // the new pointer is the address of the array + range.fst

                let sliceType = SliceType::new (loc, innerType, isMutable-> true);
                let sliceCtor = SliceCtorValue::new (loc, sliceType, newPtr, newLen); // Construction of the slice from pointer and length
                let sliceValue = SliceValue::new (loc, sliceType, sliceCtor, implicitAlias-> false);


                // If tests cannot be made at cte, then add runtime checks
                return if (!cteFst || !cteScd || !cteOrder) {
                    // The debug test is if (len < rng.scd || rng.scd < rng.fst) throw OutOfArray ();
                    let cmpLen = CmpIntOperatorValue::new (loc, BinaryOperators::INF, arraySize, scdIndex);
                    let cmpRange = CmpIntOperatorValue::new (loc, BinaryOperators::INF, scdIndex, fstIndex);
                    let cmp = LogicalBinBoolOperatorValue::new (loc, BinaryOperators::DPIPE, cmpLen, cmpRange);

                    let cond = self.createOutOfArrayTest (alias context, loc, cmp);

                    BlockValue::new (loc, sliceType, [cond, sliceValue], isSet-> true)
                } else {
                    sliceValue
                };
            }
        }

        throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_INDEX_OP, left.getType (), right.getType ()));
    }


    /**
     * Validate an index access on an array value using a range operand
     * @params:
     *    - context: the context of the validation
     *    - loc: the location of the index
     *    - left: the left operand (assumed to be of type array)
     *    - right: the right operand (assumed to be of type range)
     * @returns: the access value (of type slice)
     * @throws:
     *    - &ErrorMsg: if this operation is impossible
     * */
    fn validateArrayRange (self, dmut context : &Validator, loc : &Word, left : &Value, right : &Value)-> &Value
        throws &ErrorMsg
    {
        match right.getType ().asOf!{&RangeType} ().getInners ()[0] {
            indexType : &IntType => {
                let sizeType = IntType::new (loc, size-> 0u16, signed-> false);
                let innerType = left.getType ().asOf!{&ArrayType} ().getInners ()[0];
                let arraySize = left.getType ().asOf!{&ArrayType} ().getSize ();

                // We create uniq values, to make sure they are constructed only one time
                // They are involved multiple times in the operation
                let rng = right;
                let (fst, scd) = {
                    let fstIndex = context:.getCompileTimeInterpreter ().computeInt (StructFieldAccessValue::new (loc, indexType, rng, RangeKeys::FST));
                    let scdIndex = context:.getCompileTimeInterpreter ().computeInt (StructFieldAccessValue::new (loc, indexType, rng, RangeKeys::SCD));
                    (fstIndex, scdIndex)
                } catch {
                    err : &ErrorMsg => {
                        throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::RANGE_ON_ARRAY_NO_COPY, left.getType (), right.getType ()), notes-> [err]);
                    }
                }

                if (fst < 0) throw ErrorMsg::fatal (loc, end-> right.getLoc (), format (ValidateErrorMessage::NEGATIVE_INT_INDEX, left.getType (), fst));
                if (scd < 0) throw ErrorMsg::fatal (loc, end-> right.getLoc (), format (ValidateErrorMessage::NEGATIVE_INT_INDEX, left.getType (), scd));
                if (scd > arraySize.getValue ()) throw ErrorMsg::fatal (loc, end-> right.getLoc (), format (ValidateErrorMessage::ARRAY_OVERFLOW, arraySize, scd));
                if (fst > scd) throw ErrorMsg::fatal (loc, end-> right.getLoc (), format (ValidateErrorMessage::DECREASING_RANGE_ACCESS, left.getType (), fst, scd));

                let dmut values = Vec!{&Value}::new ();
                {
                    for i in fst.to!{usize} () .. scd.to!{usize} () {
                        values:.push (self.createArrayAccess (loc, innerType, left, makeIntValue (loc, i)));
                    }
                } catch {
                    _ => __pragma!panic ();
                }

                let finInner = if (!innerType.isMutable ()) { innerType.clone (1u32) } else { innerType };
                let finType = ArrayType::new (loc, finInner, IntValue::new (loc, sizeType, scd - fst), isMutable-> true);
                return ArrayValue::new (loc, finType, values[]);
            }
        }

        throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_INDEX_OP, left.getType (), right.getType ()));
    }

    /**
     * Create an array access value, (assuming that if the index is cte, then index overflow was already checked)
     * @info: This function tries to optimize a bit the access if the operation can be done at cte (even without returning a fully cte value)
     * @params:
     *    - loc: the location of the access
     *    - type: the type of the access
     *    - value: the value being accessed
     *    - index: the index of the access
     * */
    pub fn createArrayAccess (self, loc : &Word, type : &Type, value : &Value, index : &Value)-> &Value {
        match (index, value) {
            (i : &IntValue, arr : &ArrayValue) => {
                // We already checked overflow
                let ib = i.getValue ().toT!{usize} ();
                arr.getInners ()[ib]
            }
            _ => {
                cast!{&Value} (ArrayAccessValue::new (loc, type, value, index))
            }
        }

    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================            SLICE             =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate an index access on a slice value
     * @params:
     *    - context: the context of the validation
     *    - loc: the location of the validation
     *    - left: the left operand of the access (assumed to be of type slice)
     *    - rights: the right operands of the access
     *    - rTypes: the types of the right operands
     * @returns: The slice access value
     * @throws: 
     *   - &ErrorMsg: if the access is impossible
     */
    fn validateSlice (self, dmut context : &Validator, loc : &Word, left : &Value, rights : [&Value], rTypes : [&Type])-> &Value
        throws &ErrorMsg
    {
        let leftU = left;
        if (rTypes.len == 1us && rTypes [0].isOf!{&IntType} ()) {
            return self.validateSliceInteger (alias context, loc, leftU, rights [0]);
        } else if (rTypes.len == 1us && rTypes [0].isOf!{&RangeType} ()) {
            return self.validateSliceRange (alias context, loc, leftU, rights [0]);
        }

        throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_INDEX_OP, left.getType (), rTypes));
    }

    /**
     * Validate a index operation on a slice using a single int value
     * @params:
     *    - context: the context of the validation
     *    - loc: the location of the access
     *    - left: the left operand (of type slice)
     *    - right: the right operand (of type int)
     * @returns: an access value
     * @throws:
     *    - &ErrorMsg: if the access is impossible
     */
    fn validateSliceInteger (self, dmut context : &Validator, loc : &Word, left : &Value, right : &Value)-> &Value
        throws &ErrorMsg
    {
        let sizeType = IntType::new (loc, size-> 0u16, signed-> false);
        let type = left.getType ().asOf!{&SliceType} ().getInners ()[0us];

        let (cteLen, len) = context:.getCompileTimeInterpreter ().simplify (StructFieldAccessValue::new (loc, sizeType, left, SliceKeys::LEN));

        let maxSize = if (cteLen) { len.asOf!{&IntValue}().getValue () } else { BigInt::new (u64::max) };
        // Cte verification if possible, to check wether the index is positive
        let cteTest = self.verifyNotNegativeInt (alias context, loc, left.getType (), right, maximum-> maxSize);

        // Index is cast into a usize (as it will have to, for pointer arithmetic)
        let index = match right.getType ().asOf!{&IntType} ().getSize () {
            0us => { right }
            _ => {
                context:.getCastValidator ().validateCast (alias context, right, sizeType)
            }
        };

        if (cteLen && cteTest) {
            SliceAccessValue::new (loc, type, left, index)
        } else {
            // Slice size is not cte, then the test cannot be made at cte, we add a runtime check
            let cmp = CmpIntOperatorValue::new (loc, BinaryOperators::INF_EQUAL, len, index);

            let cond = self.createOutOfArrayTest (alias context, loc, cmp);
            let sliceAccess = SliceAccessValue::new (loc, type, left, index);

            BlockValue::new (loc, type, [cond, sliceAccess], isSet-> true)
        }
    }

    /**
     * Verify that the index is not negative (if CTE)
     * @returns: true, if the test is cte
     */
    fn verifyNotNegativeInt (self, dmut context : &Validator, loc : &Word, leftType : &Type, right : &Value, maximum : &BigInt = BigInt::new (u64::max))-> bool
        throws &ErrorMsg
    {
        let (isNegative, isTooBig, val) = {
            let i = context:.getCompileTimeInterpreter ().computeInt (right);
            (i < 0, i > maximum, i)
        } catch {
            // The value is not cte
            _ => { return false; }
        };

        if (isNegative) { // The cte value is negative, that cannot happen when used as index
            throw ErrorMsg::fatal (loc, end-> right.getLoc (), format (ValidateErrorMessage::NEGATIVE_INT_INDEX, leftType, val));
        }

        if (isTooBig) { // The cte value is bigger than the array length
            throw ErrorMsg::fatal (loc, end-> right.getLoc (), format (ValidateErrorMessage::ARRAY_OVERFLOW, maximum, val));
        }

        true
    }
    
    /**
     * Validate a index operation on a slice using a single range value
     * @params:
     *    - context: the context of the validation
     *    - loc: the location of the access
     *    - left: the left operand (of type slice)
     *    - right: the right operand (of type range)
     * @returns: an access value
     * @throws:
     *    - &ErrorMsg: if the access is impossible
     */
    fn validateSliceRange (self, dmut context : &Validator, loc : &Word, slice : &Value, right : &Value)-> &Value
        throws &ErrorMsg
    {
        match right.getType ().asOf!{&RangeType} ().getInners ()[0] {
            indexType : &IntType => { // range access only works if the range is made of integers
                let sizeType = IntType::new (loc, size-> 0u16, signed-> false);
                let innerType = slice.getType ().asOf!{&SliceType} ().getInners ()[0];

                // We create uniq values, to make sure they are constructed only one time
                // They are involved multiple times in the operation
                let rng = right;
                let (_, fstIndex) = context:.getCompileTimeInterpreter ().simplify (StructFieldAccessValue::new (loc, indexType, rng, RangeKeys::FST));
                let (_, scdIndex) = context:.getCompileTimeInterpreter ().simplify (StructFieldAccessValue::new (loc, indexType, rng, RangeKeys::SCD));

                // Cte verification if possible, to check wether the range values are correctly bounded
                let cteFst = self.verifyNotNegativeInt (alias context, loc, slice.getType (), fstIndex);
                let cteScd = self.verifyNotNegativeInt (alias context, loc, slice.getType (), scdIndex);

                // Cte verification to check wether the range is increasing or decreasing
                let cteOrder = self.verifyScdGTFst (alias context, loc, slice.getType (), fstIndex, scdIndex);

                let (fstSizeIndex, scdSizeIndex) = match indexType.getSize () {
                    0us => { (fstIndex, scdIndex) }
                    _ => { // casting index values into usize, as they will be involved in pointer arithmetics
                        let fstSize = context:.getCastValidator ().validateCast (alias context, fstIndex, sizeType);
                        let scdSize = context:.getCastValidator ().validateCast (alias context, scdIndex, sizeType);
                        (fstSize, scdSize)
                    }
                };

                // The new len is the subtraction of (range.scd - range.fst)
                let (_, newLen) = context:.getCompileTimeInterpreter ().simplify (BinaryMathIntOperatorValue::new (loc, sizeType, BinaryOperators::MINUS, scdSizeIndex, fstSizeIndex));
                let ptrType = PointerType::new (loc, innerType, isMutable-> innerType.isMutable ()); // the pointer type of the slice value [ptr ; len]
                let newPtr = BinaryMathPointerOperatorValue::new (loc, ptrType, BinaryOperators::PLUS,
                                                                  StructFieldAccessValue::new (loc, ptrType, slice, SliceKeys::PTR),
                                                                  fstSizeIndex); // the new pointer is the old pointer + range.fst

                let sliceCtor = SliceCtorValue::new (loc, slice.getType (), newPtr, newLen); // Construction of the slice from pointer and length
                let sliceValue = SliceValue::new (loc, slice.getType (), sliceCtor, implicitAlias-> false);
                let len = StructFieldAccessValue::new (loc, sizeType, slice, SliceKeys::LEN);
                let (cteLen, cmpLen) = context:.getCompileTimeInterpreter ().simplify (CmpIntOperatorValue::new (loc, BinaryOperators::INF, len, scdIndex));

                // If tests cannot be made at cte, then add runtime checks
                return if (!cteFst || !cteScd || !cteOrder) {
                    // The debug test is if (len < rng.scd || rng.scd < rng.fst) throw OutOfArray ();
                    let cmpRange = CmpIntOperatorValue::new (loc, BinaryOperators::INF, scdIndex, fstIndex);
                    let cmp = LogicalBinBoolOperatorValue::new (loc, BinaryOperators::DPIPE, cmpLen, cmpRange);

                    let cond = self.createOutOfArrayTest (alias context, loc, cmp);
                    BlockValue::new (loc, slice.getType (), [cond, sliceValue], isSet-> true)
                } else {
                    if (cteLen) { // even len < rng.scd can be cte checked !
                        sliceValue
                    } else {
                        // The debug test is if (len < rng.scd) throw OutOfArray ();, we already know that rng.scd >= rng.fst
                        let cond = self.createOutOfArrayTest (alias context, loc, cmpLen);
                        BlockValue::new (loc, slice.getType (), [cond, sliceValue], isSet-> true)
                    }
                }
            }
        }

        throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_INDEX_OP, slice.getType (), right.getType ()));
    }

    /**
     * Verify that the range indexes are increasing
     * @returns: true if the test can be made at cte
     */
    fn verifyScdGTFst (self, dmut context : &Validator, loc : &Word, leftType : &Type, fst : &Value, scd : &Value)-> bool
        throws &ErrorMsg
    {
        let (isLower, valF, valS) = {
            let f = context:.getCompileTimeInterpreter ().computeInt (fst);
            let s = context:.getCompileTimeInterpreter ().computeInt (scd);
            (s < f, f, s)
        } catch {
            _ => {
                return false;
            }
        };

        if (isLower) {
            throw ErrorMsg::fatal (loc, end-> fst.getLoc (), format (ValidateErrorMessage::DECREASING_RANGE_ACCESS, leftType, valF, valS));
        }

        true
    }

    /**
     * Create out of array conditional based on the test 'test'
     * @params:
     *    - context: the context of the validation
     *    - loc: the location of the slice access
     *    - test: the test of the conditional (conditional being entered if true at runtime)
     * @returns: a conditional value (with no else)
     */
    fn createOutOfArrayTest (self, dmut context : &Validator, loc : &Word, test : &Value)-> &Value
        throws &ErrorMsg
    {
        let syntVar = context.createSyntaxVarFromPath (loc, [CoreNames::CORE_MODULE, CoreNames::ARRAY_MODULE, CoreNames::OUT_OF_ARRAY_FUNC]);
        let callExpr = MultOperatorExpr::new (Word::new (Tokens::LPAR, loc),
                                          Word::new (Tokens::RPAR, loc),
                                          left-> syntVar,
                                          rights-> [], canBeDotCall-> false);

        let call = context:.validateValue (callExpr);
        let dmut cond = ConditionalValue::new (loc, VOID_TYPE, test, call, elsev-> NONE_VALUE, isComplete-> false);
        cond:.clearThrowers ();
        cond
    }

    /**
     * ================================================================================
     * ================================================================================
     * ========================            POINTERS             =======================
     * ================================================================================
     * ================================================================================
     */

    fn validatePointer (self, dmut context : &Validator, loc : &Word, left : &Value, rights : [&Value], rTypes : [&Type])-> &Value
        throws &ErrorMsg
    {
        let leftU = left;
        if (rTypes.len == 1us && rTypes [0].isOf!{&IntType} ()) {
            return self.validatePointerInteger (alias context, loc, leftU, rights[0]);
        }

        throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_INDEX_OP, left.getType (), rTypes));
    }

    /**
     * Validate an index access on a pointer value using an integer value
     * @params:
     *     - context: the context of the validation
     *     - loc: the location of the index
     *     - left: the left operand
     *     - right: the right operand
     * @returns: the access value
     * @throws:
     *    - &ErrorMsg: if the operation is impossible
     * */
    fn validatePointerInteger (self, dmut context : &Validator, loc : &Word, left : &Value, right : &Value)-> &Value
        throws &ErrorMsg
    {
        context:.verifyUnsafeContext (loc);

        let ptype = left.getType ().asOf!{&PointerType} ();
        let retType =
            if (!left.isLvalue ()) {
                ptype.getInners ()[0].clone (0u32)
            } else {
                ptype.getInners ()[0]
            };

        if (retType.isOf!{&VoidType} ()) {
            throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_INDEX_OP, ptype, right.getType ()));
        }

        let sizeType = IntType::new (loc, signed-> false, size-> 0u16);
        let sizeValue = context:.getCastValidator ().validateCast (alias context,
                                                                   context:.getSizeofValidator ().validate (alias context, loc, retType),
                                                                   sizeType);

        // Index is cast into a usize (as it will have to, for pointer arithmetic)
        let index = match right.getType ().asOf!{&IntType} ().getSize () {
            0us => { right }
            _ => { context:.getCastValidator ().validateCast (alias context, right, sizeType) }
        }

        let shiftedIndex = BinaryMathPointerOperatorValue::new (loc, sizeType, BinaryOperators::STAR, index, sizeValue);
        let pointerValue = BinaryMathPointerOperatorValue::new (loc, ptype, BinaryOperators::PLUS, left, shiftedIndex);
        return DereferencerValue::new (loc, retType, pointerValue);
    }
    
    /**
     * ================================================================================
     * ================================================================================
     * =========================        RIGHT OPERANDS        =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate the right operands
     * @params: 
     *   - context: the context of the validation
     *   - rightOps: the list of right operands
     * @returns: the list of right operands
     */
    fn validateRightOperands (self, dmut context : &Validator, rightOps : [&Expression])-> ([&Value], [&Type])
        throws &ErrorMsg
    {
        let dmut errors = Vec!{&ErrorMsg}::new ();
        let dmut rights = Vec!{&Value}::new ();
        let dmut types = Vec!{&Type}::new ();
        
        for r in rightOps {
            {
                let v = context:.validateValue (r);
                match v {
                    e : &ExpandValue => {
                        for i_v in e.getInnerValues () {
                            rights:.push (i_v);
                            types:.push (i_v.getType ());
                        }
                    }
                    _ => {
                        rights:.push (v);
                        types:.push (v.getType ());
                    }
                }            
            } catch {
                err : &ErrorMsg => {
                    errors:.push (err);
                }
            }
        }

        if (errors.len () != 0us) throw ErrorMsg::list (errors[]);

        (rights [], types [])
    }

    
    
}
