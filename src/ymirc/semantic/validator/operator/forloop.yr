in forloop;

use ymirc::semantic::validator::{visitor, errors, template::_};

use ymirc::errors::_;
use ymirc::utils::{format, bigint, bigfloat, math};

use ymirc::syntax::{_,
                    declaration::_,
                    expression::{_, literal::_, macro_::_, operator::_, template::_}};

use ymirc::lexing::{word, tokens};
use ymirc::global::core_;

use ymirc::semantic::generator::{value::_, type::_};
use ymirc::semantic::generator::type::{_,
                                       syntax::_,
                                       custom::_,
                                       native::{_, scalar::_, compound::_},
                                       temporary::_};

use ymirc::semantic::generator::value::{_,
                                        syntax::_,
                                        construct::{_, delegate::_},
                                        literal::_,
                                        memory::_,
                                        operator::{_, binary::_, call::_, fields::_, map::_, slice::_, unary::_},
                                        operator::binary::{bool_::_, char_::_, float_::_, int_::_, pointer_::_},
                                        operator::map::iteration::_,
                                        prototypes::_,
                                        scope::_,
                                        syntax::_,
                                        template::_};

/**
 * The For loop validator is used to validate ForLoopExpr
 * It is a class validator because for loop operations are complex
 */
pub record ForLoopValidator {

    /**
     * Create an empty validator     
     */
    pub self () {}
    
    /**
     * Validate a for loop expression
     * @params: 
     *  - context: the context of the validation
     *  - f: the for loop to validate
     * @returns: a value
     * @throws:
     *   - &ErrorMsg: if the validation failed
     */
    pub fn validate (self, dmut context : &Validator, f : &ForLoopExpr) -> &Value
        throws ErrorMsg
    {
        let mValue = context.implicitEnumUnwrap (context:.getValueValidator ().validate (alias context, f.getValue (), canBeRef-> true));
        let (byMutRef, byAlias, fVal) = match mValue {
            r : &ReferencerValue => { (r.isMutable (), false, r.getValue ()) }
            a : &AliaserValue => { (false, true, a.getValue ()) }
            _ => { (false, false, mValue) }
        };

        let (value, innerUseRef, innerUseAlias) = match fVal.getType () {
            t : &TupleType => { self.validateTupleLoop  (alias context, t, fVal, f, byMutRef, byAlias) }
            s : &SliceType => { self.validateSliceLoop  (alias context, s, fVal, f, byMutRef, byAlias) }
            a : &ArrayType => { self.validateArrayLoop  (alias context, a, fVal, f, byMutRef, byAlias) }
            m : &MapType   => { self.validateMapLoop    (alias context, m, fVal, f, byMutRef, byAlias) }
            r : &RangeType => { (self.validateRangeLoop (alias context, r, fVal, f), false, false) }
            c : &ClassPtrType => {
                let value = self.validateClassLoop (alias context, c, fVal, f, byAlias, mValue.getLoc ());
                (value, false, true) // by alias error would already be thrown inside the class loop method
            }
            _ => {
                throw copy ErrorMsg::fatal (f.getLoc (), format (ValidateErrorMessage::UNDEF_FOR_LOOP_OPERATOR, f.getVariables ().len, fVal.getType ()));
            }
        }

        if (!innerUseRef && byMutRef) {
            throw copy ErrorMsg::fatal (mValue.getLoc (), ValidateErrorMessage::UNECESSARY_REFERENCE);
        } else if (!innerUseAlias && byAlias) {
            throw copy ErrorMsg::fatal (mValue.getLoc (), format (ValidateErrorMessage::UNECESSARY_ALIAS, mValue.getType ()));
        }

        value
    }

    /**
     * Validate a for loop expression that is unrolled at cte
     * @params:
     *    - context: the context of the compilation
     *    - f: the for loop to validate
     * @returns: a block containing the unrolled for loop
     * @throws:
     *    - &ErrorMsg: if the validation failed
     * */
    pub fn validateCteForLoop (self, dmut context : &Validator, f : &ForLoopExpr)-> &Value
        throws ErrorMsg
    {
        let value = context.implicitEnumUnwrap (context:.validateValue (f.getValue ()));
        match value.getType () {
            t : &TupleType => { self.validateTupleLoop (alias context, t, value, f, false, false)._0 }
            r : &RangeType => { self.validateCteRangeLoop (alias context, r, value, f) }
            _ => {
                throw copy ErrorMsg::fatal (f.getLoc (), format (ValidateErrorMessage::UNDEF_CTE_FOR_LOOP_OPERATOR, f.getVariables ().len, value.getType ()));
            }
        }
    }

    /**
     * Validate a slice for loop expression
     * @params:
     *    - context: the context of the validation
     *    - all: the slice allocator to validate
     * @returns: a value
     * @throws:
     *    - &ErrorMsg, if the validation failed
     * */
    pub fn validateListComprehension (self, dmut context : &Validator, all : &SliceForAllocatorExpr)-> &Value
        throws ErrorMsg
    {
        let dynamic = context.isDynamic (all);
        let value = context.implicitEnumUnwrap (context:.validateValue (all.getIter ()));
        let (byMutRef, byAlias) = match value {
            r : &ReferencerValue => { (r.isMutable (), false) }
            _ : &AliaserValue => { (false, true) }
            _ => { (false, false) }
        };

        if (byMutRef) { // list comprehension is always const, so not by mut ref, and not by alias
            throw copy ErrorMsg::fatal (value.getLoc (), ValidateErrorMessage::UNECESSARY_REFERENCE);
        }

        let (res, innerUseAlias) = match value.getType () {
            t : &TupleType => { (self.validateComprTuple (alias context, t, value, all), false) }
            s : &SliceType => { (self.validateComprSlice (alias context, s, value, all, dynamic), false) }
            a : &ArrayType => { (self.validateComprArray (alias context, a, value, all, dynamic), false) }
            r : &RangeType => { (self.validateComprRange (alias context, r, value, all, dynamic), false) }
            m : &MapType   => { (self.validateComprMap   (alias context, m, value, all, dynamic), false) }
            c : &ClassPtrType => {
                // by alias error would already be thrown inside the class loop method
                (self.validateComprClass (alias context, c, value, all, byAlias, value.getLoc (), dynamic), true)
            }
            _ => {
                throw copy ErrorMsg::fatal (all.getForLoc (), format (ValidateErrorMessage::UNDEF_FOR_LOOP_OPERATOR, all.getVariables ().len, value.getType ()));
            }
        }

        if (byAlias && !innerUseAlias) {
            throw copy ErrorMsg::fatal (value.getLoc (), format (ValidateErrorMessage::UNECESSARY_ALIAS, value.getType ()));
        }

        res
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================        LOOP ON TUPLES        =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a for loop on a tuple
     * @params: 
     *    - context: the context of the validation
     *    - type: the type of the tuple
     *    - value: the value to iterate
     *    - f: the for loop to validate
     * @throws: 
     *    - &ErrorMsg: if the validation failed
     * @returns: the validated loop
     */
    fn validateTupleLoop (self, dmut context : &Validator, type : &TupleType, value : &Value, f : &ForLoopExpr, byMutRef : bool, byAlias : bool)-> (&Value, bool, bool)
        throws ErrorMsg
    {
        let vars = f.getVariables ();
        match vars.len {
            1us => {
                return self.validateTupleIteration (alias context, type, value, f, vars[0], EMPTY_EXPR, byMutRef, byAlias);
            }
            2us => {
                return self.validateTupleIteration (alias context, type, value, f, vars[0], vars[1], byMutRef, byAlias);
            }
            _ => {
                throw copy ErrorMsg::fatal (f.getLoc (), format (ValidateErrorMessage::UNDEF_FOR_LOOP_OPERATOR, vars.len, type));
            }
        }
    }

    /**
     * Validate a for loop iteration on a tuple
     * @params:
     *     - context: the context of the validation
     *     - type: the type of the tuple
     *     - value: the value of the tuple (already uniq)
     *     - f: the for loop
     *     - iter1: the declaration of the first iteration variable
     *     - iter2: the declaration of the second iteration variable (might be EmptyExpression)
     * @throws:
     *     - &ErrorMsg: if the validation failed
     * @returns: the validated loop
     * */
    fn validateTupleIteration (self, dmut context : &Validator, type : &TupleType, value : &Value, f : &ForLoopExpr, iter1 : &Expression, iter2 : &Expression, byMutRef : bool, byAlias : bool)-> (&Value, bool, bool)
        throws ErrorMsg
    {
        let mut useRef = false, mut useAlias = false;
        let mut content : [&Value] = [];
        context:.enterLoop ();// Even if it is unwinded at compile time, it should behave like a loop (so we can break in it)
        context:.setCurrentLoopType (copy VoidType (f.getLoc ())); // it has no type, (because there is no else part for the moment ?, in theory it is no necessary if we check that there is at least one value in the tuple?)
        {
            for i in 0us .. type.getInners ().len { // we validate the content of the loop for each type of the tuple
                let (value_, useRef_, useAlias_) = self.validateTupleInnerLoop (alias context, i, iter1, iter2, type, value, f.getBlock (), byMutRef, byAlias);
                content ~= [value_];
                useAlias = useAlias || useAlias_;
                useRef = useRef || useRef_;
            }
        } catch {
            err : &ErrorMsg => {
                context:.quitLoop (); // we must not forget to quit the loop
                throw err;
            }
        }

        context:.quitLoop ();
        let inner = copy BlockValue (f.getLoc (), copy VoidType (f.getLoc ()), content);
        (copy LoopValue (f.getLoc (), copy VoidType (f.getLoc ()), UNIT_VALUE, inner, false, isCteFor-> true), useRef, useAlias)
    }

    /**
     * Validate the inner content of a loop iteration over a tuple value
     * @params: 
     *     - context: the context of the validation
     *     - i: the index of the current iteration 
     *     - vdecl: the variable iterator to declare
     *     - type: the type of the tuple to iterate
     *     - value: the content of the tuple value
     *     - blk: the content of the for loop
     * @returns: the content of the for loop validated for th i-th iteration
     * @throws:
     *    - &ErrorMsg: if the validation failed
     */
    fn validateTupleInnerLoop (self, dmut context : &Validator, i : usize, iter1 : &Expression, iter2 : &Expression, type : &TupleType, value : &Value, blk : &Expression, byMutRef : bool, byAlias : bool, forLstCompr : bool = false)-> (&Value, bool, bool)
        throws ErrorMsg
    {
        let mut errors : [&ErrorMsg] = [];
        context:.enterBlock ();
        let (pre, res, useRef, useAlias) = { // Simply validate the content of a single iteration
            match (iter1, iter2) {
                (vdecl : &VarDeclExpr, EmptyExpression ()) => {
                    let (var, useRef, useAlias) = self.validateTupleIterDecl (alias context, vdecl, type, value, byMutRef, byAlias, i);
                    context:.insertLocal (vdecl.getLoc (), vdecl.getName ().str, var); // we declare the variable so we can retreive it inside the loop

                    let content = context:.validateValue (blk); // we validate the content of the loop
                    ([var], content, useRef, useAlias) // and we return the loop iteration block
                }
                (idecl : &VarDeclExpr, vdecl : &VarDeclExpr) => {
                    let (var, useRef, useAlias) = self.validateTupleIterDecl (alias context, vdecl, type, value, byMutRef, byAlias, i);
                    context:.insertLocal (vdecl.getLoc (), vdecl.getName ().str, var);

                    let indexType = copy IntType (idecl.getLoc (), size-> 0u16, signed-> false);
                    let indexVal = makeIntValue (idecl.getLoc (), i);
                    let index = self.validateIndexIterDecl (alias context, value.getLoc (), idecl, indexType, value-> indexVal, globType-> type, canCte-> true);
                    context:.insertLocal (idecl.getLoc (), idecl.getName ().str, index);

                    let content = context:.validateValue (blk); // we validate the content of the loop
                    ([var, index], content, useRef, useAlias)
                }
                _ => panic;
            }
        } catch {
            err: &ErrorMsg => {
                errors ~= [err];
                ([], UNIT_VALUE, false, false)
            }
        }

        {
            context:.quitBlock (warnUnused-> errors.len == 0us); // if there was an error, we don't add the warn unused
        } catch { 
            err : &ErrorMsg => { errors ~= [err]; }
        }

        let blkRes = if (forLstCompr) {
            let innerType = context:.inferTypeImplicitMutability (res);

            copy BlockValue (blk.getLoc (), innerType, pre ~ [res])
        } else {
            copy BlockValue (blk.getLoc (), copy VoidType (blk.getLoc ()), pre ~ [res])
        };

        if (errors.len != 0us) throw copy ErrorMsg::list (errors);
        (blkRes, useRef, useAlias)
    }

    /**
     * Validate the iterator variable of a tuple iteration
     * @params:
     *    - context: the context of the validation
     *    - vdecl: the iterator variable declaration
     *    - type: the type of the tuple
     *    - value: the value being iterated
     *    - byMutRef: true if the value is passed by mutable reference
     *    - byAlias: true if the value was aliased
     *    - i: the current index
     * */
    fn validateTupleIterDecl (self, dmut context : &Validator, vdecl : &VarDeclExpr, type : &TupleType, value : &Value, byMutRef : bool, byAlias : bool, i : usize)-> (&Value, bool, bool)
        throws ErrorMsg
    {
        let curTupleType = type.getInners()[i];

        let mut useRef = false, mut useAlias = false;
        let vType = if (vdecl.getType () !of EmptyExpression) {
            let vtype = context:.validateTypeForVarDecl (vdecl.getType (), vdecl, canBeRef-> true);
            context.verifyCompatibleType (vdecl.getType ().getLoc (), curTupleType.getLoc (), vtype, curTupleType);
            vtype
        } else {
            context:.validateTypeForVarDecl (copy TypeWrapperExpr (value.getLoc (), curTupleType), vdecl, canBeRef-> true)
        };

        if (vType.isMutable () && !vType.needExplicitAlias () && !vType.isMovable () && !vdecl.isRef ()) {
            throw copy ErrorMsg::fatal (vdecl.getMutOrDmutLocation (), ValidateErrorMessage::MUTABLE_CONST_ITERATOR);
        }

        let indexValue = context:.getBinOpValidator ().createTupleFieldAccess (vdecl.getLoc (), type.getInners ()[i], value, i, reduce-> false);
        let reducedValue = if (!byMutRef && !vdecl.isRef ()) { context:.getCompileTimeInterpreter ():.reduce (indexValue) } else { indexValue };
        let iterValue = context:.verifyCompatibleTypeWithValue (vdecl.getLoc (), vType, reducedValue, byReference-> vdecl.isRef ());

        let access = if (byMutRef && vdecl.isRef () && curTupleType.isMutable () && iterValue.isLvalue ()) {
            useRef = true;
            copy ReferencerValue (vdecl.getLoc (), iterValue.getType (), iterValue, isMutable-> true)
        } else if (!vdecl.isRef () && byAlias && curTupleType.isMutable () && vType.needExplicitAlias ()) {
            useAlias = true;
            copy AliaserValue (vdecl.getLoc (), iterValue.getType (), iterValue)
        } else if (vdecl.isRef () && !byMutRef && iterValue.isLvalue ()) {
            copy ReferencerValue (vdecl.getLoc (), iterValue.getType (), iterValue, isMutable-> false)
        } else {
            iterValue
        };

        context.verifyMemoryOwner (vdecl.getLoc (), vType, access, construct-> true, byReference-> vdecl.isRef ());
        let nameLoc = if (vdecl.getLoc () == Keys::UNDER) {
            copy Word ("#_iter", vdecl.getLoc ())
        } else {
            vdecl.getLoc ()
        };

        let decl = copy VarDeclValue (nameLoc, vType, access, isMutable-> (vdecl.isMutable () || vdecl.isDeeplyMutable ()), isReference-> vdecl.isRef (), isIterator-> true);
        (decl, useRef, useAlias)
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================        LOOP ON ARRAYS        =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a for loop operation on an array value
     * @params:
     *    - context: the context of the validation
     *    - arrType: the type of the value
     *    - value: the value being iterated
     *    - content: the expression to validate
     * @returns: a validate value
     * @throws:
     *     - &ErrorMsg: if the validation failed
     * */
    fn validateArrayLoop (self, dmut context : &Validator, arrType : &ArrayType, value : &Value, content : &ForLoopExpr, byMutRef : bool, byAlias : bool)-> (&Value, bool, bool)
        throws ErrorMsg
    {
        if (arrType.getInners () [0] of VoidType) {
            throw copy ErrorMsg::fatal (content.getLoc (), format (ValidateErrorMessage::UNDEF_FOR_LOOP_OPERATOR, content.getVariables ().len, value.getType ()));
        }

        let vars = content.getVariables ();
        let uniqV = context.createSliceAliasFromArray (content.getLoc (), arrType, value, mutable-> (byMutRef || byAlias) && arrType.isMutable ());
        let slcT = uniqV.getType ().asOf!{&SliceType} ();

        match vars.len {
            1us => // only the value of the array
                return self.validateSliceIteration (alias context, slcT, uniqV, content, vars[0], EMPTY_EXPR, byMutRef, byAlias);
            2us => // The value of the array and the iterator
                return self.validateSliceIteration (alias context, slcT, uniqV, content, vars[0], vars[1], byMutRef, byAlias);
            _ => { // no iteration is possible with three variables
                throw copy ErrorMsg::fatal (content.getLoc (), format (ValidateErrorMessage::UNDEF_FOR_LOOP_OPERATOR, vars.len, arrType));
            }
        }
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================        LOOP ON SLICES        =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a for loop iterating through a slice value
     * @params: 
     *     - context: the context of the validation
     *     - slcType: the type of the iteration
     *     - value: the value that is iterated
     *     - content: the content of the iteration to validate
     */
    fn validateSliceLoop (self, dmut context : &Validator, slcType : &SliceType, value : &Value, content : &ForLoopExpr, byMutRef : bool, byAlias : bool)-> (&Value, bool, bool)
        throws ErrorMsg
    {
        if (slcType.getInners () [0] of VoidType) {
            throw copy ErrorMsg::fatal (content.getLoc (), format (ValidateErrorMessage::UNDEF_FOR_LOOP_OPERATOR, content.getVariables ().len, value.getType ()));
        }

        let vars = content.getVariables ();
        match vars.len {
            1us => // only the value of the array
                return self.validateSliceIteration (alias context, slcType, value, content, vars[0], EMPTY_EXPR, byMutRef, byAlias);
            2us => // The value of the array and the iterator
                return self.validateSliceIteration (alias context, slcType, value, content, vars[0], vars[1], byMutRef, byAlias);
            _ => { // no iteration is possible with three variables
                throw copy ErrorMsg::fatal (content.getLoc (), format (ValidateErrorMessage::UNDEF_FOR_LOOP_OPERATOR, vars.len, slcType));
            }
        }
    }

    /**
     * Validate the iteration over the slice
     * @params: 
     *    - context: the context of the validation
     *    - slcType: the type of the slice of the iteration
     *    - value: the value of the slice of the iteration
     *    - content: the for loop containing the ocntent of the iteration
     *    - iter1: the first iteration variable (never empty)
     *    - iter2: the second iteration variable (might be empty)
     * @returns: the value of the iteration
     * @throws:
     *    - &ErrorMsg: if the iteration cannot be validated
     */
    fn validateSliceIteration (self, dmut context : &Validator, slcType : &SliceType, sliceValue : &Value, content : &ForLoopExpr, iter1 : &Expression, iter2 : &Expression, byMutRef : bool, byAlias : bool)-> (&Value, bool, bool)
        throws ErrorMsg
    {
        let mut errors : [&ErrorMsg] = [];
        let mut innerValues : [&Value] = [];
        let mut values : [&Value] = [];
        let loc = content.getLoc ();
        let mut test : &Value = UNIT_VALUE;
        let mut useRef = false, mut useAlias = false;

        // => for index, value in S
        // ==
        // let array = S;
        // let index = 0;
        // while index < array.len {
        //    let value = array [index];
        //    {  } // content
        //    index += 1;
        // }

        context:.enterLoop ();
        context:.setCurrentLoopType (copy VoidType (content.getLoc ()));

        context:.enterBlock ();
        {
            let sliceDecl = copy VarDeclValue (copy Word ("#_value", sliceValue.getLoc ()), slcType, sliceValue, isMutable-> (byMutRef || byAlias) && slcType.isMutable ());
            let sliceRef = copy VarRefValue (sliceDecl.getLoc (), sliceDecl.getLoc (), slcType, sliceDecl.getUniqId (), isSelf-> false, canCte-> false);
            values ~= [sliceDecl];

            // First we create the iteration variables, that will store the value at the current array index, and the value of the index
            let vars = self.validateSliceIteratorVars (alias context, sliceValue.getLoc (), slcType, sliceRef, iter1, iter2, byMutRef, byAlias);
            let iter = vars._0; // the value of the current index

            values ~= [vars._1]; // declare index iterator outside the content of the loop

            useRef = vars._3;
            useAlias = vars._4;

            let one = makeIntValue (loc, 1us); // used to increment the iterator

            // access the size of the array to verify test when to exit the loop
            let len = {
                // Compute the len from the initial value, because the generator #_value may lose the cte len (e.g. a [0 .. 2], [1, 2, 3], ...)
                let bi = context:.getCompileTimeInterpreter ():.computeInt (copy StructFieldAccessValue (loc, one.getType (), sliceValue, SliceKeys::LEN));
                copy IntValue (loc, one.getType ().asOf!{&IntType} (), bi)
            } catch {
                _ => { // it is not cte, so we can use the value from the uniq value instead, to avoid recreating the slice at each iteration
                    context:.getCompileTimeInterpreter ():.reduce (copy StructFieldAccessValue (loc, one.getType (), sliceRef, SliceKeys::LEN))
                }
            };

            test = copy CmpIntOperatorValue (loc, BinaryOperators::INF, iter, len); // if the iterator is greater than the value of the array the loop is stopped
            let increment = copy AffectValue (loc, iter.getType (), iter, copy BinaryMathIntOperatorValue (loc, iter.getType (), BinaryOperators::PLUS, iter, one)); // increment the iterator for the next iteration

            // the loop has three steps: value iterator declarations, content, increment
            innerValues ~= [vars._2];
            innerValues ~= [context:.validateValue (content.getBlock ())]; // execute the content of the loop
            innerValues ~= [increment];
            // go to the next iteration
        } catch {
            err : &ErrorMsg => { errors ~= [err]; } // we catch everything because we need to exit the block
        }

        let blkContent = copy BlockValue (loc, copy VoidType (loc), innerValues); // create the loop
        let _loop = copy LoopValue (loc, copy VoidType (loc), test-> test, blkContent, isDo-> false);
        values ~= [_loop];

        {
            context:.quitLoop ();
            context:.quitBlock (warnUnused-> errors.len == 0us); // we only warn if there was no error in the loop content
        } catch {
            err : &ErrorMsg => { errors ~= [err]; } // some warn unused
        }

        if (errors.len != 0us) throw copy ErrorMsg::list (errors);
        (copy BlockValue (loc, copy VoidType (loc), values), useRef, useAlias)
    }

    /**
     * Create the iteration variable (and verify that they are correctly defined)
     * @params: 
     *    - context: the context of the validaiton
     *    - loc: the location of the value iterated
     *    - slcType: the type of the iteration
     *    - iter1: the iterator (value if iter2 is empty, index otherwise)
     *    - iter2: value if not empty
     * @returns:
     *    - .0: the ref to the index variable (even if iter2 is empty)
     *    - .1: the vardecl of the index variable (even if iter1 is empty)
     *    - .2: the vardecl of the value variable
     * @throws:
     *    - &ErrorMsg: if the variables are uncorrectly defined
     */
    fn validateSliceIteratorVars (self, dmut context : &Validator, loc : &Word, slcType : &SliceType, sliceRef : &Value, iter1 : &Expression, iter2 : &Expression, byMutRef : bool, byAlias : bool)-> (&Value, &Value, &Value, bool, bool)
        throws ErrorMsg
    {
        // This function can seem a bit complex but isn't
        match (iter1, iter2) { // we have two cases, (with one variable, or with two)            
            (v : &VarDeclExpr, EmptyExpression ()) => { // 1. with one
                // And the variable for the iterator, with an name that cannot be taken elsewhere, but this is not important
                let iter = copy VarDeclValue (copy Word ("#_iter", v.getLoc ()), copy IntType (v.getLoc (), size-> 0u16, signed-> false), makeIntValue (v.getLoc (), 0us), isMutable-> false, isIterator-> true);
                let vrefIter = copy VarRefValue (iter.getLoc (), iter.getLoc (), iter.getVarType (), iter.getUniqId (), isSelf-> false, canCte-> false, isIterator-> true);

                let (array, useRef, useAlias) = self.validateSliceIterDecl (alias context, v, slcType, sliceRef, vrefIter, byMutRef, byAlias);
                context:.insertLocal (v.getLoc (), v.getName ().str, array); // The variable must be retreivable, so we insert it inside the context, (but not the iterator that is hidden)

                return (vrefIter, iter, array, useRef, useAlias); // we return the variable for the loop validation
            }
            (i : &VarDeclExpr, v : &VarDeclExpr) => {
                let iter = self.validateIndexIterDecl (alias context, loc, i, copy IntType (i.getLoc (), size-> 0u16, signed-> false), value-> makeIntValue (i.getLoc (), 0us), slcType, canCte-> false);
                let vrefIter = copy VarRefValue (iter.getLoc (), iter.getLoc (), iter.getVarType (), iter.getUniqId (), isSelf-> false, canCte-> false, isIterator-> true);

                let (array, useRef, useAlias) = self.validateSliceIterDecl (alias context, v, slcType, sliceRef, vrefIter, byMutRef, byAlias);
                context:.insertLocal (v.getLoc (), v.getName ().str, array); // insert them, so we can retreive them
                context:.insertLocal (i.getLoc (), i.getName ().str, iter);

                return (vrefIter, iter, array, useRef, useAlias); // and we return them for the loop valiation
            }
            _ => panic; // panic if we get something else
        }
    }

    /**
     * Validate the iterator variable of a slice iteration
     * @params:
     *    - context: the context of the validation
     *    - vdecl: the iterator variable declaration
     *    - type: the type of the slice
     *    - value: the value being iterated
     *    - index: the variable reference to the index value
     *    - byMutRef: true if the value is passed by mutable reference
     *    - byAlias: true if the value was aliased
     * */
    fn validateSliceIterDecl (self, dmut context : &Validator, vdecl : &VarDeclExpr, type : &SliceType, sliceValue : &Value, index : &Value, byMutRef : bool, byAlias : bool)-> (&Value, bool, bool)
        throws ErrorMsg
    {
        let innerType = type.getInners ()[0];

        let mut useRef = false, mut useAlias = false;

        let vType = if (vdecl.getType () !of EmptyExpression) {
            let vtype = context:.validateTypeForVarDecl (vdecl.getType (), vdecl, canBeRef-> true);
            context.verifyCompatibleType (vdecl.getType ().getLoc (), innerType.getLoc (), vtype, innerType);
            vtype
        } else {
            context:.validateTypeForVarDecl (copy TypeWrapperExpr (sliceValue.getLoc (), innerType), vdecl, canBeRef-> true)
        };

        if (vType.isMutable () && !vType.needExplicitAlias () && !vType.isMovable () && !vdecl.isRef ()) {
            throw copy ErrorMsg::fatal (vdecl.getMutOrDmutLocation (), ValidateErrorMessage::MUTABLE_CONST_ITERATOR);
        }

        let slAcc : &Value = copy SliceAccessValue (sliceValue.getLoc (), innerType, sliceValue, index);
        let reducedValue = if (!byMutRef && !vdecl.isRef ()) { context:.getCompileTimeInterpreter ():.reduce (slAcc) } else { slAcc };
        let iterValue = context:.verifyCompatibleTypeWithValue (vdecl.getLoc (), vType, reducedValue, byReference-> vdecl.isRef ());

        let access = if (byMutRef && vdecl.isRef () && innerType.isMutable () && iterValue.isLvalue ()) {
            useRef = true;
            copy ReferencerValue (vdecl.getLoc (), iterValue.getType (), iterValue, isMutable-> true)
        } else if (!vdecl.isRef () && byAlias && innerType.isMutable () && vType.needExplicitAlias ()) {
            useAlias = true;
            copy AliaserValue (vdecl.getLoc (), iterValue.getType (), iterValue)
        } else if (vdecl.isRef () && !byMutRef && iterValue.isLvalue ()) {
            copy ReferencerValue (vdecl.getLoc (), iterValue.getType (), iterValue, isMutable-> false)
        } else {
            iterValue
        };

        context.verifyMemoryOwner (vdecl.getLoc (), vType, access, construct-> true, byReference-> vdecl.isRef ());
        let nameLoc = if (vdecl.getLoc () == Keys::UNDER) {
            copy Word ("#_iter", vdecl.getLoc ())
        } else {
            vdecl.getLoc ()
        };

        let decl = copy VarDeclValue (nameLoc, vType, access, isMutable-> (vdecl.isMutable () || vdecl.isDeeplyMutable ()), isReference-> vdecl.isRef (), isIterator-> true);
        (decl, useRef, useAlias)
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ==================================          LOOP ON MAPS          ==================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Validate a for loop on a map value
     * @params:
     *    - context: the context of the validation
     *    - mapType : the type of the map
     *    - value: the valur to iterate
     *    - content: the for loop to validate
     * @returns: the validated loop
     * @throws:
     *   - &ErrorMsg: if the validation fails
     */
    fn validateMapLoop (self, dmut context : &Validator, mapType : &MapType, value : &Value, content : &ForLoopExpr, byMutRef : bool, byAlias : bool)-> (&Value, bool, bool)
        throws ErrorMsg
    {
        let vars = content.getVariables ();
        let (key, val) = match vars.len {
            1us => {
                let name = copy Word (Keys::UNDER, content.getLoc ());
                let valVar = copy VarDeclExpr (name, name, EMPTY_EXPR, EMPTY_EXPR);
                (vars [0], valVar)
            }
            2us => {
                (vars [0], vars [1])
            }
            _ => throw copy ErrorMsg::fatal (content.getLoc (), format (ValidateErrorMessage::UNDEF_FOR_LOOP_OPERATOR, vars.len, mapType));
        };

        match (key, val) {
            (keyIter : &VarDeclExpr, valIter : &VarDeclExpr) => {
                return self.validateMapIteration (alias context, mapType, value, content, keyIter, valIter, byMutRef, byAlias);
            }
            _ => throw copy ErrorMsg::fatal (content.getLoc (), format (ValidateErrorMessage::UNDEF_FOR_LOOP_OPERATOR, vars.len, mapType));
        }
    }

    /**
     * Validate the iteration over a map
     * @params:
     *    - context: the context of the validation
     *    - mapType: the type of the map being iterated
     *    - value: the value of the map being iterated
     *    - content: the content of the for loop
     *    - iter1: the first iteration variable
     *    - iter2: the second iteration variable
     * @returns: the value of the iteration
     * @throws:
     *    - &ErrorMsg: if the iteration is malformed
     * */
    fn validateMapIteration (self, dmut context : &Validator, mapType : &MapType, value : &Value, content : &ForLoopExpr, keyIter : &VarDeclExpr, valIter : &VarDeclExpr, byMutRef : bool, byAlias : bool)-> (&Value, bool, bool)
        throws ErrorMsg
    {
        let mut errors : [&ErrorMsg] = [];
        let mut innerValues : [&Value] = [];
        let mut values : [&Value] = [];
        let mut finalValues : [&Value] = [];

        let loc = content.getLoc ();

        // for key, value in mp
        // ==
        //  let iterator = _yrt_map_begin (mp);
        //  {
        //     while (_yrt_map_end (iterator)) {
        //        let key = _yrt_map_iterator_key (iterator);
        //        let val = _yrt_map_iterator_value (iterator);
        //        {  } // content
        //        _yrt_map_iterator_next (iterator);
        //     }
        //  } exit {
        //     _yrt_map_close (iterator);
        //  }

        context:.enterLoop ();
        context:.setCurrentLoopType (copy VoidType (content.getLoc ()));

        context:.enterBlock ();
        let (test, useAlias, useRef) = {
            let iterType = copy MapIteratorType (value.getLoc (), mapType);
            let beginValue = copy MapIteratorBeginValue (content.getLoc (), iterType, value);
            let iterDecl = copy VarDeclValue (copy Word ("#_iter", value.getLoc ()), iterType, beginValue, isMutable-> true);
            let iterRef = copy VarRefValue (iterDecl.getLoc (), iterDecl.getLoc (), iterType, iterDecl.getUniqId (), isSelf-> false, canCte-> false);
            values ~= [iterDecl]; // create the iterator over the map

            // Create the index and value iterators using the created iterator
            let (keyDecl, valDecl, useRef, useAlias) = self.validateMapIteratorVars (alias context, mapType, iterRef, keyIter, valIter, byMutRef, byAlias, value.isLvalue ());

            innerValues ~= [keyDecl]; // Insert their declaration inside the for loop content
            innerValues ~= [valDecl];

            // Insert the variable in the current scop
            context:.insertLocal (keyIter.getLoc (), keyIter.getName ().str, keyDecl);
            context:.insertLocal (valIter.getLoc (), valIter.getName ().str, valDecl);

            innerValues ~= [context:.validateValue (content.getBlock ())]; // validate the content of the loop
            innerValues ~= [copy MapIteratorNextValue (content.getLoc (), iterRef)]; // gotos the next element in the map

            finalValues ~= [copy MapIteratorDelValue (content.getLoc (), iterRef)]; // The iterator might need clearing at the end of the for loop ?
            (copy MapIteratorEndValue (content.getLoc (), iterRef), useAlias, useRef) // the test, checking wether the map iterator reached the end of the map ?
        } catch {
            err : &ErrorMsg => {
                errors ~= [err];
                (UNIT_VALUE, false, false)
            }
        }

        let vdType = copy VoidType (loc);
        let blkContent = copy BlockValue (loc, vdType, innerValues); // create the loop
        let _loop = copy LoopValue (loc, vdType, test-> test, blkContent, isDo-> false); // Loop value
        let finBlk = copy BlockValue (loc, vdType, finalValues);
        let finally = copy TryFinallyValue (loc, vdType, _loop, finBlk, failVar-> UNIT_VALUE); // try { loop } finally { del; }

        values ~= [finally];

        {
            context:.quitLoop ();
            context:.quitBlock (warnUnused-> errors.len == 0us); // we only warn if there was no error in the loop content
        } catch {
            err : &ErrorMsg => { errors ~= [err]; } // some warn unused
        }

        if (errors.len != 0us) throw copy ErrorMsg::list (errors);
        (copy BlockValue (loc, copy VoidType (loc), values), useRef, useAlias) // { let iter = ...; try {loop} finally... }
    }

    /**
     * Validate the iterator variables of a map iteration
     * @params:
     *    - context: the context of the iteration
     *    - loc: the location of the iteration
     *    - mapType: the type of the map being iterated
     *    - iterRef: the reference to the iterator variable
     *    - keyIter: the key iterator var decl
     *    - valueIter: the value iterator var decl
     * */
    fn validateMapIteratorVars (self, dmut context : &Validator, mapType : &MapType, iterRef : &Value, keyIter : &VarDeclExpr, valIter : &VarDeclExpr, byMutRef : bool, byAlias : bool, mapIsLvalue : bool)-> (&Value, &Value, bool, bool)
        throws ErrorMsg
    {
        let mapKeyType = mapType.getInners ()[0];
        let mapValType = mapType.getInners ()[1];

        if (!keyIter.getLazyOrRefLocation ().isEof ()) { // key is the index and therefore cannot be lazy or a ref
            // In practice key is a always a reference, but it does not need the developper to know to be usable
            throw copy ErrorMsg::fatal (keyIter.getLazyOrRefLocation (), format (ValidateErrorMessage::FORBID_DECO_FOR_LOOP, mapType));
        }

        if (!keyIter.getMutOrDmutLocation ().isEof ()) { // It also cannot be mutable
            throw copy ErrorMsg::fatal (keyIter.getMutOrDmutLocation (), format (ValidateErrorMessage::FORBID_DECO_FOR_LOOP, mapType));
        }

        let mut useRef = false, mut useAlias = false;
        let kType = if (keyIter.getType () !of EmptyExpression) { // a type was declared in the key
            let vtype = context:.validateTypeForVarDecl (keyIter.getType (), keyIter, canBeRef-> false);
            // must be the same as the one declared in the map (or implicitely compatible)
            context.verifyCompatibleType (keyIter.getType ().getLoc (), mapKeyType.getLoc (), vtype, mapKeyType);
            vtype
        } else {
            context:.validateTypeForVarDecl (copy TypeWrapperExpr (keyIter.getLoc (), mapKeyType), keyIter, canBeRef-> false)
        };

        let vType = if (valIter.getType () !of EmptyExpression) { // A type declared in the value iterator
            let vtype = context:.validateTypeForVarDecl (valIter.getType (), valIter, canBeRef-> true);
            // must be the same as the one declared in the map (or implicitely compatible)
            context.verifyCompatibleType (valIter.getType ().getLoc (), mapValType.getLoc (), vtype, mapValType);
            vtype
        } else {
            context:.validateTypeForVarDecl (copy TypeWrapperExpr (valIter.getLoc (), mapValType), valIter, canBeRef-> true)
        };

        // Value iterator needs to be a ref to be mutable, or to borrow mutable data
        if (vType.isMutable () && !vType.needExplicitAlias () && !valIter.isRef ()) {
            throw copy ErrorMsg::fatal (valIter.getMutOrDmutLocation (), ValidateErrorMessage::MUTABLE_CONST_ITERATOR);
        }

        // Create the access to the value of the map
        let valAcc = copy MapIteratorValueValue (valIter.getLoc (), vType, iterRef);
        let iterVal = context:.verifyCompatibleTypeWithValue (valIter.getLoc (), vType, valAcc, byReference-> valIter.isRef ());
        let access = if (byMutRef && valIter.isRef () && mapValType.isMutable () && mapIsLvalue) {
            useRef = true; // by mutable reference
            copy ReferencerValue (valIter.getLoc (), iterVal.getType (), iterVal, isMutable-> true)
        } else if (!valIter.isRef () && byAlias && mapValType.isMutable () && vType.needExplicitAlias ()) {
            useAlias = true; // by mutable alias
            copy AliaserValue (valIter.getLoc (), iterVal.getType (), iterVal)
        } else if (valIter.isRef () && !byMutRef && mapIsLvalue) { // by const reference
            copy ReferencerValue (valIter.getLoc (), iterVal.getType (), iterVal, isMutable-> false)
        } else {
            iterVal // by value
        };

        // Verify the memory movement permission
        context.verifyMemoryOwner (valIter.getLoc (), vType, access, construct-> true, byReference-> valIter.isRef ());

        // Create the iterator variables
        let keyValue = copy MapIteratorKeyValue (keyIter.getLoc (), kType, iterRef);
        let nameKeyLoc = if (keyIter.getLoc () == Keys::UNDER) {
            copy Word ("#_iter0", keyIter.getLoc ())
        } else {
            keyIter.getLoc ()
        };

        // Always iterate using a reference
        let keyDecl = copy VarDeclValue (nameKeyLoc, kType,
                                         copy ReferencerValue (keyValue.getLoc (), keyValue.getType (), keyValue, isMutable-> false),
                                         isMutable-> false,
                                         isReference-> true,
                                         isCte-> false,
                                         isIterator-> true);

        let nameValLoc = if (valIter.getLoc () == Keys::UNDER) {
            copy Word ("#_iter1", valIter.getLoc ())
        } else {
            valIter.getLoc ()
        };
        let valDecl = copy VarDeclValue (nameValLoc, vType, access,
                                         isMutable-> (valIter.isMutable () || valIter.isDeeplyMutable ()),
                                         isIterator-> true,
                                         isReference-> valIter.isRef (),
                                         isCte-> false);

        (keyDecl, valDecl, useRef, useAlias)
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================        LOOP ON RANGES        =========================
     * ================================================================================
     * ================================================================================
     */


    /**
     * Validate a for loop on a range value
     * @params: 
     *    - context: the context of the validation
     *    - rngType: the type of the range 
     *    - value: the value to iterate
     *    - f: the for loop to validate
     * @returns: the validated loop
     * @throws:
     *    - &ErrorMsg: if the validation fails
     */
    fn validateRangeLoop (self, dmut context : &Validator, rngType : &RangeType, value : &Value, f : &ForLoopExpr)-> &Value
        throws ErrorMsg
    {        
        let vars = f.getVariables ();

        // We can iterate over range with only one variable
        if (vars.len != 1us) throw copy ErrorMsg::fatal (f.getLoc (), format (ValidateErrorMessage::UNDEF_FOR_LOOP_OPERATOR, vars.len, rngType));

        let loc = f.getLoc ();
        let mut values : [&Value] = [];
        let dmut interpret = context:.getCompileTimeInterpreter ();

        let fst  = interpret:.reduce (copy StructFieldAccessValue (loc, rngType.getInners ()[0], value, RangeKeys::FST));
        let scd  = interpret:.reduce (copy StructFieldAccessValue (loc, rngType.getInners ()[0], value, RangeKeys::SCD));
        let step = interpret:.reduce (copy StructFieldAccessValue (loc, rngType.getInners ()[1], value, RangeKeys::STEP));
        let contains = interpret:.reduce (copy StructFieldAccessValue (loc, copy BoolType (loc), value, RangeKeys::CONTAINS));

        let iterDecl = copy VarDeclValue (copy Word ("#_iter", loc), copy IntType (loc, signed-> false, size-> 0u16), makeIntValue (loc, 0us), isMutable-> true);
        let mut iterRef = copy VarRefValue (iterDecl.getLoc (), loc, iterDecl.getVarType (), iterDecl.getUniqId (), isSelf-> false, canCte-> false, isIterator-> true);
        values ~= [iterDecl];

        let nbIterRef = if (!interpret.isCte (fst) || !interpret.isCte (scd) || !interpret.isCte (step) || !interpret.isCte (contains)) {
            let nbIteration = self.validateComputeNbIterations (loc, alias context, fst, scd, step, contains);
            let nbIterDecl = copy VarDeclValue (copy Word ("#_nb_iter", loc), copy IntType (loc, signed-> false, size-> 0u16), nbIteration, isMutable-> true);
            let mut nbIterRef = copy VarRefValue (nbIterDecl.getLoc (), loc, nbIterDecl.getVarType (), nbIterDecl.getUniqId (), isSelf-> false, canCte-> false);

            values ~= [nbIterDecl];
            nbIterRef
        } else {
            context:.getCompileTimeInterpreter ():.reduce (self.validateComputeNbIterations (loc, alias context, fst, scd, step, contains))
        }

        let _loop = self.validateRangeInnerLoop (alias context, rngType, f, iterRef, nbIterRef, fst, step);

        values ~= [_loop]; // push the loop after the declaration of the iterator variable
        copy BlockValue (loc, copy VoidType (loc), values)
    }

    /**
     * Validate the inner part of the range loop
     * @returns: the loop
     * */
    fn validateRangeInnerLoop (self, dmut context : &Validator, rngType : &RangeType, f : &ForLoopExpr, iterRef : &Value, nbIterRef : &Value, fst : &Value, step : &Value)-> &Value
        throws ErrorMsg
    {
        let loc = f.getLoc ();
        let mut errors : [&ErrorMsg] = [];
        let mut values : [&Value] = [];

        context:.enterLoop ();
        context:.setCurrentLoopType (copy VoidType (f.getLoc ()));

        context:.enterBlock ();
        let test = {
            let (varRef, varDecl) = self.validateRangeIteratorVar (alias context, loc, rngType, f.getVariables ()[0]);
            let (increment, setIndex, _test) = self.validateRangeIteratorIncrement (alias context, loc, iterRef, nbIterRef, varRef, fst, step);
            if (varRef.getLoc () != Keys::UNDER) {
                values ~= [varDecl]; // push the var decl before the loop
                values ~= [setIndex];
            }

            values ~= [context:.validateValue (f.getBlock ())]; // the loop content
            values ~= [increment]; // the loop increment
            _test
        } catch {
            err : &ErrorMsg => {
                errors ~= [err];
                UNIT_VALUE
            }
        }

        {
            context:.quitLoop ();
            context:.quitBlock (warnUnused-> errors.len == 0us);
        } catch {
            err : &ErrorMsg => { errors ~= [err]; } // Some warn unused
        }

        if (errors.len != 0us) throw copy ErrorMsg::list (errors);
        let blkContent = copy BlockValue (loc, copy VoidType (loc), values);

        copy LoopValue (loc, copy VoidType (loc), test-> test, blkContent, isDo-> false)
    }


    /**
     * Validate the iterator variable
     * @params: 
     *    - context: the context of the validation
     *    - rngType: the type of the range value
     *    - iterDecl: the declaration of the iterator
     *    - rngValue: the value of the range
     * @returns:
     *    - .0: true iif cannot use only compile time values
     *    - .1: the variable declaration
     *    - .2: the variable ref value
     * @throws:
     *    - &ErrorMsg: if the validation fails
     */
    fn validateRangeIteratorVar (self, dmut context : &Validator, loc : &Word, rngType : &RangeType, iterDecl : &Expression)-> (&Value, &Value)
        throws ErrorMsg
    {
        match iterDecl {
            v : &VarDeclExpr => {
                // We create the variable for the iterator
                let iterType = rngType.getInners ()[0].clone (0u32);
                let iterValue = self.validateIndexIterDecl (alias context, loc, v, iterType, rngType, canCte-> false);
                context:.insertLocal (v.getLoc (), v.getName ().str, iterValue);

                // And the variable ref so we can use it
                let vRefIter = copy VarRefValue (v.getLoc (), iterValue.getLoc (), iterType, iterValue.getUniqId (), isSelf-> false, canCte-> false, isIterator-> true);
                return (vRefIter, iterValue);
            }
            _ => panic;
        }
    }

    /**
     * * Validate the increment of the iterator during an iteration on a range value of integers
     * @params:
     *    - context: the context of the validation
     *    - iterRef: the validation containing the iterator
     *    - nbIter: the number of iteration
     *    - indexRef: the number of iteration
     * @returns:
     *    - .0: the increment value
     *    - .1: the affectation of index
     *    - .2: the test for the loop
     * */
    fn validateRangeIteratorIncrement (self, dmut context : &Validator, loc : &Word, iterRef : &Value, nbIter : &Value, indexRef : &Value, fst : &Value, step : &Value)-> (&Value, &Value, &Value)
        throws ErrorMsg
    {
        let dmut interpret = context:.getCompileTimeInterpreter ();
        let test = copy CmpIntOperatorValue (loc, BinaryOperators::INF, iterRef, nbIter);
        let increment = copy AffectValue (loc, iterRef.getType (), iterRef, copy BinaryMathIntOperatorValue (loc, iterRef.getType (), BinaryOperators::PLUS, iterRef, makeIntValue (loc, 1us)));
        let (stepInf0, stepInt) = {
            let i = interpret:.computeInt (step);
            if (i < 0) {
                (true, i)
            } else {
                (false, copy BigInt (0))
            }
        } catch {
            _ => { (false, copy BigInt (0)) } // not cte
        };

        let affectIndex = if (!stepInf0) {
            let indexMul = copy BinaryMathIntOperatorValue (loc, iterRef.getType (), BinaryOperators::STAR, iterRef, copy CastValue (loc, iterRef.getType (), step));
            let currIndex = copy BinaryMathIntOperatorValue (loc, indexRef.getType (), // i = fst + #_iter * step
                                                             BinaryOperators::PLUS, fst,
                                                             copy CastValue (loc, indexRef.getType (), indexMul));
            copy AffectValue (loc, indexRef.getType (), indexRef, context:.getCompileTimeInterpreter ():.reduce (currIndex))
        } else {
            let indexMul = copy BinaryMathIntOperatorValue (loc, iterRef.getType (), BinaryOperators::STAR, iterRef, copy IntValue (loc, iterRef.getType ().asOf!{&IntType} (), 0us - stepInt));
            let currIndex = copy BinaryMathIntOperatorValue (loc, indexRef.getType (), // i = fst - (#_iter * -step)
                                                             BinaryOperators::MINUS, fst,
                                                             copy CastValue (loc, indexRef.getType (), indexMul));

            copy AffectValue (loc, indexRef.getType (), indexRef, context:.getCompileTimeInterpreter ():.reduce (currIndex))
        }

        (increment, affectIndex, test)
    }

    /**
     * Compute the number of iterations of a for loop
     * */
    pub fn validateComputeNbIterations (self, loc : &Word, dmut context : &Validator, fst : &Value, scd : &Value, step : &Value, contains : &Value)-> &Value
        throws ErrorMsg
    {
        let sizeType = copy IntType (loc, size-> 0u16, signed-> false);
        let max = context:.getCompileTimeInterpreter ().createIntMaxValue (sizeType);

        match (fst, scd, step, contains) {
            (fstI : &IntValue, scdI : &IntValue, stepI : &IntValue, containsB : &BoolValue) =>
            {
                return copy IntValue (loc, sizeType, self.validateCteComputeNbIterations (fstI.getValue (), scdI.getValue (), stepI.getValue (), max, containsB.isTrue ()));
            }
            _ => {
                let val = if (step of IntValue && contains of BoolValue) {
                    // Almost cte, we can infer some things as step and contains are known
                    self.validateAlmostCteComputeNbIterations (loc, fst, scd, step.asOf!{&IntValue} ().getValue (), max, contains.asOf!{&BoolValue} ().isTrue ())
                } else {
                    self.validateNonCteComputeNbIterations (loc, fst, scd, step, max, contains)
                };

                return context:.getCompileTimeInterpreter ():.reduce (val);
            }
        }
    }

    /**
     * Cte version of fun to compute the number of iterations of a range
     * @params:
     *     - fst: the cte fst value of the range
     *     - scd: the cte scd value of the range
     *     - step: the cte step value of the range
     *     - max: the maximal int value reprensentable in the target language
     *     - contains: the cte contains value of the range
     * @returns: the number of iterations of the range
     * */
    fn validateCteComputeNbIterations (self, fst : &BigInt, scd : &BigInt, step : &BigInt, max : &BigInt, contains : bool)-> &BigInt {
        let stepU = if (step < 0) { 0 - step } else { step };
        if (stepU == 0) return copy BigInt (0);

        let (fstU, scdU, subU) = if (fst > scd) {
            (scd, fst, fst - scd)
        } else {
            (fst, scd, scd - fst)
        };

        let nbAll = subU / stepU;

        if (nbAll == max) return nbAll;
        if (contains) return nbAll + 1us;

        // recompute, because is it not necessarily == scd since the division might trunc the value
        let last = (nbAll * stepU) + fstU;
        if (last != scdU) return nbAll + 1us;

        nbAll
    } catch {
        _ => panic; // stepU == 0
    }

    /**
     * Almost cte version of the function used to compute the number of iteration in a range
     * Almost because fst and scd are not cte, but step and contains are (it can happen a lot actually, ex: for i in 0 .. a.len, with a : [T])
     * @params:
     *     - fst: the fst value of the range
     *     - scd: the scd value of the range
     *     - step: the cte step value of the range
     *     - max: the maximal int value reprensentable in the target language
     *     - contains: the cte contains value of the range
     * @returns: an expression used to compute the number of iteration in the range
     * */
    fn validateAlmostCteComputeNbIterations (self, loc : &Word, fst : &Value, scd : &Value, step : &BigInt, max : &BigInt, contains : bool)-> &Value {
        let stepU = if (step < 0) { 0 - step } else { step };
        if (stepU == 0) return makeIntValue (0us);

        let rngType = fst.getType ().asOf!{&IntType} ();
        let (fstU, scdU, mut subU) = if (step < 0) {
            (scd, fst, copy BinaryMathIntOperatorValue (loc, rngType, BinaryOperators::MINUS, fst, scd))
        } else {
            (fst, scd, copy BinaryMathIntOperatorValue (loc, rngType, BinaryOperators::MINUS, scd, fst))
        };

        let stepI = copy IntValue (loc, rngType, stepU);
        let maxI = copy IntValue (loc, rngType, max);
        let nbAll = copy BinaryMathIntOperatorValue (loc, rngType, BinaryOperators::DIV, subU, stepI);
        let nbAllP1 = copy BinaryMathIntOperatorValue (loc, rngType, BinaryOperators::PLUS, nbAll, copy IntValue (loc, rngType, 1us));

        if (contains) {
            let cmp = copy CmpIntOperatorValue (loc, BinaryOperators::DEQUAL, nbAll, maxI);
            return copy ConditionalValue (loc, rngType, cmp, nbAll, nbAllP1); // if contains { return if (nbAll == max) { nbAll } else { nbAll + 1 } }
        }

        let mulNbAll = copy BinaryMathIntOperatorValue (loc, rngType, BinaryOperators::STAR, nbAll, stepI);
        let last = copy BinaryMathIntOperatorValue (loc, rngType, BinaryOperators::PLUS, mulNbAll, fstU);

        let cmp = copy CmpIntOperatorValue (loc, BinaryOperators::NOT_EQUAL, last, scdU);
        return copy ConditionalValue (loc, rngType, cmp, nbAllP1, nbAll); // return if (last == scdU) { nbAll } else { nbAll + 1 };
    }


    /**
     * Completely non cte version of the function used to compute the number of iteration in a range
     * * @params:
     *     - fst: the fst value of the range
     *     - scd: the scd value of the range
     *     - step: the step value of the range
     *     - max: the maximal int value reprensentable in the target language
     *     - contains: the contains value of the range
     * @returns: an expression used to compute the number of iteration in the range
     * */
    fn validateNonCteComputeNbIterations (self, loc : &Word, fstV : &Value, scdV : &Value, stepV : &Value, max : &BigInt, contains : &Value)-> &Value {
        let mut lst : [&Value] = [];

        let rngTuType = {
            copy TupleType (loc, copy [fstV.getType (), scdV.getType (), stepV.getType ()])
        } catch {
            _ => panic;
        };

        let vdecl = copy VarDeclValue (copy Word ("#_range", loc), rngTuType, copy TupleValue (loc, rngTuType, copy [fstV, scdV, stepV]), isMutable-> false);
        let vref = copy VarRefValue (vdecl.getLoc (), loc, rngTuType, vdecl.getUniqId (), isSelf-> false, canCte-> true);

        lst ~= [vdecl];

        let fst = copy TupleFieldAccessValue (loc, rngTuType.getInners ()[0], vref, 0us);
        let scd = copy TupleFieldAccessValue (loc, rngTuType.getInners ()[1], vref, 1us);
        let step = copy TupleFieldAccessValue (loc, rngTuType.getInners ()[2], vref, 2us);

        let rngType = fst.getType ().asOf!{&IntType} ();
        let stepCmp = copy CmpIntOperatorValue (loc, BinaryOperators::INF, step, copy IntValue (loc, step.getType ().asOf!{&IntType} (), 0us));

        let tuType = {
            copy TupleType (loc, copy [rngType, rngType, rngType, rngType])
        } catch {
            _ => panic;
        };

        let valNeg = copy TupleValue (loc, tuType, copy [copy UnaryIntOperatorValue (loc, step.getType ().asOf!{&IntType} (), UnaryOperators::MINUS, step), scd, fst, copy BinaryMathIntOperatorValue (loc, rngType, BinaryOperators::MINUS, fst, scd)]);
        let valPos = copy TupleValue (loc, tuType, copy [step, fst, scd, copy BinaryMathIntOperatorValue (loc, rngType, BinaryOperators::MINUS, scd, fst)]);

        let valDecl = copy VarDeclValue (copy Word ("#_val", loc), tuType, copy ConditionalValue (loc, tuType, stepCmp, valNeg, valPos), isMutable-> false);
        let val = copy VarRefValue (valDecl.getLoc (), loc, tuType, valDecl.getUniqId (), isSelf-> false, canCte-> true);
        lst ~= [valDecl];

        let maxI = copy IntValue (loc, rngType, max);
        let stepU = copy TupleFieldAccessValue (loc, rngType, val, 0us);
        let fstU = copy TupleFieldAccessValue (loc, rngType, val, 1us);
        let scdU = copy TupleFieldAccessValue (loc, rngType, val, 2us);
        let subU = copy TupleFieldAccessValue (loc, rngType, val, 3us);

        let nbAllDecl = copy VarDeclValue (copy Word ("#_nbAll", loc), rngType, copy BinaryMathIntOperatorValue (loc, rngType, BinaryOperators::DIV, subU, stepU), isMutable-> false);
        let nbAll = copy VarRefValue (nbAllDecl.getLoc (), loc, rngType, nbAllDecl.getUniqId (), isSelf-> false, canCte-> true);
        lst ~= [nbAllDecl];

        let valIfNoMax = {
            let mulNbAll = copy BinaryMathIntOperatorValue (loc, rngType, BinaryOperators::STAR, nbAll, stepU);
            let last = copy BinaryMathIntOperatorValue (loc, rngType, BinaryOperators::PLUS, mulNbAll, fstU);

            let nbAllP1 = copy BinaryMathIntOperatorValue (loc, rngType, BinaryOperators::PLUS, nbAll, copy IntValue (loc, rngType, 1us));
            let cmp = copy LogicalBinBoolOperatorValue (loc, BinaryOperators::DPIPE, copy CmpIntOperatorValue (loc, BinaryOperators::NOT_EQUAL, last, scdU), contains);
            copy ConditionalValue (loc, rngType, cmp, nbAllP1, nbAll)
        };

        // if (nbAll == max) { nbAll } else { let last = (nbAll * stepU) + fstU; if (last != scdU || contains) { nbAll + 1 } else { nbAll } };
        let cmp = copy CmpIntOperatorValue (loc, BinaryOperators::DEQUAL, nbAll, maxI);
        let cnd = copy ConditionalValue (loc, rngType, cmp, nbAll, valIfNoMax);
        lst ~= [cnd];

        return copy BlockValue (loc, rngType, lst);
    }

    /*!
     * ================================================================================
     * ================================================================================
     * ===========================    LOOP ON CLASS            ========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a loop operator overloading on a class type
     * @params:
     *    - context: the context of the validation
     *    - cptr: the class pointer being iterated
     *    - value: the value instance of the class
     *    - f: the for loop to validate
     *    - byAlias: true iif the class value is aliased
     * */
    fn validateClassLoop (self, dmut context : &Validator, cptr : &ClassPtrType, value : &Value, f : &ForLoopExpr, byAlias : bool, aliasLoc : &Word)-> &Value
        throws ErrorMsg
    {
        let loc = f.getLoc ();
        let (useAlias, beginMeth, endMeth) = {
            let inst = if (byAlias) { copy ClassAliaserValue (loc, cptr, value) } else { value };
            let (beginMeth, useAliasBeg) = self.createIterOverCptrCall (alias context, loc, cptr, inst, OpOverrideNames::BEGIN);
            let (endMeth, useAliasEnd) = self.createIterOverCptrCall (alias context, loc, cptr, inst, OpOverrideNames::END);
            (useAliasEnd || useAliasBeg, beginMeth, endMeth)
        } catch {
            err : &ErrorMsg => throw copy ErrorMsg::fatal (loc, format (ValidateErrorMessage::FOR_LOOP_CPTR, cptr), notes-> copy [err]);
        };

        let mut outerLoop : [&Value] = [];
        let mut innerLoop : [&Value] = [];
        let mut errors : [&ErrorMsg] = [];

        context:.enterLoop ();
        context:.setCurrentLoopType (copy VoidType (f.getLoc ()));

        context:.enterBlock ();
        let _loop = {
            let (test, increment) = self.validateClassLoopIteratorVar (alias context, loc, cptr, beginMeth, endMeth, f.getVariables (), ref innerLoop, ref outerLoop);
            innerLoop ~= [context:.validateValue (f.getBlock ())];
            innerLoop ~= [increment];

            let blkContent = copy BlockValue (loc, copy VoidType (loc), innerLoop);
            let _loop = copy LoopValue (loc, copy VoidType (loc), test-> test, blkContent, isDo-> false);
            _loop
        } catch {
            err : &ErrorMsg => {
                errors ~= [err];
                UNIT_VALUE
            }
        };

        {
            context:.quitLoop ();
            context:.quitBlock (warnUnused-> errors.len == 0us);
        } catch {
            err : &ErrorMsg => { errors ~= [err]; }
        }

        if (errors.len != 0us) throw copy ErrorMsg::fatal (f.getLoc (), format (ValidateErrorMessage::FOR_LOOP_CPTR, cptr), notes-> errors);
        self.verifyUseAliasCptrIter (loc, aliasLoc, cptr, beginMeth, endMeth, useAlias, byAlias);

        outerLoop ~= [_loop];
        copy BlockValue (loc, copy VoidType (loc), outerLoop)
    }

    /**
     * Validate the iterator vars of a class loop
     * @params:
     *    - context: the context of the validation
     *    - loc : the location of the loop
     *    - cptr: the class type
     *    - beginMeth: the call to the begin meth
     *    - endMeth: the call to the end method
     *    - len: the len field (can be unit if it does not apply)
     *    - vars: the list of vars declared by the loop
     * @returns:
     *    - innerLoop: add the declaration of the iterators
     *    - outerLoop: add the declaration of the begin, end values
     *    - .0: the test that stop the loop
     *    - .1: the instruction used to increment the iterator to put after the content of the loop
     * @throws:
     *    - &ErrorMsg: if the loop is not valid
     * */
    fn validateClassLoopIteratorVar (self, dmut context : &Validator, loc : &Word, cptr : &ClassPtrType, beginMeth : &Value, endMeth : &Value, vars : [&Expression], ref mut innerLoop : [&Value], ref mut outerLoop : [&Value])-> (&Value, &Value)
        throws ErrorMsg
    {
        let iteratorDecl = copy VarDeclValue (copy Word ("#_iter", beginMeth.getLoc ()), beginMeth.getType ().toDeeplyMutable (), beginMeth, isMutable-> true, isIterator-> true);
        let endDecl = copy VarDeclValue (copy Word ("#_end", endMeth.getLoc ()), endMeth.getType ().clone (0u32), endMeth, isMutable-> false, isIterator-> false);
        let iteratorType = iteratorDecl.getVarType ();
        self.verifyCptrBeginIsValid (alias context, loc, cptr, iteratorDecl, beginMeth);

        let iteratorRef = copy VarRefValue (iteratorDecl.getLoc (), iteratorDecl.getLoc (), iteratorType, iteratorDecl.getUniqId (), isSelf-> false, canCte-> false);
        let endRef = copy VarRefValue (endDecl.getLoc (), endDecl.getLoc (), endDecl.getVarType (), endDecl.getUniqId (), isSelf-> false, canCte-> false);
        let aliasRef = copy ClassAliaserValue (iteratorDecl.getLoc (), iteratorType.asOf!{&ClassPtrType} (), iteratorRef);

        let mut test = context:.getBinOpValidator ().validateComparisonOperation (alias context, loc, BinaryOperators::NOT_EQUAL, iteratorRef, endRef);
        let mut increment = self.validateCptrIncrement (alias context, loc, iteratorType, aliasRef);

        outerLoop ~= [iteratorDecl];
        outerLoop ~= [endDecl];

        let nbVars = vars.len;
        for index, it in vars match it {
            v : &VarDeclExpr => {
                let iter = self.validateCptrIterDecl (alias context, loc, v, iteratorType, aliasRef, index, nbVars);
                context:.insertLocal (v.getLoc (), v.getName ().str, iter);

                innerLoop ~= [iter];
            }
            _ => panic;
        }

        (test, increment)
    }

    /**
     * Validate a the call the op overloading function
     * @params:
     *   - context: the context of the validation
     *   - cptr: the type of the class begin iterated
     *   - value: the instance being iterated
     *   - name: the name of the meth to call
     *   - mustBeMutable: true iif the return type of the call has to be mutable
     * */
    fn createIterOverCptrCall (self, dmut context : &Validator, loc : &Word, cptr : &ClassPtrType, value : &Value, name : [c8])-> (&Value, bool)
        throws ErrorMsg
    {
        let meth = context:.constructObjectMethodAcc (loc, cptr, value, name, allowImmut-> true);
        let cl = context:.getCallOpValidator ().validate (alias context, loc, meth, []);

        let useAlias = match cl {
            c : &MethodCallValue => {
                c.getMethod ().getPrototype ().isMutable ()
            }
            _ => { false }
        };

        (cl, useAlias)
    }

    /**
     * Validate the declaration of an iterator variable within a for loop overloading on a class type
     * @params:
     *    - context: the context of the validation
     *    - loc: the location of the loop
     *    - v: the iterator variable to declare
     *    - iteratorType: the type of the iterator (from begin call on the class)
     *    - iterRef: the variable of type iteratorType (containing the current class iterator)
     *    - index: the index of the variable decl
     * */
    fn validateCptrIterDecl (self, dmut context : &Validator, loc : &Word, vdecl : &VarDeclExpr, iteratorType : &Type, iterRef : &Value, index : usize, nbVars : usize)-> &Value
        throws ErrorMsg
    {
        // let x = iter.get!{0, N} ();
        let getVal = self.validateCptrIterCallGet (alias context, vdecl.getLoc (), iteratorType, iterRef, index, nbVars);
        let (protoLoc, protoMsg) = match getVal {
            c : &MethodCallValue => { (c.getMethod ().getPrototype ().getLoc (),
                                       format ("%", c.getMethod ().getPrototype (), tags-> FormatTags (withParams-> true)))
            }
            _ => { (loc, format ("%", getVal)) }
        };

        {
            return self.validateCptrIterValidateVDecl (alias context, vdecl, getVal);
        } catch {
            err : &ErrorMsg => {
                let note = copy ErrorMsg::note (loc, format (ValidateErrorMessage::CALL_GET_OP_ONE_LINE, vdecl.getLoc ().str, iterRef, index, nbVars), oneLine-> true);
                let protoNote = copy ErrorMsg::note (protoLoc, format (ValidateErrorMessage::CALL_PROTO, protoMsg));
                throw copy ErrorMsg::fatal (vdecl.getLoc (), format (ValidateErrorMessage::USE_GET_OP_ITERATOR, protoMsg, iteratorType),
                                            notes-> copy [note, err.withNote (copy [protoNote])]);
            }
        }
    }


    /**
     * Validate the declaration of the iterator decl from a call to the get method (or function) of an iterator
     * @params:
     *    - context: the context of the validation
     *    - loc: the location of the call
     *    - vdecl: the variable to declare
     *    - val: the value (call of iter.get)
     * @returns: the validated declaration of the variable
     * */
    fn validateCptrIterValidateVDecl (self, dmut context : &Validator, vdecl : &VarDeclExpr, val : &Value)-> &Value
        throws ErrorMsg
    {
        let vType = if (vdecl.getType () !of EmptyExpression) {
            let vtype = context:.validateTypeForVarDecl (vdecl.getType (), vdecl, canBeRef-> false);
            context.verifyCompatibleType (vdecl.getLoc (), val.getLoc (), vtype, val.getType ());
            vtype
        } else {
            context:.validateTypeForVarDecl (copy TypeWrapperExpr (vdecl.getLoc (), val.getType ()), vdecl, canBeRef-> false)
        };

        if (vType.isMutable () && !vType.needExplicitAlias () && !vType.isMovable ()) { // iterator cannot be a reference in that case
            throw copy ErrorMsg::fatal (vdecl.getMutOrDmutLocation (), ValidateErrorMessage::MUTABLE_CONST_ITERATOR);
        }

        let retTypeLoc = match val {
            c : &MethodCallValue => { c.getMethod ().getPrototype ().getRetType ().getLoc () }
            _ => { val.getLoc () }
        };

        context.verifyMemoryOwner (retTypeLoc, vType, val, construct-> true, byReference-> false);
        let nameLoc = if (vdecl.getLoc () == Keys::UNDER) {
            copy Word ("#_iter", vdecl.getLoc ())
        } else {
            vdecl.getLoc ()
        };

        let decl = copy VarDeclValue (nameLoc, vType, val, isMutable-> (vdecl.isMutable () || vdecl.isDeeplyMutable ()), isReference-> false, isIterator-> true);
        decl
    }

    /**
     * Validate the call to the method "get" of the iterator value
     * @warning: assumes that the iterator type is a class or a struct
     * @params:
     *    - context: the context of the validation
     *    - loc: the location of variable to declare
     *    - iteratorType: the type of the iterator
     *    - iterRef: the reference (class aliaser) of the iterator
     *    - index: the index of the variable to create
     *    - nbVars: the number of variables iterating the class
     * */
    fn validateCptrIterCallGet (self, dmut context : &Validator, loc : &Word, iteratorType : &Type, iterRef : &Value, index : usize, nbVars : usize)-> &Value
        throws ErrorMsg
    {
        {
            match iteratorType {
                cptr : &ClassPtrType => {
                    let meth = context:.constructObjectMethodAcc (loc, cptr, iterRef, OpOverrideNames::GET_ITER, allowImmut-> true);
                    let templ = context:.getValueValidator ():.validateTemplateCall (alias context, loc, meth, copy [makeIntValue (loc, index), makeIntValue (loc, nbVars)]);
                    return context:.getCallOpValidator ().validate (alias context, loc, templ, []);
                }
                _ => {
                    panic;
                }
            }
        } catch {
            err : &ErrorMsg => {
                let note = copy ErrorMsg::note (loc, format (ValidateErrorMessage::CALL_GET_OP_ONE_LINE, loc.str, iterRef, index, nbVars), oneLine-> true);
                throw copy ErrorMsg::fatal (loc, format (ValidateErrorMessage::CALL_GET_OP_ITERATOR, iteratorType, index, nbVars),
                                            notes-> copy [note, err]);
            }
        }
    }

    /**
     * Validate the increment on a iterator for a class ptr iteration, i.e., call to the "next" method
     * @warning: assumes that the iterator type is a class or a struct
     * @params:
     *    - context: the context of the validation
     *    - loc: the location of the for loop
     *    - iteratorType : the type of the iterator
     *    - iterRef: the reference to the iterator value (in a class aliaser)
     * * */
    fn validateCptrIncrement (self, dmut context : &Validator, loc : &Word, iteratorType : &Type, iterRef : &Value)-> &Value
        throws ErrorMsg
    {
        {
            match iteratorType {
                cptr : &ClassPtrType => {
                    let meth = context:.constructObjectMethodAcc (loc, cptr, iterRef, OpOverrideNames::NEXT);
                    return context:.getCallOpValidator ().validate (alias context, loc, meth, []);
                }
                _ => {
                    panic;
                }
            }
        } catch {
            err : &ErrorMsg => {
                let note = copy ErrorMsg::note (loc, format (ValidateErrorMessage::CALL_NEXT_OP_ONE_LINE, iterRef, iterRef), oneLine-> true);
                throw copy ErrorMsg::fatal (loc, format (ValidateErrorMessage::CALL_NEXT_OP_ITERATOR, iteratorType), notes-> copy [note, err]);
            }
        }
    }

    /**
     * Verify that the begin method returns a valid iterator, and that the iterator is deeply mutable
     * @params:
     *    - context: the context of the validation
     *    - loc : the location of the for loop
     *    - cptr: the type being iterated
     *    - iteratorDecl: the declaration of the iterator variable
     *    - beginMeth: the call to the begin method
     * */
    fn verifyCptrBeginIsValid (self, dmut context : &Validator, loc : &Word, cptr : &ClassPtrType, iteratorDecl : &VarDeclValue, beginMeth : &Value)
        throws ErrorMsg
    {
        let (protoLocBeg, retTypeProtoLoc, protoMsg) = match beginMeth {
            c : &MethodCallValue => { (c.getMethod ().getPrototype ().getLoc (),
                                       c.getMethod ().getPrototype ().getRetType ().getLoc (),
                                       format ("%", c.getMethod ().getPrototype (), tags-> FormatTags (withParams-> true)))
            }
            _ => { (loc, loc, format ("%", beginMeth)) }
        };

        {
            let iteratorTrait = context:.validateIteratorTrait (loc);
            context.verifyImplement (retTypeProtoLoc, beginMeth.getType (), iteratorTrait);
            context.verifyMemoryOwner (retTypeProtoLoc, iteratorDecl.getVarType (), beginMeth, byReference-> false, construct-> true, byLazy-> false);
        } catch {
            err : &ErrorMsg => {
                let noteBeg = copy ErrorMsg::note (protoLocBeg, format (ValidateErrorMessage::CALL_PROTO, protoMsg), notes-> copy [err]);
                let rewriteNote = copy ErrorMsg::note (loc, format (ValidateErrorMessage::CALL_BEGIN_ONE_LINE, cptr), oneLine-> true);
                throw copy ErrorMsg::list (copy [rewriteNote, noteBeg]);
            }
        }
    }


    /**
     * Verify that alias was not uselessly used on an iteration over a class pointer object
     * @params:
     *    - loc: the location of the for loop
     *    - cptr: the class pointer being iterated
     *    - beginMeth: the call to the begin method
     *    - endMeth: the call to the end method
     *    - useAlias: true if alias was used for at least one of the calls
     *    - byAlias: true if the value is passed by alias
     * @throws:
     *    - &ErrorMsg: the error message if the alias was used but is useless
     * */
    fn verifyUseAliasCptrIter (self, loc : &Word, valLoc : &Word, cptr : &ClassPtrType, beginMeth : &Value, endMeth : &Value, useAlias : bool, byAlias : bool)
        throws ErrorMsg
    {
        if (!useAlias && byAlias) {
            let (protoLocBeg, _) = match beginMeth {
                c : &MethodCallValue => { (c.getMethod ().getPrototype ().getLoc (),
                                           format ("%", c.getMethod ().getPrototype (), tags-> FormatTags (withParams-> true)))
                }
                _ => { (loc, format ("%", beginMeth)) }
            };

            let (protoLocEnd, _) = match endMeth {
                c : &MethodCallValue => { (c.getMethod ().getPrototype ().getLoc (),
                                           format ("%", c.getMethod ().getPrototype (), tags-> FormatTags (withParams-> true)))
                }
                _ => { (loc, format ("%", endMeth)) }
            };

            let noteBeg = copy ErrorMsg::note (protoLocBeg, format (ValidateErrorMessage::CALL_PROTO, beginMeth), oneLine-> true, withLoc-> true);
            let noteEnd = copy ErrorMsg::note (protoLocEnd, format (ValidateErrorMessage::CALL_PROTO, endMeth), oneLine-> true, withLoc-> true);

            let unecessaryErr = copy ErrorMsg::fatal (valLoc, format (ValidateErrorMessage::UNECESSARY_ALIAS_CPTR_LOOP, cptr), notes-> copy [noteBeg, noteEnd]);
            throw copy ErrorMsg::fatal (loc, format (ValidateErrorMessage::FOR_LOOP_CPTR, cptr), notes-> copy [unecessaryErr]);
        }
    }


    /*!
     * ================================================================================
     * ================================================================================
     * ========================        COMPREHENSION SLICE        =====================
     * ================================================================================
     * ================================================================================
     */

    /**
     * validate a list comprehension from an array value
     * @params:
     *   - context: the context of the validation
     *   - arrType: the type of array being iterated
     *   - value: the value of the array being iterated
     *   - all: the slice for creating the list comprehension
     *   - canDynamic: if true, then the slice allocator is surrounded by a /copy/ operator, and therefore can be dynamically allocated
     * @returns: the generated slice/array/tuple
     * @throws:
     *    - &ErrorMsg: of the validated failed
     * */
    fn validateComprArray (self, dmut context : &Validator, arrType : &ArrayType, value : &Value, all : &SliceForAllocatorExpr, canDynamic : bool)-> &Value
        throws ErrorMsg
    {
        let vars = all.getVariables ();
        let uniqV = context.createSliceAliasFromArray (all.getLoc (), arrType, value, mutable-> false); // create a slice from the address of the array
        let slcT = uniqV.getType ().asOf!{&SliceType} ();

        match vars.len {
            1us => // value iterator, _ in A
                return self.validateComprSliceIteration (alias context, slcT, uniqV, vars [0], EMPTY_EXPR, all, canDynamic);
            2us => // index iterator, value iterator in A
                return self.validateComprSliceIteration (alias context, slcT, uniqV, vars [0], vars [1], all, canDynamic);
            _ => { // not allowed
                throw copy ErrorMsg::fatal (all.getForLoc (), format (ValidateErrorMessage::UNDEF_FOR_LOOP_OPERATOR, all.getVariables ().len, value.getType ()));
            }
        }
    }

    /**
     * Validate a list comprehension from a slice value
     * @params:
     *   - context: the context of the validation
     *   - slc: the slice type being iterated
     *   - iter: the value being iterated
     *   - all: the list comprehension to validate
     *   - canDynamic: if true, then the slice allocator is surrounded by a /copy/ operator, and therefore can be dynamically allocated
     * @returns: the generated slice/array/tuple
     * @throws:
     *   - &ErrorMsg: if the validation failed
     * */
    fn validateComprSlice (self, dmut context : &Validator, slcType : &SliceType, value : &Value, all : &SliceForAllocatorExpr, canDynamic : bool)-> &Value
        throws ErrorMsg
    {
        let vars = all.getVariables ();
        match vars.len {
            1us => // value iterator, _ in A
                return self.validateComprSliceIteration (alias context, slcType, value, vars [0], EMPTY_EXPR, all, canDynamic);
            2us => // index iterator, value iterator in A
                return self.validateComprSliceIteration (alias context, slcType, value, vars [0], vars [1], all, canDynamic);
            _ => { // not allowed
                throw copy ErrorMsg::fatal (all.getForLoc (), format (ValidateErrorMessage::UNDEF_FOR_LOOP_OPERATOR, all.getVariables ().len, value.getType ()));
            }
        }
    }

    /**
     * Validate a list comprehension from a slice value
     * @params:
     *   - context: the context of the validation
     *   - slcType: the type of the slice
     *   - value: the value of the slice
     *   - iter1: the index or value iterator (if iter2 is EmptyExpression)
     *   - iter2: the value iterator (or EmptyExpression)
     *   - all: the slice allocator to validate
     *   - canDynamic: if true, then the slice allocator is surrounded by a /copy/ operator, and therefore can be dynamically allocated
     * @returns: the generated slice/array/tuple
     * @throws:
     *   - &ErrorMsg: if the validation failed
     * */
    fn validateComprSliceIteration (self, dmut context : &Validator, slcType : &SliceType, value : &Value, iter1 : &Expression, iter2 : &Expression, all : &SliceForAllocatorExpr, canDynamic : bool)-> &Value
        throws ErrorMsg
    {
        let mut values : [&Value] = [];
        let mut errors : [&ErrorMsg] = [];
        let loc = all.getLoc ();

        context:.enterBlock ();

        // put the slice into a value, to avoid validating it multiple times (not necessary since YIL, but more clear)
        let sliceDecl = copy VarDeclValue (copy Word ("#_value", value.getLoc ()), slcType, value, isMutable-> false && slcType.isMutable ());
        let sliceRef = copy VarRefValue (sliceDecl.getLoc (), sliceDecl.getLoc (), slcType, sliceDecl.getUniqId (), isSelf-> false, canCte-> false);
        let one = makeIntValue (loc, 1us);

        // Compute the len from the initial value, because the generator #_value may lose the cte len (e.g. a [0 .. 2], [1, 2, 3], ...)
        let len = {
            // Compute the len from the initial value, because the generator #_value may lose the cte len (e.g. a [0 .. 2], [1, 2, 3], ...)
            let bi = context:.getCompileTimeInterpreter ():.computeInt (copy StructFieldAccessValue (loc, one.getType (), value, SliceKeys::LEN));
            copy IntValue (loc, one.getType ().asOf!{&IntType} (), bi)
        } catch {
            _ => { // it is not cte, so we can use the value from the uniq value instead, to avoid recreating the slice at each iteration
                context:.getCompileTimeInterpreter ():.reduce (copy StructFieldAccessValue (loc, one.getType (), sliceRef, SliceKeys::LEN))
            }
        };

        values ~= [sliceDecl]; // insert the slice above the loop

        let retValue = if (all.isTuple ()) { // tuple iteration is unfolded, so need to be cte
            let lp = self.validateComprSliceInnerLoopTuple (alias context, slcType, sliceRef, all, iter1, iter2, len);
            values ~= [lp];

            copy BlockValue (loc, lp.getType (), values) // return the tuple value
        } else { // array/slice creation are loops
            if (!canDynamic) {
                let size = context:.getCompileTimeInterpreter ():.computeInt (len);
                size.to!u64 ();
            } catch {
                _ : &ErrorMsg => throw copy ErrorMsg::fatal (all.getIter ().getLoc (), format (ValidateErrorMessage::LIST_COMPR_SIZE_CTE, slcType),
                                                             notes-> copy [copy ErrorMsg::note (loc, format (ValidateErrorMessage::ENCLOSE_COPY_LST_COMPR))]);
                _ : &BigIntError => throw copy ErrorMsg::fatal (loc, format (ValidateErrorMessage::OVERFLOW_CAPACITY, copy IntType (loc, size-> 0u16, signed-> false), len, u64::max));
            }

            let (lp, slcValueRef, slcValueDecl, sliceType, withoutLoop) = self.validateComprSliceInnerLoop (alias context, slcType, sliceRef, all, iter1, iter2, len, canDynamic);
            if (withoutLoop) {
                copy BlockValue (loc, lp.getType (), copy [lp])
            } else {

                values ~= [slcValueDecl]; // declare the result value
                values ~= [lp]; // fill the value
                values ~= [slcValueRef]; // return it

                let innerBlock = copy ListComprValue (loc, sliceType, copy BlockValue (loc, sliceType, values));
                if (canDynamic) {
                    // If we are inside a copy, then we avoid unecessary copy as the slice alloc already makes an allocation
                    copy CopierValue (loc, sliceType, isDone-> true, innerBlock)
                } else { // creation of an array, just return it
                    innerBlock
                }
            }
        } catch {
            err : &ErrorMsg => {
                errors ~= [err];
                UNIT_VALUE
            }
        };

        {
            context:.quitBlock (warnUnused-> errors.len == 0us);
        } catch {
            err : &ErrorMsg => { errors ~= [err]; }
        }

        if (errors.len != 0us) throw copy ErrorMsg::list (errors);
        retValue
    }

    /**
     * Validate a list comprehension on a slice value, that creates a tuple value
     * @info: the len of the slice/array must be cte
     * @params:
     *    - context: the context of the validation
     *    - slcType: the type of the slice being iterated
     *    - sliceRef: the reference to the uniq value containing the slice
     *    - all: the slice allocator to validate
     *    - iter1: the index iterator, or value iterator if iter2 is EmptyExpression
     *    - iter2: the value iterator or EmptyExpression
     *    - len: the length of the slice being iterated (throws an error if not cte)
     * @return: the created tuple value
     * @throws:
     *    - &ErrorMsg: if the validation failed
     * */
    fn validateComprSliceInnerLoopTuple (self, dmut context : &Validator, slcType : &SliceType, sliceRef : &Value, all : &SliceForAllocatorExpr, iter1 : &Expression, iter2 : &Expression, len : &Value)-> &Value
        throws ErrorMsg
    {
        let loc = all.getLoc ();
        let mut outerLoop : [&Value] = [];
        let mut values : [&Value] = [];
        let mut types : [&Type] = [];

        let tabSize = { // compute the len of the slice at cte
            let size = context:.getCompileTimeInterpreter ():.computeInt (len, signed-> false);
            size.to!usize ()
        } catch {
            _ : &ErrorMsg => throw copy ErrorMsg::fatal (all.getIter ().getLoc (), format (ValidateErrorMessage::LIST_COMPR_SIZE_CTE, slcType));
            _ : &BigIntError => {
                throw copy ErrorMsg::fatal (loc, format (ValidateErrorMessage::OVERFLOW_CAPACITY, copy IntType (loc, size-> 0u16, signed-> false), len, u64::max));
            }
        };

        let (iterRef, valueIter) = match (iter1, iter2) { // construct the index iterator
            (v : &VarDeclExpr, EmptyExpression ()) => { // only one iterator, declare an implicit iterator
                let iter = copy VarDeclValue (copy Word ("#_iter", v.getLoc ()), copy IntType (v.getLoc (), size-> 0u16, signed-> false), makeIntValue (v.getLoc (), 0us), isMutable-> false);
                let vrefIter = copy VarRefValue (iter.getLoc (), iter.getLoc (), iter.getVarType (), iter.getUniqId (), isSelf-> false, canCte-> false, isIterator-> true);
                outerLoop ~= [iter];

                (vrefIter, v)
            }
            (i : &VarDeclExpr, u : &VarDeclExpr) => { // two iterators, declare the index iterator using the provided name
                let iter = self.validateIndexIterDecl (alias context, loc, i, copy IntType (i.getLoc (), size-> 0u16, signed-> false), value-> makeIntValue (i.getLoc (), 0us), slcType, canCte-> false);
                let vrefIter = copy VarRefValue (iter.getLoc (), iter.getLoc (), iter.getVarType (), iter.getUniqId (), isSelf-> false, canCte-> false);
                context:.insertLocal (i.getLoc (), i.getName ().str, iter);

                outerLoop ~= [iter];
                (vrefIter, u)
            }
            _ => panic;
        };

        let mut errors : [&ErrorMsg] = [];
        let mut index = copy BigInt (0us);
        while (index < tabSize) { // unfolded iteratation over the slice
            context:.enterBlock ();
            let currValue = {
                // put the current index in the index iterator variable
                let currIndex = copy AffectValue (loc, iterRef.getType (), iterRef, copy IntValue (loc, iterRef.getType ().asOf!{&IntType} (), index));
                let (array, _, _) = self.validateSliceIterDecl (alias context, valueIter, slcType, sliceRef, iterRef, false, false); // use it to declare the value iterator
                context:.insertLocal (valueIter.getLoc (), valueIter.getName ().str, array);

                let value = context:.validateValue (all.getValue ()); // use those two variable to declare the value at given index

                copy BlockValue (loc, value.getType (), copy [currIndex, array, value]) // push it inside the tuple
            } catch {
                err : &ErrorMsg => {
                    errors ~= [err];
                    UNIT_VALUE
                }
            };

            {
                context:.quitBlock (warnUnused-> errors.len == 0us);
            } catch {
                err : &ErrorMsg => { errors ~= [err]; }
            }

            if (errors.len != 0us) throw copy ErrorMsg::list (errors);

            context:.getLiteralValidator ().addTupleType (alias context, currValue, alias values, alias types);
            index += 1;
        }


        let type = copy TupleType (loc, types, isMutable-> true);
        let tuV = copy TupleValue (loc, type, values); // create the tuple from the unfolded loop
        outerLoop ~= [tuV];

        // let #_iter = 0;
        // ...
        // {
        //    #_iter = 1;
        //    let v = #_value [#_iter];
        //    v
        // }
        // {
        //    #_iter = 2;
        //    let v = #_value [#_iter];
        //    v
        // }
        // ...
        copy BlockValue (loc, type, outerLoop)
    }
    
    /**
     * Validate the inner part of a list comprehension on a slice value that creates a slice or an array
     * @params:
     *    - context: the context of the validation
     *    - slcType: the type of the slice being iterated
     *    - value: the value being iterated
     *    - all: the list comprehension to validate
     *    - iter1: the index iterator or value iterator if iter2 is EmptyExpression
     *    - iter2: the value iterator of EmptyExpression
     *    - len: the length of the slice (can be unknown at cte if canDynamic)
     *    - canDynamic: if true, then the slice allocator is surrounded by a /copy/ operator, and therefore can be dynamically allocated
     * @returns:
     *   - .0: the loop filling the generated array/slice
     *   - .1: the reference to the generated array/slice
     *   - .2: the var decl of the array/slice
     *   - .3: the type of the generated array/slice
     *   - .4: iif true, only the .0 is useful, no loop was created
     * @throws:
     *   - &ErrorMsg: if the validation failed
     * */
    fn validateComprSliceInnerLoop (self, dmut context : &Validator, slcType : &SliceType, value : &Value, all : &SliceForAllocatorExpr, iter1 : &Expression, iter2 : &Expression, len : &Value, canDynamic : bool)-> (&Value, &Value, &Value, &Type, bool)
        throws ErrorMsg
    {
        let loc = all.getLoc ();
        let mut outerLoop : [&Value] = [];
        let mut innerLoopValues : [&Value] = [];

        let vars = self.validateSliceIteratorVars (alias context, value.getLoc (), slcType, value, iter1, iter2, false, false);
        let innerValue = context:.validateValue (all.getValue ());
        if (innerValue.isFullLiteral ()) {
            let fin = if (canDynamic) {
                context:.getLiteralValidator ().validateDynamicSliceAllocator (alias context, all.getLoc (), innerValue, len)
            } else {
                context:.getLiteralValidator ().validateStaticSliceAllocator (alias context, all.getLoc (), innerValue, len)
            };

            return (fin, UNIT_VALUE, UNIT_VALUE, VOID_TYPE, true);
        }

        let innerType = context:.inferTypeImplicitMutability (innerValue); // use the validated value to infer the type of the created slice

        // let x = {
        //     let #_iter = 0;
        //     let res : [i32] = new [#_value.len];
        //     while #_iter < len {
        //        let v = #_value [#_iter];
        //        res [#_iter] = v;
        //        #_iter += 1;
        //     }
        //     res
        // };
        let iter = vars._0;

        // Create the variable declaration of the result value
        let (slcValueDecl, slcValueRef, slcIndex, sliceType) = self.validateComprSliceValueDecl (alias context, all.getLoc (), slcType, innerType, iter, len, canDynamic);
        outerLoop ~= [vars._1]; // declare the index iterator

        let one = makeIntValue (loc, 1us);
        let test = copy CmpIntOperatorValue (loc, BinaryOperators::INF, iter, len); // if the iterator is greater than the value of the array the loop is stopped
        let increment = copy AffectValue (loc, iter.getType (), iter, copy BinaryMathIntOperatorValue (loc, iter.getType (), BinaryOperators::PLUS, iter, one));

        innerLoopValues ~= [vars._2]; // declare the value iterator
        innerLoopValues ~= [copy AffectValue (loc, innerType, slcIndex, innerValue)]; // affect the current iteration
        innerLoopValues ~= [increment]; // increment the index iterator

        let blkContent = copy BlockValue (loc, copy VoidType (loc), innerLoopValues);
        let lp = LoopValue (loc, copy VoidType (loc), test-> test, blkContent, isDo-> false);

        outerLoop ~= [lp];

        let retLp = copy BlockValue (loc, copy VoidType (loc), outerLoop);
        (retLp, slcValueRef, slcValueDecl, sliceType, false)
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===============================          COMPREHENSION MAP          ================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * validate a list comprehension from a map value
     * @params:
     *   - context: the context of the validation
     *   - mapType: the map type being iterated
     *   - value: the value of the map
     *   - all: the slice for creating the list comprehension
     *   - canDynamic: if true, then the slice allocator is surrounded by a /copy/ operator, and therefore can be dynamically allocated
     * @returns: the generated slice
     * @throws:
     *    - &ErrorMsg: of the validated failed
     * */
    fn validateComprMap (self, dmut context : &Validator, mapType : &MapType, value : &Value, content : &SliceForAllocatorExpr, canDynamic : bool)-> &Value
        throws ErrorMsg
    {
        let vars = content.getVariables ();
        let (key, val) = match vars.len {
            1us => {
                let name = copy Word (Keys::UNDER, content.getLoc ());
                let valVar = copy VarDeclExpr (name, name, EMPTY_EXPR, EMPTY_EXPR);
                (vars [0], valVar)
            }
            2us => {
                (vars [0], vars [1])
            }
            _ => throw copy ErrorMsg::fatal (content.getLoc (), format (ValidateErrorMessage::UNDEF_FOR_LOOP_OPERATOR, vars.len, mapType));
        };

        match (key, val) {
            (keyIter : &VarDeclExpr, valIter : &VarDeclExpr) => {
                return self.validateComprMapIteration (alias context, mapType, value, keyIter, valIter, content, canDynamic);
            }
            _ => throw copy ErrorMsg::fatal (content.getLoc (), format (ValidateErrorMessage::UNDEF_FOR_LOOP_OPERATOR, vars.len, mapType));
        }
    }


    /**
     * Validate a list comprehension from a map value
     * @params:
     *    - context: the context of the validation
     *    - mapType: the type of the map
     *    - value: the value of the map
     *    - keyIter: the key iterator
     *    - mapIter: the map iterator
     * @returns: the validated value
     * */
    fn validateComprMapIteration (self, dmut context : &Validator, mapType : &MapType, value : &Value, keyIter : &VarDeclExpr, valIter : &VarDeclExpr, all : &SliceForAllocatorExpr, canBeDynamic : bool)-> &Value
        throws ErrorMsg
    {
        if (all.isTuple ()) {
            throw copy ErrorMsg::fatal (all.getIter ().getLoc (), format (ValidateErrorMessage::LIST_COMPR_SIZE_CTE, mapType))
        } else if (!canBeDynamic) {
            throw copy ErrorMsg::fatal (all.getIter ().getLoc (), format (ValidateErrorMessage::LIST_COMPR_SIZE_CTE, mapType),
                                        notes-> copy [copy ErrorMsg::note (all.getLoc (), format (ValidateErrorMessage::ENCLOSE_COPY_LST_COMPR))]);
        }

        let mut errors : [&ErrorMsg] = [];
        let mut values : [&Value] = [];

        let loc = all.getLoc ();
        context:.enterBlock ();

        let retValue = {
            let len = context:.getCompileTimeInterpreter ():.reduce (copy StructFieldAccessValue (loc, copy IntType (loc, size-> 0u16, signed-> false), value, SliceKeys::LEN));
            let (lp, slcValueDecl, slcValueRef, sliceType) = self.validateComprMapInnerLoop (alias context, mapType, value, all, keyIter, valIter, len);

            values ~= [slcValueDecl];
            values ~= [lp];
            values ~= [slcValueRef];

            let innerBlock = copy ListComprValue (loc, sliceType, copy BlockValue (loc, sliceType, values));
            copy CopierValue (loc, sliceType, isDone-> true, innerBlock)
        } catch {
            err : &ErrorMsg => {
                errors ~= [err];
                UNIT_VALUE
            }
        };

        {
            context:.quitBlock (warnUnused-> errors.len == 0us);
        } catch {
            err : &ErrorMsg => { errors ~= [err]; }
        }

        if (errors.len != 0us) throw copy ErrorMsg::list (errors);
        retValue
    }

    /**
     * Validate the inner loop the creation of a list from a map value iteration
     * @params:
     *    - context: the context of the validation
     *    - mapType: the type of the value being iterated
     *    - value: the map value being iterated
     *    - all: the slice expr
     *    - keyIter: the var decl of the key iterator
     *    - valIter: the var decl of the value iterator
     *    - len: the value containing the length of the slice to create
     * @returns:
     *    - .0: the loop creating the slice value
     *    - .1: the declaration of the slice value
     *    - .2: the reference of the slice value
     *    - .3: the type of the slice value
     * */
    fn validateComprMapInnerLoop (self, dmut context : &Validator, mapType : &MapType, value : &Value, all : &SliceForAllocatorExpr, keyIter : &VarDeclExpr, valIter : &VarDeclExpr, len : &Value)-> (&Value, &Value, &Value, &Type)
        throws ErrorMsg
    {
        let loc = all.getLoc ();
        let mut outerValues : [&Value] = [];
        let mut innerValues : [&Value] = [];

        let indexDecl = copy VarDeclValue (copy Word ("#_index", loc), copy IntType (loc, signed-> false, size-> 0u16), makeIntValue (loc, 0us), isMutable-> true);
        let indexRef = copy VarRefValue (indexDecl.getLoc (), indexDecl.getLoc (), indexDecl.getVarType (), indexDecl.getUniqId (), isSelf-> false, canCte-> false);

        let iterType = copy MapIteratorType (value.getLoc (), mapType);
        let beginValue = copy MapIteratorBeginValue (all.getLoc (), iterType, value);
        let iterDecl = copy VarDeclValue (copy Word ("#_iter", value.getLoc ()), iterType, beginValue, isMutable-> true);
        let iterRef = copy VarRefValue (iterDecl.getLoc (), iterDecl.getLoc (), iterType, iterDecl.getUniqId (), isSelf-> false, canCte-> false);
        outerValues ~= [iterDecl]; // create the iterator over the map
        outerValues ~= [indexDecl];

        // Create the index and value iterators using the created iterator
        let (keyDecl, valDecl, _, _) = self.validateMapIteratorVars (alias context, mapType, iterRef, keyIter, valIter, false, false, value.isLvalue ());

        innerValues ~= [keyDecl]; // Insert their declaration inside the for loop content
        innerValues ~= [valDecl];

        // Insert the variable in the current scope
        context:.insertLocal (keyIter.getLoc (), keyIter.getName ().str, keyDecl);
        context:.insertLocal (valIter.getLoc (), valIter.getName ().str, valDecl);

        let resInnerValue = context:.validateValue (all.getValue ());
        let resInnerType = context:.inferTypeImplicitMutability (resInnerValue);

        let (slcValueDecl, slcValueRef, slcIndex, sliceType) = self.validateComprSliceValueDecl (alias context, all.getLoc (), mapType, resInnerType, indexRef, len, true);
        innerValues ~= [copy AffectValue (loc, resInnerType, slcIndex, resInnerValue)];

        let one = makeIntValue (loc, 1us);
        innerValues ~= [copy AffectValue (loc, indexRef.getType (), indexRef, copy BinaryMathIntOperatorValue (loc, indexRef.getType (), BinaryOperators::PLUS, indexRef, one))];
        innerValues ~= [copy MapIteratorNextValue (loc, iterRef)];
        innerValues ~= [UNIT_VALUE];

        let vdType = copy VoidType (loc);
        let test = copy MapIteratorEndValue (loc, iterRef);
        let finBlk = copy BlockValue (loc, vdType, copy [copy MapIteratorDelValue (loc, iterRef)]);

        let blk = copy BlockValue (loc, vdType, innerValues);
        outerValues ~= [copy TryFinallyValue (loc, vdType,
                                              copy LoopValue (loc, vdType, test-> test, blk, isDo-> false),
                                              finBlk, failVar-> UNIT_VALUE)];

        let upperBlk = copy BlockValue (loc, vdType, outerValues);
        (upperBlk, slcValueDecl, slcValueRef, sliceType)
    }

    /*!
     * ================================================================================
     * ================================================================================
     * ========================        COMPREHENSION TUPLE        =====================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a list comprehension from a tuple value
     * @params:
     *   - context: the context of the validation
     *   - tu: the tuple type being iterated
     *   - iter: the value being iterated
     *   - all: the list comprehension to validate
     *   - canDynamic: if true then a slice is created, thus the size can be unknown at cte
     * @returns: the generated slice/array
     * @throws:
     *   - &ErrorMsg: if the validation failes
     * */
    fn validateComprTuple (self, dmut context : &Validator, type : &TupleType, value : &Value, all : &SliceForAllocatorExpr)-> &Value
        throws ErrorMsg
    {
        let vars = all.getVariables ();
        match vars.len {
            1us => {
                return self.validateComprTupleIteration (alias context, type, value, all, vars[0], EMPTY_EXPR);
            }
            2us => {
                return self.validateComprTupleIteration (alias context, type, value, all, vars[0], vars[1]);
            }
            _ => {
                throw copy ErrorMsg::fatal (all.getLoc (), format (ValidateErrorMessage::UNDEF_FOR_LOOP_OPERATOR, vars.len, type));
            }
        }
    }

    /**
     * Validate the list comprehension from a tuple value
     * @params:
     *    - context: the context of the validation
     *    - type: the type of the tuple being iterated
     *    - value: the
     * */
    fn validateComprTupleIteration (self, dmut context : &Validator, type : &TupleType, value : &Value, all : &SliceForAllocatorExpr, iter1 : &Expression, iter2 : &Expression)-> &Value
        throws ErrorMsg
    {
        let mut content : [&Value] = [];
        let mut arrType : &Type = copy NoneType (all.getLoc ());
        let mut tuTypes : [&Type] = [];

        for i in 0us .. type.getInners ().len { // we validate the content of the loop for each type of the tuple
            let (value_, _, _) = self.validateTupleInnerLoop (alias context, i, iter1, iter2, type, value, all.getValue (), false, false, forLstCompr-> true);
            if (all.isTuple ()) {
                context:.getLiteralValidator ().addTupleType (alias context, value_, alias content, alias tuTypes);
            } else {
                arrType = context:.getLiteralValidator ().addArrayType (alias context, value_, alias content, arrType);
            }
        }

        if (all.isTuple ()) {
            let tu = copy TupleType (all.getLoc (), tuTypes, isMutable-> true);
            copy TupleValue (all.getLoc (), tu, content)
        } else {
            if (content.len == 0us && arrType of NoneType) arrType = copy VoidType (all.getLoc ());

            let finType = copy ArrayType (all.getLoc (), arrType, content.len, isMutable-> true);
            copy ArrayValue (all.getLoc (), finType, content)
        }
    }

    /*!
     * ================================================================================
     * ================================================================================
     * ========================        COMPREHENSION RANGE        =====================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a list comprehension from a range value
     * @params:
     *   - context: the context of the validation
     *   - ra: the range type being iterated
     *   - iter: the value being iterated
     *   - all: the list comprehension to validate
     *   - canDynamic: if true then a slice is created, thus the size can be unknown at cte
     * @returns: the generated slice/array
     * @throws:
     *   - &ErrorMsg: if the validation failes
     * */
    fn validateComprRange (self, dmut context : &Validator, rngType : &RangeType, value : &Value, all : &SliceForAllocatorExpr, canDynamic : bool)-> &Value
        throws ErrorMsg
    {
        let vars = all.getVariables ();

        if (vars.len != 1us) throw copy ErrorMsg::fatal (all.getLoc (), format (ValidateErrorMessage::UNDEF_FOR_LOOP_OPERATOR, vars.len, rngType));

        let loc = all.getLoc ();
        let mut values : [&Value] = [];
        let dmut interpret = context:.getCompileTimeInterpreter ();

        let fst  = interpret:.reduce (copy StructFieldAccessValue (loc, rngType.getInners ()[0], value, RangeKeys::FST));
        let scd  = interpret:.reduce (copy StructFieldAccessValue (loc, rngType.getInners ()[0], value, RangeKeys::SCD));
        let step = interpret:.reduce (copy StructFieldAccessValue (loc, rngType.getInners ()[1], value, RangeKeys::STEP));
        let contains = interpret:.reduce (copy StructFieldAccessValue (loc, copy BoolType (loc), value, RangeKeys::CONTAINS));

        let iterDecl = copy VarDeclValue (copy Word ("#_iter", loc), copy IntType (loc, signed-> false, size-> 0u16), makeIntValue (loc, 0us), isMutable-> true, isIterator-> true);
        let mut iterRef = copy VarRefValue (iterDecl.getLoc (), loc, iterDecl.getVarType (), iterDecl.getUniqId (), isSelf-> false, canCte-> false, isIterator-> true);
        values ~= [iterDecl];

        let nbIterRef = if (!interpret.isCte (fst) || !interpret.isCte (scd) || !interpret.isCte (step) || !interpret.isCte (contains)) {
            let nbIteration = self.validateComputeNbIterations (scd.getLoc (), alias context, fst, scd, step, contains);
            let nbIterDecl = copy VarDeclValue (copy Word ("#_nb_iter", scd.getLoc ()), copy IntType (loc, signed-> false, size-> 0u16), nbIteration, isMutable-> true);
            let mut nbIterRef = copy VarRefValue (nbIterDecl.getLoc (), loc, nbIterDecl.getVarType (), nbIterDecl.getUniqId (), isSelf-> false, canCte-> false);

            values ~= [nbIterDecl];
            nbIterRef
        } else {
            context:.getCompileTimeInterpreter ():.reduce (self.validateComputeNbIterations (loc, alias context, fst, scd, step, contains))
        };


        let mut errors : [&ErrorMsg] = [];

        context:.enterBlock ();
        let retValue = if (all.isTuple ()) {
            let lp = self.validateComprRangeInnerLoopTuple (alias context, rngType, all, vars [0], nbIterRef, fst, step);
            values ~= [lp];
            copy BlockValue (loc, lp.getType (), values)
        } else {
            if (!canDynamic) {
                let size = context:.getCompileTimeInterpreter ():.computeInt (nbIterRef);
                size.to!u64 ();
            } catch {
                _ : &ErrorMsg => throw copy ErrorMsg::fatal (all.getIter ().getLoc (), format (ValidateErrorMessage::LIST_COMPR_SIZE_CTE, rngType),
                                                             notes-> copy [copy ErrorMsg::note (loc, format (ValidateErrorMessage::ENCLOSE_COPY_LST_COMPR))]);
                _ : &BigIntError => throw copy ErrorMsg::fatal (loc, format (ValidateErrorMessage::OVERFLOW_CAPACITY, copy IntType (loc, size-> 0u16, signed-> false), nbIterRef, u64::max));
            }

            let (lp, slcValueRef, slcValueDecl, sliceType, withoutLoop) = self.validateComprRangeInnerLoopArray (alias context, rngType, all, vars [0], iterRef, nbIterRef, fst, step, canDynamic);
            if (withoutLoop) {
                copy BlockValue (loc, lp.getType (), copy [lp])
            } else {

                // Declare the value
                values ~= [slcValueDecl];
                values ~= [lp]; // iterate to fill its content
                values ~= [slcValueRef]; // return the generated value

                // Put inside a copier, because it is already allocated, so first level copy should not be done again
                let innerBlock = copy ListComprValue (loc, sliceType, copy BlockValue (loc, sliceType, values));
                if (canDynamic) {
                    copy CopierValue (loc, sliceType, isDone-> true, innerBlock)
                } else {
                    innerBlock
                }
            }
        } catch {
            err : &ErrorMsg => {
                errors ~= [err];
                UNIT_VALUE
            }
        };

        {
            context:.quitBlock (warnUnused-> errors.len == 0us);
        } catch {
            err : &ErrorMsg => { errors ~= [err]; }
        }

        if (errors.len != 0us) throw copy ErrorMsg::list (errors);
        retValue
    }

    /**
     * Validate the inner value of a list comprehension iterating over a range value
     * @params:
     *    - context: the context of the validation
     *    - rngType: the type of the iterated value
     *    - all: the slice for allocator
     *    - var: the value iterator (not yet validated)
     *    - nbIterRef: the value containing the number of iteration to perform
     *    - fst: the first value of the range
     *    - step: the step of the range
     * @returns:
     *    - .0: the loop filling the result value
     *    - .1: the refrence to the created value
     *    - .2: the declaration of the created value
     *    - .3: the type of the created value
     * @throws:
     *    - &ErrorMsg: if the validation failed
     * */
    fn validateComprRangeInnerLoopTuple (self, dmut context : &Validator, rngType : &RangeType, all : &SliceForAllocatorExpr, var : &Expression, nbIterRef : &Value, fst : &Value, step : &Value)-> &Value
        throws ErrorMsg
    {
        let loc = all.getLoc ();
        let mut values : [&Value] = [];
        let mut types : [&Type] = [];

        let tabSize = {
            let size = context:.getCompileTimeInterpreter ():.computeInt (nbIterRef, signed-> false);
            size.to!usize ()
        } catch {
            _ : &ErrorMsg => throw copy ErrorMsg::fatal (all.getIter ().getLoc (), format (ValidateErrorMessage::LIST_COMPR_SIZE_CTE, rngType));
            _ : &BigIntError => throw copy ErrorMsg::fatal (loc, format (ValidateErrorMessage::OVERFLOW_CAPACITY, copy IntType (loc, size-> 0u16, signed-> false), nbIterRef, u64::max));
        };

        let st = context:.getCompileTimeInterpreter ():.computeInt (step);
        let fs = context:.getCompileTimeInterpreter ():.computeInt (fst);

        let mut index = copy BigInt (0us);
        while (index < tabSize) {
            let current = copy IntValue (loc, rngType.getInners ()[0].asOf!{&IntType} (), index * st + fs);
            let innerValue = context:.validateValue (self.createCurrentCteBlock (alias context, all.getValue (), rngType, copy [var], copy [current]));

            context:.getLiteralValidator ().addTupleType (alias context, innerValue, alias values, alias types);
            index += 1;
        }

        let type = copy TupleType (loc, types, isMutable-> true);
        copy TupleValue (loc, type, values)
    }

    /**
     * Validate the inner value of a list comprehension iterating over a range value
     * @params:
     *    - context: the context of the validation
     *    - rngType: the type of the iterated value
     *    - all: the slice for allocator
     *    - var: the value iterator (not yet validated)
     *    - iterRef: the reference to the index iterator
     *    - nbIterRef: the value containing the number of iteration to perform
     *    - fst: the first value of the range
     *    - step: the step of the range
     *    - canDynamic: true if the result is a slice, false if the result is an array
     * @returns:
     *    - .0: the loop filling the result value
     *    - .1: the refrence to the created value
     *    - .2: the declaration of the created value
     *    - .3: the type of the created value
     *    - .4: iif true, only the .0 is useful, no loop was created
     * @throws:
     *    - &ErrorMsg: if the validation failed
     * */
    fn validateComprRangeInnerLoopArray (self, dmut context : &Validator, rngType : &RangeType, all : &SliceForAllocatorExpr, var : &Expression, iterRef : &Value, nbIterRef : &Value, fst : &Value, step : &Value, canDynamic : bool)-> (&Value, &Value, &Value, &Type, bool)
        throws ErrorMsg
    {
        let loc = all.getLoc ();
        let mut innerLoopValues : [&Value] = [];

        let (varRef, varDecl) = self.validateRangeIteratorVar (alias context, loc, rngType, var); // validate the value iterator
        let innerValue = context:.validateValue (all.getValue ()); // Validate the value using the declared iterator
        if (innerValue.isFullLiteral ()) {
            let fin = if (canDynamic) {
                context:.getLiteralValidator ().validateDynamicSliceAllocator (alias context, all.getLoc (), innerValue, nbIterRef)
            } else {
                context:.getLiteralValidator ().validateStaticSliceAllocator (alias context, all.getLoc (), innerValue, nbIterRef)
            };

            return (fin, UNIT_VALUE, UNIT_VALUE, VOID_TYPE, true);
        }

        let innerType = context:.inferTypeImplicitMutability (innerValue); // use the validated value to infer the type of the created slice
        let (slcValueDecl, slcValueRef, slcIndex, sliceType) = self.validateComprSliceValueDecl (alias context, all.getLoc (), rngType, innerType, iterRef, nbIterRef, canDynamic);

        // Loop incrementation
        let (increment, setIndex, test) = self.validateRangeIteratorIncrement (alias context, loc, iterRef, nbIterRef, varRef, fst, step);
        if (varRef.getLoc () != Keys::UNDER) {
            innerLoopValues ~= [varDecl];
            innerLoopValues ~= [setIndex];
        }

        // Content of the loop
        innerLoopValues ~= [copy AffectValue (loc, innerType, slcIndex, innerValue)];
        innerLoopValues ~= [increment];

        let blkContent = copy BlockValue (loc, copy VoidType (loc), innerLoopValues);
        let lp = copy LoopValue (loc, copy VoidType (loc), test-> test, blkContent, isDo-> false);

        (lp, slcValueRef, slcValueDecl, sliceType, false)
    }


    /*!
     * ================================================================================
     * ================================================================================
     * ========================        COMPREHENSION CLASS        =====================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a list comprehension over a class value
     * @params:
     *     - context: the context of the validation
     *     - cptr: the type being iterated
     *     - value: the value being iterated
     *     - all: the for loop
     *     - canDynamic: if not true, throws an error the len cannot be cte
     * @throws:
     *    - &ErrorMsg: if the class is not iterable, or has no len or tries to create a tuple/array
     * @returns: the generated slice value
     * */
    fn validateComprClass (self, dmut context : &Validator, cptr : &ClassPtrType, value : &Value, all : &SliceForAllocatorExpr, byAlias : bool, aliasLoc : &Word, canDynamic : bool)-> &Value
        throws ErrorMsg
    {
        let loc = all.getLoc ();
        let (useAlias, beginMeth, endMeth) = {
            let inst = if (byAlias) { copy ClassAliaserValue (loc, cptr, value) } else {value};
            let (beginMeth, useAliasBeg) = self.createIterOverCptrCall (alias context, loc, cptr, inst, OpOverrideNames::BEGIN);
            let (endMeth, useAliasEnd) = self.createIterOverCptrCall (alias context, loc, cptr, inst, OpOverrideNames::END);
            (useAliasEnd || useAliasBeg, beginMeth, endMeth)
        } catch {
            err : &ErrorMsg => throw copy ErrorMsg::fatal (loc, format (ValidateErrorMessage::FOR_LOOP_CPTR, cptr), notes-> copy [err]);
        };

        if (!canDynamic || all.isTuple ()) {
            throw copy ErrorMsg::fatal (all.getIter ().getLoc (), format (ValidateErrorMessage::LIST_COMPR_SIZE_CTE, cptr),
                                        notes-> copy [copy ErrorMsg::note (loc, format (ValidateErrorMessage::ENCLOSE_COPY_LST_COMPR))]);
        }

        let mut outerLoop : [&Value] = [];
        let mut innerLoop : [&Value] = [];
        let mut errors : [&ErrorMsg] = [];

        context:.enterBlock ();
        let (_loop, slcValueDecl, slcValueRef, slcType) = {
            let (test, increment) = self.validateClassLoopIteratorVar (alias context, loc, cptr, beginMeth, endMeth, all.getVariables (), ref innerLoop, ref outerLoop);
            let innerValue = context:.validateValue (all.getValue ());
            let innerType = context:.inferTypeImplicitMutability (innerValue);

            let slcType = copy SliceType (loc, innerType, isMutable-> true);
            let slcValueDecl = copy VarDeclValue (copy Word ("#_value", loc), slcType, copy ArrayAllocValue::dyn (loc, slcType, UNIT_VALUE, makeIntValue (loc, 0us)), isMutable-> true);
            let slcValueRef = copy VarRefValue (slcValueDecl.getLoc (), loc, slcValueDecl.getVarType (), slcValueDecl.getUniqId (), isSelf-> false, canCte-> false);
            let val = context.createSliceFromSingleValue (loc, innerValue, mutable-> innerType.isMutable ());

            innerLoop ~= [copy SliceAppendValue (loc, slcType, slcValueRef, val)]; //copy AffectValue (loc, innerType, slcIndex, innerValue));
            innerLoop ~= [increment];

            let blkContent = copy BlockValue (loc, copy VoidType (loc), innerLoop);
            let _loop = copy LoopValue (loc, copy VoidType (loc), test-> test, blkContent, isDo-> false);
            (_loop, slcValueDecl, slcValueRef, slcType)
        } catch {
            err : &ErrorMsg => {
                errors ~= [err];
                (UNIT_VALUE, UNIT_VALUE, UNIT_VALUE, NONE_TYPE)
            }
        };

        {
            context:.quitBlock (warnUnused-> errors.len == 0us);
        } catch {
            err : &ErrorMsg => { errors ~= [err]; }
        }

        if (errors.len != 0us) throw copy ErrorMsg::fatal (loc, format (ValidateErrorMessage::FOR_LOOP_CPTR, cptr), notes-> errors);
        self.verifyUseAliasCptrIter (loc, aliasLoc, cptr, beginMeth, endMeth, useAlias, byAlias);

        outerLoop ~= [slcValueDecl];
        outerLoop ~= [_loop];
        outerLoop ~= [slcValueRef];

        let innerBlock = copy ListComprValue (loc, slcType, copy BlockValue (loc, slcType, outerLoop));
        copy CopierValue (loc, slcType, isDone-> true, innerBlock)
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =============================        CTE RANGE        ==========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a cte for loop operation on an range value
     * @params:
     *    - context: the context of the validation
     *    - rngType: the type of the value
     *    - value: the value being iterated
     *    - content: the expression to validate
     * @returns: a validate value
     * @throws:
     *     - &ErrorMsg: if the validation failed
     * */
    fn validateCteRangeLoop (self, dmut context : &Validator, rngType : &RangeType, value : &Value, f : &ForLoopExpr)-> &Value
        throws ErrorMsg
    {
        let vars = f.getVariables ();
        if (vars.len != 1us) throw copy ErrorMsg::fatal (f.getLoc (), format (ValidateErrorMessage::UNDEF_CTE_FOR_LOOP_OPERATOR, vars.len, rngType));

        let mut errors : [&ErrorMsg] = [];
        let mut innerValues : [&Value] = [];
        let loc = f.getLoc ();

        context:.enterBlock ();
        {
            let start = context:.getCompileTimeInterpreter ():.computeInt (copy StructFieldAccessValue (loc, rngType.getInners ()[0], value, RangeKeys::FST));
            let step = context:.getCompileTimeInterpreter ():.computeInt (copy StructFieldAccessValue (loc, rngType.getInners ()[1], value, RangeKeys::STEP));
            let contains = context:.getCompileTimeInterpreter ():.computeBool (copy StructFieldAccessValue (loc, copy BoolType (loc), value, RangeKeys::CONTAINS));
            let end = context:.getCompileTimeInterpreter ():.computeInt (copy StructFieldAccessValue (loc, rngType.getInners ()[0], value, RangeKeys::SCD));

            let sizeType = copy IntType (loc, size-> 0u16, signed-> false);
            let max = context:.getCompileTimeInterpreter ().createIntMaxValue (sizeType);
            let nbIterations = self.validateCteComputeNbIterations (start, end, step, max, contains);

            if (nbIterations > global::state::instance ().getMaxCteLoopIter ()) {
                throw copy ErrorMsg::fatal (loc, format (ValidateErrorMessage::MAX_LOOP_ITERATIONS, nbIterations, global::state::instance ().getMaxCteLoopIter ()));
            }

            let mut index = copy BigInt (0us);
            while (index < nbIterations) {
                let current = copy IntValue (loc, rngType.getInners ()[0].asOf!{&IntType} (), index * step + start);

                let block = self.createCurrentCteBlock (alias context, f.getBlock (), rngType, vars, copy [current]);
                innerValues ~= [context:.validateValue (block)];
                index += 1;
            }
        } catch {
            err : &ErrorMsg => { errors ~= [err]; }
        }

        {
            context:.quitBlock (warnUnused-> errors.len == 0us);
        } catch {
            err : &ErrorMsg => { errors ~= [err]; } // Some warn unused
        }

        if (errors.len != 0us) throw copy ErrorMsg::list (errors);
        copy BlockValue (loc, copy VoidType (loc), innerValues)
    }


    /*!
     * ================================================================================
     * ================================================================================
     * =============================        COMMON        =============================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a variable decl from iteration variable
     * @params:
     *     - context: the context of the validation
     *     - loc: the location of the iteration
     *     - vdecl: the variable being declared
     *     - type: the expected type of the resutl value
     *     - globType: the type being iterated
     *     - withDeco: true if the variable can have decorators
     * @returns: a vardecl value
     * */
    fn validateIndexIterDecl (self, dmut context : &Validator, loc : &Word, vdecl : &VarDeclExpr, type : &Type, value : &Value = UNIT_VALUE, globType : &Type, canCte : bool = true)-> &VarDeclValue
        throws ErrorMsg
    {
        if (!vdecl.getLazyOrRefLocation ().isEof ()) {
            throw copy ErrorMsg::fatal (vdecl.getLazyOrRefLocation (), end-> loc, format (ValidateErrorMessage::FORBID_DECO_FOR_LOOP, globType));
        }

        if (!vdecl.getMutOrDmutLocation ().isEof ()) {
            throw copy ErrorMsg::fatal (vdecl.getMutOrDmutLocation (), end-> loc, format (ValidateErrorMessage::FORBID_DECO_FOR_LOOP, globType));
        }

        let vType = if (vdecl.getType () !of EmptyExpression) {
            let vtype = context:.validateType (vdecl.getType (), parentMutable-> false);
            context.verifyCompatibleType (vdecl.getType ().getLoc (), loc, vtype, type);
            vtype
        } else {
            context:.validateType (copy TypeWrapperExpr (value.getLoc (), type), parentMutable-> false)
        };

        let nameLoc = if (vdecl.getLoc () == Keys::UNDER) {
            copy Word ("#_iter", vdecl.getLoc ())
        } else {
            vdecl.getLoc ()
        };

        copy VarDeclValue (nameLoc, vType, value, isMutable-> false, isCte-> canCte, isIterator-> true)
    }

    /**
     * Create the block of a for loop that has to be validated at cte time
     * @params:
     *    - context: the context of the validation
     *    - block: the block template
     *    - globType: the type being iterated
     *    - vars: the list of variables used to iterate (assuming its len is equal to the len of values)
     *    - values: the list of values to assign to vars
     * @returns: an expression
     * */
    fn createCurrentCteBlock (self, dmut context : &Validator, block : &Expression, globType : &Type, vars : [&Expression], values : [&Value])-> &Expression
        throws ErrorMsg
    {
        let mut mapper = TemplateMapper ();
        for i in 0us .. vars.len match vars [i] {
            v : &VarDeclExpr => {
                if (!v.getLazyOrRefLocation ().isEof ()) {
                    throw copy ErrorMsg::fatal (v.getLazyOrRefLocation (), format (ValidateErrorMessage::FORBID_DECO_FOR_LOOP, globType));
                }

                if (!v.getMutOrDmutLocation ().isEof ()) {
                    throw copy ErrorMsg::fatal (v.getMutOrDmutLocation (), format (ValidateErrorMessage::FORBID_DECO_FOR_LOOP, globType));
                }

                if (v.getType () !of EmptyExpression) {
                    let vtype = context:.validateTypeForVarDecl (v.getType (), v, canBeRef-> false);
                    context.verifyCompatibleType (v.getType ().getLoc (), values [i].getLoc (), vtype, values [i].getType ());
                }

                mapper:.insert (v.getLoc ().str, copy ValueWrapperExpr (values [i].getLoc (), values [i]));
            }
            _ => panic;
        }

        // We directly rewrite without using the template declarator
        // Template declarator is mandatory for complex template mapper, but here we only have value wrapper
        // There is no lambda or inlining to perform, thus there is no need for complexity
        let rewriter = TemplateRewriter (mapper);
        rewriter.rewrite (block)
    }

    /**
     * Validate the variable declaration of the value result of a list comprehension
     * @params:
     *    - context: the context of the validation
     *    - loc: the location of the slice for
     *    - iterType: the type being iterated
     *    - innerType: the innerType of the result slice/array
     *    - iterRef: the reference to the index iterator
     *    - len: the length of the result array/slice
     *    - canDynamic: if true return an allocated slice, an array otherwise
     * @return:
     *   - .0: the variable declaration of the result
     *   - .1: the reference to the declared variable
     *   - .2: value indexing the declared variable to put as a left operand in the loop validation (e.g. #_value [#_iter])
     *   - .3: the type of the result variable
     * */
    pub fn validateComprSliceValueDecl (self, dmut context : &Validator, loc : &Word, iterType : &Type, innerType : &Type, iterRef : &Value, len : &Value, canDynamic : bool)-> (&Value, &Value, &Value, &Type)
        throws ErrorMsg
    {
        let (sliceType, sliceInitValue) = if (canDynamic) {
            let type = copy SliceType (loc, innerType, isMutable-> true);
            (type, copy ArrayAllocValue::dyn (loc, type, UNIT_VALUE, len)) // allocate a slice to be filled without setting a default value that will be replace anyway
        } else {
            let tabSize = { // if it is not dynamic, then we must know the size at cte
                let size = context:.getCompileTimeInterpreter ():.computeInt (len, signed-> false);
                size.to!usize ()
            } catch {
                _ : &ErrorMsg => throw copy ErrorMsg::fatal (loc, format (ValidateErrorMessage::LIST_COMPR_SIZE_CTE, iterType));
                _ : &BigIntError => throw copy ErrorMsg::fatal (loc, format (ValidateErrorMessage::OVERFLOW_CAPACITY, copy IntType (loc, size-> 0u16, signed-> false), len, u64::max));
            };

            if (tabSize > 1048576us) { // 1MB
                throw copy ErrorMsg::fatal (loc, format (ValidateErrorMessage::OVERFLOW_CAPACITY_ARRAY, tabSize, 1048576us));
            }

            let type = copy ArrayType (loc, innerType, tabSize, isMutable-> true);
            (type, UNIT_VALUE) // no need to allocate, the variable declaration will be enough
        };

        // Declaration of the variable that will store the result of the list comprehension
        let name = copy Word ("#_value", loc);
        let slcValueDecl = copy VarDeclValue (name, sliceType, sliceInitValue, isMutable-> true);
        let slcValueRef = copy VarRefValue (name, name, slcValueDecl.getVarType (), slcValueDecl.getUniqId (), isSelf-> false, canCte-> false);

        let slcIndex = if (canDynamic) { // affecting at each index
            copy SliceAccessValue (loc, innerType, slcValueRef, iterRef)
        } else {
            copy ArrayAccessValue (loc, innerType, slcValueRef, iterRef)
        };

        (slcValueDecl, slcValueRef, slcIndex, sliceType)
    }

}
