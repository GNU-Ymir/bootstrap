mod ymirc::semantic::validator::operator::forloop;

import std::io;
import std::collection::vec;

import ymirc::semantic::validator::visitor;
import ymirc::semantic::validator::errors;
import ymirc::semantic::validator::template::_;

import ymirc::errors::_;
import ymirc::utils::format;
import ymirc::semantic::generator::value::_;
import ymirc::syntax::expression::_;
import ymirc::syntax::keys;
import ymirc::lexing::word;
import ymirc::lexing::tokens;

import ymirc::semantic::generator::type::_;
import ymirc::global::core_;
import ymirc::utils::bigint;

/**
 * The For loop validator is used to validate ForLoopExpr
 * It is a class validator because for loop operations are complex
 */
pub class ForLoopValidator {

    /**
     * Create an empty validator     
     */
    pub self () {}
    
    /**
     * Validate a for loop expression
     * @params: 
     *  - context: the context of the validation
     *  - f: the for loop to validate
     * @returns: a value
     * @throws:
     *   - &ErrorMsg: if the validation failed
     */
    pub fn validate (self, dmut context : &Validator, f : &ForLoopExpr) -> &Value
        throws &ErrorMsg
    {
        let mValue = context:.getValueValidator ().validate (alias context, f.getValue (), canBeRef-> true);
        let (byMutRef, byAlias, fVal) = match mValue {
            r : &ReferencerValue => { (r.isMutable (), false, r.getValue ()) }
            a : &AliaserValue => { (false, true, a.getValue ()) }
            _ => { (false, false, mValue) }
        };

        let (value, innerUseRef, innerUseAlias) = match fVal.getType () {
            t : &TupleType => { self.validateTupleLoop (alias context, t, fVal, f, byMutRef, byAlias) }
            s : &SliceType => { self.validateSliceLoop (alias context, s, fVal, f, byMutRef, byAlias) }
            a : &ArrayType => { self.validateArrayLoop (alias context, a, fVal, f, byMutRef, byAlias) }
            r : &RangeType => { (self.validateRangeLoop (alias context, r, fVal, f), false, false) }
            _ => {
                throw ErrorMsg::fatal (f.getLoc (), format (ValidateErrorMessage::UNDEF_FOR_LOOP_OPERATOR, f.getVariables ().len, fVal.getType ()));
            }
        }

        if (!innerUseRef && byMutRef) {
            throw ErrorMsg::fatal (mValue.getLoc (), ValidateErrorMessage::UNECESSARY_REFERENCE);
        } else if (!innerUseAlias && byAlias) {
            throw ErrorMsg::fatal (mValue.getLoc (), format (ValidateErrorMessage::UNECESSARY_ALIAS, mValue.getType ()));
        }

        value
    }

    /**
     * Validate a for loop expression that is unrolled at cte
     * @params:
     *    - context: the context of the compilation
     *    - f: the for loop to validate
     * @returns: a block containing the unrolled for loop
     * @throws:
     *    - &ErrorMsg: if the validation failed
     * */
    pub fn validateCteForLoop (self, dmut context : &Validator, f : &ForLoopExpr)-> &Value
        throws &ErrorMsg
    {
        let value = context:.validateValue (f.getValue ());
        match value.getType () {
            t : &TupleType => { self.validateTupleLoop (alias context, t, value, f, false, false)._0 }
            r : &RangeType => { self.validateCteRangeLoop (alias context, r, value, f) }
            _ => {
                throw ErrorMsg::fatal (f.getLoc (), format (ValidateErrorMessage::UNDEF_CTE_FOR_LOOP_OPERATOR, f.getVariables ().len, value.getType ()));
            }
        }
    }

    /**
     * Validate a slice for loop expression
     * @params:
     *    - context: the context of the validation
     *    - all: the slice allocator to validate
     * @returns: a value
     * @throws:
     *    - &ErrorMsg, if the validation failed
     * */
    pub fn validateListComprehension (self, dmut context : &Validator, all : &SliceForAllocatorExpr)-> &Value
        throws &ErrorMsg
    {
        let dynamic = context.isDynamic (all);
        let value = context:.validateValue (all.getIter ());
        match value.getType () {
            t : &TupleType => { self.validateComprTuple (alias context, t, value, all, dynamic) }
            s : &SliceType => { self.validateComprSlice (alias context, s, value, all, dynamic) }
            r : &RangeType => { self.validateComprRange (alias context, r, value, all, dynamic) }
            _ => {
                throw ErrorMsg::fatal (all.getForLoc (), format (ValidateErrorMessage::UNDEF_FOR_LOOP_OPERATOR, all.getVariables ().len, value.getType ()));
            }
        }
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================        LOOP ON TUPLES        =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a for loop on a tuple
     * @params: 
     *    - context: the context of the validation
     *    - type: the type of the tuple
     *    - value: the value to iterate
     *    - f: the for loop to validate
     * @throws: 
     *    - &ErrorMsg: if the validation failed
     * @returns: the validated loop
     */
    fn validateTupleLoop (self, dmut context : &Validator, type : &TupleType, value : &Value, f : &ForLoopExpr, byMutRef : bool, byAlias : bool)-> (&Value, bool, bool)
        throws &ErrorMsg
    {
        let vars = f.getVariables ();
        match vars.len {
            1us => {
                return self.validateTupleIteration (alias context, type, value, f, vars[0], EmptyExpression::new (), byMutRef, byAlias);
            }
            2us => {
                return self.validateTupleIteration (alias context, type, value, f, vars[0], vars[1], byMutRef, byAlias);
            }
            _ => {
                throw ErrorMsg::fatal (f.getLoc (), format (ValidateErrorMessage::UNDEF_FOR_LOOP_OPERATOR, vars.len, type));
            }
        }
    }

    /**
     * Validate a for loop iteration on a tuple
     * @params:
     *     - context: the context of the validation
     *     - type: the type of the tuple
     *     - value: the value of the tuple (already uniq)
     *     - f: the for loop
     *     - iter1: the declaration of the first iteration variable
     *     - iter2: the declaration of the second iteration variable (might be EmptyExpression)
     * @throws:
     *     - &ErrorMsg: if the validation failed
     * @returns: the validated loop
     * */
    fn validateTupleIteration (self, dmut context : &Validator, type : &TupleType, value : &Value, f : &ForLoopExpr, iter1 : &Expression, iter2 : &Expression, byMutRef : bool, byAlias : bool)-> (&Value, bool, bool)
        throws &ErrorMsg
    {
        let mut useRef = false, mut useAlias = false;
        let dmut content = Vec!{&Value}::new ();
        context:.enterLoop (); // Even if it is unwinded at compile time, it should behave like a loop (so we can break in it)
        context:.setCurrentLoopType (VoidType::new (f.getLoc ())); // it has no type, (because there is no else part for the moment ?, in theory it is no necessary if we check that there is at least one value in the tuple?)
        {
            for i in 0us .. type.getInners ().len { // we validate the content of the loop for each type of the tuple
                let (value_, useRef_, useAlias_) = self.validateTupleInnerLoop (alias context, i, iter1, iter2, type, value, f.getBlock (), byMutRef, byAlias);
                content:.push (value_);
                useAlias = useAlias || useAlias_;
                useRef = useRef || useRef_;
            }
        } catch {
            err : &ErrorMsg => {
                context:.quitLoop (); // we must not forget to quit the loop
                throw err;
            }
        }

        context:.quitLoop ();
        let inner = BlockValue::new (f.getLoc (), VoidType::new (f.getLoc ()), content[]);
        (LoopValue::new (f.getLoc (), VoidType::new (f.getLoc ()), UNIT_VALUE, inner, false, isCteFor-> true), useRef, useAlias)
    }

    /**
     * Validate the inner content of a loop iteration over a tuple value
     * @params: 
     *     - context: the context of the validation
     *     - i: the index of the current iteration 
     *     - vdecl: the variable iterator to declare
     *     - type: the type of the tuple to iterate
     *     - value: the content of the tuple value
     *     - blk: the content of the for loop
     * @returns: the content of the for loop validated for th i-th iteration
     * @throws:
     *    - &ErrorMsg: if the validation failed
     */
    fn validateTupleInnerLoop (self, dmut context : &Validator, i : usize, iter1 : &Expression, iter2 : &Expression, type : &TupleType, value : &Value, blk : &Expression, byMutRef : bool, byAlias : bool)-> (&Value, bool, bool)
        throws &ErrorMsg
    {
        let dmut errors = Vec!{&ErrorMsg}::new ();        
        context:.enterBlock ();
        let (res, useRef, useAlias) = { // Simply validate the content of a single iteration
            match (iter1, iter2) {
                (vdecl : &VarDeclExpr, EmptyExpression ()) => {
                    let (var, useRef, useAlias) = self.validateTupleIterDecl (alias context, vdecl, type, value, byMutRef, byAlias, i);
                    if (vdecl.getLoc () != Keys::UNDER) context:.insertLocal (vdecl.getLoc ().str (), var); // we declare the variable so we can retreive it inside the loop

                    let content = context:.validateValue (blk); // we validate the content of the loop
                    (BlockValue::new (blk.getLoc (), VoidType::new (blk.getLoc ()), [var, content]), useRef, useAlias) // and we return the loop iteration block
                }
                (idecl : &VarDeclExpr, vdecl : &VarDeclExpr) => {
                    let (var, useRef, useAlias) = self.validateTupleIterDecl (alias context, vdecl, type, value, byMutRef, byAlias, i);
                    if (vdecl.getLoc () != Keys::UNDER) context:.insertLocal (vdecl.getLoc ().str (), var);

                    let indexType = IntType::new (idecl.getLoc (), size-> 0u16, signed-> false);
                    let indexVal = makeIntValue (idecl.getLoc (), i);
                    let index = self.validateIndexIterDecl (alias context, value.getLoc (), idecl, indexType, value-> indexVal, globType-> type, canCte-> true);
                    if (idecl.getLoc () != Keys::UNDER) context:.insertLocal (idecl.getLoc ().str (), index);

                    let content = context:.validateValue (blk); // we validate the content of the loop
                    (BlockValue::new (blk.getLoc (), VoidType::new (blk.getLoc ()), [var, index, content]), useRef, useAlias)
                }
                _ => __pragma!panic ();
            }
        } catch {
            err: &ErrorMsg => {
                errors:.push (err);
                (UNIT_VALUE, false, false)
            }
        }

        {
            context:.quitBlock (warnUnused-> errors.len () == 0us); // if there was an error, we don't add the warn unused
        } catch { 
            err : &ErrorMsg => errors:.push (err); 
        }

        if (errors.len () != 0us) throw ErrorMsg::list (errors[]);
        (res, useRef, useAlias)
    }

    /**
     * Validate the iterator variable of a tuple iteration
     * @params:
     *    - context: the context of the validation
     *    - vdecl: the iterator variable declaration
     *    - type: the type of the tuple
     *    - value: the value being iterated
     *    - byMutRef: true if the value is passed by mutable reference
     *    - byAlias: true if the value was aliased
     *    - i: the current index
     * */
    fn validateTupleIterDecl (self, dmut context : &Validator, vdecl : &VarDeclExpr, type : &TupleType, value : &Value, byMutRef : bool, byAlias : bool, i : usize)-> (&Value, bool, bool)
        throws &ErrorMsg
    {
        let curTupleType = type.getInners()[i];
        let isPure = context.findDecos (vdecl.getDecos (), [Decorators::PURE]);
        let isRef = context.findDecos (vdecl.getDecos (), [Decorators::REF]);
        let isMutable = context.findDecos (vdecl.getDecos (), [Decorators::MUT, Decorators::DMUT]);
        let mut useRef = false, mut useAlias = false;

        let vType = if (!vdecl.getType ().isOf!{&EmptyExpression} ()) {
            let (_, t) = context:.validateType (vdecl.getType (), decos-> vdecl.getDecos (), canBeRef-> isRef);
            let vtype = if (isPure) { t.clone (0u32) } else { t };
            context:.verifyCompatibleType (vdecl.getType ().getLoc (), curTupleType.getLoc (), vtype, curTupleType);
            vtype
        } else {
            let (_, t) = context:.validateType (TypeWrapperExpr::new (value.getLoc (), curTupleType), decos-> vdecl.getDecos (), canBeRef-> isRef);
            let vtype = if (isPure) { t.clone (0u32) } else { t };
            vtype
        };

        if (vType.isMutable () && !vType.needExplicitAlias () && !isRef) {
            throw ErrorMsg::fatal (vdecl.getLoc (), ValidateErrorMessage::MUTABLE_CONST_ITERATOR);
        }

        let indexValue = context.getCompileTimeInterpreter ().reduce (context:.getBinOpValidator ().createTupleFieldAccess (vdecl.getLoc (), type.getInners ()[i], value, i));
        let iterValue = context:.verifyCompatibleTypeWithValue (vdecl.getLoc (), vType, indexValue, byReference-> isRef);

        let access = if (byMutRef && isRef && curTupleType.isMutable () && iterValue.isLvalue ()) {
            useRef = true;
            cast!{&Value} (ReferencerValue::new (vdecl.getLoc (), iterValue.getType (), iterValue, isMutable-> true))
        } else if (!isRef && byAlias && curTupleType.isMutable () && vType.needExplicitAlias ()) {
            useAlias = true;
            cast!{&Value} (AliaserValue::new (vdecl.getLoc (), iterValue.getType (), iterValue))
        } else if (isRef && !byMutRef && iterValue.isLvalue ()) {
            cast!{&Value} (ReferencerValue::new (vdecl.getLoc (), iterValue.getType (), iterValue, isMutable-> false))
        } else {
            iterValue
        };

        context:.verifyMemoryOwner (vdecl.getLoc (), vType, access, construct-> true, byReference-> isRef);
        let decl = VarDeclValue::new (vdecl.getLoc (), vType, access, isMutable-> isMutable, isPure-> isPure, isReference-> isRef, isIterator-> true);
        (decl, useRef, useAlias)
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================        LOOP ON ARRAYS        =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a for loop operation on an array value
     * @params:
     *    - context: the context of the validation
     *    - arrType: the type of the value
     *    - value: the value being iterated
     *    - content: the expression to validate
     * @returns: a validate value
     * @throws:
     *     - &ErrorMsg: if the validation failed
     * */
    fn validateArrayLoop (self, dmut context : &Validator, arrType : &ArrayType, value : &Value, content : &ForLoopExpr, byMutRef : bool, byAlias : bool)-> (&Value, bool, bool)
        throws &ErrorMsg
    {
        let vars = content.getVariables ();
        let uniqV = context.createSliceAliasFromArray (content.getLoc (), arrType, value, mutable-> (byMutRef || byAlias) && arrType.isMutable ());
        let slcT = uniqV.getType ().asOf!{&SliceType} ();

        match vars.len {
            1us => // only the value of the array
                return self.validateSliceIteration (alias context, slcT, uniqV, content, vars[0], EmptyExpression::new (), byMutRef, byAlias);
            2us => // The value of the array and the iterator
                return self.validateSliceIteration (alias context, slcT, uniqV, content, vars[0], vars[1], byMutRef, byAlias);
            _ => { // no iteration is possible with three variables
                throw ErrorMsg::fatal (content.getLoc (), format (ValidateErrorMessage::UNDEF_FOR_LOOP_OPERATOR, vars.len, arrType));
            }
        }
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================        LOOP ON SLICES        =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a for loop iterating through a slice value
     * @params: 
     *     - context: the context of the validation
     *     - slcType: the type of the iteration
     *     - value: the value that is iterated
     *     - content: the content of the iteration to validate
     */
    fn validateSliceLoop (self, dmut context : &Validator, slcType : &SliceType, value : &Value, content : &ForLoopExpr, byMutRef : bool, byAlias : bool)-> (&Value, bool, bool)
        throws &ErrorMsg
    {
        let vars = content.getVariables ();
        match vars.len {
            1us => // only the value of the array
                return self.validateSliceIteration (alias context, slcType, value, content, vars[0], EmptyExpression::new (), byMutRef, byAlias);
            2us => // The value of the array and the iterator
                return self.validateSliceIteration (alias context, slcType, value, content, vars[0], vars[1], byMutRef, byAlias);
            _ => { // no iteration is possible with three variables
                throw ErrorMsg::fatal (content.getLoc (), format (ValidateErrorMessage::UNDEF_FOR_LOOP_OPERATOR, vars.len, slcType));
            }
        }
    }

    /**
     * Validate the iteration over the slice
     * @params: 
     *    - context: the context of the validation
     *    - slcType: the type of the slice of the iteration
     *    - value: the value of the slice of the iteration
     *    - content: the for loop containing the ocntent of the iteration
     *    - iter1: the first iteration variable (never empty)
     *    - iter2: the second iteration variable (might be empty)
     * @returns: the value of the iteration
     * @throws:
     *    - &ErrorMsg: if the iteration cannot be validated
     */
    fn validateSliceIteration (self, dmut context : &Validator, slcType : &SliceType, sliceValue : &Value, content : &ForLoopExpr, iter1 : &Expression, iter2 : &Expression, byMutRef : bool, byAlias : bool)-> (&Value, bool, bool)
        throws &ErrorMsg
    {
        let dmut errors = Vec!{&ErrorMsg}::new ();
        let dmut innerValues = Vec!{&Value}::new ();
        let dmut values = Vec!{&Value}::new ();
        let loc = content.getLoc ();
        let mut test : &Value = UNIT_VALUE;
        let mut useRef = false, mut useAlias = false;

        // => for index, value in S
        // ==
        // let array = S;
        // let index = 0;
        // while index < array.len {
        //    let value = array [index];
        //    {  } // content
        //    index += 1;
        // }

        context:.enterBlock ();
        {
            let sliceDecl = VarDeclValue::new (Word::new ("#_value"s8, sliceValue.getLoc ()), slcType, sliceValue, isMutable-> (byMutRef || byAlias) && slcType.isMutable (), isPure-> false);
            let sliceRef = VarRefValue::new (sliceDecl.getLoc (), sliceDecl.getLoc (), slcType, sliceDecl.getUniqId (), isSelf-> false, canCte-> false);
            values:.push (sliceDecl);

            // First we create the iteration variables, that will store the value at the current array index, and the value of the index
            let vars = self.validateSliceIteratorVars (alias context, sliceValue.getLoc (), slcType, sliceRef, iter1, iter2, byMutRef, byAlias);
            let iter = vars._0; // the value of the current index

            values:.push (vars._1); // declare index iterator outside the content of the loop

            useRef = vars._3;
            useAlias = vars._4;

            let one = makeIntValue (loc, 1us); // used to increment the iterator
            let len = StructFieldAccessValue::new (loc, one.getType (), sliceRef, SliceKeys::LEN); // access the size of the array to verify test when to exit the loop

            test = CmpIntOperatorValue::new (loc, BinaryOperators::INF, iter, len); // if the iterator is greater than the value of the array the loop is stopped
            let increment = AffectValue::new (loc, iter.getType (), iter, BinaryMathIntOperatorValue::new (loc, iter.getType (), BinaryOperators::PLUS, iter, one)); // increment the iterator for the next iteration

            // the loop has three steps: value iterator declarations, content, increment
            innerValues:.push (vars._2);
            innerValues:.push (context:.validateValue (content.getBlock ())); // execute the content of the loop
            innerValues:.push (increment);
            // go to the next iteration
        } catch {
            err : &ErrorMsg => { errors:.push (err); } // we catch everything because we need to exit the block
        }
    
        let blkContent = BlockValue::new (loc, VoidType::new (loc), innerValues[]); // create the loop 
        let _loop = LoopValue::new (loc, VoidType::new (loc), test-> test, blkContent, isDo-> false);
        values:.push (_loop);

        {
            context:.quitBlock (warnUnused-> errors.len () == 0us); // we only warn if there was no error in the loop content
        } catch {
            err : &ErrorMsg => errors:.push (err); // some warn unused
        }

        if (errors.len () != 0us) throw ErrorMsg::list (errors[]);
        (BlockValue::new (loc, VoidType::new (loc), values[]), useRef, useAlias)
    }

    /**
     * Create the iteration variable (and verify that they are correctly defined)
     * @params: 
     *    - context: the context of the validaiton
     *    - loc: the location of the value iterated
     *    - slcType: the type of the iteration
     *    - iter1: the iterator (value if iter2 is empty, index otherwise)
     *    - iter2: value if not empty
     * @returns:
     *    - .0: the ref to the index variable (even if iter2 is empty)
     *    - .1: the vardecl of the index variable (even if iter1 is empty)
     *    - .2: the vardecl of the value variable
     * @throws:
     *    - &ErrorMsg: if the variables are uncorrectly defined
     */
    fn validateSliceIteratorVars (self, dmut context : &Validator, loc : &Word, slcType : &SliceType, sliceRef : &Value, iter1 : &Expression, iter2 : &Expression, byMutRef : bool, byAlias : bool)-> (&Value, &Value, &Value, bool, bool)
        throws &ErrorMsg
    {
        // This function can seem a bit complex but isn't
        match (iter1, iter2) { // we have two cases, (with one variable, or with two)            
            (v : &VarDeclExpr, EmptyExpression ()) => { // 1. with one
                // And the variable for the iterator, with an name that cannot be taken elsewhere, but this is not important
                let iter = VarDeclValue::new (Word::new ("#_iter"s8, v.getLoc ()), IntType::new (v.getLoc (), size-> 0u16, signed-> false), makeIntValue (v.getLoc (), 0us), isMutable-> false, isPure-> false);
                let vrefIter = VarRefValue::new (iter.getLoc (), iter.getLoc (), iter.getVarType (), iter.getUniqId (), isSelf-> false, canCte-> false);

                let (array, useRef, useAlias) = self.validateSliceIterDecl (alias context, v, slcType, sliceRef, vrefIter, byMutRef, byAlias);
                if (v.getLoc () != Keys::UNDER) context:.insertLocal (v.getLoc ().str (), array); // The variable must be retreivable, so we insert it inside the context, (but not the iterator that is hidden)

                return (vrefIter, iter, array, useRef, useAlias); // we return the variable for the loop validation
            }
            (i : &VarDeclExpr, v : &VarDeclExpr) => {
                let iter = self.validateIndexIterDecl (alias context, loc, i, IntType::new (i.getLoc (), size-> 0u16, signed-> false), value-> makeIntValue (i.getLoc (), 0us), slcType, canCte-> false);
                let vrefIter = VarRefValue::new (iter.getLoc (), iter.getLoc (), iter.getVarType (), iter.getUniqId (), isSelf-> false, canCte-> false);

                let (array, useRef, useAlias) = self.validateSliceIterDecl (alias context, v, slcType, sliceRef, vrefIter, byMutRef, byAlias);

                if (v.getLoc () != Keys::UNDER) context:.insertLocal (v.getLoc ().str (), array); // insert them, so we can retreive them
                if (i.getLoc () != Keys::UNDER) context:.insertLocal (i.getLoc ().str (), iter);

                return (vrefIter, iter, array, useRef, useAlias); // and we return them for the loop valiation
            }
            _ => __pragma!panic (); // panic if we get something else
        }
    }

    /**
     * Validate the iterator variable of a slice iteration
     * @params:
     *    - context: the context of the validation
     *    - vdecl: the iterator variable declaration
     *    - type: the type of the slice
     *    - value: the value being iterated
     *    - index: the variable reference to the index value
     *    - byMutRef: true if the value is passed by mutable reference
     *    - byAlias: true if the value was aliased
     * */
    fn validateSliceIterDecl (self, dmut context : &Validator, vdecl : &VarDeclExpr, type : &SliceType, sliceValue : &Value, index : &Value, byMutRef : bool, byAlias : bool)-> (&Value, bool, bool)
        throws &ErrorMsg
    {
        let innerType = type.getInners ()[0];
        let isPure = context.findDecos (vdecl.getDecos (), [Decorators::PURE]);
        let isRef = context.findDecos (vdecl.getDecos (), [Decorators::REF]);
        let isMutable = context.findDecos (vdecl.getDecos (), [Decorators::MUT, Decorators::DMUT]);

        let mut useRef = false, mut useAlias = false;

        let vType = if (!vdecl.getType ().isOf!{&EmptyExpression} ()) {
            let (_, t) = context:.validateType (vdecl.getType (), decos-> vdecl.getDecos (), canBeRef-> isRef);
            let vtype = if (isPure) { t.clone (0u32) } else { t };
            context:.verifyCompatibleType (vdecl.getType ().getLoc (), innerType.getLoc (), vtype, innerType);
            vtype
        } else {
            let (_, t) = context:.validateType (TypeWrapperExpr::new (sliceValue.getLoc (), innerType), decos-> vdecl.getDecos (), canBeRef-> isRef);
            let vtype = if (isPure) { t.clone (0u32) } else { t };
            vtype
        };

        if (vType.isMutable () && !vType.needExplicitAlias () && !isRef) {
            throw ErrorMsg::fatal (vdecl.getLoc (), ValidateErrorMessage::MUTABLE_CONST_ITERATOR);
        }

        let reducedValue = context.getCompileTimeInterpreter ().reduce (SliceAccessValue::new (sliceValue.getLoc (), innerType, sliceValue, index));
        let iterValue = context:.verifyCompatibleTypeWithValue (vdecl.getLoc (), vType, reducedValue, byReference-> isRef);

        let access = if (byMutRef && isRef && innerType.isMutable () && iterValue.isLvalue ()) {
            useRef = true;
            cast!{&Value} (ReferencerValue::new (vdecl.getLoc (), iterValue.getType (), iterValue, isMutable-> true))
        } else if (!isRef && byAlias && innerType.isMutable () && vType.needExplicitAlias ()) {
            useAlias = true;
            cast!{&Value} (AliaserValue::new (vdecl.getLoc (), iterValue.getType (), iterValue))
        } else if (isRef && !byMutRef && iterValue.isLvalue ()) {
            cast!{&Value} (ReferencerValue::new (vdecl.getLoc (), iterValue.getType (), iterValue, isMutable-> false))
        } else {
            iterValue
        };

        context:.verifyMemoryOwner (vdecl.getLoc (), vType, access, construct-> true, byReference-> isRef);
        let decl = VarDeclValue::new (vdecl.getLoc (), vType, access, isMutable-> isMutable, isPure-> isPure, isReference-> isRef, isIterator-> true);
        (decl, useRef, useAlias)
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================        LOOP ON RANGES        =========================
     * ================================================================================
     * ================================================================================
     */


    /**
     * Validate a for loop on a range value
     * @params: 
     *    - context: the context of the validation
     *    - rngType: the type of the range 
     *    - value: the value to iterate
     *    - f: the for loop to validate
     * @returns: the validated loop
     * @throws:
     *    - &ErrorMsg: if the validation fails
     */
    fn validateRangeLoop (self, dmut context : &Validator, rngType : &RangeType, value : &Value, f : &ForLoopExpr)-> &Value
        throws &ErrorMsg
    {        
        let vars = f.getVariables ();

        // We can iterate over range with only one variable
        if (vars.len != 1us) throw ErrorMsg::fatal (f.getLoc (), format (ValidateErrorMessage::UNDEF_FOR_LOOP_OPERATOR, vars.len, rngType));

        let loc = f.getLoc ();
        let dmut values = Vec!{&Value}::new ();
        let interpret = context.getCompileTimeInterpreter ();

        let fst  = interpret.reduce (StructFieldAccessValue::new (loc, rngType.getInners ()[0], value, RangeKeys::FST));
        let scd  = interpret.reduce (StructFieldAccessValue::new (loc, rngType.getInners ()[0], value, RangeKeys::SCD));
        let step = interpret.reduce (StructFieldAccessValue::new (loc, rngType.getInners ()[1], value, RangeKeys::STEP))
        let contains = interpret.reduce (StructFieldAccessValue::new (loc, BoolType::new (loc), value, RangeKeys::CONTAIN));

        let iterDecl = VarDeclValue::new (Word::new ("#_iter"s8, loc), IntType::new (loc, signed-> false, size-> 0u16), makeIntValue (loc, 0us), isMutable-> true, isPure-> false);
        let mut iterRef = VarRefValue::new (iterDecl.getLoc (), loc, iterDecl.getVarType (), iterDecl.getUniqId (), isSelf-> false, canCte-> false);
        values:.push (iterDecl);

        let nbIterRef = if (!interpret.isCte (fst) || !interpret.isCte (scd) || !interpret.isCte (step) || !interpret.isCte (contains)) {
            let nbIteration = self.validateComputeNbIterations (loc, alias context, fst, scd, step, contains);
            let nbIterDecl = VarDeclValue::new (Word::new ("#_nb_iter"s8, loc), IntType::new (loc, signed-> false, size-> 0u16), nbIteration, isMutable-> true, isPure-> false);
            let mut nbIterRef = VarRefValue::new (nbIterDecl.getLoc (), loc, nbIterDecl.getVarType (), nbIterDecl.getUniqId (), isSelf-> false, canCte-> false);

            values:.push (nbIterDecl);
            nbIterRef
        } else {
            context:.getCompileTimeInterpreter ().reduce (self.validateComputeNbIterations (loc, alias context, fst, scd, step, contains))
        }

        let _loop = self.validateRangeInnerLoop (alias context, rngType, f, iterRef, nbIterRef, fst, step);

        values:.push (_loop); // push the loop after the declaration of the iterator variable
        BlockValue::new (loc, VoidType::new (loc), values[])
    }

    /**
     * Validate the inner part of the range loop
     * @returns: the loop
     * */
    fn validateRangeInnerLoop (self, dmut context : &Validator, rngType : &RangeType, f : &ForLoopExpr, iterRef : &Value, nbIterRef : &Value, fst : &Value, step : &Value)-> &Value
        throws &ErrorMsg
    {
        let loc = f.getLoc ();
        let dmut errors = Vec!{&ErrorMsg}::new ();
        let dmut values = Vec!{&Value}::new ();

        context:.enterLoop ();
        context:.setCurrentLoopType (VoidType::new (f.getLoc ()));
        context:.enterBlock ();
        let test = {
            let (varRef, varDecl) = self.validateRangeIteratorVar (alias context, loc, rngType, f.getVariables ()[0]);
            let (increment, setIndex, _test) = self.validateRangeIteratorIncrement (alias context, loc, iterRef, nbIterRef, varRef, fst, step);
            if (varRef.getLoc () != Keys::UNDER) {
                values:.push (varDecl); // push the var decl before the loop
                values:.push (setIndex);
            }

            values:.push (context:.validateValue (f.getBlock ())); // the loop content
            values:.push (increment); // the loop increment
            _test
        } catch {
            err : &ErrorMsg => {
                errors:.push (err);
                cast!{&Value} (UNIT_VALUE)
            }
        }

        {
            context:.quitLoop ();
            context:.quitBlock (warnUnused-> errors.len () == 0us);
        } catch {
            err : &ErrorMsg => errors:.push (err); // Some warn unused
        }

        if (errors.len () != 0us) throw ErrorMsg::list (errors[]);
        let blkContent = BlockValue::new (loc, VoidType::new (loc), values[]);

        LoopValue::new (loc, VoidType::new (loc), test-> test, blkContent, isDo-> false)
    }


    /**
     * Validate the iterator variable
     * @params: 
     *    - context: the context of the validation
     *    - rngType: the type of the range value
     *    - iterDecl: the declaration of the iterator
     *    - rngValue: the value of the range
     * @returns:
     *    - .0: true iif cannot use only compile time values
     *    - .1: the variable declaration
     *    - .2: the variable ref value
     * @throws:
     *    - &ErrorMsg: if the validation fails
     */
    fn validateRangeIteratorVar (self, dmut context : &Validator, loc : &Word, rngType : &RangeType, iterDecl : &Expression)-> (&Value, &Value)
        throws &ErrorMsg
    {
        match iterDecl {
            v : &VarDeclExpr => {
                // We create the variable for the iterator
                let iterType = rngType.getInners ()[0].clone (0u32);
                let iterValue = self.validateIndexIterDecl (alias context, loc, v, iterType, rngType, canCte-> false);
                if (v.getLoc () != Keys::UNDER) context:.insertLocal (v.getLoc ().str (), iterValue);

                // And the variable ref so we can use it
                let vRefIter = VarRefValue::new (v.getLoc (), iterValue.getLoc (), iterType, iterValue.getUniqId (), isSelf-> false, canCte-> false);
                return (vRefIter, iterValue);
            }
            _ => __pragma!panic ();
        }
    }

    /**
     * * Validate the increment of the iterator during an iteration on a range value of integers
     * @params:
     *    - context: the context of the validation
     *    - iterRef: the validation containing the iterator
     *    - nbIter: the number of iteration
     *    - indexRef: the number of iteration
     * @returns:
     *    - .0: the increment value
     *    - .1: the affectation of index
     *    - .2: the test for the loop
     * */
    fn validateRangeIteratorIncrement (self, dmut context : &Validator, loc : &Word, iterRef : &Value, nbIter : &Value, indexRef : &Value, fst : &Value, step : &Value)-> (&Value, &Value, &Value)
        throws &ErrorMsg
    {
        let test = CmpIntOperatorValue::new (loc, BinaryOperators::INF, iterRef, nbIter);
        let increment = AffectValue::new (loc, iterRef.getType (), iterRef, BinaryMathIntOperatorValue::new (loc, iterRef.getType (), BinaryOperators::PLUS, iterRef, makeIntValue (loc, 1us)));

        let indexMul = BinaryMathIntOperatorValue::new (loc, iterRef.getType (), BinaryOperators::STAR, iterRef, CastValue::new (loc, iterRef.getType (), step));
        let currIndex = BinaryMathIntOperatorValue::new (loc, indexRef.getType (), // i = fst + #_iter * step
                                                         BinaryOperators::PLUS, fst,
                                                         CastValue::new (loc, indexRef.getType (), indexMul));
        let affectIndex = AffectValue::new (loc, indexRef.getType (), indexRef, context.getCompileTimeInterpreter ().reduce (currIndex));

        (increment, affectIndex, test)
    }

    /**
     * Compute the number of iterations of a for loop
     * */
    fn validateComputeNbIterations (self, loc : &Word, dmut context : &Validator, fst : &Value, scd : &Value, step : &Value, contains : &Value)-> &Value
        throws &ErrorMsg
    {
        let sizeType = IntType::new (loc, size-> 0u16, signed-> false);
        let max = context.getCompileTimeInterpreter ().createIntMaxValue (sizeType);

        match (fst, scd, step, contains) {
            (fstI : &IntValue, scdI : &IntValue, stepI : &IntValue, containsB : &BoolValue) =>
            {
                return IntValue::new (loc, sizeType, self.validateCteComputeNbIterations (fstI.getValue (), scdI.getValue (), stepI.getValue (), max, containsB.isTrue ()));
            }
            _ => {
                let val = if (step.isOf!{&IntValue} () && contains.isOf!{&BoolValue} ()) {
                    // Almost cte, we can infer some things as step and contains are known
                    self.validateAlmostCteComputeNbIterations (loc, fst, scd, step.asOf!{&IntValue} ().getValue (), max, contains.asOf!{&BoolValue} ().isTrue ())
                } else {
                    self.validateNonCteComputeNbIterations (loc, fst, scd, step, max, contains)
                };

                return context.getCompileTimeInterpreter ().reduce (val);
            }
        }
    }

    /**
     * Cte version of fun to compute the number of iterations of a range
     * @params:
     *     - fst: the cte fst value of the range
     *     - scd: the cte scd value of the range
     *     - step: the cte step value of the range
     *     - max: the maximal int value reprensentable in the target language
     *     - contains: the cte contains value of the range
     * @returns: the number of iterations of the range
     * */
    fn validateCteComputeNbIterations (self, fst : &BigInt, scd : &BigInt, step : &BigInt, max : &BigInt, contains : bool)-> &BigInt {
        let stepU = if (step < 0) { 0 - step } else { step };
        if (stepU == 0) return BigInt::new (0);

        let (fstU, scdU, subU) = if (fst > scd) {
            (scd, fst, fst - scd)
        } else {
            (fst, scd, scd - fst)
        };

        let nbAll = subU / stepU;

        if (nbAll == max) return nbAll;
        if (contains) return nbAll + 1us;

        // recompute, because is it not necessarily == scd since the division might trunc the value
        let last = (nbAll * stepU) + fstU;
        if (last != scdU) return nbAll + 1us;

        nbAll
    } catch {
        _ => __pragma!panic (); // stepU == 0
    }

    /**
     * Almost cte version of the function used to compute the number of iteration in a range
     * Almost because fst and scd are not cte, but step and contains are (it can happen a lot actually, ex: for i in 0 .. a.len, with a : [T])
     * @params:
     *     - fst: the fst value of the range
     *     - scd: the scd value of the range
     *     - step: the cte step value of the range
     *     - max: the maximal int value reprensentable in the target language
     *     - contains: the cte contains value of the range
     * @returns: an expression used to compute the number of iteration in the range
     * */
    fn validateAlmostCteComputeNbIterations (self, loc : &Word, fst : &Value, scd : &Value, step : &BigInt, max : &BigInt, contains : bool)-> &Value {
        let stepU = if (step < 0) { 0 - step } else { step };
        if (stepU == 0) return makeIntValue (0us);

        let rngType = fst.getType ().asOf!{&IntType} ();
        let (fstU, scdU, mut subU) = if (step < 0) {
            (scd, fst, BinaryMathIntOperatorValue::new (loc, rngType, BinaryOperators::MINUS, fst, scd))
        } else {
            (fst, scd, BinaryMathIntOperatorValue::new (loc, rngType, BinaryOperators::MINUS, scd, fst))
        };

        let stepI = IntValue::new (loc, rngType, stepU);
        let maxI = IntValue::new (loc, rngType, max);
        let nbAll = BinaryMathIntOperatorValue::new (loc, rngType, BinaryOperators::DIV, subU, stepI);
        let nbAllP1 = BinaryMathIntOperatorValue::new (loc, rngType, BinaryOperators::PLUS, nbAll, IntValue::new (loc, rngType, 1us));

        if (contains) {
            let cmp = CmpIntOperatorValue::new (loc, BinaryOperators::DEQUAL, nbAll, maxI);
            return ConditionalValue::new (loc, rngType, cmp, nbAll, nbAllP1); // if contains { return if (nbAll == max) { nbAll } else { nbAll + 1 } }
        }

        let mulNbAll = BinaryMathIntOperatorValue::new (loc, rngType, BinaryOperators::STAR, nbAll, stepI);
        let last = BinaryMathIntOperatorValue::new (loc, rngType, BinaryOperators::PLUS, mulNbAll, fstU);

        let cmp = CmpIntOperatorValue::new (loc, BinaryOperators::NOT_EQUAL, last, scdU);
        return ConditionalValue::new (loc, rngType, cmp, nbAllP1, nbAll); // return if (last == scdU) { nbAll } else { nbAll + 1 };
    }


    /**
     * Completely non cte version of the function used to compute the number of iteration in a range
     * * @params:
     *     - fst: the fst value of the range
     *     - scd: the scd value of the range
     *     - step: the step value of the range
     *     - max: the maximal int value reprensentable in the target language
     *     - contains: the contains value of the range
     * @returns: an expression used to compute the number of iteration in the range
     * */
    fn validateNonCteComputeNbIterations (self, loc : &Word, fstV : &Value, scdV : &Value, stepV : &Value, max : &BigInt, contains : &Value)-> &Value {
        let dmut lst = Vec!{&Value}::new ();

        let rngTuType = TupleType::new (loc, [fstV.getType (), scdV.getType (), stepV.getType ()]);
        let vdecl = VarDeclValue::new (Word::new ("#_range"s8, loc), rngTuType, TupleValue::new (loc, rngTuType, [fstV, scdV, stepV]), isMutable-> false, isPure-> false);
        let vref = VarRefValue::new (vdecl.getLoc (), loc, rngTuType, vdecl.getUniqId (), isSelf-> false, canCte-> true);

        lst:.push (vdecl);

        let fst = TupleFieldAccessValue::new (loc, rngTuType.getInners ()[0], vref, 0us);
        let scd = TupleFieldAccessValue::new (loc, rngTuType.getInners ()[1], vref, 1us);
        let step = TupleFieldAccessValue::new (loc, rngTuType.getInners ()[2], vref, 2us);

        let rngType = fst.getType ().asOf!{&IntType} ();
        let stepCmp = CmpIntOperatorValue::new (loc, BinaryOperators::INF, step, IntValue::new (loc, step.getType ().asOf!{&IntType} (), 0us));

        let tuType = TupleType::new (loc, [rngType, rngType, rngType, rngType]);
        let valNeg = TupleValue::new (loc, tuType, [UnaryIntOperatorValue::new (loc, step.getType ().asOf!{&IntType} (), UnaryOperators::MINUS, step), scd, fst, BinaryMathIntOperatorValue::new (loc, rngType, BinaryOperators::MINUS, fst, scd)]);
        let valPos = TupleValue::new (loc, tuType, [step, fst, scd, BinaryMathIntOperatorValue::new (loc, rngType, BinaryOperators::MINUS, scd, fst)]);

        let valDecl = VarDeclValue::new (Word::new ("#_val"s8, loc), tuType, ConditionalValue::new (loc, tuType, stepCmp, valNeg, valPos), isMutable-> false, isPure-> false);
        let val = VarRefValue::new (valDecl.getLoc (), loc, tuType, valDecl.getUniqId (), isSelf-> false, canCte-> true);
        lst:.push (valDecl);

        let maxI = IntValue::new (loc, rngType, max);
        let stepU = TupleFieldAccessValue::new (loc, rngType, val, 0us);
        let fstU = TupleFieldAccessValue::new (loc, rngType, val, 1us);
        let scdU = TupleFieldAccessValue::new (loc, rngType, val, 2us);
        let subU = TupleFieldAccessValue::new (loc, rngType, val, 3us);

        let nbAllDecl = VarDeclValue::new (Word::new ("#_nbAll"s8, loc), rngType, BinaryMathIntOperatorValue::new (loc, rngType, BinaryOperators::DIV, subU, stepU), isMutable-> false, isPure-> false);
        let nbAll = VarRefValue::new (nbAllDecl.getLoc (), loc, rngType, nbAllDecl.getUniqId (), isSelf-> false, canCte-> true);
        lst:.push (nbAllDecl);

        let valIfNoMax = {
            let mulNbAll = BinaryMathIntOperatorValue::new (loc, rngType, BinaryOperators::STAR, nbAll, stepU);
            let last = BinaryMathIntOperatorValue::new (loc, rngType, BinaryOperators::PLUS, mulNbAll, fstU);

            let nbAllP1 = BinaryMathIntOperatorValue::new (loc, rngType, BinaryOperators::PLUS, nbAll, IntValue::new (loc, rngType, 1us));
            let cmp = LogicalBinBoolOperatorValue::new (loc, BinaryOperators::DPIPE, CmpIntOperatorValue::new (loc, BinaryOperators::NOT_EQUAL, last, scdU), contains);
            ConditionalValue::new (loc, rngType, cmp, nbAllP1, nbAll)
        };

        // if (nbAll == max) { nbAll } else { let last = (nbAll * stepU) + fstU; if (last != scdU || contains) { nbAll + 1 } else { nbAll } };
        let cmp = CmpIntOperatorValue::new (loc, BinaryOperators::DEQUAL, nbAll, maxI);
        let cnd = ConditionalValue::new (loc, rngType, cmp, nbAll, valIfNoMax);
        lst:.push (cnd);

        return BlockValue::new (loc, rngType, lst[]);
    }


    /**
     * ================================================================================
     * ================================================================================
     * ========================        COMPREHENSION SLICE        =====================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a list comprehension from a slice value
     * @params:
     *   - context: the context of the validation
     *   - slc: the slice type being iterated
     *   - iter: the value being iterated
     *   - all: the list comprehension to validate
     *   - canDynamic: if true then a slice is created, thus the size can be unknown at cte
     * @returns: the generated slice/array
     * @throws:
     *   - &ErrorMsg: if the validation failes
     * */
    fn validateComprSlice (self, dmut context : &Validator, slc : &SliceType, iter : &Value, all : &SliceForAllocatorExpr, canDynamic : bool)-> &Value
        throws &ErrorMsg
    {
        context;
        slc;
        iter;
        all;
        canDynamic;
        __pragma!fake_throw (&ErrorMsg);
        __pragma!panic ();
    }

    /**
     * ================================================================================
     * ================================================================================
     * ========================        COMPREHENSION TUPLE        =====================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a list comprehension from a tuple value
     * @params:
     *   - context: the context of the validation
     *   - tu: the tuple type being iterated
     *   - iter: the value being iterated
     *   - all: the list comprehension to validate
     *   - canDynamic: if true then a slice is created, thus the size can be unknown at cte
     * @returns: the generated slice/array
     * @throws:
     *   - &ErrorMsg: if the validation failes
     * */
    fn validateComprTuple (self, dmut context : &Validator, tu : &TupleType, iter : &Value, all : &SliceForAllocatorExpr, canDynamic : bool)-> &Value
        throws &ErrorMsg
    {
        context;
        tu;
        iter;
        all;
        canDynamic;
        __pragma!fake_throw (&ErrorMsg);
        __pragma!panic ();
    }



    /**
     * ================================================================================
     * ================================================================================
     * ========================        COMPREHENSION RANGE        =====================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a list comprehension from a range value
     * @params:
     *   - context: the context of the validation
     *   - ra: the range type being iterated
     *   - iter: the value being iterated
     *   - all: the list comprehension to validate
     *   - canDynamic: if true then a slice is created, thus the size can be unknown at cte
     * @returns: the generated slice/array
     * @throws:
     *   - &ErrorMsg: if the validation failes
     * */
    fn validateComprRange (self, dmut context : &Validator, ra : &RangeType, iter : &Value, all : &SliceForAllocatorExpr, canDynamic : bool)-> &Value
        throws &ErrorMsg
    {
        context;
        ra;
        iter;
        all;
        canDynamic;
        __pragma!fake_throw (&ErrorMsg);
        __pragma!panic ();
    }

    /**
     * ================================================================================
     * ================================================================================
     * =============================        CTE RANGE        ==========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a cte for loop operation on an range value
     * @params:
     *    - context: the context of the validation
     *    - rngType: the type of the value
     *    - value: the value being iterated
     *    - content: the expression to validate
     * @returns: a validate value
     * @throws:
     *     - &ErrorMsg: if the validation failed
     * */
    fn validateCteRangeLoop (self, dmut context : &Validator, rngType : &RangeType, value : &Value, f : &ForLoopExpr)-> &Value
        throws &ErrorMsg
    {
        let vars = f.getVariables ();
        if (vars.len != 1us) throw ErrorMsg::fatal (f.getLoc (), format (ValidateErrorMessage::UNDEF_CTE_FOR_LOOP_OPERATOR, vars.len, rngType));

        let dmut errors = Vec!{&ErrorMsg}::new ();
        let dmut innerValues = Vec!{&Value}::new ();
        let loc = f.getLoc ();

        context:.enterBlock ();
        {
            let start = context:.getCompileTimeInterpreter ().computeInt (StructFieldAccessValue::new (loc, rngType.getInners ()[0], value, RangeKeys::FST));
            let step = context:.getCompileTimeInterpreter ().computeInt (StructFieldAccessValue::new (loc, rngType.getInners ()[1], value, RangeKeys::STEP));
            let contains = context:.getCompileTimeInterpreter ().computeBool (StructFieldAccessValue::new (loc, BoolType::new (loc), value, RangeKeys::CONTAIN));
            let end = context:.getCompileTimeInterpreter ().computeInt (StructFieldAccessValue::new (loc, rngType.getInners ()[0], value, RangeKeys::SCD));

            let sizeType = IntType::new (loc, size-> 0u16, signed-> false);
            let max = context.getCompileTimeInterpreter ().createIntMaxValue (sizeType);
            let nbIterations = self.validateCteComputeNbIterations (start, end, step, max, contains);

            if (nbIterations > global::state::instance ().getMaxCteLoopIter ()) {
                throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::MAX_LOOP_ITERATIONS, nbIterations, global::state::instance ().getMaxCteLoopIter ()));
            }

            let mut index = BigInt::new (0us);
            while (index < nbIterations) {
                let current = IntValue::new (loc, rngType.getInners ()[0].asOf!{&IntType} (), index * step + start);

                let block = self.createCurrentCteBlock (alias context, f.getBlock (), rngType, vars, [current]);
                innerValues:.push (context:.validateValue (block));
                index += 1;
            }
        } catch {
            err : &ErrorMsg => { errors:.push (err); }
        }

        {
            context:.quitBlock (warnUnused-> errors.len () == 0us);
        } catch {
            err : &ErrorMsg => errors:.push (err); // Some warn unused
        }

        if (errors.len () != 0us) throw ErrorMsg::list (errors[]);
        BlockValue::new (loc, VoidType::new (loc), innerValues[])
    }


    /**
     * ================================================================================
     * ================================================================================
     * =============================        COMMON        =============================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a variable decl from iteration variable
     * @params:
     *     - context: the context of the validation
     *     - loc: the location of the iteration
     *     - vdecl: the variable being declared
     *     - type: the expected type of the resutl value
     *     - globType: the type being iterated
     *     - withDeco: true if the variable can have decorators
     * @returns: a vardecl value
     * */
    fn validateIndexIterDecl (self, dmut context : &Validator, loc : &Word, vdecl : &VarDeclExpr, type : &Type, value : &Value = UNIT_VALUE, globType : &Type, canCte : bool = true)-> &VarDeclValue
        throws &ErrorMsg
    {
        if (context.findDecos (vdecl.getDecos (), Decorators::__members__)) {
            throw ErrorMsg::fatal (vdecl.getDecos ()[0].loc, end-> loc, format (ValidateErrorMessage::FORBID_DECO_FOR_LOOP, globType));
        }

        let vType = if (!vdecl.getType ().isOf!{&EmptyExpression} ()) {
            let vtype = context:.validateType (vdecl.getType (), decos-> [], canBeRef-> false)._1;
            context:.verifyCompatibleType (vdecl.getType ().getLoc (), loc, vtype, type);
            vtype
        } else {
            let (_, t) = context:.validateType (TypeWrapperExpr::new (value.getLoc (), type), decos-> [], canBeRef-> false);
            t
        }

        if (vdecl.getLoc () != Keys::UNDER) context:.verifyShadow (vdecl.getLoc ());
        VarDeclValue::new (vdecl.getLoc (), vType, value, isMutable-> false, isPure-> false, isCte-> canCte)
    }

    /**
     * Create the block of a for loop that has to be validated at cte time
     * @params:
     *    - context: the context of the validation
     *    - block: the block template
     *    - globType: the type being iterated
     *    - vars: the list of variables used to iterate (assuming its len is equal to the len of values)
     *    - values: the list of values to assign to vars
     * @returns: an expression
     * */
    fn createCurrentCteBlock (self, dmut context : &Validator, block : &Expression, globType : &Type, vars : [&Expression], values : [&Value])-> &Expression
        throws &ErrorMsg
    {
        let dmut mapper = TemplateMapper::new ();
        for i in 0us .. vars.len match vars [i] {
            v : &VarDeclExpr => {
                if (context.findDecos (v.getDecos (), Decorators::__members__)) {
                    throw ErrorMsg::fatal (v.getLoc (), format (ValidateErrorMessage::FORBID_DECO_FOR_LOOP, globType));
                }

                if (!v.getType ().isOf!{&EmptyExpression} ()) {
                    let vtype = context:.validateType (v.getType (), decos-> v.getDecos (), canBeRef-> false)._1;
                    context:.verifyCompatibleType (v.getType ().getLoc (), values [i].getLoc (), vtype, values [i].getType ());
                }

                mapper:.insert (v.getLoc ().str (), ValueWrapperExpr::new (values [i].getLoc (), values [i]));
            }
            _ => __pragma!panic ();
        }

        // We directly rewrite without using the template declarator
        // Template declarator is mandatory for complex template mapper, but here we only have value wrapper
        // There is no lambda or inlining to perform, thus there is no need for complexity
        let rewriter = TemplateRewriter::new (mapper);
        rewriter.rewrite (block)
    }


}
