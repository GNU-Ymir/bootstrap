mod ymirc::semantic::validator::operator::forloop;

import std::io;

import ymirc::semantic::validator::visitor;
import ymirc::semantic::validator::errors;
import ymirc::errors::_;
import ymirc::utils::format;
import ymirc::semantic::generator::value::base;
import ymirc::syntax::expression::for_;

import ymirc::semantic::generator::type::_;

/**
 * The For loop validator is used to validate ForLoopExpr
 * It is a class validator because for loop operations are complex
 */
pub class ForLoopValidator {

    /**
     * Create an empty validator     
     */
    pub self () {}

    /**
     * Validate a for loop expression
     * @params: 
     *  - context: the context of the validation
     *  - f: the for loop to validate
     * @returns: a value
     * @throws: &ErrorMsg, if the validation failed
     */
    pub def validate (self, dmut context : &Validator, f : &ForLoopExpr) -> &Value
        throws &ErrorMsg
    {
        let value = context:.validateValue (f.getValue ());
        match value.getType () {
            t : &TupleType => { self.validateTupleLoop (alias context, t, value) }
            _ => __pragma!panic ();
        }
    }


    /**
     * ================================================================================
     * ================================================================================
     * =========================        LOOP ON TUPLES        =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a for loop on a tuple
     * @params: 
     *    - context: the context of the validation
     *    - type: the type of the tuple
     *    - value: the value to iterate
     * @throws: 
     *    - &ErrorMsg: if the validation failed
     * @returns: the validated loop
     */
    def validateTupleLoop (self, dmut context : &Validator, type : &TupleType, value : &Value)-> &Value
        throws &ErrorMsg
    {
        context;
        type;
        value;
        __pragma!fake_throw (&ErrorMsg);
        __pragma!panic ();
    }
    
}
