mod ymirc::semantic::validator::operator::forloop;

import std::io;
import std::collection::vec;

import ymirc::semantic::validator::visitor;
import ymirc::semantic::validator::errors;
import ymirc::errors::_;
import ymirc::utils::format;
import ymirc::semantic::generator::value::_;
import ymirc::syntax::expression::_;
import ymirc::syntax::keys;


import ymirc::semantic::generator::type::_;

/**
 * The For loop validator is used to validate ForLoopExpr
 * It is a class validator because for loop operations are complex
 */
pub class ForLoopValidator {

    /**
     * Create an empty validator     
     */
    pub self () {}

    /**
     * Validate a for loop expression
     * @params: 
     *  - context: the context of the validation
     *  - f: the for loop to validate
     * @returns: a value
     * @throws: &ErrorMsg, if the validation failed
     */
    pub def validate (self, dmut context : &Validator, f : &ForLoopExpr) -> &Value
        throws &ErrorMsg
    {
        let value = context:.validateValue (f.getValue ());
        match value.getType () {
            t : &TupleType => { self.validateTupleLoop (alias context, t, value, f) }
            _ => __pragma!panic ();
        }
    }


    /**
     * ================================================================================
     * ================================================================================
     * =========================        LOOP ON TUPLES        =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a for loop on a tuple
     * @params: 
     *    - context: the context of the validation
     *    - type: the type of the tuple
     *    - value: the value to iterate
     *    - f: the for loop to validate
     * @throws: 
     *    - &ErrorMsg: if the validation failed
     * @returns: the validated loop
     */
    def validateTupleLoop (self, dmut context : &Validator, type : &TupleType, value : &Value, f : &ForLoopExpr)-> &Value
        throws &ErrorMsg
    {
        let vars = f.getVariables ();
        // we van iterate on tuple with only one variable
        if (vars.len != 1us) throw ErrorMsg::fatal (f.getLoc (), format (ValidateErrorMessage::UNDEF_FOR_LOOP_OPERATOR, vars.len, type));
        
        match vars[0] {
            vdecl : &VarDeclExpr => {
                if (context.findDecos (vdecl.getDecos (), Decorators::__members__)) {
                    throw ErrorMsg::fatal (vdecl.getLoc (), format (ValidateErrorMessage::FORBID_DECO_FOR_LOOP_TUPLE, type));
                }

                let dmut content = Vec!{&Value}::new ();
                context:.enterLoop (); // Even if it is unwinded at compile time, it should behave like a loop (so we can break in it)
                context:.setCurrentLoopType (VoidType::new (f.getLoc ())); // it has no type, (because there is no else part for the moment ?, in theory it is no necessary if we check that there is at least one value in the tuple?)
                {
                    for i in 0us .. type.getInners ().len { // we validate the content of the loop for each type of the tuple
                        content:.push (self.validateTupleInnerLoop (alias context, i, vdecl, type, value, f.getBlock ()));
                    }
                } catch {
                    err : &ErrorMsg => {
                        context:.quitLoop (); // we must not forget to quit the loop 
                        throw err;
                    }
                }
                
                context:.quitLoop ();
                let inner = BlockValue::new (f.getLoc (), VoidType::new (f.getLoc ()), content[]);
                LoopValue::new (f.getLoc (), VoidType::new (f.getLoc ()), NONE_VALUE, inner, false, isCteFor-> true)
            }
            _ =>
                __pragma!panic ();
        }        
    }

    /**
     * Validate the inner content of a loop iteration over a tuple value
     * @params: 
     *     - context: the context of the validation
     *     - i: the index of the current iteration 
     *     - vdecl: the variable iterator to declare
     *     - type: the type of the tuple to iterate
     *     - value: the content of the tuple value
     *     - blk: the content of the for loop
     * @returns: the content of the for loop validated for th i-th iteration
     * @throws:
     *    - &ErrorMsg: if the validation failed
     */
    def validateTupleInnerLoop (self, dmut context : &Validator, i : usize, vdecl : &VarDeclExpr, type : &TupleType, value : &Value, blk : &Expression)-> &Value
        throws &ErrorMsg
    {
        let dmut errors = Vec!{&ErrorMsg}::new ();        
        context:.enterBlock ();
        let res = {
            let var = VarDeclValue::new (vdecl.getLoc (), type.getInners ()[i], TupleFieldAccessValue::new (vdecl.getLoc (), type.getInners ()[i], value, i), false, false);
            context:.insertLocal (vdecl.getLoc ().str (), var);

            let content = context:.validateValue (blk);
            BlockValue::new (blk.getLoc (), VoidType::new (blk.getLoc ()), [var, content])
        } catch {
            err: &ErrorMsg => {
                errors:.push (err);
                NONE_VALUE
            }
        }
        
        {
            context:.quitBlock (warnUnused-> errors.len () == 0us);
        } catch { 
            err : &ErrorMsg => errors:.push (err); 
        }

        if (errors.len () != 0us) throw ErrorMsg::list (errors[]);
        res
    }
    
}
