mod ymirc::semantic::validator::operator::forloop;

import std::io;
import std::collection::vec;

import ymirc::semantic::validator::visitor;
import ymirc::semantic::validator::errors;
import ymirc::errors::_;
import ymirc::utils::format;
import ymirc::semantic::generator::value::_;
import ymirc::syntax::expression::_;
import ymirc::syntax::keys;
import ymirc::lexing::word;

import ymirc::semantic::generator::type::_;

/**
 * The For loop validator is used to validate ForLoopExpr
 * It is a class validator because for loop operations are complex
 */
pub class ForLoopValidator {

    /**
     * Create an empty validator     
     */
    pub self () {}
    
    /**
     * Validate a for loop expression
     * @params: 
     *  - context: the context of the validation
     *  - f: the for loop to validate
     * @returns: a value
     * @throws:
     *   - &ErrorMsg, if the validation failed
     */
    pub def validate (self, dmut context : &Validator, f : &ForLoopExpr) -> &Value
        throws &ErrorMsg
    {
        let value = context:.validateValue (f.getValue ());
        match value.getType () {
            t : &TupleType => { self.validateTupleLoop (alias context, t, value, f) }
            s : &SliceType => { self.validateSliceLoop (alias context, s, value, f) }
            r : &RangeType => { self.validateRangeLoop (alias context, r, value, f) }
            _ => {
                throw ErrorMsg::fatal (f.getLoc (), format (ValidateErrorMessage::UNDEF_FOR_LOOP_OPERATOR, f.getVariables ().len, value.getType ()));
            }
        }
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================        LOOP ON TUPLES        =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a for loop on a tuple
     * @params: 
     *    - context: the context of the validation
     *    - type: the type of the tuple
     *    - value: the value to iterate
     *    - f: the for loop to validate
     * @throws: 
     *    - &ErrorMsg: if the validation failed
     * @returns: the validated loop
     */
    def validateTupleLoop (self, dmut context : &Validator, type : &TupleType, value : &Value, f : &ForLoopExpr)-> &Value
        throws &ErrorMsg
    {
        let vars = f.getVariables ();
        let uniqV = UniqValue::new (value.getLoc (), value);
        
        // we van iterate on tuple with only one variable
        if (vars.len != 1us) throw ErrorMsg::fatal (f.getLoc (), format (ValidateErrorMessage::UNDEF_FOR_LOOP_OPERATOR, vars.len, type));
        
        match vars[0] {
            vdecl : &VarDeclExpr => {
                if (context.findDecos (vdecl.getDecos (), Decorators::__members__)) {
                    throw ErrorMsg::fatal (vdecl.getLoc (), format (ValidateErrorMessage::FORBID_DECO_FOR_LOOP_TUPLE, type));
                }

                let dmut content = Vec!{&Value}::new ();
                context:.enterLoop (); // Even if it is unwinded at compile time, it should behave like a loop (so we can break in it)
                context:.setCurrentLoopType (VoidType::new (f.getLoc ())); // it has no type, (because there is no else part for the moment ?, in theory it is no necessary if we check that there is at least one value in the tuple?)
                {
                    for i in 0us .. type.getInners ().len { // we validate the content of the loop for each type of the tuple
                        content:.push (self.validateTupleInnerLoop (alias context, i, vdecl, type, uniqV, f.getBlock ()));
                    }
                } catch {
                    err : &ErrorMsg => {
                        context:.quitLoop (); // we must not forget to quit the loop 
                        throw err;
                    }
                }
                
                context:.quitLoop ();
                let inner = BlockValue::new (f.getLoc (), VoidType::new (f.getLoc ()), content[]);
                LoopValue::new (f.getLoc (), VoidType::new (f.getLoc ()), NONE_VALUE, inner, false, isCteFor-> true)
            }
            _ =>
                __pragma!panic ();
        }        
    }

    /**
     * Validate the inner content of a loop iteration over a tuple value
     * @params: 
     *     - context: the context of the validation
     *     - i: the index of the current iteration 
     *     - vdecl: the variable iterator to declare
     *     - type: the type of the tuple to iterate
     *     - value: the content of the tuple value
     *     - blk: the content of the for loop
     * @returns: the content of the for loop validated for th i-th iteration
     * @throws:
     *    - &ErrorMsg: if the validation failed
     */
    def validateTupleInnerLoop (self, dmut context : &Validator, i : usize, vdecl : &VarDeclExpr, type : &TupleType, value : &Value, blk : &Expression)-> &Value
        throws &ErrorMsg
    {
        let dmut errors = Vec!{&ErrorMsg}::new ();        
        context:.enterBlock ();
        let res = { // Simply validate the content of a single iteration
            // Declare the variable that access the current field
            if (vdecl.getLoc () != Keys::UNDER) context:.verifyShadow (vdecl.getLoc ());
            let var = VarDeclValue::new (vdecl.getLoc (), type.getInners ()[i], TupleFieldAccessValue::new (vdecl.getLoc (), type.getInners ()[i], value, i), false, false); 
            if (vdecl.getLoc () != Keys::UNDER) context:.insertLocal (vdecl.getLoc ().str (), var); // we declare the variable so we can retreive it inside the loop

            let content = context:.validateValue (blk); // we validate the content of the loop
            BlockValue::new (blk.getLoc (), VoidType::new (blk.getLoc ()), [var, content]) // and we return the loop iteration block
        } catch {
            err: &ErrorMsg => {
                errors:.push (err);
                NONE_VALUE
            }
        }
        
        {
            context:.quitBlock (warnUnused-> errors.len () == 0us); // if there was an error, we don't add the warn unused
        } catch { 
            err : &ErrorMsg => errors:.push (err); 
        }

        if (errors.len () != 0us) throw ErrorMsg::list (errors[]);
        res
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================        LOOP ON SLICES        =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a for loop iterating through a slice value
     * @params: 
     *     - context: the context of the validation
     *     - slcType: the type of the iteration
     *     - value: the value that is iterated
     *     - content: the content of the iteration to validate
     */
    def validateSliceLoop (self, dmut context : &Validator, slcType : &SliceType, value : &Value, content : &ForLoopExpr)-> &Value
        throws &ErrorMsg
    {
        let vars = content.getVariables ();
        let uniqV = UniqValue::new (value.getLoc (), value);
        match vars.len {
            1us => // only the value of the array 
                return self.validateSliceIteration (alias context, slcType, uniqV, content, vars[0], EmptyExpression::new ());            
            2us => // The value of the array and the iterator
                return self.validateSliceIteration (alias context, slcType, uniqV, content, vars[0], vars[1]);
            _ => { // no iteration is possible with three variables
                throw ErrorMsg::fatal (content.getLoc (), format (ValidateErrorMessage::UNDEF_FOR_LOOP_OPERATOR, vars.len, slcType));
            }            
        }
    }

    /**
     * Validate the iteration over the slice
     * @params: 
     *    - context: the context of the validation
     *    - slcType: the type of the slice of the iteration
     *    - value: the value of the slice of the iteration
     *    - content: the for loop containing the ocntent of the iteration
     *    - iter1: the first iteration variable (never empty)
     *    - iter2: the second iteration variable (might be empty)
     * @returns: the value of the iteration
     * @throws:
     *    - &ErrorMsg: if the iteration cannot be validated
     */
    def validateSliceIteration (self, dmut context : &Validator, slcType : &SliceType, value : &Value, content : &ForLoopExpr, iter1 : &Expression, iter2 : &Expression)-> &Value
        throws &ErrorMsg
    {
        let dmut errors = Vec!{&ErrorMsg}::new ();
        let dmut innerValues = Vec!{&Value}::new ();
        let dmut values = Vec!{&Value}::new ();
        let loc = content.getLoc ();
        let mut test : &Value = NONE_VALUE;

        context:.enterBlock ();
        {
            // First we create the iteration variables, that will store the value at the current array index, and the value of the index
            let vars = self.validateSliceIteratorVars (alias context, slcType, iter1, iter2);
            let array = vars._0; // the value inside the array
            let iter = vars._1; // the value of the current index
            values:.push (vars._2);
            values:.push (vars._3);
            
            let one = usize (loc, 1us); // used to increment the iterator
            let len = StructFieldAccessValue::new (loc, one.getType (), value, SliceKeys::LEN); // access the size of the array to verify test when to exit the loop
            
            test = CmpIntOperatorValue::new (loc, BinaryOperators::INF, iter, len); // if the iterator is greater than the value of the array the loop is stopped
            let affect = AffectValue::new (loc, array.getType (), array, SliceAccessValue::new (loc, array.getType (), value, iter)); // affect the current value of the array to the index
            let increment = AffectValue::new (loc, iter.getType (), iter, BinaryMathIntOperatorValue::new (loc, iter.getType (), BinaryOperators::PLUS, iter, one)); // increment the iterator for the next iteration

            // the loop has three steps: 
            innerValues:.push (affect); // 1. get the current value of the array
            innerValues:.push (context:.validateValue (content.getBlock ())); // execute the content of the loop
            innerValues:.push (increment); // go to the next iteration
        } catch {
            err : &ErrorMsg => { errors:.push (err); } // we catch everything because we need to exit the block
        }
    
        let blkContent = BlockValue::new (loc, VoidType::new (loc), innerValues[]); // create the loop 
        let _loop = LoopValue::new (loc, VoidType::new (loc), test-> test, blkContent, isDo-> false);
        values:.push (_loop);

        {
            context:.quitBlock (warnUnused-> errors.len () == 0us); // we only warn if there was no error in the loop content
        } catch {
            err : &ErrorMsg => errors:.push (err); // some warn unused
        }        

        if (errors.len () != 0us) throw ErrorMsg::list (errors[]); 
        BlockValue::new (loc, VoidType::new (loc), values[])
    }

    /**
     * Create the iteration variable (and verify that they are correctly defined)
     * @params: 
     *    - context: the context of the validaiton
     *    - slcType: the type of the iteration
     *    - iter1: the iterator (value if iter2 is empty, index otherwise)
     *    - iter2: value if not empty
     * @returns:
     *    - .0: the ref to the value variable 
     *    - .1: the ref to the index variable (even if iter2 is empty)
     *    - .2: the vardecl of the value variable
     *    - .3: the vardecl of the index variable (even if iter1 is empty)
     * @throws:
     *    - &ErrorMsg: if the variables are uncorrectly defined
     */
    def validateSliceIteratorVars (self, dmut context : &Validator, slcType : &SliceType, iter1 : &Expression, iter2 : &Expression)-> (&Value, &Value, &Value, &Value)
        throws &ErrorMsg
    {
        // This function can seem a bit complex but isn't
        match (iter1, iter2) { // we have two cases, (with one variable, or with two)            
            (v : &VarDeclExpr, EmptyExpression ()) => { // 1. with one
                if (v.getLoc () != Keys::UNDER) context:.verifyShadow (v.getLoc ()); // verify that the iterator name is not used
                if (context.findDecos (v.getDecos (), Decorators::__members__)) { // the iteration is always const, so it is impossible to have decorators on iterator values (to have specific decoration, two variable iteration should be used)
                    throw ErrorMsg::fatal (v.getLoc (), format (ValidateErrorMessage::FORBID_DECO_FOR_LOOP_SLICE, slcType));
                }

                // We create the variable for the value
                let array = VarDeclValue::new (v.getLoc (), slcType.getInners ()[0].clone (isMutable-> false), NoneValue::new (), isMutable-> false, isPure-> false);
                // And the variable for the iterator, with an name that cannot be taken elsewhere, but this is not important
                let iter = VarDeclValue::new (Word::new ("#_iter"s8, v.getLoc ()), IntType::new (v.getLoc (), size-> 0u16, signed-> false), usize (v.getLoc (), 0us), isMutable-> false, isPure-> false);
                if (v.getLoc () != Keys::UNDER) context:.insertLocal (v.getLoc ().str (), array); // The variable must be retreivable, so we insert it inside the context, (but not the iterator that is hidden)               

                let vrefArray = VarRefValue::new (v.getLoc (), array.getLoc (), array.getType (), false, array.getUniqId (), isSelf-> false);
                let vrefIter = VarRefValue::new (iter.getLoc (), iter.getLoc (), iter.getType (), false, iter.getUniqId (), isSelf-> false);
                
                return (vrefArray, vrefIter, array, iter); // we return the variable for the loop validation
            }
            (i : &VarDeclExpr, v : &VarDeclExpr) => {
                if (i.getLoc () != Keys::UNDER) context:.verifyShadow (i.getLoc ()); // verify that the iterator name is not used
                if (v.getLoc () != Keys::UNDER) context:.verifyShadow (v.getLoc ());
                
                if (context.findDecos (v.getDecos (), Decorators::__members__)) { // same as with only one variable, no decorators are allowed
                    throw ErrorMsg::fatal (v.getLoc (), format (ValidateErrorMessage::FORBID_DECO_FOR_LOOP_SLICE, slcType));
                }

                if (context.findDecos (i.getDecos (), Decorators::__members__)) { // even for index iterator
                    throw ErrorMsg::fatal (i.getLoc (), format (ValidateErrorMessage::FORBID_DECO_FOR_LOOP_SLICE, slcType));
                }

                // Variable for value
                let array = VarDeclValue::new (v.getLoc (), slcType.getInners ()[0].clone (isMutable-> false), NoneValue::new (), isMutable-> false, isPure-> false);
                // Variable for index
                let iter = VarDeclValue::new (i.getLoc (), IntType::new (i.getLoc (), size-> 0u16, signed-> false), usize (i.getLoc (), 0us), isMutable-> false, isPure-> false);
                if (v.getLoc () != Keys::UNDER) context:.insertLocal (v.getLoc ().str (), array); // insert them, so we can retreive them
                if (i.getLoc () != Keys::UNDER) context:.insertLocal (i.getLoc ().str (), iter);

                let vrefArray = VarRefValue::new (v.getLoc (), array.getLoc (), array.getType (), false, array.getUniqId (), isSelf-> false);
                let vrefIter = VarRefValue::new (iter.getLoc (), iter.getLoc (), iter.getType (), false, iter.getUniqId (), isSelf-> false);
                
                return (vrefArray, vrefIter, array, iter); // and we return them for the loop valiation
            }
            _ => __pragma!panic (); // panic if we get something else
        }
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================        LOOP ON RANGES        =========================
     * ================================================================================
     * ================================================================================
     */


    /**
     * Validate a for loop on a range value
     * @params: 
     *    - context: the context of the validation
     *    - rngType: the type of the range 
     *    - value: the value to iterate
     *    - f: the for loop to validate
     * @returns: the validated loop
     * @throws:
     *    - &ErrorMsg: if the validation fails
     */
    def validateRangeLoop (self, dmut context : &Validator, rngType : &RangeType, value : &Value, f : &ForLoopExpr)-> &Value
        throws &ErrorMsg
    {        
        let vars = f.getVariables ();
        let uniqV = UniqValue::new (value.getLoc (), value);
        
        // We can iterate over range with only one variable
        if (vars.len != 1us) throw ErrorMsg::fatal (f.getLoc (), format (ValidateErrorMessage::UNDEF_FOR_LOOP_OPERATOR, vars.len, rngType));


        let dmut errors = Vec!{&ErrorMsg}::new ();
        let dmut innerValues = Vec!{&Value}::new ();
        let dmut values = Vec!{&Value}::new ();
        let loc = f.getLoc ();
        let mut test : &Value = NONE_VALUE;

        context:.enterBlock ();
        {
            // First we create the variable that will store the iterator
            let (varRef, varDecl) = self.validateRangeIteratorVar (alias context, rngType, vars[0], uniqV);
            values:.push (varDecl); // push the var decl before the loop 
            
            // Validate the increment of the iterator, and the test of the loop
            let (increment, _test) = self.validateRangeIteratorIncrement (alias context, rngType, varRef, uniqV);    

            innerValues:.push (context:.validateValue (f.getBlock ())); // the loop content 
            innerValues:.push (increment); // the loop increment
            test = _test;
        } catch {
            err : &ErrorMsg => { errors:.push (err); }
        }

        let blkContent = BlockValue::new (loc, VoidType::new (loc), innerValues[]); // The content of the loop
        let _loop = LoopValue::new (loc, VoidType::new (loc), test-> test, blkContent, isDo-> false); // The loop

        values:.push (_loop); // push the loop after the declaration of the iterator variable
        {
            context:.quitBlock (warnUnused-> errors.len () == 0us);
        } catch {
            err : &ErrorMsg => errors:.push (err); // Some warn unused
        }

        if (errors.len () != 0us) throw ErrorMsg::list (errors[]);
        BlockValue::new (loc, VoidType::new (loc), values[])
    }

    /**
     * Validate the iterator variable
     * @params: 
     *    - context: the context of the validation
     *    - rngType: the type of the range value
     *    - iterDecl: the declaration of the iterator
     *    - rngValue: the value of the range
     * @returns: 
     *    - .0: the variable declaration
     *    - .1: the variable ref value
     * @throws:
     *    - &ErrorMsg: if the validation fails
     */
    def validateRangeIteratorVar (self, dmut context : &Validator, rngType : &RangeType, iterDecl : &Expression, rngValue : &Value)-> (&Value, &Value)
        throws &ErrorMsg
    {
        match iterDecl {
            v : &VarDeclExpr => {
                if (v.getLoc () != Keys::UNDER) context:.verifyShadow (v.getLoc ());
                if (context.findDecos (v.getDecos (), Decorators::__members__)) {
                    // The iteration is always const, so it is impossible to have decorators on iterator values
                    throw ErrorMsg::fatal (v.getLoc (), format (ValidateErrorMessage::FORBID_DECO_FOR_LOOP_RANGE, rngType));
                }

                // We create the variable for the iterator
                let iterType = rngType.getInners ()[0].clone (isMutable-> false);
                let iterContent = context:.getCompileTimeInterpreter ():.simplify (StructFieldAccessValue::new (v.getLoc (), iterType, rngValue, RangeKeys::FST));
                let iterValue = VarDeclValue::new (v.getLoc (), iterType, iterContent, isMutable-> false, isPure-> false);

                if (v.getLoc () != Keys::UNDER) context:.insertLocal (v.getLoc ().str (), iterValue);
                // And the variable ref so we can use it
                let vRefIter = VarRefValue::new (v.getLoc (), iterValue.getLoc (), iterType, false, iterValue.getUniqId (), isSelf-> false);

                return (vRefIter, iterValue);
            }
            _ => __pragma!panic ();
        }
    }

    /**
     * Validate the increment of the iterator during an iteration on a range value
     * @params: 
     *    - context: the context of the validation
     *    - rngType: the type of the range
     *    - varRef: the variable containing the iterator
     *    - value: the range value
     * @returns:
     *    - .0: the increment value
     *    - .1: the test for the loop
     */
    def validateRangeIteratorIncrement (self, dmut context : &Validator, rngType : &RangeType, varRef : &Value, value : &Value)-> (&Value, &Value)
        throws &ErrorMsg
    {
        let loc = varRef.getLoc ();
        
        let step = context:.getCompileTimeInterpreter ().simplify (StructFieldAccessValue::new (loc, rngType.getInners ()[1], value, RangeKeys::STEP));
        let scd  = context:.getCompileTimeInterpreter ().simplify (StructFieldAccessValue::new (loc, rngType.getInners ()[0], value, RangeKeys::SCD));               
        let contains = context:.getCompileTimeInterpreter ().simplify (StructFieldAccessValue::new (loc, BoolType::new (loc), value, RangeKeys::CONTAIN));
       
        let (inf, infEq, sup, supEq) = match rngType.getInners ()[0] {
            IntType () => {
                (cast!{&Value} (CmpIntOperatorValue::new (loc, BinaryOperators::INF, varRef, scd)),
                 cast!{&Value} (CmpIntOperatorValue::new (loc, BinaryOperators::INF_EQUAL, varRef, scd)),
                 cast!{&Value} (CmpIntOperatorValue::new (loc, BinaryOperators::SUP, varRef, scd)),
                 cast!{&Value} (CmpIntOperatorValue::new (loc, BinaryOperators::SUP_EQUAL, varRef, scd)))            
            }
            FloatType () => {
                (cast!{&Value} (CmpFloatOperatorValue::new (loc, BinaryOperators::INF, varRef, scd)),
                 cast!{&Value} (CmpFloatOperatorValue::new (loc, BinaryOperators::INF_EQUAL, varRef, scd)),
                 cast!{&Value} (CmpFloatOperatorValue::new (loc, BinaryOperators::SUP, varRef, scd)),
                 cast!{&Value} (CmpFloatOperatorValue::new (loc, BinaryOperators::SUP_EQUAL, varRef, scd)))            
            }
            CharType () => {
                (cast!{&Value} (CmpCharOperatorValue::new (loc, BinaryOperators::INF, varRef, scd)),
                 cast!{&Value} (CmpCharOperatorValue::new (loc, BinaryOperators::INF_EQUAL, varRef, scd)),
                 cast!{&Value} (CmpCharOperatorValue::new (loc, BinaryOperators::SUP, varRef, scd)),
                 cast!{&Value} (CmpCharOperatorValue::new (loc, BinaryOperators::SUP_EQUAL, varRef, scd)))            
            }
            _ => __pragma!panic ();
        };
                
        // step < 0
        let stepCmp = context:.getCompileTimeInterpreter ():.simplify (match rngType.getInners ()[1] {
            i : &IntType => {
                CmpIntOperatorValue::new (loc, BinaryOperators::INF, step, intValue (loc, 0us, i.getSize (), true))
            }
            f : &FloatType => {
                CmpFloatOperatorValue::new (loc, BinaryOperators::INF, step, floatValue (loc, d-> 0.0, f.getSize ()))
            }
            _ => __pragma!panic ()
        });        
        
        // varRef = varRef + cast!(typeof (varRef)) (step)
        let increment = match varRef.getType () {
            i : &IntType => {
                AffectValue::new (loc, i, varRef, BinaryMathIntOperatorValue::new (loc, varRef.getType (), BinaryOperators::PLUS, varRef, CastValue::new (loc, i, step)))
            }
            f : &FloatType => {
                AffectValue::new (loc, f, varRef, BinaryMathFloatOperatorValue::new (loc, varRef.getType (), BinaryOperators::PLUS, varRef, CastValue::new (loc, f, step)))
            }
            c : &CharType => {
                AffectValue::new (loc, c, varRef, BinaryMathCharOperatorValue::new (loc, varRef.getType (), BinaryOperators::PLUS, varRef, CastValue::new (loc, c, step)))
            }
            _ => __pragma!panic ();
        };

        let (innerCondInf, innerCondSup) = match contains {
            b : &BoolValue => {
                if b.isTrue () {
                    (infEq, supEq)
                } else {
                    (inf, sup)
                }
            }
            _ => {
                (cast!{&Value} (ConditionalValue::new (loc, BoolType::new (loc), contains, infEq, elsev-> inf, isComplete-> true)),
                 cast!{&Value} (ConditionalValue::new (loc, BoolType::new (loc), contains, supEq, elsev-> sup, isComplete-> true)))
            }
        }
        
        let test = match (stepCmp) {
            b : &BoolValue => {
                if (b.isTrue ()) {
                    innerCondSup
                } else {
                    innerCondInf
                }
            }
            _ => {
                cast!{&Value} (ConditionalValue::new (loc, BoolType::new (loc), stepCmp, innerCondSup, innerCondInf, isComplete-> true))
            }
        }
                        
        (increment, test)
    }
    
}
