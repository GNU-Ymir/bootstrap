in copyop;

use ymirc::semantic::validator::{visitor, errors, template::_};

use ymirc::errors::_;
use ymirc::utils::format;
use ymirc::semantic::generator::{value::_, type::_};
use ymirc::syntax::{_,
                    declaration::_,
                    expression::{_, literal::_, macro_::_, operator::_, template::_}};

use ymirc::lexing::{word, tokens};
use ymirc::global::core_;

use ymirc::semantic::generator::type::{_,
                                       syntax::_,
                                       custom::_,
                                       native::{_, scalar::_, compound::_},
                                       temporary::_};

use ymirc::semantic::generator::value::{_,
                                        syntax::_,
                                        construct::{_, delegate::_},
                                        literal::_,
                                        memory::_,
                                        operator::{_, binary::_, call::_, fields::_, map::_, slice::_, unary::_},
                                        operator::binary::{bool_::_, char_::_, float_::_, int_::_, pointer_::_},
                                        operator::map::iteration::_,
                                        prototypes::_,
                                        scope::_,
                                        syntax::_,
                                        template::_};

/**
 * The validator for copy and deep copy
 * */
pub record CopyOpValidator {

    /**
     * Create an empty validator
     * */
    pub self () {}

    /**
     * Validate a single level copy
     * @params:
     *    - context: the context of the copy
     *    - i: the intrinsic expression to validate
     * @returns: the value copied (by multiple means depending on the type)
     * @throws:
     *    - &ErrorMsg: if the validation failed
     * */
    pub fn validateCopy (self, dmut context : &Validator, i : &IntrinsicExpr)-> &Value
        throws ErrorMsg
    {
        let content = {
            context:.enterCopy (i);
            let mut content = context:.getValueValidator ().validate (alias context, i.getContent (), canBeLazy-> true);
            if (content of ExpandValue) {
                throw copy ErrorMsg::fatal (i.getLoc (), end-> content.getLoc (), format (ValidateErrorMessage::MISMATCH_COPY_EXPAND, content.getType ()));
            } else if (content of LazyValue) {
                throw copy ErrorMsg::fatal (i.getLoc (), end-> content.getLoc (), format (ValidateErrorMessage::MISMATCH_COPY_LAZY, content.getType ()));
            };

            context.implicitEnumUnwrap (context:.getCompileTimeInterpreter ():.reduce (content))
        } exit {
            context:.exitCopy ();
        };

        // No need to copy something that is already allocated
        if (self.isAllocated (content, deeply-> false)) return content;

        // The only aliasable types that are one level copiable are slice and maps
        match content.getType () {
            s : &SliceType => { self.validateSingleCopySlice (alias context, i, content, s) }
            a : &ArrayType => { self.validateSingleCopyArray (alias context, i, content, a) }
            m : &MapType   => { self.validateSingleCopyMap   (alias context, i, content, m) }
            _ => {
                match content {
                    c : &CtorDelegateValue => {
                        return context:.getCallOpValidator ().validate (alias context, i.getLoc (), c, [], inCopy-> true);
                    }
                    c : &CtorDelegateTemplateValue => {
                        return context:.getCallOpValidator ().validate (alias context, i.getLoc (), c, [], inCopy-> true);
                    }
                    _ => {
                        throw copy ErrorMsg::fatal (i.getLoc (), format (ValidateErrorMessage::NO_COPY_EXIST, content.getType ()));
                    }
                }
            }
        }
    }

    /**
     * Validate a deep level copy
     * @params:
     *    - context: the context of the copy
     *    - i: the intrinsic expression to validate
     * @returns: the value deep copied (by multiple means depending on the type)
     * @throws:
     *    - &ErrorMsg: if the validation failed
     * */
    pub fn validateDeepCopy (self, dmut context : &Validator, i : &IntrinsicExpr)-> &Value
        throws ErrorMsg
    {
        let content = {
            context:.enterCopy (i);
            let mut content = context:.getValueValidator ().validate (alias context, i.getContent (), canBeLazy-> true);
            if (content of ExpandValue) {
                throw copy ErrorMsg::fatal (i.getLoc (), end-> content.getLoc (), format (ValidateErrorMessage::MISMATCH_DCOPY_EXPAND, content.getType ()));
            } else if (content of LazyValue) {
                throw copy ErrorMsg::fatal (i.getLoc (), end-> content.getLoc (), format (ValidateErrorMessage::MISMATCH_DCOPY_LAZY, content.getType ()));
            };

            context.implicitEnumUnwrap (context:.getCompileTimeInterpreter ():.reduce (content))
        } exit {
            context:.exitCopy ();
        };

        // No need to copy something that is already allocated
        if (self.isAllocated (content, deeply-> true)) return content;

        match content.getType () {
            c : &ClassPtrType => { self.validateDeepCopyClassPtr (alias context, i, content, c) }
            s : &SliceType    => { self.validateDeepCopySlice (alias context, i, content, s) }
            a : &ArrayType    => { self.validateDeepCopyArray (alias context, i, content, a) }
            m : &MapType      => { self.validateDeepCopyMap (alias context, i, content, m) }
            _ => {
                throw copy ErrorMsg::fatal (i.getLoc (), format (ValidateErrorMessage::NO_COPY_EXIST, content.getType ()));
            }
        }
    }

    /**
     * Validate a move operation
     * @params:
     *    - context: the context of the move
     *    - i: the intrinsic expression to validate
     * @returns: the moved value
     * @throws:
     *    - &ErrorMsg: if the move is not allowed
     * */
    pub fn validateMove (self, dmut context : &Validator, i : &IntrinsicExpr)-> &Value
        throws ErrorMsg
    {
        let ret = context:.validateValue (i.getContent ());

        // only movable structures are movable
        if (!ret.getType ().isMovable ()) throw copy ErrorMsg::fatal (i.getLoc (), format (ValidateErrorMessage::NOT_MOVABLE, ret.getType ()));
        match ret.getType () {
            c : &ClassPtrType => { self.validateMoveStruct (alias context, i, c, ret) }
            _ => {
                throw copy ErrorMsg::fatal (i.getLoc (), format (ValidateErrorMessage::NOT_MOVABLE, ret.getType ()));
            }
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===============================          SINGLE LEVEL COPY          ================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Validate a one level copy of an array value
     * @params:
     *    - context: the context of the validation
     *    - i: the expression to validate
     *    - value: the value of the copy
     *    - type: the type of the copy
     * @returns: the copied value
     * @throws:
     *    - &ErrorMsg: if the validation failed
     * */
    fn validateSingleCopyArray (self, dmut _ : &Validator, i : &IntrinsicExpr, value : &Value, arr : &ArrayType)-> &Value
        throws ErrorMsg
    {
        let inner = arr.getInners () [0].cloneMutableTilBorrow ();
        let type  = copy SliceType (i.getLoc (), inner, isMutable-> true);

        let addr = copy AddressValue (i.getLoc (), copy PointerType (i.getLoc (), inner), value);
        let ctor = copy SliceCtorValue (i.getLoc (), type, addr,
                                        NULL_VALUE,
                                        makeIntValue (arr.getLen ()), isImplicitAlias-> true);

        copy CopierValue (i.getLoc (), type, ctor)
    }

    /**
     * Validate a one level copy of an slice value
     * @params:
     *    - context: the context of the validation
     *    - i: the expression to validate
     *    - value: the value of the copy
     *    - type: the type of the copy
     * @returns: the copied value
     * @throws:
     *    - &ErrorMsg: if the validation failed
     * */
    fn validateSingleCopySlice (self, dmut _ : &Validator, i : &IntrinsicExpr, value : &Value, slc : &SliceType)-> &Value
        throws ErrorMsg
    {
        let inner = slc.getInners () [0].cloneMutableTilBorrow ();
        let type  = copy SliceType (i.getLoc (), inner, isMutable-> true);

        copy CopierValue (i.getLoc (), type, value)
    }

    /**
     * Validate a one level copy of a map value
     * @params:
     *    - context: the context of the validation
     *    - i: the expression to validate
     *    - value: the value of the copy
     *    - type: the type of the copy
     * @returns: the copied value
     * @throws:
     *    - &ErrorMsg: if the validation failed
     * */
    fn validateSingleCopyMap (self, dmut _ : &Validator, i : &IntrinsicExpr, value : &Value, m : &MapType)-> &Value
        throws ErrorMsg
    {
        let keyT = m.getInners () [0];
        let valueT = m.getInners () [1].cloneMutableTilBorrow ();
        let type = copy MapType (i.getLoc (), keyT, valueT, isMutable-> true);

        copy CopierValue (i.getLoc (), type, value)
    }

    /*!
     * =================================================================================
     * =================================================================================
     * =========================           CORE COPY            ========================
     * =================================================================================
     * =================================================================================
     */

    /**
     * Validate a deep copy on an classptr value
     * @params:
     *    - context: the context of the validation
     *    - i: the expression to validate
     *    - value: the value of the deep copy
     *    - type: the type of the copy
     * @returns: the deep copied value
     * @throws:
     *    - &ErrorMsg: if the validation failed
     * */
    fn validateDeepCopyClassPtr (self, dmut context : &Validator, i : &IntrinsicExpr, value : &Value, cptr : &ClassPtrType)-> &Value
        throws ErrorMsg
    {
        let tr = context.createSyntaxVarFromPath (i.getLoc (), GlobalTraitUtils::COPIABLE_TRAIT);
        let im = context:.validateType (tr);
        context.verifyImplement (i.getLoc (), cptr, im);

        let dcopyName = copy VarExpr (copy Word (OpOverrideNames::DCOPY, i.getLoc ()));
        let dot = copy BinaryExpr (copy Word (Tokens::DOT, i.getLoc ()), copy ValueWrapperExpr (value.getLoc (), value), dcopyName);
        let syntCall = copy MultOperatorExpr (copy Word (Tokens::LPAR, i.getLoc ()),
                                              copy Word (Tokens::RPAR, i.getLoc ()),
                                              left-> dot, rights-> [], canBeDotCall-> false);
        let v = context:.validateValue (syntCall);
        return context:.getCastValidator ().validateCast (alias context, v, cptr.toDeeplyMutable ());
    }

    /**
     * Validate a deep copy on an array value
     * @params:
     *    - context: the context of the validation
     *    - i: the expression to validate
     *    - value: the value of the deep copy
     *    - type: the type of the copy
     * @returns: the deep copied value
     * @throws:
     *    - &ErrorMsg: if the validation failed
     * */
    fn validateDeepCopyArray (self, dmut context : &Validator, i : &IntrinsicExpr, value : &Value, type : &ArrayType)-> &Value
        throws ErrorMsg
    {
        if (self.pointerLevelAfterDCopy (type) == 1us) {
            return self.validateCopy (alias context, copy IntrinsicExpr (i.getLoc (), IntrinsicKeys::COPY, copy ValueWrapperExpr (i.getLoc (), value)));
        }

        let mut parameters : [&Value] = [];
        let inner = type.getInners ()[0];
        let mut innerR : &Type = NONE_TYPE;

        for z in 0us .. type.getLen () {
            let curr = context:.getIndexOpValidator ().createArrayAccess (i.getLoc (), inner, value, makeIntValue (i.getLoc (), z));
            let dc = copy IntrinsicExpr (i.getLoc (), IntrinsicKeys::DCOPY, copy ValueWrapperExpr (i.getLoc (), curr));
            let p = self.validateDeepCopy (alias context, dc);
            innerR = p.getType ();
            parameters ~= [p];
        }

        let arrType = copy ArrayType (i.getLoc (), innerR, parameters.len, isMutable-> true);
        let arrValue = copy ArrayValue (i.getLoc (), arrType, parameters);
        let addr = copy AddressValue (i.getLoc (), copy PointerType (i.getLoc (), innerR), arrValue);


        let slcType = copy SliceType (i.getLoc (), innerR, isMutable-> true);
        let ctor = copy SliceCtorValue (i.getLoc (), slcType,
                                        addr,
                                        NULL_VALUE,
                                        makeIntValue (i.getLoc (), arrType.getLen ()), isImplicitAlias-> true);

        copy CopierValue (i.getLoc (), slcType, ctor, isDeep-> true)
    }

    /**
     * Validate a deep copy on a slice value
     * @params:
     *    - context: the context of the validation
     *    - i: the expression to validate
     *    - value: the value to deep copy
     *    - type: the type of the copy
     * @returns: the deep copied value
     * @throws:
     *    - &ErrorMsg: if the validation failed
     * */
    fn validateDeepCopySlice (self, dmut context : &Validator, i : &IntrinsicExpr, value : &Value, type : &SliceType)-> &Value
        throws ErrorMsg
    {
        if (self.pointerLevelAfterDCopy (type) == 1us) {
            return self.validateCopy (alias context, copy IntrinsicExpr (i.getLoc (), IntrinsicKeys::COPY, copy ValueWrapperExpr (i.getLoc (), value)));
        }

        // Calling the core function
        let syntVar = context.createSyntaxVarFromPath(i.getLoc (), SliceUtils::DCOPY_FUNC);

        // It is a template function, taking the slice type as template parameter
        let templCall = copy TemplateCallExpr (i.getLoc (),
                                               syntVar,
                                               copy [copy TypeWrapperExpr (type.getLoc (), type)]);

        // And taking one argument, the slice itself, and it return a deep copy version of the slice (deep copying every inner elements)
        let syntCall = copy MultOperatorExpr (copy Word (Tokens::LPAR, i.getLoc ()), copy Word (Tokens::RPAR, i.getLoc ()),
                                              templCall,
                                              copy [copy ValueWrapperExpr (value.getLoc (), value)], canBeDotCall-> false);

        {
            let callVal = context:.validateValue (syntCall);
            copy CopierValue (i.getLoc (), callVal.getType (), callVal, isDeep-> true, isDone-> true)
        } catch {
            err : &ErrorMsg => {
                throw copy ErrorMsg::note (i.getLoc (), ValidateErrorMessage::VALIDATING, notes-> copy [err]);
            }
        }
    }

    /**
     * Validate a deep copy on a map value
     * @params:
     *    - context: the context of the validation
     *    - i: the expression to validate
     *    - value: the value to deep copy
     *    - type: the type of the deep copy
     * @returns: the deep copied value
     * @throws:
     *    - &ErrorMsg: if the validation failed
     * */
    fn validateDeepCopyMap (self, dmut context : &Validator, i : &IntrinsicExpr, value : &Value, type : &MapType)-> &Value
        throws ErrorMsg
    {
        if (self.pointerLevelAfterDCopy (type) == 1us) {
            return self.validateCopy (alias context, copy IntrinsicExpr (i.getLoc (), IntrinsicKeys::COPY, copy ValueWrapperExpr (i.getLoc (), value)));
        }

        // Calling the core function
        let syntVar = context.createSyntaxVarFromPath(i.getLoc (), MapUtils::DCOPY_FUNC);

        // It is a template function, taking the map type as template parameter
        let templCall = copy TemplateCallExpr (i.getLoc (),
                                               syntVar,
                                               copy [copy TypeWrapperExpr (type.getLoc (), type.getInners ()[0]), // K
                                                     copy TypeWrapperExpr (type.getLoc (), type.getInners ()[1])]); // V

        // And taking one argument, the slice itself, and it return a deep copy version of the slice (deep copying every inner elements)
        let syntCall = copy MultOperatorExpr (copy Word (Tokens::LPAR, i.getLoc ()), copy Word (Tokens::RPAR, i.getLoc ()),
                                              templCall,
                                              copy [copy ValueWrapperExpr (value.getLoc (), value)],
                                              canBeDotCall-> false);

        {
            let callVal = context:.validateValue (syntCall);
            copy CopierValue (i.getLoc (), callVal.getType (), callVal, isDeep-> true, isDone-> true)
        } catch {
            err : &ErrorMsg => {
                throw copy ErrorMsg::note (i.getLoc (), ValidateErrorMessage::VALIDATING, notes-> copy [err]);
            }
        }
    }

    /*!
     * ================================================================================
     * ================================================================================
     * ===========================           MOVE            ==========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate the move of a struct value
     * @params:
     *     - context: the context of the validation
     *     - i: the intrinsic expression
     *     - c: the struct type
     *     - ret: the struct value
     * @returns: the moved value
     * @throws:
     *    - &ErrorMsg: if the move is not allowed
     * */
    fn validateMoveStruct (self, dmut context : &Validator, i : &IntrinsicExpr, c : &ClassPtrType, ret : &Value)-> &Value
        throws ErrorMsg
    {
        let reset = if (context.needExplicitMove (ret)) {
            context.verifyLeftOperandMove (i.getLoc (), ret, forMove-> true); // only mutable values that can be used as reference can be movable
            let ctors = context:.getSubTypeValidator ().validateClassCtors (alias context, i.getLoc (), c.getInner (), name-> "");
            let call = context:.getCallOpValidator ().validate (alias context, i.getLoc (), ctors, []);
            match call {
                cv : &CtorCallValue => {
                    let oldDg = cv.getCtor ();
                    let ndg = copy CtorDelegateValue (oldDg.getLoc (), oldDg.getType (), instance-> copy ReferencerValue (ret.getLoc (), ret.getType (), ret),
                                                      proto-> oldDg.getPrototype ());

                    copy CtorCallValue (i.getLoc (), VOID_TYPE, ndg, [])
                }
                _ => panic;
            }
        } else {
            UNIT_VALUE
        };


        copy MoverValue (i.getLoc (), ret.getType (), ret, reset-> reset)
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================           CHECKING            ========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Check if the value is an allocation value, that is already complying to the copy/dcopy statement
     * This can happen for literal values, such as slice from array literal, or class ctors
     * @params:
     *   - alloc: the value to check
     *   - deeply: true iif we need the value to be deeply mutable
     * @returns: true iif the value is allocated
     * */
    fn isAllocated (self, alloc : &Value, deeply : bool = false)-> bool {
        return match alloc {
            c : &CopierValue => {
                (c.isDeep () || !deeply)
            }
            a : &ArrayAllocValue => {
                (a.isDynamic () && !deeply)
            }
            s : &SliceCtorValue => {
                (s.getPointer () of NullValue) // null is allocated
            }
            c : &CtorCallValue => {
                match c.getType () {
                    cp : &ClassPtrType => return (!cp.isStruct ());
                }
                false
            }
            b : &BlockValue => {
                if (b.getValues ().len != 0us) {
                    return self.isAllocated (b.getValues () [$ - 1us]);
                }

                false
            }
            m : &MethodDelegateValue => {
                (m.isStruct () && m.isAddressed () && !deeply)
            }
            MapValue () => { !deeply }
            NullValue () => { true }
            _ => { false }
        }
    }

    /**
     * Count the height of the type (in term of pointers) if the type is deeply copied
     * @returns: the height of the type
     * */
    fn pointerLevelAfterDCopy (self, type : &Type)-> usize {
        return match type {
            a : &ArrayType => { 1us + self.pointerLevelAfterDCopy (a.getInners ()[0]) }
            s : &SliceType => { 1us + self.pointerLevelAfterDCopy (s.getInners ()[0]) }
            m : &MapType   => { 1us + self.pointerLevelAfterDCopy (m.getInners ()[1]) }
            t : &TupleType => {
                let mut ret = 0us;
                for inner in t.getInners () {
                    let h = self.pointerLevelAfterDCopy (inner);
                    if (ret < h) ret = h;
                }
                ret
            }
            _ : &ClassPtrType => { 1us }
            e : &EnumType => {
                self.pointerLevelAfterDCopy (e.getProxy ())
            }
            _ : &PointerType => { 0us } // pointers are not deep copied ?
            _ => { 0us }
        };
    }

}
