mod ymirc::semantic::validator::operator::cast_;

import ymirc::semantic::validator::visitor;
import ymirc::semantic::validator::errors;
import ymirc::errors::_;
import ymirc::utils::format;
import ymirc::utils::math;
import ymirc::syntax::expression::cast_;
import ymirc::global::core_;

import ymirc::semantic::symbol::_;
import ymirc::semantic::generator::_;

import ymirc::lexing::word;
import ymirc::lexing::tokens;
import ymirc::syntax::keys;
import ymirc::syntax::expression::_;

import std::algorithm::comparison;
import std::collection::vec;
import std::io;

/**
 * The cast validator is used to validate CastExpr
 */
pub class CastValidator {

    /**
     * Create an empty validator
     */
    pub self () {}

    /**
     * Validate a cast expression that returns a value
     * @params: 
     *    - context: the context of the validation
     *    - c: the cast operator to validate
     * @returns: a value
     * @throws:
     *    - &ErrorMsg, if the validation failed
     */
    pub def validateValue (self, dmut context : &Validator, c : &CastExpr)-> &Value
        throws &ErrorMsg
    {
        let value = context:.validateValue (c.getValue ());
        let type = context:.validateType (c.getType ());

        // It is possible to cast into the following types, with some conditions
        match type {
            i : &IntType => return self.validateIntCast (alias context, c.getLoc (), i, value);
            f : &FloatType => return self.validateFloatCast (alias context, c.getLoc (), f, value);
            ct : &CharType => return self.validateCharCast (alias context, c.getLoc (), ct, value);
            p : &PointerType => return self.validatePointerCast (alias context, c.getLoc (), p, value);
            cp : &ClassPtrType => return self.validateClassPtrCast (alias context, c.getLoc (), cp, value);            
        }

        // If the value contains an enumeration, it can be casted into the proxy type
        match value.getType () {
            en : &EnumType => return self.validateFromEnumCast (alias context, c.getLoc (), type, value, en);
        }

        /// Other casts are not allowed
        throw ErrorMsg::fatal (c.getLoc (), format (ValidateErrorMessage::UNDEFINED_CAST_OP, value.getType (), type));
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================             INT              =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a cast from value into a value of type int
     * @params: 
     *    - context: the context of the validation
     *    - loc: the location of the cast
     *    - i: the type of the cast
     *    - value: the value being casted
     * @returns: the casted value
     * @throws:
     *    - &ErrorMsg: if the cast is impossible
     */
    def validateIntCast (self, dmut _ : &Validator, loc : &Word, i : &IntType, value : &Value)-> &Value
        throws &ErrorMsg
    {
        match value.getType () {
            IntType () => { // int value can be casted to any int value
                return CastValue::new (loc, i, value);
            }
            CharType () => {
                if (!i.isSigned ()) { // char values can be casted to unsigned int
                    return CastValue::new (loc, i, value);
                }
            }
        }

        // Other types are not castable to int
        throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_CAST_OP, value.getType (), i));
    }
    
    /**
     * ================================================================================
     * ================================================================================
     * =========================            FLOAT             =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a cast from value into a value of type float
     * @params: 
     *    - context: the context of the validation
     *    - loc: the location of the cast
     *    - f: the type of the cast
     *    - value: the value being casted
     * @returns: the casted value
     * @throws:
     *    - &ErrorMsg: if the cast is impossible
     */
    def validateFloatCast (self, dmut context : &Validator, loc : &Word, f : &FloatType, value : &Value)-> &Value
        throws &ErrorMsg
    {
        context;
        loc;
        f;
        value;
        __pragma!fake_throw (&ErrorMsg);
        __pragma!panic ();
    }
    
    /**
     * ================================================================================
     * ================================================================================
     * =========================             CHAR             =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a cast from value into a value of type char
     * @params: 
     *    - context: the context of the validation
     *    - loc: the location of the cast
     *    - c: the type of the cast
     *    - value: the value being casted
     * @returns: the casted value
     * @throws:
     *    - &ErrorMsg: if the cast is impossible
     */
    def validateCharCast (self, dmut context : &Validator, loc : &Word, c : &CharType, value : &Value)-> &Value
        throws &ErrorMsg
    {
        context;
        loc;
        c;
        value;
        __pragma!fake_throw (&ErrorMsg);
        __pragma!panic ();
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================           POINTER            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a cast from value into a value of type pointer
     * @params: 
     *    - context: the context of the validation
     *    - loc: the location of the cast
     *    - p: the type of the cast
     *    - value: the value being casted
     * @returns: the casted value
     * @throws:
     *    - &ErrorMsg: if the cast is impossible
     */
    def validatePointerCast (self, dmut context : &Validator, loc : &Word, p : &PointerType, value : &Value)-> &Value
        throws &ErrorMsg
    {
        context;
        loc;
        p;
        value;
        __pragma!fake_throw (&ErrorMsg);
        __pragma!panic ();
    }
    
    /**
     * ================================================================================
     * ================================================================================
     * =========================            CLASS             =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a cast from value into a value of type class ptr
     * @params: 
     *    - context: the context of the validation
     *    - loc: the location of the cast
     *    - c: the type of the cast
     *    - value: the value being casted
     * @returns: the casted value
     * @throws:
     *    - &ErrorMsg: if the cast is impossible
     */
    def validateClassPtrCast (self, dmut context : &Validator, loc : &Word, c : &ClassPtrType, value : &Value)-> &Value
        throws &ErrorMsg
    {
        context;
        loc;
        c;
        value;
        __pragma!fake_throw (&ErrorMsg);
        __pragma!panic ();
    }
    
    /**
     * ================================================================================
     * ================================================================================
     * =========================             ENUM             =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a cast from a value ot type enum
     * @params: 
     *    - context: the context of the validation
     *    - loc: the location of the cast
     *    - t: the type of the cast
     *    - value: the value being casted whose type is an enum
     *    - en: the type of the enumeration (value.getType ())
     * @returns: the casted value
     * @throws:
     *    - &ErrorMsg: if the cast is impossible
     */
    def validateFromEnumCast (self, dmut context : &Validator, loc : &Word, t : &Type, value : &Value, en : &EnumType)-> &Value
        throws &ErrorMsg
    {
        context;
        loc;
        t;
        value;
        en;
        __pragma!fake_throw (&ErrorMsg);
        __pragma!panic ();
    }
    
}
