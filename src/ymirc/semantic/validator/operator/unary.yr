mod ymirc::semantic::validator::operator::unary;

import ymirc::semantic::validator::visitor;
import ymirc::semantic::validator::errors;
import ymirc::errors::_;
import ymirc::utils::format;
import ymirc::syntax::expression::operator::unary;
import ymirc::semantic::generator::value::base;
import ymirc::semantic::generator::value::operator::unary::_;
import ymirc::syntax::keys;
import ymirc::semantic::generator::type::_;

/**
 * The unary validator is used to validate UnaryOpExpr
 * It is a class validator because unary operation are complex
 */
pub class UnaryOpValidator {

    /**
     * Create an empty validator     
     */
    pub self () {}

    /**
     * Validate a unary expression
     * @params: 
     *  - context: the context of the validation
     *  - un: the unary operator to validate
     * @returns: a value
     * @throws: &ErrorMsg, if the validation failed
     */
    pub def validate (self, dmut context : &Validator, un : &UnaryExpr) -> &Value
        throws &ErrorMsg
    {
        match un.getLoc () {
            UnaryOperators::MINUS => {
                self.validateMinusOperator (alias context, un)
            }
            UnaryOperators::AND => {
                self.validateAndOperator (alias context, un)
            }
            UnaryOperators::STAR => {
                self.validateStarOperator (alias context, un)
            }
            UnaryOperators::NOT => {
                self.validateNotOperator (alias context, un)
            }
            _ => {
                throw ErrorMsg::fatal (un.getLoc (), format (ValidateErrorMessage::UNDEFINED_UN_OP_TOK, un.getLoc ().str ()));
            }
        }
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================            MINUS             =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a minus unary expression
     * @params: 
     *    - context: the context of the validation
     *    - un: the unary operator to validate
     * @returns: a value
     * @throws: 
     *   - &ErrorMsg: if there is an error in the validation       
     */
    def validateMinusOperator (self, dmut context : &Validator, un : &UnaryExpr)-> &Value
        throws &ErrorMsg
    {
        let value = context:.validateValue (un.getOperand ());
        match value.getType () { // minus operator works only on int and float operands
            IntType () => {
                UnaryIntOperatorValue::new (un.getLoc (), UnaryOperators::MINUS, value.getType (), value)
            }
            FloatType () => {
                UnaryFloatOperatorValue::new (un.getLoc (), UnaryOperators::MINUS, value.getType (), value)
            }
            _ => {
                throw ErrorMsg::fatal (un.getLoc (), format (ValidateErrorMessage::UNDEFINED_UN_OP, un.getLoc ().str (), value.getType ()));
            }
        }
    }
    
    
    /**
     * ================================================================================
     * ================================================================================
     * =========================             AND              =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate an and unary expression
     * @params: 
     *    - context: the context of the validation
     *    - un: the unary operator to validate
     * @returns: a value
     * @throws: 
     *   - &ErrorMsg: if there is an error in the validation       
     */
    def validateAndOperator (self, dmut context : &Validator, un : &UnaryExpr)-> &Value
        throws &ErrorMsg
    {
        context;
        un;
        __pragma!fake_throw (&ErrorMsg);
        __pragma!panic ();
    }

    
    /**
     * ================================================================================
     * ================================================================================
     * =========================             STAR             =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a star unary expression
     * @params: 
     *    - context: the context of the validation
     *    - un: the unary operator to validate
     * @returns: a value
     * @throws: 
     *   - &ErrorMsg: if there is an error in the validation       
     */
    def validateStarOperator (self, dmut context : &Validator, un : &UnaryExpr)-> &Value
        throws &ErrorMsg
    {
        context;
        un;
        __pragma!fake_throw (&ErrorMsg);
        __pragma!panic ();
    }
    

    /**
     * ================================================================================
     * ================================================================================
     * =========================             NOT              =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a not unary expression
     * @params:
     *    - context: the context of the validation
     *    - un: the unary operator to validate
     * @returns: a value
     * @throws:
     *   - &ErrorMsg: if there is an error in the validation
     */
    def validateNotOperator (self, dmut context : &Validator, un : &UnaryExpr)-> &Value
        throws &ErrorMsg
    {
        let value = context:.validateValue (un.getOperand ());
        match value.getType () {
            IntType () => {
                UnaryIntOperatorValue::new (un.getLoc (), UnaryOperators::NOT, value.getType (), value)
            }
            BoolType () => {
                UnaryBoolOperatorValue::new (un.getLoc (), UnaryOperators::NOT, value)
            }
            _ => {
                throw ErrorMsg::fatal (un.getLoc (), format (ValidateErrorMessage::UNDEFINED_UN_OP, un.getLoc ().str (), value.getType ()));
            }
        }
    }

}
