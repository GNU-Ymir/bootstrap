in unary;

use ymirc::semantic::validator::{visitor, errors, template::_};
use ymirc::syntax::{_,
                    declaration::_,
                    expression::{_, literal::_, macro_::_, operator::_, template::_}};

use ymirc::errors::_;
use ymirc::utils::format;
use ymirc::semantic::generator::{value::_, type::_};
use ymirc::lexing::{word, tokens};
use ymirc::global::{core_, state};
use ymirc::utils::{bigint, bigfloat};

use ymirc::semantic::generator::type::{_,
                                       custom::_,
                                       native::{_, scalar::_, compound::_},
                                       temporary::_};

use ymirc::semantic::generator::value::{_,
                                        construct::{_, delegate::_},
                                        literal::_,
                                        memory::_,
                                        operator::{_, binary::_, call::_, fields::_, map::_, slice::_, unary::_},
                                        operator::map::iteration::_,
                                        prototypes::_,
                                        scope::_,
                                        syntax::_,
                                        template::_};


/**
 * The unary validator is used to validate UnaryOpExpr
 * It is a class validator because unary operation are complex
 */
pub record UnaryOpValidator {

    /**
     * Create an empty validator     
     */
    pub self () {}

    /**
     * Validate a unary expression
     * @params: 
     *  - context: the context of the validation
     *  - un: the unary operator to validate
     * @returns: a value
     * @throws: &ErrorMsg, if the validation failed
     */
    pub fn validate (self, dmut context : &Validator, un : &UnaryExpr) -> &Value
        throws ErrorMsg
    {
        match un.getLoc () {
            UnaryOperators::MINUS => {
                self.validateMinusOperator (alias context, un)
            }
            UnaryOperators::AND => {
                self.validateAndOperator (alias context, un)
            }
            UnaryOperators::STAR => {
                self.validateStarOperator (alias context, un)
            }
            UnaryOperators::NOT => {
                self.validateNotOperator (alias context, un)
            }
            _ => {
                throw copy ErrorMsg::fatal (un.getLoc (), format (ValidateErrorMessage::UNDEFINED_UN_OP_TOK, un.getLoc ().str));
            }
        }
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================            MINUS             =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a minus unary expression
     * @params: 
     *    - context: the context of the validation
     *    - un: the unary operator to validate
     * @returns: a value
     * @throws: 
     *   - &ErrorMsg: if there is an error in the validation       
     */
    fn validateMinusOperator (self, dmut context : &Validator, un : &UnaryExpr)-> &Value
        throws ErrorMsg
    {
        let value = context.implicitEnumUnwrap (context:.validateValue (un.getOperand ()));
        match value.getType () { // minus operator works only on int and float operands
            it : &IntType => {
                if (!it.isSigned ()) {
                    throw copy ErrorMsg::fatal (un.getLoc (), format (ValidateErrorMessage::UNDEFINED_UN_OP, un.getLoc ().str, it));
                }

                let ret = copy UnaryIntOperatorValue (un.getLoc (), value.getType (), UnaryOperators::MINUS, value);
                let x = context:.getCompileTimeInterpreter ():.reduce (ret);
                match (x, x.getType ()) {
                    (i : &IntValue, t : &IntType) => {
                        context:.getCompileTimeInterpreter ().verifyOverFlowInt (un.getLoc (), t, i.getValue ());
                    }
                }
                x
            }
            FloatType () => {
                copy UnaryFloatOperatorValue (un.getLoc (), value.getType (), UnaryOperators::MINUS, value)
            }
            c : &ClassPtrType => {
                self.validateClassOp (alias context, un.getLoc (), UnaryOperators::MINUS, c, value)
            }
            _ => {
                throw copy ErrorMsg::fatal (un.getLoc (), format (ValidateErrorMessage::UNDEFINED_UN_OP, un.getLoc ().str, value.getType ()));
            }
        }
    }
    
    
    /*!
     * ================================================================================
     * ================================================================================
     * =========================             AND              =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate an and unary expression
     * @params: 
     *    - context: the context of the validation
     *    - un: the unary operator to validate
     * @returns: a value
     * @throws: 
     *   - &ErrorMsg: if there is an error in the validation       
     */
    fn validateAndOperator (self, dmut context : &Validator, un : &UnaryExpr)-> &Value
        throws ErrorMsg
    {
        let value = context:.validateValue (un.getOperand (), noReduce-> true);
        match value {
            m : &MethodDelegateValue => {
                return self.validateFunctionPointerFromMethodDg (alias context, un.getLoc (), un, m);
            }
            p : &PrototypeValue => {
                return self.validateFunctionPointerFromProto (alias context, un.getLoc (), p);
            }
            _ => {
                context.verifyLeftOperandMove (un.getLoc (), value, allowImmutable-> true, allowSelf-> true);

                // If we can make a ref, but not when immutable is not allowed,
                // therefore the ref is of a param,iter,closure, etc.
                // And cannot be made mutable
                let innerType = if (!context.checkLeftOperandMove (value, allowImmutable-> false, allowSelf-> true)) {
                    value.getType ().clone (0u32)
                } else {
                    value.getType ()
                };

                let ptr = copy PointerType (un.getLoc (), innerType, isMutable-> true);
                copy AddressValue (un.getLoc (), ptr, value)
            }
        }
    }


    /**
     * Validate an and unary operator on a method delegate
     * @params:
     *    - context: the context of the validation
     *    - loc: the location of the operation
     *    - m: the delegate value
     * @returns: a value
     * @throws:
     *    - &ErrorMsg: if the validation fails
     * */
    fn validateFunctionPointerFromMethodDg (self, dmut context : &Validator, loc : &Word, un : &UnaryExpr, m : &MethodDelegateValue)-> &Value
        throws ErrorMsg
    {
        if (m.isAddressed ()) {
            throw copy ErrorMsg::fatal (m.getAddressedLoc (), format (ValidateErrorMessage::UNECESSARY_ADDRESS_METHOD));
        }


        if (m.getPrototype ().getThrowers ().len != 0us) {
            let notes = copy [copy ErrorMsg::note (i._0, format (ValidateErrorMessage::THROWING, i._1))
                                  for i in m.getPrototype ().getThrowers ()];

            throw copy ErrorMsg::fatal (loc, format (ValidateErrorMessage::FUNCTION_TO_FPTR_THROWING, m, tags-> FormatTags (withParams-> true)),
                                        notes-> notes);
        }

        if (m.getPrototype ().isUnsafe ()) {
            throw copy ErrorMsg::fatal (loc, format (ValidateErrorMessage::FUNCTION_TO_FPTR_UNSAFE, m, tags-> FormatTags (withParams-> true)));
        }

        if (m.getClosure ().getType ().isMovable ()) {
            throw copy ErrorMsg::fatal (loc, format (ValidateErrorMessage::FUNCTION_TO_FPTR_ENTITY));
        }

        if (m.isStruct ()) {
            if (!context.isDynamic (un)) {
                throw copy ErrorMsg::fatal (loc, format (ValidateErrorMessage::FUNCTION_TO_FPTR_RECORD),
                                       notes-> copy [copy ErrorMsg::note (loc, format (ValidateErrorMessage::ENCLOSE_COPY_LST_COMPR), oneLine-> true)]);
            } else if (context.isDynamicDeep ()) {
                throw copy ErrorMsg::fatal (loc, format (ValidateErrorMessage::FUNCTION_TO_FPTR_RECORD_DCOPY),
                                       notes-> copy [copy ErrorMsg::note (context.getDynamicExpr ().getLoc (), format (ValidateErrorMessage::SIMPLE_COPY_CLASS_CTOR))]);
            }
        }
        
        return m.cloneAsAddressed (loc);
    }

    /**
     * Validate an and unary operator on a prototype value
     * @params:
     *    - context: the context of the validation
     *    - loc: the location of the operation
     *    - p: the prototype value
     * @returns: a value
     * @throws:
     *    - &ErrorMsg: if the validation fails
     * */
    pub fn validateFunctionPointerFromProto (self, dmut _ : &Validator, loc : &Word, p : &PrototypeValue)-> &Value
        throws ErrorMsg
    {
        // only function can be used not child classes of prototype (method, lambda, dtor, ctors, ...)
        let isFunc = match p {
            CtorPrototypeValue () => { false }
            DtorPrototypeValue () => { false }
            MethodPrototypeValue () => { false }
            NamePrototypeValue () => { false }
            _ => { true }
        };

        if (!isFunc) {
            throw copy ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_UN_OP, loc.str, p, tags-> FormatTags (withParams-> true)));
        }

        if (p.getThrowers ().len != 0us) {
            let notes = copy [copy ErrorMsg::note (i._0, format (ValidateErrorMessage::THROWING, i._1))
                              for i in p.getThrowers ()];
            throw copy ErrorMsg::fatal (loc, format (ValidateErrorMessage::FUNCTION_TO_FPTR_THROWING, p, tags-> FormatTags (withParams-> true)), notes-> notes);
        }

        if (p.isUnsafe ()) {
            throw copy ErrorMsg::fatal (loc, format (ValidateErrorMessage::FUNCTION_TO_FPTR_UNSAFE, p, tags-> FormatTags (withParams-> true)));
        }

        let types = copy [v.getType () for v in p.getParameters ()];
        let references = copy [v.isReference () for v in p.getParameters ()];
        let lazys = copy [v.isLazy () for v in p.getParameters ()];
        let retType = p.getRetType ();

        copy ProtoFuncPtrValue (loc, p, references, lazys, types, retType)
    }
    
    /*!
     * ================================================================================
     * ================================================================================
     * =========================             STAR             =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a star unary expression
     * @params: 
     *    - context: the context of the validation
     *    - un: the unary operator to validate
     * @returns: a value
     * @throws: 
     *   - &ErrorMsg: if there is an error in the validation       
     */
    fn validateStarOperator (self, dmut context : &Validator, un : &UnaryExpr)-> &Value
        throws ErrorMsg
    {
        let value = context.implicitEnumUnwrap (context:.validateValue (un.getOperand ()));
        match value.getType () {
            p : &PointerType => {
                return self.validateDerefPointer (alias context, un.getLoc (), p, value);
            }
            _ => {
                throw copy ErrorMsg::fatal (un.getLoc (), format (ValidateErrorMessage::UNDEFINED_UN_OP, un.getLoc ().str, value.getType ()));
            }
        }
    }

    /**
     * Validate a deref on a pointer value
     * @params:
     *    - context: the context of the validation
     *    - un: the unary operator to validate
     * @returns: a value
     * @throws:
     *    - &ErrorMsg: if there is an error in the validation
     * */
    fn validateDerefPointer (self, dmut context : &Validator, loc : &Word, ptype : &PointerType, value : &Value)-> &Value
        throws ErrorMsg
    {
        context:.verifyUnsafeContext (loc);

        let retType =
            if (!value.isLvalue ()) {
                ptype.getInners ()[0].clone (0u32)
            } else {
                ptype.getInners ()[0]
            };

        if (retType of VoidType) {
            throw copy ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_UN_OP, loc.str, ptype));
        }

        return copy DereferencerValue (value.getLoc (), retType, value);
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================             NOT              =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a not unary expression
     * @params:
     *    - context: the context of the validation
     *    - un: the unary operator to validate
     * @returns: a value
     * @throws:
     *   - &ErrorMsg: if there is an error in the validation
     */
    fn validateNotOperator (self, dmut context : &Validator, un : &UnaryExpr)-> &Value
        throws ErrorMsg
    {
        let value = context.implicitEnumUnwrap (context:.validateValue (un.getOperand ()));
        self.validateNotOperator (alias context, un.getLoc (), value)
    }

    /**
     * Validate a not unary expression
     * @params:
     *    - context: the context of the validation
     *    - value: the value operand that is negated
     * @returns: a value
     * @throws:
     *   - &ErrorMsg: if there is an error in the validation
     */
    pub fn validateNotOperator (self, dmut context : &Validator, loc : &Word, value : &Value)-> &Value
        throws ErrorMsg
    {
        match value.getType () {
            IntType () => {
                let ret = copy UnaryIntOperatorValue (loc, value.getType (), UnaryOperators::NOT, value);
                let x = context:.getCompileTimeInterpreter ():.reduce (ret);
                match (x, x.getType ()) {
                    (i : &IntValue, t : &IntType) => {
                        context:.getCompileTimeInterpreter ().verifyOverFlowInt (loc, t, i.getValue ());
                    }
                }
                x
            }
            BoolType () => {
                copy UnaryBoolOperatorValue (loc, UnaryOperators::NOT, value)
            }
            c : &ClassPtrType => {
                self.validateClassOp (alias context, loc, UnaryOperators::NOT, c, value)
            }
            _ => {
                throw copy ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_UN_OP, UnaryOperators::NOT, value.getType ()));
            }
        }
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =====================             CLASS/STRUCT              ====================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate an op override on a class value
     * @params:
     * */
    fn validateClassOp (self, dmut context : &Validator, loc : &Word, op : UnaryOperators, cptr : &ClassPtrType, value : &Value)-> &Value
        throws ErrorMsg
    {
        {
            let str = makeStringSliceValue (loc, op);
            let meth = context:.constructObjectMethodAcc (loc, cptr, value, OpOverrideNames::UNARY);
            let templ = context:.getValueValidator ().validateTemplateCall (alias context, loc, meth, copy [str]);

            context:.getCallOpValidator ().validate (alias context, loc, templ, [])
        } catch {
            err : &ErrorMsg => { // In case of error show the location of the rewrite for clearer errors
                throw copy ErrorMsg::note (loc, ValidateErrorMessage::VALIDATING, notes-> copy [err]);
            }
        }
    }

}
