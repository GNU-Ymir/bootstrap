mod ymirc::semantic::validator::operator::mult;

import ymirc::semantic::validator::visitor;
import ymirc::semantic::validator::errors;
import ymirc::semantic::validator::scores;
import ymirc::errors::_;
import ymirc::utils::format;
import ymirc::syntax::expression::_;
import ymirc::semantic::generator::value::_;
import ymirc::semantic::generator::type::_;
import ymirc::semantic::generator::value::expandvalue;
import ymirc::lexing::word;
import ymirc::lexing::tokens;
import ymirc::syntax::keys;


import std::collection::vec;
import std::io;

/**
 * The mult validator is used to validate MultOpExpr
 * It is a class validator because mult operation are complex
 */
pub class MultOpValidator {

    /**
     * Create an empty validator     
     */
    pub self () {}

    /**
     * Validate a mult expression
     * @params: 
     *  - context: the context of the validation
     *  - mult: the mult operator to validate
     * @returns: a value
     * @throws: &ErrorMsg, if the validation failed
     */
    pub def validate (self, dmut context : &Validator, mult : &MultOperatorExpr) -> &Value
        throws &ErrorMsg
    {
        let (left, rightDot) = self.validateLeftOperand (alias context, mult.getLeft (), mult.canBeDotCall ());
        let rights = self.validateRightOperands (alias context, mult.getRights (), rightDot);

        let (res, _) = match left {
            m : &MultSymValue => { // Mult syms are flattened
                self.validateMultSym (alias context, mult.getLoc (), m, rights)
            }
            _ => {
                self.validate (alias context, mult.getLoc (), left, rights)
            }
        }

        res
    }
    
    /**
     * ================================================================================
     * ================================================================================
     * =========================         LEFT OPERAND         =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate the left operand of the mult operator
     * @params: 
     *   - context: the context of the validation
     *   - left: the left operand to validate
     *   - canBeDotCall: true iif the left expression can be a dot call syntax
     * @returns: 
     *   - .0: the value of the left operand
     *   - .1: the list of parameters to add to the right operand (applicable only iif dot call)
     */
    def validateLeftOperand (self, dmut context : &Validator, left : &Expression, canBeDotCall : bool)-> (&Value, [&Value])
        throws &ErrorMsg
    {
        {
            let l = context:.validateValue (left);
            return (l, []);
        } catch {
            err : &ErrorMsg => {
                if (canBeDotCall) { // If left was not correct, maybe it is a dotCall syntax
                    return self.validateDotCall (alias context, left, err);                    
                } else throw err;
            }
        }
    }

    /**
     * Try to validate a dot call expression
     * @params: 
     *   - context: the context of the validation
     *   - left: the left operand of the mult operation
     *   - err: the error that occured when validating without trying dot call
     * @returns: 
     *   - .0: the left operand of the expression
     *   - .1: the list of parameters to add to the mult operators (len == 1us, or throws)
     * @throws: &ErrorMsg, if this is not a dot call
     */
    def validateDotCall (self, dmut context : &Validator, left : &Expression, err : &ErrorMsg)-> (&Value, [&Value])
        throws &ErrorMsg
    {
        let (leftSynt, rightSynt) = self.rewriteDotCallSyntax (alias context, left, err);
        let lval = {
            context:.validateValue (leftSynt)
        } catch {
            // Just throw the error passed as parameter, it should be almost the same, so no need to add an error
            ErrorMsg () => throw err; 
        };

        let rval = {
            context:.validateValue (rightSynt)
        } catch {
            rerr : &ErrorMsg => {
                // We add the error, in case the user really wanted a dot call but the function is miswritten or something
                let note = ErrorMsg::note (rightSynt.getLoc (), ValidateErrorMessage::UFC_REWRITING, notes-> [rerr]);
                throw ErrorMsg::list ([note, err]);
            }
        };

        (rval, [lval])
    }

    /**
     * Try to transform unwrap 'left' to get two elements for dot call validation      
     * @params:
     *    - context: the context of the validation
     *    - left: the left operand of the mult operation
     *    - err: the error to throw if the unwrapping fails
     * @returns: 
     *    - .0: the first parameter of the call (element on the left of the dot call)
     *    - .1: the function to call 
     * @throws: 
     *   - &ErrorMsg: parameter err, if the unwrap fails, and thus this is not a dot call
     */
    def rewriteDotCallSyntax (self, dmut _ : &Validator, left : &Expression, err : &ErrorMsg)-> (&Expression, &Expression)
        throws &ErrorMsg
    {
        match left {
            bin : &BinaryExpr => { 
                if (bin.getLoc () == Tokens::DOT_AND) { // rewrite (a:.b)
                    let intr : &Expression = IntrinsicExpr::new (left.getLoc (), IntrinsicKeys::ALIAS, bin.getLeft ());
                    (intr, bin.getRight ())               
                } else { // rewritte (a.b)
                    (bin.getLeft (), bin.getRight ())
                }
            }
            t : &TemplateCallExpr => {
                match t.getLeft () { 
                    bin : &BinaryExpr => { 
                        if (bin.getLoc () == Tokens::DOT_AND) { // rewritte ( (a:.b)!{params} )
                            let intr : &Expression = IntrinsicExpr::new (left.getLoc (), IntrinsicKeys::ALIAS, bin.getLeft ());
                            let right : &Expression = TemplateCallExpr::new (t.getLoc (), bin.getRight (), t.getRights ());
                            (intr, right)               
                        } else { // rewritte ( (a.b)!{params} )
                            let right : &Expression = TemplateCallExpr::new (t.getLoc (), bin.getRight (), t.getRights ());
                            (bin.getLeft (), right)
                        }
                    }
                    _ => throw err;                    
                }
            }
            _ => throw err;
        }
    }
    
    /**
     * ================================================================================
     * ================================================================================
     * =========================       RIGHT OPERANDS         =========================
     * ================================================================================
     * ================================================================================
     */


    /**
     * Validate the right operands
     * @params: 
     *   - context: the context of the validation
     *   - rightOps: the list of right operands
     *   - validated: the list of values already validated by Dot call syntax
     * @returns: the list of right operands
     */
    def validateRightOperands (self, dmut context : &Validator, rightOps : [&Expression], validated : [&Value])-> [&Value]
        throws &ErrorMsg
    {
        let dmut errors = Vec!{&ErrorMsg}::new ();
        let dmut rights = Vec!{&Value}::new ();
        
        for r in validated { rights:.push (r); }        
        for r in rightOps {
            {
                let v = context:.validateValue (r);
                match v {
                    e : &ExpandValue => {
                        for i_v in e.getInnerValues () rights:.push (i_v); 
                    }
                    _ => {
                        rights:.push (v);
                    }
                }            
            } catch {
                err : &ErrorMsg => {
                    errors:.push (err);
                }
            }
        }

        if (errors.len () != 0us) throw ErrorMsg::list (errors[]);

        rights []
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================           MULTSYM            =========================
     * ================================================================================
     * ================================================================================
     */
    
    /**
     * Validate the calling where the values left and rights are already validated, and the left value is a multsym
     * @params: 
     *   - context: the context of the validation
     *   - loc: the location of the operator
     *   - left: the left operand
     *   - rights: the right operands
     * @returns: 
     *   - .0: a value
     *   - .1: the score of the validation
     * @throws: if the operation is impossible
     */
    def validateMultSym (self, dmut context : &Validator, loc : &Word, left : &MultSymValue, rights : [&Value])-> (&Value, u32)
        throws &ErrorMsg
    {
        context;
        loc;
        left;
        rights;
        __pragma!fake_throw (&ErrorMsg);
        __pragma!panic ();
    }

    
    /**
     * ================================================================================
     * ================================================================================
     * =========================           CALLING            =========================
     * ================================================================================
     * ================================================================================
     */


    /**
     * Validate the calling where the values left and rights are already validated
     * @params: 
     *   - context: the context of the validation
     *   - loc: the location of the operator
     *   - left: the left operand
     *   - rights: the right operands
     * @returns: 
     *   - .0: a value
     *   - .1: the score of the validation
     * @throws: if the operation is impossible
     */
    def validate (self, dmut context : &Validator, loc : &Word, left : &Value, rights : [&Value], candidate : bool = true)-> (&Value, u32)
        throws &ErrorMsg
    {
        match left.getType () {
            FuncPtrType () => { self.validateFuncPtrType (alias context, loc, left, rights, candidate-> candidate) }
            DelegateType () => { self.validateDelegateType (alias context, loc, left, rights, candidate-> candidate) }
            _ => {                    
                match left {
                    f : &PrototypeValue => {
                        self.validatePrototype (alias context, loc, f, rights, candidate-> candidate)
                    }
                    v : &VarRefValue => {
                        if (!v.getValue ().isOf!{&NoneValue} ()) {
                            self.validate (alias context, loc, v.getValue (), rights, candidate-> candidate)
                        } else {
                            throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_CALL_OP, self.prettyName (left), rights))
                        }
                    }
                    _ => {
                        throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_CALL_OP, self.prettyName (left), rights))
                    }
                    // c : &ConstructorValue => {}
                    // l : &LambdaValue => {}
                    // t : &TemplateRefValue => {}
                }
            }
        }
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================     FUNCTION PROTOTYPE       =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a function prototype call
     * @params: 
     *    - context: the context of the validation
     *    - loc: the location of the call
     *    - left: the left operand
     *    - rights: the right operands
     *    - candidate: add the candidate_are not in case of failure ?
     * @returns: 
     *   - .0: the call
     *   - .1: the score of the call
     * @throws: &ErrorMsg, if the call is not possible
     */
    def validatePrototype (self, dmut context : &Validator, loc : &Word, left : &PrototypeValue, rights : [&Value], candidate : bool = false)-> (&Value, u32)
        throws &ErrorMsg
    {        
        let (params, rest) = self.validateParameterList (left.getParameters (), rights);        
        if (rest.len != 0us && !left.isCVariadic ()) {
            let dmut err = Vec!{&ErrorMsg}::new ();
            for it in rest {
                match it {
                    n : &NamedValue => {
                        err:.push (ErrorMsg::fatal (it.getLoc (), format (ValidateErrorMessage::NO_PARAMETER_NAMED, n.getName ())));
                    }
                }
            }

            if ((params.len + rest.len) != left.getParameters ().len) {
                throw ErrorMsg::fatal (loc, format (if (params.len + rest.len == 1us)  { ValidateErrorMessage::TOO_FEW_PARAMETERS_ONE } else { ValidateErrorMessage::TOO_FEW_PARAMETERS}, left.getParameters ().len, params.len + rest.len), notes-> err[]);
            } else {
                throw ErrorMsg::list (err[]);
            }
        } else if (params.len != left.getParameters ().len) {
            throw ErrorMsg::fatal (loc, format (if (params.len == 1us)  { ValidateErrorMessage::TOO_FEW_PARAMETERS_ONE } else { ValidateErrorMessage::TOO_FEW_PARAMETERS}, left.getParameters ().len, params.len));
        }

        let (_, score) = self.validateTypeParameterList (alias context, loc, left.getParameters (), params, verifType-> true, verifMemory-> true, isLambda-> false);
        
        (CallValue::new (loc, left.getRetType (), left, params, addParams-> rest), score) 
    } catch {
        err : &ErrorMsg => {
            if (!candidate) throw err;
            throw ErrorMsg::note (left.getLoc (), format (ValidateErrorMessage::CANDIDATE_ARE, left.getLoc (), left), notes-> [err]);
        }
    }

    /**
     * Validate the list of parameters 
     * @params: 
     *   - arguments: the list of parameters of the prototype
     *   - parameters: the list of values passed to the call
     * @returns: 
     *   - .0: the list of parameters (in the correct order)
     *   - .1: the list of parameters that are associated to no arguments (in the correct order)
     */
    def validateParameterList (self, arguments : [&ProtoVarValue], parameters : [&Value])-> ([&Value], [&Value])
        // throws &ErrorMsg
    {
        let dmut result = Vec!{&Value}::new ();
        let mut rest = parameters;
        for i in 0us .. arguments.len {
            let indexes = self.findParameter (rest, arguments [i]);
            if (indexes.len == 0us) return (result[], rest);
            
            if indexes.len != 1us { __pragma!panic (); }
            for index in indexes {
                result:.push (index._1);
                rest = rest [0us .. index._0] ~ rest [(index._0 + 1us) .. $];
            }
        }

        (result[], rest)
    }

    /**
     * Validate the type of the parameters
     * @params: 
     *   - context: the context of the validation
     *   - loc: the location of the call
     *   - arguments: the list of arguments of the prototype
     *   - parameters: the list of parameters passed to the prototype
     *   - verifType: verify the equality of the types
     *   - verifMemory: verify that the memory const, alias, etc are respected
     *   - isLambda: the prototype is a lambda prototype
     * @returns: 
     *   - .0: the list of types of the parameters
     *   - .1: the score of the call
     */
    def validateTypeParameterList (self, dmut context : &Validator, loc : &Word, arguments : [&ProtoVarValue], parameters : [&Value], verifType : bool = true, verifMemory : bool = true, isLambda : bool = false)-> ([&Type], u32)
        throws &ErrorMsg
    {
        let dmut types = Vec!{&Type}::new ();
        let dmut errors = Vec!{&ErrorMsg}::new ();
        let mut score = 0u32;

        for i in 0us .. arguments.len {
            let argType = arguments[i].getType ();
            let paramType = parameters [i].getType ();
            
            if (isLambda && argType.isOf!{&NoneType} ()) {
                types:.push (parameters [i].getType ().clone (isMutable-> false));
            } else {
                {
                    if (verifType) {
                        context:.verifyCompatibleTypeWithValue (parameters [i].getLoc (), argType, parameters [i]);
                    }

                    if (verifMemory) {
                        context:.verifyMemoryOwner (parameters [i].getLoc (), argType, parameters [i], construct-> true, checkTypes-> false);
                    }
                    
                    score += Scores::TYPE;
                    let llevel = paramType.mutabilityLevel ();
                    let rlevel = argType.mutabilityLevel () + 1u32;
                    if (rlevel > llevel) {
                        score += rlevel - llevel;
                    }
                } catch {
                    err : &ErrorMsg => {
                        errors:.push (err.withNote ([ErrorMsg::note (loc, format (ValidateErrorMessage::PARAMETER_NAME, arguments [i].getName ()), oneLine-> true)]));
                    }
                }
            }
        }

        if (errors.len () != 0us) throw ErrorMsg::list (errors[]);

        (types[], score)
    }


    /**
     * Find the parameter in the list that is associated to the var
     * @params: 
     *   - parameters: a list of value that are passed to the call
     *   - var: the protovar that is called
     */
    def findParameter (self, parameters : [&Value], var : &ProtoVarValue)-> [(usize, &Value)] {
        if (var.getNbConsume () == 1us) { // non template validation        
            let (i, v) = self.findSingleParameter (parameters, var);
            match v {
                NoneValue () => { [] }
                _ => { [(i, v)] }
            }
        } else {
            __pragma!panic ();
        }
    }
    
    /**
    
     */
    def findSingleParameter (self, parameters : [&Value], var : &ProtoVarValue, canBeNamed : bool = true)-> (usize, &Value) {
        let mut toRet = parameters.len, mut pos = true;
        for i, p in parameters {
            match p {
                n : &NamedValue => {
                    if (n.getName () == var.getName () && canBeNamed) {
                        toRet = i;
                        pos = false;
                        break {}
                    }
                }
                _ => {
                    if (toRet == parameters.len) {
                        toRet = i;
                    }
                }
            }
        }

        if (toRet == parameters.len || pos) {
            if (!var.getDefaultValue ().isOf!{&NoneValue} ()) {
                return (parameters.len, var.getDefaultValue ());
            }
        }

        if (toRet != parameters.len) {
            (toRet, parameters [toRet])
        } else {
            (parameters.len, NONE_VALUE)
        }
    }
    
    
    /**
     * ================================================================================
     * ================================================================================
     * =========================      FPTR AND DELEGATE       =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a function pointer call
     * @params: 
     *    - context: the context of the validation
     *    - loc: the location of the call
     *    - left: the left operand
     *    - rights: the right operands
     *    - candidate: add the candidate_are not in case of failure ?
     * @returns: 
     *   - .0: the call
     *   - .1: the score of the call
     * @throws: &ErrorMsg, if the call is not possible
     */
    def validateFuncPtrType (self, dmut context : &Validator, loc : &Word, left : &Value, rights : [&Value], candidate : bool = false)-> (&Value, u32)
        throws &ErrorMsg
    {
        context;
        loc;
        left;
        rights;
        candidate;
        __pragma!fake_throw (&ErrorMsg);
        __pragma!panic ();
    }
    
    /**
     * Validate a delegate call
     * @params: 
     *    - context: the context of the validation
     *    - loc: the location of the call
     *    - left: the left operand
     *    - rights: the right operands
     *    - candidate: add the candidate_are not in case of failure ?
     * @returns: 
     *   - .0: the call
     *   - .1: the score of the call
     * @throws: &ErrorMsg, if the call is not possible
     */
    def validateDelegateType (self, dmut context : &Validator, loc : &Word, left : &Value, rights : [&Value], candidate : bool = false)-> (&Value, u32)
        throws &ErrorMsg
    {
        context;
        loc;
        left;
        rights;
        candidate;
        __pragma!fake_throw (&ErrorMsg);
        __pragma!panic ();
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================             MISC             =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Transform a value into a printable string, with correct debug informations
     * @params: 
     *    - v: the value 
     * @returns: a string, that can be put in an error message
     */
    def prettyName (self, v : &Value)-> [c8] {
        match v {
            vdecl : &VarDeclValue => {
                match v.getType () {
                    LambdaType () => {
                        return format ("%", vdecl.getValue ());
                    }
                }
            }
            vref : &VarRefValue => {
                match v.getType () {
                    LambdaType () => {
                        return format ("%", vref.getValue ());
                    }
                }
            }
        }
        
        format ("%", v)
    }

    
}
