mod ymirc::semantic::validator::operator::mult;

import ymirc::semantic::validator::visitor;
import ymirc::semantic::validator::errors;
import ymirc::errors::_;
import ymirc::utils::format;
import ymirc::syntax::expression::_;
import ymirc::semantic::generator::value::base;

import std::io;

/**
 * The mult validator is used to validate MultOpExpr
 * It is a class validator because mult operation are complex
 */
pub class MultOpValidator {

    /**
     * Create an empty validator     
     */
    pub self () {}

    /**
     * Validate a mult expression
     * @params: 
     *  - context: the context of the validation
     *  - mult: the mult operator to validate
     * @returns: a value
     * @throws: &ErrorMsg, if the validation failed
     */
    pub def validate (self, dmut context : &Validator, mult : &MultOperatorExpr) -> &Value
        throws &ErrorMsg
    {
        let left = self.validateLeftOperand (alias context, mult.getLeft (), mult.canBeDotCall ());
        println (left);
        
        __pragma!panic ();
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================         LEFT OPERAND         =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate the left operand of the mult operator
     * @params: 
     *   - context: the context of the validation
     *   - left: the left operand to validate
     *   - canBeDotCall: true iif the left expression can be a dot call syntax
     * @returns: 
     *   - .0: the value of the left operand
     *   - .1: the list of parameters to add to the right operand (applicable only iif dot call)
     */
    def validateLeftOperand (self, dmut context : &Validator, left : &Expression, canBeDotCall : bool)-> (&Value, [&Value])
        throws &ErrorMsg
    {
        {
            let l = context:.validateValue (left);
            return (l, []);
        } catch {
            err : &ErrorMsg => {
                if (canBeDotCall) {
                    return self.validateDotCall (alias context, left, err);                    
                } else throw err;
            }
        }
    }

    /**
     * Try to validate a dot call expression
     * @params: 
     *   - context: the context of the validation
     *   - left: the left operand of the mult operation
     *   - err: the error that occured when validating without trying dot call
     * @returns: 
     *   - .0: the left operand of the expression
     *   - .1: the list of parameters to add to the mult operators (len == 1us, or throws)
     * @throws: &ErrorMsg, if this is not a dot call
     */
    def validateDotCall (self, dmut context : &Validator, left : &Expression, err : &ErrorMsg)-> (&Value, [&Value])
        throws &ErrorMsg
    {
        context;
        left;
        throw err;        
    }
    
    
    
}
