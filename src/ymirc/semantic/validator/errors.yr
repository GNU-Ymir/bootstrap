in errors;

/**
 * All the error messages that can occur in symbol validation
 */
pub enum
| AKA_CLASS_CTOR                            = "a name alias cannot be created to alias class ctors"
| ALREADY_CAUGHT                            = "Exception type %(y) is already caught by another catching pattern of type %(y)"
| ALREADY_INIT_BY_CTOR_REDIRECT             = "field %(y) was already initialized by ctor redirection"
| ARRAY_OVERFLOW                            = "slice access, index overflow %(y) (len) <= %(y) (index)"
| ARRAY_PATTERN_SIZE                        = "array pattern match len %(y) never matches the value len %(y)"
| ATOMIC_NEEDS_MONITOR                      = "@(r=atomic) operation can only monitor object instances"
| BRANCHING_VALUE                           = "when validating conditional value"
| BREAK_NO_LOOP                             = "break statement is not within a loop"
| BREAK_SCOPE_GUARD                         = "cannot break loop inside a scope guard"
| CALL_BEGIN_ONE_LINE                       = "rewritten into let @(r=dmut) @(y=#_iter) = %(y).begin ()"
| CALL_GET_OP_ITERATOR                      = "calling the @(y=get) method for iterator %(y) with template parameters {%(y), %(y)}"
| CALL_GET_OP_ONE_LINE                      = "rewritten into %(y) = %(y).get!{%(y), %(y)} ()"
| CALL_LEN_ONE_LINE                         = "rewritten into let @(y=#_len) = %(y).len ()"
| CALL_NEXT_OP_ITERATOR                     = "calling the @(y=next) method for iterator %(y)"
| CALL_NEXT_OP_ONE_LINE                     = "rewritten into %(y) = %(y).next ()"
| CALL_PROTO                                = "calling %(y)"
| CANDIDATE_ARE                             = "candidate %(y)"
| CANNOT_CASTTO_BASE_CLASS                  = "cannot cast derived type %(y) to base class type %(y) in that context"
| CATCH_NOTHING                             = "Catching pattern of type %(y) catch no exceptions"
| CATCH_PATTERN_MULT_OR_VDECL               = "The pattern of a catch scope guard must start with a variable declaration or a field deconstructor"
| CATCH_VALIDATION                          = "when validating catching pattern with type %(y)"
| CLASS_ALIAS_FIELD                         = "class alias operator @(y=:.) is not usable to access fields"
| CLASS_ALIAS_FIELD_NO_CLASS                = "alias operator @(y=:.) is only usable on class, record, entity or map types, not %(y)"
| CLASS_ALIAS_INDEX_NO_CLASS                = "class alias operator @(y=:[) is only usable on class, record or entity types, not %(y)"
| CLASS_FIELD_NOT_INIT_YET                  = "field %(y) has not yet been initialized"
| CLASS_FIELD_NOT_VALIDATED_YET             = "field %(y) has not yet been validated"
| CLASS_NOT_IMPL                            = "class type %(y) does not implement trait %(y)"
| CLASS_NO_FIELD                            = "class %(y) has no field named %(y)"
| CLASS_NO_METHOD                           = "class %(y) has no method named %(y)"
| CLASS_THROW_PTR                           = "class type excepted, not the class object instance type %(y) (i.e. the @(y=&) is useless)"
| CLOSURE_TEMPLATE_LAMBDA                   = "closure functions cannot be used as template values"
| COLLIDING_METHOD_DEFINITION               = "colliding method definitions %(y) and %(y)"
| COLLIDING_FUNCTION_DEFINITION             = "colliding function definitions %(y) and %(y)"
| CONFLIT_DECORATORS                        = "conflicting decorators %(y) and %(y)"
| CONSTRUCT_ABSTRACT_CLASS                  = "cannot construct an instance of class %(y) that is abstract"
| CONST_METHOD                              = "method %(y) is defined as constant"
| CONTAIN_MOVABLE_TYPE                      = "movable type %(y) cannot be embedded within another type"
| CONTAIN_ALIASABLE_TYPE                    = "type %(y) cannot be embedded within an union type"
| CONTAIN_ALIASABLE_TYPE_NOTE               = "union cannot contain aliasable types, with the exceptions of pointer types"
| CONTAIN_MOVABLE_TYPE_NOTE                 = "only an entity type can contain another entity type"
| CONTAIN_MOVABLE_TYPE_RECORD               = "the structure is defined as a record but must be an entity to store movable values"
| CTE_ASSERT_NO_MSG                         = "cte assertion failed"
| CTE_ASSERT_WITH_MSG                       = "cte assertion failed %(y)"
| CTE_IGNORED                               = "%(y) values contained in block scope are ignored at compile time execution"
| CTOR_CLASS_DCOPY                          = "using deep copy instead of on level copy is prohibited when constructing class %(y)"
| CTOR_CLASS_STACK                          = "creating an instance of class %(y) on the stack is prohibited"
| CTOR_INFINITE_REDIRECTION                 = "infinite constructor redirection calls when calling %(y)"
| CTOR_MAP_DCOPY                            = "using deep copy instead of on level copy is prohibited when constructing a map %(y)"
| CTOR_MAP_STACK                            = "creating an instance of map %(y) on the stack is prohibited"
| DECLARED_HERE                             = "declared here"
| DECLARED_NOT_USED                         = "the symbol %(y) was declared but never used"
| DECLARE_VOID_VAR                          = "cannot declare a variable of type %(y)"
| DECREASING_RANGE_ACCESS                   = "range index cannot be decreasing for type %(y), but goes from %(y) to %(y)"
| DEEPLY_INNER_TYPE                         = "decorator is not applicable on inner types, already deeply mutable"
| DEFAULT_VAR_NO_NAME                       = "parameter with a default value must have a referencaable name"
| DEFINED_HERE                              = "defined here"
| DISCARD_CONST                             = "discard the constant property is prohibited"
| DISCARD_CONST_LEVEL_TYPES                 = "from %(y) to %(y)"
| DIVISION_BY_ZERO                          = "division by 0"
| DOLLAR_OUTSIDE_CONTEXT                    = "'$' is usable only inside an index operation"
| DTOR_SELF_NOT_MUT                         = "the @(y=self) parameter must be mutable in the destructor"
| EMPTY_ARRAY_INNER                         = "array inner type cannot be %(y)"
| EMPTY_METHOD_NO_ABSTRACT                  = "%(y) is empty"
| ENCLOSE_COPY_CLASS_CTOR                   = "did you mean to enclose the constructor call within a @(y=copy) ?"
| ENCLOSE_COPY_LST_COMPR                    = "did you mean to enclose it within a @(y=copy) ?"
| ENCLOSE_INCOMPLETE_TYPE                   = "the type %(y) cannot be enclosed because it is not complete"
| ENCLOSE_MOVABLE_TYPE                      = "movable type %(y) cannot be enclosed within a closure function"
| ERROR_PARAM                               = "value %(y) is of type %(y)"
| EXCEPTION_NOT_CAUGHT                      = "scope guard does not catch exceptions of type %(y)"
| EXITING_SCOPE_HERE                        = "exiting scope here"
| EXIT_SCOPE_NO_THROW                       = "%(y) guard cannot be used when guarding a scope that cannot throw"
| EXIT_SCOPE_VALUE_TYPE                     = "%(y) scope guard value must be of type @(y=void), not %(y)"
| EXTERN_GLOBAL_NO_TYPE                     = "external global variable must be declared with a type"
| EXTERN_GLOBAL_WITH_VALUE                  = "external global variable cannot be declared with a value"
| FIELD_MATCHER_NO_NAME                     = "expected a name expression"
| FIELD_METHOD_PARAMS                       = "field method cannot have parameters"
| FIELD_METHOD_NO_RETURN                    = "field method must return a value"
| FIRST_DEFINED                             = "defined here"
| FORBID_DECO_FOR_LOOP                      = "decorators are forbidden for index iterator, on %(y) iteration"
| FORGET_AND_CLASS                          = "did you forget @(y=&) ?"
| FORGET_AND_PROTO                          = "or did you forget @(y=&)?"
| FORGET_PAR_PROTO_CALL                     = "did you forget %(y)?"
| FORWARD_REFERENCE_AKA                     = "the name alias %(y) cannot be validated due to forward reference"
| FORWARD_REFERENCE_TYPE                    = "the type cannot be validated due to forward reference"
| FORWARD_REFERENCE_VALUE                   = "the value cannot be computed, as it depends on a forward reference"
| FORWARD_REFERENCE_VAR                     = "the type cannot be infered, as it depends on a forward reference"
| FOR_FIELD                                 = "for the field %(y)"
| FOR_LOOP_CPTR                             = "overriding the for loop operation on a class type %(y)"
| FOR_PATTERN_FIELD                         = "for pattern field access %(y) on type %(y)"
| FOR_TYPE                                  = "within type %(y)"
| FUNCTION_TO_FPTR_THROWING                 = "cannot create a function pointer from the throwing function %(y)"
| FUNCTION_TO_FPTR_UNSAFE                   = "cannot create a function pointer from the unsafe function %(y)"
| FUNCTION_TO_FPTR_RECORD_DCOPY             = "using deep copy instead of on level copy is prohibited when enclosing a record"
| FUNCTION_TO_FPTR_RECORD                   = "cannot create a function pointer, it would enclose the record by reference"
| FUNCTION_TO_FPTR_ENTITY                   = "cannot create a function pointer, entities are not copiable"
| GLOBAL_NO_VALUE                           = "local global variable must be declared with a value"
| HERE                                      = "here"
| IF_COND_NOT_COMPLETE                      = "the if condition has no else value, so it must produce a @(y=void) value not a %(y)"
| IMMUTABLE_LVALUE                          = "left operand of type %(y) is immutable"
| IMMUTABLE_PARENT                          = "type must be immutable"
| IMPLICIT_ADDRESS_FUNCTION                 = "cannot create of a function pointer from %(y) implicitly"
| IMPLICIT_ADDRESS_METHOD                   = "cannot create of a delegate from the method %(y) implicitly"
| IMPLICIT_ALIAS                            = "implicit @(r=alias) of type %(y) is prohibited, it implicitly gives up on borrowings of mutable values"
| IMPLICIT_CONST_REFERENCE                  = "@(r=ref) of type %(y) must be const, but is mutable"
| IMPLICIT_LAZY                             = "cannot construct a lazy value of type %(y) implicitely"
| IMPLICIT_MOVE                             = "implicit @(r=move) of type %(y) is prohibited"
| IMPLICIT_MUT_REFERENCE                    = "@(r=ref) of type %(y) must be mutable, but is const"
| IMPLICIT_OVERRIDE                         = "method %(y) implicitly override method %(y)"
| IMPLICIT_OVERRIDE_BY_TRAIT                = "implicit override of method %(y) by trait @(y=impl)"
| IMPLICIT_REFERENCE                        = "cannot pass value of type %(y) as @(r=ref)"
| IMPL_MULTIPLE_TIMES                       = "trait %(y) is implemented multiple times by %(y)"
| IMPL_NO_TRAIT                             = "@(r=impl) statement must be followed by a trait, not %(y)"
| INCOMPATIBLE_TYPE                         = "incompatible types %(y) and %(y)"
| INCOMPATIBLE_VALUES                       = "incompatible values %(y) and %(y)"
| INCOMPLETE_TYPE                           = "the type %(y) is not complete"
| INCOMPLETE_TYPE_CLASS                     = "the type %(y) is not complete due to previous errors"
| INCOMPLETE_TYPE_CLREF                     = "type %(y) is a class"
| INDEX_ASSIGN_REWRITE                      = "when rewritting as index assign operator"
| INFINITE_LOOP                             = "infinite loop with always @(y=true) test is not allowed, rather use a @(y=loop) construct"
| INHERIT_FINAL_CLASS                       = "the base class %(y) is marked as final"
| INHERIT_NO_CLASS                          = "the base of a class must be a class, not a %(y)"
| INLINE_VIRTUAL_METHOD                     = "method %(y) cannot be inline as it is virtual (overridable or inherited)"
| INVALID_SYMBOLS                           = "symbol %(y) has errors"
| IN_MACRO_FINALIZATION                     = "during finalization of macro content: \n%\n%\n%"
| IS_AN_ENTITY                              = "%(y) is an entity type"
| IS_A_METHOD                               = "%(y) is a method and must be called from an instance"
| IS_A_RECORD                               = "%(y) is a record type"
| IS_NATIVE_TYPE                            = "the identifier %(y) describes a native type but has no meaning within this context"
| IS_NOT_CALLABLE                           = "call operator is not defined for value %(y)"
| LAZY_VALIDATION                           = "validation of lazy closure function fails to generate value of type %(y)"
| LIST_COMPR_SIZE_CTE                       = "The size of the list comprehension, constructed from type %(y), must be determinable at compile time"
| MACRO_CALL_VALIDATION_FAILED              = "validation of macro call failed"
| MACRO_DOES_NOT_MATCH                      = "macro call with \"%(y)\" does not match the rule \"%(y)\""
| MACRO_IN_CTOR                             = "in validation of macro constructor"
| MACRO_IN_RULE                             = "in validation of macro rule %(y)"
| MACRO_REST                                = "macro validation is not complete, rest some unassociated tokens \n%\n%\n%"
| MAIN_FUNCTION_ONE_ARG                     = "main function takes at most one argument"
| MAIN_INLINE                               = "main function cannot be inline"
| MALFORMED_CHAR                            = "malformed literal, number of %(y) is %(y)"
| MALFORMED_CORE                            = "core module is malformed"
| MALFORMED_FLOAT_LITERAL                   = "malformed float literal %(y)"
| MALFORMED_INT_LITERAL                     = "malformed int literal %(y)"
| MALFORMED_PRAGMA                          = "malformed __pragma %(y)"
| MAP_KEY_MUTABLE                           = "the type %(y) that is used as a map key must always be immutable"
| MAP_KEY_NOT_COMPARABLE                    = "the type %(y) cannot be used as a key, it is not comparable"
| MAP_KEY_NOT_HASHABLE                      = "the type %(y) cannot be used as a key, it is not hashable"
| MATCH_NOT_COMPLETE                        = "the pattern matching has no default case, so each branch must produce a @(y=void) value not a %(y)"
| MATCH_VALIDATION                          = "when validating pattern matching with value %(y) of type %(y)"
| MAX_LOOP_ITERATIONS                       = "reached the maximum number of cte iterations %(y) > %(y)"
| MAYBE_TYPE_AKA                            = "maybe a type name alias was meant (i.e. using the token @(y=:) instead of @(y==))"
| MISMATCH_ALIAS_EXPAND                     = "cannot alias an expand value, maybe @(y=alias) and @(y=expand) keywords are inverted ? (@(y=expand alias) V)"
| MISMATCH_ALIAS_LAZY                       = "cannot alias a lazy value, maybe @(y=alias) and @(y=lazy) keywords are inverted ? (@(y=lazy alias) V)"
| MISMATCH_COPY_EXPAND                      = "cannot copy an expand value, maybe @(y=copy) and @(y=expand) keywords are inverted ? (@(y=expand copy) V)"
| MISMATCH_COPY_LAZY                        = "cannot copy a lazy value, maybe @(y=copy) and @(y=lazy) keywords are inverted ? (@(y=lazy copy) V)"
| MISMATCH_DCOPY_EXPAND                     = "cannot copy an expand value, maybe @(y=dcopy) and @(y=expand) keywords are inverted ? (@(y=expand dcopy) V)"
| MISMATCH_DCOPY_LAZY                       = "cannot copy a lazy value, maybe @(y=dcopy) and @(y=lazy) keywords are inverted ? (@(y=lazy dcopy) V)"
| MISMATCH_TUPLE_ARITY                      = "mismatch tuple arity %(y) and %(y)"
| MULTIPLE_DECORATORS                       = "decorator %(y) is specified multiple times"
| MULTIPLE_FIELD_INIT                       = "field %(y) is initialized multiple times"
| MULTIPLE_NAMED_PARAM                      = "named parameter %(y) is set multiple times"
| MULTIPLE_SYMBOL_TYPES                     = "expression refers to multiple symbols that generate types"
| MULTIPLE_UNSAFE                           = "context is already unsafe"
| MUTABLE_CONST_ITERATOR                    = "an iterator cannot be mutable, if it is not a reference or does not borrow mutable data"
| MUTABLE_CONST_PARAM                       = "a parameter cannot be mutable, if it is not a reference or does not borrow mutable data"
| MUTABLE_LAMBDA_VAR                        = "a lambda variable cannot be mutable"
| MUTABLE_LAZY_VAR                          = "a lazy variable cannot be mutable, if it does not borrow mutable data"
| MUTABLE_METHOD                            = "method %(y) is defined as mutable"
| NEGATIVE_INT_INDEX                        = "index cannot be negative for type %(y), but is %(y)"
| NEVER_ENTERED_LOOP                        = "loop test is always @(y=false), loop is never entered"
| NON_ABSTRACT_NOT_COMPLETE                 = "class %(y) is not abstract but have empty methods"
| NOTHING_TO_CATCH                          = "nothing to catch"
| NOT_ALIASABLE                             = "%(y) is not an aliasable type"
| NOT_ANCESTOR                              = "%(y) is not an ancestor type of %(y)"
| NOT_AN_ARRAY                              = "%(y) is not an array type"
| NOT_AN_EXCEPTION_CLASS                    = "class type %(y) does not inherit from exception type %(y)"
| NOT_A_CLASS                               = "%(y) is not a class type"
| NOT_A_LVALUE                              = "not a lvalue"
| NOT_A_LVALUE_CLOSURE                      = "%(y) is enclosed, and cannot be used as a lvalue"
| NOT_A_LVALUE_ITERATOR                     = "%(y) is a value iterator, and cannot be used as a lvalue"
| NOT_A_LVALUE_MAP_ACCESS                   = "%(y) is a map access, and cannot be used as a lvalue"
| NOT_A_LVALUE_LAZY                         = "%(y) is a lazy variable, and cannot be used as a lvalue"
| NOT_A_LVALUE_PARAM                        = "%(y) is a value parameter, and cannot be used as a lvalue"
| NOT_A_LVALUE_TYPE                         = "value of type %(y) is not a lvalue"
| NOT_A_MAP                                 = "%(y) is not a map type"
| NOT_A_RECORD                              = "%(y) is not a record type"
| NOT_A_SLICE                               = "%(y) is not a slice type"
| NOT_A_STRUCT                              = "%(y) is not an entity type"
| NOT_A_TRAIT                               = "%(y) is not a trait"
| NOT_A_TUPLE                               = "%(y) is not a tuple type"
| NOT_CALLABLE                              = "call operator is not defined for type %(y)"
| NOT_MOVABLE                               = "type %(y) is not a movable type"
| NOT_UNSAFE                                = "an unsafe context is entered, but no unsafe operations are made"
| NO_ALIAS_PATTERN                          = "there is no pattern that requires the value to be passed by @(y=alias)"
| NO_COPY_EXIST                             = "no copy exists for type %(y)"
| NO_CTOR_FOUND                             = "no constructor found for class %(y)"
| NO_CTOR_FOUND_NAME                        = "no constructor named %(y) found for class %(y)"
| NO_DEFAULT_CTOR_MOVE_STRUCT               = "type %(y) is an entity, but has no default ctor @(r=self)()"
| NO_LAZY_PATTERN                           = "there is no pattern that requires the value to be lazy"
| NO_PARAMETER_NAMED                        = "no parameter is named %(y)"
| NO_REFERENCE_PATTERN                      = "there is no pattern that requires the value to be passed by mutable reference"
| NO_SIZE_FORWARD_REF                       = "record or entity type %(y) has no size due to forward references"
| NO_SUPER_CLASS                            = "class %(y) has no ancestor"
| ONE_ITER_LOOP                             = "do while loop test is always @(y=false), the loop is always entered just one time, so the branching construct is useless"
| OPTION_HAS_NO_ERROR                       = "option of type %(y) has no error"
| OPTION_HAS_NO_VALUE                       = "option of type %(y) has no value"
| OPTION_MATCHER                            = "option matcher %(y) only applies to option values not %(y)"
| OVERFLOW_CAPACITY                         = "overflow capacity for type %(y) = %(y), maximum value is %(y)"
| OVERFLOW_CAPACITY_ARRAY                   = "static array size %(y) exceeds limits %(y)"
| OVERFLOW_CAPACITY_MIN                     = "overflow capacity for type %(y) = %(y), minimum value is %(y)"
| OVERRIDE_EMPTY                            = "method %(y) must have a body to override %(y)"
| OVERRIDE_FIELD_NO_FIELD                   = "method %(y) must be a field method to override %(y)"
| OVERRIDE_FINAL                            = "cannot override final method %(y)"
| OVERRIDE_MISMATCH_PROTECTION              = "the protection %(y) of the overriden method %(y) does not match with the definition of the ancestor class %(y)"
| OVERRIDE_MISMATCH_THROWERS                = "the throwers of the overriden method %(y) are not compatible with the throwers of the ancestor method %(y)"
| OVERRIDE_MULTIPLE_TIMES_TRAIT             = "trait method %(y) was already overriden"
| OVERRIDE_NON_TRAIT_INSIDE                 = "cannot override a non trait method %(y) with %(y) inside impl"
| OVERRIDE_NOTHING                          = "method %(y) overrides nothing"
| OVERRIDE_NO_FIELD_BY_FIELD                = "field method %(y) cannot override the non field method %(y)"
| OVERRIDE_PRIVATE                          = "cannot override private method %(y)"
| OVERRIDE_TRAIT_OUTSIDE                    = "cannot override trait method %(y) with %(y) outside impl"
| OVERRIDE_INCOMPATIBLE_RETURN_TYPE         = "thr return type of the overriden method %(y) is not compatible with the return type of the ancestor method %(y)"
| PARAMETER_NAME                            = "for parameter %(y)"
| PATTERN_IS_REFUTABLE                      = "the pattern %(y) with value %(y) is refutable"
| PRAGMA_FIELD_NO_DEFAULT                   = "field %(y) from type %(y) has no default value"
| RANGE_ON_ARRAY_NO_COPY                    = "the index operator on %(y) with an dynamic operand of type %(y) is allowed only in the context of a copy statement"
| RETURN_NO_FUNCTION                        = "return statement is not within a function"
| RETURN_SCOPE_GUARD                        = "cannot return inside a scope guard"
| SHADOWING_DECL                            = "declaration of %(y) shadows another declaration"
| SIMPLE_ALIAS_NOT_CLASS                    = "using basic alias instead of class alias operator (i.e. @(y=:.), @(y=:[)) is prohibited"
| SIMPLE_COPY_CLASS_CTOR                    = "replace @(y=dcopy) by the simple @(y=copy) operator"
| SUPER_NO_SELF_CLASS                       = "the superclass proxy of %(y) is only accessible through @(y=self)"
| TEMPLATE_REST                             = "template validation incomplete, rest : {%(y)}"
| TEMPLATE_SPE                              = "with %(y)"
| TEMPLATE_SPECIALIZATION_FAILS             = "template specialization for %(y) fails with %(y)"
| TEMPLATE_SPECIALIZATION_FAILS_SIMPLE      = "template specialization fails with %(y)"
| TEMPLATE_TEST_FAILED                      = "the test of the template specialization failed"
| TEMPLATE_VALUE_TRY                        = "when trying template value resolution"
| THROWING                                  = "throwing %(y)"
| THROWS_IN_LAMBDA                          = "a lambda function must be safe, but there are exceptions that are not caught"
| THROWS_NOT_DECLARED                       = "the function %(y) might throw an exception of type %(y), but that is not declared in its prototype"
| THROWS_NOT_DECLARED_OVER                  = "the method might throw an exception of type %(y), but that is not covered by the method of the ancestor class"
| THROWS_NOT_USED                           = "the function %(y) prototype informs about a possible throw of an exception of type %(y), but this is not true"
| THROW_NO_FUNCTION                         = "throw statement is not within a function"
| THROW_SCOPE_GUARD                         = "cannot throw exception inside a scope guard"
| THROW_SCOPE_GUARD_RETHROW                 = "Rethrowing an exception of type %(y) inside a scope guard is forbidden"
| TOO_FEW_PARAMETERS                        = "%(y) parameters % expected, but %(y) % provided"
| TUPLE_ARITY_OVERFLOW                      = "tuple access out of bound (%(y)), tuple arity is %(y)"
| TUPLE_MATCHER                             = "tuple matcher only applies to tuple values not %(y)"
| TUPLE_PATTERN                             = "pattern %(y) only matches tuple values, not %(y)"
| TYPE_HAS_NO_FIELDINFO                     = "type %(y) has no fields"
| TYPE_HAS_NO_SIZE                          = "temporary type %(y) has no size"
| TYPE_HAS_NO_TYPEINFO                      = "temporary type %(y) has no type information"
| TYPE_NO_FIELD                             = "type %(y) has no field named %(y)"
| UFC_REWRITING                             = "when using uniform function call syntax"
| UNDEFINED_ATTRIBUTE                       = "attribute %(y) is not usable in this context"
| UNDEFINED_BIN_ACC_OP                      = "undefined operator %(y) for type %(y) and field %(y)"
| UNDEFINED_BIN_MOD_OP                      = "undefined module operator %(y) for %(y) and field %(y)"
| UNDEFINED_BIN_OP                          = "undefined operator %(y) for types %(y) and %(y)"
| UNDEFINED_BIN_OP_TOK                      = "undefined binary operator %(y)"
| UNDEFINED_CALL_OP                         = "the call operator is not defined for %(y) and %"
| UNDEFINED_CAST_OP                         = "cannot cast value of type %(y) into a value of type %(y)"
| UNDEFINED_CTOR_MACRO                      = "macro %(y) has no accessible constructors in that context"
| UNDEFINED_DOLLAR_OP                       = "operator @(y=$) is not defined for type %(y)"
| UNDEFINED_ESCAPE                          = "undefined escape sequence"
| UNDEFINED_INDEX_OP                        = "the index operator is not defined for type %(y) and %(y)"
| UNDEFINED_MACRO_CALL                      = "macro call is undefined for %(y)"
| UNDEFINED_REDIRECT_CALL_CTOR              = "no constructor is callable with the parameters %(y)"
| UNDEFINED_RULE_MACRO                      = "macro symbol %(y) has no rule named %(y)"
| UNDEFINED_SUPER_CALL_CTOR                 = "no constructor of the super class is callable with the parameters %(y)"
| UNDEFINED_TEMPLATE_CALL                   = "undefined template call for %(y) with %(y)"
| UNDEFINED_UN_OP                           = "undefined operator %(y) for type %(y)"
| UNDEFINED_UN_OP_TOK                       = "undefined operator unary operator %(y)"
| UNDEF_CTE_FOR_LOOP_OPERATOR               = "undefine cte for loop operator with %(y) iterator for type %(y)"
| UNDEF_DECORATOR_HERE                      = "decorator %(y) is not applicable in that context"
| UNDEF_DECORATOR_TEMPLATE                  = "decorator %(y) is not applicable in template specialization"
| UNDEF_DECORATOR_TYPE                      = "decorator %(y) is not applicable for types"
| UNDEF_DECORATOR_VALUE                     = "decorator %(y) is not applicable for values"
| UNDEF_FOR_LOOP_OPERATOR                   = "undefine for loop operator with %(y) iterator for type %(y)"
| UNDEF_VAR                                 = "undefined symbol %(y)"
| UNECESSARY_ADDRESS_METHOD                 = "the creation of a delegate from a method has no effect"
| UNECESSARY_ALIAS                          = "aliasing the value of type %(y) to create a constant borrowing is prohibited"
| UNECESSARY_ALIAS_CPTR_LOOP                = "aliasing the value of type %(y) to call @(y=begin) and @(y=end) iterator constant methods is useless"
| UNECESSARY_LAZY                           = "the construction of a lazy value has not effect"
| UNECESSARY_LMBD_COPY                      = "copy the lambda closure has no effect, no values are enclosed"
| UNECESSARY_MOVE                           = "the move has no effect"
| UNECESSARY_REFERENCE                      = "referencing the value has no effect"
| UNINIT_FIELD                              = "the field %(y) has no initial value"
| UNION_CTOR_MULTIPLE_FIELDS                = "constructor of the union type %(y) initialize mutliple fields %(y)"
| UNION_CTOR_NO_FIELD                       = "constructor of the union type %(y) initialize no field"
| UNKNOWN_AT_COMPILE_TIME                   = "value of type %(y) is needed but unknown at compilation time"
| UNKNOWN_LENGTH_OF_EXPANSION               = "unknown length of expansion for type %(y)"
| UNKNOWN_PRAGMA                            = "unknown __pragma expression %(y)"
| UNREACHABLE_MATCHER                       = "matcher expression is never evaluated"
| UNREACHBLE_STATEMENT                      = "unreachable statement"
| UNRESOLVED_TEMPLATE                       = "unresolved template"
| UNSAFE_CALL                               = "call of unsafe function outside unsafe context"
| UNSAFE_OPERATION                          = "unsafe operation outside unsafe context"
| UNTERMINATED_ESCAPE                       = "unterminated escape sequence"
| USELESS_COND_FALSE                        = "conditional test is always evaluated to @(y=false), branch is never entered"
| USELESS_COND_TRUE                         = "conditional test is always evaluated to @(y=true), branch is always entered"
| USELESS_RUNTIME_ASSERT                    = "useless runtime assertion for a test that is always @(y=true)"
| USE_AS_TYPE                               = "expression produces a value, but is used as a type"
| USE_AS_TYPE_TEMPLATE                      = "template specialization expected a type not the value %(y)"
| USE_AS_TYPE_VAL                           = "expression produces a value of type %(y), but is used as a type"
| USE_AS_VALUE                              = "expression produces a type, but is used as a value"
| USE_AS_VALUE_TEMPLATE                     = "template specialization expected a value not the type %(y)"
| USE_AS_VALUE_TYPE                         = "expression produces the type %(y), but is used as a value"
| USE_GET_OP_ITERATOR                       = "calling the %(y) method for iterator %(y)"
| VALIDATING                                = "when validating"
| VALIDATING_SYMBOL                         = "when validating %(y)"
| VAR_DECL_WITHOUT_VALUE                    = "var declared without value, when necessary"
| VAR_DECL_WITH_NOTHING                     = "var declaration must at least have a type or a value"
| VOID_VALUE                                = "void expression cannot be used as a value"
| VOID_VAR                                  = "cannot create a variable of type void"
| WHEN_CREATING_VALUE                       = "when creating the value %(y)"
| WITHIN_TYPE                               = "within type %(y)"
| WORKS_WITH_BOTH                           = "%(y) called with %(y) works with multiple candidates"
| RECURSIVE_ANCESTOR                        = "ancestor cycle found when validating %(y)"
 -> ValidateErrorMessage;
