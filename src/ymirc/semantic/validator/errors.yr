mod ymirc::semantic::validator::errors;

/**
 * All the error messages that can occur in symbol validation
 */
pub enum
| ALREADY_INIT_BY_CTOR_REDIRECT    = "field %(y) was already initialized by ctor redirection"s8
| ARRAY_OVERFLOW		   = "slice access, index overflow %(y) (len) <= %(y) (index)"s8
| ARRAY_SIZE_TYPE		   = "size of static array type must be cte int value, not %(y)"s8
| BRANCHING_VALUE		   = "for branching value"s8
| BREAK_NO_LOOP			   = "break statement is not within a loop"s8
| CANDIDATE_ARE			   = "candidate % : %"s8
| CLASS_FIELD_NOT_INIT_YET         = "field %(y) has not yet been initialized"s8
| CLASS_NO_FIELD                   = "class %(y) has no field named %(y)"s8
| COLLIDING_METHOD_DEFINITION      = "colliding method definitions %(y) and %(y)"s8
| CONFLIT_DECORATORS		   = "conflicting decorators %(y) and %(y)"s8
| CTE_IGNORED			   = "%(y) values contained in block scope are ignored at compile time execution"s8
| DECLARED_NOT_USED		   = "the symbol %(y) was declared but never used"s8
| DECLARED_HERE                    = "declared here"s8
| DECLARE_VOID_VAR		   = "cannot declare a variable of type %(y)"s8
| DEEPLY_INNER_TYPE		   = "decorator is not applicable on inner types"s8
| DEFAULT_VAR_NO_NAME              = "parameter with a default value must have a referencaable name"s8
| DEFINED_HERE                     = "defined here"s8
| DISCARD_CONST			   = "discard the constant property is prohibited"s8
| DISCARD_CONST_LEVEL		   = "discard the constant property is prohibited, left operand mutability level is %(y) but must be at most %(y)"s8
| DISCARD_CONST_LEVEL_TYPES        = "from %(y) to %(y)"s8
| DIVISION_BY_ZERO                 = "division by 0"s8
| FIRST_DEFINED			   = "defined here"s8
| FORBID_DECO_FOR_LOOP_RANGE       = "decorators are forbidden on range %(y) iteration"s8
| FORBID_DECO_FOR_LOOP_SLICE       = "decorators are forbidden on slice %(y) iteration"s8
| FORBID_DECO_FOR_LOOP_TUPLE       = "decorators are forbidden on tuple %(y) iteration"s8
| FORGET_AND_CLASS                 = "did you forget '&'"s8
| FORWARD_REFERENCE_TYPE	   = "the type cannot be validated due to forward reference"s8
| FORWARD_REFERENCE_VALUE	   = "the value cannot be computed, as it depends on a forward reference"s8
| FORWARD_REFERENCE_VAR		   = "the type cannot be infered, as it depends on a forward reference"s8
| IMMUTABLE_LVALUE                 = "left operand of type %(y) is immutable"s8
| IMMUTABLE_PARENT		   = "parent type is immutable"s8
| IMPLICIT_ALIAS		   = "implicit alias of type %(y), it will implicitly discard constant property"s8
| IMPLICIT_OVERRIDE                = "method %(y) implicitly override method %(y)"s8
| IMPLICIT_OVERRIDE_BY_TRAIT	   = "implicit override of method %(y) by trait impl"s8
| IMPLICIT_PURE			   = "implicit pure of type %(y), it will implicitly discard constant property"s8
| IMPL_NO_TRAIT			   = "impl statement must be followed by a trait, not %(y)"s8
| INCOMPATIBLE_TYPE		   = "incompatible types %(y) and %(y)"s8
| INCOMPLETE_TYPE		   = "the type %(y) is not complete"s8
| ENCLOSE_INCOMPLETE_TYPE          = "the type %(y) cannot be enclosed because it is not complete"s8
| INCOMPLETE_TYPE_CLASS		   = "the type %(y) is not complete due to previous errors"s8
| INHERIT_FINAL_CLASS		   = "the base class %(y) is marked as final"s8
| INHERIT_NO_CLASS		   = "the base of a class must be a class, not a %(y)"s8
| IS_NATIVE_TYPE		   = "cannot declare a variable named %(y), identifier is already used for a native type"s8
| MAIN_FUNCTION_ONE_ARG		   = "main function takes at most one argument"s8
| MALFORMED_CHAR		   = "malformed literal, number of %(y) is %(y)"s8
| MALFORMED_FLOAT_LITERAL	   = "malformed float literal %(y)"s8
| MALFORMED_INT_LITERAL		   = "malformed int literal %(y)"s8
| MAYBE_WAS_MEANT		   = "maybe %(y) was meant"s8
| MAYBE_WAS_MEANT_FROM_MOD	   = "maybe %(y) from module %(y) was meant"s8
| MISMATCH_TUPLE_ARITY             = "mismatch tuple arity %(y) and %(y)"s8
| MULTIPLE_DECORATORS		   = "decorator %(y) is specified multiple times"s8
| MULTIPLE_FIELD_INIT              = "field %(y) is initialized multiple times"s8
| MUTABLE_CONST_PARAM		   = "a parameter cannot be mutable, if it is not a reference or an aliasable type"s8
| NOTHING_TO_CATCH		   = "nothing to catch"s8
| NOT_ALIASABLE                    = "%(y) is not an aliasable type"s8
| NOT_ANCESTOR                     = "%(y) is not an ancestor type of %(y)"s8
| NOT_AN_ARRAY                     = "%(y) is not an array type"s8
| NOT_A_CLASS                      = "%(y) is not a class type"s8
| NOT_A_LVALUE			   = "not a lvalue"s8
| NOT_A_LVALUE_TYPE                = "value of type %(y) is not a lvalue"s8
| NOT_A_SLICE                      = "%(y) is not a slice type"s8
| NOT_A_STRUCT                     = "%(y) is not a struct type"s8
| NOT_A_TUPLE                      = "%(y) is not a tuple type"s8
| NO_COPY_EXIST                    = "no copy exists for type %(y)"s8
| NO_CTOR_FOUND                    = "no constructor found for class %(y)"s8
| NO_CTOR_FOUND_NAME               = "no constructor named %(y) found for class %(y)"s8
| NO_PARAMETER_NAMED		   = "no parameter is named %(y)"s8
| NO_SUPER_CLASS                   = "class %(y) has no ancestor"s8
| OVERFLOW_CAPACITY                = "overflow capacity for type %(y) = %(y), maximum value is %(y)"s8
| OVERRIDE_FINAL                   = "cannot override final method %(y)"s8
| OVERRIDE_MISMATCH_PROTECTION     = "the protection %(y) of the overriden method %(y) does not match with the definition of the ancestor class %(y)"s8
| OVERRIDE_MULTIPLE_TIMES_TRAIT    = "trait method %(y) was already overriden"s8
| OVERRIDE_NON_TRAIT_INSIDE        = "cannot override a non trait method %(y) with %(y) inside impl"s8
| OVERRIDE_NOTHING                 = "method %(y) overrides nothing"s8
| OVERRIDE_PRIVATE                 = "cannot override private method %(y)"s8
| OVERRIDE_TRAIT_OUTSIDE           = "cannot override trait method %(y) with %(y) outside impl"s8
| PARAMETER_NAME		   = "for parameter %(y)"s8
| PRIVATE_IN_THIS_CONTEXT	   = "%(y) is private within this context"s8
| PRIVATE_IN_THIS_CONTEXT_FROM_MOD = "%(y) from module %(y) is private within this context"s8
| RANGE_NO_FIELD                   = "range type %(y) has no field named %(y)"s8
| RETURN_NO_FUNCTION		   = "return statement is not within a function"s8
| SHADOWING_DECL		   = "declaration of %(y) shadows another declaration"s8
| TEMPLATE_REST                    = "template validation incomplete, rest : {%(y)}"s8
| TEMPLATE_SPE                     = "with %(y)"s8
| TEMPLATE_SPECIALIZATION_FAILS    = "template specialization for %(y) fails with %(y)"s8
| TEMPLATE_TEST_FAILED             = "the test of the template specialization failed"s8
| TEMPLATE_VALUE_TRY               = "when trying template value resolution"s8
| THROWS_IN_LAMBDA		   = "a lambda function must be safe, but there are exceptions that are not caught"s8
| TOO_FEW_PARAMETERS		   = "%(y) parameters are expected, but %(y) are provided"s8
| TOO_FEW_PARAMETERS_ONE	   = "%(y) parameters are expected, but %(y) is provided"s8
| TUPLE_ARITY_OVERFLOW             = "tuple access out of bound (%(y)), tuple arity is %(y)"s8
| UFC_REWRITING			   = "when using uniform function call syntax"s8
| UNDEFINED_BIN_OP		   = "undefined operator %(y) for types %(y) and %(y)"s8
| UNDEFINED_CALL_OP		   = "the call operator is not defined for %(y) and %(y)"s8
| UNDEFINED_CAST_OP                = "cannot cast value of type %(y) into a value of type %(y)"s8
| UNDEFINED_ESCAPE		   = "undefined escape sequence"s8
| UNDEFINED_INDEX_OP               = "the index operator is not defined for type %(y) and %(y)"s8
| UNDEFINED_SUPER_CALL_CTOR        = "no constructor of the super class is callable with the parameters %(y)"s8
| UNDEFINED_TEMPLATE_CALL          = "undefined template call for %(y) with %(y)"s8
| UNDEFINED_UN_OP                  = "undefined operator %(y) for type %(y)"s8
| UNDEF_DECORATOR_TYPE		   = "decorator %(y) is not applicable for types"s8
| UNDEF_FOR_LOOP_OPERATOR          = "undefine for loop operator with %(y) iterator for type %(y)"s8
| UNDEF_VAR			   = "undefined symbol %(y)"s8
| UNINIT_FIELD                     = "the field %(y) has no initial value"s8
| UNKNOWN_AT_COMPILE_TIME	   = "value of type %(y) is needed but unknown at compilation time"s8
| UNKNOWN_PRAGMA                   = "unknown __pragma expression %(y)"s8
| UNREACHBLE_STATEMENT		   = "unreachable statement"s8
| UNTERMINATED_ESCAPE		   = "unterminated escape sequence"s8
| USE_AS_TYPE			   = "expression used as a type"s8
| USE_AS_VALUE			   = "expression used as a value"s8
| VALIDATING			   = "when validating"s8
| VALIDATING_SYMBOL		   = "when validating %(y)"s8
| VAR_DECL_WITHOUT_VALUE	   = "var declared without value, when necessary"s8
| VAR_DECL_WITH_NOTHING		   = "var declaration must at least have a type or a value"s8
| VOID_VALUE			   = "void expression cannot be used as a value"s8
| VOID_VAR			   = "cannot create a variable of type void"s8
| WORKS_WITH_BOTH                  = "%(y) called with {%(y)} works with multiple candidates"s8
 -> ValidateErrorMessage;
