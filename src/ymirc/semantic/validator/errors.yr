mod ymirc::semantic::validator::errors;

/**
 * All the error messages that can occur in symbol validation
 */
pub enum
| ARRAY_OVERFLOW		   = "slice access, index overflow %(y) (len) <= %(y) (index)"s8
| ARRAY_SIZE_TYPE		   = "size of static array type must be cte int value, not %(y)"s8
| BRANCHING_VALUE		   = "for branching value"s8
| BREAK_NO_LOOP			   = "break statement is not within a loop"s8
| CANDIDATE_ARE			   = "candidate % : %"s8
| CONFLIT_DECORATORS		   = "conflicting decorators %(y) and %(y)"s8
| CTE_IGNORED			   = "%(y) values contained in block scope are ignored at compile time execution"s8
| DECLARED_NOT_USED		   = "the symbol %(y) was declared but never used"s8
| DECLARE_VOID_VAR		   = "cannot declare a variable of type %(y)"s8
| DEEPLY_INNER_TYPE		   = "decorator is not applicable on inner types"s8
| DISCARD_CONST			   = "discard the constant property is prohibited"s8
| DISCARD_CONST_LEVEL		   = "discard the constant property is prohibited, left operand mutability level is %(y) but must be at most %(y)"s8
| FIRST_DEFINED			   = "defined here"s8
| FORWARD_REFERENCE_TYPE	   = "the type cannot be validated due to forward reference"s8
| FORWARD_REFERENCE_VAR		   = "the type cannot be infered, as it depends on a forward reference"s8
| IMMUTABLE_PARENT		   = "parent type is immutable"s8
| IMPLICIT_ALIAS		   = "implicit alias of type %(y) is not allowed, it will implicitly discard constant property"s8
| IMPLICIT_OVERRIDE_BY_TRAIT	   = "implicit override of method %(y) by trait implementation is not allowed"s8
| IMPLICIT_PURE			   = "implicit pure of type %(y) is not allowed, it will implicitly discard constant property"s8
| IMPL_NO_TRAIT			   = "impl statement must be followed by a trait, not %(y)"s8
| INCOMPATIBLE_TYPE		   = "incompatible types %(y) and %(y)"s8
| INCOMPLETE_TYPE		   = "the type %(y) is not complete"s8
| INCOMPLETE_TYPE_CLASS		   = "the type %(y) is not complete due to previous errors"s8
| INHERIT_FINAL_CLASS		   = "the base class %(y) is marked as final"s8
| INHERIT_NO_CLASS		   = "the base of a class must be a class, not a %(y)"s8
| IS_NATIVE_TYPE		   = "cannot declare a variable named %(y), identifier is already used for a native type"s8
| MAIN_FUNCTION_ONE_ARG		   = "main function takes at most one argument"s8
| MALFORMED_CHAR		   = "malformed literal, number of %(y) is %(y)"s8
| MALFORMED_FLOAT_LITERAL	   = "malformed float literal %(y)"s8
| MALFORMED_INT_LITERAL		   = "malformed int literal %(y)"s8
| MAYBE_WAS_MEANT		   = "maybe %(y) was meant"s8
| MAYBE_WAS_MEANT_FROM_MOD	   = "maybe %(y) from module %(y) was meant"s8
| MULTIPLE_DECORATORS		   = "decorator %(y) is specified multiple times"s8
| MUTABLE_CONST_PARAM		   = "a parameter cannot be mutable, if it is not a reference or an aliasable type"s8
| NOTHING_TO_CATCH		   = "nothing to catch"s8
| NOT_A_LVALUE			   = "not a lvalue"s8
| NO_PARAMETER_NAMED		   = "no parameter is named %(y)"s8
| PARAMETER_NAME		   = "for parameter %(y)"s8
| PRIVATE_IN_THIS_CONTEXT	   = "%(y) is private within this context"s8
| PRIVATE_IN_THIS_CONTEXT_FROM_MOD = "%(y) from module %(y) is private within this context"s8
| RETURN_NO_FUNCTION		   = "return statement is not within a function"s8
| SHADOWING_DECL		   = "declaration of %(y) shadows another declaration"s8
| THROWS_IN_LAMBDA		   = "a lambda function must be safe, but there are exceptions that are not caught"s8
| TOO_FEW_PARAMETERS		   = "%(y) parameters are expected, but %(y) are provided"s8
| TOO_FEW_PARAMETERS_ONE	   = "%(y) parameters are expected, but %(y) is provided"s8
| UFC_REWRITING			   = "when using uniform function call syntax"s8
| UNDEFINED_BIN_OP		   = "undefined operator %(y) for types %(y) and %(y)"s8
| UNDEFINED_CALL_OP		   = "the call operator is not defined for %(y) and %(y)"s8
| UNDEFINED_ESCAPE		   = "undefined escape sequence"s8
| UNDEF_DECORATOR_TYPE		   = "decorator %(y) is not applicable for types"s8
| UNDEF_VAR			   = "undefined symbol %(y)"s8
| UNKNOWN_AT_COMPILE_TIME	   = "value of type %(y) is needed but unknown at compilation time"s8
| UNREACHBLE_STATEMENT		   = "unreachable statement"s8
| UNTERMINATED_ESCAPE		   = "unterminated escape sequence"s8
| USE_AS_TYPE			   = "expression used as a type"s8
| USE_AS_VALUE			   = "expression used as a value"s8
| VALIDATING			   = "when validating"s8
| VALIDATING_SYMBOL		   = "when validating %(y)"s8
| VAR_DECL_WITHOUT_VALUE	   = "var declared without value, when necessary"s8
| VAR_DECL_WITH_NOTHING		   = "var declaration must at least have a type or a value"s8
| VOID_VALUE			   = "void expression cannot be used as a value"s8
| VOID_VAR			   = "cannot create a variable of type void"s8
 -> ValidateErrorMessage;
