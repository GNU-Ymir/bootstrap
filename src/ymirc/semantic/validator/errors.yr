mod ymirc::semantic::validator::errors;

/**
 * All the error messages that can occur in symbol validation
 */
pub enum
| ALREADY_INIT_BY_CTOR_REDIRECT             = "field %(y) was already initialized by ctor redirection"s8
| ARRAY_OVERFLOW                            = "slice access, index overflow %(y) (len) <= %(y) (index)"s8
| ARRAY_PATTERN_SIZE                        = "array pattern match len %(y) never matches the value len %(y)"s8
| BRANCHING_VALUE                           = "when validating conditional value"s8
| BREAK_NO_LOOP                             = "break statement is not within a loop"s8
| CANDIDATE_ARE                             = "candidate %(y)"s8
| CANNOT_CASTTO_BASE_CLASS                  = "cannot cast derived type %(y) to base class type %(y) in that context"s8
| CLASS_FIELD_NOT_INIT_YET                  = "field %(y) has not yet been initialized"s8
| CLASS_NOT_IMPL                            = "class type %(y) does not implement trait %(y)"s8
| CLASS_NO_FIELD                            = "class %(y) has no field named %(y)"s8
| CLASS_THROW_PTR                           = "class type excepted, not the class object instance type %(y) (i.e. the @(y=&) is useless)"s8
| CLOSURE_TEMPLATE_LAMBDA                   = "closure functions cannot be used as template values"s8
| COLLIDING_METHOD_DEFINITION               = "colliding method definitions %(y) and %(y)"s8
| CONFLIT_DECORATORS                        = "conflicting decorators %(y) and %(y)"s8
| CONST_METHOD                              = "method %(y) is defined as constant"s8
| CTE_ASSERT_NO_MSG                         = "cte assertion failed"s8
| CTE_ASSERT_WITH_MSG                       = "cte assertion failed %(y)"s8
| CTE_IGNORED                               = "%(y) values contained in block scope are ignored at compile time execution"s8
| DECLARED_HERE                             = "declared here"s8
| DECLARED_NOT_USED                         = "the symbol %(y) was declared but never used"s8
| DECLARE_VOID_VAR                          = "cannot declare a variable of type %(y)"s8
| DECREASING_RANGE_ACCESS                   = "range index cannot be decreasing for type %(y), but goes from %(y) to %(y)"s8
| DEEPLY_INNER_TYPE                         = "decorator is not applicable on inner types, already deeply mutable"s8
| DEFAULT_VAR_NO_NAME                       = "parameter with a default value must have a referencaable name"s8
| DEFINED_HERE                              = "defined here"s8
| DISCARD_CONST                             = "discard the constant property is prohibited"s8
| DISCARD_CONST_LEVEL_TYPES                 = "from %(y) to %(y)"s8
| DIVISION_BY_ZERO                          = "division by 0"s8
| DOLLAR_OUTSIDE_CONTEXT                    = "'$' is usable only inside an index operation"s8
| EMPTY_ARRAY_INNER                         = "array inner type cannot be %(y)"s8
| ENCLOSE_INCOMPLETE_TYPE                   = "the type %(y) cannot be enclosed because it is not complete"s8
| ERROR_PARAM                               = "value %(y) is of type %(y)"s8
| EXITING_SCOPE_HERE                        = "exiting scope here"s8
| FIELD_METHOD_PARAMS                       = "field method cannot have parameters"s8
| FIRST_DEFINED                             = "defined here"s8
| FORBID_DECO_FOR_LOOP                      = "decorators are forbidden on %(y) iteration"s8
| FORGET_AND_CLASS                          = "did you forget '&'"s8
| FORWARD_REFERENCE_TYPE                    = "the type cannot be validated due to forward reference"s8
| FORWARD_REFERENCE_VALUE                   = "the value cannot be computed, as it depends on a forward reference"s8
| FORWARD_REFERENCE_VAR                     = "the type cannot be infered, as it depends on a forward reference"s8
| FOR_FIELD                                 = "for the field %(y)"s8
| FOR_PATTERN_FIELD                         = "for pattern field access %(y) on type %(y)"s8
| FOR_TYPE                                  = "within type %(y)"s8
| HERE                                      = "here"s8
| IF_COND_NOT_COMPLETE                      = "the if condition has no else value, so it must produce a @(y=void) value not a %(y)"s8
| IMMUTABLE_LVALUE                          = "left operand of type %(y) is immutable"s8
| IMMUTABLE_PARENT                          = "type must be immutable"s8
| IMPLICIT_ALIAS                            = "implicit alias of type %(y) is prohibited, it implicitly gives up on borrowings of mutable values"s8
| IMPLICIT_CONST_REFERENCE                  = "reference of type %(y) must be const, but is mutable"s8
| IMPLICIT_MUT_REFERENCE                    = "reference of type %(y) must be mutable, but is const"s8
| IMPLICIT_OVERRIDE                         = "method %(y) implicitly override method %(y)"s8
| IMPLICIT_OVERRIDE_BY_TRAIT                = "implicit override of method %(y) by trait impl"s8
| IMPLICIT_PURE                             = "implicit pure of type %(y) is prohibited, it will implicitly discard constant property"s8
| IMPLICIT_REFERENCE                        = "cannot pass value of type %(y) as reference"s8
| IMPL_NO_TRAIT                             = "impl statement must be followed by a trait, not %(y)"s8
| INCOMPATIBLE_TYPE                         = "incompatible types %(y) and %(y)"s8
| INCOMPATIBLE_VALUES                       = "incompatible values %(y) and %(y)"s8
| INCOMPLETE_TYPE                           = "the type %(y) is not complete"s8
| INCOMPLETE_TYPE_CLASS                     = "the type %(y) is not complete due to previous errors"s8
| INFINITE_LOOP                             = "infinite loop with always @(y=true) test is not allowed, rather use a @(y=loop) construct"s8
| INHERIT_FINAL_CLASS                       = "the base class %(y) is marked as final"s8
| INHERIT_NO_CLASS                          = "the base of a class must be a class, not a %(y)"s8
| INLINE_VIRTUAL_METHOD                     = "method %(y) cannot be inline as it is virtual (overridable or inherited)"s8
| IS_NATIVE_TYPE                            = "cannot declare a variable named %(y), identifier is already used for a native type"s8
| IS_NOT_CALLABLE                           = "call operator is not defined for value %(y)"s8
| MAIN_FUNCTION_ONE_ARG                     = "main function takes at most one argument"s8
| MAIN_INLINE                               = "main function cannot be inline"s8
| MALFORMED_CHAR                            = "malformed literal, number of %(y) is %(y)"s8
| MALFORMED_FLOAT_LITERAL                   = "malformed float literal %(y)"s8
| MALFORMED_INT_LITERAL                     = "malformed int literal %(y)"s8
| MALFORMED_PRAGMA                          = "malformed __pragma %(y)"s8
| MALFORMED_TYPEINFO_CORE                   = "core module typeinfo is malformed"s8
| MATCH_NOT_COMPLETE                        = "the pattern matching has no default case, so each branch must produce a @(y=void) value not a %(y)"s8
| MATCH_VALIDATION                          = "when validating pattern matching with value %(y) of type %(y)"s8
| MAX_LOOP_ITERATIONS                       = "reached the maximum number of cte iterations %(y) > %(y)"s8
| MISMATCH_TUPLE_ARITY                      = "mismatch tuple arity %(y) and %(y)"s8
| MULTIPLE_DECORATORS                       = "decorator %(y) is specified multiple times"s8
| MULTIPLE_FIELD_INIT                       = "field %(y) is initialized multiple times"s8
| MULTIPLE_UNSAFE                           = "context is already unsafe"s8
| MUTABLE_CONST_PARAM                       = "a parameter cannot be mutable, if it is not a reference or does not borrow mutable data"s8
| MUTABLE_CONST_ITERATOR                    = "an iterator cannot be mutable, if it is not a reference or does not borrow mutable data"s8
| MUTABLE_METHOD                            = "method %(y) is defined as mutable"s8
| NEGATIVE_INT_INDEX                        = "index cannot be negative for type %(y), but is %(y)"s8
| NEVER_ENTERED_LOOP                        = "loop test is always @(y=false), loop is never entered"s8
| NOTHING_TO_CATCH                          = "nothing to catch"s8
| NOT_ALIASABLE                             = "%(y) is not an aliasable type"s8
| NOT_ANCESTOR                              = "%(y) is not an ancestor type of %(y)"s8
| NOT_AN_ARRAY                              = "%(y) is not an array type"s8
| NOT_AN_EXCEPTION_CLASS                    = "class type %(y) does not inherit from exception type %(y)"s8
| NOT_A_CLASS                               = "%(y) is not a class type"s8
| NOT_A_LVALUE                              = "not a lvalue"s8
| NOT_A_LVALUE_PARAM                        = "%(y) is a value parameter, and cannot be used as a lvalue"s8
| NOT_A_LVALUE_ITERATOR                     = "%(y) is a value iterator, and cannot be used as a lvalue"s8
| NOT_A_LVALUE_TYPE                         = "value of type %(y) is not a lvalue"s8
| NOT_A_SLICE                               = "%(y) is not a slice type"s8
| NOT_A_STRUCT                              = "%(y) is not a struct type"s8
| NOT_A_TRAIT                               = "%(y) is not a trait"s8
| NOT_A_TUPLE                               = "%(y) is not a tuple type"s8
| NOT_CALLABLE                              = "call operator is not defined for type %(y)"s8
| NOT_UNSAFE                                = "an unsafe context is entered, but no unsafe operations are made"s8
| NO_ALIAS_PATTERN                          = "there is no pattern that requires the value to be passed by @(y=alias)"s8
| NO_COPY_EXIST                             = "no copy exists for type %(y)"s8
| NO_CTOR_FOUND                             = "no constructor found for class %(y)"s8
| NO_CTOR_FOUND_NAME                        = "no constructor named %(y) found for class %(y)"s8
| NO_PARAMETER_NAMED                        = "no parameter is named %(y)"s8
| NO_REFERENCE_PATTERN                      = "there is no pattern that requires the value to be passed by mutable reference"s8
| NO_SIZE_FORWARD_REF                       = "struct type %(y) has no size due to forward references"s8
| NO_SUPER_CLASS                            = "class %(y) has no ancestor"s8
| ONE_ITER_LOOP                             = "do while loop test is always @(y=false), the loop is always entered just one time, so the branching construct is useless"s8
| OPTION_HAS_NO_ERROR                       = "option of type %(y) has no error"s8
| OPTION_HAS_NO_VALUE                       = "option of type %(y) has no value"s8
| OPTION_MATCHER                            = "option matcher %(y) only applies to option values not %(y)"s8
| OVERFLOW_CAPACITY                         = "overflow capacity for type %(y) = %(y), maximum value is %(y)"s8
| OVERFLOW_CAPACITY_ARRAY                   = "static array size %(y) exceeds limits %(y)"s8
| OVERFLOW_CAPACITY_MIN                     = "overflow capacity for type %(y) = %(y), minimum value is %(y)"s8
| OVERRIDE_FIELD_NO_FIELD                   = "method %(y) must be a field method to override %(y)"s8
| OVERRIDE_FINAL                            = "cannot override final method %(y)"s8
| OVERRIDE_MISMATCH_PROTECTION              = "the protection %(y) of the overriden method %(y) does not match with the definition of the ancestor class %(y)"s8
| OVERRIDE_MULTIPLE_TIMES_TRAIT             = "trait method %(y) was already overriden"s8
| OVERRIDE_NON_TRAIT_INSIDE                 = "cannot override a non trait method %(y) with %(y) inside impl"s8
| OVERRIDE_NOTHING                          = "method %(y) overrides nothing"s8
| OVERRIDE_NO_FIELD_BY_FIELD                = "field method %(y) cannot override the non field method %(y)"s8
| OVERRIDE_PRIVATE                          = "cannot override private method %(y)"s8
| OVERRIDE_TRAIT_OUTSIDE                    = "cannot override trait method %(y) with %(y) outside impl"s8
| PARAMETER_NAME                            = "for parameter %(y)"s8
| PATTERN_IS_REFUTABLE                      = "the pattern %(y) with value %(y) is refutable"s8
| RANGE_ON_ARRAY_NO_COPY                    = "the index operator on %(y) with an dynamic operand of type %(y) is allowed only in the context of a copy statement"s8
| RETURN_NO_FUNCTION                        = "return statement is not within a function"s8
| SHADOWING_DECL                            = "declaration of %(y) shadows another declaration"s8
| TEMPLATE_REST                             = "template validation incomplete, rest : {%(y)}"s8
| TEMPLATE_SPE                              = "with %(y)"s8
| TEMPLATE_SPECIALIZATION_FAILS             = "template specialization for %(y) fails with %(y)"s8
| TEMPLATE_SPECIALIZATION_FAILS_SIMPLE      = "template specialization fails with %(y)"s8
| TEMPLATE_TEST_FAILED                      = "the test of the template specialization failed"s8
| TEMPLATE_VALUE_TRY                        = "when trying template value resolution"s8
| THROWS_IN_LAMBDA                          = "a lambda function must be safe, but there are exceptions that are not caught"s8
| THROWS_NOT_DECLARED                       = "the function %(y) might throw an exception of type %(y), but that is not declared in its prototype"s8
| THROWS_NOT_USED                           = "the function %(y) prototype informs about a possible throw of an exception of type %(y), but this is not true"s8
| TOO_FEW_PARAMETERS                        = "%(y) parameters % expected, but %(y) % provided"s8
| TUPLE_ARITY_OVERFLOW                      = "tuple access out of bound (%(y)), tuple arity is %(y)"s8
| TUPLE_MATCHER                             = "tuple matcher only applies to tuple values not %(y)"s8
| TUPLE_PATTERN                             = "pattern %(y) only matches tuple values, not %(y)"s8
| TYPE_HAS_NO_SIZE                          = "temporary type %(y) has no size"s8
| TYPE_NO_FIELD                             = "type %(y) has no field named %(y)"s8
| UFC_REWRITING                             = "when using uniform function call syntax"s8
| UNDEFINED_ATTRIBUTE                       = "attribute %(y) is not usable in this context"s8
| UNDEFINED_BIN_ACC_OP                      = "undefined operator %(y) for type %(y) and field %(y)"s8
| UNDEFINED_BIN_MOD_OP                      = "undefined module operator %(y) for %(y) and field %(y)"s8
| UNDEFINED_BIN_OP                          = "undefined operator %(y) for types %(y) and %(y)"s8
| UNDEFINED_BIN_OP_TOK                      = "undefined binary operator %(y)"s8
| UNDEFINED_CALL_OP                         = "the call operator is not defined for %(y) and %"s8
| UNDEFINED_CAST_OP                         = "cannot cast value of type %(y) into a value of type %(y)"s8
| UNDEFINED_DOLLAR_OP                       = "operator '$' is not defined for type %(y)"s8
| UNDEFINED_ESCAPE                          = "undefined escape sequence"s8
| UNDEFINED_INDEX_OP                        = "the index operator is not defined for type %(y) and %(y)"s8
| UNDEFINED_SUPER_CALL_CTOR                 = "no constructor of the super class is callable with the parameters %(y)"s8
| UNDEFINED_TEMPLATE_CALL                   = "undefined template call for %(y) with %(y)"s8
| UNDEFINED_UN_OP                           = "undefined operator %(y) for type %(y)"s8
| UNDEFINED_UN_OP_TOK                       = "undefined operator unary operator %(y)"s8
| UNDEF_CTE_FOR_LOOP_OPERATOR               = "undefine cte for loop operator with %(y) iterator for type %(y)"s8
| UNDEF_DECORATOR_TEMPLATE                  = "decorator %(y) is not applicable in template specialization"s8
| UNDEF_DECORATOR_TYPE                      = "decorator %(y) is not applicable for types"s8
| UNDEF_FOR_LOOP_OPERATOR                   = "undefine for loop operator with %(y) iterator for type %(y)"s8
| UNDEF_VAR                                 = "undefined symbol %(y)"s8
| UNECESSARY_ALIAS                          = "aliasing the value of type %(y) to create a constant borrowing is prohibited"s8
| UNECESSARY_REFERENCE                      = "referencing the value has no effect"s8
| UNINIT_FIELD                              = "the field %(y) has no initial value"s8
| UNKNOWN_AT_COMPILE_TIME                   = "value of type %(y) is needed but unknown at compilation time"s8
| UNKNOWN_LENGTH_OF_EXPANSION               = "unknown length of expansion for type %(y)"s8
| UNKNOWN_PRAGMA                            = "unknown __pragma expression %(y)"s8
| UNREACHABLE_MATCHER                       = "matcher expression is never evaluated"s8
| UNREACHBLE_STATEMENT                      = "unreachable statement"s8
| UNRESOLVED_TEMPLATE                       = "unresolved template"s8
| UNSAFE_CALL                               = "call of unsafe function outside unsafe context"s8
| UNSAFE_OPERATION                          = "unsafe operation outside unsafe context"s8
| UNTERMINATED_ESCAPE                       = "unterminated escape sequence"s8
| USELESS_COND_FALSE                        = "conditional test is always evaluated to @(y=false), branch is never entered"s8
| USELESS_COND_TRUE                         = "conditional test is always evaluated to @(y=true), branch is always entered"s8
| USELESS_RUNTIME_ASSERT                    = "useless runtime assertion for a test that is always @(y=true)"s8
| USE_AS_TYPE                               = "expression used as a type"s8
| USE_AS_TYPE_TEMPLATE                      = "template specialization expected a type not the value %(y)"s8
| USE_AS_VALUE                              = "expression used as a value"s8
| USE_AS_VALUE_TEMPLATE                     = "template specialization expected a value not the type %(y)"s8
| VALIDATING                                = "when validating"s8
| VALIDATING_SYMBOL                         = "when validating %(y)"s8
| VAR_DECL_WITHOUT_VALUE                    = "var declared without value, when necessary"s8
| VAR_DECL_WITH_NOTHING                     = "var declaration must at least have a type or a value"s8
| VOID_VALUE                                = "void expression cannot be used as a value"s8
| VOID_VAR                                  = "cannot create a variable of type void"s8
| WHEN_CREATING_VALUE                       = "when creating the value %(y)"s8
| WITHIN_STRUCT_TYPE                        = "within struct type %(y)"s8
| WORKS_WITH_BOTH                           = "%(y) called with %(y) works with multiple candidates"s8
 -> ValidateErrorMessage;
