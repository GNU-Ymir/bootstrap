mod ymirc::semantic::validator::errors;

/**
 * All the error messages that can occur in symbol validation
 */
pub enum
| ALREADY_INIT_BY_CTOR_REDIRECT     = "field %(y) was already initialized by ctor redirection"s8
| ARRAY_OVERFLOW                    = "slice access, index overflow %(y) (len) <= %(y) (index)"s8
| BRANCHING_VALUE                   = "for branching value"s8
| BREAK_NO_LOOP                     = "break statement is not within a loop"s8
| CANDIDATE_ARE                     = "candidate %(y)"s8
| CLASS_FIELD_NOT_INIT_YET          = "field %(y) has not yet been initialized"s8
| CLASS_NOT_IMPL                    = "class type %(y) does not implement trait %(y)"s8
| CLASS_NO_FIELD                    = "class %(y) has no field named %(y)"s8
| COLLIDING_METHOD_DEFINITION       = "colliding method definitions %(y) and %(y)"s8
| CONFLIT_DECORATORS                = "conflicting decorators %(y) and %(y)"s8
| CONST_METHOD                      = "method %(y) is defined as constant"s8
| CTE_ASSERT_NO_MSG                 = "cte assertion failed"s8
| CTE_ASSERT_WITH_MSG               = "cte assertion failed %(y)"s8
| CTE_IGNORED                       = "%(y) values contained in block scope are ignored at compile time execution"s8
| DECLARED_HERE                     = "declared here"s8
| DECLARED_NOT_USED                 = "the symbol %(y) was declared but never used"s8
| DECLARE_VOID_VAR                  = "cannot declare a variable of type %(y)"s8
| DECREASING_RANGE_ACCESS           = "range index cannot be decreasing for type %(y), but goes from %(y) to %(y)"s8
| DEEPLY_INNER_TYPE                 = "decorator is not applicable on inner types, already deeply mutable"s8
| DEFAULT_VAR_NO_NAME               = "parameter with a default value must have a referencaable name"s8
| DEFINED_HERE                      = "defined here"s8
| DISCARD_CONST                     = "discard the constant property is prohibited"s8
| DISCARD_CONST_LEVEL               = "discard the constant property is prohibited, left operand mutability level is %(y) but must be at most %(y)"s8
| DISCARD_CONST_LEVEL_TYPES         = "from %(y) to %(y)"s8
| DIVISION_BY_ZERO                  = "division by 0"s8
| DOLLAR_OUTSIDE_CONTEXT            = "'$' is usable only inside an index operation"s8
| EMPTY_ARRAY_INNER                 = "array inner type cannot be %(y)"s8
| ENCLOSE_INCOMPLETE_TYPE           = "the type %(y) cannot be enclosed because it is not complete"s8
| FIELD_METHOD_PARAMS               = "field method cannot have parameters"s8
| FIRST_DEFINED                     = "defined here"s8
| FORBID_DECO_FOR_LOOP              = "decorators are forbidden on %(y) iteration"s8
| FORGET_AND_CLASS                  = "did you forget '&'"s8
| FORWARD_REFERENCE_TYPE            = "the type cannot be validated due to forward reference"s8
| FORWARD_REFERENCE_VALUE           = "the value cannot be computed, as it depends on a forward reference"s8
| FORWARD_REFERENCE_VAR             = "the type cannot be infered, as it depends on a forward reference"s8
| FOR_FIELD                         = "for the field %(y)"s8
| FOR_TUPLE_TYPE                    = "within tuple type %(y)"s8
| HERE                              = "here"s8
| IMMUTABLE_LVALUE                  = "left operand of type %(y) is immutable"s8
| IMMUTABLE_PARENT                  = "type must be immutable"s8
| IMPLICIT_ALIAS                    = "implicit alias of type %(y) is prohibited, it will implicitly discard constant property"s8
| IMPLICIT_OVERRIDE                 = "method %(y) implicitly override method %(y)"s8
| IMPLICIT_OVERRIDE_BY_TRAIT        = "implicit override of method %(y) by trait impl"s8
| IMPLICIT_PURE                     = "implicit pure of type %(y) is prohibited, it will implicitly discard constant property"s8
| IMPLICIT_REFERENCE                = "implicit reference of type %(y) is prohibited"s8
| IMPL_NO_TRAIT                     = "impl statement must be followed by a trait, not %(y)"s8
| INCOMPATIBLE_TYPE                 = "incompatible types %(y) and %(y)"s8
| INCOMPATIBLE_VALUES               = "incompatible values %(y) and %(y)"s8
| INCOMPLETE_TYPE                   = "the type %(y) is not complete"s8
| INCOMPLETE_TYPE_CLASS             = "the type %(y) is not complete due to previous errors"s8
| INHERIT_FINAL_CLASS               = "the base class %(y) is marked as final"s8
| INHERIT_NO_CLASS                  = "the base of a class must be a class, not a %(y)"s8
| INLINE_VIRTUAL_METHOD             = "method %(y) cannot be inline as it is virtual (overridable or inherited)"s8
| IS_NATIVE_TYPE                    = "cannot declare a variable named %(y), identifier is already used for a native type"s8
| IS_NOT_CALLABLE                   = "call operator is not defined for value %(y)"s8
| MAIN_FUNCTION_ONE_ARG             = "main function takes at most one argument"s8
| MAIN_INLINE                       = "main function cannot be inline"s8
| MALFORMED_CHAR                    = "malformed literal, number of %(y) is %(y)"s8
| MALFORMED_FLOAT_LITERAL           = "malformed float literal %(y)"s8
| MALFORMED_INT_LITERAL             = "malformed int literal %(y)"s8
| MALFORMED_PRAGMA                  = "malformed __pragma %(y)"s8
| MALFORMED_TYPEINFO_CORE           = "core module typeinfo is malformed"s8
| MISMATCH_TUPLE_ARITY              = "mismatch tuple arity %(y) and %(y)"s8
| MULTIPLE_DECORATORS               = "decorator %(y) is specified multiple times"s8
| MULTIPLE_FIELD_INIT               = "field %(y) is initialized multiple times"s8
| MULTIPLE_UNSAFE                   = "context is already unsafe"s8
| MUTABLE_CONST_PARAM               = "a parameter cannot be mutable, if it is not a reference or an aliasable type"s8
| MUTABLE_METHOD                    = "method %(y) is defined as mutable"s8
| NEGATIVE_INT_INDEX                = "index cannot be negative for type %(y), but is %(y)"s8
| NOTHING_TO_CATCH                  = "nothing to catch"s8
| NOT_ALIASABLE                     = "%(y) is not an aliasable type"s8
| NOT_ANCESTOR                      = "%(y) is not an ancestor type of %(y)"s8
| NOT_AN_ARRAY                      = "%(y) is not an array type"s8
| NOT_A_CLASS                       = "%(y) is not a class type"s8
| NOT_A_LVALUE                      = "not a lvalue"s8
| NOT_A_LVALUE_TYPE                 = "value of type %(y) is not a lvalue"s8
| NOT_A_SLICE                       = "%(y) is not a slice type"s8
| NOT_A_STRUCT                      = "%(y) is not a struct type"s8
| NOT_A_TRAIT                       = "%(y) is not a trait"s8
| NOT_A_TUPLE                       = "%(y) is not a tuple type"s8
| NOT_CALLABLE                      = "call operator is not defined for type %(y)"s8
| NOT_UNSAFE                        = "an unsafe context is entered, but no unsafe operations are made"s8
| NO_COPY_EXIST                     = "no copy exists for type %(y)"s8
| NO_CTOR_FOUND                     = "no constructor found for class %(y)"s8
| NO_CTOR_FOUND_NAME                = "no constructor named %(y) found for class %(y)"s8
| NO_PARAMETER_NAMED                = "no parameter is named %(y)"s8
| NO_SIZE_FORWARD_REF               = "struct type %(y) has no size due to forward references"s8
| NO_SUPER_CLASS                    = "class %(y) has no ancestor"s8
| OVERFLOW_CAPACITY                 = "overflow capacity for type %(y) = %(y), maximum value is %(y)"s8
| OVERFLOW_CAPACITY_ARRAY           = "static array size %(y) exceeds limits %(y)"s8
| OVERFLOW_CAPACITY_MIN             = "overflow capacity for type %(y) = %(y), minimum value is %(y)"s8
| OVERRIDE_FIELD_NO_FIELD           = "method %(y) must be a field method to override %(y)"s8
| OVERRIDE_FINAL                    = "cannot override final method %(y)"s8
| OVERRIDE_MISMATCH_PROTECTION      = "the protection %(y) of the overriden method %(y) does not match with the definition of the ancestor class %(y)"s8
| OVERRIDE_MULTIPLE_TIMES_TRAIT     = "trait method %(y) was already overriden"s8
| OVERRIDE_NON_TRAIT_INSIDE         = "cannot override a non trait method %(y) with %(y) inside impl"s8
| OVERRIDE_NOTHING                  = "method %(y) overrides nothing"s8
| OVERRIDE_NO_FIELD_BY_FIELD        = "field method %(y) cannot override the non field method %(y)"s8
| OVERRIDE_PRIVATE                  = "cannot override private method %(y)"s8
| OVERRIDE_TRAIT_OUTSIDE            = "cannot override trait method %(y) with %(y) outside impl"s8
| PARAMETER_NAME                    = "for parameter %(y)"s8
| RETURN_NO_FUNCTION                = "return statement is not within a function"s8
| SHADOWING_DECL                    = "declaration of %(y) shadows another declaration"s8
| TEMPLATE_REST                     = "template validation incomplete, rest : {%(y)}"s8
| TEMPLATE_SPE                      = "with %(y)"s8
| TEMPLATE_SPECIALIZATION_FAILS     = "template specialization for %(y) fails with %(y)"s8
| TEMPLATE_TEST_FAILED              = "the test of the template specialization failed"s8
| TEMPLATE_VALUE_TRY                = "when trying template value resolution"s8
| THROWS_IN_LAMBDA                  = "a lambda function must be safe, but there are exceptions that are not caught"s8
| THROWS_NOT_DECLARED               = "the function %(y) might throw an exception of type %(y), but that is not declared in its prototype"s8
| THROWS_NOT_USED                   = "the function %(y) prototype informs about a possible throw of an exception of type %(y), but this is not true"s8
| TOO_FEW_PARAMETERS                = "%(y) parameters are expected, but %(y) are provided"s8
| TOO_FEW_PARAMETERS_ONE            = "%(y) parameters are expected, but %(y) is provided"s8
| TUPLE_ARITY_OVERFLOW              = "tuple access out of bound (%(y)), tuple arity is %(y)"s8
| TYPE_HAS_NO_SIZE                  = "temporary type %(y) has no size"s8
| TYPE_NO_FIELD                     = "type %(y) has no field named %(y)"s8
| UFC_REWRITING                     = "when using uniform function call syntax"s8
| UNDEFINED_ATTRIBUTE               = "attribute %(y) is not usable in this context"s8
| UNDEFINED_BIN_ACC_OP              = "undefined operator %(y) for type %(y) and field %(y)"s8
| UNDEFINED_BIN_MOD_OP              = "undefined module operator %(y) for %(y) and field %(y)"s8
| UNDEFINED_BIN_OP                  = "undefined operator %(y) for types %(y) and %(y)"s8
| UNDEFINED_BIN_OP_TOK              = "undefined binary operator %(y)"s8
| UNDEFINED_CALL_OP                 = "the call operator is not defined for %(y) and %"s8
| UNDEFINED_CAST_OP                 = "cannot cast value of type %(y) into a value of type %(y)"s8
| UNDEFINED_DOLLAR_OP               = "operator '$' is not defined for type %(y)"s8
| UNDEFINED_ESCAPE                  = "undefined escape sequence"s8
| UNDEFINED_INDEX_OP                = "the index operator is not defined for type %(y) and %(y)"s8
| UNDEFINED_SUPER_CALL_CTOR         = "no constructor of the super class is callable with the parameters %(y)"s8
| UNDEFINED_TEMPLATE_CALL           = "undefined template call for %(y) with %(y)"s8
| UNDEFINED_UN_OP                   = "undefined operator %(y) for type %(y)"s8
| UNDEFINED_UN_OP_TOK               = "undefined operator unary operator %(y)"s8
| UNDEF_DECORATOR_TEMPLATE          = "decorator %(y) is not applicable in template specialization"s8
| UNDEF_DECORATOR_TYPE              = "decorator %(y) is not applicable for types"s8
| UNDEF_FOR_LOOP_OPERATOR           = "undefine for loop operator with %(y) iterator for type %(y)"s8
| UNDEF_VAR                         = "undefined symbol %(y)"s8
| UNECESSARY_ALIAS                  = "aliasing the value to create a constant borrowing is prohibited"s8
| UNECESSARY_REFERENCE              = "referencing the value has no effect"s8
| UNINIT_FIELD                      = "the field %(y) has no initial value"s8
| UNKNOWN_AT_COMPILE_TIME           = "value of type %(y) is needed but unknown at compilation time"s8
| UNKNOWN_PRAGMA                    = "unknown __pragma expression %(y)"s8
| UNREACHBLE_STATEMENT              = "unreachable statement"s8
| UNRESOLVED_TEMPLATE               = "unresolved template"s8
| UNSAFE_CALL                       = "call of unsafe function outside unsafe context"s8
| UNSAFE_OPERATION                  = "unsafe operation outside unsafe context"s8
| UNTERMINATED_ESCAPE               = "unterminated escape sequence"s8
| USE_AS_TYPE                       = "expression used as a type"s8
| USE_AS_VALUE                      = "expression used as a value"s8
| VALIDATING                        = "when validating"s8
| VALIDATING_SYMBOL                 = "when validating %(y)"s8
| VAR_DECL_WITHOUT_VALUE            = "var declared without value, when necessary"s8
| VAR_DECL_WITH_NOTHING             = "var declaration must at least have a type or a value"s8
| VOID_VALUE                        = "void expression cannot be used as a value"s8
| VOID_VAR                          = "cannot create a variable of type void"s8
| WHEN_CREATING_VALUE               = "when creating the value %(y)"s8
| WITHIN_STRUCT_TYPE                = "within struct type %(y)"s8
| WORKS_WITH_BOTH                   = "%(y) called with %(y) works with multiple candidates"s8
 -> ValidateErrorMessage;
