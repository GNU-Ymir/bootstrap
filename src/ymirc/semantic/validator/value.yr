in value;

use ymirc::semantic::validator::{visitor, errors, template::_};
use ymirc::syntax::{_,
                    declaration::_,
                    expression::{_, literal::_, macro_::_, operator::_, template::_}};

use ymirc::syntax::keys;
use ymirc::semantic::symbol::_;
use ymirc::semantic::declarator::visitor;

use ymirc::semantic::generator::_;
use ymirc::global::core_;
use ymirc::errors::_;
use ymirc::utils::format;
use ymirc::lexing::{word, tokens};
use std::{io, stream, time::_};

use ymirc::semantic::generator::type::{_,
                                       syntax::_,
                                       custom::_,
                                       native::{_, scalar::_, compound::_},
                                       temporary::_};

use ymirc::semantic::generator::value::{_,
                                        syntax::_,
                                        construct::{_, delegate::_},
                                        literal::_,
                                        memory::_,
                                        operator::{_, binary::_, call::_, fields::_, map::_, slice::_, unary::_},
                                        operator::map::iteration::_,
                                        prototypes::_,
                                        scope::_,
                                        syntax::_,
                                        template::_};


/**
 * The value validator is the class responsible for value expression validation
 */
pub record ValueValidator {

    /**
     * Create a new empty validator
     */
    pub self () {}


    /**
     * Validate an expression assuming its a value
     * @params: 
     *    - context: the context of the validation
     *    - value: the expression to validate
     * @throws: &ErrorMsg, if the expression is not valid
     * @returns: a generator containing the validated value
     */
    pub fn validate (self, dmut context : &Validator, value : &Expression, canBeRef : bool = false, canBeLazy : bool = false)-> &Value
        throws ErrorMsg
    {
        match value {
            b : &BlockExpr           => return self.validateBlock (alias context, b);
            l : &LiteralExpr         => return self.validateLiteral (alias context, l);
            o : &OperatorExpr        => return self.validateOperator (alias context, o);
            v : &VarDeclExpr         => return self.validateVarDecl (alias context, v);
            p : &PatternVarDeclExpr  => return self.validatePatternVarDecl (alias context, p);
            s : &SetExpr             => return self.validateSet (alias context, s);
            d : &DecoratedExpr       => return self.validateDecoExpr (alias context, d);
            c : &ConditionalExpr     => return self.validateConditional (alias context, c);
            f : &ForLoopExpr         => return self.validateForLoop (alias context, f);
            w : &WhileLoopExpr       => return self.validateWhileLoop (alias context, w);
            b : &BreakExpr           => return self.validateBreak (alias context, b);
            r : &ReturnExpr          => return self.validateReturn (alias context, r);
            t : &ThrowExpr           => return self.validateThrow (alias context, t);
            p : &PanicExpr           => return self.validatePanic (alias context, p);
            m : &MatcherExpr         => return self.validateMatcher (alias context, m);
            m : &MacroCallExpr       => return self.validateMacroCall (alias context, m);
            p : &PragmaExpr          => return self.validatePragma (alias context, p);
            a : &AssertExpr          => return self.validateAssert (alias context, a);
            t : &TryExpr             => return self.validateTry (alias context, t);
            a : &AtomicExpr          => return self.validateAtomic (alias context, a);
            c : &CastExpr            => return self.validateCast (alias context, c);
            l : &ListExpr            => return self.validateList (alias context, l);
            l : &ListMapExpr         => return self.validateListMap (alias context, l);
            i : &IntrinsicExpr       => return self.validateIntrinsics (alias context, i, canValidateRef-> canBeRef, canBeLazy-> canBeLazy);
            n : &NamedExpr           => return self.validateNamedExpr (alias context, n, canBeRef-> canBeRef, canBeLazy-> canBeLazy);
            t : &TemplateCallExpr    => return self.validateTemplateCall (alias context, t);
            t : &TemplateCheckerExpr => return self.validateTemplateChecker (alias context, t);
            l : &LambdaValueExpr     => return self.validateLambda (alias context, l);
            e : &EmptyExpression     => return copy UnitValue (loc-> e.getLoc ());
            w : &ValueWrapperExpr    => return w.getValue ();
            s : &SliceAllocatorExpr  => return self.validateSliceAllocator (alias context, s);
            s : &SliceForAllocatorExpr => return self.validateSliceFor (alias context, s);
            u : &UnsafeExpr          => return self.validateUnsafe (alias context, u);
            t : &TypeWrapperExpr => return self.validateValueFromTemplateType (alias context, t);
            x : _ => {
                throw copy ErrorMsg::fatal (value.getLoc (), format (ValidateErrorMessage::USE_AS_VALUE_TYPE, x));
            }            
        }
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================            BLOCK             =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a block expression
     * @params: 
     *   - context: the context of the validation
     *   - b: the block to validate
     * @returns: the validated value
     */
    fn validateBlock (self, dmut context : &Validator, b : &BlockExpr)-> &Value
        throws ErrorMsg
    {
        let mut errors : [mut &ErrorMsg] = [];
        context:.enterBlock ();
        
        let (values, valuesType, rtLoc, brLoc, valueLoc) = {
            // A block can have local symbol definitions (such as import, struct, etc.), we need to validate them
            let dmut module = self.validateInnerModule (alias context, b.getModule (), ref errors);
            
            let value = match module {                
                EmptySymbol () => { // No local symbol to access
                    self.validateInnerBlock (alias context, b.getExpressions (), ref errors)
                }
                _ => {
                    {
                        // There are some local symbols, we need to have access to them in the current block
                        context:.pushReferent (alias module);
                        self.validateInnerBlock (alias context, b.getExpressions (), ref errors)
                    } exit {
                        context:.popReferent (); // We go back to the previous symbol table, all local symbol are no longer accessible
                    }
                }
            };

            value
        } exit {

            {
                // No need to warn unused if there were errors in the validation of the block (it will complicate the error handling)
                context:.quitBlock (warnUnused-> (errors.len == 0us));
            } catch { err : &ErrorMsg => { errors ~= [err]; } }
        }

        let loc = if (!valueLoc.isEof ()) { valueLoc } else { b.getLoc () };
        let trB = copy BlockValue (loc, valuesType, values, breakLoc-> brLoc, returnLoc-> rtLoc);
        let (retBlock, type, canThrow) = match (b.getCatcher (), errors.len) {
            (m : &MatcherExpr, 0us) => {
                let (catcher, ctVar, finType) = self.validateCatcher (alias context, m, valuesType, trB.getThrowers (), ref errors);
                let trBlock = copy BlockValue (loc, finType, values, breakLoc-> brLoc, returnLoc-> rtLoc);
                (copy TryCatchValue (loc, finType, trBlock, catcher, catchVar-> ctVar), finType, true)

            }
            _ => {
                (trB, valuesType, trB.getThrowers ().len != 0us)
            }
        };

        let finalValue = if (errors.len == 0us && b.getGuards ().len != 0us) {
            let (onExit, failVar) = self.validateScopeGuards (alias context, b.getLoc (), b.getGuards (), canThrow, ref errors);
            copy TryFinallyValue (loc, type, retBlock, onExit, failVar-> failVar)
        } else {
            retBlock
        };

        if (errors.len != 0us) throw copy ErrorMsg::list (errors);
        finalValue
    }


    /**
     * Validate the local module declared inside a block
     * @params: 
     *    - context: the context of the validation
     *    - m: the module declared in the block
     * @returns:
     *    - errors: the errors that occured when validating    
     *    - the symbol that was validated (or EmptySymbol, if the validation failed)
     */
    fn validateInnerModule (self, dmut context : &Validator, m : &Declaration, ref mut errors : [&ErrorMsg])-> dmut &Symbol {
        match m {
            b : &BlockDecl => if (b.getDeclarations ().len == 0us) return alias EMPTY_SYMBOL;
        }

        let dmut modSym = {   // We get the declarator of the context, maybe there are imports here, and maybe they are already imported, so we just have to make a reference
            let dmut modSym = copy ModuleSymbol (copy Word (Keys::UNDER, m.getLoc ()), importLoc-> EOF_WORD, "", protection-> Protection::PRIVATE);
            modSym:.setReferent (alias context:.getReferent ());

            context:.getDeclarator ():.declare (m, alias modSym);
            context:.getDeclarator ():.finalizeDeclaration (alias modSym);

            alias modSym
        } catch {
            err : &ErrorMsg => {
                errors ~= [err];
                return alias EMPTY_SYMBOL;
            }
        };

        context:.enterForeign (isFnBody-> false, clContext-> context.getCurrentClassContext ()); // Enter a foreign, but this is not a function, we just want to avoid polluting the current context
        
        {
            context:.validate (alias modSym);  // Validation of the declared symbols 
        } catch {
            err : &ErrorMsg => {
                errors ~= [err];
                return alias EMPTY_SYMBOL;
            }
        } exit {            
            context:.exitForeign ();
        }
        
        // Here we return a leaf that can be accessed only from the current block            
        return alias modSym;     
    }

    /**
     * Validate the content of a block
     * @params: 
     *   - context: the context of the validation
     *   - m: the block to validate
     * @returns:
     *   - errors: the list of errors, if an errors occurs
     *   - .0: the list of values inside the block
     *   - .1: the type of the last value
     *   - .2: the location of a return statement if any (EOF otherwise)
     *   - .3: the location of a break statement if any (EOF otherwise)
     *   - .4: the location of the last value
     */
    fn validateInnerBlock (self, dmut context : &Validator, exprs : [&Expression], ref mut errors : [&ErrorMsg])-> ([&Value], &Type, &Word, &Word, &Word) {
        let mut returner = false, mut breaker = false; // Blocks can break loops or return functions
        // A returned block is a block in which every path leads to a return statement, and a break statement is breaker
        
        let mut rtLoc = EOF_WORD, mut brLoc = EOF_WORD, mut valueLoc = EOF_WORD; // The location of the return, break, and value for error handling
        let mut type : &Type = VOID_TYPE; // By default a block has no value, thus its type is void
        let mut values : [mut &Value] = []; // List of values in the block
        for i in 0us .. exprs.len {
            {
                // There is another expression to validate, but there is no way that the program arrives at that point (cf. breaker or returner)
                if ((breaker || returner) && exprs [i] !of EmptyExpression) {
                    throw copy ErrorMsg::fatal (exprs [i].getLoc (), ValidateErrorMessage::UNREACHBLE_STATEMENT, notes-> copy [copy ErrorMsg::note (rtLoc, ValidateErrorMessage::EXITING_SCOPE_HERE)]);
                }

                let val = context:.validateValue (exprs [i]);
                context.verifyCompleteTypeWithValue (exprs [i].getLoc (), val.getType (), val, construct-> false);

                if (val.isReturner ()) { returner = true; rtLoc = val.getReturnerLoc (); } else { returner = false; }
                if (val.isBreaker ())  { breaker = true; rtLoc = val.getBreakerLoc (); } else { breaker = false; }

                // If the value is implicitely aliased, then we transform it into a immutable value
                type = if (context.needExplicitAlias (val)) {
                    val.getType ().clone (0u32)
                } else {
                    val.getType ()
                };
                
                valueLoc = val.getLoc (); // store the location of the value of the block (if it is the last value, it will be definitely stored)
                if (i == exprs.len - 1us || val !of UnitValue) { // ignore unit values, if there created by otherthings than EmptyExpression
                    values ~= [val];  // push the value in the list of value of the block
                }
            } catch {
                err : &ErrorMsg => { errors ~= [err]; }
            }            
        }

        match type { 
            VoidType () => {} 
            _ => { // Verify implicit aliases and stuff
                values [$ - 1] = context:.verifyCompatibleTypeWithValue (valueLoc, type, values [$ - 1], byReference-> false);
                context.verifyMemoryOwner (valueLoc, type, values [$ - 1], byReference-> false);
            } catch {
                err : &ErrorMsg => { errors ~= [err]; }
            }
        }

        (values, type, rtLoc, brLoc, valueLoc)
    }


    /**
     * Validate the catcher part of a block
     * @params: 
     *   - context: the context of the validation
     *   - catcher: the catcher to validate
     *   - type: the type of the block that is catched
     *   - throwers: the list of exception thrown by the block
     * @returns: 
     *   - errors: if errors occured
     *   - .0: the content of the catcher
     *   - .1: the variable that is catched
     *   - .2: the type of the value (try{} catch{})
     */
    fn validateCatcher (self, dmut context : &Validator, catcher : &MatcherExpr, type : &Type, throwers : [(&Word, &Type)], ref mut errors : [&ErrorMsg])-> (&Value, &Value, &Type) {
        if (throwers.len == 0us) {
            errors ~= [copy ErrorMsg::fatal (catcher.getLoc (), ValidateErrorMessage::NOTHING_TO_CATCH)];
            (UNIT_VALUE, UNIT_VALUE, NONE_TYPE)
        } else {
            let mut failed = false;

            context:.enterBlock ();
            let (content, catchVar, finType) = {
                let mut caughtType = context.createClassInstance (throwers [0]._1); // throwers are class ref, but catch variable is a class ptr
                {
                    for i in 1us .. throwers.len {
                        caughtType = context.inferTypeBranching (catcher.getLoc (), throwers [i]._0, caughtType, context.createClassInstance (throwers [i]._1));
                    }
                } catch {
                    _ => {
                        caughtType = context:.getExceptionType (loc-> catcher.getLoc ());
                    }
                };

                let catchVar = copy VarDeclValue (copy Word ("#_catch", catcher.getLoc ()), caughtType, UNIT_VALUE, isMutable-> false);
                let catchVarRef = copy VarRefValue (catchVar.getLoc (), catchVar.getLoc (), catchVar.getVarType (), catchVar.getUniqId (), isSelf-> false, canCte-> false);

                let (x, y) = context:.getMatcherValidator ().validateCatcher (alias context, catcher, type, catchVarRef, throwers);
                (x, catchVar, y)
            } catch {
                err : &ErrorMsg => {
                    failed = true;
                    errors ~= [err];
                    (UNIT_VALUE, UNIT_VALUE, NONE_TYPE)
                }
            };

            {
                context:.quitBlock (warnUnused-> !failed)
            } catch {
                err : &ErrorMsg => { errors ~= [err]; }
            }

            (content, catchVar, finType)
        }
    }

    /**
     * Validate the scope guards of a block expression
     * @params:
     *    - context: the context of the validation
     *    - guards: the scope guards to validate
     *    - throwers: the list of throwers from the guarded scope
     * @returns:
     *    - errors: filled with errors if some occured
     *    - .0: the content of the validated scope guard
     *    - .1: the variable to declare in case of failure/success guards (might be UNIT_VALUE)
     * */
    fn validateScopeGuards (self, dmut context : &Validator, loc : &Word, guards : [&ScopeGuardExpr], canThrow : bool, ref mut errors : [&ErrorMsg])-> (&Value, &Value) {
        let mut exit : &Value = UNIT_VALUE;
        let mut fail : &Value = UNIT_VALUE;
        let mut succ : &Value = UNIT_VALUE;

        // already inside a scope guard, scope within another scope
        let inScope = context.getInScopeGuard ();
        for gu in guards {
            match gu.getKind () {
                ScopeGuardType::FAILURE | ScopeGuardType::SUCCESS => {
                    if !canThrow {
                        errors ~= [copy ErrorMsg::fatal (gu.getLoc (), format (ValidateErrorMessage::EXIT_SCOPE_NO_THROW, gu.getLoc ().str))];
                    }
                }
            }

            let mut failed = false;
            context:.enterBlock ();
            if (inScope.isEof ()) context:.enterScopeGuard (gu.getLoc ());

            let value = {
                context:.validateValue (gu.getContent ())
            } catch {
                err : &ErrorMsg => {
                    errors ~= [err];
                    failed = true;
                    UNIT_VALUE
                }
            };

            for i in value.getThrowers () { // cannot throw error in a scope guard
                errors ~= [copy ErrorMsg::fatal (i.0, end-> gu.getLoc (), format (ValidateErrorMessage::THROW_SCOPE_GUARD_RETHROW, i._1))];
            }

            {
                if (inScope.isEof ()) context:.exitScopeGuard ();
                context:.quitBlock (warnUnused-> !failed)
            } catch {
                err : &ErrorMsg => { errors ~= [err]; }
            }

            if (value.getType () !of VoidType && value.getType () !of NoneType) {
                errors ~= [copy ErrorMsg::fatal (gu.getContent ().getLoc (), format (ValidateErrorMessage::EXIT_SCOPE_VALUE_TYPE, gu.getLoc ().str, value.getType ()))];
            }

            match gu.getKind () {
                ScopeGuardType::SUCCESS => { succ = value; }
                ScopeGuardType::FAILURE => { fail = value; }
                _ => { exit = value; }
            }
        }

        if (fail !of UnitValue || succ !of UnitValue) {
            let var  = copy VarDeclValue (copy Word ("#_failed", loc), copy BoolType (loc), copy BoolValue (loc, true), isMutable-> true);
            let vref = copy VarRefValue (var.getLoc (), var.getLoc (), var.getVarType (), var.getUniqId (), isSelf-> false, canCte-> false);

            let cnd = copy ConditionalValue (loc, copy VoidType (loc), vref, fail, succ);
            let finValue = if (exit of UnitValue) {
                cnd
            } else {
                copy BlockValue (loc, cnd.getType (), copy [cnd, exit])
            };


            (finValue, var)
        } else {
            (exit, UNIT_VALUE)
        }
    }

    /*!
     * ================================================================================
     * ================================================================================
     * ==========================           UNSAFE            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate an unsafe expression
     * @params:
     *    - context: the context of the validation
     *    - u: the unsafe expression to validate
     * @returns: the validated value
     * */
    fn validateUnsafe (self, dmut context : &Validator, u : &UnsafeExpr)-> &Value
        throws ErrorMsg
    {
        let loc = context.getUnsafeContextLoc ();
        if (!loc.isEof ()) throw copy ErrorMsg::fatal (u.getLoc (), ValidateErrorMessage::MULTIPLE_UNSAFE, notes-> copy [copy ErrorMsg::note (loc, "")]);

        let mut error : (&ErrorMsg)? = none;
        let value = {
            context:.enterUnsafeContext (u.getLoc ());
            context:.validateValue (u.getValue ())
        } exit {
            {
                context:.exitUnsafeContext ();
            } catch {
                err : &ErrorMsg => { error = err?; }
            }
        }

        match error {
            Ok (err : _) => throw err;
        }

        value
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =============================          TEMPLATE TYPE WRAPPER          ==============================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Validate a value from a template type wrapper that might contain a class ptr
     * @params:
     *    - context: the context of the validation
     *    - t: the type wrapper to validate
     * @returns: a value
     * @throws:
     *    - &ErrorMsg: if the validation fails
     * */
    fn validateValueFromTemplateType (self, dmut context : &Validator, t : &TypeWrapperExpr)-> &Value
        throws ErrorMsg
    {
        let type = context:.validateType (t);
        match type {
            c : &ClassRefType => {
                return context:.getSubTypeValidator ().validateClassCtors (alias context, t.getLoc (), c, name-> "");
            }
            c : &ClassPtrType => {
                return context:.getSubTypeValidator ().validateClassCtors (alias context, t.getLoc (), c.getInner (), name-> "");
            }
        }

        throw copy ErrorMsg::fatal (t.getLoc (), format (ValidateErrorMessage::USE_AS_VALUE_TYPE, type));
    }


    /*!
     * ================================================================================
     * ================================================================================
     * =========================           LITERAL            =========================
     * ================================================================================
     * ================================================================================
     */
    
    
    /**
     * Validate a literal expression
     * @params: 
     *   - context: the context of the validation
     *   - l: the literal to validate
     *   - forceType: the type to force (if different from NONE_TYPE), only applicable in some case (e.g. StringExpr)
     * @returns: the validated value
     */
    fn validateLiteral (self, dmut context : &Validator, l : &LiteralExpr)-> &Value
        throws ErrorMsg
    {
        return context:.getLiteralValidator ().validate (alias context, l);
    }


    /*!
     * ================================================================================
     * ================================================================================
     * =========================            LAMBDA             ========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a lambda value expression
     * @params: 
     *   - context: the context of the validation
     *   - l: the lambda value
     * @returns: the validated value
     */
    fn validateLambda (self, dmut context : &Validator, l : &LambdaValueExpr)-> &Value
        throws ErrorMsg
    {
        context:.getLambdaValidator ():.validate (alias context, l)
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =====================          SLICE/ARRAYS/TUPLES           ===================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a list expression
     * */
    fn validateList (self, dmut context : &Validator, l : &ListExpr)-> &Value
        throws ErrorMsg
    {
        context:.getLiteralValidator ().validateList (alias context, l)
    }

    /**
     * Validate a map literal expression
     * */
    fn validateListMap (self, dmut context : &Validator, l : &ListMapExpr)-> &Value
        throws ErrorMsg
    {
        context:.getLiteralValidator ().validateListMap (alias context, l)
    }

    /**
     * Validate a slice allocator expression
     * */
    fn validateSliceAllocator (self, dmut context :  &Validator, l : &SliceAllocatorExpr)-> &Value
        throws ErrorMsg
    {
        context:.getLiteralValidator ().validateSliceAllocator (alias context, l)
    }

    /**
     * Validate a slice allocation using a for loop
     * @params:
     *    - context: the context of the validation
     *    - alloc: the allocator to validate
     * */
    fn validateSliceFor (self, dmut context : &Validator, alloc : &SliceForAllocatorExpr)-> &Value
        throws ErrorMsg
    {
        context:.getForLoopValidator ().validateListComprehension (alias context, alloc)
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================          OPERATORS           =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate an operator expression
     * @params: 
     *   - context: the context of the validation
     *   - o: the operator to validate
     * @returns: the validated value
     */
    fn validateOperator (self, dmut context : &Validator, o : &OperatorExpr)-> &Value
        throws ErrorMsg
    {
        match o {
            b : &BinaryExpr => return context:.getBinOpValidator ().validateValue (alias context, b);
            m : &MultOperatorExpr => {
                if (m.isIndex ()) {
                    return context:.getIndexOpValidator ().validate (alias context, m);
                } else {
                    return context:.getCallOpValidator ().validate (alias context, m);
                }
            }
            u : &UnaryExpr => return context:.getUnOpValidator ().validate (alias context, u);
            p : &PathExpr =>  return context:.getBinOpValidator ().validateModuleOperation (alias context, p);
            _ => {
                println ("Unknown OP : ", o.__typeinfo__.name);
                panic;
            }
        }
    }
    
    /*!
     * ================================================================================
     * ================================================================================
     * =========================           VAR_DECL           =========================
     * ================================================================================
     * ================================================================================
     */
    
    /**
     * Validate a var declaration expression
     * @params: 
     *   - context: the context of the validation
    *    - v: the var declaration to validate
     * @returns: the validated var decl value
     */
    pub fn validateVarDecl (self, dmut context : &Validator, v : &VarDeclExpr, needInitValue : bool = true)-> &VarDeclValue
        throws ErrorMsg
    {
        if (v.getValue () of EmptyExpression) {
            if (v.getType () of EmptyExpression) {
                throw copy ErrorMsg::fatal (v.getLoc (), ValidateErrorMessage::VAR_DECL_WITH_NOTHING);
            } else if (needInitValue) {
                throw copy ErrorMsg::fatal (v.getLoc (), ValidateErrorMessage::VAR_DECL_WITHOUT_VALUE);
            }

            self.validateVarDeclNoValue (alias context, v)
        } else {
            let rewrite = copy VarDeclExpr (v.getLoc (), v.getName (), value-> EMPTY_EXPR, type-> v.getType (),
                                            isLazyOrRef-> v.getLazyOrRefLocation (),
                                            isMutOrDmut-> v.getMutOrDmutLocation ());

            let fin = self.validatePatternVarDecl (alias context, copy PatternVarDeclExpr (v.getLoc (), rewrite, v.getValue ()));
            match fin {
                z : &VarDeclValue => {
                    return z;
                }
                _ => {
                    println (format ("% %", fin, fin.__typeinfo__.name));
                    panic;
                }
            }
        }
    }


    /**
     * Validate a var declaration that has no value
     * @params:
     *    - context: the context of the validation
     *    - v: the variable declaration to validate
     *    - needInitValue:
     * */
    fn validateVarDeclNoValue (self, dmut context : &Validator, v : &VarDeclExpr)-> &VarDeclValue
        throws ErrorMsg
    {
        let mut errors : [&ErrorMsg] = [];
        context.verifyShadow (v.getLoc ());

        let type = {
            context:.validateTypeForVarDecl (v.getType (), v, canBeRef-> true, canBeLazy-> true)
        }  catch {
            err : &ErrorMsg => { // error when validating the type of the variable, so it has an error type, no matter the value
                errors ~= [err];
                copy ErrorType (v.getLoc ())
            }
        };

        {
            context.verifyNonVoidType (v.getType ().getLoc (), type, true)
        } catch {
            err : &ErrorMsg => { errors ~= [err]; }
        }

        let finalType = if (errors.len != 0) {
            copy ErrorType (v.getLoc ())
        } else {
            type
        };

        let ret = copy VarDeclValue (v.getLoc (), finalType, UNIT_VALUE, isReference-> v.isRef (), isLazy-> v.isLazy (), isMutable-> type.isMutable ());
        context:.insertLocal (v.getLoc (), v.getLoc ().str, ret, canShadow-> false);

        if (errors.len != 0) throw copy ErrorMsg::list (errors);

        return ret;
    }

    /**
     * Validate a pattern var declaration
     * @params:
     *     - context: the context of the validation
     *     - p: the pattern to validate
     * @returns: the validate value
     * @throws:
     *     - If the validation fails
     * */
    fn validatePatternVarDecl (self, dmut context : &Validator, p : &PatternVarDeclExpr)-> &Value
        throws ErrorMsg
    {
        let mut blk : [&Value] = [];
        let (mValue, cond, vars, error) = context:.getMatcherValidator ().validateMatcher (alias context, p.getValue (), p.getPattern (), canBeLazy-> true);
        for v in vars { // insert the declared variables
            context:.insertLocal (v.1.getLoc (), v.0, v.1);
            blk ~= [v.1];
        }

        // error during the pattern matching, we throw it after inserting error variables to have better error printing for next statements using these variables
        if let Ok (err) = error { throw err; }

        // the test has to be irrefutable to be usable outside a conditional
        let reducedCond = context:.getCompileTimeInterpreter ():.reduce (cond);
        if (match reducedCond {
            b : &BoolValue => { !b.isTrue () }
            _ => { true }
        }) throw copy ErrorMsg::fatal (p.getLoc (), format (ValidateErrorMessage::PATTERN_IS_REFUTABLE, p.getPattern (), mValue));

        if (blk.len == 1us) {
            blk [0]
        } else {
            copy BlockValue (p.getLoc (), copy VoidType (p.getLoc ()), blk, isSet-> true)
        }
    }
    
    /**
     * Validate a set expression (generally a succession of var decl)
     * @params: 
     *   - context: the context of the validation
     *   - s: the set to validate
     * @returns: the validated value
     */
    fn validateSet (self, dmut context : &Validator, s : &SetExpr)-> &Value
        throws ErrorMsg
    {
        let mut errors : [&ErrorMsg] = [];
        let (values, type, brLoc, rtLoc, _) = {
            self.validateInnerBlock (alias context, s.getContent (), ref errors)
        };

        let retBlock = copy BlockValue (s.getLoc (), type, values, breakLoc-> brLoc, returnLoc-> rtLoc, isSet-> true);

        if (errors.len != 0) throw copy ErrorMsg::list (errors);
                
        retBlock
    }    

    /*!
     * ================================================================================
     * ================================================================================
     * =========================          DECORATED           =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a decorated expression as a value
     * @params:
     *    - context: the context of the validation
     *    - i: the decorated expression
     * */
    fn validateDecoExpr (self, dmut _ : &Validator, d : &DecoratedExpr)-> &Value
        throws ErrorMsg
    {
        throw copy ErrorMsg::fatal (d.getLoc (), format (ValidateErrorMessage::UNDEF_DECORATOR_VALUE, d.getDecorator ().str));
    }

    /**
     * Validate an intrinsic expr
     * @params: 
     *   - context: the context of the validation
     *   - i: the intrinsic expression to validate
     * @returns: the validated value
     */
    fn validateIntrinsics (self, dmut context : &Validator, i : &IntrinsicExpr, canValidateRef : bool = false, canBeLazy : bool = false)-> &Value
        throws ErrorMsg
    {
        match i.getType () {
            IntrinsicKeys::COPY => {
                if let lmbd : &LambdaValueExpr = i.getContent () {
                    return context:.getLambdaValidator ():.validate (alias context, lmbd, isClosure-> true, copyLoc-> i.getLoc ());
                } else {
                    return context:.getCopyValidator ().validateCopy (alias context, i);
                }
            }
            IntrinsicKeys::ALIAS  => {
                return self.validateAlias (alias context, i.getLoc (), i.getContent (), isClass-> false);
            }
            IntrinsicKeys::TYPEOF => { // Typeof is necessarily a type (it's in the name)
                throw copy ErrorMsg::fatal (i.getLoc (), format (ValidateErrorMessage::USE_AS_VALUE));
            }
            IntrinsicKeys::EXPAND => {
                return context:.getExpandValidator ().validateExpand (alias context, i);
            }
            IntrinsicKeys::DCOPY => {
                return context:.getCopyValidator ().validateDeepCopy (alias context, i);
            }
            IntrinsicKeys::CTE => {
                return self.validateCteExpr (alias context, i.getContent ());
            }
            IntrinsicKeys::REF => {
                return self.validateRefExpr (alias context, i, i.getContent (), canValidateRef-> canValidateRef);
            }
            IntrinsicKeys::MOVE => {
                return context:.getCopyValidator ().validateMove (alias context, i);
            }
            IntrinsicKeys::LAZY => {
                return self.validateLazy (alias context, i, i.getContent (), canBeLazy-> canBeLazy);
            }
            IntrinsicKeys::SPAWN => {
                return self.validateFuture (alias context, i, i.getContent ());
            }
        }

        panic;
    }

    /**
     * Validate an alias of a value
     * @returns: the validated value
     * @throws:
     *    - &ErrorMsg: if the value is not aliasable, or cannot be validated
     */
    pub fn validateAlias (self, dmut context : &Validator, loc : &Word, content : &Expression, isClass : bool = false, isField : bool = false)-> &Value
        throws ErrorMsg
    {
        let mut value = context:.getValueValidator ().validate (alias context, content, canBeLazy-> true);
        self.validateAlias (alias context, loc, value, isClass-> isClass, isField-> isField)
    }

    /**
     * Validate an alias of a value
     * @returns: the validated value
     * @throws:
     *    - &ErrorMsg: if the value is not aliasable, or cannot be validated
     */
    pub fn validateAlias (self, dmut context : &Validator, loc : &Word, value : &Value, isClass : bool = false, isField : bool = false)-> &Value
        throws ErrorMsg
    {
        if (isClass) {
            match value.getType () {
                cl : &ClassPtrType => {
                    if (cl.isStruct ()) {
                        context.verifyLeftOperandMove (loc, value, allowSelf-> true);
                    } else {
                        if (!cl.isDeeplyMutable ()) {
                            throw copy ErrorMsg::fatal (loc, end-> value.getLoc (), format (ValidateErrorMessage::NOT_A_LVALUE_TYPE, value.getType ()));
                        }
                    }

                    return copy ClassAliaserValue (loc, cl, value);
                }
                m : &MapType => {
                    if (!isField) throw copy ErrorMsg::fatal (value.getLoc (), format (ValidateErrorMessage::CLASS_ALIAS_INDEX_NO_CLASS, m));
                    if (!m.isMutable ()) {
                        throw copy ErrorMsg::fatal (loc, end-> value.getLoc (), format (ValidateErrorMessage::NOT_A_LVALUE_TYPE, m));
                    }

                    return copy MapAliaserValue (loc, m, value);
                }
                t : _ => {
                    if (isField) {
                        throw copy ErrorMsg::fatal (value.getLoc (), format (ValidateErrorMessage::CLASS_ALIAS_FIELD_NO_CLASS, t));
                    } else {
                        throw copy ErrorMsg::fatal (value.getLoc (), format (ValidateErrorMessage::CLASS_ALIAS_INDEX_NO_CLASS, t));
                    }
                }
            };
        } else {
            if (value of ExpandValue) {
                throw copy ErrorMsg::fatal (loc, end-> value.getLoc (), format (ValidateErrorMessage::MISMATCH_ALIAS_EXPAND, value.getType ()));
            } else if (value of LazyValue) {
                throw copy ErrorMsg::fatal (loc, end-> value.getLoc (), format (ValidateErrorMessage::MISMATCH_ALIAS_LAZY, value.getType ()));
            }

            let resValue = context:.getCompileTimeInterpreter ():.reduce (value);
            if (!resValue.getType ().isMutable ()) {
                throw copy ErrorMsg::fatal (loc, end-> resValue.getLoc (), format (ValidateErrorMessage::NOT_A_LVALUE_TYPE, resValue.getType ()));
            } else if (!resValue.getType ().needExplicitAlias ()) {
                throw copy ErrorMsg::fatal (loc, end-> resValue.getLoc (), format (ValidateErrorMessage::UNECESSARY_ALIAS, resValue.getType ()));
            }

            return copy AliaserValue (loc, resValue.getType (), resValue);
        }
    }

    /**
     * Validate a named expression
     * @params: 
     *   - context: the context of the validation
     *   - n: the named expression to validate
     * @returns: the validated value
     */
    fn validateNamedExpr (self, dmut context : &Validator, n : &NamedExpr, canBeRef : bool = false, canBeLazy : bool = false)-> &Value
        throws ErrorMsg
    {
        let content = self.validate (alias context, n.getContent (), canBeRef-> canBeRef, canBeLazy-> canBeLazy);
        let rContent = if (!canBeLazy && !canBeRef) {
            context:.getCompileTimeInterpreter ():.reduce (content)
        } else {
            content
        };

        copy NamedValue (n.getLoc (), n.getLoc ().str, rContent)
    }

    /**
     * Validate a reference expression
     * @params:
     *    - context: the context of the validation
     *    - i: the intrinsic expression containing the ref
     *    - expr: the content of the ref
     *    - canValidateRef: true iif a ref can be constructed here
     * @returns: the ref value
     * @throws:
     *   - &ErrorMsg: if the validation fails
     * */
    fn validateRefExpr (self, dmut context : &Validator, i : &IntrinsicExpr, expr : &Expression, canValidateRef : bool)-> &Value
        throws ErrorMsg
    {
        let ret = context:.validateValue (expr);
        context.verifyLeftOperandMove (i.getLoc (), ret, allowSelf-> true);

        if (!canValidateRef) {
            throw copy ErrorMsg::fatal (i.getLoc (), end-> ret.getLoc (), ValidateErrorMessage::UNECESSARY_REFERENCE);
        }

        return copy ReferencerValue (i.getLoc (), ret.getType (), ret, isMutable-> true);
    }


    /**
     * Validate a lazy intrinsic expression
     * @params:
     *    - context: the context of the validation
     *    - i: the intrinsic expression containing the lazy
     *    - expr: the content of the lazy
     *    - canBeLazy: true iif a lazy can be constructed here
     * @returns: the lazy value
     * @throws:
     *   - &ErrorMsg: if the validation fails
     * */
    pub fn validateLazy (self, dmut context : &Validator, i : &IntrinsicExpr, expr : &Expression, canBeLazy : bool)-> &Value
        throws ErrorMsg
    {
        if (!canBeLazy) throw copy ErrorMsg::fatal (i.getLoc (), format (ValidateErrorMessage::UNECESSARY_LAZY));

        let retValue = context:.validateValue (expr);
        context.verifyNonVoidType (i.getLoc (), retValue.getType (), false);

        let (byAlias, retType) = if (context.needExplicitAlias (retValue)) {
            (false, retValue.getType ().clone (0u32))
        } else {
            (retValue.getType ().needExplicitAlias (), retValue.getType ())
        };

        let name = copy Word ("#_REF", i.getLoc ());
        let retVdecl = copy VarDeclExpr (name, name,
                                         type-> copy TypeWrapperExpr (i.getLoc (), retType, asIs-> true),
                                         value-> EMPTY_EXPR,
                                         isMutOrDmut-> copy Word (Keys::MUTABLE, i.getLoc ()),
                                         isLazyOrRef -> copy Word (Keys::REF, i.getLoc ()));

        let vexpr = copy VarExpr (name);
        let proto = copy FunctionProtoDecl (i.getLoc (), copy [retVdecl], EMPTY_EXPR, forLambda-> true);
        let blk = copy BinaryExpr (copy Word (Tokens::EQUAL, i.getLoc ()), vexpr, expr);
        let lmbd = copy LambdaValueExpr (i.getLoc (), proto, blk);

        let retFunc = context:.getLambdaValidator ():.validate (alias context, lmbd, isClosure-> true, forLazy-> true, copyLoc-> i.getLoc ());
        copy LazyValue (i.getLoc (), retType, retValue,
                        lmbd-> retFunc,
                        byAlias-> byAlias)
    }

    /**
     * Validate the creation of a future value
     * @params:
     *    - context: the context of the validation
     *    - i: the intrinsic expression containing the future
     *    - expr: the content of the future
     * @returns: the future value
     * @throws:
     *    - &ErrorMsg: if the validation fails
     * */
    pub fn validateFuture (self, dmut context : &Validator, i : &IntrinsicExpr, expr : &Expression)-> &Value
        throws ErrorMsg
    {
        let retValue = context:.validateValue (expr);
        let (byAlias, innerType) = if (context.needExplicitAlias (retValue)) {
            (false, retValue.getType ().cloneMutableTilBorrow ())
        } else {
            (retValue.getType ().needExplicitAlias (), retValue.getType ())
        };

        let lmbd = if (innerType of VoidType) {
            let proto = copy FunctionProtoDecl (i.getLoc (), [], EMPTY_EXPR, forLambda-> true);
            copy LambdaValueExpr (i.getLoc (), proto, expr)
        } else {
            let name = copy Word ("#_REF", i.getLoc ());
            let retVdecl = copy VarDeclExpr (name, name,
                                             type-> copy TypeWrapperExpr (i.getLoc (), innerType, asIs-> true),
                                             value-> EMPTY_EXPR,
                                             isMutOrDmut-> copy Word (Keys::MUTABLE, i.getLoc ()),
                                             isLazyOrRef -> copy Word (Keys::REF, i.getLoc ()));

            let vexpr = copy VarExpr (name);

            let proto = copy FunctionProtoDecl (i.getLoc (), copy [retVdecl], EMPTY_EXPR, forLambda-> true);
            let blk = copy BinaryExpr (copy Word (Tokens::EQUAL, i.getLoc ()), vexpr, expr);
            copy LambdaValueExpr (i.getLoc (), proto, blk)
        };

        let retFunc = context:.getLambdaValidator ():.validate (alias context, lmbd, isClosure-> true, forLazy-> true, copyLoc-> i.getLoc ());
        let type = copy FutureType (i.getLoc (), innerType, isMutable-> true);
        copy FutureValue (i.getLoc (), type, retValue,
                          lmbd-> retFunc,
                          byAlias-> byAlias)
    }

    /**
     * Validate an expression that has been marked as "cte"
     * @params:
     *   - context: the context of the validation
     *   - expr: the expression to validate
     * @returns: the validated expression
     * @throws:
     *   - &ErrorMsg: if the validation fails
     */
    pub fn validateCteExpr (self, dmut context : &Validator, expr : &Expression)-> &Value
        throws ErrorMsg
    {
        match expr {
            c : &ConditionalExpr => { // Conditionals have a different treatment for ctes
                return self.validateCteConditionalExpr (alias context, c);
            }
            f : &ForLoopExpr => { // Same for "for" loops
                return self.validateCteForLoopExpr (alias context, f);
            }
            a : &AssertExpr => {
                return self.validateCteAssertExpr (alias context, a);
            }
            _ => { // Otherwise we just try to get the value at compilation time
                let resExpr = context:.validateValue (expr);
                if (!context:.getCompileTimeInterpreter ().isCte (resExpr)) {
                    throw copy ErrorMsg::fatal (resExpr.getLoc (), format (ValidateErrorMessage::UNKNOWN_AT_COMPILE_TIME, resExpr.getType ()));
                }

                return resExpr;
            }
        }
    }

    /**
     * Validate a conditional expression whose test must be evaluated at compilation time
     * @params:
     *    - context: the context of the validation
     *    - expr: the expression to validate
     * @returns: the result content of the if expression (or its else value if the test did not pass)
     * @throws:
     *     - &ErrorMsg: if the validation fails or the test value cannot be known at compile time
     */
    fn validateCteConditionalExpr (self, dmut context : &Validator, expr : &ConditionalExpr)-> &Value
        throws ErrorMsg
    {
        let test = context:.validateValue (expr.getTest ()); // First we need to validate the expression of the test of the conditional
        let value = context:.getCompileTimeInterpreter ():.computeBool (test); // And try to retreive its real value at compilation time
        if (value) {
            context:.validateValue (expr.getContent ())
        } else { // otherwise only the else part is validated
            context:.validateValue (expr.getElse ())
        }
    }

    /**
     * Validate a for loop that is marked cte
     * @params:
     *    - context: the context of the validation
     *    - expr: the for loop to validate
     * @returns: the content of the for loop, unrolled at compile time
     * @throws:
     *    - &ErrorMsg: if the for loop cannot be executed at compile time, or there is an error in the validation (iterator, or for loop content)
     */
    fn validateCteForLoopExpr (self, dmut context : &Validator, expr : &ForLoopExpr)-> &Value
        throws ErrorMsg
    {
        context:.getForLoopValidator ().validateCteForLoop (alias context, expr)
    }

    /**
     * Validate an assert expression whose test is made at compilation time
     * @params:
     *     - context: the context of the validation
     *     - a: the expression to validate
     * @returns: a unit expr
     * @throws:
     *   - &ErrorMsg: if the assert expression failed to be validated, or is test is false
     * */
    fn validateCteAssertExpr (self, dmut context : &Validator, a : &AssertExpr)-> &Value
        throws ErrorMsg
    {
        let test = context:.validateValue (a.getTest ());
        let value = context:.getCompileTimeInterpreter ():.computeBool (test);
        if (!value) {
            match a.getMessage () {
                EmptyExpression () => {
                    throw copy ErrorMsg::fatal (a.getLoc (), ValidateErrorMessage::CTE_ASSERT_NO_MSG);
                }
                msg : _ => {
                    let m = context:.validateValue (msg);
                    throw copy ErrorMsg::fatal (a.getLoc (), format (ValidateErrorMessage::CTE_ASSERT_WITH_MSG, m));
                }
            }
        }

        UNIT_VALUE
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================     CONDITION AND LOOPS      =========================
     * ================================================================================
     * ================================================================================
     */
    
    /**
     * Validate a conditional expression
     * @params: 
     *   - context: the context of the validation
     *   - c: the conditional expression to validate
     * @returns: the validated value
     */
    fn validateConditional (self, dmut context : &Validator, c : &ConditionalExpr)-> &Value
        throws ErrorMsg
    {
        if (c.isLet ()) {
            return self.validateConditionalPattern (alias context, c);
        }

        let test = match c.getTest () {
            EmptyExpression () => { UNIT_VALUE }
            t : _ => {
                let r = context:.validateValue (t);
                if (r.getType () !of BoolType) {
                    throw copy ErrorMsg::fatal (r.getLoc (), format (ValidateErrorMessage::INCOMPATIBLE_TYPE, r.getType (), copy BoolType (r.getLoc ())));
                }
                r
            }
        };

        match test {
            b : &BoolValue => {
                if (b.isTrue ()) throw copy ErrorMsg::fatal (b.getLoc (), format (ValidateErrorMessage::USELESS_COND_TRUE));
                else throw copy ErrorMsg::fatal (b.getLoc (), format (ValidateErrorMessage::USELESS_COND_FALSE));
            }
        }

        let content = context:.validateValue (c.getContent ());
        let mut type = content.getType ();
        {
            context.verifyMemoryOwner (content.getLoc (), type, content, byReference-> false);
        } catch {
            _ : &ErrorMsg => {
                type = type.clone (0u32);
                context.verifyMemoryOwner (content.getLoc (), type, content, byReference-> false);
            }
        }

        self.validateConditionalElse (alias context, c, type, test, content)
    }

    /**
     * Validate a conditional where the test is a pattern matching variable declaration
     * @params:
     *    - context: the context of the validation
     *    - c: the conditional to validate
     * */
    fn validateConditionalPattern (self, dmut context : &Validator, c : &ConditionalExpr)-> &Value
        throws ErrorMsg
    {
        let mut error : (&ErrorMsg)? = none, mut hasErrors = false;
        let (pattern, value) = match c.getTest () {
            v : &VarDeclExpr => {
                let rewrite = copy VarDeclExpr (v.getLoc (), v.getName (), value-> EMPTY_EXPR, type-> v.getType (),
                                                isLazyOrRef-> v.getLazyOrRefLocation (),
                                                isMutOrDmut-> v.getMutOrDmutLocation ());
                (rewrite, v.getValue ())
            }
            p : &PatternVarDeclExpr => (p.getPattern (), p.getValue ())
            _ => panic;
        };

        let (_, test_, vars, error_) = context:.getMatcherValidator ().validateMatcher (alias context, value, pattern);
        if let Ok (err) = error_ { throw err; }

        context:.enterBlock ();
        let (content, test, type) = {
            let (test, taut, _) = context:.getMatcherValidator ().validateConditionGuard (alias context, vars, c.getGuard (), test_);
            match context:.getCompileTimeInterpreter ():.reduce (taut) {
                b : &BoolValue => {
                    if (b.isTrue ()) throw copy ErrorMsg::fatal (b.getLoc (), format (ValidateErrorMessage::USELESS_COND_TRUE));
                    else throw copy ErrorMsg::fatal (b.getLoc (), format (ValidateErrorMessage::USELESS_COND_FALSE));
                }
            }

            let content = context:.validateValue (c.getContent ());
            let mut type = content.getType ();
            {
                context.verifyMemoryOwner (content.getLoc (), type, content, byReference-> false);
            } catch {
                _ : &ErrorMsg => {
                    type = type.clone (0u32);
                    context.verifyMemoryOwner (content.getLoc (), type, content, byReference-> false);
                }
            }

            (content, test, type)
        } catch {
            err : &ErrorMsg => {
                error = (err)?;
                hasErrors = true;
                (UNIT_VALUE, UNIT_VALUE, NONE_TYPE)
            }
        };

        {
            // No need to warn unused if there were errors in the validation of the block (it will complicate the error handling)
            context:.quitBlock (warnUnused-> !hasErrors);
        } catch {
            err : &ErrorMsg => {
                if (!hasErrors) {
                    error = (err)?;
                }
            }
        }

        if let Ok (err) = error { throw err; }

        self.validateConditionalElse (alias context, c, type, test, content)
    }

    /**
     * Validate the else part of a conditional
     * @params:
     *    - context: the context of the validation
     *    - c: the conditional to validate
     *    - content: the content of the if
     * */
    fn validateConditionalElse (self, dmut context : &Validator, c : &ConditionalExpr, type : &Type, test : &Value, content : &Value)-> &Value
        throws ErrorMsg
    {
        match c.getElse () {
            EmptyExpression () => {
                if (type !of VoidType) {
                    throw copy ErrorMsg::fatal (c.getLoc (), end-> content.getLoc (), format (ValidateErrorMessage::IF_COND_NOT_COMPLETE, type));
                }

                copy ConditionalValue (c.getLoc (), type, test, content, elsev-> UNIT_VALUE)
            }
            e : _ => {
                let else_ = context:.validateValue (e);
                let (inferedType, valueElse) = if (!else_.isBreaker () && !else_.isReturner ()) {
                    {
                        if (content.isBreaker () || content.isReturner ()) {
                            (else_.getType (), else_)
                        } else { // neither are breakers/returners
                            context:.inferTypeBranchingWithValue (content.getLoc (), type, else_)
                        }
                    } catch {
                        err : &ErrorMsg => throw copy ErrorMsg::fatal (c.getLoc (), notes-> copy [err], ValidateErrorMessage::BRANCHING_VALUE);
                    }
                } else {
                    if (!content.isBreaker () && !content.isReturner ()) {
                        (content.getType (), else_)
                    } else { // both are breakers/returner
                        (copy VoidType (c.getLoc ()), else_)
                    }
                }

                copy ConditionalValue (c.getLoc (), inferedType, test, content, elsev-> valueElse)
            }
        }
    }
        
    /**
     * Validate a for loop
     * @params: 
     *   - context: the context of the validation
     *   - f: the for loop to validate
     * @returns: the validated value
     */
    fn validateForLoop (self, dmut context : &Validator, f : &ForLoopExpr)-> &Value
        throws ErrorMsg
    {
        return context:.getForLoopValidator ().validate (alias context, f);
    }

    /**
     * Validate a while loop
     * @params: 
     *   - context: the context of the validation
     *   - w: the while loop to validate
     * @returns: the validated value
     */
    fn validateWhileLoop (self, dmut context : &Validator, w : &WhileLoopExpr)-> &Value
        throws ErrorMsg
    {
        let test = match w.getTest () {
            EmptyExpression () => { UNIT_VALUE }
            t : _ => {
                let r = context:.validateValue (t);
                if (r.getType () !of BoolType) {
                    throw copy ErrorMsg::fatal (r.getLoc (), format (ValidateErrorMessage::INCOMPATIBLE_TYPE, r.getType (), copy BoolType (r.getLoc ())));
                }

                match r {
                    b : &BoolValue => {
                        if b.isTrue () throw copy ErrorMsg::fatal (b.getLoc (), format (ValidateErrorMessage::INFINITE_LOOP));
                        else {
                            if (!w.isDo ()) throw copy ErrorMsg::fatal (b.getLoc (), format (ValidateErrorMessage::NEVER_ENTERED_LOOP));
                            else throw copy ErrorMsg::fatal (b.getLoc (), format (ValidateErrorMessage::ONE_ITER_LOOP));
                        }
                    }
                }

                r
            }
        };

        let voidType = copy VoidType (w.getLoc ());
        let content = {
            context:.enterLoop ();
            if (w.getTest () !of EmptyExpression)
                context:.setCurrentLoopType (voidType);
            
            context:.validateValue (w.getContent ())
        } catch {
            err : &ErrorMsg => { 
                context:.quitLoop ();
                throw err;
            }
        }

        let mut loopType = context.getCurrentLoopType ();
        if (loopType of NoneType) loopType = voidType;

        context:.quitLoop ();        
        context.verifyCompatibleType (content.getLoc (), w.getLoc (), content.getType (), voidType);

        copy LoopValue (w.getLoc (), loopType, test, content, w.isDo ())
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================    BREAK/RETURN/ and MISC    =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a break expression
     * @params: 
     *   - context: the context of the validation
     *   - b: the break to validate
     * @returns: the validated value
     */
    fn validateBreak (self, dmut context : &Validator, b : &BreakExpr)-> &Value
        throws ErrorMsg
    {        
        if (!context.isInLoop ()) throw copy ErrorMsg::fatal (b.getLoc (), ValidateErrorMessage::BREAK_NO_LOOP);
        let inScope = context.getInScopeGuard ();
        if (!inScope.isEof ()) throw copy ErrorMsg::fatal (b.getLoc (), end-> inScope, format (ValidateErrorMessage::BREAK_SCOPE_GUARD));

        // Break can have a value in 'loop' loops
        let val = match b.getValue () {
            EmptyExpression () => { copy UnitValue (loc-> b.getLoc ()) }
            v : &Expression => {
                context:.validateValue (v)
            }
        };
        
        let loopType = context.getCurrentLoopType ();

        // There may be multiple break in the loop, we need to verify that the type is compatible
        // It is a branching type (multiple branch with slightly different types)
        let (finLoopType, finLoopValue) = context:.inferTypeBranchingWithValue (b.getLoc (), loopType, val);

        // We need to ensure that there is no mutability issue 
        context.verifyMemoryOwner (b.getLoc (), finLoopType, finLoopValue, byReference-> false);

        // Change the loop type for future break branches (and loop type)
        context:.setCurrentLoopType (finLoopType);

        // Breaks are not really values (you cannot write 'a = break 12;'), they are always typed 'void'
        copy BreakValue (b.getLoc (), finLoopValue)
    }

    /**
     * Validate a return expression
     * @params: 
     *   - context: the context of the validation
     *   - r: the return to validate
     * @returns: the validated value
     */
    fn validateReturn (self, dmut context : &Validator, r : &ReturnExpr)-> &Value
        throws ErrorMsg
    {
        if (!context.isInFunctionBody ()) throw copy ErrorMsg::fatal (r.getLoc (), ValidateErrorMessage::RETURN_NO_FUNCTION);
        let inScope = context.getInScopeGuard ();
        if (!inScope.isEof ()) throw copy ErrorMsg::fatal (r.getLoc (), end-> inScope, format (ValidateErrorMessage::RETURN_SCOPE_GUARD));

        // The function type is set once at the beginning of a function validation, or by return statement in case of lambda validation
        let fnType = context.getFunctionReturn ();
        
        // Return can be used in void function to quit the function immediately, so without a value
        let val = match r.getValue () {
            EmptyExpression () => { copy UnitValue (loc-> r.getLoc ()) }
            v : &Expression => {
                let res = context:.validateValue (v);
                
                match res.getType () {
                    LambdaType () => {
                        // We have the possibility here - thanks to the return type of the function - to know the types of the prototype of a lambda function
                        if (fnType of FuncPtrType || fnType of DelegateType) { // inferLambdaValue manage that test, but we don't want error throwing for anything else than lambda validation error
                            context:.inferLambdaValue (fnType, res)
                        } else { res }
                    }
                    _ => { res }
                }
            }
        };

        
        let resVal = if (context.isInLambdaBody ()) { // The type can be changed by the return statement
            let (finFnType, f) = context:.inferTypeBranchingWithValue (val.getLoc (), fnType, val);
            context:.setFunctionReturn (finFnType);
            f
        } else {
            // Verify that the mutability of the returned values is respected
            let f = context:.verifyCompatibleTypeWithValue (fnType.getLoc (), fnType, val, byReference-> false);
            context.verifyMemoryOwner (fnType.getLoc (), fnType, f, construct-> true, byReference-> false);
            f
        }
        

        // Returns are not really values (you cannot write 'a = return 12;'), they are always typed 'void'
        copy ReturnValue (r.getLoc (), resVal)
    }

    /**
     * Validate a throw expression
     * @params: 
     *   - context: the context of the validation
     *   - t: the throw to validate
     * @returns: the validated value
     */
    fn validateThrow (self, dmut context : &Validator, t : &ThrowExpr)-> &Value
        throws ErrorMsg
    {
        if (!context.isInFunctionBody ()) throw copy ErrorMsg::fatal (t.getLoc (), ValidateErrorMessage::THROW_NO_FUNCTION);
        // let inScope = context.getInScopeGuard ();
        // if (!inScope.isEof ()) throw copy ErrorMsg::fatal (t.getLoc (), end-> inScope, format (ValidateErrorMessage::THROW_SCOPE_GUARD));

        let inner = context:.validateValue (t.getValue ());
        let type = inner.getType ();

        let exceptionType = context:.getExceptionType (loc-> t.getLoc ());
        context.verifyAncestor (t.getLoc (), exceptionType, type);
        
        copy ThrowValue (t.getLoc (), inner)
    }

    /**
     * Validate a panic expression
     * @params:
     *    - context: the context of the validation
     *    - p: the panic to validate
     * @returns: the panic value
     * */
    fn validatePanic (self, dmut _ : &Validator, p : &PanicExpr)-> &Value {
        copy PanicValue (p.getLoc ())
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================        PATTERN MATCH         =========================
     * ================================================================================
     * ================================================================================
     */
    
    /**
     * Validate a pattern matcher
     * @params: 
     *   - context: the context of the validation
     *   - m: the pattern matcher to validate
     * @returns: the validated value
     */
    fn validateMatcher (self, dmut context : &Validator, m : &MatcherExpr)-> &Value
        throws ErrorMsg
    {
        return context:.getMatcherValidator ().validate (alias context, m);
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================            MACRO             =========================
     * ================================================================================
     * ================================================================================
     */


    /**
     * Validate a macro call expression
     * @params: 
     *   - context: the context of the validation
     *   - m: the macro call expression to validate
     * @returns: the validated value
     */
    fn validateMacroCall (self, dmut context : &Validator, m : &MacroCallExpr)-> &Value
        throws ErrorMsg
    {
        return context:.getMacroSolver ().validate (alias context, m);
    }


    /*!
     * ================================================================================
     * ================================================================================
     * =========================            PRAGMA            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a pragma expression
     * @params: 
     *   - context: the context of the validation
     *   - p: the pragma expression to validate
     * @returns: the validated value
     */
    fn validatePragma (self, dmut context : &Validator, p : &PragmaExpr)-> &Value
        throws ErrorMsg
    {
        context:.getPragmaValidator ().validateValue (alias context, p)
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================            ASSERT            =========================
     * ================================================================================
     * ================================================================================
     */


    /**
     * Validate an assert expression
     * @params: 
     *   - context: the context of the validation
     *   - p: the assert expression to validate
     *   - isCte: true iif the assertion has to be done CTE
     * @returns: the validated value
     */
    fn validateAssert (self, dmut context : &Validator, a : &AssertExpr, isCte : bool = false)-> &Value
        throws ErrorMsg
    {
        let test = context:.validateValue (a.getTest ());
        let (isFalse, canCte) = { // if the test is false at compile time, we can assume its a return loc
            (!context:.getCompileTimeInterpreter ():.computeBool (test), true)
        } catch {
            err : _ => {
                if (isCte) throw err;
                (false, false) // not cte
            }
        };

        if (!isCte) {
            // if the expression has a message, it is passed to the abort function
            let message = match a.getMessage () {
                EmptyExpression () => { makeStringSliceValue (a.getLoc (), "") }
                expr : _ => {
                    context:.validateValue (expr)
                }
            };

            let assertType = context:.getExceptionFromName (ExceptionUtils::ASSERT_ERR);
            let assertInstanceCtor = context:.constructObjectInstance (a.getLoc (), assertType, copy [message]);
            let throwVal = copy ThrowValue (a.getLoc (), assertInstanceCtor);

            return if (isFalse) { // the test is always false, then it is a returner
                copy BlockValue (a.getLoc (), VOID_TYPE, copy [throwVal], returnLoc-> a.getLoc (), breakLoc-> EOF_WORD, isSet-> true)
            } else { // otherwise (always true, or not cte)
                if (canCte) throw copy ErrorMsg::fatal (a.getLoc (), end-> test.getLoc (), format (ValidateErrorMessage::USELESS_RUNTIME_ASSERT));
                copy ConditionalValue (a.getLoc (), VOID_TYPE, copy UnaryBoolOperatorValue (a.getLoc (), UnaryOperators::NOT, test), throwVal, elsev-> UNIT_VALUE, isComplete-> false, isReduced-> true)
            };
        } else {
            if (isFalse) {
                match a.getMessage () {
                    EmptyExpression () => throw copy ErrorMsg::fatal (a.getLoc (), ValidateErrorMessage::CTE_ASSERT_NO_MSG);
                    expr => {
                        let msg = context:.validateValue (expr);
                        throw copy ErrorMsg::fatal (a.getLoc (), format (ValidateErrorMessage::CTE_ASSERT_WITH_MSG, msg));
                    }
                };
            }

            return UNIT_VALUE;
        }
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================             TRY              =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a try expression
     * @params: 
     *   - context: the context of the validation
     *   - t: the try expression to validate
     * @returns: the validated value
     */
    fn validateTry (self, dmut context : &Validator, t : &TryExpr)-> &Value
        throws ErrorMsg
    {
        let content = context:.validateValue (t.getValue ());
        if (content.getThrowers ().len == 0us) {
            context.verifyNoBreaking (t.getLoc (), content);

            let innerType = context:.inferTypeImplicitMutability (content);
            copy OptionValue (t.getLoc (), copy OptionType (t.getLoc (), innerType, isMutable-> true), content)
        } else {
            let innerType = context:.inferTypeImplicitMutability (content);
            self.validateOptionCatcher (alias context, t.getLoc (), innerType, content)
        }
    }

    /**
     * Validate an try expression where inner value can throw exceptions
     * @params:
     *    - context: the context of the validation
     *    - loc: the location of the option value
     *    - t: the type of the inner type
     *    - v: the value being created
     * @returns: an option value catching everything
     * @throws:
     *    - &ErrorMsg: if the validation fails
     * */
    fn validateOptionCatcher (self, dmut context : &Validator, loc : &Word, t : &Type, v : &Value)-> &Value
        throws ErrorMsg
    {
        let optType = copy OptionType (loc, t, isMutable-> true);
        let tryValue = copy OptionValue (loc, optType, v);

        let exceptType = context:.getExceptionType (loc-> loc);
        let catchVar = copy VarDeclValue (copy Word ("#_catch", loc), exceptType, UNIT_VALUE, isMutable-> false);
        let catchVarRef = copy VarRefValue (catchVar.getLoc (), catchVar.getLoc (), exceptType, catchVar.getUniqId (), isSelf-> false, canCte-> false);

        let elsValue = copy ErrOptionValue (loc, type-> optType, errValue-> catchVarRef);

        let tryBlock = copy BlockValue (loc, optType, copy [tryValue]);
        let elsBlock = copy BlockValue (loc, optType, copy [elsValue]);

        copy TryCatchValue (loc, optType, tryBlock, elsBlock, catchVar-> catchVar)
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================            ATOMIC            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate an atomic expression
     * @params: 
     *   - context: the context of the validation
     *   - a: the atomic expression to validate
     * @returns: the validated value
     */
    fn validateAtomic (self, dmut context : &Validator, a : &AtomicExpr)-> &Value
        throws ErrorMsg
    {
        match a.getMonitor () {
            EmptyExpression () => {
                return self.validateAtomicNoMonitor (alias context, a);
            }
            _ => {
                return self.validateAtomicWithMonitor (alias context, a);
            }
        }
    }

    /**
     * Validate an atomic value that does not use a monitor
     * @params:
     *     - context: the context of the validation
     *     - a: the atomic expr to validate
     * @returns: the try finally value
     * */
    fn validateAtomicWithMonitor (self, dmut context : &Validator, a : &AtomicExpr)-> &Value
        throws ErrorMsg
    {
        let monitor = context:.validateValue (a.getMonitor ());
        let isClass = match monitor.getType () {
            c : &ClassPtrType => { !c.isStruct () }
            _ => { false }
        };

        if (!isClass) {
            throw copy ErrorMsg::fatal (a.getMonitor ().getLoc (), format (ValidateErrorMessage::NOT_A_CLASS, monitor.getType ()),
                                   notes-> copy [copy ErrorMsg::note (a.getLoc (), format (ValidateErrorMessage::ATOMIC_NEEDS_MONITOR))]);
        }

        let (lock, unlock) = context:.getAtomicLockerWithMonitorFuncs (loc-> a.getLoc ());
        let inner = context:.validateValue (a.getValue ());

        let before = context:.getCallOpValidator ().validate (alias context, a.getLoc (), lock, copy [monitor]);
        let post = context:.getCallOpValidator ().validate (alias context, a.getLoc (), unlock, copy [monitor]);

        let innerType = context:.inferTypeImplicitMutability (inner);
        let blk = copy BlockValue (a.getLoc (), innerType, copy [before, inner], breakLoc-> inner.getBreakerLoc (), returnLoc-> inner.getReturnerLoc ());
        let postBlock = copy BlockValue (a.getLoc (), VOID_TYPE, copy [post]);

        copy TryFinallyValue (a.getLoc (), innerType, blk, postBlock, failVar-> UNIT_VALUE)
    }

    /**
     * Validate an atomic value that does not use a monitor
     * @params:
     *     - context: the context of the validation
     *     - a: the atomic expr to validate
     * @returns: the try finally value
     * */
    fn validateAtomicNoMonitor (self, dmut context : &Validator, a : &AtomicExpr)-> &Value
        throws ErrorMsg
    {
        let (lock, unlock) = context:.getAtomicLockerNoMonitorFuncs (loc-> a.getLoc ());
        let inner = context:.validateValue (a.getValue ());

        let before = context:.getCallOpValidator ().validate (alias context, a.getLoc (), lock, []);
        let post = context:.getCallOpValidator ().validate (alias context, a.getLoc (), unlock, []);

        let innerType = context:.inferTypeImplicitMutability (inner);
        let blk = copy BlockValue (a.getLoc (), innerType, copy [before, inner], breakLoc-> inner.getBreakerLoc (), returnLoc-> inner.getReturnerLoc ());
        let postBlock = copy BlockValue (a.getLoc (), VOID_TYPE, copy [post]);

        copy TryFinallyValue (a.getLoc (), innerType, blk, postBlock, failVar-> UNIT_VALUE)
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================             CAST             =========================
     * ================================================================================
     * ================================================================================
     */


    /**
     * Validate a cast expression
     * @params: 
     *   - context: the context of the validation
     *   - c: the cast expression to validate
     * @returns: the validated value
     */
    fn validateCast (self, dmut context : &Validator, c : &CastExpr)-> &Value
        throws ErrorMsg
    {
        context:.getCastValidator ().validateValue (alias context, c)
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================          TEMPLATES           =========================
     * ================================================================================
     * ================================================================================
     */
    
    /**
     * Validate a template call expression
     * @params: 
     *   - context: the context of the validation
     *   - t: the template call to validate
     * @returns: the validated value
     */
    fn validateTemplateCall (self, dmut context : &Validator, t : &TemplateCallExpr)-> &Value
        throws ErrorMsg
    {
        let left = context:.validateValue (t.getLeft ());
         // validate the list of argument of the template call
        let list = context:.validateTemplateArgumentList (t.getRights ());

        self.validateTemplateCall (alias context, t.getLoc (), left, list)
    }

    /**
     * Validate a template call
     * @params:
     *    - context: the context of the validation
     *    - t: the template call to validate
     * @returns: the validated value
     * */
    pub fn validateTemplateCall (self, dmut context : &Validator, loc : &Word, left : &Value, rights : [&Generator])-> &Value
        throws ErrorMsg
    {
        let value : &MultSymValue = match left {
            m : &MultSymValue => { m }
            tmp : _ => { copy MultSymValue (left.getLoc (), copy [tmp], prettyStr-> format ("%", tmp, tags-> FormatTags (withParams-> true))) }
        };

        self.validateTemplateCallMultSym (alias context, loc, value, rights)
    }

    /**
     * Validate a template call where left and right operands are valdiated
     * @params: 
     *    - context: the context of the valdiation
     *    - left: the left operand
     *    - rights: the list of arguments
     * @returns: the result value
     * @throws:
     *    - &ErrorMsg: if the call is impossible
     */
    pub fn validateTemplateCallMultSym (self, dmut context : &Validator, loc : &Word, left : &MultSymValue, rights : [&Generator])-> &Value
        throws ErrorMsg
    {
        // We store the results inside a vector, where to each valid values is associated the correct rewriter
        let mut results : [u32 => mut [(TemplateRewriter, &Value)]] = copy [];
        let mut notFinalized : [(TemplateRewriter, &Value)] = [];
        let mut maxScore = 0u32;
        let mut errors : [&ErrorMsg] = [];
        for it in left.getValues () {
            {
                let rewriter = context:.getTemplateSolver ().validateCallValue (alias context, left.getLoc (), it, rights);
                let (isFinalized, score) = match it {
                    t : &TemplateRefValue => {
                        let oldScore = match t.getSymbol ().getTemplateMapper () {
                            Ok (map) => { map.getScore () }
                            _ => { 0u32 }
                        };

                        (context:.getTemplateDeclarator ().isFinalized (rewriter, t), rewriter.getScore () + oldScore)
                    }
                    _ => { (true, rewriter.getScore ()) }
                };

                if isFinalized {
                    if score > maxScore { maxScore = score; }
                    if let Ok (lst) = results [score] {
                        let r = lst ~ [(rewriter, it)];
                        results [score] = r;
                    } else {
                        results [score] = copy [(rewriter, it)];
                    }
                } else {
                    notFinalized ~= [(rewriter, it)];
                }
            } catch {
                err : &ErrorMsg => { // does not work
                    errors ~= [err];
                }
            }
        }

        if (results.len == 0us && notFinalized.len == 0 && errors.len != 0us) { // No value succeded, and there was some errors
            throw copy ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_TEMPLATE_CALL, left, rights, tags-> FormatTags (withParams-> true)), notes-> errors);
        }

        {
            let final = if results.len == 0 {
                notFinalized
            } else if let Ok (z) = results [maxScore] {
                z ~ notFinalized
            } else panic;

            self.finalizeTemplateCallMultSym (alias context, left.getLoc (), final)
        } catch {
            err : &ErrorMsg => {
                throw copy ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_TEMPLATE_CALL, left, rights, tags-> FormatTags (withParams-> true)), notes-> copy [err]);
            }
        }
    }
      
    /**
     * Finalize the validation of rewrittable template specialization
     * @params: 
     *     - context: the context of the validation
     *     - loc: the location of the specialization
     *     - list: the list of rewrittable specialization (@warning: assumed to contain at least one value)
     * @returns: the value containing the declared sybmols
     * @throws:
     *     - &ErrorMsg: if there was in error in the validation
     */
    fn finalizeTemplateCallMultSym (self, dmut context : &Validator, loc : &Word, list : [(TemplateRewriter, &Value)])-> &Value
        throws ErrorMsg
    {
        let mut finalResults : [dmut &Symbol] = [];
        let mut delegates : [&Value] = [];
        let mut errors : [&ErrorMsg] = [];

        for it in list { // for each value that can be rewritten
            {
                match it._1 {
                    m : &MethodDelegateTemplateValue => {
                        delegates ~= [self.finalizeTemplateMethodCall (alias context, loc, it._0, m)];
                    }
                    c : &CtorDelegateTemplateValue => {
                        delegates ~= [self.finalizeTemplateCtorCall (alias context, loc, it._0, c)];
                    }
                    x : &TemplateRefValue => {
                        let dmut val = alias context:.getTemplateDeclarator ():.declare (alias context, loc, it._0, x);
                        finalResults ~= [alias val];
                    }
                    z : _ => {
                        println ("TODO : ", z.__typeinfo__.name);
                        panic;
                    }
                }
            } catch {
                err : &ErrorMsg => { // symbol declaration failed (rewrite cannot fail)
                    errors ~= [err];
                }
            }            
        }

        if (finalResults.len == 0us && delegates.len == 0us) { // if there is not symbol with validation
            throw copy ErrorMsg::list (errors);
        }

        // transform the standard declared symbols into values
        context:.getLiteralValidator ().validateMultSymbols (loc, alias context, alias finalResults, base-> delegates)
    }

    /**
     * Finalize the declaration and validation of a constructor template that was called using template call syntax
     * @params:
     *   - context: the context of the validation
     *   - loc: the location of the template call
     *   - r: the template rewriter that was defined during template solving
     *   - c: the constructor template to finalize
     * @returns: The delegate value with some template left or fully validated (and thus validated by the function validator)
     * @info: uses the function validator to include the frame generator if the constructor templates are all rewritten
     * */
    fn finalizeTemplateCtorCall (self, dmut context : &Validator, loc : &Word, r : TemplateRewriter, c : &CtorDelegateTemplateValue)-> &Value
        throws ErrorMsg
    {
        let dmut val = alias context:.getTemplateDeclarator ():.declare (alias context, loc, r, c.getPrototype ());
        if let dmut func : &ConstructorSymbol = alias val {
            if let Ok (clRef : &ClassRefType) = c.getPrototype ().getClassSymbol ().getClassRef () {
                let proto : &CtorPrototypeValue = context:.getFunctionValidator ():.validateCtorPrototype (alias context, alias func, clRef);
                return copy CtorDelegateValue (loc, c.getInstanceType (), proto, instance-> c.getInstance ());
            }
        }

        else if let z : &TemplateSymbol = val {
            let meth = copy TemplateRefCtorValue (z.getLoc (), c.getPrototype ().getClassSymbol (), z);
            return copy CtorDelegateTemplateValue (loc, c.getInstanceType (), meth, instance-> c.getInstance ());
        }

        panic;
    }

    /**
     * Finalize the declaration and validation of a method template that was called using template call syntax
     * @params:
     *   - context: the context of the validation
     *   - loc: the location of the template call
     *   - r: the template rewriter that was defined during template solving
     *   - m: the method template to finalize
     * @returns: The delegate value with some template left or fully validated (and thus validated by the function validator)
     * @info: uses the function validator to include the frame generator if the method templates are all rewritten
     * */
    fn finalizeTemplateMethodCall (self, dmut context : &Validator, loc : &Word, r : TemplateRewriter, m : &MethodDelegateTemplateValue)-> &Value
        throws ErrorMsg
    {
        let dmut val = alias context:.getTemplateDeclarator ():.declare (alias context, loc, r, m.getPrototype ());
        if let dmut func : &FunctionSymbol = alias val {
            if let Ok (clRef : &ClassRefType) = m.getPrototype ().getClassSymbol ().getClassRef () {
                let proto : &MethodPrototypeValue = context:.getFunctionValidator ():.validateMethodPrototype (alias context, alias func, clRef);
                return copy MethodDelegateValue (loc, proto, closure-> m.getClosure (), direct-> true, vtableIndex-> 0us, isStruct-> m.isStruct ());
            }
        }

        else if let z : &TemplateSymbol = val {
            let meth = copy TemplateRefMethodValue (z.getLoc (), m.getPrototype ().getClassSymbol (), z);
            return copy MethodDelegateTemplateValue (loc, meth, m.getClosure (), isStruct-> m.isStruct ());
        }

        panic;
    }

    /**
     * Validate a template checker expression
     * @params: 
     *   - context: the context of the validation
     *   - t: the template checker to validate
     * @returns: the validated value
     */
    fn validateTemplateChecker (self, dmut context : &Validator, t : &TemplateCheckerExpr)-> &Value
        throws ErrorMsg
    {        
        let list = context:.validateTemplateArgumentList (t.getParameters ());// validate the arguments passed to the checker
        
        {
            let rewriter = context:.getTemplateSolver ().validateFromTemplateChecker (alias context, t.getLoc (), t.getRules (), list); // use the template solver to perform a specialization
            let syntTmp = rewriter.replaceSyntaxTempl (t.getRules ()); // use the rewriter to remove set template specialization, and keep only those without value/type association
            if (syntTmp.len == 0us) { // the template specialization passed, and there is no template left in the checker
                return copy BoolValue (t.getLoc (), isTrue-> true); // Then the expression is evaluated to "true"
            } 
        } catch { // every error of template specialization are caught, they just mean that the expression is evaluated to "false"
            _ => {}
        }

        copy BoolValue (t.getLoc (), isTrue-> false)
    }

}
