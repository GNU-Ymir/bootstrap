mod ymirc::semantic::validator::value;

import ymirc::semantic::validator::visitor;
import ymirc::semantic::validator::errors;
import ymirc::syntax::declaration::protection;
import ymirc::syntax::expression::_;
import ymirc::syntax::declaration::_;
import ymirc::syntax::keys;
import ymirc::semantic::symbol::_;
import ymirc::semantic::validator::template::_;
import ymirc::semantic::declarator::visitor;


import ymirc::semantic::generator::_;
import ymirc::global::core_;
import ymirc::errors::_;
import ymirc::utils::format;
import ymirc::lexing::word;
import ymirc::lexing::tokens;

import std::collection::vec;
import std::collection::map;
import std::collection::set;
import std::io;
import std::time::_;

/**
 * The value validator is the class responsible for value expression validation
 */
pub class ValueValidator {

    /**
     * Create a new empty validator
     */
    pub self () {}


    /**
     * Validate an expression assuming its a value
     * @params: 
     *    - context: the context of the validation
     *    - value: the expression to validate
     * @throws: &ErrorMsg, if the expression is not valid
     * @returns: a generator containing the validated value
     */
    pub fn validate (self, dmut context : &Validator, value : &Expression, canBeRef : bool = false, canBeLazy : bool = false)-> &Value
        throws &ErrorMsg
    {
        match value {
            b : &BlockExpr           => return self.validateBlock (alias context, b);
            l : &LiteralExpr         => return self.validateLiteral (alias context, l);
            o : &OperatorExpr        => return self.validateOperator (alias context, o);
            v : &VarDeclExpr         => return self.validateVarDecl (alias context, v);
            p : &PatternVarDeclExpr  => return self.validatePatternVarDecl (alias context, p);
            s : &SetExpr             => return self.validateSet (alias context, s);
            d : &DecoratedExpr       => return self.validateDecoExpr (alias context, d);
            c : &ConditionalExpr     => return self.validateConditional (alias context, c);
            f : &ForLoopExpr         => return self.validateForLoop (alias context, f);
            w : &WhileLoopExpr       => return self.validateWhileLoop (alias context, w);
            b : &BreakExpr           => return self.validateBreak (alias context, b);
            r : &ReturnExpr          => return self.validateReturn (alias context, r);
            t : &ThrowExpr           => return self.validateThrow (alias context, t);
            p : &PanicExpr           => return self.validatePanic (alias context, p);
            m : &MatcherExpr         => return self.validateMatcher (alias context, m);
            m : &MacroCallExpr       => return self.validateMacroCall (alias context, m);
            p : &PragmaExpr          => return self.validatePragma (alias context, p);
            a : &AssertExpr          => return self.validateAssert (alias context, a);
            t : &TryExpr             => return self.validateTry (alias context, t);
            a : &AtomicExpr          => return self.validateAtomic (alias context, a);
            c : &CastExpr            => return self.validateCast (alias context, c);
            l : &ListExpr            => return self.validateList (alias context, l);
            i : &IntrinsicExpr       => return self.validateIntrinsics (alias context, i, canValidateRef-> canBeRef, canBeLazy-> canBeLazy);
            n : &NamedExpr           => return self.validateNamedExpr (alias context, n, canBeRef-> canBeRef, canBeLazy-> canBeLazy);
            t : &TemplateCallExpr    => return self.validateTemplateCall (alias context, t);
            t : &TemplateCheckerExpr => return self.validateTemplateChecker (alias context, t);
            l : &LambdaValueExpr     => return self.validateLambda (alias context, l);
            e : &EmptyExpression     => return UnitValue::new (loc-> e.getLoc ());
            w : &ValueWrapperExpr    => return w.getValue ();
            s : &SliceAllocatorExpr  => return self.validateSliceAllocator (alias context, s);
            s : &SliceForAllocatorExpr => return self.validateSliceFor (alias context, s);
            u : &UnsafeExpr          => return self.validateUnsafe (alias context, u);
            t : &TypeWrapperExpr => {
                throw ErrorMsg::fatal (t.getLoc (), format (ValidateErrorMessage::USE_AS_VALUE_TYPE, context:.validateType (t)));
            }
            x : _ => {
                throw ErrorMsg::fatal (value.getLoc (), format (ValidateErrorMessage::USE_AS_VALUE_TYPE, x));
            }            
        }
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================            BLOCK             =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a block expression
     * @params: 
     *   - context: the context of the validation
     *   - b: the block to validate
     * @returns: the validated value
     */
    fn validateBlock (self, dmut context : &Validator, b : &BlockExpr)-> &Value
        throws &ErrorMsg
    {
        let dmut errors = Vec!{&ErrorMsg}::new ();
        context:.enterBlock ();
        
        let (values, valuesType, rtLoc, brLoc, valueLoc) = {
            // A block can have local symbol definitions (such as import, struct, etc.), we need to validate them
            let dmut module = self.validateInnerModule (alias context, b.getModule (), alias errors);
            
            let value = match module {                
                EmptySymbol () => { // No local symbol to access
                    self.validateInnerBlock (alias context, b.getExpressions (), alias errors)
                }
                _ => {
                    {
                        // There are some local symbols, we need to have access to them in the current block
                        context:.pushReferent (alias module);
                        self.validateInnerBlock (alias context, b.getExpressions (), alias errors)
                    } exit {
                        context:.popReferent (); // We go back to the previous symbol table, all local symbol are no longer accessible
                    }
                }
            };

            value
        } exit {

            {
                // No need to warn unused if there were errors in the validation of the block (it will complicate the error handling)
                context:.quitBlock (warnUnused-> errors.len () == 0us);
            } catch { err : &ErrorMsg => errors:.push (err); }
        }

        let loc = if (!valueLoc.isEof ()) { valueLoc } else { b.getLoc () };
        let trB = BlockValue::new (loc, valuesType, values, breakLoc-> brLoc, returnLoc-> rtLoc);
        let (retBlock, type, canThrow) = match (b.getCatcher (), errors.len ()) {
            (m : &MatcherExpr, 0us) => {
                let (catcher, ctVar, finType) = self.validateCatcher (alias context, m, valuesType, trB.getThrowers (), alias errors);
                let trBlock = BlockValue::new (loc, finType, values, breakLoc-> brLoc, returnLoc-> rtLoc);
                (cast!{&Value} (TryCatchValue::new (loc, finType, trBlock, catcher, catchVar-> ctVar)), finType, true)

            }
            _ => {
                (cast!{&Value} (trB), valuesType, trB.getThrowers ().len != 0us)
            }
        };

        let finalValue = if (errors.len () == 0us && b.getGuards ().len != 0us) {
            let (onExit, failVar) = self.validateScopeGuards (alias context, b.getLoc (), b.getGuards (), canThrow, alias errors);
            TryFinallyValue::new (loc, type, retBlock, onExit, failVar-> failVar)
        } else {
            retBlock
        };

        if (errors.len () != 0us) throw ErrorMsg::list (errors[]);
        finalValue
    }


    /**
     * Validate the local module declared inside a block
     * @params: 
     *    - context: the context of the validation
     *    - m: the module declared in the block
     * @returns:
     *    - errors: the errors that occured when validating    
     *    - the symbol that was validated (or EmptySymbol, if the validation failed)
     */
    fn validateInnerModule (self, dmut context : &Validator, m : &Declaration, dmut errors : &Vec!{&ErrorMsg})-> dmut &Symbol {
        match m {
            b : &BlockDecl => if (b.getDeclarations ().len == 0us) return EmptySymbol::new ();
        }

        let dmut modSym = {   // We get the declarator of the context, maybe there are imports here, and maybe they are already imported, so we just have to make a reference
            let start = instant::now ();
            let dmut modSym = ModuleSymbol::new (Word::new (Keys::UNDER, m.getLoc ()), importLoc-> EOF_WORD, ""s8, protection-> Protection::PRIVATE);
            modSym:.setReferent (alias context:.getReferent ());

            context:.getDeclarator ():.declare (m, alias modSym);
            context:.getDeclarator ():.finalizeDeclaration (alias modSym);

            let end = instant::now ();
            context:.removeTime (end - start);

            alias modSym
        } catch {
            err : &ErrorMsg => {
                errors:.push (err);
                return EmptySymbol::new ();
            }
        };

        context:.enterForeign (isFnBody-> false, clContext-> context:.getCurrentClassContext ()); // Enter a foreign, but this is not a function, we just want to avoid polluting the current context
        
        {
            context:.validate (alias modSym);  // Validation of the declared symbols 
        } catch {
            err : &ErrorMsg => {
                errors:.push (err);
                return EmptySymbol::new ();
            }
        } exit {            
            context:.exitForeign ();
        }
        
        // Here we return a leaf that can be accessed only from the current block            
        return alias modSym;     
    }

    /**
     * Validate the content of a block
     * @params: 
     *   - context: the context of the validation
     *   - m: the block to validate
     * @returns:
     *   - errors: the list of errors, if an errors occurs
     *   - .0: the list of values inside the block
     *   - .1: the type of the last value
     *   - .2: the location of a return statement if any (EOF otherwise)
     *   - .3: the location of a break statement if any (EOF otherwise)
     *   - .4: the location of the last value
     */
    fn validateInnerBlock (self, dmut context : &Validator, exprs : [&Expression], dmut errors : &Vec!{&ErrorMsg})-> ([&Value], &Type, &Word, &Word, &Word) {
        let mut returner = false, mut breaker = false; // Blocks can break loops or return functions
        // A returned block is a block in which every path leads to a return statement, and a break statement is breaker
        
        let mut rtLoc = EOF_WORD, mut brLoc = EOF_WORD, mut valueLoc = EOF_WORD; // The location of the return, break, and value for error handling
        let mut type : &Type = VoidType::new (EOF_WORD); // By default a block has no value, thus its type is void
        let dmut values = Vec!{&Value}::new (); // List of values in the block
        for i in 0us .. exprs.len {
            {
                // There is another expression to validate, but there is no way that the program arrives at that point (cf. breaker or returner)
                if ((breaker || returner) && !exprs [i].isOf!{&UnitExpr}()) throw ErrorMsg::fatal (exprs [i].getLoc (), ValidateErrorMessage::UNREACHBLE_STATEMENT, notes-> [ErrorMsg::note (rtLoc, ValidateErrorMessage::EXITING_SCOPE_HERE)]);
                
                let val = context:.validateValue (exprs [i]);
                context.verifyCompleteTypeWithValue (exprs [i].getLoc (), val.getType (), val, construct-> false);

                if (val.isReturner ()) { returner = true; rtLoc = val.getReturnerLoc (); }
                if (val.isBreaker ())  { breaker = true; rtLoc = val.getBreakerLoc (); }

                // If the value is implicitely aliased, then we transform it into a immutable value
                type = if (context.needExplicitAlias (val)) {
                    val.getType ().clone (0u32)
                } else {
                    val.getType ()
                };
                
                valueLoc = val.getLoc (); // store the location of the value of the block (if it is the last value, it will be definitely stored)
                if (i == exprs.len - 1us || !val.isOf!{&UnitValue} ()) { // ignore unit values, if there created by otherthings than UnitExpr
                    values:.push (val);  // push the value in the list of value of the block
                }
            } catch {
                err : &ErrorMsg => { errors:.push (err); }
            }            
        }

        match type { 
            VoidType () => {} 
            _ => { // Verify implicit aliases and stuff
                (alias values) [values.len () - 1us] = context:.verifyCompatibleTypeWithValue (valueLoc, type, values [][$ - 1us], byReference-> false);
                context:.verifyMemoryOwner (valueLoc, type, values[][$ - 1us], byReference-> false);
            } catch {
                err : &ErrorMsg => { errors:.push (err); }
            }
        }

        (values[], type, rtLoc, brLoc, valueLoc) 
    }


    /**
     * Validate the catcher part of a block
     * @params: 
     *   - context: the context of the validation
     *   - catcher: the catcher to validate
     *   - type: the type of the block that is catched
     *   - throwers: the list of exception thrown by the block
     * @returns: 
     *   - errors: if errors occured
     *   - .0: the content of the catcher
     *   - .1: the variable that is catched
     *   - .2: the type of the value (try{} catch{})
     */
    fn validateCatcher (self, dmut context : &Validator, catcher : &MatcherExpr, type : &Type, throwers : [(&Word, &Type)], dmut errors : &Vec!{&ErrorMsg})-> (&Value, &Value, &Type) {
        if (throwers.len == 0us) {
            errors:.push (ErrorMsg::fatal (catcher.getLoc (), ValidateErrorMessage::NOTHING_TO_CATCH));
            (UNIT_VALUE, UNIT_VALUE, NONE_TYPE)
        } else {
            let mut failed = false;

            context:.enterBlock ();
            let (content, catchVar, finType) = {
                let mut caughtType = context.createClassInstance (throwers [0]._1); // throwers are class ref, but catch variable is a class ptr
                {
                    for i in 1us .. throwers.len {
                        caughtType = context:.inferTypeBranching (catcher.getLoc (), throwers [i]._0, caughtType, context.createClassInstance (throwers [i]._1));
                    }
                } catch {
                    _ => {
                        caughtType = context:.getExceptionType (loc-> catcher.getLoc ());
                    }
                };

                let catchVar = VarDeclValue::new (Word::new ("#_catch"s8, catcher.getLoc ()), caughtType, UNIT_VALUE, isMutable-> false);
                let catchVarRef = VarRefValue::new (catchVar.getLoc (), catchVar.getLoc (), catchVar.getVarType (), catchVar.getUniqId (), isSelf-> false, canCte-> false);

                let (x, y) = context:.getMatcherValidator ().validateCatcher (alias context, catcher, type, catchVarRef, throwers);
                (x, catchVar, y)
            } catch {
                err : &ErrorMsg => {
                    failed = true;
                    errors:.push (err);
                    (UNIT_VALUE, UNIT_VALUE, NONE_TYPE)
                }
            };

            {
                context:.quitBlock (warnUnused-> !failed)
            } catch {
                err : &ErrorMsg => { errors:.push (err); }
            }

            (content, catchVar, finType)
        }
    }

    /**
     * Validate the scope guards of a block expression
     * @params:
     *    - context: the context of the validation
     *    - guards: the scope guards to validate
     *    - throwers: the list of throwers from the guarded scope
     * @returns:
     *    - errors: filled with errors if some occured
     *    - .0: the content of the validated scope guard
     *    - .1: the variable to declare in case of failure/success guards (might be UNIT_VALUE)
     * */
    fn validateScopeGuards (self, dmut context : &Validator, loc : &Word, guards : [&ScopeGuardExpr], canThrow : bool, dmut errors : &Vec!{&ErrorMsg})-> (&Value, &Value) {
        let mut exit : &Value = UNIT_VALUE;
        let mut fail : &Value = UNIT_VALUE;
        let mut succ : &Value = UNIT_VALUE;

        // already inside a scope guard, scope within another scope
        let inScope = context:.getInScopeGuard ();
        for gu in guards {
            match gu.getKind () {
                ScopeGuardType::FAILURE | ScopeGuardType::SUCCESS => {
                    if !canThrow {
                        errors:.push (ErrorMsg::fatal (gu.getLoc (), format (ValidateErrorMessage::EXIT_SCOPE_NO_THROW, gu.getLoc ().str ())));
                    }
                }
            }

            let mut failed = false;
            context:.enterBlock ();
            if (inScope.isEof ()) context:.enterScopeGuard (gu.getLoc ());

            let value = {
                context:.validateValue (gu.getContent ())
            } catch {
                err : &ErrorMsg => {
                    errors:.push (err);
                    failed = true;
                    UNIT_VALUE
                }
            };

            for i in value.getThrowers () { // cannot throw error in a scope guard
                errors:.push (ErrorMsg::fatal (i.0, end-> gu.getLoc (), format (ValidateErrorMessage::THROW_SCOPE_GUARD_RETHROW, i._1)));
            }

            {
                if (inScope.isEof ()) context:.exitScopeGuard ();
                context:.quitBlock (warnUnused-> !failed)
            } catch {
                err : &ErrorMsg => { errors:.push (err); }
            }

            if (!value.getType ().isOf!{&VoidType} () && !value.getType ().isOf!{&NoneType} ()) {
                errors:.push (ErrorMsg::fatal (gu.getContent ().getLoc (), format (ValidateErrorMessage::EXIT_SCOPE_VALUE_TYPE, gu.getLoc ().str (), value.getType ())));
            }

            match gu.getKind () {
                ScopeGuardType::SUCCESS => { succ = value; }
                ScopeGuardType::FAILURE => { fail = value; }
                _ => { exit = value; }
            }
        }

        if (!fail.isOf!{&UnitValue} () || !succ.isOf!{&UnitValue} ()) {
            let var = VarDeclValue::new (Word::new ("#_failed"s8, loc), BoolType::new (loc), BoolValue::new (loc, true), isMutable-> true);
            let vref = VarRefValue::new (var.getLoc (), var.getLoc (), var.getVarType (), var.getUniqId (), isSelf-> false, canCte-> false);

            let cnd = ConditionalValue::new (loc, VoidType::new (loc), vref, fail, succ);
            let finValue = if (exit.isOf!{&UnitValue} ()) {
                cnd
            } else {
                BlockValue::new (loc, cnd.getType (), [cnd, exit])
            };


            (finValue, var)
        } else {
            (exit, UNIT_VALUE)
        }
    }

    /*!
     * ================================================================================
     * ================================================================================
     * ==========================           UNSAFE            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate an unsafe expression
     * @params:
     *    - context: the context of the validation
     *    - u: the unsafe expression to validate
     * @returns: the validated value
     * */
    fn validateUnsafe (self, dmut context : &Validator, u : &UnsafeExpr)-> &Value
        throws &ErrorMsg
    {
        let loc = context.getUnsafeContextLoc ();
        if (!loc.isEof ()) throw ErrorMsg::fatal (u.getLoc (), ValidateErrorMessage::MULTIPLE_UNSAFE, notes-> [ErrorMsg::note (loc, ""s8)]);

        let mut error = ((&ErrorMsg)?)::__err__;
        let value = {
            context:.enterUnsafeContext (u.getLoc ());
            context:.validateValue (u.getValue ())
        } exit {
            {
                context:.exitUnsafeContext ();
            } catch {
                err : &ErrorMsg => { error = err?; }
            }
        }

        match error {
            Ok (err : _) => throw err;
        }

        value
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================           LITERAL            =========================
     * ================================================================================
     * ================================================================================
     */
    
    
    /**
     * Validate a literal expression
     * @params: 
     *   - context: the context of the validation
     *   - l: the literal to validate
     *   - forceType: the type to force (if different from NONE_TYPE), only applicable in some case (e.g. StringExpr)
     * @returns: the validated value
     */
    fn validateLiteral (self, dmut context : &Validator, l : &LiteralExpr)-> &Value
        throws &ErrorMsg
    {
        return context:.getLiteralValidator ().validate (alias context, l);
    }


    /*!
     * ================================================================================
     * ================================================================================
     * =========================            LAMBDA             ========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a lambda value expression
     * @params: 
     *   - context: the context of the validation
     *   - l: the lambda value
     * @returns: the validated value
     */
    fn validateLambda (self, dmut context : &Validator, l : &LambdaValueExpr)-> &Value
        throws &ErrorMsg
    {
        context:.getLambdaValidator ():.validate (alias context, l)
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =====================          SLICE/ARRAYS/TUPLES           ===================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a list expression
     * */
    fn validateList (self, dmut context : &Validator, l : &ListExpr)-> &Value
        throws &ErrorMsg
    {
        context:.getLiteralValidator ():.validateList (alias context, l)
    }

    /**
     * Validate a slice allocator expression
     * */
    fn validateSliceAllocator (self, dmut context :  &Validator, l : &SliceAllocatorExpr)-> &Value
        throws &ErrorMsg
    {
        context:.getLiteralValidator ():.validateSliceAllocator (alias context, l)
    }

    /**
     * Validate a slice allocation using a for loop
     * @params:
     *    - context: the context of the validation
     *    - alloc: the allocator to validate
     * */
    fn validateSliceFor (self, dmut context : &Validator, alloc : &SliceForAllocatorExpr)-> &Value
        throws &ErrorMsg
    {
        context:.getForLoopValidator ():.validateListComprehension (alias context, alloc)
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================          OPERATORS           =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate an operator expression
     * @params: 
     *   - context: the context of the validation
     *   - o: the operator to validate
     * @returns: the validated value
     */
    fn validateOperator (self, dmut context : &Validator, o : &OperatorExpr)-> &Value
        throws &ErrorMsg
    {
        match o {
            b : &BinaryExpr => return context:.getBinOpValidator ().validateValue (alias context, b);
            m : &MultOperatorExpr => {
                if (m.isIndex ()) {
                    return context:.getIndexOpValidator ().validate (alias context, m);
                } else {
                    return context:.getCallOpValidator ().validate (alias context, m);
                }
            }
            u : &UnaryExpr => return context:.getUnOpValidator ().validate (alias context, u);
            p : &PathExpr =>  return context:.getBinOpValidator ().validateModuleOperation (alias context, p);
            _ => {
                println ("Unknown OP : ", o::typeinfo.name);
                __pragma!panic ();
            }
        }
    }
    
    /*!
     * ================================================================================
     * ================================================================================
     * =========================           VAR_DECL           =========================
     * ================================================================================
     * ================================================================================
     */
    
    /**
     * Validate a var declaration expression
     * @params: 
     *   - context: the context of the validation
    *    - v: the var declaration to validate
     * @returns: the validated var decl value
     */
    pub fn validateVarDecl (self, dmut context : &Validator, v : &VarDeclExpr, needInitValue : bool = true)-> &VarDeclValue
        throws &ErrorMsg
    {
        if (v.getValue ().isOf!{&EmptyExpression} ()) {
            if (v.getType ().isOf!{&EmptyExpression} ()) {
                throw ErrorMsg::fatal (v.getLoc (), ValidateErrorMessage::VAR_DECL_WITH_NOTHING);
            } else if (needInitValue) {
                throw ErrorMsg::fatal (v.getLoc (), ValidateErrorMessage::VAR_DECL_WITHOUT_VALUE);
            }

            self.validateVarDeclNoValue (alias context, v)
        } else {
            let rewrite = VarDeclExpr::new (v.getLoc (), v.getName (), value-> EmptyExpression::new (), type-> v.getType (),
                                            isLazyOrRef-> v.getLazyOrRefLocation (),
                                            isMutOrDmut-> v.getMutOrDmutLocation ());

            let fin = self.validatePatternVarDecl (alias context, PatternVarDeclExpr::new (v.getLoc (), rewrite, v.getValue ()));
            match fin {
                z : &VarDeclValue => {
                    return z;
                }
                _ => {
                    println (format ("% %", fin, fin::typeinfo.name));
                    __pragma!panic ();
                }
            }
        }
    }


    /**
     * Validate a var declaration that has no value
     * @params:
     *    - context: the context of the validation
     *    - v: the variable declaration to validate
     *    - needInitValue:
     * */
    fn validateVarDeclNoValue (self, dmut context : &Validator, v : &VarDeclExpr)-> &VarDeclValue
        throws &ErrorMsg
    {
        let dmut errors = Vec!{&ErrorMsg}::new ();
        if (v.getLoc () != Keys::UNDER) context:.verifyShadow (v.getLoc ());

        let type = {
            context:.validateTypeForVarDecl (v.getType (), v, canBeRef-> true, canBeLazy-> true)
        }  catch {
            err : &ErrorMsg => { // error when validating the type of the variable, so it has an error type, no matter the value
                errors:.push (err);
                cast!{&Type} (ErrorType::new (v.getLoc ()))
            }
        };

        {
            context.verifyNonVoidType (v.getType ().getLoc (), type, true)
        } catch {
            err : &ErrorMsg => errors:.push (err);
        }

        let finalType = if (errors.len () != 0us) {
            ErrorType::new (v.getLoc ())
        } else {
            type
        };

        let ret = VarDeclValue::new (v.getLoc (), finalType, UNIT_VALUE, isReference-> v.isRef (), isLazy-> v.isLazy (), isMutable-> type.isMutable ());
        if (v.getLoc () != Keys::UNDER) context:.insertLocal (v.getLoc ().str (), ret);

        return ret;
    }

    /**
     * Validate a pattern var declaration
     * @params:
     *     - context: the context of the validation
     *     - p: the pattern to validate
     * @returns: the validate value
     * @throws:
     *     - If the validation fails
     * */
    fn validatePatternVarDecl (self, dmut context : &Validator, p : &PatternVarDeclExpr)-> &Value
        throws &ErrorMsg
    {
        let dmut blk = Vec!{&Value}::new ();
        let (mValue, cond, vars, error) = context:.getMatcherValidator ().validateMatcher (alias context, p.getValue (), p.getPattern (), canBeLazy-> true);
        for v in vars { // insert the declared variables
            if (v.0 != Keys::UNDER) {
                context:.insertLocal (v.0, v.1);
            }

            blk:.push (v.1);
        }

        match error {
            // error during the pattern matching, we throw it after inserting error variables to have better error printing for next statements using these variables
            Ok (err : _) => throw err;
        }

        // the test has to be irrefutable to be usable outside a conditional
        let reducedCond = context:.getCompileTimeInterpreter ().reduce (cond);
        if (match reducedCond {
            b : &BoolValue => { !b.isTrue () }
            _ => { true }
        }) throw ErrorMsg::fatal (p.getLoc (), format (ValidateErrorMessage::PATTERN_IS_REFUTABLE, p.getPattern (), mValue));

        if (blk.len () == 1us) {
            blk [0]
        } else {
            cast!{&Value} (BlockValue::new (p.getLoc (), VoidType::new (p.getLoc ()), blk[], isSet-> true))
        }
    }
    
    /**
     * Validate a set expression (generally a succession of var decl)
     * @params: 
     *   - context: the context of the validation
     *   - s: the set to validate
     * @returns: the validated value
     */
    fn validateSet (self, dmut context : &Validator, s : &SetExpr)-> &Value
        throws &ErrorMsg
    {
        let dmut errors = Vec!{&ErrorMsg}::new ();
        let (values, type, brLoc, rtLoc, _) = {
            self.validateInnerBlock (alias context, s.getContent (), alias errors)
        };

        let retBlock = BlockValue::new (s.getLoc (), type, values, breakLoc-> brLoc, returnLoc-> rtLoc, isSet-> true);

        if (errors.len () != 0us) throw ErrorMsg::list (errors[]);
                
        retBlock
    }    

    /*!
     * ================================================================================
     * ================================================================================
     * =========================          DECORATED           =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a decorated expression as a value
     * @params:
     *    - context: the context of the validation
     *    - i: the decorated expression
     * */
    fn validateDecoExpr (self, dmut _ : &Validator, d : &DecoratedExpr)-> &Value
        throws &ErrorMsg
    {
        throw ErrorMsg::fatal (d.getLoc (), format (ValidateErrorMessage::UNDEF_DECORATOR_VALUE, d.getDecorator ().str ()));
    }

    /**
     * Validate an intrinsic expr
     * @params: 
     *   - context: the context of the validation
     *   - i: the intrinsic expression to validate
     * @returns: the validated value
     */
    fn validateIntrinsics (self, dmut context : &Validator, i : &IntrinsicExpr, canValidateRef : bool = false, canBeLazy : bool = false)-> &Value
        throws &ErrorMsg
    {
        match i.getType () {
            IntrinsicKeys::COPY => {
                match i.getContent () {
                    lmbd : &LambdaValueExpr =>
                        return context:.getLambdaValidator ():.validate (alias context, lmbd, isClosure-> true);
                    _ =>
                        return context:.getCopyValidator ().validateCopy (alias context, i);
                }
            }
            IntrinsicKeys::ALIAS  => {
                return self.validateAlias (alias context, i.getLoc (), i.getContent (), isClass-> false);
            }
            IntrinsicKeys::TYPEOF => { // Typeof is necessarily a type (it's in the name)
                throw ErrorMsg::fatal (i.getLoc (), format (ValidateErrorMessage::USE_AS_VALUE));
            }
            IntrinsicKeys::EXPAND => {
                return context:.getExpandValidator ().validateExpand (alias context, i);
            }
            IntrinsicKeys::DCOPY => {
                return context:.getCopyValidator ().validateDeepCopy (alias context, i);
            }
            IntrinsicKeys::CTE => {
                return self.validateCteExpr (alias context, i.getContent ());
            }
            IntrinsicKeys::REF => {
                return self.validateRefExpr (alias context, i, i.getContent (), canValidateRef-> canValidateRef);
            }
            IntrinsicKeys::MOVE => {
                return context:.getCopyValidator ().validateMove (alias context, i);
            }
            IntrinsicKeys::LAZY => {
                return self.validateLazy (alias context, i, i.getContent (), canBeLazy-> canBeLazy);
            }
        }

        __pragma!panic ();
    }

    /**
     * Validate an alias of a value
     * @params: 
     *    - context: the context of the validation
     *    - i: the intrinsic expression assumed to be an alias
     * @returns: the validated value
     * @throws:
     *    - &ErrorMsg: if the value is not aliasable, or cannot be validated
     */
    pub fn validateAlias (self, dmut context : &Validator, loc : &Word, content : &Expression, isClass : bool = false)-> &Value
        throws &ErrorMsg
    {
        let mut value = context:.getValueValidator ().validate (alias context, content, canBeLazy-> true);
        if (isClass) {
            match value.getType () {
                cl : &ClassPtrType => {
                    if (cl.isStruct ()) {
                        context.verifyLeftOperandMove (loc, value, allowSelf-> true);
                    } else {
                        if (!cl.isDeeplyMutable ()) {
                            throw ErrorMsg::fatal (loc, end-> value.getLoc (), format (ValidateErrorMessage::NOT_A_LVALUE_TYPE, value.getType ()));
                        }
                    }

                    return ClassAliaserValue::new (loc, cl, value);
                }
                t : _ => {
                    throw ErrorMsg::fatal (value.getLoc (), format (ValidateErrorMessage::CLASS_ALIAS_NO_CLASS, t));
                }
            };
        } else {
            if (value.isOf!{&ExpandValue} ()) {
                throw ErrorMsg::fatal (loc, end-> value.getLoc (), format (ValidateErrorMessage::MISMATCH_ALIAS_EXPAND, value.getType ()));
            } else if (value.isOf!{&LazyValue} ()) {
                throw ErrorMsg::fatal (loc, end-> value.getLoc (), format (ValidateErrorMessage::MISMATCH_ALIAS_LAZY, value.getType ()));
            }

            value = context.getCompileTimeInterpreter ().reduce (value);
            if (!value.getType ().isMutable ()) {
                throw ErrorMsg::fatal (loc, end-> value.getLoc (), format (ValidateErrorMessage::NOT_A_LVALUE_TYPE, value.getType ()));
            } else if (!value.getType ().needExplicitAlias ()) {
                throw ErrorMsg::fatal (loc, end-> value.getLoc (), format (ValidateErrorMessage::UNECESSARY_ALIAS, value.getType ()));
            }



            return AliaserValue::new (loc, value.getType (), value);
        }
    }

    /**
     * Validate a named expression
     * @params: 
     *   - context: the context of the validation
     *   - n: the named expression to validate
     * @returns: the validated value
     */
    fn validateNamedExpr (self, dmut context : &Validator, n : &NamedExpr, canBeRef : bool = false, canBeLazy : bool = false)-> &Value
        throws &ErrorMsg
    {
        let content = self.validate (alias context, n.getContent (), canBeRef-> canBeRef, canBeLazy-> canBeLazy);
        let rContent = if (!canBeLazy && !canBeRef) {
            context:.getCompileTimeInterpreter ().reduce (content)
        } else {
            content
        };

        NamedValue::new (n.getLoc (), n.getLoc ().str (), rContent)
    }

    /**
     * Validate a reference expression
     * @params:
     *    - context: the context of the validation
     *    - i: the intrinsic expression containing the ref
     *    - expr: the content of the ref
     *    - canValidateRef: true iif a ref can be constructed here
     * @returns: the ref value
     * @throws:
     *   - &ErrorMsg: if the validation fails
     * */
    fn validateRefExpr (self, dmut context : &Validator, i : &IntrinsicExpr, expr : &Expression, canValidateRef : bool)-> &Value
        throws &ErrorMsg
    {
        let ret = context:.validateValue (expr);
        context.verifyLeftOperandMove (i.getLoc (), ret, allowSelf-> true);

        if (!canValidateRef) {
            throw ErrorMsg::fatal (i.getLoc (), end-> ret.getLoc (), ValidateErrorMessage::UNECESSARY_REFERENCE);
        }

        return ReferencerValue::new (i.getLoc (), ret.getType (), ret, isMutable-> true);
    }


    /**
     * Validate a lazy intrinsic expression
     * @params:
     *    - context: the context of the validation
     *    - i: the intrinsic expression containing the lazy
     *    - expr: the content of the lazy
     *    - canBeLazy: true iif a lazy can be constructed here
     * @returns: the lazy value
     * @throws:
     *   - &ErrorMsg: if the validation fails
     * */
    pub fn validateLazy (self, dmut context : &Validator, i : &IntrinsicExpr, expr : &Expression, canBeLazy : bool)-> &Value
        throws &ErrorMsg
    {
        if (!canBeLazy) throw ErrorMsg::fatal (i.getLoc (), format (ValidateErrorMessage::UNECESSARY_LAZY));

        let retValue = context:.validateValue (expr);
        let (byAlias, retType) = if (context.needExplicitAlias (retValue)) {
            (false, retValue.getType ().clone (0u32))
        } else {
            (retValue.getType ().needExplicitAlias (), retValue.getType ())
        };

        let name = Word::new ("#_REF"s8, i.getLoc ());
        let retVdecl = VarDeclExpr::new (name, name,
                                         type-> TypeWrapperExpr::new (i.getLoc (), retType, asIs-> true),
                                         value-> EmptyExpression::new (),
                                         isMutOrDmut-> Word::new (Keys::MUTABLE, i.getLoc ()),
                                         isLazyOrRef -> Word::new (Keys::REF, i.getLoc ()));

        let vexpr = VarExpr::new (name);

        let proto = FunctionProtoDecl::new (i.getLoc (), [retVdecl], EmptyExpression::new (), forLambda-> true);
        let blk = BinaryExpr::new (Word::new (Tokens::EQUAL, i.getLoc ()), vexpr, expr);
        let lmbd = LambdaValueExpr::new (i.getLoc (), proto, blk);

        let retFunc = context:.getLambdaValidator ():.validate (alias context, lmbd, isClosure-> true, forLazy-> true);

        LazyValue::new (i.getLoc (), retType, retFunc, byAlias-> byAlias)
    }

    /**
     * Validate an expression that has been marked as "cte"
     * @params:
     *   - context: the context of the validation
     *   - expr: the expression to validate
     * @returns: the validated expression
     * @throws:
     *   - &ErrorMsg: if the validation fails
     */
    pub fn validateCteExpr (self, dmut context : &Validator, expr : &Expression)-> &Value
        throws &ErrorMsg
    {
        match expr {
            c : &ConditionalExpr => { // Conditionals have a different treatment for ctes
                return self.validateCteConditionalExpr (alias context, c);
            }
            f : &ForLoopExpr => { // Same for "for" loops
                return self.validateCteForLoopExpr (alias context, f);
            }
            a : &AssertExpr => {
                return self.validateCteAssertExpr (alias context, a);
            }
            _ => { // Otherwise we just try to get the value at compilation time
                let resExpr = context:.validateValue (expr);
                if (!context.getCompileTimeInterpreter ().isCte (resExpr)) {
                    throw ErrorMsg::fatal (resExpr.getLoc (), format (ValidateErrorMessage::UNKNOWN_AT_COMPILE_TIME, resExpr.getType ()));
                }

                return resExpr;
            }
        }
    }

    /**
     * Validate a conditional expression whose test must be evaluated at compilation time
     * @params:
     *    - context: the context of the validation
     *    - expr: the expression to validate
     * @returns: the result content of the if expression (or its else value if the test did not pass)
     * @throws:
     *     - &ErrorMsg: if the validation fails or the test value cannot be known at compile time
     */
    fn validateCteConditionalExpr (self, dmut context : &Validator, expr : &ConditionalExpr)-> &Value
        throws &ErrorMsg
    {
        let test = context:.validateValue (expr.getTest ()); // First we need to validate the expression of the test of the conditional
        let value = context:.getCompileTimeInterpreter ().computeBool (test); // And try to retreive its real value at compilation time
        if (value) {
            context:.validateValue (expr.getContent ())
        } else { // otherwise only the else part is validated
            context:.validateValue (expr.getElse ())
        }
    }

    /**
     * Validate a for loop that is marked cte
     * @params:
     *    - context: the context of the validation
     *    - expr: the for loop to validate
     * @returns: the content of the for loop, unrolled at compile time
     * @throws:
     *    - &ErrorMsg: if the for loop cannot be executed at compile time, or there is an error in the validation (iterator, or for loop content)
     */
    fn validateCteForLoopExpr (self, dmut context : &Validator, expr : &ForLoopExpr)-> &Value
        throws &ErrorMsg
    {
        context:.getForLoopValidator ():.validateCteForLoop (alias context, expr)
    }

    /**
     * Validate an assert expression whose test is made at compilation time
     * @params:
     *     - context: the context of the validation
     *     - a: the expression to validate
     * @returns: a unit expr
     * @throws:
     *   - &ErrorMsg: if the assert expression failed to be validated, or is test is false
     * */
    fn validateCteAssertExpr (self, dmut context : &Validator, a : &AssertExpr)-> &Value
        throws &ErrorMsg
    {
        let test = context:.validateValue (a.getTest ());
        let value = context:.getCompileTimeInterpreter ().computeBool (test);
        if (!value) {
            match a.getMessage () {
                EmptyExpression () => {
                    throw ErrorMsg::fatal (a.getLoc (), ValidateErrorMessage::CTE_ASSERT_NO_MSG);
                }
                msg : _ => {
                    let m = context:.validateValue (msg);
                    throw ErrorMsg::fatal (a.getLoc (), format (ValidateErrorMessage::CTE_ASSERT_WITH_MSG, m));
                }
            }
        }

        UNIT_VALUE
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================     CONDITION AND LOOPS      =========================
     * ================================================================================
     * ================================================================================
     */
    
    /**
     * Validate a conditional expression
     * @params: 
     *   - context: the context of the validation
     *   - c: the conditional expression to validate
     * @returns: the validated value
     */
    fn validateConditional (self, dmut context : &Validator, c : &ConditionalExpr)-> &Value
        throws &ErrorMsg
    {
        if (c.isLet ()) {
            return self.validateConditionalPattern (alias context, c);
        }

        let test = match c.getTest () {
            EmptyExpression () => { cast!{&Value} (UNIT_VALUE) }
            t : _ => {
                let r = context:.validateValue (t);
                if (!r.getType ().isOf!{&BoolType} ()) {
                    throw ErrorMsg::fatal (r.getLoc (), format (ValidateErrorMessage::INCOMPATIBLE_TYPE, r.getType (), BoolType::new (r.getLoc ())));
                }
                r
            }
        };

        match test {
            b : &BoolValue => {
                if (b.isTrue ()) throw ErrorMsg::fatal (b.getLoc (), format (ValidateErrorMessage::USELESS_COND_TRUE));
                else throw ErrorMsg::fatal (b.getLoc (), format (ValidateErrorMessage::USELESS_COND_FALSE));
            }
        }

        let content = context:.validateValue (c.getContent ());
        let mut type = content.getType ();
        {
            context.verifyMemoryOwner (content.getLoc (), type, content, byReference-> false);
        } catch {
            _ : &ErrorMsg => {
                type = type.clone (0u32);
                context.verifyMemoryOwner (content.getLoc (), type, content, byReference-> false);
            }
        }

        self.validateConditionalElse (alias context, c, type, test, content)
    }

    /**
     * Validate a conditional where the test is a pattern matching variable declaration
     * @params:
     *    - context: the context of the validation
     *    - c: the conditional to validate
     * */
    fn validateConditionalPattern (self, dmut context : &Validator, c : &ConditionalExpr)-> &Value
        throws &ErrorMsg
    {
        let mut error = ((&ErrorMsg)?)::__err__, mut hasErrors = false;
        let (pattern, value) = match c.getTest () {
            v : &VarDeclExpr => {
                let rewrite = VarDeclExpr::new (v.getLoc (), v.getName (), value-> EmptyExpression::new (), type-> v.getType (),
                                                isLazyOrRef-> v.getLazyOrRefLocation (),
                                                isMutOrDmut-> v.getMutOrDmutLocation ());
                (rewrite, v.getValue ())
            }
            p : &PatternVarDeclExpr => (p.getPattern (), p.getValue ())
            _ => __pragma!panic ();
        };

        let (_, test_, vars, error_) = context:.getMatcherValidator ().validateMatcher (alias context, value, pattern);
        match error_ {
            Ok (err : _) => throw err;
        }

        context:.enterBlock ();
        let (content, test, type) = {
            let (test, taut, _) = context:.getMatcherValidator ().validateConditionGuard (alias context, vars, c.getGuard (), test_);
            match context:.getCompileTimeInterpreter ().reduce (taut) {
                b : &BoolValue => {
                    if (b.isTrue ()) throw ErrorMsg::fatal (b.getLoc (), format (ValidateErrorMessage::USELESS_COND_TRUE));
                    else throw ErrorMsg::fatal (b.getLoc (), format (ValidateErrorMessage::USELESS_COND_FALSE));
                }
            }

            let content = context:.validateValue (c.getContent ());
            let mut type = content.getType ();
            {
                context.verifyMemoryOwner (content.getLoc (), type, content, byReference-> false);
            } catch {
                _ : &ErrorMsg => {
                    type = type.clone (0u32);
                    context.verifyMemoryOwner (content.getLoc (), type, content, byReference-> false);
                }
            }

            (content, test, type)
        } catch {
            err : &ErrorMsg => {
                error = (err)?;
                hasErrors = true;
                (UNIT_VALUE, UNIT_VALUE, NONE_TYPE)
            }
        };

        {
            // No need to warn unused if there were errors in the validation of the block (it will complicate the error handling)
            context:.quitBlock (warnUnused-> !hasErrors);
        } catch {
            err : &ErrorMsg => {
                if (!hasErrors) {
                    error = (err?);
                }
            }
        }

        match error {
            Ok (err : _) => throw err;
        }

        self.validateConditionalElse (alias context, c, type, test, content)
    }

    /**
     * Validate the else part of a conditional
     * @params:
     *    - context: the context of the validation
     *    - c: the conditional to validate
     *    - content: the content of the if
     * */
    fn validateConditionalElse (self, dmut context : &Validator, c : &ConditionalExpr, type : &Type, test : &Value, content : &Value)-> &Value
        throws &ErrorMsg
    {
        match c.getElse () {
            EmptyExpression () => {
                if (!type.isOf!{&VoidType} ()) {
                    throw ErrorMsg::fatal (c.getLoc (), end-> content.getLoc (), format (ValidateErrorMessage::IF_COND_NOT_COMPLETE, type));
                }

                ConditionalValue::new (c.getLoc (), type, test, content, elsev-> UNIT_VALUE)
            }
            e : _ => {
                let else_ = context:.validateValue (e);
                let (inferedType, valueElse) = if (!else_.isBreaker () && !else_.isReturner ()) {
                    {
                        if (content.isBreaker () || content.isReturner ()) {
                            (else_.getType (), else_)
                        } else { // neither are breakers/returners
                            context:.inferTypeBranchingWithValue (content.getLoc (), type, else_)
                        }
                    } catch {
                        err : &ErrorMsg => throw ErrorMsg::fatal (c.getLoc (), notes-> [err], ValidateErrorMessage::BRANCHING_VALUE);
                    }
                } else {
                    if (!content.isBreaker () && !content.isReturner ()) {
                        (content.getType (), else_)
                    } else { // both are breakers/returner
                        (cast!{&Type} (VoidType::new (c.getLoc ())), else_)
                    }
                }

                ConditionalValue::new (c.getLoc (), inferedType, test, content, elsev-> valueElse)
            }
        }
    }
        
    /**
     * Validate a for loop
     * @params: 
     *   - context: the context of the validation
     *   - f: the for loop to validate
     * @returns: the validated value
     */
    fn validateForLoop (self, dmut context : &Validator, f : &ForLoopExpr)-> &Value
        throws &ErrorMsg
    {
        return context:.getForLoopValidator ().validate (alias context, f);
    }

    /**
     * Validate a while loop
     * @params: 
     *   - context: the context of the validation
     *   - w: the while loop to validate
     * @returns: the validated value
     */
    fn validateWhileLoop (self, dmut context : &Validator, w : &WhileLoopExpr)-> &Value
        throws &ErrorMsg
    {
        let test = match w.getTest () {
            EmptyExpression () => { cast!{&Value} (UNIT_VALUE) }
            t : _ => {
                let r = context:.validateValue (t);
                if (!r.getType ().isOf!{&BoolType} ()) {
                    throw ErrorMsg::fatal (r.getLoc (), format (ValidateErrorMessage::INCOMPATIBLE_TYPE, r.getType (), BoolType::new (r.getLoc ())));
                }

                match r {
                    b : &BoolValue => {
                        if b.isTrue () throw ErrorMsg::fatal (b.getLoc (), format (ValidateErrorMessage::INFINITE_LOOP));
                        else {
                            if (!w.isDo ()) throw ErrorMsg::fatal (b.getLoc (), format (ValidateErrorMessage::NEVER_ENTERED_LOOP));
                            else throw ErrorMsg::fatal (b.getLoc (), format (ValidateErrorMessage::ONE_ITER_LOOP));
                        }
                    }
                }

                r
            }
        };

        let voidType = VoidType::new (w.getLoc ());
        let content = {
            context:.enterLoop ();
            if (!w.getTest ().isOf!{&EmptyExpression} ())
                context:.setCurrentLoopType (voidType);
            
            context:.validateValue (w.getContent ())
        } catch {
            err : &ErrorMsg => { 
                context:.quitLoop ();
                throw err;
            }
        }

        let mut loopType = context:.getCurrentLoopType ();
        if (loopType.isOf!{&NoneType} ()) loopType = voidType;

        context:.quitLoop ();        
        context:.verifyCompatibleType (content.getLoc (), w.getLoc (), content.getType (), voidType);

        LoopValue::new (w.getLoc (), loopType, test, content, w.isDo ())
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================    BREAK/RETURN/ and MISC    =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a break expression
     * @params: 
     *   - context: the context of the validation
     *   - b: the break to validate
     * @returns: the validated value
     */
    fn validateBreak (self, dmut context : &Validator, b : &BreakExpr)-> &Value
        throws &ErrorMsg
    {        
        if (!context.isInLoop ()) throw ErrorMsg::fatal (b.getLoc (), ValidateErrorMessage::BREAK_NO_LOOP);
        let inScope = context.getInScopeGuard ();
        if (!inScope.isEof ()) throw ErrorMsg::fatal (b.getLoc (), end-> inScope, format (ValidateErrorMessage::BREAK_SCOPE_GUARD));

        // Break can have a value in 'loop' loops
        let val = match b.getValue () {
            EmptyExpression () => { cast!{&Value} (UnitValue::new (loc-> b.getLoc ())) }
            v : &Expression => {
                context:.validateValue (v)
            }
        };
        
        let loopType = context.getCurrentLoopType ();

        // There may be multiple break in the loop, we need to verify that the type is compatible
        // It is a branching type (multiple branch with slightly different types)
        let (finLoopType, finLoopValue) = context:.inferTypeBranchingWithValue (b.getLoc (), loopType, val);

        // We need to ensure that there is no mutability issue 
        context.verifyMemoryOwner (b.getLoc (), finLoopType, finLoopValue, byReference-> false);

        // Change the loop type for future break branches (and loop type)
        context:.setCurrentLoopType (finLoopType);

        // Breaks are not really values (you cannot write 'a = break 12;'), they are always typed 'void'
        BreakValue::new (b.getLoc (), finLoopValue)
    }

    /**
     * Validate a return expression
     * @params: 
     *   - context: the context of the validation
     *   - r: the return to validate
     * @returns: the validated value
     */
    fn validateReturn (self, dmut context : &Validator, r : &ReturnExpr)-> &Value
        throws &ErrorMsg
    {
        if (!context.isInFunctionBody ()) throw ErrorMsg::fatal (r.getLoc (), ValidateErrorMessage::RETURN_NO_FUNCTION);
        let inScope = context.getInScopeGuard ();
        if (!inScope.isEof ()) throw ErrorMsg::fatal (r.getLoc (), end-> inScope, format (ValidateErrorMessage::RETURN_SCOPE_GUARD));

        // The function type is set once at the beginning of a function validation, or by return statement in case of lambda validation
        let fnType = context.getFunctionReturn ();
        
        // Return can be used in void function to quit the function immediately, so without a value
        let val = match r.getValue () {
            EmptyExpression () => { cast!{&Value} (UnitValue::new (loc-> r.getLoc ())) }
            v : &Expression => {
                let res = context:.validateValue (v);
                
                match res.getType () {
                    LambdaType () => {
                        // We have the possibility here - thanks to the return type of the function - to know the types of the prototype of a lambda function
                        if (fnType.isOf!{&FuncPtrType} () || fnType.isOf!{&DelegateType} ()) { // inferLambdaValue manage that test, but we don't want error throwing for anything else than lambda validation error
                            context:.inferLambdaValue (fnType, res)
                        } else { res }
                    }
                    _ => { res }
                }
            }
        };

        
        let resVal = if (context.isInLambdaBody ()) { // The type can be changed by the return statement
            let (finFnType, f) = context:.inferTypeBranchingWithValue (val.getLoc (), fnType, val);
            context:.setFunctionReturn (finFnType);
            f
        } else {
            // Verify that the mutability of the returned values is respected
            let f = context:.verifyCompatibleTypeWithValue (fnType.getLoc (), fnType, val, byReference-> false);
            context:.verifyMemoryOwner (fnType.getLoc (), fnType, f, construct-> true, byReference-> false);
            f
        }
        

        // Returns are not really values (you cannot write 'a = return 12;'), they are always typed 'void'
        ReturnValue::new (r.getLoc (), resVal)
    }

    /**
     * Validate a throw expression
     * @params: 
     *   - context: the context of the validation
     *   - t: the throw to validate
     * @returns: the validated value
     */
    fn validateThrow (self, dmut context : &Validator, t : &ThrowExpr)-> &Value
        throws &ErrorMsg
    {
        if (!context.isInFunctionBody ()) throw ErrorMsg::fatal (t.getLoc (), ValidateErrorMessage::THROW_NO_FUNCTION);
        // let inScope = context.getInScopeGuard ();
        // if (!inScope.isEof ()) throw ErrorMsg::fatal (t.getLoc (), end-> inScope, format (ValidateErrorMessage::THROW_SCOPE_GUARD));

        let inner = context:.validateValue (t.getValue ());
        let type = inner.getType ();

        let exceptionType = context:.getExceptionType (loc-> t.getLoc ());
        context.verifyAncestor (t.getLoc (), exceptionType, type);
        
        ThrowValue::new (t.getLoc (), inner)
    }

    /**
     * Validate a panic expression
     * @params:
     *    - context: the context of the validation
     *    - p: the panic to validate
     * @returns: the panic value
     * */
    fn validatePanic (self, dmut _ : &Validator, p : &PanicExpr)-> &Value {
        PanicValue::new (p.getLoc ())
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================        PATTERN MATCH         =========================
     * ================================================================================
     * ================================================================================
     */
    
    /**
     * Validate a pattern matcher
     * @params: 
     *   - context: the context of the validation
     *   - m: the pattern matcher to validate
     * @returns: the validated value
     */
    fn validateMatcher (self, dmut context : &Validator, m : &MatcherExpr)-> &Value
        throws &ErrorMsg
    {
        return context:.getMatcherValidator ().validate (alias context, m);
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================            MACRO             =========================
     * ================================================================================
     * ================================================================================
     */


    /**
     * Validate a macro call expression
     * @params: 
     *   - context: the context of the validation
     *   - m: the macro call expression to validate
     * @returns: the validated value
     */
    fn validateMacroCall (self, dmut context : &Validator, m : &MacroCallExpr)-> &Value
        throws &ErrorMsg
    {
        return context:.getMacroSolver ().validate (alias context, m);
    }


    /*!
     * ================================================================================
     * ================================================================================
     * =========================            PRAGMA            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a pragma expression
     * @params: 
     *   - context: the context of the validation
     *   - p: the pragma expression to validate
     * @returns: the validated value
     */
    fn validatePragma (self, dmut context : &Validator, p : &PragmaExpr)-> &Value
        throws &ErrorMsg
    {
        context:.getPragmaValidator ():.validateValue (alias context, p)
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================            ASSERT            =========================
     * ================================================================================
     * ================================================================================
     */


    /**
     * Validate an assert expression
     * @params: 
     *   - context: the context of the validation
     *   - p: the assert expression to validate
     *   - isCte: true iif the assertion has to be done CTE
     * @returns: the validated value
     */
    fn validateAssert (self, dmut context : &Validator, a : &AssertExpr, isCte : bool = false)-> &Value
        throws &ErrorMsg
    {
        let test = context:.validateValue (a.getTest ());
        let (isFalse, canCte) = { // if the test is false at compile time, we can assume its a return loc
            (!context:.getCompileTimeInterpreter ():.computeBool (test), true)
        } catch {
            err : _ => {
                if (isCte) throw err;
                (false, false) // not cte
            }
        };

        if (!isCte) {
            // if the expression has a message, it is passed to the abort function
            let message = match a.getMessage () {
                EmptyExpression () => { cast!{&Value} (makeStringSliceValue (a.getLoc (), ""s8)) }
                expr : _ => {
                    context:.validateValue (expr)
                }
            };

            let assertType = context:.getExceptionFromName (CoreNames::ASSERT_EXCEPTION);
            let assertInstanceCtor = context:.constructObjectInstance (a.getLoc (), assertType, [message]);
            let throwVal = ThrowValue::new (a.getLoc (), assertInstanceCtor);

            return if (isFalse) { // the test is always false, then it is a returner
                BlockValue::new (a.getLoc (), VOID_TYPE, [throwVal], returnLoc-> a.getLoc (), isSet-> true)
            } else { // otherwise (always true, or not cte)
                if (canCte) throw ErrorMsg::fatal (a.getLoc (), end-> test.getLoc (), format (ValidateErrorMessage::USELESS_RUNTIME_ASSERT));
                ConditionalValue::new (a.getLoc (), VOID_TYPE, UnaryBoolOperatorValue::new (a.getLoc (), UnaryOperators::NOT, test), throwVal, elsev-> UNIT_VALUE, isComplete-> false, isReduced-> true)
            };
        } else {
            if (isFalse) {
                match a.getMessage () {
                    EmptyExpression ()=> throw ErrorMsg::fatal (a.getLoc (), ValidateErrorMessage::CTE_ASSERT_NO_MSG);
                    expr : _ => {
                        let msg = context:.validateValue (expr);
                        throw ErrorMsg::fatal (a.getLoc (), format (ValidateErrorMessage::CTE_ASSERT_WITH_MSG, msg));
                    }
                }
            }

            return UNIT_VALUE;
        }
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================             TRY              =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a try expression
     * @params: 
     *   - context: the context of the validation
     *   - t: the try expression to validate
     * @returns: the validated value
     */
    fn validateTry (self, dmut context : &Validator, t : &TryExpr)-> &Value
        throws &ErrorMsg
    {
        let content = context:.validateValue (t.getValue ());
        if (content.getThrowers ().len == 0us) {
            context.verifyNoBreaking (t.getLoc (), content);

            let innerType = context:.inferTypeImplicitMutability (content);
            OptionValue::new (t.getLoc (), OptionType::new (t.getLoc (), innerType, isMutable-> true), content)
        } else {
            let innerType = context:.inferTypeImplicitMutability (content);
            self.validateOptionCatcher (alias context, t.getLoc (), innerType, content)
        }
    }

    /**
     * Validate an try expression where inner value can throw exceptions
     * @params:
     *    - context: the context of the validation
     *    - loc: the location of the option value
     *    - t: the type of the inner type
     *    - v: the value being created
     * @returns: an option value catching everything
     * @throws:
     *    - &ErrorMsg: if the validation fails
     * */
    fn validateOptionCatcher (self, dmut context : &Validator, loc : &Word, t : &Type, v : &Value)-> &Value
        throws &ErrorMsg
    {
        let optType = OptionType::new (loc, t, isMutable-> true);
        let tryValue = OptionValue::new (loc, optType, v);
        let elsValue = ErrOptionValue::new (loc, type-> optType);

        let exceptType = context:.getExceptionType (loc-> loc);
        let catchVar = VarDeclValue::new (Word::new ("#_catch"s8, loc), exceptType, UNIT_VALUE, isMutable-> false);

        let tryBlock = BlockValue::new (loc, optType, [tryValue]);
        let elsBlock = BlockValue::new (loc, optType, [elsValue]);

        TryCatchValue::new (loc, optType, tryBlock, elsBlock, catchVar-> catchVar)
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================            ATOMIC            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate an atomic expression
     * @params: 
     *   - context: the context of the validation
     *   - a: the atomic expression to validate
     * @returns: the validated value
     */
    fn validateAtomic (self, dmut context : &Validator, a : &AtomicExpr)-> &Value
        throws &ErrorMsg
    {
        match a.getMonitor () {
            EmptyExpression () => {
                return self.validateAtomicNoMonitor (alias context, a);
            }
            UnitExpr () => {
                return self.validateAtomicNoMonitor (alias context, a);
            }
            _ => {
                return self.validateAtomicWithMonitor (alias context, a);
            }
        }
    }

    /**
     * Validate an atomic value that does not use a monitor
     * @params:
     *     - context: the context of the validation
     *     - a: the atomic expr to validate
     * @returns: the try finally value
     * */
    fn validateAtomicWithMonitor (self, dmut context : &Validator, a : &AtomicExpr)-> &Value
        throws &ErrorMsg
    {
        let monitor = context:.validateValue (a.getMonitor ());
        let isClass = match monitor.getType () {
            c : &ClassPtrType => { !c.isStruct () }
            _ => { false }
        };

        if (!isClass) {
            throw ErrorMsg::fatal (a.getMonitor ().getLoc (), format (ValidateErrorMessage::NOT_A_CLASS, monitor.getType ()),
                                   notes-> [ErrorMsg::note (a.getLoc (), format (ValidateErrorMessage::ATOMIC_NEEDS_MONITOR))]);
        }

        let (lock, unlock) = context:.getAtomicLockerWithMonitorFuncs (loc-> a.getLoc ());
        let inner = context:.validateValue (a.getValue ());

        let before = context:.getCallOpValidator ().validate (alias context, a.getLoc (), lock, [monitor]);
        let post = context:.getCallOpValidator ().validate (alias context, a.getLoc (), unlock, [monitor]);

        let innerType = context:.inferTypeImplicitMutability (inner);
        let blk = BlockValue::new (a.getLoc (), innerType, [before, inner], breakLoc-> inner.getBreakerLoc (), returnLoc-> inner.getReturnerLoc ());
        let postBlock = BlockValue::new (a.getLoc (), VOID_TYPE, [post]);

        TryFinallyValue::new (a.getLoc (), innerType, blk, postBlock, failVar-> UNIT_VALUE)
    }

    /**
     * Validate an atomic value that does not use a monitor
     * @params:
     *     - context: the context of the validation
     *     - a: the atomic expr to validate
     * @returns: the try finally value
     * */
    fn validateAtomicNoMonitor (self, dmut context : &Validator, a : &AtomicExpr)-> &Value
        throws &ErrorMsg
    {
        let (lock, unlock) = context:.getAtomicLockerNoMonitorFuncs (loc-> a.getLoc ());
        let inner = context:.validateValue (a.getValue ());

        let before = context:.getCallOpValidator ().validate (alias context, a.getLoc (), lock, []);
        let post = context:.getCallOpValidator ().validate (alias context, a.getLoc (), unlock, []);

        let innerType = context:.inferTypeImplicitMutability (inner);
        let blk = BlockValue::new (a.getLoc (), innerType, [before, inner], breakLoc-> inner.getBreakerLoc (), returnLoc-> inner.getReturnerLoc ());
        let postBlock = BlockValue::new (a.getLoc (), VOID_TYPE, [post]);

        TryFinallyValue::new (a.getLoc (), innerType, blk, postBlock, failVar-> UNIT_VALUE)
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================             CAST             =========================
     * ================================================================================
     * ================================================================================
     */


    /**
     * Validate a cast expression
     * @params: 
     *   - context: the context of the validation
     *   - c: the cast expression to validate
     * @returns: the validated value
     */
    fn validateCast (self, dmut context : &Validator, c : &CastExpr)-> &Value
        throws &ErrorMsg
    {
        context:.getCastValidator ().validateValue (alias context, c)
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================          TEMPLATES           =========================
     * ================================================================================
     * ================================================================================
     */
    
    /**
     * Validate a template call expression
     * @params: 
     *   - context: the context of the validation
     *   - t: the template call to validate
     * @returns: the validated value
     */
    fn validateTemplateCall (self, dmut context : &Validator, t : &TemplateCallExpr)-> &Value
        throws &ErrorMsg
    {
        let left = context:.validateValue (t.getLeft ());
         // validate the list of argument of the template call
        let list = context:.validateTemplateArgumentList (t.getRights ());

        self.validateTemplateCall (alias context, t.getLoc (), left, list)
    }

    /**
     * Validate a template call
     * @params:
     *    - context: the context of the validation
     *    - t: the template call to validate
     * @returns: the validated value
     * */
    pub fn validateTemplateCall (self, dmut context : &Validator, loc : &Word, left : &Value, rights : [&Generator])-> &Value
        throws &ErrorMsg
    {
        let value : &MultSymValue = match left {
            m : &MultSymValue => { m }
            tmp : _ => { MultSymValue::new (left.getLoc (), [tmp], prettyStr-> format ("%", tmp, withTags-> ["withParams"s8])) }
        };

        self.validateTemplateCallMultSym (alias context, loc, value, rights)
    }

    /**
     * Validate a template call where left and right operands are valdiated
     * @params: 
     *    - context: the context of the valdiation
     *    - left: the left operand
     *    - rights: the list of arguments
     * @returns: the result value
     * @throws:
     *    - &ErrorMsg: if the call is impossible
     */
    pub fn validateTemplateCallMultSym (self, dmut context : &Validator, loc : &Word, left : &MultSymValue, rights : [&Generator])-> &Value
        throws &ErrorMsg
    {
        // We store the results inside a vector, where to each valid values is associated the correct rewritter
        let mut results : mut [mut (u32, [(&TemplateRewriter, &Value)])] = []; 
        let dmut errors = Vec!{&ErrorMsg}::new ();
        for it in left.getValues () {
            {
                let rewriter = context:.getTemplateSolver ().validateCallValue (alias context, left.getLoc (), it, rights);                    
                let mut found = false;
                for i in 0us .. results.len {                    
                    if (results[i]._0 == rewriter.getScore ()) {
                        (alias results)[i] = (results[i]._0, results[i]._1 ~ [(rewriter, it)]);
                        found = true;
                        break {}
                    } else if (results[i]._0 < rewriter.getScore ()) {
                        results = alias ((alias results[0us .. i] ~ [(rewriter.getScore (), [(rewriter, it)])]) ~ results[i .. $]);
                        found = true;
                        break {}
                    }
                }

                if (!found) results = alias (results ~ [(rewriter.getScore (), [(rewriter, it)])]);
            } catch {
                err : &ErrorMsg => { // does not work
                    errors:.push (err);
                }
            }
        }

        if (results.len == 0us && errors.len () != 0us) { // No value succeded, and there was some errors
            throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_TEMPLATE_CALL, left, rights, withTags-> ["withParams"s8]), notes-> errors[]);
        }

        {
            self.finalizeTemplateCallMultSym (alias context, left.getLoc (), results[0us]._1)
        } catch {
            err : &ErrorMsg => {
                throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_TEMPLATE_CALL, left, rights, withTags-> ["withParams"s8]), notes-> [err]);
            }
        }
    }
      
    /**
     * Finalize the validation of rewrittable template specialization
     * @params: 
     *     - context: the context of the validation
     *     - loc: the location of the specialization
     *     - list: the list of rewrittable specialization (@warning: assumed to contain at least one value)
     * @returns: the value containing the declared sybmols
     * @throws:
     *     - &ErrorMsg: if there was in error in the validation
     */
    fn finalizeTemplateCallMultSym (self, dmut context : &Validator, loc : &Word, list : [(&TemplateRewriter, &Value)])-> &Value
        throws &ErrorMsg
    {
        let dmut finalResults = Vec!{dmut &Symbol}::new ();
        let dmut delegates = Vec!{&Value}::new ();
        let dmut errors = Vec!{&ErrorMsg}::new ();

        for it in list { // for each value that can be rewritten 
            {
                match it._1 {
                    m : &MethodDelegateTemplateValue => {
                        delegates:.push (self.finalizeTemplateMethodCall (alias context, loc, it._0, m));
                    }
                    c : &CtorDelegateTemplateValue => {
                        delegates:.push (self.finalizeTemplateCtorCall (alias context, loc, it._0, c));
                    }
                    x : &TemplateRefValue => {
                        let dmut val = alias context:.getTemplateDeclarator ().declare (alias context, loc, it._0, x);
                        finalResults:.push (alias val);
                    }
                    z : _ => {
                        println ("TODO : ", z::typeinfo.name);
                        __pragma!panic ();
                    }
                }
            } catch {
                err : &ErrorMsg => { // symbol declaration failed (rewrite cannot fail)
                    errors:.push (err);
                }
            }            
        }

        if (finalResults.len () == 0us && delegates.len () == 0us) { // if there is not symbol with validation
            throw ErrorMsg::list (errors[]);
        }

        // transform the standard declared symbols into values
        context:.getLiteralValidator ().validateMultSymbols (loc, alias context, alias (alias finalResults)[], base-> delegates[])
    }

    /**
     * Finalize the declaration and validation of a constructor template that was called using template call syntax
     * @params:
     *   - context: the context of the validation
     *   - loc: the location of the template call
     *   - r: the template rewriter that was defined during template solving
     *   - c: the constructor template to finalize
     * @returns: The delegate value with some template left or fully validated (and thus validated by the function validator)
     * @info: uses the function validator to include the frame generator if the constructor templates are all rewritten
     * */
    fn finalizeTemplateCtorCall (self, dmut context : &Validator, loc : &Word, r : &TemplateRewriter, c : &CtorDelegateTemplateValue)-> &Value
        throws &ErrorMsg
    {
        let dmut val = alias context:.getTemplateDeclarator ():.declare (alias context, loc, r, c.getPrototype ());
        match ref val {
            dmut func : &ConstructorSymbol => {
                let clRef = c.getPrototype ().getClassSymbol ().getClassRef ().asOf!{&ClassRefType} ();
                let proto = context:.getFunctionValidator ().validateCtorPrototype (alias context, alias func, clRef);
                return CtorDelegateValue::new (loc, c.getInstanceType (), proto.asOf!{&CtorPrototypeValue} (), instance-> c.getInstance ());
            }
            z : &TemplateSymbol => {
                let meth = TemplateRefCtorValue::new (z.getLoc (), c.getPrototype ().getClassSymbol (), z);
                return CtorDelegateTemplateValue::new (loc, c.getInstanceType (), meth, instance-> c.getInstance ());
            }
            _ => __pragma!panic ();
        }
    }

    /**
     * Finalize the declaration and validation of a method template that was called using template call syntax
     * @params:
     *   - context: the context of the validation
     *   - loc: the location of the template call
     *   - r: the template rewriter that was defined during template solving
     *   - m: the method template to finalize
     * @returns: The delegate value with some template left or fully validated (and thus validated by the function validator)
     * @info: uses the function validator to include the frame generator if the method templates are all rewritten
     * */
    fn finalizeTemplateMethodCall (self, dmut context : &Validator, loc : &Word, r : &TemplateRewriter, m : &MethodDelegateTemplateValue)-> &Value
        throws &ErrorMsg
    {
        let dmut val = alias context:.getTemplateDeclarator ():.declare (alias context, loc, r, m.getPrototype ());
        match ref val {
            dmut func : &FunctionSymbol => {
                let clRef = m.getPrototype ().getClassSymbol ().getClassRef ().asOf!{&ClassRefType} ();
                let proto = context:.getFunctionValidator ().validateMethodPrototype (alias context, alias func, clRef);
                return MethodDelegateValue::new (loc, proto.asOf!{&MethodPrototypeValue} (), closure-> m.getClosure (), direct-> true, vtableIndex-> 0us, isStruct-> m.isStruct ());
            }
            z : &TemplateSymbol => {
                let meth = TemplateRefMethodValue::new (z.getLoc (), m.getPrototype ().getClassSymbol (), z);
                return MethodDelegateTemplateValue::new (loc, meth, m.getClosure (), isStruct-> m.isStruct ());
            }
            _ => __pragma!panic ();
        }
    }



    /**
     * Validate a template checker expression
     * @params: 
     *   - context: the context of the validation
     *   - t: the template checker to validate
     * @returns: the validated value
     */
    fn validateTemplateChecker (self, dmut context : &Validator, t : &TemplateCheckerExpr)-> &Value
        throws &ErrorMsg
    {        
        let list = context:.validateTemplateArgumentList (t.getParameters ());// validate the arguments passed to the checker
        
        {
            let rewriter = context:.getTemplateSolver ().validateFromTemplateChecker (alias context, t.getLoc (), t.getRules (), list); // use the template solver to perform a specialization
            let syntTmp = rewriter.replaceSyntaxTempl (t.getRules ()); // use the rewritter to remove set template specialization, and keep only those without value/type association
            if (syntTmp.len == 0us) { // the template specialization passed, and there is no template left in the checker
                return BoolValue::new (t.getLoc (), isTrue-> true); // Then the expression is evaluated to "true"
            } 
        } catch { // every error of template specialization are caught, they just mean that the expression is evaluated to "false"
            _ => {}
        }

        BoolValue::new (t.getLoc (), isTrue-> false)
    }

}
