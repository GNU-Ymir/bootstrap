mod ymirc::semantic::validator::value;

import ymirc::semantic::validator::visitor;
import ymirc::semantic::validator::errors;
import ymirc::syntax::declaration::protection;
import ymirc::syntax::expression::_;
import ymirc::syntax::declaration::_;
import ymirc::syntax::keys;
import ymirc::semantic::symbol::_;
import ymirc::semantic::validator::template::_;
import ymirc::semantic::declarator::visitor;


import ymirc::semantic::generator::_;
import ymirc::global::core_;
import ymirc::errors::_;
import ymirc::utils::format;
import ymirc::lexing::word;
import ymirc::lexing::tokens;

import std::collection::vec;
import std::collection::map;
import std::collection::set;
import std::io;
import std::time::_;

/**
 * The value validator is the class responsible for value expression validation
 */
pub class ValueValidator {

    /**
     * Create a new empty validator
     */
    pub self () {}


    /**
     * Validate an expression assuming its a value
     * @params: 
     *    - context: the context of the validation
     *    - value: the expression to validate
     * @throws: &ErrorMsg, if the expression is not valid
     * @returns: a generator containing the validated value
     */
    pub fn validate (self, dmut context : &Validator, value : &Expression, canBeRef : bool = false)-> &Value
        throws &ErrorMsg
    {
        match value {
            b : &BlockExpr           => return self.validateBlock (alias context, b);
            l : &LiteralExpr         => return self.validateLiteral (alias context, l);
            o : &OperatorExpr        => return self.validateOperator (alias context, o);
            v : &VarDeclExpr         => return self.validateVarDecl (alias context, v);
            s : &SetExpr             => return self.validateSet (alias context, s);
            d : &DecoratedExpr       => return self.validateDecoExpr (alias context, d, canValidateRef-> canBeRef);
            c : &ConditionalExpr     => return self.validateConditional (alias context, c);
            f : &ForLoopExpr         => return self.validateForLoop (alias context, f);
            w : &WhileLoopExpr       => return self.validateWhileLoop (alias context, w);
            b : &BreakExpr           => return self.validateBreak (alias context, b);
            r : &ReturnExpr          => return self.validateReturn (alias context, r);
            t : &ThrowExpr           => return self.validateThrow (alias context, t);
            m : &MatcherExpr         => return self.validateMatcher (alias context, m);
            m : &MacroCallExpr       => return self.validateMacroCall (alias context, m);
            p : &PragmaExpr          => return self.validatePragma (alias context, p);
            a : &AssertExpr          => return self.validateAssert (alias context, a);
            t : &TryExpr             => return self.validateTry (alias context, t);
            w : &DisposeScopeExpr    => return self.validateWith (alias context, w);
            a : &AtomicExpr          => return self.validateAtomic (alias context, a);
            c : &CastExpr            => return self.validateCast (alias context, c);
            l : &ListExpr            => return self.validateList (alias context, l);
            i : &IntrinsicExpr       => return self.validateIntrinsics (alias context, i);
            n : &NamedExpr           => return self.validateNamedExpr (alias context, n);
            t : &TemplateCallExpr    => return self.validateTemplateCall (alias context, t);
            t : &TemplateCheckerExpr => return self.validateTemplateChecker (alias context, t);
            l : &LambdaValueExpr     => return self.validateLambda (alias context, l);
            d : &DestructVarDeclExpr => return self.validateDestructVarDecl (alias context, d);
            e : &EmptyExpression     => return UnitValue::new (loc-> e.getLoc ());
            w : &ValueWrapperExpr    => return w.getValue ();
            s : &SliceAllocatorExpr  => return self.validateSliceAllocator (alias context, s);
            s : &SliceForAllocatorExpr => return self.validateSliceFor (alias context, s);
            u : &UnsafeExpr          => return self.validateUnsafe (alias context, u);
            t : &TypeWrapperExpr => {
                throw ErrorMsg::fatal (t.getLoc (), ValidateErrorMessage::USE_AS_VALUE);
            }
            x : _ => {
                println (x::typeinfo.name);
                __pragma!panic ();
            }            
        }
    }


    /**
     * ================================================================================
     * ================================================================================
     * =========================            BLOCK             =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a block expression
     * @params: 
     *   - context: the context of the validation
     *   - b: the block to validate
     * @returns: the validated value
     */
    fn validateBlock (self, dmut context : &Validator, b : &BlockExpr)-> &Value
        throws &ErrorMsg
    {
        let dmut errors = Vec!{&ErrorMsg}::new ();

        context:.enterBlock ();
        
        let (values, type, rtLoc, brLoc, _) = {
            // A block can have local symbol definitions (such as import, struct, etc.), we need to validate them
            let dmut module = self.validateInnerModule (alias context, b.getModule (), alias errors);
            
            let value = match module {                
                EmptySymbol () => { // No local symbol to access
                    self.validateInnerBlock (alias context, b.getExpressions (), alias errors)
                }
                _ => {
                    {
                        // There are some local symbols, we need to have access to them in the current block
                        context:.pushReferent (alias module);
                        self.validateInnerBlock (alias context, b.getExpressions (), alias errors)
                    } exit {
                        context:.popReferent (); // We go back to the previous symbol table, all local symbol are no longer accessible
                    }
                }
            };

            value
        } exit {
        
            {
                // No need to warn unused if there were errors in the validation of the block (it will complicate the error handling)
                context:.quitBlock (warnUnused-> errors.len () == 0us);
            } catch { err : &ErrorMsg => errors:.push (err); }
        }

        let retBlock = BlockValue::new (b.getLoc (), type, values, breakLoc-> brLoc, returnLoc-> rtLoc);        
        let (_, _, _) = if (errors.len () != 0us) {
            self.validateCatcher (alias context, b.getCatcher (), type, retBlock.getThrowers (), alias errors)
        } else {
            let a : &Value = UNIT_VALUE;
            (a, a, a)
        }

        // let (onExit, onSuccess, onFailure) = self.validateScopes ();
        
        if (errors.len () != 0us) {
            throw ErrorMsg::list (errors[]);
        }
        
        
        retBlock
    }


    /**
     * Validate the local module declared inside a block
     * @params: 
     *    - context: the context of the validation
     *    - m: the module declared in the block
     * @returns:
     *    - errors: the errors that occured when validating    
     *    - the symbol that was validated (or EmptySymbol, if the validation failed)
     */
    fn validateInnerModule (self, dmut context : &Validator, m : &Declaration, dmut errors : &Vec!{&ErrorMsg})-> dmut &Symbol {
        let dmut modSym = {   // We get the declarator of the context, maybe there are imports here, and maybe they are already imported, so we just have to make a reference
            let start = instant::now ();
            let dmut modSym = ModuleSymbol::new (Word::new (Keys::UNDER, m.getLoc ()), importLoc-> EOF_WORD, ""s8, protection-> Protection::PRIVATE);
            modSym:.setReferent (alias context:.getReferent ());

            context:.getDeclarator ():.declare (m, alias modSym);
            context:.getDeclarator ():.finalizeDeclaration (alias modSym);

            let end = instant::now ();
            context:.removeTime (end - start);

            alias modSym
        } catch {
            err : &ErrorMsg => {
                errors:.push (err);
                return EmptySymbol::new ();
            }
        };

        context:.enterForeign (isFnBody-> false, clContext-> context:.getCurrentClassContext ()); // Enter a foreign, but this is not a function, we just want to avoid polluting the current context
        
        {
            context:.validate (alias modSym);  // Validation of the declared symbols 
        } catch {
            err : &ErrorMsg => {
                errors:.push (err);
                return EmptySymbol::new ();
            }
        } exit {            
            context:.exitForeign ();
        }
        
        // Here we return a leaf that can be accessed only from the current block            
        return alias modSym;     
    }

    /**
     * Validate the content of a block
     * @params: 
     *   - context: the context of the validation
     *   - m: the block to validate
     * @returns:
     *   - errors: the list of errors, if an errors occurs
     *   - .0: the list of values inside the block
     *   - .1: the type of the last value
     *   - .2: the location of a return statement if any (EOF otherwise)
     *   - .3: the location of a break statement if any (EOF otherwise)
     *   - .4: the location of the last value
     */
    fn validateInnerBlock (self, dmut context : &Validator, exprs : [&Expression], dmut errors : &Vec!{&ErrorMsg})-> ([&Value], &Type, &Word, &Word, &Word) {
        let mut returner = false, mut breaker = false; // Blocks can break loops or return functions
        // A returned block is a block in which every path leads to a return statement, and a break statement is breaker
        
        let mut rtLoc = EOF_WORD, mut brLoc = EOF_WORD, mut valueLoc = EOF_WORD; // The location of the return, break, and value for error handling
        let mut type : &Type = VoidType::new (EOF_WORD); // By default a block has no value, thus its type is void
        let dmut values = Vec!{&Value}::new (); // List of values in the block
        for i in 0us .. exprs.len {
            {
                // There is another expression to validate, but there is no way that the program arrives at that point (cf. breaker or returner)
                if ((breaker || returner) && !exprs [i].isOf!{&UnitExpr}()) throw ErrorMsg::fatal (exprs [i].getLoc (), ValidateErrorMessage::UNREACHBLE_STATEMENT);
                
                let val = context:.validateValue (exprs [i]);
                context.verifyCompleteTypeWithValue (exprs [i].getLoc (), val.getType (), val, construct-> false);

                if (val.isReturner ()) { returner = true; rtLoc = val.getReturnerLoc (); }
                if (val.isBreaker ())  { breaker = true; rtLoc = val.getBreakerLoc (); }

                // If the value is implicitely aliased, then we transform it into a immutable value
                type = if (context.needExplicitAlias (val.getType (), val)) {
                    val.getType ().clone (0u32)
                } else {
                    val.getType ()
                };
                
                valueLoc = val.getLoc (); // store the location of the value of the block (if it is the last value, it will be definitely stored)
                if (i == exprs.len - 1us || !val.isOf!{&UnitValue} ()) { // ignore unit values, if there created by otherthings than UnitExpr
                    values:.push (val);  // push the value in the list of value of the block
                }
            } catch {
                err : &ErrorMsg => { errors:.push (err); }
            }            
        }

        match type { 
            VoidType () => {} 
            _ => { // Verify implicit aliases and stuff
                context:.verifyMemoryOwner (valueLoc, type, values[][$ - 1us], byReference-> false);
            } catch {
                err : &ErrorMsg => { errors:.push (err); }
            }
        }

        (values[], type, rtLoc, brLoc, valueLoc) 
    }


    /**
     * Validate the catcher part of a block
     * @params: 
     *   - context: the context of the validation
     *   - catcher: the catcher to validate
     *   - type: the type of the block that is catched
     *   - throwers: the list of exception thrown by the block
     * @returns: 
     *   - errors: if errors occured
     *   - .0: the variable that is catched
     *   - .1: the type info of the catch var
     *   - .2: the content of the catcher
     */
    fn validateCatcher (self, dmut context : &Validator, catcher : &Expression, type : &Type, throwers : [(&Word, &Type)], dmut errors : &Vec!{&ErrorMsg})-> (&Value, &Value, &Value) {
        match catcher {
            EmptyExpression () => {
                let a : &Value = UNIT_VALUE;
                return (a, a, a);
            }
            _ => {
                if (throwers.len == 0us) errors:.push (ErrorMsg::fatal (catcher.getLoc (), ValidateErrorMessage::NOTHING_TO_CATCH));
            }
        }
        
        context;
        catcher;
        errors;
        type;
        // Need pattern matching
        __pragma!panic ();
    }


    /**
     * ================================================================================
     * ================================================================================
     * ==========================           UNSAFE            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate an unsafe expression
     * @params:
     *    - context: the context of the validation
     *    - u: the unsafe expression to validate
     * @returns: the validated value
     * */
    fn validateUnsafe (self, dmut context : &Validator, u : &UnsafeExpr)-> &Value
        throws &ErrorMsg
    {
        let loc = context.getUnsafeContextLoc ();
        if (!loc.isEof ()) throw ErrorMsg::fatal (u.getLoc (), ValidateErrorMessage::MULTIPLE_UNSAFE, notes-> [ErrorMsg::note (loc, ""s8)]);

        let mut error = ((&ErrorMsg)?)::__err__;
        let value = {
            context:.enterUnsafeContext (u.getLoc ());
            context:.validateValue (u.getValue ())
        } exit {
            {
                context:.exitUnsafeContext ();
            } catch {
                err : &ErrorMsg => { error = err?; }
            }
        }

        match error {
            Ok (err : _) => throw err;
        }

        value
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================           LITERAL            =========================
     * ================================================================================
     * ================================================================================
     */
    
    
    /**
     * Validate a literal expression
     * @params: 
     *   - context: the context of the validation
     *   - l: the literal to validate
     *   - forceType: the type to force (if different from NONE_TYPE), only applicable in some case (e.g. StringExpr)
     * @returns: the validated value
     */
    fn validateLiteral (self, dmut context : &Validator, l : &LiteralExpr)-> &Value
        throws &ErrorMsg
    {
        return context:.getLiteralValidator ().validate (alias context, l);
    }

    /**
     * Validate a list expression
     * @params: 
     *   - context: the context of the validation
     *   - l: the list expression to validate
     *   - type: the type to force (if different to NONE_TYPE) and only applicable to ListArray 
     * @returns: the validated value
     */
    fn validateList (self, dmut context : &Validator, l : &ListExpr)-> &Value
        throws &ErrorMsg
    {
        if (l.isArray ()) {
            if (context.isDynamic (l)) {
                self.validateListSlice (alias context, l)
            } else {
                self.validateListStaticArray (alias context, l)
            }
        } else {
            self.validateListTuple (alias context, l)
        }
    }

    /**
     * Validate a list expression containing an array literal
     * @params: 
     *   - context: the context of the validation
     *   - l: the list to validate
     * @returns: the validated value
     */
    fn validateListStaticArray (self, dmut context : &Validator, l : &ListExpr)-> &Value
        throws &ErrorMsg
    {
        let dmut parameters = Vec!{&Value}::new ();
        let mut inner : &Type = NoneType::new (l.getLoc ());

        for it in l.getParameters () {
            let val = context:.validateValue (it);
            match val {
                e : &ExpandValue => {
                    for g_it in e.getInnerValues () {
                        inner = self.addArrayType (alias context, g_it, alias parameters, inner);
                    }
                }
                g_it : _ => {
                    inner = self.addArrayType (alias context, g_it, alias parameters, inner);
                }
            }
        }

        // If there is no value in the slice (i.e. []), its values is [void]
        if (parameters.len () == 0us) inner = VoidType::new (l.getLoc ());
        if (!inner.isMutable ()) {
            inner = inner.clone (1u32);
        }

        let arrType = ArrayType::new (l.getLoc (), inner, parameters.len (), isMutable-> true);
        ArrayValue::new (l.getLoc (), arrType, parameters [])
    }

    /**
     * Validate a list expression containing a slice literal (same as array literal but within a copy or dcopy context)
     * @params:
     *    - context: the context of the validation
     *    - l: the list to validate
     * @returns: the validated value
     * */
    fn validateListSlice (self, dmut context : &Validator, l : &ListExpr)-> &Value
        throws &ErrorMsg
    {
        let content = self.validateListStaticArray (alias context, l);
        let arrType = content.getType ().asOf!{&ArrayType} ();
        let inner = arrType.getInners ()[0];

        let addr = AddressValue::new (l.getLoc (), PointerType::new (l.getLoc (), inner), content);
        let slcType = SliceType::new (l.getLoc (), inner, isMutable-> true);

        let ctor = SliceCtorValue::new (l.getLoc (), slcType, addr, makeIntValue (l.getLoc (), arrType.getLen ()));

        match context.getDynamicExpr () {
            i : &IntrinsicExpr => {
                return CopierValue::new (i.getLoc (), slcType, ctor, isDeep-> i.getType () == IntrinsicKeys::DCOPY);
            }
            _ => __pragma!panic ();
        }

    }

    /**
     * Add a parameter to an list of array parameters
     * @params: 
     *   - context: the context of the validation
     *   - val: the value to add
     *   - parameters: the list of parameters inside the array literal
     *   - innerType: the current type of the inner values of the array
     */
    pub fn addArrayType (self, dmut context : &Validator, val : &Value, dmut parameters : &Vec!{&Value}, innerType : &Type)-> &Type
        throws &ErrorMsg
    {
        if (val.getType ().isOf!{&NoneType} () || val.getType ().isOf!{&VoidType} ()) {
            throw ErrorMsg::fatal (val.getLoc (), ValidateErrorMessage::VOID_VALUE);
        }

        let (t, v) = context:.inferTypeBranchingWithValue (innerType.getLoc (), innerType, val);
        parameters:.push (v);
        t
    }

    /**
     * Validate a list expression containing a tuple literal
     * @params: 
     *   - context: the context of the validation
     *   - l: the list to validate
     * @returns: the validated value
     */
    fn validateListTuple (self, dmut context : &Validator, l : &ListExpr)-> &Value
        throws &ErrorMsg
    {
        let dmut parameters = Vec!{&Value}::new ();
        let dmut types = Vec!{&Type}::new ();
        for it in l.getParameters () {
            let val = context:.validateValue (it);
            match val {
                e : &ExpandValue => {
                    for g_it in e.getInnerValues () {
                        self.addTupleType (alias context, g_it, alias parameters, alias types);
                    }
                }
                g_it : _ => {
                    self.addTupleType (alias context, g_it, alias parameters, alias types);
                }
            }            
        }
        
        let type = TupleType::new (l.getLoc (), types[], isMutable-> true);
        TupleValue::new (l.getLoc (), type, parameters[])
    }

    /**
     * Add an element at the end of a list of tuple parameters and types
     * @params: 
     *   - context: the context of the validation
     *   - val: the value to add
     *   - params: the list of parameters
     *   - types: the list of types
     */
    fn addTupleType (self, dmut context : &Validator, val : &Value, dmut params : &Vec!{&Value}, dmut types : &Vec!{&Type})
        throws &ErrorMsg
    {
        if (val.getType ().isOf!{&NoneType} () || val.getType ().isOf!{&VoidType} ()) {
            throw ErrorMsg::fatal (val.getLoc (), ValidateErrorMessage::VOID_VALUE);
        }

        params:.push (val);
        
        {
            let type = val.getType ();
            context:.verifyMemoryOwner (val.getLoc (), type, val, byReference-> false);
            types:.push (type);
        } catch {
            _ => {
                let type = val.getType ().clone (0u32);
                context:.verifyMemoryOwner (val.getLoc (), type, val, byReference-> false);
                types:.push (type);
            }
        }
    }
    
    /**
     * Validate a lambda value expression
     * @params: 
     *   - context: the context of the validation
     *   - l: the lambda value
     * @returns: the validated value
     */
    fn validateLambda (self, dmut context : &Validator, l : &LambdaValueExpr)-> &Value
        throws &ErrorMsg
    {
        context:.getLambdaValidator ():.validate (alias context, l)
    }

    /**
     * Validate a slice allocator expression
     * @params:
     *     - context: the context of the validation
     *     - alloc: the allocation to validate
     *  @throws: &ErrorMsg: if the expression is not valid
     *  @returns: the value containing the allocation
     */
    fn validateSliceAllocator (self, dmut context : &Validator, alloc : &SliceAllocatorExpr)-> &Value
        throws &ErrorMsg
    {
        if (context.isDynamic (alloc)) {
            self.validateDynamicSliceAllocator (alias context, alloc)
        } else {
            self.validateStaticSliceAllocator (alias context, alloc)
        }
    }

    /**
     * Validate a slice allocator whose size might not be cte
     * @params:
     *    - context: the context of the validation
     *    - allooc: the allocator to validate
     * */
    fn validateDynamicSliceAllocator (self, dmut context : &Validator, alloc : &SliceAllocatorExpr)-> &Value
        throws &ErrorMsg
    {
        let size = context:.validateValue (alloc.getSize ());
        match size.getType () {
            IntType () => {}
            _ => {
                let iType = IntType::new (alloc.getSize ().getLoc (), size-> 0u16, signed-> false);
                throw ErrorMsg::fatal (alloc.getSize ().getLoc (),
                                       format (ValidateErrorMessage::INCOMPATIBLE_TYPE,
                                               size.getType (), iType));
            }
        };

        let value = context:.validateValue (alloc.getValue ());
        let mut innerType = value.getType ();
        if (!innerType.isMutable ()) { // [i32] => mut [mut i32]
            innerType = innerType.clone (1u32);
        }

        context.verifyCompleteType (alloc.getValue ().getLoc (), innerType, false);
        if (innerType.isOf!{&NoneType} () || innerType.isOf!{&VoidType} ()) {
            throw ErrorMsg::fatal (alloc.getValue ().getLoc (), format (ValidateErrorMessage::EMPTY_ARRAY_INNER, innerType));
        }

        if (size.isOf!{&IntValue} ()) {
            let tabSize = {
                size.asOf!{&IntValue} ().getValue ().to!usize ()
            } catch {
                _ => throw ErrorMsg::fatal (alloc.getSize ().getLoc (), format (ValidateErrorMessage::OVERFLOW_CAPACITY, IntType::new (alloc.getSize ().getLoc (), size-> 0u16, signed-> false), size, u64::max));
            };

            if (tabSize <= 1024us) { // 1MB, then alloc from copy is faster (memset is slower than memcpy)
                let valSize = makeIntValue (alloc.getSize ().getLoc (), tabSize);
                let type = ArrayType::new (alloc.getLoc (), innerType, tabSize, isMutable-> true);
                let slcType = SliceType::new (alloc.getLoc (), innerType, isMutable-> true);
                let content = AddressValue::new (alloc.getLoc (), PointerType::new (alloc.getLoc (), innerType),
                                                 ArrayAllocValue::stat (alloc.getLoc (), type, value, valSize));

                let ctor = SliceCtorValue::new (alloc.getLoc (), slcType, content, valSize);
                match context.getDynamicExpr () { // We can make a dynamic alloc only if we are inside a copy
                    i : &IntrinsicExpr => {
                        return CopierValue::new (i.getLoc (), slcType, ctor, isDeep-> i.getType () == IntrinsicKeys::DCOPY);
                    }
                    _ => __pragma!panic (); // thus should not be there
                }
            }
        }

        // Size is unknown, we cannot make an array in the stack to copy from
        let type = SliceType::new (alloc.getLoc (), innerType, isMutable-> true);
        ArrayAllocValue::dyn (alloc.getLoc (), type, value, size)
    }


    /**
     * Validate an array allocator, thus whose size is cte
     * @params:
     *    - context: the context of the validaton
     *    - alloc: the allocator to validate
     * */
    fn validateStaticSliceAllocator (self, dmut context : &Validator, alloc : &SliceAllocatorExpr)-> &Value
        throws &ErrorMsg
    {
        let size = context:.getCompileTimeInterpreter ().computeInt (context:.validateValue (alloc.getSize ()), signed-> false);
        let value = context:.validateValue (alloc.getValue ());
        let mut innerType = value.getType ();
        if (!innerType.isMutable ()) { // [i32 ; N] => mut [mut i32 ; N]
            innerType = innerType.clone (1u32);
        }

        context.verifyCompleteType (alloc.getValue ().getLoc (), innerType, false);
        if (innerType.isOf!{&NoneType} () || innerType.isOf!{&VoidType} ()) {
            throw ErrorMsg::fatal (alloc.getValue ().getLoc (), format (ValidateErrorMessage::EMPTY_ARRAY_INNER, innerType));
        }

        let tabSize = {
            size.to!usize ()
        } catch {
            _ => throw ErrorMsg::fatal (alloc.getSize ().getLoc (), format (ValidateErrorMessage::OVERFLOW_CAPACITY, IntType::new (alloc.getSize ().getLoc (), size-> 0u16, signed-> false), size, u64::max));
        };

        if (tabSize > 1048576us) { // 1MB
            throw ErrorMsg::fatal (alloc.getSize ().getLoc (), format (ValidateErrorMessage::OVERFLOW_CAPACITY_ARRAY, tabSize, 1048576us));
        }

        let valSize = makeIntValue (alloc.getSize ().getLoc (), tabSize);
        let type = ArrayType::new (alloc.getLoc (), innerType, tabSize, isMutable-> true);
        ArrayAllocValue::stat (alloc.getLoc (), type, value, valSize)
    }

    /**
     *
     * Validate a slice allocation using a for loop
     * @params:
     *    - context: the context of the validation
     *    - alloc: the allocator to validate
     * */
    fn validateSliceFor (self, dmut context : &Validator, alloc : &SliceForAllocatorExpr)-> &Value
        throws &ErrorMsg
    {
        context:.getForLoopValidator ():.validateListComprehension (alias context, alloc)
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================         DESTUCT DECL         =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a destructor decl of variables
     * @params: 
     *    - context: the context of the validation
     *    - d: the destructor decl
     * @returns: the set of decl values
     * @throws: 
     *    - &ErrorMsg: if there is an error during the validation
     */
    fn validateDestructVarDecl (self, dmut context : &Validator, d : &DestructVarDeclExpr)-> &Value
        throws &ErrorMsg
    {
        let value = context:.validateValue (d.getValue ());
        context.verifyCompleteTypeWithValue (d.getValue ().getLoc (), value.getType (), value, construct-> false);

        let intrValue = context:.validateValue (IntrinsicExpr::new (value.getLoc (), IntrinsicKeys::EXPAND, ValueWrapperExpr::new (value.getLoc (), value)));
        match intrValue {
            ev : &ExpandValue => { // it was probably a tuple, or something expandable
                return self.validateDestructDeclExpand (alias context, d, ev);
            }
            _ => // it was not expandable, so it is just a single declaration
                return self.validateDestructDeclSingle (alias context, d, value);
        }
    }
    
    /**
     * Validate a destruct decl for an expand value
     * @params: 
     *    - context: the context of the validation
     *    - d: the destructor declaration
     *    - value: the expand value to deconstruct
     *    - et: the type of the expand value to deconstruct
     */
    fn validateDestructDeclExpand (self, dmut context : &Validator, d : &DestructVarDeclExpr, value : &ExpandValue)-> &Value
        throws &ErrorMsg
    {
        // if the arity mismatch then throw an error
        if ((d.isVariadic () && d.getParameters ().len > value.getValues ().len) ||
            (!d.isVariadic () && d.getParameters ().len != value.getValues ().len)) {
            throw ErrorMsg::fatal (d.getLoc (), format (ValidateErrorMessage::TUPLE_ARITY_OVERFLOW, d.getParameters ().len, value.getValues ().len));            
        }

        let dmut values = Vec!{&Value}::new ();

        // For each variable declaration of the destruct decl
        for i in 0us .. d.getParameters ().len {
            let assocValue : &Value = if (i != d.getParameters ().len - 1us || !d.isVariadic ()) { // get the current value
                value.getValues()[i]
            } else { // or when it is an expand of the rest values, create a tuple value containing the list of values                
                let dmut rest = Vec!{&Value}::new ();
                let dmut tupleTypes = Vec!{&Type}::new ();
                
                for j in i .. value.getValues ().len {
                    rest:.push (value.getValues()[j]);
                    tupleTypes:.push (value.getValues()[j].getType ());
                }

                let tupleType = TupleType::new (value.getLoc (), tupleTypes[], isMutable-> true);
                cast!{&Value} (TupleValue::new (value.getLoc (), tupleType, rest[]))
            }
            
            match d.getParameters ()[i] {
                vDecl : &VarDeclExpr => { // validate the current variable declaration
                    let aux = VarDeclExpr::new (vDecl.getLoc (), vDecl.getName (), ValueWrapperExpr::new (vDecl.getLoc (), assocValue), vDecl.getType (), decos-> vDecl.getDecos ());
                    
                    values:.push (self.validateVarDecl (alias context, aux)); // using the classical variable declaration for code factorization
                }
                _ => __pragma!panic (); // destruct decl is malformed
            }
        }

        // return the list of variable declaration
        return BlockValue::new (d.getLoc (), VoidType::new (d.getLoc ()), values[], isSet-> true);
    }

    
    /**
     * Validate a destructor decl where right operand is neither a tuple nor an expand value
     * @params: 
     *   - context: the context of the validation
     *   - d: the destructor declaration
     *   - value: the value to put as the default value of the destructor decl
     * @returns: the declaration value
     * @throws:
     *   - &ErrorMsg: if there is an error during the validaton
     */
    fn validateDestructDeclSingle (self, dmut context : &Validator, d : &DestructVarDeclExpr, value : &Value)-> &Value
        throws &ErrorMsg
    {
        // When using the dtor call syntax on single values, then we need to have one decl only
        if (d.getParameters ().len != 1us) {
            throw ErrorMsg::fatal (d.getLoc (), format (ValidateErrorMessage::TUPLE_ARITY_OVERFLOW, d.getParameters ().len, 1us));                    
        }

        match d.getParameters ()[0us] {
            v : &VarDeclExpr => { // it contains a var decl
                let aux = VarDeclExpr::new (v.getLoc (), v.getName (), ValueWrapperExpr::new (v.getLoc (), value), v.getType (), decos-> v.getDecos ());

                // We just rewrite the destruct var decl into a simple var decl
                return self.validateVarDecl (alias context, aux, needInitValue-> true);
            }
            _ => __pragma!panic (); // it is malformed
        }        
    }
    
    
    /**
     * ================================================================================
     * ================================================================================
     * =========================          OPERATORS           =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate an operator expression
     * @params: 
     *   - context: the context of the validation
     *   - o: the operator to validate
     * @returns: the validated value
     */
    fn validateOperator (self, dmut context : &Validator, o : &OperatorExpr)-> &Value
        throws &ErrorMsg
    {
        match o {
            b : &BinaryExpr => return context:.getBinOpValidator ().validateValue (alias context, b);
            m : &MultOperatorExpr => {
                match m.getLoc () {
                    Tokens::LPAR => {
                        return context:.getCallOpValidator ().validate (alias context, m);
                    }
                    _ => {
                        return context:.getIndexOpValidator ().validate (alias context, m);
                    }
                }
            }
            u : &UnaryExpr => return context:.getUnOpValidator ().validate (alias context, u);
            p : &PathExpr =>  return context:.getBinOpValidator ().validateModuleOperation (alias context, p);
            _ => {
                println ("Unknown OP : ", o::typeinfo.name);
                __pragma!panic ();
            }
        }
    }
    
    /**
     * ================================================================================
     * ================================================================================
     * =========================           VAR_DECL           =========================
     * ================================================================================
     * ================================================================================
     */
    
    /**
     * Validate a var declaration expression
     * @params: 
     *   - context: the context of the validation
    *    - v: the var declaration to validate
     * @returns: the validated value
     */
    pub fn validateVarDecl (self, dmut context : &Validator, v : &VarDeclExpr, needInitValue : bool = true)-> &Value
        throws &ErrorMsg
    {

        let dmut errors = Vec!{&ErrorMsg}::new ();
        if (v.getLoc () != Keys::UNDER) context:.verifyShadow (v.getLoc ());
        let isPure = context.findDecos (v.getDecos (), [Decorators::PURE]);
        let isMutable = context.findDecos (v.getDecos (), [Decorators::MUT, Decorators::DMUT]);

        // Validate the type of the vardecl => let v : type = ...
        let type : &Type = {
            match v.getType () {
                EmptyExpression () => {
                    cast!{&Type} (NONE_TYPE)
                }
                t_inner : _ => {
                    let (_, t) = context:.validateType (t_inner, decos-> v.getDecos (), canBeRef-> false);
                    if (isPure) t.clone (0u32)
                    else t
                }
            }
        } catch {
            err : &ErrorMsg => { // error when validating the type of the variable, so it has an error type, no matter the value
                errors:.push (err);
                cast!{&Type} (ErrorType::new (v.getLoc ()))
            }
        }

        // validate the value of the vardecl => let v : ... = value
        let val : &Value = {
            match v.getValue () {
                EmptyExpression () => {
                    if (v.getType ().isOf!{&EmptyExpression} ()) {
                        throw ErrorMsg::fatal (v.getLoc (), ValidateErrorMessage::VAR_DECL_WITH_NOTHING);
                    } else if (needInitValue) {
                        throw ErrorMsg::fatal (v.getLoc (), ValidateErrorMessage::VAR_DECL_WITHOUT_VALUE);
                    }

                    cast!{&Value} (UNIT_VALUE)
                }
                v_inner : _ => { context:.validateValue (v_inner.getLoc (), v_inner, type-> type, verif-> false) }
            }
        } catch {
            err : &ErrorMsg => { // error when validating the value of the vardecl
                errors:.push (err);
                cast!{&Value} (UNIT_VALUE)
            }
        }

        {
            if (errors.len () == 0us) {
                // If no type is defined for the variable, we have to set it
                let finalType = if (v.getType ().isOf!{&EmptyExpression} ()) {
                    context:.validateType (TypeWrapperExpr::new (val.getType ().getLoc (), val.getType ()), v.getDecos (), canBeRef-> false)._1
                } else {
                    type
                };

                let finalVal = if (!v.getValue ().isOf!{&EmptyExpression} ()) { // if the value is needed, an error was thrown earlier, and we never enter here
                    let f = context:.verifyCompatibleTypeWithValue (v.getLoc (), finalType, val); // check if the type is compatible with the value
                    context:.verifyMemoryOwner (v.getLoc (), finalType, f, construct-> true, byReference-> false); // checking implicit alias, and other memory stuff
                    f
                } else {
                    val
                };

                if (finalType.isOf!{&NoneType} () || finalType.isOf!{&VoidType} ()) { // a var cannot be void, or none
                    throw ErrorMsg::fatal (v.getLoc (), ValidateErrorMessage::VOID_VAR);
                } // else if (type.isOf!{&TraitRef} ()) // TODO

                let ret = VarDeclValue::new (v.getLoc (), finalType, finalVal, isMutable-> isMutable, isPure-> isPure);
                if (v.getLoc () != Keys::UNDER) context:.insertLocal (v.getLoc ().str (), ret);

                return ret;
            }
        } catch {
            err : &ErrorMsg => { // error when checking for compatibility between the vardecl and the affectation value
                errors:.push (err);
            }
        }

        // at this point, 4 possibilities, type == ErrorType, val = UnitValue, type != val.getType (), or memory error
        //
        let errType = if (v.getType ().isOf!{&EmptyExpression} () && type.isOf!{&NoneType} ()) {
            ErrorType::new (v.getLoc ()) // then error came from value validation
        } else {
            type // error came from elsewhere, maybe type, maybe memory checking
        };

        let ret = VarDeclValue::new (v.getLoc (), errType, UNIT_VALUE, isMutable-> isMutable, isPure-> isPure);
        if (v.getLoc () != Keys::UNDER) context:.insertLocal (v.getLoc ().str (), ret); // we insert the variable to have better errors in the rest of the block validation

        throw ErrorMsg::list (errors[]);
    }
    
    /**
     * Validate a set expression (generally a succession of var decl)
     * @params: 
     *   - context: the context of the validation
     *   - s: the set to validate
     * @returns: the validated value
     */
    fn validateSet (self, dmut context : &Validator, s : &SetExpr)-> &Value
        throws &ErrorMsg
    {
        let dmut errors = Vec!{&ErrorMsg}::new ();
        let (values, type, brLoc, rtLoc, _) = {
            self.validateInnerBlock (alias context, s.getContent (), alias errors)
        };

        let retBlock = BlockValue::new (s.getLoc (), type, values, breakLoc-> brLoc, returnLoc-> rtLoc, isSet-> true);
        
        if (errors.len () != 0us) {
            throw ErrorMsg::list (errors[]);
        }
                
        retBlock
    }    

    /**
     * ================================================================================
     * ================================================================================
     * =========================          DECORATED           =========================
     * ================================================================================
     * ================================================================================
     */


    /**
     * Validate a decorated expression
     * @params: 
     *   - context: the context of the validation
     *   - d: the decorated expression to validate
     * @returns: the validated value
     * @throws:
     *   - &ErrorMsg: if the validation fails
     */    
    fn validateDecoExpr (self, dmut context : &Validator, d : &DecoratedExpr, canValidateRef : bool)-> &Value
        throws &ErrorMsg
    {
        let decos = d.getDecorators ();
        let dmut found = HashMap!{Decorators, &Word}::new ();
        let dmut antiAffs = hmap #[
            Decorators::CTE => hset #{Decorators::CONST, Decorators::REF},
            Decorators::CONST  => hset #{Decorators::PURE},
            Decorators::REF => hset #{Decorators::PURE}
        ];

        for i in decos {
            match found.find (i.deco) {
                Ok (l : _) => throw ErrorMsg::warn (i.loc, format (ValidateErrorMessage::MULTIPLE_DECORATORS, i.deco), notes-> [ErrorMsg::note (l, ""s8)]);
            }
            
            match antiAffs.find (i.deco) {
                Ok (an : _) => {
                    for j in an {
                        match found.find (j) {
                            Ok (l : _) => throw ErrorMsg::fatal (i.loc, format (ValidateErrorMessage::CONFLIT_DECORATORS, j, i.deco), notes-> [ErrorMsg::note (l, ""s8)]);
                        }
                    }
                }
                Err () => {
                    throw ErrorMsg::fatal (i.loc, format (ValidateErrorMessage::UNDEF_DECORATOR_TYPE, i.deco));
                }
            }
                
            found:.insert (i.deco, i.loc);        
        }


        if (Decorators::CTE in found) {
            return self.validateCteExpr (alias context, d.getContent ());            
        }

        let mut ret = context:.validateValue (d.getContent ());
        let canBeRef = ret.isLvalue ();
        
        if (Decorators::CONST in found) {
            ret = CastValue::new (d.getLoc (), ret.getType ().clone (0u32), ret);
        }

        if (Decorators::REF in found) {
            if (!canBeRef) throw ErrorMsg::fatal (ret.getLoc (), ValidateErrorMessage::NOT_A_LVALUE,
                                                  notes-> [ErrorMsg::note (d.getLoc (), ""s8)]);

            if (!canValidateRef) {
                throw ErrorMsg::fatal (d.getLoc (), ValidateErrorMessage::UNECESSARY_REFERENCE);
            }
            
            ret = ReferencerValue::new (d.getLoc (), ret.getType (), ret);
        }
       
        ret
    }

    /**
     * Validate an expression that has been marked as "cte"
     * @params: 
     *   - context: the context of the validation
     *   - expr: the expression to validate
     * @returns: the validated expression
     * @throws:
     *   - &ErrorMsg: if the validation fails
     */
    fn validateCteExpr (self, dmut context : &Validator, expr : &Expression)-> &Value
        throws &ErrorMsg
    {
        match expr {
            c : &ConditionalExpr => { // Conditionals have a different treatment for ctes
                return self.validateCteConditionalExpr (alias context, c);
            }
            f : &ForLoopExpr => { // Same for "for" loops
                return self.validateCteForLoopExpr (alias context, f);
            }
            a : &AssertExpr => {
                return self.validateCteAssertExpr (alias context, a);
            }
            _ => { // Otherwise we just try to get the value at compilation time
                let resExpr = context:.validateValue (expr);
                if (!context.getCompileTimeInterpreter ().isCte (resExpr)) {
                    throw ErrorMsg::fatal (resExpr.getLoc (), format (ValidateErrorMessage::UNKNOWN_AT_COMPILE_TIME, resExpr.getType ()));
                }

                return resExpr;
            }
        }
    }

    /**
     * Validate a conditional expression whose test must be evaluated at compilation time
     * @params: 
     *    - context: the context of the validation
     *    - expr: the expression to validate
     * @returns: the result content of the if expression (or its else value if the test did not pass)
     * @throws:
     *     - &ErrorMsg: if the validation fails or the test value cannot be known at compile time
     */
    fn validateCteConditionalExpr (self, dmut context : &Validator, expr : &ConditionalExpr)-> &Value
        throws &ErrorMsg
    {
        let test = context:.validateValue (expr.getTest ()); // First we need to validate the expression of the test of the conditional
        let value = context:.getCompileTimeInterpreter ().computeBool (test); // And try to retreive its real value at compilation time
        if (value) {
            context:.validateValue (expr.getContent ())
        } else { // otherwise only the else part is validated
            context:.validateValue (expr.getElse ())
        }
    }

    /**
     * Validate a for loop that is marked cte
     * @params: 
     *    - context: the context of the validation
     *    - expr: the for loop to validate
     * @returns: the content of the for loop, unrolled at compile time
     * @throws:
     *    - &ErrorMsg: if the for loop cannot be executed at compile time, or there is an error in the validation (iterator, or for loop content)
     */
    fn validateCteForLoopExpr (self, dmut context : &Validator, expr : &ForLoopExpr)-> &Value
        throws &ErrorMsg
    {
        context:.getForLoopValidator ():.validateCteForLoop (alias context, expr)
    }

    /**
     * Validate an assert expression whose test is made at compilation time
     * @params:
     *     - context: the context of the validation
     *     - a: the expression to validate
     * @returns: a unit expr
     * @throws:
     *   - &ErrorMsg: if the assert expression failed to be validated, or is test is false
     * */
    fn validateCteAssertExpr (self, dmut context : &Validator, a : &AssertExpr)-> &Value
        throws &ErrorMsg
    {
        let test = context:.validateValue (a.getTest ());
        let value = context:.getCompileTimeInterpreter ().computeBool (test);
        if (!value) {
            match a.getMessage () {
                EmptyExpression () => {
                    throw ErrorMsg::fatal (a.getLoc (), ValidateErrorMessage::CTE_ASSERT_NO_MSG);
                }
                msg : _ => {
                    let m = context:.validateValue (msg);
                    throw ErrorMsg::fatal (a.getLoc (), format (ValidateErrorMessage::CTE_ASSERT_WITH_MSG, m));
                }
            }
        }

        UNIT_VALUE
    }

    /**
     * Validate an intrinsic expr
     * @params: 
     *   - context: the context of the validation
     *   - i: the intrinsic expression to validate
     * @returns: the validated value
     */
    fn validateIntrinsics (self, dmut context : &Validator, i : &IntrinsicExpr)-> &Value
        throws &ErrorMsg
    {
        match i.getType () {
            IntrinsicKeys::COPY => {
                match i.getContent () {
                    lmbd : &LambdaValueExpr =>
                        return context:.getLambdaValidator ():.validate (alias context, lmbd, isClosure-> true);
                    _ =>
                        return context:.getCopyValidator ().validateCopy (alias context, i);
                }
            }
            IntrinsicKeys::ALIAS => {
                return self.validateAlias (alias context, i);
            }
            IntrinsicKeys::TYPEOF => { // Typeof is necessarily a type (it's in the name)
                throw ErrorMsg::fatal (i.getLoc (), ValidateErrorMessage::USE_AS_VALUE);
            }
            IntrinsicKeys::SIZEOF => {
                return self.validateSizeof (alias context, i);
            }
            IntrinsicKeys::EXPAND => {
                return self.validateExpand (alias context, i);
            }
            IntrinsicKeys::DCOPY => {
                return context:.getCopyValidator ().validateDeepCopy (alias context, i);
            }
        }

        __pragma!panic ();
    }

    /**
     * Validate an alias of a value
     * @params: 
     *    - context: the context of the validation
     *    - i: the intrinsic expression assumed to be an alias
     * @returns: the validated value
     * @throws:
     *    - &ErrorMsg: if the value is not aliasable, or cannot be validated
     */
    fn validateAlias (self, dmut context : &Validator, i : &IntrinsicExpr)-> &Value
        throws &ErrorMsg
    {
        let content = context:.validateValue (i.getContent ());
        if (!content.getType ().isMutable ()) {
            throw ErrorMsg::fatal (i.getLoc (), end-> content.getLoc (), format (ValidateErrorMessage::NOT_A_LVALUE_TYPE, content.getType ()));
        }        
        
        AliaserValue::new (i.getLoc (), content.getType (), content)
    }

    /**
     * Validate a named expression
     * @params: 
     *   - context: the context of the validation
     *   - n: the named expression to validate
     * @returns: the validated value
     */
    fn validateNamedExpr (self, dmut context : &Validator, n : &NamedExpr)-> &Value
        throws &ErrorMsg
    {
        let content = context:.validateValue (n.getContent ());
        NamedValue::new (n.getLoc (), n.getLoc ().str (), content)
    }


    /**
     * Validate the expansion (for a tuple or an array)
     * @params:
     *    - context: the context of the validation
     *    - i: the intrinsic expression to validate
     * @returns: the validated expression
     * */
    fn validateExpand (self, dmut context : &Validator, i : &IntrinsicExpr)-> &Value
        throws &ErrorMsg
    {
        let content = context:.validateValue (i.getContent ());
        match content.getType () {
            t : &TupleType => {
                let dmut values = Vec!{&Value}::new ();
                for it in 0us .. t.getInners ().len {
                    let access = context:.getBinOpValidator ().createTupleFieldAccess (i.getLoc (), t.getInners ()[it].clone (0u32), content, it);
                    values:.push (context.getCompileTimeInterpreter ().reduce (access));
                }

                return ExpandValue::new (i.getLoc (), values[]);
            }
            a : &ArrayType => {
                let dmut values = Vec!{&Value}::new ();
                let ty = a.getInners ()[0].clone (0u32);
                for it in 0us .. a.getLen () {
                    let acccess = context:.getIndexOpValidator ().createArrayAccess (i.getLoc (), ty, content, makeIntValue (i.getLoc (), it));
                    values:.push (context.getCompileTimeInterpreter ().reduce (acccess));
                }

                return ExpandValue::new (i.getLoc (), values[]);
            }
            a : &SliceType => {
                let sizeType = IntType::new (i.getLoc (), size-> 0u16, signed-> false);
                let len = {
                    context:.getCompileTimeInterpreter ().computeInt (StructFieldAccessValue::new (i.getLoc (), sizeType, content, SliceKeys::LEN))
                } catch {
                    _ : &ErrorMsg => {
                        throw ErrorMsg::fatal (i.getLoc (), format (ValidateErrorMessage::UNKNOWN_LENGTH_OF_EXPANSION, content.getType ()));
                    }
                }

                let dmut values = Vec!{&Value}::new ();
                let ty = a.getInners ()[0].clone (0u32);
                for it in 0us .. len.toT!{usize} () {
                    let acccess = SliceAccessValue::new (i.getLoc (), ty, content, makeIntValue (i.getLoc (), it));
                    values:.push (context.getCompileTimeInterpreter ().reduce (acccess));
                }

                return ExpandValue::new (i.getLoc (), values[]);
            }
            _ => return content;            
        }          
    }

    /**
     * Validate a sizeof expression
     * @params:
     *    - context: the context of the validation
     *    - i: the intrinsic expression to validate
     * @returns: the validated expression
     * */
    fn validateSizeof (self, dmut context : &Validator, i : &IntrinsicExpr)-> &Value
        throws &ErrorMsg
    {
        return context:.getSizeofValidator ():.validate (alias context, i);
    }

    
    /**
     * ================================================================================
     * ================================================================================
     * =========================     CONDITION AND LOOPS      =========================
     * ================================================================================
     * ================================================================================
     */
    
    /**
     * Validate a conditional expression
     * @params: 
     *   - context: the context of the validation
     *   - c: the conditional expression to validate
     * @returns: the validated value
     */
    fn validateConditional (self, dmut context : &Validator, c : &ConditionalExpr)-> &Value
        throws &ErrorMsg
    {
        let test = match c.getTest () {
            EmptyExpression () => { cast!{&Value} (UNIT_VALUE) }
            t : _ => {
                let r = context:.validateValue (t);
                if (!r.getType ().isOf!{&BoolType} ()) {
                    throw ErrorMsg::fatal (r.getLoc (), format (ValidateErrorMessage::INCOMPATIBLE_TYPE, r.getType (), BoolType::new (r.getLoc ())));
                }
                r
            }
        };

        let content = context:.validateValue (c.getContent ());
        let mut type = content.getType ();
        {
            context.verifyMemoryOwner (content.getLoc (), type, content, byReference-> false);
        } catch {
            _ : &ErrorMsg => {
                type = type.clone (0u32);
                context.verifyMemoryOwner (content.getLoc (), type, content, byReference-> false);
            }
        }

        match c.getElse () {
            EmptyExpression () => {
                context.verifyCompatibleType (c.getLoc (), content.getLoc (), VoidType::new (c.getLoc ()), type);
                ConditionalValue::new (c.getLoc (), type, test, content, elsev-> UNIT_VALUE)
            }
            e : _ => {
                let else_ = context:.validateValue (e);
                let (inferedType, valueElse) = if (!else_.isBreaker () && !else_.isReturner ()) {
                    {
                        if (content.isBreaker () || content.isReturner ()) {
                            (else_.getType (), else_)
                        } else { // neither are breakers/returners
                            context:.inferTypeBranchingWithValue (else_.getLoc (), type, else_)
                        }
                    } catch {
                        err : &ErrorMsg => throw ErrorMsg::note (c.getLoc (), notes-> [err], ValidateErrorMessage::BRANCHING_VALUE);
                    }
                } else {
                    if (!content.isBreaker () && !content.isReturner ()) {
                        (content.getType (), else_)
                    } else { // both are breakers/returner
                        (cast!{&Type} (VoidType::new (c.getLoc ())), else_)
                    }
                }

                ConditionalValue::new (c.getLoc (), inferedType, test, content, elsev-> valueElse)
            }                
        }
    }

        
    /**
     * Validate a for loop
     * @params: 
     *   - context: the context of the validation
     *   - f: the for loop to validate
     * @returns: the validated value
     */
    fn validateForLoop (self, dmut context : &Validator, f : &ForLoopExpr)-> &Value
        throws &ErrorMsg
    {
        return context:.getForLoopValidator ().validate (alias context, f);
    }

    /**
     * Validate a while loop
     * @params: 
     *   - context: the context of the validation
     *   - w: the while loop to validate
     * @returns: the validated value
     */
    fn validateWhileLoop (self, dmut context : &Validator, w : &WhileLoopExpr)-> &Value
        throws &ErrorMsg
    {
        let test = match w.getTest () {
            EmptyExpression () => { cast!{&Value} (UNIT_VALUE) }
            t : _ => {
                let r = context:.validateValue (t);
                if (!r.getType ().isOf!{&BoolType} ()) {
                    throw ErrorMsg::fatal (r.getLoc (), format (ValidateErrorMessage::INCOMPATIBLE_TYPE, r.getType (), BoolType::new (r.getLoc ())));
                }
                r
            }
        };

        let voidType = VoidType::new (w.getLoc ());
        let content = {
            context:.enterLoop ();
            if (!w.getTest ().isOf!{&EmptyExpression} ())
                context:.setCurrentLoopType (voidType);
            
            context:.validateValue (w.getContent ())
        } catch {
            err : &ErrorMsg => { 
                context:.quitLoop ();
                throw err;
            }
        }

        context:.quitLoop ();        
        context:.verifyCompatibleType (content.getLoc (), w.getLoc (), content.getType (), voidType);

        LoopValue::new (w.getLoc (), voidType, test, content, w.isDo ())
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================    BREAK/RETURN/ and MISC    =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a break expression
     * @params: 
     *   - context: the context of the validation
     *   - b: the break to validate
     * @returns: the validated value
     */
    fn validateBreak (self, dmut context : &Validator, b : &BreakExpr)-> &Value
        throws &ErrorMsg
    {        
        if (!context.isInLoop ()) throw ErrorMsg::fatal (b.getLoc (), ValidateErrorMessage::BREAK_NO_LOOP);

        // Break can have a value in 'loop' loops
        let val = match b.getValue () {
            EmptyExpression () => { cast!{&Value} (UnitValue::new (loc-> b.getLoc ())) }
            v : &Expression => {
                context:.validateValue (v)
            }
        };
        
        let loopType = context.getCurrentLoopType ();

        // There may be multiple break in the loop, we need to verify that the type is compatible
        // It is a branching type (multiple branch with slightly different types)
        let (finLoopType, finLoopValue) = context:.inferTypeBranchingWithValue (b.getLoc (), loopType, val);

        // We need to ensure that there is no mutability issue 
        context.verifyMemoryOwner (b.getLoc (), finLoopType, finLoopValue, byReference-> false);

        // Change the loop type for future break branches (and loop type)
        context:.setCurrentLoopType (finLoopType);

        // Breaks are not really values (you cannot write 'a = break 12;'), they are always typed 'void'
        BreakValue::new (b.getLoc (), finLoopValue)
    }

    /**
     * Validate a return expression
     * @params: 
     *   - context: the context of the validation
     *   - r: the return to validate
     * @returns: the validated value
     */
    fn validateReturn (self, dmut context : &Validator, r : &ReturnExpr)-> &Value
        throws &ErrorMsg
    {
        if (!context.isInFunctionBody ()) throw ErrorMsg::fatal (r.getLoc (), ValidateErrorMessage::RETURN_NO_FUNCTION);

        // The function type is set once at the beginning of a function validation, or by return statement in case of lambda validation
        let fnType = context.getFunctionReturn ();
        
        // Return can be used in void function to quit the function immediately, so without a value
        let val = match r.getValue () {
            EmptyExpression () => { cast!{&Value} (UnitValue::new (loc-> r.getLoc ())) }
            v : &Expression => {
                let res = context:.validateValue (v);
                
                match res.getType () {
                    LambdaType () => {
                        // We have the possibility here - thanks to the return type of the function - to know the types of the prototype of a lambda function
                        if (fnType.isOf!{&FuncPtrType} () || fnType.isOf!{&DelegateType} ()) { // inferLambdaValue manage that test, but we don't want error throwing for anything else than lambda validation error
                            context:.inferLambdaValue (fnType, res)
                        } else { res }
                    }
                    _ => { res }
                }
            }
        };

        
        let resVal = if (context.isInLambdaBody ()) { // The type can be changed by the return statement
            let (finFnType, f) = context:.inferTypeBranchingWithValue (val.getLoc (), fnType, val);
            context:.setFunctionReturn (finFnType);
            f
        } else {
            // Verify that the mutability of the returned values is respected
            let f = context:.verifyCompatibleTypeWithValue (fnType.getLoc (), fnType, val);
            context:.verifyMemoryOwner (fnType.getLoc (), fnType, f, construct-> true, byReference-> false);
            f
        }
        

        // Returns are not really values (you cannot write 'a = return 12;'), they are always typed 'void'
        ReturnValue::new (r.getLoc (), resVal)
    }

    /**
     * Validate a throw expression
     * @params: 
     *   - context: the context of the validation
     *   - t: the throw to validate
     * @returns: the validated value
     */
    fn validateThrow (self, dmut context : &Validator, t : &ThrowExpr)-> &Value
        throws &ErrorMsg
    {
        let inner = context:.validateValue (t.getValue ());
        let type = inner.getType ();

        let exceptionType = context:.getExceptionType (loc-> t.getLoc ());
        context.verifyAncestor (t.getLoc (), exceptionType, type);
        
        ThrowValue::new (t.getLoc (), inner)
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================        PATTERN MATCH         =========================
     * ================================================================================
     * ================================================================================
     */
    
    /**
     * Validate a pattern matcher
     * @params: 
     *   - context: the context of the validation
     *   - m: the pattern matcher to validate
     * @returns: the validated value
     */
    fn validateMatcher (self, dmut context : &Validator, m : &MatcherExpr)-> &Value
        throws &ErrorMsg
    {
        return context:.getMatcherValidator ().validate (alias context, m);
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================            MACRO             =========================
     * ================================================================================
     * ================================================================================
     */


    /**
     * Validate a macro call expression
     * @params: 
     *   - context: the context of the validation
     *   - m: the macro call expression to validate
     * @returns: the validated value
     */
    fn validateMacroCall (self, dmut context : &Validator, m : &MacroCallExpr)-> &Value
        throws &ErrorMsg
    {
        context;
        m;
        __pragma!fake_throw (&ErrorMsg);
        __pragma!panic ();
    }


    /**
     * ================================================================================
     * ================================================================================
     * =========================            PRAGMA            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a pragma expression
     * @params: 
     *   - context: the context of the validation
     *   - p: the pragma expression to validate
     * @returns: the validated value
     */
    fn validatePragma (self, dmut context : &Validator, p : &PragmaExpr)-> &Value
        throws &ErrorMsg
    {
        context:.getPragmaValidator ():.validate (alias context, p)
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================            ASSERT            =========================
     * ================================================================================
     * ================================================================================
     */


    /**
     * Validate an assert expression
     * @params: 
     *   - context: the context of the validation
     *   - p: the assert expression to validate
     *   - isCte: true iif the assertion has to be done CTE
     * @returns: the validated value
     */
    fn validateAssert (self, dmut context : &Validator, a : &AssertExpr, isCte : bool = false)-> &Value
        throws &ErrorMsg
    {
        let test = context:.validateValue (a.getTest ());
        let isFalse = { // if the test is false at compile time, we can assume its a return loc
            !context:.getCompileTimeInterpreter ():.computeBool (test)
        } catch {
            err : _ => {
                if (isCte) throw err;
                false // not cte
            }
        };

        if (!isCte) {
            // if the expression has a message, it is passed to the abort function
            let params = match a.getMessage () {
                EmptyExpression () => { [ValueWrapperExpr::new (test.getLoc (), test), ValueWrapperExpr::new (a.getLoc (), makeStringSliceValue (a.getLoc (), ""s8))] }
                expr : _ => {
                    [ValueWrapperExpr::new (test.getLoc (), test), expr]
                }
            };

            // Create a syntax rewritting to the core function 'core::exception::abort'
            let clVar = context.createSyntaxVarFromPath (a.getLoc (), [CoreNames::CORE_MODULE, CoreNames::EXCEPTION_MODULE, CoreNames::ASSERT_FUNC]);
            let call = MultOperatorExpr::new (Word::new (Tokens::LPAR, a.getLoc ()),
                                              Word::new (Tokens::RPAR, a.getLoc ()),
                                              clVar,
                                              params);

            // A transform it into a value
            let ret = context:.validateValue (call);
            return if (isFalse) { // the test is always false, then it is a returner
                BlockValue::new (a.getLoc (),
                                 ret.getType (), [ret], breakLoc-> ret.getBreakerLoc (), returnLoc-> ret.getLoc (), isSet-> true)

            } else { // otherwise (always true, or not cte)
                ret
            };
        } else {
            if (isFalse) {
                match a.getMessage () {
                    EmptyExpression ()=> throw ErrorMsg::fatal (a.getLoc (), ValidateErrorMessage::CTE_ASSERT_NO_MSG);
                    expr : _ => {
                        let msg = context:.validateValue (expr);
                        throw ErrorMsg::fatal (a.getLoc (), format (ValidateErrorMessage::CTE_ASSERT_WITH_MSG, msg));
                    }
                }
            }

            return UNIT_VALUE;
        }
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================             TRY              =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a try expression
     * @params: 
     *   - context: the context of the validation
     *   - t: the try expression to validate
     * @returns: the validated value
     */
    fn validateTry (self, dmut context : &Validator, t : &TryExpr)-> &Value
        throws &ErrorMsg
    {
        let content = context:.validateValue (t.getValue ());
        if (content.getThrowers ().len != 0us) {
            __pragma!panic (); // try { value } catch { none }?
        }

        let mut innerType = content.getType ();
        if (!innerType.isMutable ()) {
            innerType = innerType.clone (1u32);
        }

        OptionValue::new (t.getLoc (), OptionType::new (t.getLoc (), innerType, isMutable-> true), content)
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================             WITH             =========================
     * ================================================================================
     * ================================================================================
     */


    /**
     * Validate a with expression
     * @params: 
     *   - context: the context of the validation
     *   - w: the with expression to validate
     * @returns: the validated value
     */
    fn validateWith (self, dmut context : &Validator, w : &DisposeScopeExpr)-> &Value
        throws &ErrorMsg
    {
        context;
        w;
        __pragma!fake_throw (&ErrorMsg);
        __pragma!panic ();
    }


    /**
     * ================================================================================
     * ================================================================================
     * =========================            ATOMIC            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate an atomic expression
     * @params: 
     *   - context: the context of the validation
     *   - a: the atomic expression to validate
     * @returns: the validated value
     */
    fn validateAtomic (self, dmut context : &Validator, a : &AtomicExpr)-> &Value
        throws &ErrorMsg
    {
        context;
        a;
        __pragma!fake_throw (&ErrorMsg);
        __pragma!panic ();
    }


    /**
     * ================================================================================
     * ================================================================================
     * =========================             CAST             =========================
     * ================================================================================
     * ================================================================================
     */


    /**
     * Validate a cast expression
     * @params: 
     *   - context: the context of the validation
     *   - c: the cast expression to validate
     * @returns: the validated value
     */
    fn validateCast (self, dmut context : &Validator, c : &CastExpr)-> &Value
        throws &ErrorMsg
    {
        context:.getCastValidator ().validateValue (alias context, c)
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================          TEMPLATES           =========================
     * ================================================================================
     * ================================================================================
     */
    
    /**
     * Validate a template call expression
     * @params: 
     *   - context: the context of the validation
     *   - t: the template call to validate
     * @returns: the validated value
     */
    fn validateTemplateCall (self, dmut context : &Validator, t : &TemplateCallExpr)-> &Value
        throws &ErrorMsg
    {
        let list = context:.validateTemplateArgumentList (t.getRights ()); // validate the list of argument of the template call
        let value : &MultSymValue = match context:.validateValue (t.getLeft ()) {  // Validate the left operand of the call
            m : &MultSymValue => { m } 
            tmp : _ => { MultSymValue::new (t.getLeft ().getLoc (), [tmp], prettyStr-> format ("%", tmp)) } // we nned a multsym to be generic in the next validation
        };
        
        // Finally validate the call
        self.validateTemplateCallMultSym (alias context, t.getLoc (), value, list)
    }

    /**
     * Validate a template call where left and right operands are valdiated
     * @params: 
     *    - context: the context of the valdiation
     *    - left: the left operand
     *    - rights: the list of arguments
     * @returns: the result value
     * @throws:
     *    - &ErrorMsg: if the call is impossible
     */
    pub fn validateTemplateCallMultSym (self, dmut context : &Validator, loc : &Word, left : &MultSymValue, rights : [&Generator])-> &Value
        throws &ErrorMsg
    {
        // We store the results inside a vector, where to each valid values is associated the correct rewritter
        let mut results : mut [mut (u32, [(&TemplateRewriter, &Value)])] = []; 
        let dmut errors = Vec!{&ErrorMsg}::new ();
        for it in left.getValues () {
            {
                let rewriter = context:.getTemplateSolver ().validateCallValue (alias context, left.getLoc (), it, rights);                    
                let mut found = false;
                for i in 0us .. results.len {                    
                    if (results[i]._0 == rewriter.getScore ()) {
                        (alias results)[i] = (results[i]._0, results[i]._1 ~ [(rewriter, it)]);
                        found = true;
                        break {}
                    } else if (results[i]._0 < rewriter.getScore ()) {
                        results = alias ((alias results[0us .. i] ~ [(rewriter.getScore (), [(rewriter, it)])]) ~ results[i .. $]);
                        found = true;
                        break {}
                    }
                }

                if (!found) results = alias (results ~ [(rewriter.getScore (), [(rewriter, it)])]);
            } catch {
                err : &ErrorMsg => { // does not work
                    errors:.push (err);
                }
            }
        }

        if (results.len == 0us && errors.len () != 0us) { // No value succeded, and there was some errors
            throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_TEMPLATE_CALL, left, rights), notes-> errors[]);
        } 
        
        self.finalizeTemplateCallMultSym (alias context, left.getLoc (), results[0us]._1)
    }
      
    /**
     * Finalize the validation of rewrittable template specialization
     * @params: 
     *     - context: the context of the validation
     *     - loc: the location of the specialization
     *     - list: the list of rewrittable specialization (@warning: assumed to contain at least one value)
     * @returns: the value containing the declared sybmols
     * @throws:
     *     - &ErrorMsg: if there was in error in the validation
     */
    pub fn finalizeTemplateCallMultSym (self, dmut context : &Validator, loc : &Word, list : [(&TemplateRewriter, &Value)])-> &Value
        throws &ErrorMsg
    {
        let dmut finalResults = Vec!{dmut &Symbol}::new ();
        let dmut errors = Vec!{&ErrorMsg}::new ();

        for it in list { // for each value that can be rewritten 
            {
                let dmut val = alias context:.getTemplateDeclarator ().declare (alias context, loc, it._0, it._1); // rewrite the syntax template, declare it and return the declared symbol
                finalResults:.push (alias val); 
            } catch { 
                err : &ErrorMsg => { // symbol declaration failed (rewrite cannot fail)
                    errors:.push (err);
                }
            }            
        }

        if (finalResults.len () == 0us) { // if there is not symbol with validation 
            throw ErrorMsg::list (errors[]);
        }

        // transform the symbols into values
        context:.getLiteralValidator ().validateMultSymbols (loc, alias context, alias (alias finalResults)[])
    }
    
    /**
     * Validate a template checker expression
     * @params: 
     *   - context: the context of the validation
     *   - t: the template checker to validate
     * @returns: the validated value
     */
    fn validateTemplateChecker (self, dmut context : &Validator, t : &TemplateCheckerExpr)-> &Value
        throws &ErrorMsg
    {        
        let list = context:.validateTemplateArgumentList (t.getParameters ());// validate the arguments passed to the checker
        
        {
            let rewriter = context:.getTemplateSolver ().validateFromTemplateChecker (alias context, t.getLoc (), t.getRules (), list); // use the template solver to perform a specialization
            let syntTmp = rewriter.replaceSyntaxTempl (t.getRules ()); // use the rewritter to remove set template specialization, and keep only those without value/type association
            if (syntTmp.len == 0us) { // the template specialization passed, and there is no template left in the checker
                return BoolValue::new (t.getLoc (), isTrue-> true); // Then the expression is evaluated to "true"
            } 
        } catch { // every error of template specialization are caught, they just mean that the expression is evaluated to "false"
            _ => {}
        }

        BoolValue::new (t.getLoc (), isTrue-> false)
    }

}
