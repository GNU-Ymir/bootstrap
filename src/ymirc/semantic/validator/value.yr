mod ymirc::semantic::validator::value;

import ymirc::semantic::validator::visitor;
import ymirc::semantic::validator::errors;
import ymirc::syntax::declaration::protection;
import ymirc::syntax::expression::_;
import ymirc::syntax::declaration::_;
import ymirc::syntax::keys;
import ymirc::semantic::symbol::_;
import ymirc::semantic::validator::template::_;
import ymirc::semantic::declarator::visitor;


import ymirc::semantic::generator::_;
import ymirc::errors::_;
import ymirc::utils::format;
import ymirc::lexing::word;
import ymirc::lexing::tokens;

import std::collection::vec;
import std::io;

/**
 * The value validator is the class responsible for value expression validation
 */
pub class ValueValidator {

    /**
     * Create a new empty validator
     */
    pub self () {}


    /**
     * Validate an expression assuming its a value
     * @params: 
     *    - context: the context of the validation
     *    - value: the expression to validate
     * @throws: &ErrorMsg, if the expression is not valid
     * @returns: a generator containing the validated value
     */
    pub def validate (self, dmut context : &Validator, value : &Expression, type : &Type = NONE_TYPE)-> &Value
        throws &ErrorMsg
    {
        match value {
            b : &BlockExpr => return self.validateBlock (alias context, b);
            l : &LiteralExpr => return self.validateLiteral (alias context, l, forceType-> type);
            o : &OperatorExpr => return self.validateOperator (alias context, o);
            v : &VarDeclExpr => return self.validateVarDecl (alias context, v);
            s : &SetExpr => return self.validateSet (alias context, s);
            d : &DecoratedExpr => return self.validateDecoExpr (alias context, d);
            c : &ConditionalExpr => return self.validateConditional (alias context, c);
            f : &ForLoopExpr => return self.validateForLoop (alias context, f);
            w : &WhileLoopExpr => return self.validateWhileLoop (alias context, w);
            b : &BreakExpr => return self.validateBreak (alias context, b);
            r : &ReturnExpr => return self.validateReturn (alias context, r);
            t : &ThrowExpr => return self.validateThrow (alias context, t);
            m : &MatcherExpr => return self.validateMatcher (alias context, m);
            m : &MacroCallExpr => return self.validateMacroCall (alias context, m);
            p : &PragmaExpr => return self.validatePragma (alias context, p);
            a : &AssertExpr => return self.validateAssert (alias context, a);
            t : &TryExpr => return self.validateTry (alias context, t);
            w : &DisposeScopeExpr => return self.validateWith (alias context, w);
            a : &AtomicExpr => return self.validateAtomic (alias context, a);
            c : &CastExpr => return self.validateCast (alias context, c);
            l : &ListExpr => return self.validateList (alias context, l, type-> type);
            i : &IntrinsicExpr => return self.validateIntrinsics (alias context, i);
            n : &NamedExpr => return self.validateNamedExpr (alias context, n);
            t : &TemplateCallExpr => return self.validateTemplateCall (alias context, t);
            t : &TemplateCheckerExpr => return self.validateTemplateChecker (alias context, t);
            l : &LambdaValueExpr => return self.validateLambda (alias context, l);
            d : &DestructVarDeclExpr => return self.validateDestructVarDecl (alias context, d);
            e : &EmptyExpression => return UnitValue::new (loc-> e.getLoc ());
            w : &ValueWrapperExpr => return w.getContent ();
            t : &TypeWrapperExpr => {
                throw ErrorMsg::fatal (t.getLoc (), ValidateErrorMessage::USE_AS_VALUE);
            }
            x : _ => {
                println (x::typeinfo.name);
                __pragma!panic ();
            }            
        }
    }


    /**
     * ================================================================================
     * ================================================================================
     * =========================            BLOCK             =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a block expression
     * @params: 
     *   - context: the context of the validation
     *   - b: the block to validate
     * @returns: the validated value
     */
    def validateBlock (self, dmut context : &Validator, b : &BlockExpr)-> &Value
        throws &ErrorMsg
    {
        let dmut errors = Vec!{&ErrorMsg}::new ();

        context:.enterBlock ();
        
        let (values, type, brLoc, rtLoc, _) = {
            // A block can have local symbol definitions (such as import, struct, etc.), we need to validate them
            let dmut module = self.validateInnerModule (alias context, b.getModule (), alias errors);
            
            let value = match module {                
                EmptySymbol () => { // No local symbol to access
                    self.validateInnerBlock (alias context, b.getExpressions (), alias errors)
                }
                _ => {
                    // There are some local symbols, we need to have access to them in the current block
                    context:.pushReferent (alias module);
                    let x = self.validateInnerBlock (alias context, b.getExpressions (), alias errors);
                    context:.popReferent (); // We go back to the previous symbol table, all local symbol are no longer accessible
                    x                    
                }
            };
            
            value
        };
        
        {
            // No need to warn unused if there were errors in the validation of the block (it will complicate the error handling)
            context:.quitBlock (warnUnused-> errors.len () == 0us);
        } catch { err : &ErrorMsg => errors:.push (err); }        

        let retBlock = BlockValue::new (b.getLoc (), type, values, breakLoc-> brLoc, returnLoc-> rtLoc);        
        let (_, _, _) = if (errors.len () != 0us) {
            self.validateCatcher (alias context, b.getCatcher (), type, retBlock.getThrowers (), alias errors)
        } else {
            let a : &Value = UnitValue::new ();
            (a, a, a)
        }

        // let (onExit, onSuccess, onFailure) = self.validateScopes ();
        
        if (errors.len () != 0us) {
            throw ErrorMsg::list (errors[]);
        }
        
        
        retBlock
    }


    /**
     * Validate the local module declared inside a block
     * @params: 
     *    - context: the context of the validation
     *    - m: the module declared in the block
     * @returns:
     *    - errors: the errors that occured when validating    
     *    - the symbol that was validated (or EmptySymbol, if the validation failed)
     */
    def validateInnerModule (self, dmut context : &Validator, m : &Declaration, dmut errors : &Vec!{&ErrorMsg})-> dmut &Symbol
    {
        {   // We get the declarator of the context, maybe there are imports here, and maybe they are already imported, so we just have to make a reference
            let dmut modSym = context:.getDeclarator ():.declare (m);
            context:.getReferent ():.insert (alias modSym); // We insert the module in the current symbol
            context:.enterForeign (isFnBody-> false, clContext-> context:.getCurrentClassContext ()); // Enter a foreign, but this is not a function, we just want to avoid polluting the current context
            
            {
                context:.validate (alias modSym);  // Validation of the declared symbols 
            } catch {
                err : &ErrorMsg => { errors:.push (err); }
            }
            
            context:.exitForeign ();            
            
            // Here we return a leaf that can be accessed only from the current block            
            return alias modSym;
        } catch {
            err : &ErrorMsg => {
                errors:.push (err);
                return EmptySymbol::new ();
            }
        } 
    }

    /**
     * Validate the content of a block
     * @params: 
     *   - context: the context of the validation
     *   - m: the block to validate
     * @returns:
     *   - errors: the list of errors, if an errors occurs
     *   - .0: the list of values inside the block
     *   - .1: the type of the last value
     *   - .2: the location of a break statement if any (EOF otherwise)
     *   - .3: the location of a return statement if any (EOF otherwise)
     *   - .4: the location of the last value
     */
    def validateInnerBlock (self, dmut context : &Validator, exprs : [&Expression], dmut errors : &Vec!{&ErrorMsg})-> ([&Value], &Type, &Word, &Word, &Word) {
        let mut returner = false, mut breaker = false; // Blocks can break loops or return functions
        // A returned block is a block in which every path leads to a return statement, and a break statement is breaker
        
        let mut rtLoc = EOF_WORD, mut brLoc = EOF_WORD, mut valueLoc = EOF_WORD; // The location of the return, break, and value for error handling
        let mut type : &Type = VoidType::new (EOF_WORD); // By default a block has no value, thus its type is void
        let dmut values = Vec!{&Value}::new (); // List of values in the block
        for i in 0us .. exprs.len {
            {
                // There is another expression to validate, but there is no way that the program arrives at that point (cf. breaker or returner)
                if ((breaker || returner) && !exprs [i].isOf!{&UnitExpr}()) throw ErrorMsg::fatal (exprs [i].getLoc (), ValidateErrorMessage::UNREACHBLE_STATEMENT);
                
                let val = context:.validateValue (exprs [i]);
                if (val.isReturner ()) { returner = true; rtLoc = val.getReturnerLoc (); }
                if (val.isBreaker ())  { breaker = true; rtLoc = val.getBreakerLoc (); }

                // If the value is implicitely aliased, then we transform it into a immutable value
                type = if (context.needExplicitAlias (val.getType (), val)) {
                    val.getType ().clone (isMutable-> false)
                } else {
                    val.getType ()
                };
                
                valueLoc = val.getLoc (); // store the location of the value of the block (if it is the last value, it will be definitely stored)
                values:.push (val);  // push the value in the list of value of the block
            } catch {
                err : &ErrorMsg => { errors:.push (err); }
            }            
        }

        match type { 
            VoidType () => {} 
            _ => { // Verify implicit aliases and stuff
                context:.verifyMemoryOwner (valueLoc, type, values[][$ - 1us]);
            } catch {
                err : &ErrorMsg => { errors:.push (err); }
            }
        }
        
        (values[], type, rtLoc, brLoc, valueLoc) 
    }


    /**
     * Validate the catcher part of a block
     * @params: 
     *   - context: the context of the validation
     *   - catcher: the catcher to validate
     *   - type: the type of the block that is catched
     *   - throwers: the list of exception thrown by the block
     * @returns: 
     *   - errors: if errors occured
     *   - .0: the variable that is catched
     *   - .1: the type info of the catch var
     *   - .2: the content of the catcher
     */
    def validateCatcher (self, dmut context : &Validator, catcher : &Expression, type : &Type, throwers : [&Type], dmut errors : &Vec!{&ErrorMsg})-> (&Value, &Value, &Value) {
        match catcher {
            EmptyExpression () => {
                let a : &Value = UnitValue::new ();
                return (a, a, a);
            }
            _ => {
                if (throwers.len == 0us) errors:.push (ErrorMsg::fatal (catcher.getLoc (), ValidateErrorMessage::NOTHING_TO_CATCH));
            }
        }
        
        context;
        catcher;
        errors;
        type;
        // Need pattern matching
        __pragma!panic ();
    }
    
    /**
     * ================================================================================
     * ================================================================================
     * =========================           LITERAL            =========================
     * ================================================================================
     * ================================================================================
     */
    
    
    /**
     * Validate a literal expression
     * @params: 
     *   - context: the context of the validation
     *   - l: the literal to validate
     *   - forceType: the type to force (if different from NONE_TYPE), only applicable in some case (e.g. StringExpr)
     * @returns: the validated value
     */
    def validateLiteral (self, dmut context : &Validator, l : &LiteralExpr, forceType : &Type = NONE_TYPE)-> &Value
        throws &ErrorMsg
    {
        return context:.getLiteralValidator ().validate (alias context, l, forceType-> forceType);
    }

    /**
     * Validate a list expression
     * @params: 
     *   - context: the context of the validation
     *   - l: the list expression to validate
     *   - type: the type to force (if different to NONE_TYPE) and only applicable to ListArray 
     * @returns: the validated value
     */
    def validateList (self, dmut context : &Validator, l : &ListExpr, type : &Type = NONE_TYPE)-> &Value
        throws &ErrorMsg
    {
        if (l.isArray ()) self.validateListArray (alias context, l, forceType-> type)
        else
            self.validateListTuple (alias context, l)
    }

    /**
     * Validate a list expression containing an array literal
     * @params: 
     *   - context: the context of the validation
     *   - l: the list to validate
     *   - forceType: the type to force (if different to NONE_TYPE)
     * @returns: the validated value
     */
    def validateListArray (self, dmut context : &Validator, l : &ListExpr, forceType : &Type = NONE_TYPE)-> &Value
        throws &ErrorMsg
    {
        let dmut parameters = Vec!{&Value}::new ();
        let mut inner : &Type = NoneType::new (l.getLoc ());
        for it in l.getParameters () {
            let val = context:.validateValue (it);
            match val {
                e : &ExpandValue => {
                    for g_it in e.getInnerValues () {
                        inner = self.addArrayType (alias context, g_it, alias parameters, inner);
                    }
                }
                g_it : _ => {
                    inner = self.addArrayType (alias context, g_it, alias parameters, inner);
                }
            }
        }

        if (parameters.len () == 0us) inner = VoidType::new (l.getLoc ());
        inner = inner.clone (isMutable-> true);
        let arrType = ArrayType::new (l.getLoc (), inner, int::usize (l.getLoc (), parameters.len ()), isMutable-> true);
        match forceType {
            ArrayType () => {
                ArrayValue::new (l.getLoc (), arrType, parameters[])
            }
            _ => {        
                let slcType = SliceType::new (l.getLoc (), inner, isMutable-> true);

                match inner {
                    VoidType () => {
                        AliaserValue::new (l.getLoc (), slcType,
                                           ArrayValue::new (l.getLoc (), arrType, parameters[]))
                    }
                    _ => {
                        CopierValue::new (l.getLoc (), slcType,
                                          AliaserValue::new (l.getLoc (), slcType,
                                                             ArrayValue::new (l.getLoc (), arrType, parameters[])))
                    }
                }
            }
        }
    }

    /**
     * Add a parameter to an list of array parameters
     * @params: 
     *   - context: the context of the validation
     *   - val: the value to add
     *   - parameters: the list of parameters inside the array literal
     *   - innerType: the current type of the inner values of the array
     */
    def addArrayType (self, dmut context : &Validator, val : &Value, dmut parameters : &Vec!{&Value}, innerType : &Type)-> &Type
        throws &ErrorMsg
    {
        if (val.getType ().isOf!{&NoneType} () || val.getType ().isOf!{&VoidType} ()) {
            throw ErrorMsg::fatal (val.getLoc (), ValidateErrorMessage::VOID_VALUE);
        }

        parameters:.push (val);        
        context.inferTypeBranchingWithValue (innerType.getLoc (), innerType, val)
    }

    /**
     * Validate a list expression containing a tuple literal
     * @params: 
     *   - context: the context of the validation
     *   - l: the list to validate
     * @returns: the validated value
     */
    def validateListTuple (self, dmut context : &Validator, l : &ListExpr)-> &Value
        throws &ErrorMsg
    {
        let dmut parameters = Vec!{&Value}::new ();
        let dmut types = Vec!{&Type}::new ();
        for it in l.getParameters () {
            let val = context:.validateValue (it);
            match val {
                e : &ExpandValue => {
                    for g_it in e.getInnerValues () {
                        self.addTupleType (alias context, g_it, alias parameters, alias types);
                    }
                }
                g_it : _ => {
                    self.addTupleType (alias context, g_it, alias parameters, alias types);
                }
            }            
        }
        
        let type = TupleType::new (l.getLoc (), types[], isMutable-> true);
        TupleValue::new (l.getLoc (), type, parameters[])
    }

    /**
     * Add an element at the end of a list of tuple parameters and types
     * @params: 
     *   - context: the context of the validation
     *   - val: the value to add
     *   - params: the list of parameters
     *   - types: the list of types
     */
    def addTupleType (self, dmut context : &Validator, val : &Value, dmut params : &Vec!{&Value}, dmut types : &Vec!{&Type})
        throws &ErrorMsg
    {
        if (val.getType ().isOf!{&NoneType} () || val.getType ().isOf!{&VoidType} ()) {
            throw ErrorMsg::fatal (val.getLoc (), ValidateErrorMessage::VOID_VALUE);
        }

        params:.push (val);
        
        {
            let type = val.getType ();
            context:.verifyMemoryOwner (val.getLoc (), type, val);
            types:.push (type);
        } catch {
            _ => {
                let type = val.getType ().clone (isMutable-> false);
                context:.verifyMemoryOwner (val.getLoc (), type, val);
                types:.push (type);
            }
        }
    }
    
    /**
     * Validate a lambda value expression
     * @params: 
     *   - context: the context of the validation
     *   - l: the lambda value
     * @returns: the validated value
     */
    def validateLambda (self, dmut context : &Validator, l : &LambdaValueExpr)-> &Value
        throws &ErrorMsg
    {
        context:.getLambdaValidator ():.validate (alias context, l)
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================         DESTUCT DECL         =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a destructor decl of variables
     * @params: 
     *    - context: the context of the validation
     *    - d: the destructor decl
     * @returns: the set of decl values
     * @throws: 
     *    - &ErrorMsg: if there is an error during the validation
     */
    def validateDestructVarDecl (self, dmut context : &Validator, d : &DestructVarDeclExpr)-> &Value
        throws &ErrorMsg
    {
        let value = context:.validateValue (d.getValue ());
        match value {
            ev : &ExpandValue => {
                return self.validateDestructDeclExpand (alias context, d, ev);
            }
            _ => { // if expand is not implicit then we explicit here to make it implicit 
                let intrValue = context:.validateValue (IntrinsicExpr::new (d.getLoc (), IntrinsicKeys::EXPAND, ValueWrapperExpr::new (value.getLoc (), value)));
                match intrValue { 
                    ev : &ExpandValue => { // it was probably a tuple, or something expandable
                        return self.validateDestructDeclExpand (alias context, d, ev);
                    }
                    _ => // it was not expandable, so it is just a single declaration
                        return self.validateDestructDeclSingle (alias context, d, value);
                }
            }
        }
    }
    
    /**
     * Validate a destruct decl for an expand value
     * @params: 
     *    - context: the context of the validation
     *    - d: the destructor declaration
     *    - value: the expand value to deconstruct
     *    - et: the type of the expand value to deconstruct
     */
    def validateDestructDeclExpand (self, dmut context : &Validator, d : &DestructVarDeclExpr, value : &ExpandValue)-> &Value
        throws &ErrorMsg
    {
        // if the arity mismatch then throw an error
        if ((d.isVariadic () && d.getParameters ().len > value.getValues ().len) ||
            (!d.isVariadic () && d.getParameters ().len != value.getValues ().len)) {
            throw ErrorMsg::fatal (d.getLoc (), format (ValidateErrorMessage::TUPLE_ARITY_OVERFLOW, d.getParameters ().len, value.getValues ().len));            
        }

        let dmut values = Vec!{&Value}::new ();

        // For each variable declaration of the destruct decl
        for i in 0us .. d.getParameters ().len {
            let assocValue : &Value = if (i != d.getParameters ().len - 1us || value.getValues ().len == d.getParameters ().len) { // get the current value
                value.getValues()[i]
            } else { // or when it is an expand of the rest values, create a tuple value containing the list of values                
                let dmut rest = Vec!{&Value}::new ();
                let dmut tupleTypes = Vec!{&Type}::new ();
                
                for j in i .. value.getValues ().len {
                    rest:.push (value.getValues()[j]);
                    tupleTypes:.push (value.getValues()[j].getType ());
                }

                let tupleType = TupleType::new (d.getParameters()[i].getLoc (), tupleTypes[], isMutable-> true);
                cast!{&Value} (TupleValue::new (d.getParameters ()[i].getLoc (), tupleType, rest[]))
            }
            
            match d.getParameters ()[i] {
                vDecl : &VarDeclExpr => { // validate the current variable declaration
                    let aux = VarDeclExpr::new (vDecl.getLoc (), vDecl.getName (), ValueWrapperExpr::new (vDecl.getLoc (), assocValue), vDecl.getType (), decos-> vDecl.getDecos ());
                    
                    values:.push (self.validateVarDecl (alias context, aux)); // using the classical variable declaration for code factorization
                }
                _ => __pragma!panic (); // destruct decl is malformed
            }
        }

        // return the list of variable declaration
        return BlockValue::new (d.getLoc (), VoidType::new (d.getLoc ()), values[], isSet-> true);
    }

    
    /**
     * Validate a destructor decl where right operand is neither a tuple nor an expand value
     * @params: 
     *   - context: the context of the validation
     *   - d: the destructor declaration
     *   - value: the value to put as the default value of the destructor decl
     * @returns: the declaration value
     * @throws:
     *   - &ErrorMsg: if there is an error during the validaton
     */
    def validateDestructDeclSingle (self, dmut context : &Validator, d : &DestructVarDeclExpr, value : &Value)-> &Value
        throws &ErrorMsg
    {
        // When using the dtor call syntax on single values, then we need to have one decl only
        if (d.getParameters ().len != 1us) {
            throw ErrorMsg::fatal (d.getLoc (), format (ValidateErrorMessage::TUPLE_ARITY_OVERFLOW, d.getParameters ().len, 1us));                    
        }

        match d.getParameters ()[0us] {
            v : &VarDeclExpr => { // it contains a var decl
                let aux = VarDeclExpr::new (v.getLoc (), v.getName (), ValueWrapperExpr::new (v.getLoc (), value), v.getType (), decos-> v.getDecos ());

                // We just rewrite the destruct var decl into a simple var decl
                return self.validateVarDecl (alias context, aux, needInitValue-> true);
            }
            _ => __pragma!panic (); // it is malformed
        }        
    }
    
    
    /**
     * ================================================================================
     * ================================================================================
     * =========================          OPERATORS           =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate an operator expression
     * @params: 
     *   - context: the context of the validation
     *   - o: the operator to validate
     * @returns: the validated value
     */
    def validateOperator (self, dmut context : &Validator, o : &OperatorExpr)-> &Value
        throws &ErrorMsg
    {
        match o {
            b : &BinaryExpr => return context:.getBinOpValidator ().validateValue (alias context, b);
            m : &MultOperatorExpr => {
                match m.getLoc () {
                    Tokens::LPAR => {
                        return context:.getCallOpValidator ().validate (alias context, m);
                    }
                    _ => {
                        return context:.getIndexOpValidator ().validate (alias context, m);
                    }
                }
            }
            u : &UnaryExpr => return context:.getUnOpValidator ().validate (alias context, u);
            p : &PathExpr => return context:.getBinOpValidator ().validateModuleOperation (alias context, p);
            _ => {
                println ("Unknown OP : ", o::typeinfo.name);
                __pragma!panic ();
            }
        }
    }
    
    /**
     * ================================================================================
     * ================================================================================
     * =========================           VAR_DECL           =========================
     * ================================================================================
     * ================================================================================
     */
    
    /**
     * Validate a var declaration expression
     * @params: 
     *   - context: the context of the validation
    *    - v: the var declaration to validate
     * @returns: the validated value
     */
    pub def validateVarDecl (self, dmut context : &Validator, v : &VarDeclExpr, needInitValue : bool = true)-> &Value
        throws &ErrorMsg
    {
        if (v.getLoc () != Keys::UNDER) context:.verifyShadow (v.getLoc ());
        let isPure = context.findDecos (v.getDecos (), [Decorators::PURE]);
        let isMutable = context.findDecos (v.getDecos (), [Decorators::MUT, Decorators::DMUT]);

        let mut type : &Type = match v.getType () {
            EmptyExpression () => {
                cast!{&Type} (NONE_TYPE)
            }
            t_inner : _ => {
                let t = context:.validateType (t_inner, v.getDecos ());
                if (isPure) t.clone (isMutable-> false)
                else t
            }
        };
        
        let val : &Value = match v.getValue () {
            EmptyExpression () => {
                if (v.getType ().isOf!{&EmptyExpression} ()) {
                    throw ErrorMsg::fatal (v.getLoc (), ValidateErrorMessage::VAR_DECL_WITH_NOTHING);
                } else if (needInitValue) {
                    throw ErrorMsg::fatal (v.getLoc (), ValidateErrorMessage::VAR_DECL_WITHOUT_VALUE);
                }
                
                cast!{&Value} (NoneValue::new ())
            }
            v_inner : _ => { context:.validateValue (v_inner.getLoc (), v_inner, type-> type, verif-> false) }
        };

        // If no type is defined for the variable, we have to set it
        if (v.getType ().isOf!{&EmptyExpression} ()) {
            type = if (context.findDecos (v.getDecos (), [Decorators::DMUT])) {
                val.getType ().toDeeplyMutable ()
            } else {
                val.getType ().clone (isMutable-> false)
            };
        }        
        
        if (!v.getValue ().isOf!{&EmptyExpression} ()) { // if the value is needed, an error was thrown earlier
            context:.verifyMemoryOwner (v.getLoc (), type, val, construct-> true, checkTypes-> true);
        }
        
        if (type.isOf!{&NoneType} () || type.isOf!{&VoidType} ()) {
            throw ErrorMsg::fatal (v.getLoc (), ValidateErrorMessage::VOID_VAR);                               
        } // else if (type.isOf!{&TraitRef} ()) // TODO

        let ret = VarDeclValue::new (v.getLoc (), type, val, isMutable-> isMutable, isPure-> isPure);
        if (v.getLoc () != Keys::UNDER) context:.insertLocal (v.getLoc ().str (), ret);

        ret
    }


    

    
    /**
     * Validate a set expression (generally a succession of var decl)
     * @params: 
     *   - context: the context of the validation
     *   - s: the set to validate
     * @returns: the validated value
     */
    def validateSet (self, dmut context : &Validator, s : &SetExpr)-> &Value
        throws &ErrorMsg
    {
        let dmut errors = Vec!{&ErrorMsg}::new ();
        let (values, type, brLoc, rtLoc, _) = {
            self.validateInnerBlock (alias context, s.getContent (), alias errors)
        };

        let retBlock = BlockValue::new (s.getLoc (), type, values, breakLoc-> brLoc, returnLoc-> rtLoc, isSet-> true);
        
        if (errors.len () != 0us) {
            throw ErrorMsg::list (errors[]);
        }
                
        retBlock
    }    

    /**
     * ================================================================================
     * ================================================================================
     * =========================          DECORATED           =========================
     * ================================================================================
     * ================================================================================
     */


    /**
     * Validate a decorated expression
     * @params: 
     *   - context: the context of the validation
     *   - d: the decorated expression to validate
     * @returns: the validated value
     * @throws:
     *   - &ErrorMsg: if the validation fails
     */    
    def validateDecoExpr (self, dmut context : &Validator, d : &DecoratedExpr)-> &Value
        throws &ErrorMsg
    {
        let decos = d.getDecorators ();
        if (decos.len == 1us && decos[0us].deco == Decorators::CTE) {
            return self.validateCteExpr (alias context, d.getContent ());
        }
       
        __pragma!panic ();        
    }

    /**
     * Validate an expression that has been marked as "cte"
     * @params: 
     *   - context: the context of the validation
     *   - expr: the expression to validate
     * @returns: the validated expression
     * @throws:
     *   - &ErrorMsg: if the validation fails
     */
    def validateCteExpr (self, dmut context : &Validator, expr : &Expression)-> &Value
        throws &ErrorMsg
    {
        match expr {
            c : &ConditionalExpr => { // Conditionals have a different treatment for ctes
                return self.validateCteConditionalExpr (alias context, c);
            }
            f : &ForLoopExpr => { // Same for "for" loops
                return self.validateCteForLoopExpr (alias context, f);
            }
            _ => { // Otherwise we just try to get the value at compilation time
                let resExpr = self.validate (alias context, expr);
                return context:.getCompileTimeInterpreter ().compute (resExpr);
            }
        }
    }

    /**
     * Validate a conditional expression whose test must be evaluated at compilation time
     * @params: 
     *    - context: the context of the validation
     *    - expr: the expression to validate
     * @returns: the result content of the if expression (or its else value if the test did not pass)
     * @throws:
     *     - &ErrorMsg: if the validation fails or the test value cannot be known at compile time
     */
    def validateCteConditionalExpr (self, dmut context : &Validator, expr : &ConditionalExpr)-> &Value
        throws &ErrorMsg
    {
        let test = self.validate (alias context, expr.getTest ()); // First we need to validate the expression of the test of the conditional
        let value = context:.getCompileTimeInterpreter ().compute (test); // And try to retreive its real value at compilation time
        match value {
            b : &BoolValue => { // To work, the test must be a bool value
                if (b.isTrue ()) { // If it is true, then only the content of the if expression is validated
                    return self.validate (alias context, expr.getContent ());                   
                } else { // otherwise only the else part is validated
                    return self.validate (alias context, expr.getElse ());
                }
            }
            x : _ => {
                throw ErrorMsg::fatal (expr.getLoc (), end-> x.getLoc (), format (ValidateErrorMessage::INCOMPATIBLE_TYPE, x.getType (), BoolType::new (expr.getLoc ())));
            }
        }
    }

    /**
     * Validate a for loop that is marked cte
     * @params: 
     *    - context: the context of the validation
     *    - expr: the for loop to validate
     * @returns: the content of the for loop, unrolled at compile time
     * @throws:
     *    - &ErrorMsg: if the for loop cannot be executed at compile time, or there is an error in the validation (iterator, or for loop content)
     */
    def validateCteForLoopExpr (self, dmut context : &Validator, expr : &ForLoopExpr)-> &Value
        throws &ErrorMsg
    {
        context;
        expr;
        __pragma!fake_throw (&ErrorMsg);
        __pragma!panic ();
    }
    
    /**
     * Validate an intrinsic expr
     * @params: 
     *   - context: the context of the validation
     *   - i: the intrinsic expression to validate
     * @returns: the validated value
     */
    def validateIntrinsics (self, dmut context : &Validator, i : &IntrinsicExpr)-> &Value
        throws &ErrorMsg
    {
        match i.getType () {
            IntrinsicKeys::COPY => {
                match i.getContent () {
                    lmbd : &LambdaValueExpr =>
                        return context:.getLambdaValidator ():.validate (alias context, lmbd, isClosure-> true);
                    _ =>
                        return self.validateCopy (alias context, i);
                }
            }
            IntrinsicKeys::ALIAS => {
                return self.validateAlias (alias context, i);
            }
            IntrinsicKeys::TYPEOF => { // Typeof is necessarily a type (it's in the name)
                throw ErrorMsg::fatal (i.getLoc (), ValidateErrorMessage::USE_AS_VALUE);
            }
            IntrinsicKeys::EXPAND => {
                return self.validateExpand (alias context, i);
            }
        }

        __pragma!panic ();
    }

    /**
     * Validate a copy intrinsic
     * @params: 
     *    - context: the context of the validation
     *    - i: the intrinsic to validated assumed to be a copy
     * @returns: the validated value
     * @throws: 
     *    - &ErrorMsg: if teh value is no copiable
     */
    def validateCopy (self, dmut context : &Validator, i : &IntrinsicExpr)-> &Value
        throws &ErrorMsg
    {
        let content = context:.validateValue (i.getContent ());
        // The only aliasable type that is one level copiable is slice
        match content.getType () {
            slc : &SliceType => {
                let inner = slc.getInners ()[0].clone (isMutable-> true);
                let type = SliceType::new (i.getLoc (), inner, isMutable-> true);

                CopierValue::new (i.getLoc (), type, content)
            }
            _ => {
                throw ErrorMsg::fatal (i.getLoc (), format (ValidateErrorMessage::NO_COPY_EXIST, content.getType ()));
            }
        }
    }
    

    /**
     * Validate an alias of a value
     * @params: 
     *    - context: the context of the validation
     *    - i: the intrinsic expression assumed to be an alias
     * @returns: the validated value
     * @throws:
     *    - &ErrorMsg: if the value is not aliasable, or cannot be validated
     */
    def validateAlias (self, dmut context : &Validator, i : &IntrinsicExpr)-> &Value
        throws &ErrorMsg
    {
        let content = context:.validateValue (i.getContent ());
        if (!content.getType ().isMutable ()) {
            throw ErrorMsg::fatal (i.getLoc (), end-> content.getLoc (), format (ValidateErrorMessage::NOT_A_LVALUE_TYPE, content.getType ()));
        }        
        
        AliaserValue::new (i.getLoc (), content.getType (), content)
    }

    /**
     * Validate a named expression
     * @params: 
     *   - context: the context of the validation
     *   - n: the named expression to validate
     * @returns: the validated value
     */
    def validateNamedExpr (self, dmut context : &Validator, n : &NamedExpr)-> &Value
        throws &ErrorMsg
    {
        let content = context:.validateValue (n.getContent ());
        NamedValue::new (n.getLoc (), n.getLoc ().str (), content)
    }


    def validateExpand (self, dmut context : &Validator, i : &IntrinsicExpr)-> &Value
        throws &ErrorMsg
    {
        let content = context:.validateValue (i.getContent ());
        match content.getType () {
            t : &TupleType => {
                let dmut values = Vec!{&Value}::new ();
                for it in 0us .. t.getInners ().len {
                    values:.push (TupleFieldAccessValue::new (i.getLoc (), t.getInners ()[it], content, it));
                }

                return ExpandValue::new (i.getLoc (), values[]);
            }
            _ => return content;            
        }          
    }

    
    /**
     * ================================================================================
     * ================================================================================
     * =========================     CONDITION AND LOOPS      =========================
     * ================================================================================
     * ================================================================================
     */
    
    /**
     * Validate a conditional expression
     * @params: 
     *   - context: the context of the validation
     *   - c: the conditional expression to validate
     * @returns: the validated value
     */
    def validateConditional (self, dmut context : &Validator, c : &ConditionalExpr)-> &Value
        throws &ErrorMsg
    {
        let test = match c.getTest () {
            EmptyExpression () => { cast!{&Value} (NoneValue::new (c.getLoc ())) }
            t : _ => {
                let r = context:.validateValue (t);
                if (!r.getType ().isOf!{&BoolType} ()) {
                    throw ErrorMsg::fatal (r.getLoc (), format (ValidateErrorMessage::INCOMPATIBLE_TYPE, r.getType (), BoolType::new (r.getLoc ())));
                }
                r
            }
        };

        let content = context:.validateValue (c.getContent ());
        let mut type = content.getType ();
        {
            context.verifyMemoryOwner (content.getLoc (), type, content);
        } catch {
            _ : &ErrorMsg => {
                type = type.clone (isMutable-> false);
                context.verifyMemoryOwner (content.getLoc (), type, content);
            }
        }

        match c.getElse () {
            EmptyExpression () => {
                context.verifyCompatibleType (c.getLoc (), content.getLoc (), VoidType::new (c.getLoc ()), type);
                ConditionalValue::new (c.getLoc (), type, test, content, elsev-> NoneValue::new (c.getLoc ()))
            }
            e : _ => {
                let else_ = context:.validateValue (e);
                if (!else_.isBreaker () && !else_.isReturner ()) {
                    {
                        type = context.inferTypeBranchingWithValue (else_.getLoc (), type, else_);
                    } catch {
                        err : &ErrorMsg => throw ErrorMsg::note (c.getLoc (), notes-> [err], ValidateErrorMessage::BRANCHING_VALUE);
                    }
                } else {
                    type = VoidType::new (c.getLoc ());
                }

                ConditionalValue::new (c.getLoc (), type, test, content, elsev-> else_)
            }                
        }
    }

        
    /**
     * Validate a for loop
     * @params: 
     *   - context: the context of the validation
     *   - f: the for loop to validate
     * @returns: the validated value
     */
    def validateForLoop (self, dmut context : &Validator, f : &ForLoopExpr)-> &Value
        throws &ErrorMsg
    {
        return context:.getForLoopValidator ().validate (alias context, f);
    }

    /**
     * Validate a while loop
     * @params: 
     *   - context: the context of the validation
     *   - w: the while loop to validate
     * @returns: the validated value
     */
    def validateWhileLoop (self, dmut context : &Validator, w : &WhileLoopExpr)-> &Value
        throws &ErrorMsg
    {
        let test = match w.getTest () {
            EmptyExpression () => { cast!{&Value} (NoneValue::new (w.getLoc ())) }
            t : _ => {
                let r = context:.validateValue (t);
                if (!r.getType ().isOf!{&BoolType} ()) {
                    throw ErrorMsg::fatal (r.getLoc (), format (ValidateErrorMessage::INCOMPATIBLE_TYPE, r.getType (), BoolType::new (r.getLoc ())));
                }
                r
            }
        };

        let voidType = VoidType::new (w.getLoc ());
        let content = {
            context:.enterLoop ();
            if (!w.getTest ().isOf!{&EmptyExpression} ())
                context:.setCurrentLoopType (voidType);
            
            context:.validateValue (w.getContent ())
        } catch {
            err : &ErrorMsg => { 
                context:.quitLoop ();
                throw err;
            }
        }

        context:.quitLoop ();        
        context:.verifyCompatibleType (content.getLoc (), w.getLoc (), content.getType (), voidType);

        LoopValue::new (w.getLoc (), voidType, test, content, w.isDo ())
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================    BREAK/RETURN/ and MISC    =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a break expression
     * @params: 
     *   - context: the context of the validation
     *   - b: the break to validate
     * @returns: the validated value
     */
    def validateBreak (self, dmut context : &Validator, b : &BreakExpr)-> &Value
        throws &ErrorMsg
    {        
        if (!context.isInLoop ()) throw ErrorMsg::fatal (b.getLoc (), ValidateErrorMessage::BREAK_NO_LOOP);

        // Break can have a value in 'loop' loops
        let val = match b.getValue () {
            EmptyExpression () => { cast!{&Value} (UnitValue::new (loc-> b.getLoc ())) }
            v : &Expression => {
                context:.validateValue (v)
            }
        };
        
        let loopType = context.getCurrentLoopType ();

        // There may be multiple break in the loop, we need to verify that the type is compatible
        // It is a branching type (multiple branch with slightly different types)
        let finLoopType = context.inferTypeBranchingWithValue (b.getLoc (), loopType, val);

        // We need to ensure that there is no mutability issue 
        context.verifyMemoryOwner (b.getLoc (), finLoopType, val);

        // Change the loop type for future break branches (and loop type)
        context:.setCurrentLoopType (finLoopType);

        // Breaks are not really values (you cannot write 'a = break 12;'), they are always typed 'void'
        BreakValue::new (b.getLoc (), val)
    }

    /**
     * Validate a return expression
     * @params: 
     *   - context: the context of the validation
     *   - r: the return to validate
     * @returns: the validated value
     */
    def validateReturn (self, dmut context : &Validator, r : &ReturnExpr)-> &Value
        throws &ErrorMsg
    {
        if (!context.isInFunctionBody ()) throw ErrorMsg::fatal (r.getLoc (), ValidateErrorMessage::RETURN_NO_FUNCTION);

        // The function type is set once at the beginning of a function validation, or by return statement in case of lambda validation
        let fnType = context.getFunctionReturn ();
        
        // Return can be used in void function to quit the function immediately, so without a value
        let val = match r.getValue () {
            EmptyExpression () => { cast!{&Value} (UnitValue::new (loc-> r.getLoc ())) }
            v : &Expression => {
                let res = context:.validateValue (v);
                
                match res.getType () {
                    LambdaType () => {
                        // We have the possibility here - thanks to the return type of the function - to know the types of the prototype of a lambda function
                        if (fnType.isOf!{&FuncPtrType} () || fnType.isOf!{&DelegateType} ()) { // inferLambdaValue manage that test, but we don't want error throwing for anything else than lambda validation error
                            context:.inferLambdaValue (fnType, res)
                        } else { res }
                    }
                    _ => { res }
                }
            }
        };

        
        if (context.isInLambdaBody ()) { // The type can be changed by the return statement
            let finFnType = context:.inferTypeBranchingWithValue (val.getLoc (), fnType, val);
            context:.setFunctionReturn (finFnType);
        } else {
            // Verify that the mutability of the returned values is respected
            context:.verifyMemoryOwner (fnType.getLoc (), fnType, val, construct-> true, checkTypes-> true);
        }
        

        // Returns are not really values (you cannot write 'a = return 12;'), they are always typed 'void'
        ReturnValue::new (r.getLoc (), val)
    }

    /**
     * Validate a throw expression
     * @params: 
     *   - context: the context of the validation
     *   - t: the throw to validate
     * @returns: the validated value
     */
    def validateThrow (self, dmut context : &Validator, t : &ThrowExpr)-> &Value
        throws &ErrorMsg
    {
        context;
        t;
        __pragma!fake_throw (&ErrorMsg);
        __pragma!panic ();
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================        PATTERN MATCH         =========================
     * ================================================================================
     * ================================================================================
     */
    
    /**
     * Validate a pattern matcher
     * @params: 
     *   - context: the context of the validation
     *   - m: the pattern matcher to validate
     * @returns: the validated value
     */
    def validateMatcher (self, dmut context : &Validator, m : &MatcherExpr)-> &Value
        throws &ErrorMsg
    {
        return context:.getMatcherValidator ().validate (alias context, m);
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================            MACRO             =========================
     * ================================================================================
     * ================================================================================
     */


    /**
     * Validate a macro call expression
     * @params: 
     *   - context: the context of the validation
     *   - m: the macro call expression to validate
     * @returns: the validated value
     */
    def validateMacroCall (self, dmut context : &Validator, m : &MacroCallExpr)-> &Value
        throws &ErrorMsg
    {
        context;
        m;
        __pragma!fake_throw (&ErrorMsg);
        __pragma!panic ();
    }


    /**
     * ================================================================================
     * ================================================================================
     * =========================            PRAGMA            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a pragma expression
     * @params: 
     *   - context: the context of the validation
     *   - p: the pragma expression to validate
     * @returns: the validated value
     */
    def validatePragma (self, dmut context : &Validator, p : &PragmaExpr)-> &Value
        throws &ErrorMsg
    {
        context;
        p;
        __pragma!fake_throw (&ErrorMsg);
        __pragma!panic ();
    }


    /**
     * ================================================================================
     * ================================================================================
     * =========================            ASSERT            =========================
     * ================================================================================
     * ================================================================================
     */


    /**
     * Validate an assert expression
     * @params: 
     *   - context: the context of the validation
     *   - p: the assert expression to validate
     * @returns: the validated value
     */
    def validateAssert (self, dmut context : &Validator, a : &AssertExpr)-> &Value
        throws &ErrorMsg
    {
        context;
        a;
        __pragma!fake_throw (&ErrorMsg);
        __pragma!panic ();
    }


    /**
     * ================================================================================
     * ================================================================================
     * =========================             TRY              =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a try expression
     * @params: 
     *   - context: the context of the validation
     *   - t: the try expression to validate
     * @returns: the validated value
     */
    def validateTry (self, dmut context : &Validator, t : &TryExpr)-> &Value
        throws &ErrorMsg
    {
        context;
        t;
        __pragma!fake_throw (&ErrorMsg);
        __pragma!panic ();
    }


    /**
     * ================================================================================
     * ================================================================================
     * =========================             WITH             =========================
     * ================================================================================
     * ================================================================================
     */


    /**
     * Validate a with expression
     * @params: 
     *   - context: the context of the validation
     *   - w: the with expression to validate
     * @returns: the validated value
     */
    def validateWith (self, dmut context : &Validator, w : &DisposeScopeExpr)-> &Value
        throws &ErrorMsg
    {
        context;
        w;
        __pragma!fake_throw (&ErrorMsg);
        __pragma!panic ();
    }


    /**
     * ================================================================================
     * ================================================================================
     * =========================            ATOMIC            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate an atomic expression
     * @params: 
     *   - context: the context of the validation
     *   - a: the atomic expression to validate
     * @returns: the validated value
     */
    def validateAtomic (self, dmut context : &Validator, a : &AtomicExpr)-> &Value
        throws &ErrorMsg
    {
        context;
        a;
        __pragma!fake_throw (&ErrorMsg);
        __pragma!panic ();
    }


    /**
     * ================================================================================
     * ================================================================================
     * =========================             CAST             =========================
     * ================================================================================
     * ================================================================================
     */


    /**
     * Validate a cast expression
     * @params: 
     *   - context: the context of the validation
     *   - c: the cast expression to validate
     * @returns: the validated value
     */
    def validateCast (self, dmut context : &Validator, c : &CastExpr)-> &Value
        throws &ErrorMsg
    {
        context;
        c;
        __pragma!fake_throw (&ErrorMsg);
        __pragma!panic ();
    }


    /**
     * ================================================================================
     * ================================================================================
     * =========================          TEMPLATES           =========================
     * ================================================================================
     * ================================================================================
     */
    
    /**
     * Validate a template call expression
     * @params: 
     *   - context: the context of the validation
     *   - t: the template call to validate
     * @returns: the validated value
     */
    def validateTemplateCall (self, dmut context : &Validator, t : &TemplateCallExpr)-> &Value
        throws &ErrorMsg
    {
        let list = context:.validateTemplateArgumentList (t.getRights ()); // validate the list of argument of the template call
        let value : &MultSymValue = match context:.validateValue (t.getLeft ()) {  // Validate the left operand of the call
            m : &MultSymValue => { m } 
            tmp : _ => { MultSymValue::new (t.getLeft ().getLoc (), [tmp], prettyStr-> format ("%", tmp)) } // we nned a multsym to be generic in the next validation
        };
        
        // Finally validate the call
        self.validateTemplateCallMultSym (alias context, value, list)
    }

    /**
     * Validate a template call where left and right operands are valdiated
     * @params: 
     *    - context: the context of the valdiation
     *    - left: the left operand
     *    - rights: the list of arguments
     * @returns: the result value
     * @throws:
     *    - &ErrorMsg: if the call is impossible
     */
    pub def validateTemplateCallMultSym (self, dmut context : &Validator, left : &MultSymValue, rights : [&Generator])-> &Value
        throws &ErrorMsg
    {
        // We store the results inside a vector, where to each valid values is associated the correct rewritter
        let mut results : mut [mut (u32, [(&TemplateRewriter, &Value)])] = []; 
        let dmut errors = Vec!{&ErrorMsg}::new ();
        for it in left.getValues () {
            {
                let rewriter = context:.getTemplateSolver ().validateCallValue (alias context, left.getLoc (), it, rights);                    
                let mut found = false;
                for i in 0us .. results.len {                    
                    if (results[i]._0 == rewriter.getScore ()) {
                        (alias results)[i] = (results[i]._0, results[i]._1 ~ [(rewriter, it)]);
                        found = true;
                        break {}
                    } else if (results[i]._0 < rewriter.getScore ()) {
                        results = alias ((alias results[0us .. i] ~ [(rewriter.getScore (), [(rewriter, it)])]) ~ results[i .. $]);
                        found = true;
                        break {}
                    }
                }

                if (!found) results = alias (results ~ [(rewriter.getScore (), [(rewriter, it)])]);
            } catch {
                err : &ErrorMsg => { // does not work
                    errors:.push (err);
                }
            }
        }

        if (results.len == 0us && errors.len () != 0us) { // No value succeded, and there was some errors
            throw ErrorMsg::list (errors[]);
        } 
        
        self.finalizeTemplateCallMultSym (alias context, left.getLoc (), results[0us]._1)
    }
      
    /**
     * Finalize the validation of rewrittable template specialization
     * @params: 
     *     - context: the context of the validation
     *     - loc: the location of the specialization
     *     - list: the list of rewrittable specialization (@warning: assumed to contain at least one value)
     * @returns: the value containing the declared sybmols
     * @throws:
     *     - &ErrorMsg: if there was in error in the validation
     */
    pub def finalizeTemplateCallMultSym (self, dmut context : &Validator, loc : &Word, list : [(&TemplateRewriter, &Value)])-> &Value
        throws &ErrorMsg
    {
        let dmut finalResults = Vec!{dmut &Symbol}::new ();
        let dmut errors = Vec!{&ErrorMsg}::new ();

        for it in list { // for each value that can be rewritten 
            {
                let dmut val = alias context:.getTemplateDeclarator ().declare (alias context, loc, it._0, it._1); // rewrite the syntax template, declare it and return the declared symbol
                finalResults:.push (alias val); 
            } catch { 
                err : &ErrorMsg => { // symbol declaration failed (rewrite cannot fail)
                    errors:.push (err);
                }
            }            
        }

        if (finalResults.len () == 0us) { // if there is not symbol with validation 
            throw ErrorMsg::list (errors[]);
        }

        // transform the symbols into values
        context:.getLiteralValidator ().validateMultSymbols (loc, alias context, alias (alias finalResults)[])
    }
    
    /**
     * Validate a template checker expression
     * @params: 
     *   - context: the context of the validation
     *   - t: the template checker to validate
     * @returns: the validated value
     */
    def validateTemplateChecker (self, dmut context : &Validator, t : &TemplateCheckerExpr)-> &Value
        throws &ErrorMsg
    {        
        let list = context:.validateTemplateArgumentList (t.getParameters ());// validate the arguments passed to the checker
        
        {
            let rewriter = context:.getTemplateSolver ().validateFromTemplateChecker (alias context, t.getLoc (), t.getRules (), list); // use the template solver to perform a specialization
            let syntTmp = rewriter.replaceSyntaxTempl (t.getRules ()); // use the rewritter to remove set template specialization, and keep only those without value/type association
            if (syntTmp.len == 0us) { // the template specialization passed, and there is no template left in the checker
                return BoolValue::new (t.getLoc (), isTrue-> true); // Then the expression is evaluated to "true"
            } 
        } catch { // every error of template specialization are caught, they just mean that the expression is evaluated to "false"
            _ => {}
        }

        BoolValue::new (t.getLoc (), isTrue-> false)
    }
    
}
