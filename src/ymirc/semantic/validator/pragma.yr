mod ymirc::semantic::validator::pragma;

import ymirc::syntax::expression::_;
import ymirc::semantic::validator::visitor;
import ymirc::semantic::validator::errors;

import ymirc::semantic::generator::_;
import ymirc::errors::_;
import ymirc::utils::format;
import ymirc::lexing::word;
import ymirc::lexing::tokens;
import ymirc::syntax::keys;

import std::collection::vec;

import std::algorithm::searching;
import std::io;
import std::conv;

/**
 * The validator responsible for the validation of '__pragma' expressions
 */
pub class PragmaValidator {

    /**
     * Create a new empty validator
     */
    pub self () {}


    /**
     * Validate a pragma expression 
     * @params:
     *    - context: the context of the validation
     *    - p: the pragma expression to validate
     * @returns: the validated expression
     */
    pub fn validate (self, dmut context : &Validator, p : &PragmaExpr)-> &Value
        throws &ErrorMsg
    {
        match p.getLoc ().str () {
            PragmaKeys::COMPILE => {
                self.validateCompile (alias context, p)
            }
            PragmaKeys::MSG => {
                self.validateMessage (alias context, p)
            }
            PragmaKeys::OPERATOR => {
                self.validateOperator (alias context, p)
            }
            PragmaKeys::TUPLEOF => {
                self.validateTupleOf (alias context, p)
            }
            _ => {
                throw ErrorMsg::fatal (p.getLoc (), format (ValidateErrorMessage::UNKNOWN_PRAGMA, p.getLoc ().str ()));
            }
        }
    }
    
    /**
     * Tries to validate the content of the pragma 
     * @params:
     *    - context: the context of the validation
     *    - p: the pragma to validate
     * @returns: a bool value containing true iif the inner values compiles, containing false otherwise
     */
    fn validateCompile (self, dmut context : &Validator, p : &PragmaExpr)-> &Value {
        
        for v in p.getParameters ()
        {            
            let _ =
                (cast!{&Generator} (context:.validateValue (v))?)
                .getOr (context:.validateType (v));            
        } catch {
            _ => {
                    return BoolValue::new (p.getLoc (), false)
                }
        }
        
        BoolValue::new (p.getLoc (), true)
    }

    /**
     * Validate a message printing at compilation time
     * @params:
     *    - context: the context of the validation
     *    - p: the expression to validate
     * @returns: en none value
     */
    fn validateMessage (self, dmut context : &Validator, p : &PragmaExpr)-> &Value
        throws &ErrorMsg
    {
        for v in p.getParameters () {
            let mut msg = context:.validateValue (v);
            match msg {
                s : &StringValue => {
                    match s.getEncodingSize () {
                        8u16 => { println (utf::instance ().decode (s.getValue ().utf8)); }
                        16u16 => { println (utf::instance ().decode (s.getValue ().utf16)); }
                        _ => { println (utf::instance ().decode (s.getValue ().utf32)); }
                    }
                }             
                m : _ => {
                    println (format ("%", m));
                }
            }
        }

        UNIT_VALUE
    }    


    /**
     * Validate a pragma 'operator' to check the existence of an operator between two types (e.g. __pragma!"operator" ("==", i32, i32))
     * @params:
     *     - context: the context of the validation
     *     - p: the pragma to validate
     * @returns: a bool value
     */
    fn validateOperator (self, dmut context : &Validator, p : &PragmaExpr)-> &Value
        throws &ErrorMsg
    {
        if (p.getParameters ().len != 2us && p.getParameters ().len != 3us) {
            throw ErrorMsg::fatal (p.getLoc (), format (ValidateErrorMessage::MALFORMED_PRAGMA, p.getLoc ().str ()));
        }
                
        let opStr = context:.getCompileTimeInterpreter ().decodeString (context:.validateValue (p.getParameters ()[0]));
        let syntOp = if (p.getParameters ().len == 2us) {
            let v = FakeValue::new (context:.validateType (p.getParameters ()[1]));
            UnaryExpr::new (Word::new (opStr, p.getLoc ()), ValueWrapperExpr::new (p.getLoc (), v))
        } else {
            let vl = FakeValue::new (context:.validateType (p.getParameters ()[1]));
            let vr = FakeValue::new (context:.validateType (p.getParameters ()[2]));

            BinaryExpr::new (Word::new (opStr, p.getLoc ()),
                             ValueWrapperExpr::new (p.getLoc (), vl),
                             ValueWrapperExpr::new (p.getLoc (), vr))
        };            


        let b = match context:.validateValue (syntOp)? {
            Ok () => { true }
            _ => { false }
        };
        
        BoolValue::new (p.getLoc (), b)
    }

    /*!
     * =================================================================================
     * =================================================================================
     * ==========================           TUPLEOF            =========================
     * =================================================================================
     * =================================================================================
     */

    /**
     * Validate the pragma 'tupleof' to create a tuple from a structure or a class value
     * @params:
     *    - context: the context of the validation
     *    - p: the pragma to validate
     * @returns: a tuple value
     * */
    fn validateTupleOf (self, dmut context : &Validator, p : &PragmaExpr)-> &Value
        throws &ErrorMsg
    {
        if (p.getParameters ().len != 1us) {
            throw ErrorMsg::fatal (p.getLoc (), format (ValidateErrorMessage::MALFORMED_PRAGMA, p.getLoc ().str ()));
        }

        let value = context:.validateValue (p.getParameters ()[0]);
        match value.getType () {
            s : &StructType => {
                return self.validateTupleOfStruct (alias context, p, value, s);
            }
            c : &ClassPtrType => {
                return self.validateTupleOfClass (alias context, p, value, c);
            }
            _ => {
                throw ErrorMsg::fatal (p.getLoc (), format (ValidateErrorMessage::MALFORMED_PRAGMA, p.getLoc ().str ()));
            }
        }
    }

    /**
     * Validate a tupleof on a struct value
     * @params:
     *    - context: the context of the validation
     *    - p: the pragma to validate
     *    - value: the value containing a class object instance
     *    - c: the type of the object
     * @returns: a tuple value
     *
     * */
    fn validateTupleOfStruct (self, dmut _ : &Validator, p : &PragmaExpr, value : &Value, s : &StructType)-> &Value {
        let dmut values = Vec!{&Value}::new ();
        let dmut types = Vec!{&Type}::new ();

        for f in s.getFields () match f {
            v : &VarDeclValue => {
                let type = v.getVarType ().clone (0u32);
                let access = StructFieldAccessValue::new (p.getLoc (), type, value, v.getLoc ().str ());
                values:.push (access);
                types:.push (type);
            }
        }

        let tuType = TupleType::new (p.getLoc (), types[], isMutable-> true);
        TupleValue::new (p.getLoc (), tuType, values[])
    }

    /**
     * Validate a tupleof on a class value
     * @params:
     *    - context: the context of the validation
     *    - p: the pragma to validate
     *    - value: the value containing a class object instance
     *    - c: the type of the object
     * @returns: a tuple value
     * */
    fn validateTupleOfClass (self, dmut context : &Validator, p : &PragmaExpr, value : &Value, cptr : &ClassPtrType)-> &Value
        throws &ErrorMsg
    {
        let (inPrv, _) = context:.getCurrentClassContextProtections (cptr.getInner ());
        if (!inPrv) {
            throw ErrorMsg::fatal (p.getLoc (), format (ValidateErrorMessage::PRAGMA_TUPLEOF_PRIVATE));
        }

        let dmut values = Vec!{&Value}::new ();
        let dmut types = Vec!{&Type}::new ();

        for f in cptr.getInner ().getLocalFields () match f {
            v : &VarDeclValue => {
                let type = v.getVarType ().clone (0u32);
                let access = ClassFieldAccessValue::new (p.getLoc (), type, value, f.getLoc ().str ());
                values:.push (access);
                types:.push (type);
            }
        }

        let tuType = TupleType::new (p.getLoc (), types[], isMutable-> true);
        TupleValue::new (p.getLoc (), tuType, values[])
    }

}
