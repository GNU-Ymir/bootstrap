mod ymirc::semantic::validator::type;

import ymirc::semantic::validator::visitor;
import ymirc::semantic::validator::errors;

import ymirc::syntax::declaration::protection;
import ymirc::syntax::expression::_;

import ymirc::semantic::generator::_;
import ymirc::errors::_;
import ymirc::utils::format;

import std::collection::vec;
import std::io;

/**
 * The type validator is the class responsible for type expression validation
 */
pub class TypeValidator {

    /**
     * Create a new empty validator
     */
    pub self () {}


    /**
     * Validate an expression assuming its a type
     * @params: 
     *    - context: the context of the validation
     *    - type: the expression to validate
     *    - parentMutable: true if the type to return is flagged mutable
     *    - isDeeplyMutable: true if the type to return is flagged deeply mutable
     *    - isRoot: true if the validation is for a a root type (false for inner types), (remark: should be modifier only by this class ?)
     * @throws: &ErrorMsg, if the expression is not valid
     * @returns: a generator containing the validated type
     */
    pub def validate (self, dmut context : &Validator, type : &Expression, parentMutable : bool = true, isMutable : bool = false, isDeeplyMutable : bool = false, isRoot : bool = true)-> &Type
        throws &ErrorMsg
    {
        isRoot;
        let ret = match type {
            UnitExpr () => { cast!{&Type} (NoneType::new (loc-> type.getLoc ())) }
            EmptyExpression () => { cast!{&Type} (NoneType::new (loc-> type.getLoc ())) }
            arr : &SliceAllocatorExpr => { self.validateSliceAllocator (alias context, arr, parentMutable, isMutable, isDeeplyMutable) }
            v : &VarExpr => { self.validateVar (alias context, v, parentMutable, isMutable, isDeeplyMutable) }
            // dec : &DecoratedExpr => { self.validateDeco (alias context, dec, parentMutable, isDeeplyMutable, isRoot) }
            // un : &UnaryExpr => { self.validateUnary (alias context, un, parentMutable, isDeeplyMutable) }
            // tr : &TryExpr => { self.validateTry (alias context, tr, parentMutable, isDeeplyMutable) }
            // lst : &ListExpr => {
            //     if (lst.isArray ()) {
            //         self.validateArrayList (alias context, lst, parentMutable, isDeeplyMutable)
            //     } else {
            //         self.validateTuple (alias context, lst, parentMutable, isDeeplyMutable)
            //     }
            // } 
            // call : &TemplateCall => { self.validateTemplateCall (alias context, cl, parentMutable, isDeeplyMutable) }            
            _ => {
                throw ErrorMsg::fatal (type.getLoc (), ""s8);
            }
        };

        // TODO verify classref?
        return ret;
    }

    /**
     * Validate an array alloc as a type
     * @params: 
     *   - context: the context of the validation
     *   - type: the type to validate
     *   - parentMutable: true if a decorator `mut` was found in the description of the parent
     *   - isMutable: true if a decorator `mut` was found in the description of this type (assuming isMutable => parentMutable)
     *   - isDeeplyMutable: true if a decorator `dmut` was found in the description
     * @returns: a type 
     * @throws: &ErrorMsg: if the type is not valid
     */
    def validateSliceAllocator (self, dmut context : &Validator, type : &SliceAllocatorExpr, parentMutable : bool, isMutable : bool, isDeeplyMutable : bool)-> &Type
        throws &ErrorMsg
    {
        if (type.isDynamic()) throw ErrorMsg::fatal (type.getLoc (), ValidateErrorMessage::USE_AS_TYPE);
        
        let innerType = self.validate (alias context, type.getValue (), isMutable-> false, parentMutable-> isMutable, isDeeplyMutable-> isDeeplyMutable, isRoot-> false);
        let size = context:.getCompileTimeInterpreter ().compute (context:.validateValue (type.getSize ()));
        
        match size {
            i : &IntValue => {
                ArrayType::new (type.getLoc (), innerType, i, isMutable-> (parentMutable && isMutable))
            }
            _ => throw ErrorMsg::fatal (size.getLoc (), format (ValidateErrorMessage::ARRAY_SIZE_TYPE, size.getType ()));
        }        
    }

    /**
     * Validate a var expression as a type
     * @params: 
     *   - context: the context of the validation
     *   - type: the type to validate
     *   - parentMutable: true if a decorator `mut` was found in the description of the parent
     *   - isMutable: true if a decorator `mut` was found in the description of this type (assuming isMutable => parentMutable)
     *   - isDeeplyMutable: true if a decorator `dmut` was found in the description
     * @returns: a type
     * @throws: &ErrorMsg: if the type is not valid
     */
    def validateVar (self, dmut context : &Validator, type : &VarExpr, parentMutable : bool, isMutable : bool, isDeeplyMutable : bool)-> &Type
        throws &ErrorMsg
    {
        context;
        isDeeplyMutable;
        match type.getLoc ().str () {
            NativeTypes::VOID => return VoidType::new (type.getLoc ());
            NativeTypes::C8 => return CharType::new (type.getLoc (), isMutable-> (parentMutable && isMutable));
            NativeTypes::C32 => return CharType::new (type.getLoc (), size-> 32u16, isMutable-> (parentMutable && isMutable));
            NativeTypes::U8 => return IntType::new (type.getLoc (), size-> 8u16, signed-> false, isMutable-> (parentMutable && isMutable));
            NativeTypes::U16 => return IntType::new (type.getLoc (), size-> 16u16, signed-> false, isMutable-> (parentMutable && isMutable));
            NativeTypes::U32 => return IntType::new (type.getLoc (), size-> 32u16, signed-> false, isMutable-> (parentMutable && isMutable));
            NativeTypes::U64 => return IntType::new (type.getLoc (), size-> 64u16, signed-> false, isMutable-> (parentMutable && isMutable));
            NativeTypes::USIZE => return IntType::new (type.getLoc (), size-> 0u16, signed-> false, isMutable-> (parentMutable && isMutable));
            NativeTypes::U8 => return IntType::new (type.getLoc (), size-> 8u16, signed-> true, isMutable-> (parentMutable && isMutable));
            NativeTypes::U16 => return IntType::new (type.getLoc (), size-> 16u16, signed-> true, isMutable-> (parentMutable && isMutable));
            NativeTypes::U32 => return IntType::new (type.getLoc (), size-> 32u16, signed-> true, isMutable-> (parentMutable && isMutable));
            NativeTypes::U64 => return IntType::new (type.getLoc (), size-> 64u16, signed-> true, isMutable-> (parentMutable && isMutable));
            NativeTypes::USIZE => return IntType::new (type.getLoc (), size-> 0u16, signed-> true, isMutable-> (parentMutable && isMutable));
            NativeTypes::BOOL => return BoolType::new (type.getLoc (), isMutable-> (parentMutable && isMutable));
            NativeTypes::F32 => return FloatType::new (type.getLoc (), size-> 32u16, isMutable-> (parentMutable && isMutable));
            NativeTypes::F64 => return FloatType::new (type.getLoc (), size-> 64u16, isMutable-> (parentMutable && isMutable));
        }

        /// TODO global types
        __pragma!fake_throw (&ErrorMsg);
        __pragma!panic ();
    }
    
    
}
