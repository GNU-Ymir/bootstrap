mod ymirc::semantic::validator::type;

import ymirc::semantic::validator::visitor;
import ymirc::semantic::validator::errors;

import ymirc::syntax::declaration::protection;
import ymirc::syntax::expression::_;
import ymirc::semantic::symbol::_;
import ymirc::syntax::keys;
import ymirc::lexing::word;

import ymirc::semantic::generator::_;
import ymirc::errors::_;
import ymirc::utils::format;

import std::collection::vec;
import std::collection::map;
import std::collection::set;
import std::io;

/**
 * The type validator is the class responsible for type expression validation
 */
pub class TypeValidator {

    /**
     * Create a new empty validator
     */
    pub self () {}


    /**
     * Validate an expression assuming its a type
     * @params: 
     *    - context: the context of the validation
     *    - type: the expression to validate
     *    - parentMutable: true if the type to return is flagged mutable
     *    - isDeeplyMutable: true if the type to return is flagged deeply mutable
     *    - isRoot: true if the validation is for a a root type (false for inner types), (remark: should be modifier only by this class ?)
     * @throws: &ErrorMsg, if the expression is not valid
     * @returns: a generator containing the validated type
     */
    pub def validate (self, dmut context : &Validator, type : &Expression, parentMutable : bool = true, isMutable : bool = false, isDeeplyMutable : bool = false, isRoot : bool = true)-> &Type
        throws &ErrorMsg
    {
        let ret = match type {
            UnitExpr () => { cast!{&Type} (NoneType::new (loc-> type.getLoc ())) }
            EmptyExpression () => { cast!{&Type} (NoneType::new (loc-> type.getLoc ())) }
            arr : &SliceAllocatorExpr => { self.validateSliceAllocator (alias context, arr, parentMutable, isMutable, isDeeplyMutable) }
            v : &VarExpr => { self.validateVar (alias context, v, parentMutable, isMutable, isDeeplyMutable) }
            dec : &DecoratedExpr => { self.validateDeco (alias context, dec, parentMutable, isDeeplyMutable, isRoot) }
            // un : &UnaryExpr => { self.validateUnary (alias context, un, parentMutable, isDeeplyMutable) }
            // tr : &TryExpr => { self.validateTry (alias context, tr, parentMutable, isDeeplyMutable) }
            lst : &ListExpr => {
                if (lst.isArray ()) {
                    self.validateSliceList (alias context, lst, parentMutable, isMutable, isDeeplyMutable)
                } else {
                    self.validateTupleList (alias context, lst, parentMutable, isMutable, isDeeplyMutable)
                }
            } 
            // call : &TemplateCall => { self.validateTemplateCall (alias context, cl, parentMutable, isDeeplyMutable) }            
            _ => {
                println ("TODO : ", type);
                __pragma!panic ();
            }
        };

        // TODO verify classref?
        return ret;
    }

    /**
     * Validate a decorated type 
     * @params: 
     *   - context: the context of the validation
     *   - type: the type to validate
     *   - parentMutable: true if a decorator `mut` was found in the description of the parent
     *   - isMutable: true if a decorator `mut` was found in the description of this type (assuming isMutable => parentMutable)
     *   - isDeeplyMutable: true if a decorator `dmut` was found in the description
     *   - isRoot: true iif this is the root of the type and not an inner type
     */
    def validateDeco (self, dmut context : &Validator, type : &DecoratedExpr, parentMutable : bool, isDeeplyMutable : bool, isRoot : bool)-> &Type
        throws &ErrorMsg
    {        
        let dmut found = HashMap!{Decorators, &Word}::new ();
        let dmut antiAffs = hmap #[
            Decorators::MUT  => hset #{Decorators::CONST, Decorators::DMUT, Decorators::PURE},
            Decorators::DMUT  => hset #{Decorators::CONST, Decorators::MUT, Decorators::PURE},
            Decorators::CONST  => hset #{Decorators::PURE, Decorators::MUT, Decorators::DMUT}
        ];

        for i in type.getDecorators () {
            match i.deco {
                Decorators::STATIC => {
                    throw ErrorMsg::fatal (i.loc, format (ValidateErrorMessage::UNDEF_DECORATOR_TYPE, Decorators::STATIC));
                }
                Decorators::CTE => {
                    throw ErrorMsg::fatal (i.loc, format (ValidateErrorMessage::UNDEF_DECORATOR_TYPE, Decorators::CTE));
                }
                Decorators::PURE => {
                    throw ErrorMsg::fatal (i.loc, format (ValidateErrorMessage::UNDEF_DECORATOR_TYPE, Decorators::PURE));
                }
                _ => {
                    match found.find (i.deco) {
                        Ok (l : _) => throw ErrorMsg::warn (i.loc, format (ValidateErrorMessage::MULTIPLE_DECORATORS, i.deco), notes-> [ErrorMsg::note (l, ""s8)]);
                    }

                    match antiAffs.find (i.deco) {
                        Ok (an : _) => {
                            for j in an {
                                match found.find (j) {
                                    Ok (l : _) => throw ErrorMsg::fatal (i.loc, format (ValidateErrorMessage::CONFLIT_DECORATORS, j, i.deco), notes-> [ErrorMsg::note (l, ""s8)]);
                                }
                            }
                        }
                    }
                    
                    found:.insert (i.deco, i.loc);
                }
            }
        }

        let (isMutable_, isDeeplyMutable_) = (Decorators::MUT in found, Decorators::DMUT in found);

        if (isRoot) {
            self.validate (alias context, type.getContent (), isMutable-> (isMutable_ || isDeeplyMutable_), isDeeplyMutable-> isDeeplyMutable_, parentMutable-> (isMutable_ || isDeeplyMutable_), isRoot-> false)
        } else {
            if (isMutable_ && (!parentMutable || isDeeplyMutable))
                match found.find (Decorators::MUT) {
                    Ok (l : _) => {
                        if (!parentMutable) {
                            throw ErrorMsg::fatal (l, ValidateErrorMessage::IMMUTABLE_PARENT)
                        } else {
                            throw ErrorMsg::fatal (l, ValidateErrorMessage::DEEPLY_INNER_TYPE)
                        }
                    }
                }

            // if (isDeeplyMutable_) {
            //     match found.find (Decorators::MUT) {
            //         Ok (l : _) => {
            //             throw ErrorMsg::fatal (l, ValidateErrorMessage::DEEPLY_INNER_TYPE)
            //         }
            //     }
            // }
            
            self.validate (alias context, type.getContent (), isMutable-> (isMutable_ || isDeeplyMutable), isDeeplyMutable-> isDeeplyMutable, parentMutable-> (isMutable_ || isDeeplyMutable), isRoot-> false)
        }
    }

    
    /**
     * Validate an array alloc as a type (e.g. [i32 ; 12u32])
     * @params: 
     *   - context: the context of the validation
     *   - type: the type to validate
     *   - parentMutable: true if a decorator `mut` was found in the description of the parent
     *   - isMutable: true if a decorator `mut` was found in the description of this type (assuming isMutable => parentMutable)
     *   - isDeeplyMutable: true if a decorator `dmut` was found in the description
     * @returns: a type 
     * @throws: &ErrorMsg: if the type is not valid
     */
    def validateSliceAllocator (self, dmut context : &Validator, type : &SliceAllocatorExpr, parentMutable : bool, isMutable : bool, isDeeplyMutable : bool)-> &Type
        throws &ErrorMsg
    {
        if (type.isDynamic()) throw ErrorMsg::fatal (type.getLoc (), ValidateErrorMessage::USE_AS_TYPE);
        
        let innerType = self.validate (alias context, type.getValue (), isMutable-> isDeeplyMutable, parentMutable-> (isMutable || isDeeplyMutable), isDeeplyMutable-> isDeeplyMutable, isRoot-> false);
        let size = context:.getCompileTimeInterpreter ().compute (context:.validateValue (type.getSize ()));
        
        match size {
            i : &IntValue => {
                ArrayType::new (type.getLoc (), innerType, i, isMutable-> (parentMutable && isMutable))
            }
            _ => throw ErrorMsg::fatal (size.getLoc (), format (ValidateErrorMessage::ARRAY_SIZE_TYPE, size.getType ()));
        }        
    }

    /**
     * Validate a slice list type (e.g. [i32])
     * @params: 
     *   - context: the context of the validation
     *   - type: the type to validate
     *   - parentMutable: true if a decorator `mut` was found in the description of the parent
     *   - isMutable: true if a decorator `mut` was found in the description of this type (assuming isMutable => parentMutable)
     *   - isDeeplyMutable: true if a decorator `dmut` was found in the description
     * @returns: a type
     * @throws: &ErrorMsg: if the type is not valid
     */
    def validateSliceList (self, dmut context : &Validator, type : &ListExpr, parentMutable : bool, isMutable : bool, isDeeplyMutable : bool)-> &Type
        throws &ErrorMsg
    {
        if (type.getParameters ().len != 1us) throw ErrorMsg::fatal (type.getLoc (), ValidateErrorMessage::USE_AS_TYPE);

        let innerType = self.validate (alias context, type.getParameters ()[0], isMutable-> isDeeplyMutable, parentMutable-> (isMutable || isDeeplyMutable), isDeeplyMutable-> isDeeplyMutable, isRoot-> false);
        
        SliceType::new (type.getLoc (), innerType, isMutable-> (parentMutable && isMutable))
    }


    /**
     * Validate a tuple type (e.g. (i32, u64))
     * @params: 
     *   - context: the context of the validation
     *   - type: the type to validate
     *   - parentMutable: true if a decorator `mut` was found in the description of the parent
     *   - isMutable: true if a decorator `mut` was found in the description of this type (assuming isMutable => parentMutable)
     *   - isDeeplyMutable: true if a decorator `dmut` was found in the description
     * @returns: a type
     * @throws: &ErrorMsg: if the type is not valid
     */
    def validateTupleList (self, dmut context : &Validator, type : &ListExpr, parentMutable : bool, isMutable : bool, isDeeplyMutable : bool)-> &Type
        throws &ErrorMsg
    {
        let dmut innerTypes = Vec!{&Type}::new ();
        for i in type.getParameters () {
            innerTypes:.push (self.validate (alias context, i, isMutable-> isDeeplyMutable, parentMutable-> (isMutable || isDeeplyMutable), isDeeplyMutable-> isDeeplyMutable, isRoot-> false));
        }

        TupleType::new (type.getLoc (), innerTypes[], isMutable-> (parentMutable && isMutable))
    }
       

    /**
     * Validate a var expression as a type
     * @params: 
     *   - context: the context of the validation
     *   - type: the type to validate
     *   - parentMutable: true if a decorator `mut` was found in the description of the parent
     *   - isMutable: true if a decorator `mut` was found in the description of this type (assuming isMutable => parentMutable)
     *   - isDeeplyMutable: true if a decorator `dmut` was found in the description
     * @returns: a type
     * @throws: &ErrorMsg: if the type is not valid
     */
    def validateVar (self, dmut context : &Validator, type : &VarExpr, parentMutable : bool, isMutable : bool, isDeeplyMutable : bool)-> &Type
        throws &ErrorMsg
    {
        context;
        isDeeplyMutable;
        match type.getLoc ().str () {
            NativeTypes::VOID => return VoidType::new (type.getLoc ());
            NativeTypes::C8 => return CharType::new (type.getLoc (), isMutable-> (parentMutable && isMutable));
            NativeTypes::C32 => return CharType::new (type.getLoc (), size-> 32u16, isMutable-> (parentMutable && isMutable));
            NativeTypes::U8 => return IntType::new (type.getLoc (), size-> 8u16, signed-> false, isMutable-> (parentMutable && isMutable));
            NativeTypes::U16 => return IntType::new (type.getLoc (), size-> 16u16, signed-> false, isMutable-> (parentMutable && isMutable));
            NativeTypes::U32 => return IntType::new (type.getLoc (), size-> 32u16, signed-> false, isMutable-> (parentMutable && isMutable));
            NativeTypes::U64 => return IntType::new (type.getLoc (), size-> 64u16, signed-> false, isMutable-> (parentMutable && isMutable));
            NativeTypes::USIZE => return IntType::new (type.getLoc (), size-> 0u16, signed-> false, isMutable-> (parentMutable && isMutable));
            NativeTypes::I8 => return IntType::new (type.getLoc (), size-> 8u16, signed-> true, isMutable-> (parentMutable && isMutable));
            NativeTypes::I16 => return IntType::new (type.getLoc (), size-> 16u16, signed-> true, isMutable-> (parentMutable && isMutable));
            NativeTypes::I32 => return IntType::new (type.getLoc (), size-> 32u16, signed-> true, isMutable-> (parentMutable && isMutable));
            NativeTypes::I64 => return IntType::new (type.getLoc (), size-> 64u16, signed-> true, isMutable-> (parentMutable && isMutable));
            NativeTypes::ISIZE => return IntType::new (type.getLoc (), size-> 0u16, signed-> true, isMutable-> (parentMutable && isMutable));
            NativeTypes::BOOL => return BoolType::new (type.getLoc (), isMutable-> (parentMutable && isMutable));
            NativeTypes::F32 => return FloatType::new (type.getLoc (), size-> 32u16, isMutable-> (parentMutable && isMutable));
            NativeTypes::F64 => return FloatType::new (type.getLoc (), size-> 64u16, isMutable-> (parentMutable && isMutable));
        }

        self.validateGlobalVar (alias context, type, parentMutable, isMutable, isDeeplyMutable)
    }

    /**
     * Validate a var reference that must be searched in global symbols
     * @params: 
     *   - context: the context of the validation
     *   - type: the type to validate
     *   - parentMutable: true if a decorator `mut` was found in the description of the parent
     *   - isMutable: true if a decorator `mut` was found in the description of this type (assuming isMutable => parentMutable)
     *   - isDeeplyMutable: true if a decorator `dmut` was found in the description
     * @returns: a type
     * @throws: &ErrorMsg: if the type is not valid
     */
    def validateGlobalVar (self, dmut context : &Validator, v : &VarExpr, parentMutable : bool, isMutable : bool, isDeeplyMutable : bool)-> &Type
        throws &ErrorMsg
    {
        // This function is close to LiteralValidator::validateGlobalVar, but returns a type instead of a value
        let dmut syms = context:.getGlobal (v.getLoc ().str ());
        if (syms.len == 0us) { // The variable was not found in the symbol table
            throw context:.createGlobalVarError (v.getLoc (), v.getLoc ().str ()); // We throw the according error
        } else {
            {
                return self.validateMultSymbols (v.getLoc (), alias context, alias syms, parentMutable, isMutable, isDeeplyMutable);
            } catch {
                err : &ErrorMsg => throw ErrorMsg::fatal (v.getLoc (), format (ValidateErrorMessage::UNDEF_VAR, v.getLoc ().str ()), notes-> [err]);        
            }
        }
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================          MULT SYMS           =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Transform symbol references into a single type
     *   - context: the context of the validation
     *   - syms: the list of symbols
     *   - parentMutable: true if a decorator `mut` was found in the description of the parent
     *   - isMutable: true if a decorator `mut` was found in the description of this type (assuming isMutable => parentMutable)
     *   - isDeeplyMutable: true if a decorator `dmut` was found in the description
     * @returns: a type containing multiple symbols (&MultSymType), or a single one (&Type)
     * @throws: 
     *   - &ErrorMsg: if the transformation fails
     */
    pub def validateMultSymbols (self, loc : &Word, dmut context : &Validator, dmut syms : [&Symbol], parentMutable : bool, isMutable : bool, _ : bool)-> &Type
        throws &ErrorMsg
    {
        let dmut res = Vec!{&Type}::new ();
        let dmut errors = Vec!{&ErrorMsg}::new ();
        let dmut valErrors = Vec!{&ErrorMsg}::new ();
        for i in 0us .. syms.len {
            {
                context:.pushReferent (alias syms [i]);
                match ref syms [i] {
                    dmut f : &FunctionSymbol => {
                        {
                            if (!f.isMethod ()) {
                                let val = context:.getFunctionValidator ().validateFuncPrototype (alias context, alias f);
                                valErrors:.push (ErrorMsg::fatal (loc, format (ValidateErrorMessage::USE_AS_TYPE, val)));
                            }
                        } catch { err : &ErrorMsg => { valErrors:.push (err); } }
                    }
                    c : &ConstructorSymbol => {
                        valErrors:.push (ErrorMsg::fatal (c.getLoc (), format (ValidateErrorMessage::USE_AS_TYPE, c)));
                    }
                    m : &ModuleSymbol => {
                        valErrors:.push (ErrorMsg::fatal (loc, format (ValidateErrorMessage::USE_AS_TYPE, ModuleRefValue::new (loc, m))));
                    }
                    dmut a : &AkaSymbol => { // Aka are sometimes types, there is a special function to handle that
                        self.validateAkaSymbolMultSym (loc, alias context, alias a, alias res, alias valErrors);
                    }
                    dmut t : &TemplateSymbol => { // Templates are sometimes types, there is a special function to handle that
                        self.validateTemplateSymbolMultSym (loc, alias context, alias t, alias res, alias valErrors);
                    }
                    dmut c : &ClassSymbol => { // class are types
                        let type = context:.getClassValidator ():.validate (alias context, alias c, inModule-> false);
                        res:.push (type.clone (isMutable-> (parentMutable && isMutable)));
                    } 
                    dmut s : &StructSymbol => { // struct are also types
                        let type = context:.getStructValidator ().validate (alias context, alias s);
                        res:.push (type.clone (isMutable-> (parentMutable && isMutable)));
                    } 
                    dmut tr : &TraitSymbol => { // Traits are also types
                        let type = context:.getTraitValidator ().validate (alias context, alias tr);
                        res:.push (type); // no need to clone, the type is necessarily immutable
                    }
                    _ => {
                        println ("TODO : ", (syms [i])::typeinfo.name);
                        __pragma!panic ();
                    }
                }
            } exit {
                context:.popReferent ();
            } catch {
                err : &ErrorMsg => {
                    errors:.push (err);
                }
            }
        }

        // There are errors in type validation
        if (errors.len () != 0us) throw ErrorMsg::list (errors[]);

        if (res.len () == 1us) { 
            res[][0us]
        } else {
            if (res.len () == 0us) { // There are no values
                if (valErrors.len () != 0us) throw ErrorMsg::list (valErrors[]); // It has to be because of value errors
                else __pragma!panic ();
            }
            
            cast!{&Type} (MultSymType::new (loc, res[], prettyStr-> loc.str ()))
        }

    }

    /**
     * Aka symbol may refer to types, or to values
     * In order to show the correct error, we should try both validation
     * @params: 
     *   - loc: the location of the symbol reference
     *   - context: the context of the validation
     *   - sym: the symbol to validate
     * @throws: 
     *   - &ErrorMsg: if the aka is malformed (but not a value)
     * @returns: 
     *   - res: add the value to the vec
     *   - valErrors: add an error, if the aka is a value (but not malformed)
     */
    def validateAkaSymbolMultSym (self, loc : &Word, dmut context : &Validator, dmut sym : &AkaSymbol, dmut res : &Vec!{&Type}, dmut valErrors : &Vec!{&ErrorMsg})
        throws &ErrorMsg
    {
        {
            res:.push (context:.getAkaValidator ().validateType (alias context, alias sym));
        } catch {
            err : &ErrorMsg => { // There are two possibilities 
                {
                    let val = context:.getAkaValidator ().validateValue (alias context, alias sym); // 1) it's a value
                    valErrors:.push (ErrorMsg::fatal (loc, format (ValidateErrorMessage::USE_AS_TYPE, val))); // Then we add no value, but add an error in valErrors
                } catch { // 2) it is just malformed
                    _ => throw err;
                }
            }
        }
    }   

    /**
     * Template symbol may refer to types, or to values
     * In order to show the correct error, we should try both validation
     * @params: 
     *   - loc: the location of the symbol reference
     *   - context: the context of the validation
     *   - sym: the symbol to validate
     * @throws: 
     *   - &ErrorMsg: if the template is malformed (but not a value)
     * @returns: 
     *   - res: add the value to the vec
     *   - valErrors: add an error, if the template is a value (but not malformed)
     */
    def validateTemplateSymbolMultSym (self, loc : &Word, dmut context : &Validator, dmut sym : &TemplateSymbol, dmut res : &Vec!{&Type}, dmut valErrors : &Vec!{&ErrorMsg})
        throws &ErrorMsg
    {
        {
            res:.push (context:.getTemplateValidator ().validateType (alias context, alias sym));
        } catch {
            err : &ErrorMsg => { // There are two possibilities 
                {
                    let val = context:.getTemplateValidator ().validateValue (alias context, alias sym); // 1) it's a value
                    valErrors:.push (ErrorMsg::fatal (loc, format (ValidateErrorMessage::USE_AS_TYPE, val))); // Then we add no value, but add an error in valErrors
                } catch { // 2) it is just malformed
                    _ => throw err;
                }
            }
        }
    }


    
}
