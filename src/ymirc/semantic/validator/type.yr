mod ymirc::semantic::validator::type;

import ymirc::semantic::validator::visitor;
import ymirc::semantic::validator::errors;

import ymirc::syntax::declaration::protection;
import ymirc::syntax::expression::_;
import ymirc::semantic::symbol::_;
import ymirc::syntax::keys;
import ymirc::lexing::word;

import ymirc::semantic::generator::_;
import ymirc::semantic::validator::template::_;
import ymirc::errors::_;
import ymirc::utils::format;

import std::collection::vec;
import std::collection::map;
import std::collection::set;
import std::io;

/**
 * The type validator is the class responsible for type expression validation
 */
pub class TypeValidator {

    /**
     * Create a new empty validator
     */
    pub self () {}


    /**
     * Validate an expression assuming its a type
     * @params: 
     *    - context: the context of the validation
     *    - type: the expression to validate
     *    - parentMutable: true if the type to return is flagged mutable
     *    - isDeeplyMutable: true if the type to return is flagged deeply mutable
     *    - isRoot: true if the validation is for a a root type (false for inner types), (remark: should be modifier only by this class ?)
     * @throws: &ErrorMsg, if the expression is not valid
     * @returns: a generator containing the validated type
     */
    pub def validate (self, dmut context : &Validator, type : &Expression, parentMutable : bool = true, isMutable : bool = false, isDeeplyMutable : bool = false, isRoot : bool = true)-> &Type
        throws &ErrorMsg
    {
        let ret = match type {
            UnitExpr () => { cast!{&Type} (NoneType::new (loc-> type.getLoc ())) }
            EmptyExpression () => { cast!{&Type} (NoneType::new (loc-> type.getLoc ())) }
            arr : &SliceAllocatorExpr => { self.validateSliceAllocator (alias context, arr, parentMutable, isMutable, isDeeplyMutable) }
            call : &TemplateCallExpr => { self.validateTemplateCall (alias context, call, parentMutable, isMutable, isDeeplyMutable) }
            v : &VarExpr => { self.validateVar (alias context, v, parentMutable, isMutable, isDeeplyMutable) }
            p : &PathExpr => { self.validatePath (alias context, p, parentMutable, isMutable, isDeeplyMutable) }
            b : &BinaryExpr => { self.validateBinary (alias context, b, parentMutable, isMutable, isDeeplyMutable) }
            u : &UnaryExpr => { self.validateUnary (alias context, u, parentMutable, isMutable, isDeeplyMutable) }
            r : &RangeTypeExpr => { self.validateRangeType (alias context, r, parentMutable, isMutable, isDeeplyMutable) }
            dec : &DecoratedExpr => { self.validateDeco (alias context, dec, parentMutable, isDeeplyMutable, isRoot) }
            lst : &ListExpr => {
                if (lst.isArray ()) {
                    self.validateSliceList (alias context, lst, parentMutable, isMutable, isDeeplyMutable)
                } else {
                    self.validateTupleList (alias context, lst, parentMutable, isMutable, isDeeplyMutable)
                }
            } 
            wrapped : &TypeWrapperExpr => {
                self.validateWrappedType (alias context, wrapped, parentMutable, isMutable, isDeeplyMutable)
            }
            list : &TypeListWrapperExpr => {
                self.validateListWrapperType (alias context, list, parentMutable, isMutable, isDeeplyMutable)
            }
            intr : &IntrinsicExpr => {
                self.validateIntrinsicType (alias context, intr, parentMutable, isMutable, isDeeplyMutable)
            }
            _ => {
                throw ErrorMsg::fatal (type.getLoc (), ValidateErrorMessage::USE_AS_TYPE);
            }
        };

        // TODO verify classref?
        return ret;
    }

    /**
     * Validate a decorated type 
     * @params: 
     *   - context: the context of the validation
     *   - type: the type to validate
     *   - parentMutable: true if a decorator `mut` was found in the description of the parent
     *   - isMutable: true if a decorator `mut` was found in the description of this type (assuming isMutable => parentMutable)
     *   - isDeeplyMutable: true if a decorator `dmut` was found in the description
     *   - isRoot: true iif this is the root of the type and not an inner type
     */
    def validateDeco (self, dmut context : &Validator, type : &DecoratedExpr, parentMutable : bool, isDeeplyMutable : bool, isRoot : bool)-> &Type
        throws &ErrorMsg
    {        
        let dmut found = HashMap!{Decorators, &Word}::new ();
        let dmut antiAffs = hmap #[
            Decorators::MUT  => hset #{Decorators::CONST, Decorators::DMUT, Decorators::PURE},
            Decorators::DMUT  => hset #{Decorators::CONST, Decorators::MUT, Decorators::PURE},
            Decorators::CONST  => hset #{Decorators::PURE, Decorators::MUT, Decorators::DMUT}
        ];

        for i in type.getDecorators () {
            match i.deco {
                Decorators::LAZY => {
                    throw ErrorMsg::fatal (i.loc, format (ValidateErrorMessage::UNDEF_DECORATOR_TYPE, Decorators::LAZY));
                }
                Decorators::CTE => {
                    throw ErrorMsg::fatal (i.loc, format (ValidateErrorMessage::UNDEF_DECORATOR_TYPE, Decorators::CTE));
                }
                Decorators::PURE => {
                    throw ErrorMsg::fatal (i.loc, format (ValidateErrorMessage::UNDEF_DECORATOR_TYPE, Decorators::PURE));
                }
                _ => {
                    match found.find (i.deco) {
                        Ok (l : _) => throw ErrorMsg::warn (i.loc, format (ValidateErrorMessage::MULTIPLE_DECORATORS, i.deco), notes-> [ErrorMsg::note (l, ""s8)]);
                    }

                    match antiAffs.find (i.deco) {
                        Ok (an : _) => {
                            for j in an {
                                match found.find (j) {
                                    Ok (l : _) => throw ErrorMsg::fatal (i.loc, format (ValidateErrorMessage::CONFLIT_DECORATORS, j, i.deco), notes-> [ErrorMsg::note (l, ""s8)]);
                                }
                            }
                        }
                    }
                    
                    found:.insert (i.deco, i.loc);
                }
            }
        }

        let (isMutable_, isDeeplyMutable_) = (Decorators::MUT in found, Decorators::DMUT in found);

        if (isRoot) {
            self.validate (alias context, type.getContent (), isMutable-> (isMutable_ || isDeeplyMutable_), isDeeplyMutable-> isDeeplyMutable_, parentMutable-> (isMutable_ || isDeeplyMutable_), isRoot-> false)
        } else {
            if (isMutable_ && (!parentMutable || isDeeplyMutable))
                match found.find (Decorators::MUT) {
                    Ok (l : _) => {
                        if (!parentMutable) {
                            throw ErrorMsg::fatal (l, ValidateErrorMessage::IMMUTABLE_PARENT)
                        } else {
                            throw ErrorMsg::fatal (l, ValidateErrorMessage::DEEPLY_INNER_TYPE)
                        }
                    }
                }

            // if (isDeeplyMutable_) {
            //     match found.find (Decorators::MUT) {
            //         Ok (l : _) => {
            //             throw ErrorMsg::fatal (l, ValidateErrorMessage::DEEPLY_INNER_TYPE)
            //         }
            //     }
            // }
            
            self.validate (alias context, type.getContent (), isMutable-> (isMutable_ || isDeeplyMutable), isDeeplyMutable-> isDeeplyMutable, parentMutable-> (isMutable_ || isDeeplyMutable), isRoot-> false)
        }
    }

    
    /**
     * Validate an array alloc as a type (e.g. [i32 ; 12u32])
     * @params: 
     *   - context: the context of the validation
     *   - type: the type to validate
     *   - parentMutable: true if a decorator `mut` was found in the description of the parent
     *   - isMutable: true if a decorator `mut` was found in the description of this type (assuming isMutable => parentMutable)
     *   - isDeeplyMutable: true if a decorator `dmut` was found in the description
     * @returns: a type 
     * @throws: &ErrorMsg: if the type is not valid
     */
    def validateSliceAllocator (self, dmut context : &Validator, type : &SliceAllocatorExpr, parentMutable : bool, isMutable : bool, isDeeplyMutable : bool)-> &Type
        throws &ErrorMsg
    {
        if (type.isDynamic()) throw ErrorMsg::fatal (type.getLoc (), ValidateErrorMessage::USE_AS_TYPE);
        
        let innerType = self.validate (alias context, type.getValue (), isMutable-> isDeeplyMutable, parentMutable-> (isMutable || isDeeplyMutable), isDeeplyMutable-> isDeeplyMutable, isRoot-> false);
        let size = context:.getCompileTimeInterpreter ().computeInt (context:.validateValue (type.getSize ()), signed-> false);        
        let tabSize = {
            size.to!usize () 
        } catch {
            _ => throw ErrorMsg::fatal (type.getSize ().getLoc (), format (ValidateErrorMessage::OVERFLOW_CAPACITY, IntType::new (type.getSize ().getLoc (), size-> 0u16, signed-> false), size, u64::max));
        };
                
        ArrayType::new (type.getLoc (), innerType, int::usize (type.getSize ().getLoc (), tabSize), isMutable-> (parentMutable && isMutable))
    }

    /**
     * Validate a slice list type (e.g. [i32])
     * @params: 
     *   - context: the context of the validation
     *   - type: the type to validate
     *   - parentMutable: true if a decorator `mut` was found in the description of the parent
     *   - isMutable: true if a decorator `mut` was found in the description of this type (assuming isMutable => parentMutable)
     *   - isDeeplyMutable: true if a decorator `dmut` was found in the description
     * @returns: a type
     * @throws: &ErrorMsg: if the type is not valid
     */
    def validateSliceList (self, dmut context : &Validator, type : &ListExpr, parentMutable : bool, isMutable : bool, isDeeplyMutable : bool)-> &Type
        throws &ErrorMsg
    {
        if (type.getParameters ().len != 1us) throw ErrorMsg::fatal (type.getLoc (), ValidateErrorMessage::USE_AS_TYPE);

        let innerType = self.validate (alias context, type.getParameters ()[0], isMutable-> isDeeplyMutable, parentMutable-> (isMutable || isDeeplyMutable), isDeeplyMutable-> isDeeplyMutable, isRoot-> false);
        
        SliceType::new (type.getLoc (), innerType, isMutable-> (parentMutable && isMutable))
    }


    /**
     * Validate a tuple type (e.g. (i32, u64))
     * @params: 
     *   - context: the context of the validation
     *   - type: the type to validate
     *   - parentMutable: true if a decorator `mut` was found in the description of the parent
     *   - isMutable: true if a decorator `mut` was found in the description of this type (assuming isMutable => parentMutable)
     *   - isDeeplyMutable: true if a decorator `dmut` was found in the description
     * @returns: a type
     * @throws: &ErrorMsg: if the type is not valid
     */
    def validateTupleList (self, dmut context : &Validator, type : &ListExpr, parentMutable : bool, isMutable : bool, isDeeplyMutable : bool)-> &Type
        throws &ErrorMsg
    {
        let dmut innerTypes = Vec!{&Type}::new ();
        for i in type.getParameters () {
            innerTypes:.push (self.validate (alias context, i, isMutable-> isDeeplyMutable, parentMutable-> (isMutable || isDeeplyMutable), isDeeplyMutable-> isDeeplyMutable, isRoot-> false));
        }

        TupleType::new (type.getLoc (), innerTypes[], isMutable-> (parentMutable && isMutable))
    }

    /**
     * Validate a tuple type from variadic template generation (e.g. (i32, i32...))
     * @params: 
     *    - context: the context of the validation
     *    - type: the type to validate
     *   - parentMutable: true if a decorator `mut` was found in the description of the parent
     *   - isMutable: true if a decorator `mut` was found in the description of this type (assuming isMutable => parentMutable)
     *   - isDeeplyMutable: true if a decorator `dmut` was found in the description
     * @returns: a type
     * @throws: &ErrorMsg: if the type is not valid
     */
    def validateListWrapperType (self, dmut context : &Validator, type : &TypeListWrapperExpr, parentMutable : bool, isMutable : bool, isDeeplyMutable : bool)-> &Type
        throws &ErrorMsg
    {
        let dmut innerTypes = Vec!{&Type}::new ();
        for i in type.getInners () {
            innerTypes:.push (self.validate (alias context, TypeWrapperExpr::new (i.getLoc (), i), isMutable-> isDeeplyMutable, parentMutable-> (isMutable || isDeeplyMutable), isDeeplyMutable-> isDeeplyMutable, isRoot-> false));
        }
        
        TupleType::new (type.getLoc (), innerTypes[], isMutable-> (parentMutable && isMutable))
    }

    
    /**
     * Validate a type wrapper 
     * @params: 
     *    - context: the context of the validation
     *    - type: the type to validate
     *    - parentMutable: true if a decorator 'mut' was found in the description of the parent
     *    - isMutable: true if a decorator 'mut' was found in the description of this type (assuming isMutable => parentMutable)
     *    - isDeeplyMutable: true if a decorator 'dmut' was found in the description
     * @returns: a type
     */
    def validateWrappedType (self, dmut _ : &Validator, type : &TypeWrapperExpr, parentMutable : bool, isMutable : bool, isDeeplyMutable : bool)-> &Type {    
        if (isDeeplyMutable) { type.getContent ().toDeeplyMutable () }
        else {
            type.getContent ().clone (isMutable-> (parentMutable && isMutable))
        }
    }

    /**
     * Validate an instrinsic type (for example typeof)
     * @params: 
     *    - context: the context of the validation
     *    - intr: the intrincic expression to validate into a type
     *    - parentMutable: true if a decorator 'mut' was found in the description of the parent
     *    - isMutable: true if a decorator 'mut' was found in the description of this type (assuming isMutable => parentMutable)
     *    - isDeeplyMutable: true if a decorator 'dmut' was found in the description
     * @returns: a type
     * @throws: 
     *    - &ErrorMsg: if the validation of the intrincic is impossible
     */
    def validateIntrinsicType (self, dmut context : &Validator, intr : &IntrinsicExpr, parentMutable : bool, isMutable : bool, isDeeplyMutable : bool)-> &Type
        throws &ErrorMsg
    {
        match intr.getType () {
            IntrinsicKeys::TYPEOF => { // typeof can return a type
                let content = context:.validateValue (intr.getContent ());
                let type = content.getType ();
                if (isDeeplyMutable) { type.toDeeplyMutable () }
                else {
                    type.clone (isMutable-> (parentMutable && isMutable))
                }
            }
            _ => { // other intrinsics are used for values only
                throw ErrorMsg::fatal (intr.getLoc (), ValidateErrorMessage::USE_AS_TYPE);
            }
        }
    }

    /**
     * Validate a var expression as a type
     * @params: 
     *   - context: the context of the validation
     *   - type: the type to validate
     *   - parentMutable: true if a decorator `mut` was found in the description of the parent
     *   - isMutable: true if a decorator `mut` was found in the description of this type (assuming isMutable => parentMutable)
     *   - isDeeplyMutable: true if a decorator `dmut` was found in the description
     * @returns: a type
     * @throws: &ErrorMsg: if the type is not valid
     */
    def validateVar (self, dmut context : &Validator, type : &VarExpr, parentMutable : bool, isMutable : bool, isDeeplyMutable : bool)-> &Type
        throws &ErrorMsg
    {
        context;
        isDeeplyMutable;
        match type.getLoc ().str () {
            NativeTypes::VOID => return VoidType::new (type.getLoc ());
            NativeTypes::C8 => return CharType::new (type.getLoc (), isMutable-> (parentMutable && isMutable));
            NativeTypes::C32 => return CharType::new (type.getLoc (), size-> 32u16, isMutable-> (parentMutable && isMutable));
            NativeTypes::U8 => return IntType::new (type.getLoc (), size-> 8u16, signed-> false, isMutable-> (parentMutable && isMutable));
            NativeTypes::U16 => return IntType::new (type.getLoc (), size-> 16u16, signed-> false, isMutable-> (parentMutable && isMutable));
            NativeTypes::U32 => return IntType::new (type.getLoc (), size-> 32u16, signed-> false, isMutable-> (parentMutable && isMutable));
            NativeTypes::U64 => return IntType::new (type.getLoc (), size-> 64u16, signed-> false, isMutable-> (parentMutable && isMutable));
            NativeTypes::USIZE => return IntType::new (type.getLoc (), size-> 0u16, signed-> false, isMutable-> (parentMutable && isMutable));
            NativeTypes::I8 => return IntType::new (type.getLoc (), size-> 8u16, signed-> true, isMutable-> (parentMutable && isMutable));
            NativeTypes::I16 => return IntType::new (type.getLoc (), size-> 16u16, signed-> true, isMutable-> (parentMutable && isMutable));
            NativeTypes::I32 => return IntType::new (type.getLoc (), size-> 32u16, signed-> true, isMutable-> (parentMutable && isMutable));
            NativeTypes::I64 => return IntType::new (type.getLoc (), size-> 64u16, signed-> true, isMutable-> (parentMutable && isMutable));
            NativeTypes::ISIZE => return IntType::new (type.getLoc (), size-> 0u16, signed-> true, isMutable-> (parentMutable && isMutable));
            NativeTypes::BOOL => return BoolType::new (type.getLoc (), isMutable-> (parentMutable && isMutable));
            NativeTypes::F32 => return FloatType::new (type.getLoc (), size-> 32u16, isMutable-> (parentMutable && isMutable));
            NativeTypes::F64 => return FloatType::new (type.getLoc (), size-> 64u16, isMutable-> (parentMutable && isMutable));
        }

        self.validateGlobalVar (alias context, type, parentMutable, isMutable, isDeeplyMutable)
    }

    
    /**
     * Validate a var reference that must be searched in global symbols
     * @params: 
     *   - context: the context of the validation
     *   - type: the type to validate
     *   - parentMutable: true if a decorator `mut` was found in the description of the parent
     *   - isMutable: true if a decorator `mut` was found in the description of this type (assuming isMutable => parentMutable)
     *   - isDeeplyMutable: true if a decorator `dmut` was found in the description
     * @returns: a type
     * @throws: &ErrorMsg: if the type is not valid
     */
    def validateGlobalVar (self, dmut context : &Validator, v : &VarExpr, parentMutable : bool, isMutable : bool, isDeeplyMutable : bool)-> &Type
        throws &ErrorMsg
    {
        // This function is close to LiteralValidator::validateGlobalVar, but returns a type instead of a value
        let dmut syms = context:.getGlobal (v.getLoc ().str ());
        if (syms.len == 0us) { // The variable was not found in the symbol table
            throw context:.createGlobalVarError (v.getLoc (), v.getLoc ().str ()); // We throw the according error
        } else {
            {
                return self.validateMultSymbols (v.getLoc (), alias context, alias syms, parentMutable, isMutable, isDeeplyMutable);
            } catch {
                err : &ErrorMsg => throw ErrorMsg::fatal (v.getLoc (), format (ValidateErrorMessage::UNDEF_VAR, v.getLoc ().str ()), notes-> [err]);        
            }
        }
    }

    /**
     * Validate a path expression
     * @params: 
     *   - context: the context of the validation
     *   - p: the path to validate
     *   - parentMutable: true if a decorator `mut` was found in the description of the parent
     *   - isMutable: true if a decorator `mut` was found in the description of this type (assuming isMutable => parentMutable)
     *   - isDeeplyMutable: true if a decorator `dmut` was found in the description
     * @returns: a type
     * @throws: &ErrorMsg: if the type is not valid
     */
    def validatePath (self, dmut context : &Validator, p : &PathExpr, parentMutable : bool, isMutable : bool, isDeeplyMutable : bool)-> &Type
        throws &ErrorMsg
    {
        let left = context:.validateValue (p.getLeft ());
        self.validatePath (alias context, p.getLoc (), left, p.getRight (), parentMutable, isMutable, isDeeplyMutable)
    }

    /**
     * Validate a binary expr
     * @params: 
     *   - context: the context of the validation
     *   - bin: the binary expr to validate
     *   - parentMutable: true if a decorator `mut` was found in the description of the parent
     *   - isMutable: true if a decorator `mut` was found in the description of this type (assuming isMutable => parentMutable)
     *   - isDeeplyMutable: true if a decorator `dmut` was found in the description
     * @returns: a type
     * @throws: &ErrorMsg: if the type is not valid
     */
    def validateBinary (self, dmut context : &Validator, bin : &BinaryExpr, parentMutable : bool, isMutable : bool, isDeeplyMutable : bool)-> &Type
        throws &ErrorMsg
    {
        let left = context:.validateValue (bin.getLeft ());
        match bin.getLoc ().str () {
            BinaryOperators::DCOLON => {
                return self.validatePath (alias context, bin.getLoc (), left, bin.getRight (), parentMutable, isMutable, isDeeplyMutable);
            }
        }

        throw ErrorMsg::fatal (bin.getLoc (), format (ValidateErrorMessage::UNDEFINED_BIN_OP, bin.getLoc ().str (), left, bin.getRight ()));
    }

    /**
     * Validate a path expr
     * @params: 
     *   - context: the context of the validation
     *   - loc: the location of the expr
     *   - left: the left operand of the operation
     *   - right: the right operand of the operation
     *   - parentMutable: true if a decorator `mut` was found in the description of the parent
     *   - isMutable: true if a decorator `mut` was found in the description of this type (assuming isMutable => parentMutable)
     *   - isDeeplyMutable: true if a decorator `dmut` was found in the description
     * @returns: a type
     * @throws: &ErrorMsg: if the type is not valid
     */
    def validatePath (self, dmut context : &Validator, loc : &Word, left : &Value, right : &Expression, parentMutable : bool, isMutable : bool, isDeeplyMutable : bool)-> &Type
        throws &ErrorMsg
    {
        match right {
            v : &VarExpr => {
                match left {
                    md : &ModuleRefValue => { // If this is a module that is simple
                        let dmut module = context:.getModuleFromRef (md);
                        let dmut res = alias (alias module:.getSymbols (v.getLoc ().str ()))[];
                        if (res.len != 0us) {
                            return self.validateMultSymbols (v.getLoc (), alias context, alias res, parentMutable, isMutable, isDeeplyMutable);
                        } catch {
                            err : &ErrorMsg => throw ErrorMsg::fatal (v.getLoc (), format (ValidateErrorMessage::UNDEF_VAR, v.getLoc ().str ()), notes-> [err]);        
                        } 
                    }
                    ms : &MultSymValue => { // The left operand returned multiple symbols
                        let dmut all = Vec!{dmut &Symbol}::new ();
                        for c in ms.getValues () {
                            match c {
                                md : &ModuleRefValue => { // Some of them are modules, so we can sub access them using var 'v'
                                    let dmut module = context:.getModuleFromRef (md);
                                    let dmut res = alias (alias module:.getSymbols (v.getLoc ().str ()))[];
                                    for i in 0us .. res.len { all:.push (alias res[i]); }
                                }
                            }
                        }
                        
                        if (all.len () != 0us) { // There are symbols whose name are 'v.getLoc ().str ()'
                            return self.validateMultSymbols (v.getLoc (), alias context, alias (alias all)[], parentMutable, isMutable, isDeeplyMutable);
                        } catch {
                            err : &ErrorMsg => throw ErrorMsg::fatal (v.getLoc (), format (ValidateErrorMessage::UNDEF_VAR, v.getLoc ().str ()), notes-> [err]);        
                        } 
                    }

                }
            }
        }

        throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_BIN_OP, loc.str (), left, right));
    }

    /**
     * Validate an unary expression type
     * @params: 
     *   - context: the context of the validation
     *   - loc: the location of the expr
     *   - un: the unary expr to validate
     *   - parentMutable: true if a decorator `mut` was found in the description of the parent
     *   - isMutable: true if a decorator `mut` was found in the description of this type (assuming isMutable => parentMutable)
     *   - isDeeplyMutable: true if a decorator `dmut` was found in the description
     * @returns: a type
     * @throws: &ErrorMsg: if the type is not valid
     */
    def validateUnary (self, dmut context : &Validator, un : &UnaryExpr, parentMutable : bool, isMutable : bool, isDeeplyMutable : bool)-> &Type
        throws &ErrorMsg
    {
        let inner = self.validate (alias context, un.getOperand (), isMutable-> isDeeplyMutable, parentMutable-> (isMutable || isDeeplyMutable), isDeeplyMutable-> isDeeplyMutable, isRoot-> false);
        match un.getLoc ().str () {            
            UnaryOperators::AND => { // Only addr unary can make a valid type
                match inner {
                    clRef : &ClassRefType => { // If it is a class then it create a ClassPtrType
                        ClassPtrType::new (un.getLoc (), isMutable-> ((parentMutable && isMutable) || isDeeplyMutable), clRef)
                    }
                    other : _ => { // Otherwise it is a standard pointer
                        PointerType::new (un.getLoc (), other, isMutable-> ((parentMutable && isMutable) || isDeeplyMutable))
                    }
                }
            }
            // Other unary are necessarily values, not types
            _ => throw ErrorMsg::fatal (un.getLoc (), format (ValidateErrorMessage::UNDEFINED_UN_OP, un.getLoc ().str (), inner));
        }
    }

    /**
     * Validate a range type expression
     * @params: 
     *   - context: the context of the validation     
     *   - r: the range to validate
     *   - parentMutable: true if a decorator `mut` was found in the description of the parent
     *   - isMutable: true if a decorator `mut` was found in the description of this type (assuming isMutable => parentMutable)
     *   - isDeeplyMutable: true if a decorator `dmut` was found in the description
     * @returns: a type
     * @throws: &ErrorMsg: if the type is not valid
     */
    def validateRangeType (self, dmut context : &Validator, r : &RangeTypeExpr, parentMutable : bool, isMutable : bool, isDeeplyMutable : bool)-> &Type
        throws &ErrorMsg
    {
        let inner = self.validate (alias context, r.getType (), isMutable-> isDeeplyMutable, parentMutable-> (isMutable || isDeeplyMutable), isDeeplyMutable-> isDeeplyMutable, isRoot-> false);
        match inner {
            IntType () => {
                return RangeType::new (r.getLoc (), inner, isMutable-> (parentMutable && isMutable));
            }
            CharType () => {
                return RangeType::new (r.getLoc (), inner, isMutable-> (parentMutable && isMutable));
            }
            FloatType () => {
                return RangeType::new (r.getLoc (), inner, isMutable-> (parentMutable && isMutable));
            }
            _ => { // range only works on int, float and char
                throw ErrorMsg::fatal (r.getLoc (), format (ValidateErrorMessage::UNDEFINED_BIN_OP, r.getLoc ().str (), inner, inner));
            }
        }
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================          MULT SYMS           =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Transform symbol references into a single type
     *   - context: the context of the validation
     *   - syms: the list of symbols
     *   - parentMutable: true if a decorator `mut` was found in the description of the parent
     *   - isMutable: true if a decorator `mut` was found in the description of this type (assuming isMutable => parentMutable)
     *   - isDeeplyMutable: true if a decorator `dmut` was found in the description
     * @returns: a type containing multiple symbols (&MultSymType), or a single one (&Type)
     * @throws: 
     *   - &ErrorMsg: if the transformation fails
     */
    pub def validateMultSymbols (self, loc : &Word, dmut context : &Validator, dmut syms : [&Symbol], parentMutable : bool, isMutable : bool, _ : bool)-> &Type
        throws &ErrorMsg
    {
        let dmut res = Vec!{&Type}::new ();
        let dmut errors = Vec!{&ErrorMsg}::new ();
        let dmut valErrors = Vec!{&ErrorMsg}::new ();
        for i in 0us .. syms.len {
            {
                context:.pushReferent (alias syms [i]);
                
                match ref syms [i] {
                    dmut f : &FunctionSymbol => {
                        {
                            if (!f.isMethod ()) {
                                let val = context:.getFunctionValidator ().validateFuncPrototype (alias context, alias f);
                                valErrors:.push (ErrorMsg::fatal (loc, format (ValidateErrorMessage::USE_AS_TYPE, val)));
                            }
                        } catch { err : &ErrorMsg => { valErrors:.push (err); } }
                    }
                    c : &ConstructorSymbol => {
                        valErrors:.push (ErrorMsg::fatal (c.getLoc (), format (ValidateErrorMessage::USE_AS_TYPE, c)));
                    }
                    m : &ModuleSymbol => {
                        valErrors:.push (ErrorMsg::fatal (loc, format (ValidateErrorMessage::USE_AS_TYPE, ModuleRefValue::new (loc, m))));
                    }
                    dmut a : &AkaSymbol => { // Aka are sometimes types, there is a special function to handle that
                        self.validateAkaSymbolMultSym (loc, alias context, alias a, alias res, alias valErrors);
                    }
                    dmut t : &TemplateSymbol => { // At this point, there is no way to determine if this is a type or a value
                        res:.push (TemplateRefType::new (loc, t));
                    }
                    dmut c : &ClassSymbol => { // class are types
                        let type = context:.getClassValidator ():.validate (alias context, alias c, inModule-> false);
                        res:.push (type.clone (isMutable-> (parentMutable && isMutable)));
                    } 
                    dmut s : &StructSymbol => { // struct are also types
                        let type = context:.getStructValidator ().validate (alias context, alias s);
                        res:.push (type.clone (isMutable-> (parentMutable && isMutable)));
                    } 
                    dmut tr : &TraitSymbol => { // Traits are also types
                        let type = context:.getTraitValidator ().validate (alias context, alias tr);
                        res:.push (type); // no need to clone, the type is necessarily immutable
                    }
                    dmut en : &EnumSymbol => {
                        let type = context:.getEnumValidator ().validate (alias context, alias en);
                        res:.push (type);
                    }
                    _ => {
                        println ("TODO : ", (syms [i])::typeinfo.name);
                        __pragma!panic ();
                    }
                }            
            } catch {
                err : &ErrorMsg => {
                    errors:.push (err);
                }
            }

            context:.popReferent ();
        }

        // There are errors in type validation
        if (errors.len () != 0us) throw ErrorMsg::list (errors[]);

        if (res.len () == 1us) { 
            res[][0us]
        } else {
            if (res.len () == 0us) { // There are no values
                if (valErrors.len () != 0us) throw ErrorMsg::list (valErrors[]); // It has to be because of value errors
                else __pragma!panic ();
            }
            
            cast!{&Type} (MultSymType::new (loc, res[], prettyStr-> loc.str ()))
        }

    }

    /**
     * Aka symbol may refer to types, or to values
     * In order to show the correct error, we should try both validation
     * @params: 
     *   - loc: the location of the symbol reference
     *   - context: the context of the validation
     *   - sym: the symbol to validate
     * @throws: 
     *   - &ErrorMsg: if the aka is malformed (but not a value)
     * @returns: 
     *   - res: add the value to the vec
     *   - valErrors: add an error, if the aka is a value (but not malformed)
     */
    def validateAkaSymbolMultSym (self, loc : &Word, dmut context : &Validator, dmut sym : &AkaSymbol, dmut res : &Vec!{&Type}, dmut valErrors : &Vec!{&ErrorMsg})
        throws &ErrorMsg
    {
        {
            res:.push (context:.getAkaValidator ().validateType (alias context, alias sym));
        } catch {
            err : &ErrorMsg => { // There are two possibilities 
                {
                    let val = context:.getAkaValidator ().validateValue (alias context, alias sym); // 1) it's a value
                    valErrors:.push (ErrorMsg::fatal (loc, format (ValidateErrorMessage::USE_AS_TYPE, val))); // Then we add no value, but add an error in valErrors
                } catch { // 2) it is just malformed
                    _ => throw err;
                }
            }
        }
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================          TEMPLATES           =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a template call expression
     * @params: 
     *    - context: tge context of the validation
     *    - t: the template call to validate
     * @returns: the validated type
     */
    def validateTemplateCall (self, dmut context : &Validator, t : &TemplateCallExpr, parentMutable : bool, isMutable : bool, isDeeplyMutable : bool)-> &Type
        throws &ErrorMsg
    {
        let list = context:.validateTemplateArgumentList (t.getRights ()); // validate the list of argument of the template call
        let type : &MultSymValue = match context:.validateValue (t.getLeft ()) {  // Validate the left operand of the call
            m : &MultSymValue => { m } 
            tmp : _ => { MultSymValue::new (t.getLeft ().getLoc (), [tmp], prettyStr-> format ("%", tmp)) } // we nned a multsym to be generic in the next validation
        };

        // Finally validate the call
        self.validateTemplateCallMultSym (alias context, type, list, parentMutable, isMutable, isDeeplyMutable)            
    }
        

    /**
     * Validate a template call where left and right operands are valdiated
     * @params: 
     *    - context: the context of the validation
     *    - left: the left operand
     *    - rights: the list of arguments
     * @returns: the result value
     * @throws:
     *    - &ErrorMsg: if the call is impossible
     */
    def validateTemplateCallMultSym (self, dmut context : &Validator, left : &MultSymValue, rights : [&Generator], parentMutable : bool, isMutable : bool, isDeeplyMutable : bool)-> &Type
        throws &ErrorMsg
    {
        // We store the results inside a vector, where to each valid values is associated the correct rewritter
        let dmut results = Vec!{(&TemplateRewriter, &Value)}::new ();
        let mut highestScore = 0u32;
        let dmut errors = Vec!{&ErrorMsg}::new ();
        for it in left.getValues () {
            {
                let rewriter = context:.getTemplateSolver ().validateCallValue (alias context, left.getLoc (), it, rights);
                if (rewriter.getScore () > highestScore) { // works and has the highest score 
                    highestScore = rewriter.getScore ();
                    results:.clear ();
                    results:.push ((rewriter, it));
                } else if (rewriter.getScore () == highestScore) { // works and has the same score as previous candidates
                    results:.push ((rewriter, it));
                }
            } catch {
                err : &ErrorMsg => { // does not work
                    errors:.push (err);
                }
            }
        }

        if (results.len () == 0us && errors.len () != 0us) { // No value succeded, and there was some errors
            throw ErrorMsg::list (errors[]);
        } 
        
        self.finalizeTemplateCallMultSym (alias context, left.getLoc (), results[], parentMutable, isMutable, isDeeplyMutable)   
    }

    /**
     * Finalize the validation of rewrittable template specialization
     * @params: 
     *     - context: the context of the validation
     *     - loc: the location of the specialization
     *     - list: the list of rewrittable specialization (@warning: assumed to contain at least one value)
     * @returns: the value containing the declared sybmols
     * @throws:
     *     - &ErrorMsg: if there was in error in the validation
     */
    def finalizeTemplateCallMultSym (self, dmut context : &Validator, loc : &Word, list : [(&TemplateRewriter, &Value)], parentMutable : bool, isMutable : bool, isDeeplyMutable : bool)-> &Type
        throws &ErrorMsg
    {
        let dmut finalResults = Vec!{dmut &Symbol}::new ();
        let dmut errors = Vec!{&ErrorMsg}::new ();

        for it in list { // for each value that can be rewritten 
            {
                let dmut val = alias context:.getTemplateDeclarator ().declare (alias context, loc, it._0, it._1); // rewrite the syntax template, declare it and return the declared symbol
                finalResults:.push (alias val); 
            } catch { 
                err : &ErrorMsg => { // symbol declaration failed (rewrite cannot fail)
                    errors:.push (err);
                }
            }            
        }

        if (finalResults.len () == 0us) { // if there is not symbol with validation 
            throw ErrorMsg::list (errors[]);
        }

        // transform the symbols into types
        self.validateMultSymbols (loc, alias context, alias (alias finalResults)[], parentMutable, isMutable, isDeeplyMutable)
    }
    
}
