in type;

use ymirc::semantic::validator::{visitor, errors, template::_};

use ymirc::syntax::declaration::protection;
use ymirc::syntax::expression::_;
use ymirc::semantic::symbol::_;
use ymirc::syntax::keys;
use ymirc::lexing::{word, tokens};

use ymirc::semantic::generator::_;
use ymirc::errors::_;
use ymirc::utils::format;
use std::{io, stream};

/**
 * The type validator is the class responsible for type expression validation
 */
pub record TypeValidator {

    /**
     * Create a new empty validator
     */
    pub self () {}

    /**
     * Validate an expression assuming its a type
     * @params: 
     *    - context: the context of the validation
     *    - type: the expression to validate
     *    - parentMutable: true if the type to return is flagged mutable
     *    - isDeeplyMutable: true if the type to return is flagged deeply mutable
     *    - isRoot: true if the validation is for a a root type (false for inner types), (remark: should be modifier only by this class ?)
     * @throws: &ErrorMsg, if the expression is not valid
     * @returns: a generator containing the validated type
     */
    pub fn validate (self, dmut context : &Validator, type : &Expression, parentMutable : bool = true, isMutable : bool = false, isDeeplyMutable : bool = false, isRoot : bool = true)-> &Type
        throws ErrorMsg
    {
        let ret = match type {
            UnitExpr ()                 => { copy NoneType (loc-> type.getLoc ()) }
            EmptyExpression ()          => { copy NoneType (loc-> type.getLoc ()) }
            arr : &SliceAllocatorExpr   => { self.validateSliceAllocator (alias context, arr, parentMutable, isMutable, isDeeplyMutable) }
            call : &TemplateCallExpr    => { self.validateTemplateCall (alias context, call, parentMutable, isMutable, isDeeplyMutable) }
            v : &VarExpr                => { self.validateVar (alias context, v, parentMutable, isMutable, isDeeplyMutable) }
            p : &PathExpr               => { self.validatePath (alias context, p, parentMutable, isMutable, isDeeplyMutable) }
            b : &BinaryExpr             => { self.validateBinary (alias context, b, parentMutable, isMutable, isDeeplyMutable) }
            u : &UnaryExpr              => { self.validateUnary (alias context, u, parentMutable, isMutable, isDeeplyMutable) }
            r : &RangeTypeExpr          => { self.validateRangeType (alias context, r, parentMutable, isMutable, isDeeplyMutable) }
            dec : &DecoratedExpr        => { self.validateDeco (alias context, dec, parentMutable, isDeeplyMutable, isRoot) }
            lst : &ListExpr             => {
                if (lst.isArray ()) {
                    self.validateSliceList (alias context, lst, parentMutable, isMutable, isDeeplyMutable)
                } else {
                    self.validateTupleList (alias context, lst, parentMutable, isMutable, isDeeplyMutable)
                }
            }
            lst : &ListMapExpr          => {
                self.validateMapList (alias context, lst, parentMutable, isMutable, isDeeplyMutable)
            }
            f : &FutureTypeExpr         => {
                self.validateFuture (alias context, f, parentMutable, isMutable, isDeeplyMutable)
            }
            wrapped : &TypeWrapperExpr  => {
                self.validateWrappedType (alias context, wrapped, parentMutable, isMutable, isDeeplyMutable)
            }
            list : &TypeListWrapperExpr => {
                self.validateListWrapperType (alias context, list, parentMutable, isMutable, isDeeplyMutable)
            }
            intr : &IntrinsicExpr       => {
                self.validateIntrinsicType (alias context, intr, parentMutable, isMutable, isDeeplyMutable)
            }
            f : &FunctionPtrTypeExpr    => {
                self.validateFuncPtrType (alias context, f, parentMutable, isMutable, isDeeplyMutable)
            }
            t : &TryExpr                => {
                self.validateTryType (alias context, t, parentMutable, isMutable, isDeeplyMutable)
            }
            p : &PragmaExpr             => {
                self.validatePragma (alias context, p, parentMutable, isMutable, isDeeplyMutable)
            }
            _                           => {
                throw copy ErrorMsg::fatal (type.getLoc (), ValidateErrorMessage::USE_AS_TYPE);
            }
        };

        // TODO verify classref?
        return ret;
    }

    /**
     * Validate a decorated type
     * @params:
     *   - context: the context of the validation
     *   - type: the type to validate
     *   - parentMutable: true if a decorator `mut` was found in the description of the parent
     *   - isMutable: true if a decorator `mut` was found in the description of this type (assuming isMutable => parentMutable)
     *   - isDeeplyMutable: true if a decorator `dmut` was found in the description
     */
    fn validateDeco (self, dmut context : &Validator, type : &DecoratedExpr, parentMutable : bool, isDeeplyMutable : bool, _ : bool)-> &Type
        throws ErrorMsg
    {
        let (isMutable_, isDeeplyMutable_) = (type.getDecorator () == Decorators::MUT, type.getDecorator () == Decorators::DMUT);
        if ((isMutable_ || isDeeplyMutable_) && (!parentMutable || isDeeplyMutable)) {
            if (!parentMutable) {
                throw copy ErrorMsg::fatal (type.getDecorator (), ValidateErrorMessage::IMMUTABLE_PARENT)
            } else {
                throw copy ErrorMsg::fatal (type.getDecorator (), ValidateErrorMessage::DEEPLY_INNER_TYPE)
            }
        }

        self.validate (alias context,
                       type.getContent (),
                       isMutable-> (isMutable_ || isDeeplyMutable_ || isDeeplyMutable),
                       isDeeplyMutable-> (isDeeplyMutable_ || isDeeplyMutable),
                       parentMutable-> (isMutable_ || isDeeplyMutable_ || isDeeplyMutable),
                       isRoot-> false)

    }


    /**
     * Validate an array alloc as a type (e.g. [i32 ; 12u32])
     * @params:
     *   - context: the context of the validation
     *   - type: the type to validate
     *   - parentMutable: true if a decorator `mut` was found in the description of the parent
     *   - isMutable: true if a decorator `mut` was found in the description of this type (assuming isMutable => parentMutable)
     *   - isDeeplyMutable: true if a decorator `dmut` was found in the description
     * @returns: a type
     * @throws: &ErrorMsg: if the type is not valid
     */
    fn validateSliceAllocator (self, dmut context : &Validator, type : &SliceAllocatorExpr, parentMutable : bool, isMutable : bool, isDeeplyMutable : bool)-> &Type
        throws ErrorMsg
    {
        // if (type.isDynamic()) throw copy ErrorMsg::fatal (type.getLoc (), ValidateErrorMessage::USE_AS_TYPE);

        let innerType = self.validate (alias context, type.getValue (), isMutable-> isDeeplyMutable, parentMutable-> (isMutable || isDeeplyMutable), isDeeplyMutable-> isDeeplyMutable, isRoot-> false);

        context.verifyCompleteType (type.getValue ().getLoc (), innerType, false);
        if (innerType.isOf!{&NoneType} ()) {
            throw copy ErrorMsg::fatal (type.getValue ().getLoc (), format (ValidateErrorMessage::EMPTY_ARRAY_INNER, innerType));
        }

        let size = context:.getCompileTimeInterpreter ().computeInt (context:.validateValue (type.getSize ()), signed-> false);
        let tabSize = {
            size.to!usize ()
        } catch {
            _ => throw copy ErrorMsg::fatal (type.getSize ().getLoc (), format (ValidateErrorMessage::OVERFLOW_CAPACITY, copy IntType (type.getSize ().getLoc (), size-> 0u16, signed-> false), size, u64::max));
        };

        if (tabSize > 1048576us) { // 1MB
            throw copy ErrorMsg::fatal (type.getSize ().getLoc (), format (ValidateErrorMessage::OVERFLOW_CAPACITY_ARRAY, tabSize, 1048576us));
        }

        copy ArrayType (type.getLoc (), innerType, tabSize, isMutable-> (parentMutable && isMutable))
    }

    /**
     * Validate a slice list type (e.g. [i32])
     * @params:
     *   - context: the context of the validation
     *   - type: the type to validate
     *   - parentMutable: true if a decorator `mut` was found in the description of the parent
     *   - isMutable: true if a decorator `mut` was found in the description of this type (assuming isMutable => parentMutable)
     *   - isDeeplyMutable: true if a decorator `dmut` was found in the description
     * @returns: a type
     * @throws: &ErrorMsg: if the type is not valid
     */
    fn validateSliceList (self, dmut context : &Validator, type : &ListExpr, parentMutable : bool, isMutable : bool, isDeeplyMutable : bool)-> &Type
        throws ErrorMsg
    {
        if (type.getParameters ().len != 1us) throw copy ErrorMsg::fatal (type.getLoc (), ValidateErrorMessage::USE_AS_TYPE);

        let innerType = self.validate (alias context, type.getParameters ()[0], isMutable-> isDeeplyMutable, parentMutable-> (isMutable || isDeeplyMutable), isDeeplyMutable-> isDeeplyMutable, isRoot-> false);
        context.verifyCompleteType (type.getLoc (), innerType, false);

        copy SliceType (type.getLoc (), innerType, isMutable-> (parentMutable && isMutable))
    }

    /**
     * Validate a map list type (e.g. [i32=> i32])
     * @params:
     *    - context: the context of the validation
     *    - type: the type to validate
     *    - parentMutable: true if a decorator `mut` was found in the description of the parent
     *    - isMutable: true if a decorator `mut` was found in the description of this type (assuming isMutable => parentMutable)
     *    - isDeeplyMutable: true if a decorator `dmut` was found in the description
     * @returns: a type
     * @throws: &ErrorMsg: if the type is not valid
     * */
    fn validateMapList (self, dmut context : &Validator, type : &ListMapExpr, parentMutable : bool, isMutable : bool, isDeeplyMutable : bool)-> &Type
        throws ErrorMsg
    {
        if (type.getKeys ().len != 1us)  throw copy ErrorMsg::fatal (type.getLoc (), ValidateErrorMessage::USE_AS_TYPE);
        let keyType = self.validate (alias context, type.getKeys ()[0], isMutable-> false, parentMutable-> false, isDeeplyMutable-> false, isRoot-> false);
        let valueType = self.validate (alias context, type.getValues ()[0], isMutable-> isDeeplyMutable, parentMutable-> (isMutable || isDeeplyMutable), isDeeplyMutable-> isDeeplyMutable, isRoot-> false);

        context:.verifyCompleteType (type.getLoc (), keyType, false);
        context:.verifyCompleteType (type.getLoc (), valueType, false);

        if (keyType.isMutable ()) { // [dmut [i32] => i32], no
            throw copy ErrorMsg::fatal (keyType.getLoc (), format (ValidateErrorMessage::MAP_KEY_MUTABLE, keyType));
        }

        // [i32 => i32], or [mut i32 => mut i32], [mut i32=> i32], ok
        let result = copy MapType (type.getLoc (), keyType, valueType,
                                   isMutable-> (parentMutable && isMutable));

        context:.createMapTypeInfo (type.getLoc (), result);
        result
    }

    /**
     * Validate a future type (e.g. future-> i32)
     * @params:
     *    - context: the context of the validation
     *    - type: the type to validate
     *    - parentMutable: true if a decorator `mut` was found in the description of the parent
     *    - isMutable: true if a decorator `mut` was found in the description of this type (assuming isMutable => parentMutable)
     *    - isDeeplyMutable: true if a decorator `dmut` was found in the description
     * @returns: a type
     * @throws: &ErrorMsg: if the type is not valid
     * */
    fn validateFuture (self, dmut context : &Validator, f : &FutureTypeExpr, parentMutable : bool, isMutable : bool, isDeeplyMutable : bool)-> &Type
        throws ErrorMsg
    {
        let inner = self.validate (alias context, f.getReturnType (),
                                   isMutable-> isDeeplyMutable,
                                   parentMutable-> (isMutable || isDeeplyMutable),
                                   isDeeplyMutable-> isDeeplyMutable, isRoot-> false);

        context.verifyCompleteType (f.getLoc (), inner, false);

        copy FutureType (f.getLoc (), inner, isMutable-> (parentMutable && isMutable))
    }

    /**
     * Validate a tuple type (e.g. (i32, u64))
     * @params:
     *   - context: the context of the validation
     *   - type: the type to validate
     *   - parentMutable: true if a decorator `mut` was found in the description of the parent
     *   - isMutable: true if a decorator `mut` was found in the description of this type (assuming isMutable => parentMutable)
     *   - isDeeplyMutable: true if a decorator `dmut` was found in the description
     * @returns: a type
     * @throws: &ErrorMsg: if the type is not valid
     */
    fn validateTupleList (self, dmut context : &Validator, type : &ListExpr, parentMutable : bool, isMutable : bool, isDeeplyMutable : bool)-> &Type
        throws ErrorMsg
    {
        let mut innerTypes : [mut &Type] = copy [{
            let inner = self.validate (alias context, i, isMutable-> isDeeplyMutable, parentMutable-> (isMutable || isDeeplyMutable), isDeeplyMutable-> isDeeplyMutable, isRoot-> false);
            context.verifyCompleteType (type.getLoc (), inner, false);
            inner
        } for i in type.getParameters ()];

        copy TupleType (type.getLoc (), innerTypes, isMutable-> (parentMutable && isMutable))
    }

    /**
     * Validate a tuple type from variadic template generation (e.g. (i32, i32...))
     * @params:
     *    - context: the context of the validation
     *    - type: the type to validate
     *   - parentMutable: true if a decorator `mut` was found in the description of the parent
     *   - isMutable: true if a decorator `mut` was found in the description of this type (assuming isMutable => parentMutable)
     *   - isDeeplyMutable: true if a decorator `dmut` was found in the description
     * @returns: a type
     * @throws: &ErrorMsg: if the type is not valid
     */
    fn validateListWrapperType (self, dmut context : &Validator, type : &TypeListWrapperExpr, parentMutable : bool, isMutable : bool, isDeeplyMutable : bool)-> &Type
        throws ErrorMsg
    {
        let mut innerTypes = copy [{
            let inner = self.validate (alias context, TypeWrapperExpr::new (i.getLoc (), i), isMutable-> isDeeplyMutable, parentMutable-> (isMutable || isDeeplyMutable), isDeeplyMutable-> isDeeplyMutable, isRoot-> false);
            context.verifyCompleteType (type.getLoc (), inner, false);
            inner
        } for i in type.getTypes ()];

        copy TupleType (type.getLoc (), innerTypes, isMutable-> (parentMutable && isMutable))
    }


    /**
     * Validate a type wrapper
     * @params:
     *    - context: the context of the validation
     *    - type: the type to validate
     *    - parentMutable: true if a decorator 'mut' was found in the description of the parent
     *    - isMutable: true if a decorator 'mut' was found in the description of this type (assuming isMutable => parentMutable)
     *    - isDeeplyMutable: true if a decorator 'dmut' was found in the description
     * @returns: a type
     */
    fn validateWrappedType (self, dmut _ : &Validator, type : &TypeWrapperExpr, parentMutable : bool, isMutable : bool, isDeeplyMutable : bool)-> &Type {
        if (isDeeplyMutable) { type.getType ().toDeeplyMutable () }
        else {
            let level = if (parentMutable && isMutable) { 1u32 } else { 0u32 };
            if (type.asIs () && type.getType ().isMutable ()) {
                type.getType ()
            } else {
                type.getType ().clone (level)
            }
        }
    }

    /**
     * Validate an instrinsic type (for example typeof)
     * @params:
     *    - context: the context of the validation
     *    - intr: the intrincic expression to validate into a type
     *    - parentMutable: true if a decorator 'mut' was found in the description of the parent
     *    - isMutable: true if a decorator 'mut' was found in the description of this type (assuming isMutable => parentMutable)
     *    - isDeeplyMutable: true if a decorator 'dmut' was found in the description
     * @returns: a type
     * @throws:
     *    - &ErrorMsg: if the validation of the intrincic is impossible
     */
    fn validateIntrinsicType (self, dmut context : &Validator, intr : &IntrinsicExpr, parentMutable : bool, isMutable : bool, isDeeplyMutable : bool)-> &Type
        throws ErrorMsg
    {
        match intr.getType () {
            IntrinsicKeys::TYPEOF => { // typeof can return a type
                let content = context:.validateValue (intr.getContent ());
                let type = content.getType ();
                if (isDeeplyMutable) { type.toDeeplyMutable () }
                else {
                    let level = if (parentMutable && isMutable) { 1u32 } else { 0u32 };
                    type.clone (level)
                }
            }
            _ => { // other intrinsics are used for values only
                throw copy ErrorMsg::fatal (intr.getLoc (), ValidateErrorMessage::USE_AS_TYPE);
            }
        }
    }

    /**
     * Validate a pragma expression that produces a type
     * @params:
     *    - context: the context of the validation
     *    - p: the pragma expression to validate
     *    - parentMutable: true if a decorator 'mut' was found in the description of the parent
     *    - isMutable: true if a decorator 'mut' was found in the description of this type (assuming isMutable => parentMutable)
     *    - isDeeplyMutable: true if a decorator 'dmut' was found in the description
     * @returns: a type
     * @throws:
     *    - &ErrorMsg: if the validation of the intrincic is impossible
     * */
    fn validatePragma (self, dmut context : &Validator, p : &PragmaExpr, parentMutable : bool, isMutable : bool, isDeeplyMutable : bool)-> &Type
        throws ErrorMsg
    {
        let type = context:.getPragmaValidator ().validateType (alias context, p);
        if (isDeeplyMutable) type.toDeeplyMutable ()
        else {
            let level = if (parentMutable && isMutable) { 1u32 } else { 0u32 };
            type.clone (level)
        }
    }

    /**
     * Validate a try expression type (ex: (i32)?)
     * @params:
     *    - context: the context of the validation
     *    - tr: the try expression to validate into a type
     *    - parentMutable: true if a decorator 'mut' was found in the description of the parent
     *    - isMutable: true if a decorator 'mut' was found in the description of this type (assuming isMutable => parentMutable)
     *    - isDeeplyMutable: true if a decorator 'dmut' was found in the description
     * @returns: a type
     * @throws:
     *    - &ErrorMsg: if the validation of the intrinsic is impossible
     * */
    fn validateTryType (self, dmut context : &Validator, tr : &TryExpr, parentMutable : bool, isMutable : bool, isDeeplyMutable : bool)-> &Type
        throws ErrorMsg
    {
        let inner = self.validate (alias context, tr.getValue (), isMutable-> isDeeplyMutable, parentMutable-> (isMutable || isDeeplyMutable), isDeeplyMutable-> isDeeplyMutable, isRoot-> false);
        context.verifyCompleteType (tr.getLoc (), inner, false);

        copy OptionType (tr.getLoc (), inner, isMutable-> (parentMutable && isMutable))
    }

    /**
     * Validate a function pointer type
     * @params:
     *    - context: the context of the validation
     *    - func: the function pointer type to validate
     *    - parentMutable: true if a decorator 'mut' was found in the description of the parent
     *    - isMutable: true if a decorator 'mut' was found in the description of this type (assuming isMutable => parentMutable)
     *    - isDeeplyMutable: true if a decorator 'dmut' was found in the description
     * @returns: a type
     * @throws:
     *    - &ErrorMsg: if the validation of the intrincic is impossible
     * * */
    fn validateFuncPtrType (self, dmut context : &Validator, func : &FunctionPtrTypeExpr, parentMutable : bool, isMutable : bool, _ : bool)-> &Type
        throws ErrorMsg
    {
        let mut types : [mut &Type] = [];
        let mut refs : [mut bool] = [];
        let mut lazys : [mut bool] = [];

        for vdecl in func.getParameters () {
            let (isRef, isLazy, t) = {
                let t = context:.validateTypeForVarDecl (vdecl.getType (), vdecl, canBeRef-> true, canBeLazy-> true);
                (vdecl.isRef (), vdecl.isLazy (), t)
            };

            types ~= [t];
            refs ~= [isRef];
            lazys ~= [isLazy];
        }

        let retType = context:.validateType (func.getReturn ());
        if (!func.isClosure ()) {
            copy FuncPtrType (func.getLoc (), refs, lazys, types, retType, isMutable-> (parentMutable && isMutable))
        } else {
            copy DelegateType (func.getLoc (), refs, lazys, types, retType, isMutable-> (parentMutable && isMutable))
        }
    }

    /**
     * Validate a var expression as a type
     * @params:
     *   - context: the context of the validation
     *   - type: the type to validate
     *   - parentMutable: true if a decorator `mut` was found in the description of the parent
     *   - isMutable: true if a decorator `mut` was found in the description of this type (assuming isMutable => parentMutable)
     *   - isDeeplyMutable: true if a decorator `dmut` was found in the description
     * @returns: a type
     * @throws: &ErrorMsg: if the type is not valid
     */
    fn validateVar (self, dmut context : &Validator, type : &VarExpr, parentMutable : bool, isMutable : bool, isDeeplyMutable : bool)-> &Type
        throws ErrorMsg
    {
        context;
        isDeeplyMutable;
        match type.getLoc ().str () {
            NativeTypes::VOID  => return copy VoidType (type.getLoc (), isMutable-> (isMutable && parentMutable));
            NativeTypes::C8    => return copy CharType (type.getLoc (), size-> 8u16, isMutable-> (parentMutable && isMutable));
            NativeTypes::C16   => return copy CharType (type.getLoc (), size-> 16u16, isMutable-> (parentMutable && isMutable));
            NativeTypes::C32   => return copy CharType (type.getLoc (), size-> 32u16, isMutable-> (parentMutable && isMutable));
            NativeTypes::U8    => return copy IntType (type.getLoc (), size-> 8u16, signed-> false, isMutable-> (parentMutable && isMutable));
            NativeTypes::U16   => return copy IntType (type.getLoc (), size-> 16u16, signed-> false, isMutable-> (parentMutable && isMutable));
            NativeTypes::U32   => return copy IntType (type.getLoc (), size-> 32u16, signed-> false, isMutable-> (parentMutable && isMutable));
            NativeTypes::U64   => return copy IntType (type.getLoc (), size-> 64u16, signed-> false, isMutable-> (parentMutable && isMutable));
            NativeTypes::USIZE => return copy IntType (type.getLoc (), size-> 0u16, signed-> false, isMutable-> (parentMutable && isMutable));
            NativeTypes::I8    => return copy IntType (type.getLoc (), size-> 8u16, signed-> true, isMutable-> (parentMutable && isMutable));
            NativeTypes::I16   => return copy IntType (type.getLoc (), size-> 16u16, signed-> true, isMutable-> (parentMutable && isMutable));
            NativeTypes::I32   => return copy IntType (type.getLoc (), size-> 32u16, signed-> true, isMutable-> (parentMutable && isMutable));
            NativeTypes::I64   => return copy IntType (type.getLoc (), size-> 64u16, signed-> true, isMutable-> (parentMutable && isMutable));
            NativeTypes::ISIZE => return copy IntType (type.getLoc (), size-> 0u16, signed-> true, isMutable-> (parentMutable && isMutable));
            NativeTypes::BOOL  => return copy BoolType (type.getLoc (), isMutable-> (parentMutable && isMutable));
            NativeTypes::F32   => return copy FloatType (type.getLoc (), size-> 32u16, isMutable-> (parentMutable && isMutable));
            NativeTypes::F64   => return copy FloatType (type.getLoc (), size-> 64u16, isMutable-> (parentMutable && isMutable));
            NativeTypes::F80   => return copy FloatType (type.getLoc (), size-> 80u16, isMutable-> (parentMutable && isMutable));
            NativeTypes::REAL  => return copy FloatType (type.getLoc (), size-> 0u16, isMutable-> (parentMutable && isMutable));
        }

        self.validateGlobalVar (alias context, type, parentMutable, isMutable, isDeeplyMutable)
    }


    /**
     * Validate a var reference that must be searched in global symbols
     * @params:
     *   - context: the context of the validation
     *   - type: the type to validate
     *   - parentMutable: true if a decorator `mut` was found in the description of the parent
     *   - isMutable: true if a decorator `mut` was found in the description of this type (assuming isMutable => parentMutable)
     *   - isDeeplyMutable: true if a decorator `dmut` was found in the description
     * @returns: a type
     * @throws: &ErrorMsg: if the type is not valid
     */
    fn validateGlobalVar (self, dmut context : &Validator, v : &VarExpr, parentMutable : bool, isMutable : bool, isDeeplyMutable : bool)-> &Type
        throws ErrorMsg
    {
        // This function is close to LiteralValidator::validateGlobalVar, but returns a type instead of a value
        let dmut syms = context:.getGlobal (v.getLoc ().str ());
        if (syms.len == 0us) { // The variable was not found in the symbol table
            throw context:.createGlobalVarError (v.getLoc (), v.getLoc ().str ()); // We throw the according error
        } else {
            return self.validateMultSymbols (v.getLoc (), alias context, alias syms, parentMutable, isMutable, isDeeplyMutable);
        }
    }

    /**
     * Validate a path expression
     * @params:
     *   - context: the context of the validation
     *   - p: the path to validate
     *   - parentMutable: true if a decorator `mut` was found in the description of the parent
     *   - isMutable: true if a decorator `mut` was found in the description of this type (assuming isMutable => parentMutable)
     *   - isDeeplyMutable: true if a decorator `dmut` was found in the description
     * @returns: a type
     * @throws: &ErrorMsg: if the type is not valid
     */
    fn validatePath (self, dmut context : &Validator, p : &PathExpr, parentMutable : bool, isMutable : bool, isDeeplyMutable : bool)-> &Type
        throws ErrorMsg
    {
        let left = context:.validateValue (p.getLeft ());
        self.validatePath (alias context, p.getLoc (), left, p.getRight (), parentMutable, isMutable, isDeeplyMutable)
    }

    /**
     * Validate a binary expr
     * @params:
     *   - context: the context of the validation
     *   - bin: the binary expr to validate
     *   - parentMutable: true if a decorator `mut` was found in the description of the parent
     *   - isMutable: true if a decorator `mut` was found in the description of this type (assuming isMutable => parentMutable)
     *   - isDeeplyMutable: true if a decorator `dmut` was found in the description
     * @returns: a type
     * @throws: &ErrorMsg: if the type is not valid
     */
    fn validateBinary (self, dmut context : &Validator, bin : &BinaryExpr, parentMutable : bool, isMutable : bool, isDeeplyMutable : bool)-> &Type
        throws ErrorMsg
    {
        let left = context:.validateValue (bin.getLeft ());
        match bin.getLoc ().str () {
            BinaryOperators::DCOLON => {
                return self.validatePath (alias context, bin.getLoc (), left, bin.getRight (), parentMutable, isMutable, isDeeplyMutable);

            }
            _ => {
                throw copy ErrorMsg::fatal (bin.getLoc (), format (ValidateErrorMessage::UNDEFINED_BIN_OP, bin.getLoc ().str (), left, bin.getRight ()));
            }
        }
    }

    /**
     * Validate a path expr
     * @params:
     *   - context: the context of the validation
     *   - loc: the location of the expr
     *   - left: the left operand of the operation
     *   - right: the right operand of the operation
     *   - parentMutable: true if a decorator `mut` was found in the description of the parent
     *   - isMutable: true if a decorator `mut` was found in the description of this type (assuming isMutable => parentMutable)
     *   - isDeeplyMutable: true if a decorator `dmut` was found in the description
     * @returns: a type
     * @throws: &ErrorMsg: if the type is not valid
     */
    fn validatePath (self, dmut context : &Validator, loc : &Word, left : &Value, right : &Expression, parentMutable : bool, isMutable : bool, isDeeplyMutable : bool)-> &Type
        throws ErrorMsg
    {
        let mut errorNotes : [&ErrorMsg] = [];

        match right {
            v : &VarExpr => {
                match left {
                    md : &ModuleRefValue => { // If this is a module that is simple
                        let dmut res = context:.getLocalFromMod (md, v.getLoc ().str ());
                        if (res.len != 0us) {
                            return self.validateMultSymbols (v.getLoc (), alias context, alias res, parentMutable, isMutable, isDeeplyMutable);
                        }

                        errorNotes = context:.createLocalVarError (v.getLoc (), md, v.getLoc ().str ());
                    }
                    ms : &MultSymValue => { // The left operand returned multiple symbols
                        let mut all : [dmut &Symbol] = [];
                        let mut errors : [&ErrorMsg] = [];
                        for c in ms.getValues () {
                            match c {
                                md : &ModuleRefValue => { // Some of them are modules, so we can sub access them using var 'v'
                                    all ~= context:.getLocalFromMod (md, v.getLoc ().str ());
                                    if (res.len == 0us) {
                                        errors ~= context:.createLocalVarError (v.getLoc (), md, v.getLoc ().str ());
                                    }
                                }
                            }
                        }

                        if (all.len != 0us) { // There are symbols whose name are 'v.getLoc ().str ()'
                            return self.validateMultSymbols (v.getLoc (), alias context, alias all, parentMutable, isMutable, isDeeplyMutable);
                        }

                        errorNotes = errors;
                    }
                }
            }
        }

        throw copy ErrorMsg::fatal (loc,
                                    format (ValidateErrorMessage::UNDEFINED_BIN_OP, loc.str (), left, right),
                                    notes-> errorNotes);
    }

    /**
     * Validate an unary expression type
     * @params:
     *   - context: the context of the validation
     *   - loc: the location of the expr
     *   - un: the unary expr to validate
     *   - parentMutable: true if a decorator `mut` was found in the description of the parent
     *   - isMutable: true if a decorator `mut` was found in the description of this type (assuming isMutable => parentMutable)
     *   - isDeeplyMutable: true if a decorator `dmut` was found in the description
     * @returns: a type
     * @throws: &ErrorMsg: if the type is not valid
     */
    fn validateUnary (self, dmut context : &Validator, un : &UnaryExpr, parentMutable : bool, isMutable : bool, isDeeplyMutable : bool)-> &Type
        throws ErrorMsg
    {
        let inner = self.validate (alias context, un.getOperand (), isMutable-> isDeeplyMutable, parentMutable-> (isMutable || isDeeplyMutable), isDeeplyMutable-> isDeeplyMutable, isRoot-> false);
        match un.getLoc ().str () {
            UnaryOperators::AND => { // Only addr unary can make a valid type
                match inner {
                    // & operator is only valid for class references
                    clRef : &ClassRefType => { // If it is a class then it create a ClassPtrType
                        if (!clRef.getSymbol ().isStruct ()) {
                            return clRef.createInstance (loc-> un.getLoc (), isMutable-> ((parentMutable && isMutable) || isDeeplyMutable), isInnerMutable-> (isDeeplyMutable || inner.isMutable ()));
                        } else { // & operator is only applicable on Class not on Structures
                            let msg = if (clRef.isMovable ()) {
                                ValidateErrorMessage::IS_AN_ENTITY
                            } else { ValidateErrorMessage::IS_A_RECORD };

                            throw copy ErrorMsg::fatal (un.getLoc (), format (ValidateErrorMessage::UNDEFINED_UN_OP, un.getLoc ().str (), inner),
                                                        notes-> copy [copy ErrorMsg::note (clRef.getLoc (), format (msg, clRef))]);
                        }
                    }
                    cptr : &ClassPtrType => {
                        if (cptr.isStruct ()) {
                            let msg = if (cptr.isMovable ()) {
                                ValidateErrorMessage::IS_AN_ENTITY
                            } else { ValidateErrorMessage::IS_A_RECORD };

                            throw copy ErrorMsg::fatal (un.getLoc (), format (ValidateErrorMessage::UNDEFINED_UN_OP, un.getLoc ().str (), inner),
                                                        notes-> copy [copy ErrorMsg::note (cptr.getLoc (), format (msg, cptr))]);
                        }
                    }
                }
            }
            UnaryOperators::STAR => { // * operator creates a pointer type for any type as long as it is a complete type
                context.verifyCompleteType (un.getLoc (), inner, construct-> false); // pointer is the only type that can store a movable type
                return copy PointerType (un.getLoc (), inner, isMutable-> ((parentMutable && isMutable) || isDeeplyMutable));
            }
        }

        // Other unary operators (i.e. '!', '-') are necessarily values, not types
        throw copy ErrorMsg::fatal (un.getLoc (), format (ValidateErrorMessage::UNDEFINED_UN_OP, un.getLoc ().str (), inner));
    }

    /**
     * Validate a range type expression
     * @params:
     *   - context: the context of the validation
     *   - r: the range to validate
     *   - parentMutable: true if a decorator `mut` was found in the description of the parent
     *   - isMutable: true if a decorator `mut` was found in the description of this type (assuming isMutable => parentMutable)
     *   - isDeeplyMutable: true if a decorator `dmut` was found in the description
     * @returns: a type
     * @throws: &ErrorMsg: if the type is not valid
     */
    fn validateRangeType (self, dmut context : &Validator, r : &RangeTypeExpr, parentMutable : bool, isMutable : bool, isDeeplyMutable : bool)-> &Type
        throws ErrorMsg
    {
        let inner = self.validate (alias context, r.getType (), isMutable-> isDeeplyMutable, parentMutable-> (isMutable || isDeeplyMutable), isDeeplyMutable-> isDeeplyMutable, isRoot-> false);
        match inner {
            i : &IntType => {
                let stepType = copy IntType (r.getLoc (), size-> i.getSize (), signed-> true);
                return copy RangeType (r.getLoc (), i, stepType, isMutable-> (parentMutable && isMutable) || isDeeplyMutable);
            }
            _ => { // range only works on int, float and char
                throw copy ErrorMsg::fatal (r.getLoc (), format (ValidateErrorMessage::UNDEFINED_BIN_OP, r.getLoc ().str (), inner, inner));
            }
        }
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================          MULT SYMS           =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Transform symbol references into a single type
     *   - context: the context of the validation
     *   - syms: the list of symbols
     *   - parentMutable: true if a decorator `mut` was found in the description of the parent
     *   - isMutable: true if a decorator `mut` was found in the description of this type (assuming isMutable => parentMutable)
     *   - isDeeplyMutable: true if a decorator `dmut` was found in the description
     * @returns: a single &Type
     * @throws:
     *   - &ErrorMsg: if the transformation fails, or multiple symbol are types
     */
    pub fn validateMultSymbols (self, loc : &Word, dmut context : &Validator, dmut syms : [&Symbol], parentMutable : bool, isMutable : bool, isDeeplyMutable : bool)-> &Type
        throws ErrorMsg
    {
        let mut res : [&Type] = [];
        let mut errors : [&ErrorMsg] = [];
        let mut valErrors : [&ErrorMsg] = [];
        for i in 0us .. syms.len {
            {
                context:.pushReferent (alias syms [i]);

                match ref syms [i] {
                    dmut f : &FunctionSymbol => {
                        {
                            if (!f.isMethod ()) {
                                let val = context:.getFunctionValidator ().validateFuncPrototype (alias context, alias f);
                                valErrors ~= [copy ErrorMsg::fatal (loc, format (ValidateErrorMessage::USE_AS_TYPE_VAL, val))];
                            }
                        } catch { err : &ErrorMsg => { valErrors ~= [err]; } }
                    }
                    c : &ConstructorSymbol => {
                        valErrors ~= [copy ErrorMsg::fatal (c.getLoc (), format (ValidateErrorMessage::USE_AS_TYPE_VAL, c))];
                    }
                    m : &ModuleSymbol => {
                        valErrors ~= [copy ErrorMsg::fatal (loc, format (ValidateErrorMessage::USE_AS_TYPE_VAL, m.getPath ().toStr ()))];
                    }
                    l : &LazyModuleSymbol => {
                        valErrors ~= [copy ErrorMsg::fatal (loc, format (ValidateErrorMessage::USE_AS_TYPE_VAL, l.getPath ().toStr ()))];
                    }
                    dmut a : &AkaSymbol => { // Aka are sometimes types, there is a special function to handle that
                        self.validateAkaSymbolMultSym (loc, alias context, alias a, ref res, ref valErrors, parentMutable, isMutable, isDeeplyMutable);
                    }
                    dmut t : &TemplateSymbol => { // At this point, there is no way to determine if this is a type or a value
                        res ~= [copy TemplateRefType (loc, t)];
                    }
                    dmut c : &ClassSymbol => { // class are types
                        let type = context:.getClassValidator ():.validate (alias context, alias c, inModule-> false);
                        let result = if (c.isStruct ()) {
                            let resMutable = (parentMutable && isMutable) || isDeeplyMutable;
                            type.createInstance (loc-> loc, isMutable-> resMutable, isInnerMutable-> resMutable)
                        } else {
                            let level = if (parentMutable && isMutable) { 1u32 } else { 0u32 };
                            type.clone (level)
                        };

                        res ~= [result];
                    }
                    dmut tr : &TraitSymbol => { // Traits are also types
                        let type = context:.getTraitValidator ().validate (alias context, alias tr);
                        res ~= [type]; // no need to clone, the type is necessarily immutable
                    }
                    dmut en : &EnumSymbol => {
                        let type = context:.getEnumValidator ().validate (alias context, alias en);
                        let level = if (parentMutable && isMutable) { 1u32 } else { 0u32 }
                        res ~= [type.clone (level)];
                    }
                    z : _ => {
                        valErrors ~= [copy ErrorMsg::fatal (loc, end-> z.getLoc (), format (ValidateErrorMessage::USE_AS_TYPE_VAL, z.getPath ()))];
                    }
                }
            } catch {
                err : &ErrorMsg => {
                    errors ~= [err];
                }
            }

            context:.popReferent ();
        }

        // There are errors in type validation
        if (errors.len != 0us) {
            let dmut form = copy StringStream ();
            for i, j in syms {
                if (i != 0us) form:.write (", ");
                form:.write (j.getPath ().toStr ());
            }

            throw copy ErrorMsg::fatal (loc, format (ValidateErrorMessage::INVALID_SYMBOLS, form[]), notes-> errors);
        }

        res = self.reduceMultSyms (res);
        if (res.len == 1us) {
            res [0]
        } else {
            if (res.len == 0us) { // There are no values
                if (valErrors.len != 0us) throw copy ErrorMsg::list (valErrors); // It has to be because of value errors
                else panic;
            }

            let mut notes : [&ErrorMsg] = [];
            for i in res {
                notes ~= [copy ErrorMsg::note (i.getLoc (), format (ValidateErrorMessage::CANDIDATE_ARE, i), oneLine-> true, withLoc-> true)];
            }

            throw copy ErrorMsg::fatal (loc, format (ValidateErrorMessage::MULTIPLE_SYMBOL_TYPES), notes-> notes);
        }
    }

    /**
     * Remove the identical values from the result multsym
     * */
    fn reduceMultSyms (self, res : [&Type])-> [&Type] {
        let mut final : [&Type] = [];
        for v in res {
            let mut found = false;
            for v2 in final {
                if v2 == v {
                    found = true;
                    break;
                }
            }
            if !found {
                final ~= [v];
            }
        }

        alias final
    }


    /**
     * Aka symbol may refer to types, or to values
     * In order to show the correct error, we should try both validation
     * @params:
     *   - loc: the location of the symbol reference
     *   - context: the context of the validation
     *   - sym: the symbol to validate
     * @throws:
     *   - &ErrorMsg: if the aka is malformed (but not a value)
     * @returns:
     *   - res: add the value to the vec
     *   - valErrors: add an error, if the aka is a value (but not malformed)
     */
    fn validateAkaSymbolMultSym (self, loc : &Word, dmut context : &Validator, dmut sym : &AkaSymbol, ref mut res : [&Type], ref mut valErrors : [&ErrorMsg], parentMutable : bool, isMutable : bool, isDeeplyMutable : bool)
        throws ErrorMsg
    {
        context:.getAkaValidator ():.validate (alias context, alias sym);
        match sym.getGenerator () {
            type : &Type => {
                if (isDeeplyMutable) res ~= [type.toDeeplyMutable ()];
                else {
                    let level = if (parentMutable && isMutable) { 1u32 } else { 0u32 };
                    res ~= [type.clone (level)];
                }
            }
            val : &Value => {
                valErrors ~= [ErrorMsg::fatal (loc, format (ValidateErrorMessage::USE_AS_TYPE_VAL, val))];
            }
            e : &ErrorGenerator => throw e.getErrorMessage ();
            _ => panic;
        };
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================          TEMPLATES           =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a template call expression
     * @params:
     *    - context: tge context of the validation
     *    - t: the template call to validate
     * @returns: the validated type
     */
    fn validateTemplateCall (self, dmut context : &Validator, t : &TemplateCallExpr, parentMutable : bool, isMutable : bool, isDeeplyMutable : bool)-> &Type
        throws ErrorMsg
    {
        let list = context:.validateTemplateArgumentList (t.getRights ()); // validate the list of argument of the template call
        let type : &MultSymValue = match context:.validateValue (t.getLeft ()) {  // Validate the left operand of the call
            m : &MultSymValue => { m }
            tmp : _ => { copy MultSymValue (t.getLeft ().getLoc (), [tmp], prettyStr-> format ("%", tmp)) } // we nned a multsym to be generic in the next validation
        };

        // Finally validate the call
        self.validateTemplateCallMultSym (alias context, t.getLoc (), type, list, parentMutable, isMutable, isDeeplyMutable)
    }


    /**
     * Validate a template call where left and right operands are valdiated
     * @params:
     *    - context: the context of the validation
     *    - left: the left operand
     *    - rights: the list of arguments
     * @returns: the result value
     * @throws:
     *    - &ErrorMsg: if the call is impossible
     */
    fn validateTemplateCallMultSym (self, dmut context : &Validator, loc : &Word, left : &MultSymValue, rights : [&Generator], parentMutable : bool, isMutable : bool, isDeeplyMutable : bool)-> &Type
        throws ErrorMsg
    {
        // We store the results inside a vector, where to each valid values is associated the correct rewriter
        let mut results : [(&TemplateRewriter, &Value)] = [];
        let mut highestScore = 0u32;
        let mut errors : [&ErrorMsg] = [];
        for it in left.getValues () {
            {
                let rewriter = context:.getTemplateSolver ().validateCallValue (alias context, left.getLoc (), it, rights);
                if (rewriter.getScore () > highestScore) { // works and has the highest score
                    highestScore = rewriter.getScore ();
                    results = [];
                    results ~= [(rewriter, it)];
                } else if (rewriter.getScore () == highestScore) { // works and has the same score as previous candidates
                    results ~= [(rewriter, it)];
                }
            } catch {
                err : &ErrorMsg => { // does not work
                    errors ~= [err];
                }
            }
        }

        if (results.len == 0us && errors.len != 0us) { // No value succeded, and there was some errors
            throw copy ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_TEMPLATE_CALL, left, rights, withTags-> copy ["withParams"]), notes-> errors);
        }

        {
            self.finalizeTemplateCallMultSym (alias context, left.getLoc (), results, parentMutable, isMutable, isDeeplyMutable)
        } catch {
            err : &ErrorMsg => {
                throw copy ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_TEMPLATE_CALL, left, rights, withTags-> copy ["withParams"]), notes-> copy [err]);
            }
        }
    }

    /**
     * Finalize the validation of rewrittable template specialization
     * @params:
     *     - context: the context of the validation
     *     - loc: the location of the specialization
     *     - list: the list of rewrittable specialization (@warning: assumed to contain at least one value)
     * @returns: the value containing the declared sybmols
     * @throws:
     *     - &ErrorMsg: if there was in error in the validation
     */
    fn finalizeTemplateCallMultSym (self, dmut context : &Validator, loc : &Word, list : [(&TemplateRewriter, &Value)], parentMutable : bool, isMutable : bool, isDeeplyMutable : bool)-> &Type
        throws ErrorMsg
    {
        let mut finalResults : [dmut &Symbol] = [];
        let mut errors : [&ErrorMsg] = [];

        for it in list { // for each value that can be rewritten
            {
                let dmut val = alias context:.getTemplateDeclarator ().declare (alias context, loc, it._0, it._1); // rewrite the syntax template, declare it and return the declared symbol
                finalResults ~= [alias val];
            } catch {
                err : &ErrorMsg => { // symbol declaration failed (rewrite cannot fail)
                    errors ~= [err];
                }
            }
        }

        if (finalResults.len == 0us) { // if there is not symbol with validation
            throw copy ErrorMsg::list (errors);
        }

        // transform the symbols into types
        self.validateMultSymbols (loc, alias context, alias finalResults, parentMutable, isMutable, isDeeplyMutable)
    }

}
