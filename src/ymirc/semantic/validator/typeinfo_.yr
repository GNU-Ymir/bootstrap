mod ymirc::semantic::validator::typeinfo_;

import ymirc::syntax::expression::_;
import ymirc::semantic::validator::visitor;
import ymirc::semantic::validator::errors;

import ymirc::semantic::symbol::base;
import ymirc::global::core_;

import ymirc::semantic::generator::_;
import ymirc::errors::_;
import ymirc::utils::format;
import ymirc::utils::bigint;
import ymirc::lexing::word;
import ymirc::lexing::tokens;
import ymirc::syntax::keys;

import std::collection::vec;
import std::algorithm::searching;
import std::io;
import std::conv;

/**
 * The validator responsible for the validation of 'typeinfo' expressions
 */
pub class TypeInfoValidator {

    /**
     * Create a new empty validator
     */
    pub self () {}


    /**
     * Validate a typeinfo expression
     * @params:
     *    - context: the context of the validation
     *    - i: the intrinsic expression to validate
     * @returns: the validated expression
     */
    pub fn validate (mut self, dmut context : &Validator, loc : &Word, type : &Type)-> &Value
        throws &ErrorMsg
    {
        let ti = context:.validateTypeInfo (loc);
        match type {
            b : &BoolType => {
                return self.validateScalarType (alias context, loc, ti, b, CoreNames::TYPEINFO_BOOL_ID);
            }
            it : &IntType => {
                if (it.isSigned ()) {
                    return self.validateScalarType (alias context, loc, ti, it, CoreNames::TYPEINFO_SIGNED_INT_ID);
                } else {
                    return self.validateScalarType (alias context, loc, ti, it, CoreNames::TYPEINFO_UNSIGNED_INT_ID);
                }
            }
            c : &CharType => {
                return self.validateScalarType (alias context, loc, ti, c, CoreNames::TYPEINFO_CHAR_ID);
            }
            f : &FloatType => {
                return self.validateScalarType (alias context, loc, ti, f, CoreNames::TYPEINFO_FLOAT_ID);
            }
            v : &VoidType => {
                return self.validateScalarType (alias context, loc, ti, v, CoreNames::TYPEINFO_VOID_ID);
            }

            d : &DelegateType => {
                return self.validateDelegateType (alias context, loc, ti, d);
            }
            f : &FuncPtrType => {
                return self.validateFuncPtrType (alias context, loc, ti, f);
            }
            a : &ArrayType => {
                return self:.validateArrayType (alias context, loc, ti, a);
            }
            p : &PointerType => {
                return self.validatePointerType (alias context, loc, ti, p);
            }
            r : &RangeType => {
                return self:.validateRangeType (alias context, loc, ti, r);
            }
            s : &SliceType => {
                return self.validateSliceType (alias context, loc, ti, s);
            }
            tu : &TupleType => {
                return self:.validateTupleType (alias context, loc, ti, tu);
            }
            c : &ClassPtrType => {
                return self.validateClassPtrType (alias context, loc, ti, c);
            }
            s : &StructType => {
                return self:.validateStructType (alias context, loc, ti, s);
            }
            c : &ClassRefType => {
                return self:.validateClassRefType (alias context, loc, ti, c);
            }
            o : &OptionType => {
                return self:.validateOptionType (alias context, loc, ti, o);
            }

            e : &EnumType => {
                return self:.validate (alias context, loc, e.getProxy ());
            }
        }

        throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::TYPE_HAS_NO_TYPEINFO, type));
    }

    /**
     * Validate the typeinfo of a scalar
     * @params:
     *    - loc: the location of the operation
     *    - ti: the typeinfo type
     *    - b: the bool type
     * */
    fn validateScalarType (self, dmut context : &Validator, loc : &Word, ti : &StructType, scal : &Type, code : [c8])-> &Value
        throws &ErrorMsg
    {
        let fieldnames = ti.getFieldNames ();
        let mut params : [mut &Value] = [UNIT_VALUE ; new fieldnames.len];
        params [0] = context:.validateTypeIDs (loc, code);
        params [1] = context:.getSizeofValidator ():.validate (alias context, loc, scal);

        let arrType = ArrayType::new (loc, ti, 0us);
        params [2] = context.createSliceAliasFromArray (loc, arrType, ArrayValue::new (loc, arrType, []));

        let name = format ("%", scal);
        params [3] = makeStringSliceValue (loc, name);

        StructCtorCallValue::new (loc, ti, params)
    }

    fn validateDelegateType (self, dmut context : &Validator, loc : &Word, ti : &StructType, d : &DelegateType)-> &Value {
        context; loc;
        ti;
        d;
        __pragma!panic ();
    }

    fn validateFuncPtrType (self, dmut context : &Validator, loc : &Word, ti : &StructType, f : &FuncPtrType)-> &Value {
        context; loc;
        ti;
        f;
        __pragma!panic ();
    }

    fn validateArrayType (self, dmut context : &Validator, loc : &Word, ti : &StructType, a : &ArrayType)-> &Value {
        context; loc;
        ti;
        a;
        __pragma!panic ();
    }

    fn validatePointerType (self, dmut context : &Validator, loc : &Word, ti : &StructType, p : &PointerType)-> &Value {
        context; loc;
        ti;
        p;
        __pragma!panic ();
    }

    fn validateRangeType (self, dmut context : &Validator, loc : &Word, ti : &StructType, p : &RangeType)-> &Value {
        context; loc;
        ti;
        p;
        __pragma!panic ();
    }

    fn validateSliceType (self, dmut context : &Validator, loc : &Word, ti : &StructType, s : &SliceType)-> &Value {
        context; loc;
        ti;
        s;
        __pragma!panic ();
    }

    fn validateTupleType (self, dmut context : &Validator, loc : &Word, ti : &StructType, t : &TupleType)-> &Value {
        context; loc;
        ti;
        t;
        __pragma!panic ();
    }

    fn validateClassPtrType (self, dmut context : &Validator, loc : &Word, ti : &StructType, c : &ClassPtrType)-> &Value {
        context; loc;
        ti;
        c;
        __pragma!panic ();
    }

    fn validateStructType (self, dmut context : &Validator, loc : &Word, ti : &StructType, s : &StructType)-> &Value {
        context; loc;
        ti;
        s;
        __pragma!panic ();
    }

    fn validateClassRefType (self, dmut context : &Validator, loc : &Word, ti : &StructType, c : &ClassRefType)-> &Value {
        context; loc;
        ti;
        c;
        __pragma!panic ();
    }

    fn validateOptionType (self, dmut context : &Validator, loc : &Word, ti : &StructType, t : &OptionType)-> &Value {
        context; loc;
        ti;
        t;
        __pragma!panic ();
    }


}
