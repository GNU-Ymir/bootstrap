mod ymirc::semantic::validator::interpret;

import ymirc::semantic::generator::_;
import ymirc::semantic::symbol::function;
import ymirc::semantic::validator::utf;
import ymirc::errors::message;
import std::io;
import ymirc::utils::bigint;
import ymirc::utils::bigfloat;

import ymirc::global::state;

import ymirc::lexing::word;
import ymirc::syntax::keys;
import ymirc::utils::format;
import ymirc::semantic::validator::errors;

import std::collection::vec;

/**
 * The compile time interpreter, is the class that can compute the values at compilation time
 * It is used to compute some stuff, that must be known at compilation time, or for optimization purpose
 */
pub class CompileTimeInterpreter {

    /**
     * Create an empty interpreter
     */
    pub self () {}

    /**
     * Try to compute the value and return
     * @returns: a cte value iif the value is cte, 'value' otherwise
     */
    pub fn simplify (self, value : &Value)-> (bool, &Value) {
        {
            (true, self.compute (value))
        } catch {
            _ => {
                (false, value)
            }
        }
    }            

    /**
     * Compute the value of `value`, by transforming it into a literal of some sort, that can be interpreted by the compiler as a single value
     * @params: 
     *   - value: the value to interpret
     * @returns: a literal value of some kind (TODO, define precisely what kind ?)
     * @throws: &ErrorMsg: if the value cannot be known at compilation time
     */
    pub fn compute (self, value : &Value)-> &Value
        throws &ErrorMsg
    {
        match value {
            l : &LiteralValue => { self.computeLiteral (l) }
            a : &AliaserValue => { self.computeAliaser (a) }
            s : &SliceValue => { self.computeSliceValue (s) }
            rng : &RangeValue => { self.computeRangeValue (rng) }
            slc : &SliceConcatValue => { self.computeSliceConcat (slc) }
            slc : &SliceCompareValue => { self.computeSliceCompare (slc) }
            slc : &SliceAccessValue => { self.computeSliceAccess (slc) }
            bin : &BinaryOperatorValue => { self.computeBinary (bin) }
            un : &UnaryOperatorValue => { self.computeUnary (un) }
            cd : &ConditionalValue => { self.computeConditional (cd) }
            bl : &BlockValue => { self.computeBlock (bl) }
            vref : &VarRefValue => { self.computeVarRef (vref) }
            addr : &AddressValue => { self.computeAddress (addr) }
            s : &StructFieldAccessValue => { self.computeFieldAccess (s) }
            t : &TupleFieldAccessValue => { self.computeFieldAccessTuple (t) }
            c : &CallValue => { self.computeCallValue (c) }
            c : &CastValue => { self.computeCastValue (c) }
            a : &ArrayAccessValue => { self.computeArrayAccessValue (a) }
            _ => {
                throw ErrorMsg::fatal (value.getLoc (), format (ValidateErrorMessage::UNKNOWN_AT_COMPILE_TIME, value.getType ()));
            }
        }
    }

    /**
     * ================================================================================
     * ================================================================================
     * =======================            COMPUTE LITERAL           ===================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Compute a literal value
     * */
    fn computeLiteral (self, lit : &LiteralValue)-> &Value
        throws &ErrorMsg
    {
        match lit {
            a : &ArrayValue => { return self.computeArray (a); }
            b : &BoolValue => { return b; }
            c : &CharValue => { return c; }
            f : &FloatValue => { return f; }
            i : &IntValue => { return i; }
            n : &NullValue => { return n; }
            s : &StringValue => { return s; }
            t : &TupleValue => { return self.computeTuple (t); }
            u : &UnitValue => { return u; }
            _ => {
                throw ErrorMsg::fatal (lit.getLoc (), format (ValidateErrorMessage::UNKNOWN_AT_COMPILE_TIME, lit.getType ()));
            }
        }
    }

    /**
     * Compute array value
     * */
    fn computeArray (self, arr : &ArrayValue)-> &Value
        throws &ErrorMsg
    {
        let dmut inners = Vec!{&Value}::new ();
        for i in arr.getInners () {
            inners:.push (self.compute (i));
        }

        ArrayValue::new (arr.getLoc (), arr.getType (), inners[])
    }

    /**
     * Compute a tuple value
     * */
    fn computeTuple (self, t : &TupleValue)-> &Value
        throws &ErrorMsg
    {
        let dmut inners = Vec!{&Value}::new ();
        for i in t.getInners () {
            inners:.push (self.compute (i));
        }

        TupleValue::new (t.getLoc (), t.getType (), inners[])
    }

    /**
     * ================================================================================
     * ================================================================================
     * ====================            COMPUTE AND TRANSFORM           ================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Compute the value of "value" and try transforming it into a string literal directly usable
     * @params:
     *    - value: the value to compute and transform
     * @returns:
     *    - .0: the size of encoding (8, 16, 32)
     *    - .1: the content of the string (encoded)
     * @throws:
     *    - &ErrorMsg: if the value cannot be retreived at compilation time, or does not contain a string literal
     */
    pub fn computeString (self, value : &Value)-> (u16, StringValueContent)
        throws &ErrorMsg
    {
        let inner = match self.compute (value) {
            a : &SliceValue => { a.getInner () }
            l : _ => { l }
        };
        
        match inner {
            s : &StringValue => {
                let size = s.getType ().asOf!{&ArrayType} ().getInners ()[0].asOf!{&CharType} ().getSize ();
                return (size, s.getValue ());
            }
            _ => {
                let ch = CharType::new (value.getLoc (), size-> 8u16);
                let slcType = SliceType::new (value.getLoc (), ch);
                throw ErrorMsg::fatal (inner.getLoc (),
                                       format (ValidateErrorMessage::INCOMPATIBLE_TYPE,
                                               inner.getType (), slcType));                                               
            }
        };
    }

    /**
     * Compute the value of "value" and try transforming it into a decoded string value in utf8 directly usable
     * @params:
     *    - value: the value to compute and transform
     * @returns: the utf8 decoded string
     * @throws:
     *    - &ErrorMsg: if the value cannot be retreived at compilation time, or does not contain a string literal
     */
    pub fn decodeString (self, value : &Value)-> [c8]
        throws &ErrorMsg
    {
        match self.computeString (value) {
            (8u16, val : _) => {
                utf::instance ().decode (val.utf8)
            }
            (16u16, val : _) => {
                utf::instance ().decode (val.utf16)
            }
            (_, val : _) => {
                utf::instance ().decode (val.utf32)
            }
        }
    }

    /**
     * Compute the value of 'value' and try transforming it into a bool literal 
     * @throws:
     *    - &ErrorMsg: if the value cannot be retreived at compilation time, or does not contain a bool literal
     */
    pub fn computeBool (self, value : &Value)-> bool
        throws &ErrorMsg
    {
        let inner = self.compute (value);
        match inner {
            b : &BoolValue => {
                b.isTrue ()
            }
            _ => {
                let bType = BoolType::new (value.getLoc ());
                throw ErrorMsg::fatal (inner.getLoc (),
                                       format (ValidateErrorMessage::INCOMPATIBLE_TYPE,
                                               inner.getType (), bType));
            }
        }
    }

    /**
     * Compute the value of 'value' and try transforming it into a int literal
     * @params:
     *     - size: the size of the int type (for error throwing only, does not check that on the literal value)
     *     - signed: true if the int type is signed (for error throwing only, does not check that on the literal value)
     * @throws:
     *    - &ErrorMsg: if the value cannot be retreived at compilation time, or does not contain a int literal
     */
    pub fn computeInt (self, value : &Value, size : u16 = 0u16, signed : bool = true)-> &BigInt
        throws &ErrorMsg
    {
        let inner = self.compute (value);
        match inner {
            i : &IntValue => {
                i.getValue ()
            }
            _ => {
                let iType = IntType::new (value.getLoc (), size-> size, signed-> signed);
                throw ErrorMsg::fatal (inner.getLoc (),
                                       format (ValidateErrorMessage::INCOMPATIBLE_TYPE,
                                               inner.getType (), iType));
            }
        }
    }

    /**
     * Compute the value of "value" and try to transform it into a float literal
     * @params:
     *     - size: the size of the int type (for error throwing only, does not check that on the literal value)
     * @throws:
     *    - &ErrorMsg: if the value cannot be retreived at compilation time, or does not contain a float literal
     * */
    pub fn computeFloat (self, value : &Value, size : u16 = 0u16)-> &BigFloat
        throws &ErrorMsg
    {
        let inner = self.compute (value);
        match inner {
            f : &FloatValue => {
                f.getValue ()
            }
            _ => {
                let fType = FloatType::new (value.getLoc (), size-> size);
                throw ErrorMsg::fatal (inner.getLoc (),
                                       format (ValidateErrorMessage::INCOMPATIBLE_TYPE,
                                               inner.getType (), fType));
            }
        }
    }
    
    /**
     * ================================================================================
     * ================================================================================
     * =========================            RANGE             =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Compute the content of a range value at compilation time
     * @params: 
     *   - value: the range value to compute
     * @returns: a range value
     * @throws: &ErrorMsg if the value cannot be known at compilation time
     */
    fn computeRangeValue (self, value : &RangeValue)-> &Value
        throws &ErrorMsg
    {
        let left = self.compute (value.getLeft ());
        let right = self.compute (value.getRight ());
        let full = self.compute (value.getIsFull ());
        let step = match value.getStep () {
            n : &NoneValue => { cast!{&Value} (n) }
            s : &Value => { self.compute (s) }
        }
        
        RangeValue::new (value.getLoc (), value.getType (), left, right, full-> full, step-> step)
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================        CONCATENATION         =========================
     * ================================================================================
     * ================================================================================
     */
    
    /**
     * Compute a slice concatenation operation
     * @params: 
     *  - value: the value to compute
     * @returns: the value
     * @throws: 
     *   - &ErrorMsg: if the value cannot be known at compilation time
     */
    fn computeSliceConcat (self, value : &SliceConcatValue)-> &Value
        throws &ErrorMsg
    {
        let left = match self.compute (value.getLeft ()) {
            al : &SliceValue => { al.getInner () }
            l : _ => { l }
        };

        let right = match self.compute (value.getRight ()) {
            al : &SliceValue => { al.getInner () }
            r : _ => { r }
        };

        let res = match (left, right) {
            (l : &StringValue, r : &StringValue) => {
                self.concatStrings (value.getLoc (), value.getType (), l, r)
            }
            // (l : &LiteralValue, r : &LiteralValue) => {
            //     self.concatArrays (value.getLoc (), value.getType (), l, r)
            // }
            _ => {
                throw ErrorMsg::fatal (value.getLoc (), format (ValidateErrorMessage::UNKNOWN_AT_COMPILE_TIME, value.getType ()));
            }            
        }

        res
    }

    /**
     * Concatenation of two string values
     * @params: 
     *  - loc: the location of the operation
     *  - type: the type of the operation
     *  - left: the left operand of the concat
     *  - right: the right operand of the concat
     * @returns: a aliaservalue containing a new string value
     */
    fn concatStrings (self, loc : &Word, type : &Type, left : &StringValue, right : &StringValue)-> &Value {
        if (left.getEncodingSize () != right.getEncodingSize ()) { __pragma!panic (); }

        let (needSlc, inner) = match type {
            slc : &SliceType => {
                (true, slc.getInners ()[0])
            }
            arr : &ArrayType => {
                (false, arr.getInners ()[0])
            }
            _ => __pragma!panic ();
        };

        let strValue = match left.getEncodingSize () {
            8u16 => {
                let result = left.getValue ().utf8 ~ right.getValue ().utf8;
                let arr = ArrayType::new (loc, inner, size-> makeIntValue (loc, result.len), isMutable-> true);

                StringValue::new (loc, arr, result)
            }
            16u16 => {
                let result = left.getValue ().utf16 ~ right.getValue ().utf16;
                let arr = ArrayType::new (loc, inner, size-> makeIntValue (loc, result.len), isMutable-> true);

                StringValue::new (loc, arr, result)
            }
            _ => {
                let result = left.getValue ().utf32 ~ right.getValue ().utf32;
                let arr = ArrayType::new (loc, inner, size-> makeIntValue (loc, result.len), isMutable-> true);

                StringValue::new (loc, arr, result)
            }
        };

        if (needSlc) {
            SliceValue::new (loc, SliceType::new (loc, inner, isMutable-> true), strValue, implicitAlias-> true)
        } else {
            strValue
        }
    }

    /**
     * Concatenate two arrays
     * @params: 
     *   - loc: the location of the operation
     *   - type: the type of the result
     *   - left: the left operand
     *   - right: the right operand
     * @returns: the result 
     */
    fn concatArrays (self, loc : &Word, type : &Type, left : &ArrayValue, right : &ArrayValue)-> &Value {
        let dmut res = Vec!{&Value}::new ();
        let l = left.getInners ();
        let r = right.getInners ();
        for i in 0us .. l.len {
            res:.push (l[i]);
        }

        for j in 0us .. r.len {
            res:.push (r[j]);
        }

        let inner = type.asOf!{&ArrayType}().getInners ()[0];
        let arrType = ArrayType::new (loc, inner, size-> makeIntValue (loc, res.len ()), isMutable-> true);

        ArrayValue::new (loc, arrType, res[])
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================          COMPARISON          =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Compute the value of a slice comparison
     * @params: 
     *   - value: the value to execute a cte
     * @returns: the result value
     * @throws: 
     *  - &ErrorMsg: if the value cannot be known at compilation time
     */
    fn computeSliceCompare (self, value : &SliceCompareValue)-> &Value
        throws &ErrorMsg
    {
        let left = match self.compute (value.getLeft ()) {
            al : &SliceValue => { al.getInner () }
            l : _ => { l }
        };

        let right = match self.compute (value.getRight ()) {
            al : &SliceValue => { al.getInner () }
            r : _ => { r }
        };

        let res = match (left, right) {
            (l : &StringValue, r : &StringValue) => {                
                BoolValue::new (value.getLoc (), (l == r))
            }
            (l : &ArrayValue, r : &ArrayValue) => {
                BoolValue::new (value.getLoc (), (l == r))
            }
            _ => {
                throw ErrorMsg::fatal (value.getLoc (), format (ValidateErrorMessage::UNKNOWN_AT_COMPILE_TIME, value.getType ()));
            }            
        }

        res
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================            BINARY            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Compute the value of a binary operation
     * @params: 
     *   - bin: the value to compute
     * @returns: the result
     * @throws:
     *   - &ErrorMsg: if the value cannot be known at compile time
     */
    fn computeBinary (self, bin : &BinaryOperatorValue)-> &Value
        throws &ErrorMsg
    {
        match bin {
            iBin : &BinaryMathIntOperatorValue => {
                return self.computeBinMathInt (iBin);
            }
            sBin : &SpecialMathIntOperatorValue => {
                return self.computeSpecialMathInt (sBin);
            }
            cmp : &CmpIntOperatorValue => {
                return self.computeCompareIntValue (cmp);
            }
            bBin : &LogicalBinBoolOperatorValue => {
                return self.computeLogicalBinBool (bBin);
            }
            bBin : &CmpBoolOperatorValue => {
                return self.computeCompareBoolValue (bBin);
            }
            fBin : &BinaryMathFloatOperatorValue => {
                return self.computeBinMathFloat (fBin);
            }
            sBin : &SpecialMathFloatOperatorValue => {
                return self.computeSpecialMathFloat (sBin);
            }
            fBin : &CmpFloatOperatorValue => {
                return self.computeCompareFloat (fBin);
            }
            cBin : &BinaryMathCharOperatorValue => {
                return self.computeBinMathChar (cBin);
            }
            cmp : &CmpCharOperatorValue => {
                return self.computeCompareChar (cmp);
            }
            rngContain : &RangeContainValue => {
                return self.computeRangeContain (rngContain);
            }
            _ => {
                throw ErrorMsg::fatal (bin.getLoc (), format (ValidateErrorMessage::UNKNOWN_AT_COMPILE_TIME, bin.getType ()));
            }
        }
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================       BINARY CMP INT        ==========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Compute the value of int binary comparison
     * @params:
     *     - bin: the operator to compute
     * @returns: the result
     * @throws:
     *    - &ErrorMsg: if the value cannot be knwon at compile time
     */
    fn computeCompareIntValue (self, bin : &CmpIntOperatorValue)-> &Value
        throws &ErrorMsg
    {
        {
            let left = self.compute (bin.getLeft ());
            let right = self.compute (bin.getRight ());
            match (left, right) {
                (l : &IntValue, r : &IntValue) => {
                    match bin.getOperator () {
                        BinaryOperators::INF => { return BoolValue::new (bin.getLoc (), l.getValue () < r.getValue ()); }
                        BinaryOperators::SUP => { return BoolValue::new (bin.getLoc (), l.getValue () > r.getValue ()); }
                        BinaryOperators::INF_EQUAL => { return BoolValue::new (bin.getLoc (), l.getValue () <= r.getValue ()); }
                        BinaryOperators::SUP_EQUAL => { return BoolValue::new (bin.getLoc (), l.getValue () >= r.getValue ()); }
                        BinaryOperators::NOT_EQUAL => { return BoolValue::new (bin.getLoc (), l.getValue () != r.getValue ()); }
                        BinaryOperators::DEQUAL => { return BoolValue::new (bin.getLoc (), l.getValue () == r.getValue ()); }
                        _ => __pragma!panic ();
                    }
                }
                _ => __pragma!panic ();
            }
        } catch {
            err : &ErrorMsg => {
                return self.computeCompareIntValueNotFull (bin, err);
            }
        }
    }

    /**
     * Perform a comparison where one of the two operands is not cte
     * But maybe the other one is
     * Sometimes, things can be told, for example, a unsigned int value cannot be lower than 0
     * */
    fn computeCompareIntValueNotFull (self, bin : &CmpIntOperatorValue, err : &ErrorMsg)-> &Value
        throws &ErrorMsg
    {
        let (cteLeft, left) = self.simplify (bin.getLeft ());
        let (cteRight, right) = self.simplify (bin.getRight ());

        if (cteLeft) { // then right is not cte
            let min = self.createIntMinValue (left.getType ().asOf!{&IntType} ());
            let max = self.createIntMaxValue (left.getType ().asOf!{&IntType} ());
            let v = left.asOf!{&IntValue} ().getValue ();
            match bin.getOperator () {
                BinaryOperators::INF => {
                    if v == min { return BoolValue::new (bin.getLoc (), true); } // 0 < right
                    if v == max { return BoolValue::new (bin.getLoc (), false); } // max < right
                }
                BinaryOperators::SUP => {
                    if v == max { return BoolValue::new (bin.getLoc (), true); } // max > right
                    if v == min { return BoolValue::new (bin.getLoc (), false); }  // 0 > right
                }
            }
        } else if (cteRight) { //  then left is not cte
            let min = self.createIntMinValue (right.getType ().asOf!{&IntType} ());
            let max = self.createIntMaxValue (right.getType ().asOf!{&IntType} ());
            let v = right.asOf!{&IntValue} ().getValue ();

            match bin.getOperator () {
                BinaryOperators::INF => {
                    if v == min { return BoolValue::new (bin.getLoc (), false); } // left < 0
                    if v == max { return BoolValue::new (bin.getLoc (), true); } // left < max
                }
                BinaryOperators::SUP => {
                    if v == max { return BoolValue::new (bin.getLoc (), false); } // left > max
                    if v == min { return BoolValue::new (bin.getLoc (), true); }  // left > 0
                }
            }
        }

        // both are unknown, or not equal to a limit
        throw err;
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================       BINARY CMP BOOL        =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Compute the value of bool binary comparison
     * @params:
     *     - bin: the operator to compute
     * @returns: the result
     * @throws:
     *    - &ErrorMsg: if the value cannot be knwon at compile time
     */
    fn computeCompareBoolValue (self, bin : &CmpBoolOperatorValue)-> &Value
        throws &ErrorMsg
    {
        let left = self.compute (bin.getLeft ());
        let right = self.compute (bin.getRight ());
        match (left, right) {
            (l : &BoolValue, r : &BoolValue) => {
                match bin.getOperator () {
                    BinaryOperators::NOT_EQUAL => { return BoolValue::new (bin.getLoc (), l.isTrue () != r.isTrue ()); }
                    BinaryOperators::DEQUAL => { return BoolValue::new (bin.getLoc (), l.isTrue () == r.isTrue ()); }
                    _ => __pragma!panic ();
                }
            }
            _ => __pragma!panic ();
        }
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================       BINARY LOGIC BOOL        =======================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Compute the value of a binary logical operation on bools
     * @params:
     *     - bin: the operator to compute
     * @throws:
     *    - &ErrorMsg: if the value cannot be knwon at compile time
     * */
    fn computeLogicalBinBool (self, bin : &LogicalBinBoolOperatorValue)-> &Value
        throws &ErrorMsg
    {
        let left = self.compute (bin.getLeft ());
        let right = self.compute (bin.getRight ());
        match (left, right) {
            (l : &BoolValue, r : &BoolValue) => {
                match bin.getOperator () {
                    BinaryOperators::DPIPE => { return BoolValue::new (bin.getLoc (), l.isTrue () || r.isTrue ()) }
                    BinaryOperators::DAND  => { return BoolValue::new (bin.getLoc (), l.isTrue () && r.isTrue ()) }
                    _ => __pragma!panic ();
                }
            }
            _ => __pragma!panic ();
        }
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================       BINARY MATH CHAR        ========================
     * ================================================================================
     * ================================================================================
     */


    /**
     * Compute the value of char binary comparison
     * @params:
     *     - bin: the operator to compute
     * @returns: the result
     * @throws:
     *    - &ErrorMsg: if the value cannot be knwon at compile time
     */
    fn computeCompareChar (self, bin : &CmpCharOperatorValue)-> &Value
        throws &ErrorMsg
    {
        let left = self.compute (bin.getLeft ());
        let right = self.compute (bin.getRight ());
        match (left, right) {
            (l : &CharValue, r : &CharValue) => {
                match (bin.getOperator (), l.getEncodingSize ()) {
                    (BinaryOperators::INF, 8u16)  => { return BoolValue::new (bin.getLoc (), l.getValue ().utf8  < r.getValue ().utf8); }
                    (BinaryOperators::INF, 16u16) => { return BoolValue::new (bin.getLoc (), l.getValue ().utf16 < r.getValue ().utf16); }
                    (BinaryOperators::INF, 32u16) => { return BoolValue::new (bin.getLoc (), l.getValue ().utf32 < r.getValue ().utf32); }

                    (BinaryOperators::SUP, 8u16)  => { return BoolValue::new (bin.getLoc (), l.getValue ().utf8  > r.getValue ().utf8); }
                    (BinaryOperators::SUP, 16u16) => { return BoolValue::new (bin.getLoc (), l.getValue ().utf16 > r.getValue ().utf16); }
                    (BinaryOperators::SUP, 32u16) => { return BoolValue::new (bin.getLoc (), l.getValue ().utf32 > r.getValue ().utf32); }

                    (BinaryOperators::INF_EQUAL, 8u16)  => { return BoolValue::new (bin.getLoc (), l.getValue ().utf8  <= r.getValue ().utf8); }
                    (BinaryOperators::INF_EQUAL, 16u16) => { return BoolValue::new (bin.getLoc (), l.getValue ().utf16 <= r.getValue ().utf16); }
                    (BinaryOperators::INF_EQUAL, 32u16) => { return BoolValue::new (bin.getLoc (), l.getValue ().utf32 <= r.getValue ().utf32); }

                    (BinaryOperators::SUP_EQUAL, 8u16)  => { return BoolValue::new (bin.getLoc (), l.getValue ().utf8  >= r.getValue ().utf8); }
                    (BinaryOperators::SUP_EQUAL, 16u16) => { return BoolValue::new (bin.getLoc (), l.getValue ().utf16 >= r.getValue ().utf16); }
                    (BinaryOperators::SUP_EQUAL, 32u16) => { return BoolValue::new (bin.getLoc (), l.getValue ().utf32 >= r.getValue ().utf32); }

                    (BinaryOperators::DEQUAL, 8u16)  => { return BoolValue::new (bin.getLoc (), l.getValue ().utf8  == r.getValue ().utf8); }
                    (BinaryOperators::DEQUAL, 16u16) => { return BoolValue::new (bin.getLoc (), l.getValue ().utf16 == r.getValue ().utf16); }
                    (BinaryOperators::DEQUAL, 32u16) => { return BoolValue::new (bin.getLoc (), l.getValue ().utf32 == r.getValue ().utf32); }

                    (BinaryOperators::NOT_EQUAL, 8u16)  => { return BoolValue::new (bin.getLoc (), l.getValue ().utf8  != r.getValue ().utf8); }
                    (BinaryOperators::NOT_EQUAL, 16u16) => { return BoolValue::new (bin.getLoc (), l.getValue ().utf16 != r.getValue ().utf16); }
                    (BinaryOperators::NOT_EQUAL, 32u16) => { return BoolValue::new (bin.getLoc (), l.getValue ().utf32 != r.getValue ().utf32); }

                    _ => __pragma!panic ();
                }
            }
            _ => __pragma!panic ();
        }
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================       BINARY MATH CHAR        ========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Compute a binary math operator on two char values
     * */
    fn computeBinMathChar (self, bin : &BinaryMathCharOperatorValue)-> &Value
        throws &ErrorMsg
    {
        let left = self.compute (bin.getLeft ());
        let right = self.compute (bin.getRight ());
        match (left, right, bin.getType ()) {
            (l : &CharValue, r : &CharValue, t : &CharType) => {
                match bin.getOperator () {
                    BinaryOperators::PLUS => { return self.computeBinMathCharAdd (bin.getLoc (), t, l, r); }
                    BinaryOperators::MINUS => { return self.computeBinMathCharSub (bin.getLoc (), t, l, r); }
                    _ => __pragma!panic ();
                }
            }
            _ => {
                __pragma!panic ();
            }
        }
    }

    /**
     * Compute an addition between two char values
     */
    fn computeBinMathCharAdd (self, loc : &Word, type : &CharType, left : &CharValue, right : &CharValue)-> &Value
        throws &ErrorMsg
    {
        match left.getEncodingSize () {
            8u16 => {
                let val = BigInt::new (cast!u64 (left.getValue ().utf8)) + BigInt::new (cast!u64 (right.getValue ().utf8));
                self.verifyOverFlowChar (loc, type, val);

                CharValue::new (loc, type, val.to!u8 ())
            }
            16u16 => {
                let val = BigInt::new (cast!u64 (left.getValue ().utf16)) + BigInt::new (cast!u64 (right.getValue ().utf16));
                self.verifyOverFlowChar (loc, type, val);

                CharValue::new (loc, type, val.to!u16 ())
            }
            _ => {
                let val = BigInt::new (cast!u64 (left.getValue ().utf32)) + BigInt::new (cast!u64 (right.getValue ().utf32));
                self.verifyOverFlowChar (loc, type, val);

                CharValue::new (loc, type, val.to!u32 ())
            }
        }
    } catch {
        _ : &BigIntError => { __pragma!panic (); }
        e : &ErrorMsg => throw e;
    }

    /**
     * Compute a substraction between two char values
     */
    fn computeBinMathCharSub (self, loc : &Word, type : &CharType, left : &CharValue, right : &CharValue)-> &Value
        throws &ErrorMsg
    {
        match left.getEncodingSize () {
            8u16 => {
                let val = BigInt::new (cast!u64 (left.getValue ().utf8)) - BigInt::new (cast!u64 (right.getValue ().utf8));
                self.verifyOverFlowChar (loc, type, val);

                CharValue::new (loc, type, val.to!u8 ())
            }
            16u16 => {
                let val = BigInt::new (cast!u64 (left.getValue ().utf16)) - BigInt::new (cast!u64 (right.getValue ().utf16));
                self.verifyOverFlowChar (loc, type, val);

                CharValue::new (loc, type, val.to!u16 ())
            }
            _ => {
                let val = BigInt::new (cast!u64 (left.getValue ().utf32)) - BigInt::new (cast!u64 (right.getValue ().utf32));
                self.verifyOverFlowChar (loc, type, val);

                CharValue::new (loc, type, val.to!u32 ())
            }
        }
    } catch {
        _ : &BigIntError => { __pragma!panic (); }
        e : &ErrorMsg => throw e;
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================       BINARY MATH INT        =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Compute the value of a int binary math operator
     * @params:
     *    - bin: the operator to compute
     * @returns: the result
     * @throws:
     *    - &ErrorMsg: if the value cannot be known at compile time
     */
    fn computeBinMathInt (self, bin : &BinaryMathIntOperatorValue)-> &Value
        throws &ErrorMsg
    {
        let left = self.compute (bin.getLeft ());
        let right = self.compute (bin.getRight ());

        match (left, right, bin.getType ()) {
            (l : &IntValue, r : &IntValue, t : &IntType) => {
                match bin.getOperator () {
                    BinaryOperators::PLUS => { return self.computeBinMathIntAdd (bin.getLoc (), t, l, r); }
                    BinaryOperators::MINUS => { return self.computeBinMathIntSub (bin.getLoc (), t, l, r); }
                    BinaryOperators::STAR => { return self.computeBinMathIntMul (bin.getLoc (), t, l, r); }
                    BinaryOperators::PERCENT => { return self.computeBinMathIntMod (bin.getLoc (), t, l, r); }
                    BinaryOperators::DIV => { return self.computeBinMathIntDiv (bin.getLoc (), t, l, r); }
                    _ => __pragma!panic ();
                }
            }
            _ => __pragma!panic ();
        }
    }

    /**
     * Compute the value of a special int binary math operator
     * @params:
     *    - bin: the operator to compute
     * @returns: the result
     * @throws:
     *    - &ErrorMsg: if the value cannot be known at compile time
     */
    fn computeSpecialMathInt (self, bin : &SpecialMathIntOperatorValue)-> &Value
        throws &ErrorMsg
    {
        let left = self.compute (bin.getLeft ());
        let right = self.compute (bin.getRight ());

        match (left, right, bin.getType ()) {
            (l : &IntValue, r : &IntValue, t : &IntType) => {
                match bin.getOperator () {
                    BinaryOperators::DXOR => { return self.computeBinMathIntPow (bin.getLoc (), t, l, r); }
                    _ => __pragma!panic ();
                }
            }
            _ => __pragma!panic ();
        }
    }
    
    /**
     * Compute an addition between two int values
     * @params:
     *    - type: the type of the addition
     *    - left: the left operand
     *    - right: the right operand
     * @returns: the result of the addition
     */
    fn computeBinMathIntAdd (self, loc : &Word, type : &IntType, left : &IntValue, right : &IntValue)-> &Value
        throws &ErrorMsg
    {
        let r = left.getValue () + right.getValue ();
        self.verifyOverFlowInt (loc, type, r);

        IntValue::new (loc, type, r)
    }

    /**
     * Compute an substraction between two int values
     * @params:
     *    - type: the type of the addition
     *    - left: the left operand
     *    - right: the right operand
     * @returns: the result of the addition
     */
    fn computeBinMathIntSub (self, loc : &Word, type : &IntType, left : &IntValue, right : &IntValue)-> &Value
        throws &ErrorMsg
    {
        let r = left.getValue () - right.getValue ();
        self.verifyOverFlowInt (loc, type, r);

        IntValue::new (loc, type, r)
    }

    /**
     * Compute an multiplication between two int values
     * @params:
     *    - type: the type of the addition
     *    - left: the left operand
     *    - right: the right operand
     * @returns: the result of the addition
     */
    fn computeBinMathIntMul (self, loc : &Word, type : &IntType, left : &IntValue, right : &IntValue)-> &Value
        throws &ErrorMsg
    {
        let r = left.getValue () * right.getValue ();
        self.verifyOverFlowInt (loc, type, r);

        IntValue::new (loc, type, r)
    }

    /**
     * Compute a division between two int values
     * @params:
     *    - type: the type of the addition
     *    - left: the left operand
     *    - right: the right operand
     * @returns: the result of the addition
     */
    fn computeBinMathIntDiv (self, loc : &Word, type : &IntType, left : &IntValue, right : &IntValue)-> &Value
        throws &ErrorMsg
    {
        let r = {
            left.getValue () / right.getValue ()
        } catch {
            _ => throw ErrorMsg::fatal (loc, ValidateErrorMessage::DIVISION_BY_ZERO);
        };

        self.verifyOverFlowInt (loc, type, r);

        IntValue::new (loc, type, r)
    }

    /**
     * Compute a modulo between two int values
     * @params:
     *    - type: the type of the addition
     *    - left: the left operand
     *    - right: the right operand
     * @returns: the result of the addition
     */
    fn computeBinMathIntMod (self, loc : &Word, type : &IntType, left : &IntValue, right : &IntValue)-> &Value
        throws &ErrorMsg
    {
        let r = {
            left.getValue () % right.getValue ()
        } catch {
            _ => throw ErrorMsg::fatal (loc, ValidateErrorMessage::DIVISION_BY_ZERO);
        };

        self.verifyOverFlowInt (loc, type, r);

        IntValue::new (loc, type, r)
    }

    /**
     * Compute a power between two int values
     * @params:
     *    - type: the type of the addition
     *    - left: the left operand
     *    - right: the right operand
     * @returns: the result of the addition
     */
    fn computeBinMathIntPow (self, loc : &Word, type : &IntType, left : &IntValue, right : &IntValue)-> &Value
        throws &ErrorMsg
    {
        let r = {
            left.getValue () ^^ right.getValue ()
        } catch {
            _ => throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::OVERFLOW_CAPACITY, right.getType (), right, u64::max));
        }

        self.verifyOverFlowInt (loc, type, r);

        IntValue::new (loc, type, r)
    }

    /**
     * ================================================================================
     * ================================================================================
     * ============================        INT UTILS        ===========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Verify that the int value does not exceed the capacities of the type
     * @params:
     *    - type: the type of the int value
     *    - val: the content of the int value
     * @throws:
     *    - &ErrorMsg: if there is an overflow
     */
    pub fn verifyOverFlowInt (self, loc : &Word, type : &IntType, value : usize)
        throws &ErrorMsg
    {
        let max = self.createIntMaxValue (type);
        let min = self.createIntMinValue (type);

        if (value > max) {
            throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::OVERFLOW_CAPACITY, type, value, max));
        }
        if (value < min) {
            throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::OVERFLOW_CAPACITY_MIN, type, value, min));
        }
    }

    /**
     * Verify that the int value does not exceed the capacities of the type
     * @params:
     *    - type: the type of the int value
     *    - val: the content of the int value
     * @throws:
     *    - &ErrorMsg: if there is an overflow
     */
    pub fn verifyOverFlowInt (self, loc : &Word, type : &IntType, value : &BigInt)
        throws &ErrorMsg
    {
        let max = self.createIntMaxValue (type);
        let min = self.createIntMinValue (type);

        if (value > max) {
            throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::OVERFLOW_CAPACITY, type, value, max));
        }
        if (value < min) {
            throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::OVERFLOW_CAPACITY_MIN, type, value, min));
        }
    }

    /**
     * Create the max value for the type 'i'
     * @params:
     *     - i: a int type
     * @returns: the maximum value the int can contain
     * */
    pub fn createIntMaxValue (self, i : &IntType)-> &BigInt {
        match (i.getSize (), i.isSigned ()) {
            (0u16, false) => { BigInt::new (2us) ^^ (global::state::instance ().getSizeTypeSize ()) - 1us }
            (0u16, true)  => { (BigInt::new (2us) ^^ (global::state::instance ().getSizeTypeSize () - 1us)) - 1us }
            (size : u16, false) => { BigInt::new (2us) ^^ cast!usize (size) - 1us }
            (size : u16, true) => { (BigInt::new (2us) ^^ cast!usize (size - 1u16)) - 1us }
            _ => {
                __pragma!panic ();
            }
        }
    } catch {
        _ : &BigIntError => {
            __pragma!panic ();
        }
    }

    /**
     * Create the min value for the type 'i'
     * @params:
     *     - i: a int type
     * @returns: the maximum value the int can contain
     * */
    pub fn createIntMinValue (self, i : &IntType)-> &BigInt {
        match (i.getSize (), i.isSigned ()) {
            (0u16, false) => { BigInt::new (0us) }
            (0u16, true)  => { 0us - (BigInt::new (2us) ^^ (global::state::instance ().getSizeTypeSize () - 1us)) }
            (_, false)    => { BigInt::new (0us) }
            (size : u16, true) => { 0us - (BigInt::new (2us) ^^ cast!usize (size - 1u16)) }
            _ => {
                __pragma!panic ();
            }
        }
    } catch {
        _ : &BigIntError => {
            __pragma!panic ();
        }
    }

    /**
     * ================================================================================
     * ================================================================================
     * ============================        CHAR UTILS        ==========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Verify that the int value does not exceed the capacities of the type
     * @params:
     *    - type: the type of the int value
     *    - val: the content of the int value
     * @throws:
     *    - &ErrorMsg: if there is an overflow
     */
    pub fn verifyOverFlowChar (self, loc : &Word, type : &CharType, value : usize)
        throws &ErrorMsg
    {
        let max = {
            BigInt::new (2us) ^^ cast!usize (type.getSize ()) - 1us
        } catch {
            _ : &BigIntError => __pragma!panic ();
        }

        if (value > max) {
            throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::OVERFLOW_CAPACITY, type, value, max));
        }
        if (value < 0u64) {
            throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::OVERFLOW_CAPACITY_MIN, type, value, 0u64));
        }
    }

    /**
     * Verify that the int value does not exceed the capacities of the type
     * @params:
     *    - type: the type of the int value
     *    - val: the content of the int value
     * @throws:
     *    - &ErrorMsg: if there is an overflow
     */
    pub fn verifyOverFlowChar (self, loc : &Word, type : &CharType, value : &BigInt)
        throws &ErrorMsg
    {
        // Char are necessarily unsigned thus can be casted to usize
        self.verifyOverFlowChar (loc, type, value.toT!{usize} ());
    }

    /**
     * Verify that the char value does not exceed to capacities of the type
     * @params:
     *    - type: the type bounding the values
     *    - val: the content of the char value
     *  @throws:
     *    - &ErrorMsg: if there is an overflow
     * */
    pub fn verifyOverFlowChar (self, loc : &Word, type : &CharType, value : &CharValue)
        throws &ErrorMsg
    {
        match value.getType ().asOf!{&CharType} ().getSize () {
            8u16 => {
                self.verifyOverFlowChar (loc, type, cast!{usize} (value.getValue ().utf8));
            }
            16u16 => {
                self.verifyOverFlowChar (loc, type, cast!{usize} (value.getValue ().utf16));
            }
            _ => {
                self.verifyOverFlowChar (loc, type, cast!{usize} (value.getValue ().utf16));
            }
        }
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================       BINARY CMP FLOAT        ========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Compute the value of float binary comparison
     * @params:
     *     - bin: the operator to compute
     * @returns: the result
     * @throws:
     *    - &ErrorMsg: if the value cannot be knwon at compile time
     */
    fn computeCompareFloat (self, bin : &CmpFloatOperatorValue)-> &Value
        throws &ErrorMsg
    {
        let left = self.compute (bin.getLeft ());
        let right = self.compute (bin.getRight ());
        match (left, right) {
            (l : &FloatValue, r : &FloatValue) => {
                match bin.getOperator () {
                    BinaryOperators::INF => { return BoolValue::new (bin.getLoc (), l.getValue () < r.getValue ()); }
                    BinaryOperators::SUP => { return BoolValue::new (bin.getLoc (), l.getValue () > r.getValue ()); }
                    BinaryOperators::INF_EQUAL => { return BoolValue::new (bin.getLoc (), l.getValue () <= r.getValue ()); }
                    BinaryOperators::SUP_EQUAL => { return BoolValue::new (bin.getLoc (), l.getValue () >= r.getValue ()); }
                    BinaryOperators::NOT_EQUAL => { return BoolValue::new (bin.getLoc (), l.getValue () != r.getValue ()); }
                    BinaryOperators::DEQUAL => { return BoolValue::new (bin.getLoc (), l.getValue () == r.getValue ()); }
                    _ => __pragma!panic ();
                }
            }
            _ => __pragma!panic ();
        }
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================       BINARY MATH FLOAT        =======================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Compute the value of a float binary math operator
     * @params:
     *    - bin: the operator to compute
     * @returns: the result
     * @throws:
     *    - &ErrorMsg: if the value cannot be known at compile time
     */
    fn computeBinMathFloat (self, bin : &BinaryMathFloatOperatorValue)-> &Value
        throws &ErrorMsg
    {
        let left = self.compute (bin.getLeft ());
        let right = self.compute (bin.getRight ());

        match (left, right, bin.getType ()) {
            (l : &FloatValue, r : &FloatValue, t : &FloatType) => {
                match bin.getOperator () {
                    BinaryOperators::PLUS => { return self.computeBinMathFloatAdd (bin.getLoc (), t, l, r); }
                    BinaryOperators::MINUS => { return self.computeBinMathFloatSub (bin.getLoc (), t, l, r); }
                    BinaryOperators::STAR => { return self.computeBinMathFloatMul (bin.getLoc (), t, l, r); }
                    BinaryOperators::DIV => { return self.computeBinMathFloatDiv (bin.getLoc (), t, l, r); }
                    _ => __pragma!panic ();
                }
            }
            _ => {
                throw ErrorMsg::fatal (bin.getLoc (), format (ValidateErrorMessage::UNKNOWN_AT_COMPILE_TIME, bin.getType ()));
            }
        }
    }

    /**
     * Compute the value of a special float binary math operator
     * @params:
     *    - bin: the operator to compute
     * @returns: the result
     * @throws:
     *    - &ErrorMsg: if the value cannot be known at compile time
     */
    fn computeSpecialMathFloat (self, bin : &SpecialMathFloatOperatorValue)-> &Value
        throws &ErrorMsg
    {
        let left = self.compute (bin.getLeft ());
        let right = self.compute (bin.getRight ());

        match (left, right, bin.getType ()) {
            (l : &FloatValue, r : &IntValue, t : &FloatType) => {
                match bin.getOperator () {
                    BinaryOperators::DXOR => { return self.computeBinMathFloatPow (bin.getLoc (), t, l, r); }
                    _ => __pragma!panic ();
                }
            }
            (l : &FloatValue, r : &FloatValue, t : &FloatType) => {
                match bin.getOperator () {
                    BinaryOperators::DXOR => { return self.computeBinMathFloatPow (bin.getLoc (), t, l, r); }
                    BinaryOperators::PERCENT => { return self.computeBinMathFloatMod (bin.getLoc (), t, l, r); }
                    _ => __pragma!panic ();
                }
            }
            _ => {
                throw ErrorMsg::fatal (bin.getLoc (), format (ValidateErrorMessage::UNKNOWN_AT_COMPILE_TIME, bin.getType ()));
            }
        }
    }

    /**
     * Compute an addition between two float values
     * @params:
     *    - type: the type of the addition
     *    - left: the left operand
     *    - right: the right operand
     * @returns: the result of the addition
     */
    fn computeBinMathFloatAdd (self, loc : &Word, type : &FloatType, left : &FloatValue, right : &FloatValue)-> &Value  {
        let r = left.getValue () + right.getValue ();
        FloatValue::new (loc, type, r)
    }

    /**
     * Compute an substraction between two float values
     * @params:
     *    - type: the type of the addition
     *    - left: the left operand
     *    - right: the right operand
     * @returns: the result of the addition
     */
    fn computeBinMathFloatSub (self, loc : &Word, type : &FloatType, left : &FloatValue, right : &FloatValue)-> &Value {
        let r = left.getValue () - right.getValue ();
        FloatValue::new (loc, type, r)
    }

    /**
     * Compute an multiplication between two float values
     * @params:
     *    - type: the type of the addition
     *    - left: the left operand
     *    - right: the right operand
     * @returns: the result of the addition
     */
    fn computeBinMathFloatMul (self, loc : &Word, type : &FloatType, left : &FloatValue, right : &FloatValue)-> &Value {
        let r = left.getValue () * right.getValue ();
        FloatValue::new (loc, type, r)
    }

    /**
     * Compute a division between two float values
     * @params:
     *    - type: the type of the addition
     *    - left: the left operand
     *    - right: the right operand
     * @returns: the result of the addition
     */
    fn computeBinMathFloatDiv (self, loc : &Word, type : &FloatType, left : &FloatValue, right : &FloatValue)-> &Value
        throws &ErrorMsg
    {
        let r = {
            left.getValue () / right.getValue ()
        } catch {
            _ => throw ErrorMsg::fatal (loc, ValidateErrorMessage::DIVISION_BY_ZERO);
        };

        FloatValue::new (loc, type, r)
    }

    /**
     * Compute a mod division between two float values
     * @params:
     *    - type: the type of the addition
     *    - left: the left operand
     *    - right: the right operand
     * @returns: the result of the addition
     */
    fn computeBinMathFloatMod (self, loc : &Word, type : &FloatType, left : &FloatValue, right : &FloatValue)-> &Value
        throws &ErrorMsg
    {
        let r = {
            left.getValue () % right.getValue ()
        } catch {
            _ => throw ErrorMsg::fatal (loc, ValidateErrorMessage::DIVISION_BY_ZERO);
        };

        FloatValue::new (loc, type, r)
    }

    /**
     * Compute a power between a float and a int value
     * @params:
     *    - type: the type of the addition
     *    - left: the left operand
     *    - right: the right operand
     * @returns: the result of the addition
     */
    fn computeBinMathFloatPow (self, loc : &Word, type : &FloatType, left : &FloatValue, right : &IntValue)-> &Value
        throws &ErrorMsg
    {
        let r = {
            left.getValue () ^^ right.getValue ().to!{i64} ()
        } catch {
            _ => throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::OVERFLOW_CAPACITY, right.getType (), right, u64::max));
        }


        FloatValue::new (loc, type, r)
    }

    /**
     * Compute a power between a float and a int value
     * @params:
     *    - type: the type of the addition
     *    - left: the left operand
     *    - right: the right operand
     * @returns: the result of the addition
     */
    fn computeBinMathFloatPow (self, loc : &Word, type : &FloatType, left : &FloatValue, right : &FloatValue)-> &Value {
        let r = left.getValue () ^^ right.getValue ();
        FloatValue::new (loc, type, r)
    }

    /**
     * ================================================================================
     * ================================================================================
     * ===========================        FLOAT UTILS        ==========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Create the maximal finite value for the type 'f'
     * @params:
     *     - f: a float type
     * @returns: the maximal finite value the float can encode
     * */
    pub fn createFloatMaxValue (self, f : &FloatType)-> &BigFloat {
        match (f.getSize (), state::instance ().getFloatTypeSize ()) {
            (32u16, _) => { self.createFloatFromHex ("1"s8, "fffffe"s8, "127"s8) }
            (64u16, _) => { self.createFloatFromHex ("1"s8, "fffffffffffff"s8, "1023"s8) }
            (80u16, _) => { self.createFloatFromHex ("f"s8, "fffffffffffffff"s8, "16380"s8) }

            // fsize
            (_, 32u16) => { self.createFloatFromHex ("1"s8, "fffffe"s8, "127"s8) }
            (_, 64u16) => { self.createFloatFromHex ("1"s8, "fffffffffffff"s8, "1023"s8) }
            _ => {
                self.createFloatFromHex ("f"s8, "fffffffffffffff"s8, "16380"s8)
            }
        }
    }

    /**
     * Create the minimal finite value for the type 'f'
     * @params:
     *     - f: a float type
     * @returns: the minimal finite value the float can encode
     * */
    pub fn createFloatMinValue (self, f : &FloatType)-> &BigFloat {
        match (f.getSize (), state::instance ().getFloatTypeSize ()) {
            (32u16, _) => { self.createFloatFromHex ("1"s8, "0"s8, "-126"s8) }
            (64u16, _) => { self.createFloatFromHex ("1"s8, "0"s8, "-1022"s8) }
            (80u16, _) => { self.createFloatFromHex ("8"s8, "0"s8, "-16385"s8) }

            // fsize
            (_, 32u16) => {  self.createFloatFromHex ("1"s8, "0"s8, "-126"s8) }
            (_, 64u16) => {  self.createFloatFromHex ("1"s8, "0"s8, "-1022"s8) }
            _ => {
                self.createFloatFromHex ("8"s8, "0"s8, "-16385"s8)
            }
        }
    }

    /**
     * Create the nan value for the type 'f'
     * @params:
     *     - f: a float type
     * @returns: the nan value the float can encode
     * */
    pub fn createFloatNanValue (self, _ : &FloatType)-> &BigFloat {
        BigFloat::new (f32::nan)
    }

    /**
     * Create the precision for the type 'f'
     * @params:
     *     - f: a float type
     * @returns: the precision of the float
     * */
    pub fn createFloatDigValue (self, f : &FloatType)-> usize {
        match (f.getSize (), global::state::instance ().getFloatTypeSize ()) {
            (32u16, _) => { 6us }
            (64u16, _) => {  15us }
            (80u16, _) => {  18us }

            // fsize
            (_, 32u16) => { 6us }
            (_, 64u16) => {  15us }
            _ => {  18us }
        }
    }

    /**
     * Create the number of bits int the mantissa for the type 'f'
     * @params:
     *     - f: a float type
     * @returns: the number of bits in the mantissa
     * */
    pub fn createFloatMantDigValue (self, f : &FloatType)-> usize {
        match (f.getSize (), state::instance ().getFloatTypeSize ()) {
            (32u16, _) => { 24us }
            (64u16, _) => {  53us }
            (80u16, _) => {  64us }

            // fsize
            (_, 32u16) => { 24us }
            (_, 64u16) => {  53us }
            _ => {  64us }
        }
    }

    /**
     * Create the maximum values such that 10^^max is representable by type 'f'
     * @params:
     *     - f: a float type
     * */
    pub fn createFloatMax10ExpValue (self, f : &FloatType)-> usize {
        match (f.getSize (), state::instance ().getFloatTypeSize ()) {
            (32u16, _) => { 38us }
            (64u16, _) => { 308us }
            (80u16, _) => { 4932us }

            // fsize
            (_, 32u16) => { 38us }
            (_, 64u16) => { 308us }
            _ => { 4932us }
        }
    }

    /**
     * Create the minimum values such that 10^^min is representable by type 'f'
     * @params:
     *     - f: a float type
     * */
    pub fn createFloatMin10ExpValue (self, f : &FloatType)-> isize {
        match (f.getSize (), state::instance ().getFloatTypeSize ()) {
            (32u16, _) => { -37is }
            (64u16, _) => {  -307is }
            (80u16, _) => {  -4931is }

            // fsize
            (_, 32u16) => { -37is }
            (_, 64u16) => {  -307is }
            _ => {  -4931is }
        }
    }

    /**
     * Create the maximum values such that 2^^(max-1) is representable by type 'f'
     * @params:
     *     - f: a float type
     * */
    pub fn createFloatMax2ExpValue (self, f : &FloatType)-> usize {
        match (f.getSize (), state::instance ().getFloatTypeSize ()) {
            (32u16, _) => { 128us }
            (64u16, _) => {  1024us }
            (80u16, _) => { 16384us }

            // fsize
            (_, 32u16) => { 128us }
            (_, 64u16) => {  1024us }
            _ => { 16384us }
        }
    }

    /**
     * Create the minimum values such that 2^^(min) is representable by type 'f'
     * @params:
     *     - f: a float type
     * */
    pub fn createFloatMin2ExpValue (self, f : &FloatType)-> isize {
        match (f.getSize (), state::instance ().getFloatTypeSize ()) {
            (32u16, _) => { -125is }
            (64u16, _) => {  -1021is }
            (80u16, _) => { -16381is }

            // fsize
            (_, 32u16) => { -125is }
            (_, 64u16) => {  -1021is }
            _ => { -16381is }
        }
    }

    /**
     * Create the number of decimal digit of precision value for the type 'f'
     * @params:
     *     - f: a float type
     * @returns: the dig value the float can encode
     * */
    pub fn createFloatInfValue (self, _ : &FloatType)-> &BigFloat {
        BigFloat::new (f32::inf)
    }

    /**
     * Create the number of decimal digit of precision value for the type 'f'
     * @params:
     *     - f: a float type
     * @returns: the dig value the float can encode
     * */
    pub fn createFloatEpsilonValue (self, f : &FloatType)-> &BigFloat {
        match (f.getSize (), state::instance ().getFloatTypeSize ()) {
            (32u16, _) => { BigFloat::new (2.0) ^^ (-23i64) }
            (64u16, _) => {  BigFloat::new (2.0) ^^ (-52i64) }
            (80u16, _) => {  BigFloat::new (2.0) ^^ (-63i64) }

            // fsize
            (_, 32u16) => { BigFloat::new (2.0) ^^ (-23i64) }
            (_, 64u16) => {  BigFloat::new (2.0) ^^ (-52i64) }
            _ => {  BigFloat::new (2.0) ^^ (-63i64) }
        }
    } // catch {
    //     _ => __pragma!panic ();
    // }

    /**
     * Create a bigfloat from hexadecimal parts
     * @params:
     *    - int: the int part of the hex literal
     *    - frac: the fractional part of the hex literal
     *    - exp: the exponential part of the hex literal
     * @returns: a bigfloat
     * */
    pub fn createFloatFromHex (self, int : [c8], frac : [c8], exp : [c8])-> &BigFloat {
        import std::conv;

        let intPartV = BigFloat::new (BigInt::new (int.to!{usize, 16us} ()));
        let decPartV = BigFloat::new ((BigInt::new (frac.to!{usize, 16us} ()))) * (BigFloat::new (16.0) ^^ -cast!i64 (frac.len));
        let expPartV = if (exp[0] == '-'c8) {
            BigFloat::new (2.0) ^^ -exp[1us .. $].to!{i64} ()
        } else {
            BigFloat::new (2.0) ^^ exp.to!{i64} ()
        };

        (intPartV + decPartV) * expPartV
    } catch {
        _ => __pragma!panic ();
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================            RANGE             =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Compute a range contain value (x in z..y)
     * */
    fn computeRangeContain (self, rng : &RangeContainValue)-> &Value
        throws &ErrorMsg
    {
        let left = self.compute (rng.getLeft ());
        let right = self.compute (rng.getRight ()).asOf!{&RangeValue} ();

        let fst = self.computeFieldAccessRange (right, RangeKeys::FST);
        let scd = self.computeFieldAccessRange (right, RangeKeys::SCD);

        let contain = self.computeBool (self.computeFieldAccessRange (right, RangeKeys::CONTAIN));

        let check = |x, a, b, contain| => {
            if (contain) {
                if (a < b) {
                    x >= a && x <= b
                } else {
                    x >= b && x <= a
                }
            } else {
                if (a < b) {
                    x >= a && x < b
                } else {
                    x > b && x <= a
                }
            }
        };

        let res = match (left, fst, scd) {
            (i_ : &IntValue, x_ : &IntValue, y_ : &IntValue) => {
                check (i_.getValue (), x_.getValue (), y_.getValue (), contain)
            }
            (i_ : &FloatValue, x_ : &FloatValue, y_ : &FloatValue) => {
                check (i_.getValue (), x_.getValue (), y_.getValue (), contain)
            }
            (i_ : &CharValue, x_ : &CharValue, y_ : &CharValue) => {
                match i_.getEncodingSize () {
                    8u16 => {
                        check (i_.getValue ().utf8, x_.getValue ().utf8, y_.getValue ().utf8, contain)
                    }
                    16u16 => {
                        check (i_.getValue ().utf16, x_.getValue ().utf16, y_.getValue ().utf16, contain)
                    }
                    _ => {
                        check (i_.getValue ().utf32, x_.getValue ().utf32, y_.getValue ().utf32, contain)
                    }
                }

            }
            _ => {
                __pragma!panic ();
            }
        };

        if (rng.getOperator () == Keys::NOT_IN) {
            BoolValue::new (rng.getLoc (), !res)
        } else {
            BoolValue::new (rng.getLoc (), res)
        }
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================            UNARY             =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Compute the value of a unary operation
     * @params: 
     *   - un: the value to compute
     * @returns: the result
     * @throws:
     *   - &ErrorMsg: if the value cannot be known at compile time
     */
    fn computeUnary (self, un : &UnaryOperatorValue)-> &Value
        throws &ErrorMsg
    {
        match un {
            b : &UnaryBoolOperatorValue => self.computeUnaryBool (b);
            i : &UnaryIntOperatorValue => self.computeUnaryInt (i);
            f : &UnaryFloatOperatorValue => self.computeUnaryFloat (f);
            _ => {
                throw ErrorMsg::fatal (un.getLoc (), format (ValidateErrorMessage::UNKNOWN_AT_COMPILE_TIME, un.getType ()));
            }
        }
    }

    /**
     * Compute the value of an unary operator on a bool value
     * @params: 
     *    - un: the unary operator to validate
     * @returns: the result value
     * @throws: 
     *    - &ErrorMsg: if the value cannot be known at compile time
     */
    fn computeUnaryBool (self, un : &UnaryBoolOperatorValue)-> &Value
        throws &ErrorMsg
    {
        let content = self.compute (un.getInner ());
        match un.getOperator () {
            UnaryOperators::NOT => {
                match content {
                    v : &BoolValue => {
                        if (v.isTrue ()) {
                            return BoolValue::new (un.getLoc (), false);
                        } else {
                            return BoolValue::new (un.getLoc (), true);
                        }
                    }
                    _ => throw ErrorMsg::fatal (un.getLoc (), format (ValidateErrorMessage::UNKNOWN_AT_COMPILE_TIME, un.getType ()));
                }
            }
            _ => __pragma!panic ();
        }
    }
    
    /**
     * Compute the value of an unary operator on an int value
     * @params: 
     *    - un: the unary operator to validate
     * @returns: the result value
     * @throws: 
     *    - &ErrorMsg: if the value cannot be known at compile time
     */
    fn computeUnaryInt (self, un : &UnaryIntOperatorValue)-> &Value
        throws &ErrorMsg
    {
        match un.getOperator () {
            UnaryOperators::MINUS => {
                let content = self.compute (un.getInner ());
                match content {
                    v : &IntValue => {
                        return IntValue::new (un.getLoc (), un.getType (), BigInt::new (0) - v.getValue ());
                    }
                }
            }
        }

        throw ErrorMsg::fatal (un.getLoc (), format (ValidateErrorMessage::UNKNOWN_AT_COMPILE_TIME, un.getType ()));
    }

    /**
     * Compute the value of an unary operator on a float value
     * @params:
     *    - un: the unary operator to validate
     * @returns: the result value
     * @throws:
     *    - &ErrorMsg: if the value cannot be known at compile time
     * */
    fn computeUnaryFloat (self, un : &UnaryFloatOperatorValue)-> &Value
        throws &ErrorMsg
    {
        match un.getOperator () {
            UnaryOperators::MINUS => {
                let content = self.compute (un.getInner ());
                match content {
                    v : &FloatValue => {
                        return FloatValue::new (un.getLoc (), un.getType (), BigFloat::new (0.0) - v.getValue ());
                    }
                }
            }
        }

        throw ErrorMsg::fatal (un.getLoc (), format (ValidateErrorMessage::UNKNOWN_AT_COMPILE_TIME, un.getType ()));
    }
    
    /**
     * ================================================================================
     * ================================================================================
     * =========================         SLICE ACCESS         =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Compute a slice access value
     * @params: 
     *   - slc: the value to compute
     * @returns: the result
     * @throws:
     *    - &ErrorMsg: if the value cannot be known at compile time
     */
    fn computeSliceAccess (self, slc : &SliceAccessValue)-> &Value
        throws &ErrorMsg
    {
        let array = self.compute (slc.getSlice ());
        let index = self.compute (slc.getIndex ());
        let u_index = match index {
            i : &IntValue => {
                {
                    i.getValue ().to!usize ()
                } catch {
                    _ => throw ErrorMsg::fatal (i.getLoc (), format (ValidateErrorMessage::OVERFLOW_CAPACITY, IntType::new (i.getLoc (), size-> 0u16, signed-> false), i.getValue (), 12));                    
                }
            }
            _ => {
                throw ErrorMsg::fatal (index.getLoc (), format (ValidateErrorMessage::UNKNOWN_AT_COMPILE_TIME, index.getType ()));
            }
        };

        let res : &Value = match array {
            a : &ArrayValue => {
                if (a.getInners ().len <= u_index) {
                    throw ErrorMsg::fatal (a.getLoc (), format (ValidateErrorMessage::ARRAY_OVERFLOW, a.getInners ().len, u_index));
                }

                a.getInners ()[u_index]
            }
            str : &StringValue => {
                if (str.getLen () <= u_index) {
                    throw ErrorMsg::fatal (str.getLoc (), format (ValidateErrorMessage::ARRAY_OVERFLOW, str.getLen (), u_index));
                }

                let chType = str.getType ().asOf!{&SliceType} ().getInners ()[0];
                match str.getEncodingSize () {
                    8u16 => {
                        cast!{&Value} (CharValue::new (slc.getLoc (), chType, str.getValue ().utf8 [u_index]))
                    }
                    16u16 => {
                        cast!{&Value} (CharValue::new (slc.getLoc (), chType, str.getValue ().utf16 [u_index]))
                    }
                    _ => {
                        cast!{&Value} (CharValue::new (slc.getLoc (), chType, str.getValue ().utf32 [u_index]))
                    }
                }
            }
            _ => {
                throw ErrorMsg::fatal (array.getLoc (), format (ValidateErrorMessage::UNKNOWN_AT_COMPILE_TIME, array.getType ()));
            }
        };

        res
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================         ARRAY ACCESS         =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Compute an array access
     * */
    fn computeArrayAccessValue (self, a : &ArrayAccessValue)-> &Value
        throws &ErrorMsg
    {
        let value = self.compute (a.getArray ());
        let index = self.compute (a.getIndex ());

        match (value, index) {
            (lit : &ArrayValue, i : &IntValue) => {
                {
                    return lit.getInners ()[i.getValue ().to!{usize} ()];
                } catch {
                    _ => __pragma!panic ();
                }
            }
            _ => {
                throw ErrorMsg::fatal (a.getLoc (), format (ValidateErrorMessage::UNKNOWN_AT_COMPILE_TIME, a.getType ()));
            }
        }
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================         FIELD ACCESS         =========================
     * ================================================================================
     * ================================================================================
     */


    /**
     * Compute a field access on a tuple
     * */
    fn computeFieldAccessTuple (self, tu : &TupleFieldAccessValue)-> &Value
        throws &ErrorMsg
    {
        match tu.getTuple () {
            lit : &TupleValue => {
                return self.compute (lit.getInners ()[tu.getFieldIndex ()]);
            }
        }

        let inner = self.compute (tu.getTuple ());
        match inner {
            lit : &TupleValue => {
                return lit.getInners ()[tu.getFieldIndex ()];
            }
            _ => {
                throw ErrorMsg::fatal (inner.getLoc (), format (ValidateErrorMessage::UNKNOWN_AT_COMPILE_TIME, inner.getType ()));
            }
        }
    }

    /**
     * Compute the value of a struct field access
     * @params:
     *    - acc: the value to compute
     */
    fn computeFieldAccess (self, acc : &StructFieldAccessValue)-> &Value
        throws &ErrorMsg
    {
        match acc.getStruct () {
            rng : &RangeValue => {
                return self.computeFieldAccessRange (rng, acc.getFieldName ());
            }
            slc : &SliceValue => {
                return self.computeFieldAccessSlice (slc, acc.getFieldName ());
            }
            v : &VarRefValue => {
                match v.getValue () {
                    rng : &RangeValue => { return self.computeFieldAccessRange (rng, acc.getFieldName ()); }
                    slc : &SliceValue => { return self.computeFieldAccessSlice (slc, acc.getFieldName ()); }
                }
            }
        }

        let inner = self.compute (acc.getStruct ());
        match inner {
            rng : &RangeValue => {
                self.computeFieldAccessRange (rng, acc.getFieldName ())
            }
            slc : &SliceValue => {
                self.computeFieldAccessSlice (slc, acc.getFieldName ())
            }
            _ => {
                throw ErrorMsg::fatal (inner.getLoc (), format (ValidateErrorMessage::UNKNOWN_AT_COMPILE_TIME, inner.getType ()));
            }
        }
    }

    /**
     * Compute the value of a struct field access on a range value
     * @params:
     *    - rng: the range value that is accessed
     *    - field: the name of the field being accessed
     */
    fn computeFieldAccessRange (self, rng : &RangeValue, field : [c8])-> &Value
        throws &ErrorMsg
    {
        match field {
            RangeKeys::STEP => {
                self.compute (rng.getStep ())
            }
            RangeKeys::CONTAIN => {
                self.compute (rng.getIsFull ())
            }
            RangeKeys::SCD => {
                self.compute (rng.getRight ())
            }
            RangeKeys::FST => {
                self.compute (rng.getLeft ())
            }
            _ => {
                __pragma!panic ();
            }
        }
    }

    /**
     * Compute the value of a field access on a slice value
     */
    fn computeFieldAccessSlice (self, slc : &SliceValue, field: [c8])-> &Value
        throws &ErrorMsg
    {
        match field {
            SliceKeys::LEN => {
                match slc.getInner () {
                    arr : &ArrayValue => {
                        return makeIntValue (slc.getLoc (), arr.getLen ());
                    }
                    s : &StringValue => {
                        return makeIntValue (slc.getLoc (), s.getLen ());
                    }
                    cp : &CopierValue => {
                        let inner = self.compute (cp.getValue ());
                        match inner {
                            arr : &ArrayValue => {
                                return makeIntValue (slc.getLoc (), arr.getLen ());
                            }
                            s : &StringValue => {
                                return makeIntValue (slc.getLoc (), s.getLen ());
                            }
                            s : &SliceValue => {
                                match s.getInner () {
                                    arr : &ArrayValue => {
                                        return makeIntValue (slc.getLoc (), arr.getLen ());
                                    }
                                    str : &StringValue => {
                                        return makeIntValue (slc.getLoc (), str.getLen ());
                                    }
                                }
                            }
                            s : &SliceCtorValue => {
                                return self.compute (s.getLen ());
                            }
                        }
                    }
                }
            }
        }

        throw ErrorMsg::fatal (slc.getLoc (), format (ValidateErrorMessage::UNKNOWN_AT_COMPILE_TIME, slc.getType ()));   
    }

    
    /**
     * ================================================================================
     * ================================================================================
     * =========================      CONDITION / LOOPS       =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Compute a conditional value
     * @params:
     *   - cd: the value to compute
     * @returns: the result
     * @throws:
     *    - &ErrorMsg: if the value cannot be known at compile time
     */
    fn computeConditional (self, cd : &ConditionalValue)-> &Value
        throws &ErrorMsg
    {
        let test = self.compute (cd.getTest ());
        let isTrue = match test {
            b : &BoolValue => {
                b.isTrue ()
            }
            _ => {
                throw ErrorMsg::fatal (test.getLoc (), format (ValidateErrorMessage::UNKNOWN_AT_COMPILE_TIME, test.getType ()));
            }
        };

        if (isTrue) {
            self.compute (cd.getContent ())
        } else match cd.getElse () {
            NoneValue () => {
                throw ErrorMsg::fatal (cd.getLoc (), format (ValidateErrorMessage::UNKNOWN_AT_COMPILE_TIME, cd.getType ()));
            }
            e : _ => {
                self.compute (e)
            }
        }     
    }

    /**
     * Compute a block value
     * @params:
     *   - bl: the block value to compute
     * @returns: the result
     * @throws:
     *    - &ErrorMsg: if the value cannot be known at compile time
     */
    fn computeBlock (self, block : &BlockValue)-> &Value
        throws &ErrorMsg
    {
        if (block.getValues ().len > 1us) {
            throw ErrorMsg::warn (block.getLoc (), format (ValidateErrorMessage::CTE_IGNORED, block.getValues ().len - 1us));
        }

        if (block.getValues ().len == 0us) {
            throw ErrorMsg::fatal (block.getLoc (), format (ValidateErrorMessage::UNKNOWN_AT_COMPILE_TIME, block.getType ()));
        }

        self.compute (block.getValues ()[$ - 1us])
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================             VARS             =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Compute a var ref value
     * @params:
     *   - bl: the value to compute
     * @returns: the result
     * @throws:
     *    - &ErrorMsg: if the value cannot be known at compile time
     */
    fn computeVarRef (self, vref : &VarRefValue)-> &Value
        throws &ErrorMsg
    {
        if (vref.getValue ().isOf!{&NoneValue} () || !vref.canCte ()) {
            throw ErrorMsg::fatal (vref.getLoc (), format (ValidateErrorMessage::UNKNOWN_AT_COMPILE_TIME, vref.getType ()));
        }

        self.compute (vref.getValue ())
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================         CAST VALUES          =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Compute a cast value
     * */
    fn computeCastValue (self, c : &CastValue)-> &Value
        throws &ErrorMsg
    {
        match c.getType () {
            iT : &IntType => { return self.computeCastToInt (c.getLoc (), c.getContent (), iT); }
            cT : &CharType => { return self.computeCastToChar (c.getLoc (), c.getContent (), cT); }
            fT : &FloatType => { return self.computeCastToFloat (c.getLoc (), c.getContent (), fT); }
            _ => {
                throw ErrorMsg::fatal (c.getLoc (), format (ValidateErrorMessage::UNKNOWN_AT_COMPILE_TIME, c.getType ()));
            }
        }
    }

    /**
     * Compute a cast to a int value
     * */
    fn computeCastToInt (self, loc : &Word, c : &Value, iT : &IntType)-> &Value
        throws &ErrorMsg
    {
        let value = self.compute (c);
        match (value) {
            i : &IntValue => {
                self.verifyOverFlowInt (loc, iT, i.getValue ());
                IntValue::new (loc, iT, i.getValue ())
            }
            ch : &CharValue => {
                let ival = match ch.getEncodingSize () {
                    8u16 => { BigInt::new (ch.getValue ().utf8) }
                    16u16 => { BigInt::new (ch.getValue ().utf16) }
                    _ => {  BigInt::new (ch.getValue ().utf32) }
                };
                self.verifyOverFlowInt (loc, iT, ival);
                IntValue::new (loc, iT, ival)
            }
            b : &BoolValue => {
                if (b.isTrue ()) {
                    IntValue::new (loc, iT, BigInt::new (1))
                } else {
                    IntValue::new (loc, iT, BigInt::new (0))
                }
            }
            f : &FloatValue => {
                let ival = BigInt::new (f.getValue ());
                self.verifyOverFlowInt (loc, iT, ival);

                IntValue::new (loc, iT, ival)
            }
            _ => {
                throw ErrorMsg::fatal (c.getLoc (), format (ValidateErrorMessage::UNKNOWN_AT_COMPILE_TIME, c.getType ()));
            }
        }
    }

    /**
     * Compute a cast to a float value
     * */
    fn computeCastToFloat (self, loc : &Word, c : &Value, fT : &FloatType)-> &Value
        throws &ErrorMsg
    {
        let value = self.compute (c);
        match value {
            i : &IntValue => {
                return FloatValue::new (loc, fT, BigFloat::new (i.getValue ()));
            }
            f : &FloatValue => {
                return FloatValue::new (loc, fT, f.getValue ());
            }
            _ => {
                throw ErrorMsg::fatal (c.getLoc (), format (ValidateErrorMessage::UNKNOWN_AT_COMPILE_TIME, c.getType ()));
            }
        }
    }

    /**
     * Compute a cast to a char value
     * */
    fn computeCastToChar (self, loc : &Word, c : &Value, ct : &CharType)-> &Value
        throws &ErrorMsg
    {
        let value = self.compute (c);
        match (value, ct.getSize ()) {
            (i : &IntValue, 8u16) => {
                self.verifyOverFlowChar (loc, ct, i.getValue ());
                CharValue::new (loc, ct, i.getValue ().to!{u8} ())
            }
            (i : &IntValue, 16u16) => {
                self.verifyOverFlowChar (loc, ct, i.getValue ());
                CharValue::new (loc, ct, i.getValue ().to!{u16} ())
            }
            (i : &IntValue, _) => {
                self.verifyOverFlowChar (loc, ct, i.getValue ());
                CharValue::new (loc, ct, i.getValue ().to!{u32} ())
            }
            _ => {
                throw ErrorMsg::fatal (c.getLoc (), format (ValidateErrorMessage::UNKNOWN_AT_COMPILE_TIME, c.getType ()));
            }
        }
    } catch {
        _ : &BigIntError => __pragma!panic ();
        e : &ErrorMsg => throw e;
    }


    /**
     * ================================================================================
     * ================================================================================
     * =========================         CALL VALUES          =========================
     * ================================================================================
     * ================================================================================
     */


    /**
     * ================================================================================
     * ================================================================================
     * =========================         CALL VALUES          =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Compute the value of a call value
     * @params:
     *    - cl: the call value to compute
     */
    fn computeCallValue (self, cl : &CallValue)-> &Value
        throws &ErrorMsg
    {
        match (cl.getParameters ().len, cl.getPrototype ().getSymbol ()) {
            (0us, func : &FunctionSymbol) => {
                match func.getFrameBody () {
                    v : &Value => {
                        {
                            if (v.isOf!{&ReturnValue} ()) {
                                return self.compute (v.asOf!{&ReturnValue} ().getValue ());
                            } else {
                                return self.compute (v);
                            }
                        } catch {
                            err : &ErrorMsg => {
                                throw ErrorMsg::fatal (cl.getLoc (), format (ValidateErrorMessage::UNKNOWN_AT_COMPILE_TIME, cl.getType ()),
                                                       notes-> [err]);
                            }
                        }
                    }
                }
            }
        }
        
        throw ErrorMsg::fatal (cl.getLoc (), format (ValidateErrorMessage::UNKNOWN_AT_COMPILE_TIME, cl.getType ()));
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================         MISC VALUES          =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Compute an address operator value
     * @params:
     *   - addr: the value to compute
     * @returns: the result
     * @throws:
     *    - &ErrorMsg: if the value cannot be known at compile time
     */
    fn computeAddress (self, addr : &AddressValue)-> &Value
        throws &ErrorMsg
    {
        match (addr.getType (), addr.getInner ()) {
            (FuncPtrType (), PrototypeValue ()) => { // Ok if this is an address to a function 
                addr
            }
            _ => {
                throw ErrorMsg::fatal (addr.getLoc (), format (ValidateErrorMessage::UNKNOWN_AT_COMPILE_TIME, addr.getType ()));
            }
        }
    }

    /**
     * Compute the value of an aliaser
     */
    fn computeAliaser (self, al : &AliaserValue)-> &Value
        throws &ErrorMsg
    {
        let inner = self.compute (al.getInnerValue ());
        AliaserValue::new (al.getLoc (),
                           al.getType (),
                           inner)
    }

    /**
     * Compute the value contained in a slice 
     */
    fn computeSliceValue (self, al : &SliceValue)-> &Value
        throws &ErrorMsg
    {
        let inner = self.compute (al.getInner ());
        SliceValue::new (al.getLoc (),
                         al.getType (),
                         inner, implicitAlias-> al.isAliaser ())
    }

}
