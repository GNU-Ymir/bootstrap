mod ymirc::semantic::validator::interpret;

import ymirc::semantic::generator::_;
import ymirc::errors::message;
import std::io;
import ymirc::utils::bigint;

import ymirc::lexing::word;
import ymirc::syntax::keys;
import ymirc::utils::format;
import ymirc::semantic::validator::errors;

import std::collection::vec;

/**
 * The compile time interpreter, is the class that can compute the values at compilation time
 * It is used to compute some stuff, that must be known at compilation time, or for optimization purpose
 */
pub class CompileTimeInterpreter {

    /**
     * Create an empty interpreter
     */
    pub self () {}

    /**
     * Simplify the value by computing what can be computed at compilation time
     * @params:
     *    - value: the value to simplify
     * @returns: the simplified value
     * @throws: if there was an error during the simplification (detecting int overflow for example)
     */
    pub def simplify (self, value : &Value)-> &Value
        throws &ErrorMsg
    {
        match value {
            LiteralValue () => { value }
            rng : &RangeValue => { self.simplifyRangeValue (rng) }
            slc : &SliceConcatValue => { self.simplifySliceConcat (slc) }
            slc : &SliceCompareValue => { self.simplifySliceCompare (slc) }
            slc : &SliceAccessValue => { self.simplifySliceAccess (slc) }
            bin : &BinaryOperatorValue => { self.simplifyBinary (bin) }
            un : &UnaryOperatorValue => { self.simplifyUnary (un) }
            cd : &ConditionalValue => { self.simplifyConditional (cd) }
            bl : &BlockValue => { self.simplifyBlock (bl) }
            vref : &VarRefValue => { self.simplifyVarRef (vref) }
            u : &UniqValue => { self.simplifyUniq (u) }           
            s : &StructFieldAccessValue => { self.simplifyFieldAccess (s) }
            _ => {
                value
            }                
        }        
    }            

    /**
     * Compute the value of `value`, by transforming it into a literal of some sort, that can be interpreted by the compiler as a single value
     * @params: 
     *   - value: the value to interpret
     * @returns: a literal value of some kind (TODO, define precisely what kind ?)
     * @throws: &ErrorMsg: if the value cannot be known at compilation time
     */
    pub def compute (self, value : &Value)-> &Value
        throws &ErrorMsg
    {
        match value {
            LiteralValue () => { value }
            rng : &RangeValue => { self.computeRangeValue (rng) }
            slc : &SliceConcatValue => { self.computeSliceConcat (slc) }
            slc : &SliceCompareValue => { self.computeSliceCompare (slc) }
            slc : &SliceAccessValue => { self.computeSliceAccess (slc) }
            bin : &BinaryOperatorValue => { self.computeBinary (bin) }
            un : &UnaryOperatorValue => { self.computeUnary (un) }
            cd : &ConditionalValue => { self.computeConditional (cd) }
            bl : &BlockValue => { self.computeBlock (bl) }
            vref : &VarRefValue => { self.computeVarRef (vref) }
            addr : &AddressValue => { self.computeAddress (addr) }
            u : &UniqValue => { self.compute (u.getValue ()) }
            s : &StructFieldAccessValue => { self.computeFieldAccess (s) }
            _ => {
                throw ErrorMsg::fatal (value.getLoc (), format (ValidateErrorMessage::UNKNOWN_AT_COMPILE_TIME, value.getType ()));
            }                
        }
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================            RANGE             =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Compute the content of a range value at compilation time
     * @params: 
     *   - value: the range value to compute
     * @returns: a range value
     * @throws: &ErrorMsg if the value cannot be known at compilation time
     */
    def computeRangeValue (self, value : &RangeValue)-> &Value
        throws &ErrorMsg
    {
        let left = self.compute (value.getLeft ());
        let right = self.compute (value.getRight ());
        let full = self.compute (value.getIsFull ());
        let step = match value.getStep () {
            n : &NoneValue => { cast!{&Value} (n) }
            s : &Value => { self.compute (s) }
        }
        
        RangeValue::new (value.getLoc (), value.getType (), left, right, full-> full, step-> step)
    }

    /**
     * Simplify the content of a range value at compilation time
     * @params:
     *    - value: the range value to simplify
     * @returns: a range value
     */
    def simplifyRangeValue (self, value : &RangeValue)-> &Value
        throws &ErrorMsg
    {
        let left = self.simplify (value.getLeft ());
        let right = self.simplify (value.getRight ());
        let full = self.simplify (value.getIsFull ());
        let step = match value.getStep () {
            n : &NoneValue => { cast!{&Value} (n) }
            s : &Value => { self.simplify (s) }
        }
        
        RangeValue::new (value.getLoc (), value.getType (), left, right, full-> full, step-> step)        
    }

    
    /**
     * ================================================================================
     * ================================================================================
     * =========================        CONCATENATION         =========================
     * ================================================================================
     * ================================================================================
     */
    
    /**
     * Compute a slice concatenation operation
     * @params: 
     *  - value: the value to compute
     * @returns: the value
     * @throws: 
     *   - &ErrorMsg: if the value cannot be known at compilation time
     */
    def computeSliceConcat (self, value : &SliceConcatValue)-> &Value
        throws &ErrorMsg
    {
        let left = match self.compute (value.getLeft ()) {
            al : &AliaserValue => { al.getInnerValue () }
            l : _ => { l }
        };

        let right = match self.compute (value.getRight ()) {
            al : &AliaserValue => { al.getInnerValue () }
            r : _ => { r }
        };

        let res = match (left, right) {
            (l : &StringValue, r : &StringValue) => {
                self.concatStrings (value.getLoc (), value.getType (), l, r)
            }
            // (l : &LiteralValue, r : &LiteralValue) => {
            //     self.concatArrays (value.getLoc (), value.getType (), l, r)
            // }
            _ => {
                throw ErrorMsg::fatal (value.getLoc (), format (ValidateErrorMessage::UNKNOWN_AT_COMPILE_TIME, value.getType ()));
            }            
        }

        res
    }

    /**
     * Simplify a slice concatenation
     */
    def simplifySliceConcat (self, value : &SliceConcatValue)-> &Value
        throws &ErrorMsg
    {
        let left = match self.simplify (value.getLeft ()) {
            al : &AliaserValue => { al.getInnerValue () }
            l : _ => { l }
        };

        let right = match self.simplify (value.getRight ()) {
            al : &AliaserValue => { al.getInnerValue () }
            r : _ => { r }
        };

        match (left, right) {
            (l : &StringValue, r : &StringValue) => {
                self.concatStrings (value.getLoc (), value.getType (), l, r)
            }
            _ => {
                cast!{&Value} (SliceConcatValue::new (value.getLoc (), value.getType (), left, right))
            }            
        }   
    }
    
    /**
     * Concatenation of two string values
     * @params: 
     *  - loc: the location of the operation
     *  - type: the type of the operation
     *  - left: the left operand of the concat
     *  - right: the right operand of the concat
     * @returns: a aliaservalue containing a new string value
     */
    def concatStrings (self, loc : &Word, type : &Type, left : &StringValue, right : &StringValue)-> &Value {
        match type {
            s : &SliceType => {
                match s.getInners ()[0] {
                    c : &CharType => {
                        if (c.getSize () == 8u16) {
                            return self.concatUtf8 (loc, left, right);
                        } else {
                            return self.concatUtf32 (loc, left, right);
                        }
                    }
                }
            }
        }

        __pragma!panic ();
    }

    /**
     * Concatenate two strings in utf-8 format
     * @params: 
     *   - loc: the location of the operation
     *   - left: the left operand
     *   - right: the right operand
     * @returns: a aliaservalue containing a new string value
     */
    def concatUtf8 (self, loc : &Word, left : &StringValue, right : &StringValue)-> &Value {
        let dmut res = Vec!{c8}::new ();
        let l_u8 = left.getUtf8 ();
        let r_u8 = right.getUtf8 ();
        for i in 0us .. left.getLen () {
            res:.push (l_u8 [i]);
        }
        
        for i in 0us .. right.getLen () {
            res:.push (r_u8 [i]);
        }

        let len = left.getLen () + right.getLen ();
        res:.push ('\u{0}'c8);
        
        let inner = CharType::new (loc, size-> 8u16);
        let arrType = ArrayType::new (loc, inner, size-> int::usize (loc, len), isMutable-> true);
        let slcType = SliceType::new (loc, inner, isMutable-> true);

        AliaserValue::new (
            loc,
            slcType,
            StringValue::new (loc, arrType, c8Val-> res[], c32Val-> [], len)) 
    }

    /**
     * Concatenate two strings in utf-32 format
     * @params: 
     *   - loc: the location of the operation
     *   - left: the left operand
     *   - right: the right operand
     * @returns: a aliaservalue containing a new string value
     */
    def concatUtf32 (self, loc : &Word, left : &StringValue, right : &StringValue)-> &Value {
        let dmut res = Vec!{c32}::new ();
        let l_u32 = left.getUtf32 ();
        let r_u32 = right.getUtf32 ();
        for i in 0us .. left.getLen () {
            res:.push (l_u32 [i]);
        }
        
        for i in 0us .. right.getLen () {
            res:.push (r_u32 [i]);
        }

        let len = left.getLen () + right.getLen ();
        res:.push ('\u{0}');
        
        let inner = CharType::new (loc, size-> 32u16);
        let arrType = ArrayType::new (loc, inner, size-> int::usize (loc, len), isMutable-> true);
        let slcType = SliceType::new (loc, inner, isMutable-> true);

        AliaserValue::new (
            loc,
            slcType,
            StringValue::new (loc, arrType, c8Val-> [], c32Val-> res[], len)) 

    }

    /**
     * Concatenate two arrays
     * @params: 
     *   - loc: the location of the operation
     *   - type: the type of the result
     *   - left: the left operand
     *   - right: the right operand
     * @returns: the result 
     */
    def concatArrays (self, loc : &Word, type : &Type, left : &ArrayValue, right : &ArrayValue)-> &Value {
        let dmut res = Vec!{&Value}::new ();
        let l = left.getInners ();
        let r = right.getInners ();
        for i in 0us .. l.len {
            res:.push (l[i]);
        }

        for j in 0us .. r.len {
            res:.push (r[j]);
        }

        let inner = type.asOf!{&ArrayType}().getInners ()[0];
        let arrType = ArrayType::new (loc, inner, size-> int::usize (loc, res.len ()), isMutable-> true);

        ArrayValue::new (loc, arrType, res[])
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================          COMPARISON          =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Compute the value of a slice comparison
     * @params: 
     *   - value: the value to execute a cte
     * @returns: the result value
     * @throws: 
     *  - &ErrorMsg: if the value cannot be known at compilation time
     */
    def computeSliceCompare (self, value : &SliceCompareValue)-> &Value
        throws &ErrorMsg
    {
        let left = match self.compute (value.getLeft ()) {
            al : &AliaserValue => { al.getInnerValue () }
            l : _ => { l }
        };

        let right = match self.compute (value.getRight ()) {
            al : &AliaserValue => { al.getInnerValue () }
            r : _ => { r }
        };

        let res = match (left, right) {
            (l : &StringValue, r : &StringValue) => {                
                BoolValue::new (value.getLoc (), (l == r))
            }
            (l : &ArrayValue, r : &ArrayValue) => {
                BoolValue::new (value.getLoc (), (l == r))
            }
            _ => {
                throw ErrorMsg::fatal (value.getLoc (), format (ValidateErrorMessage::UNKNOWN_AT_COMPILE_TIME, value.getType ()));
            }            
        }

        res
    }

    /**
     * Simplify a slice comparison value
     */
    def simplifySliceCompare (self, value : &SliceCompareValue)-> &Value
        throws &ErrorMsg
    {
        let left = match self.simplify (value.getLeft ()) {
            al : &AliaserValue => { al.getInnerValue () }
            l : _ => { l }
        };

        let right = match self.simplify (value.getRight ()) {
            al : &AliaserValue => { al.getInnerValue () }
            r : _ => { r }
        };

        let ret : &Value = match (left, right) {
            (l : &StringValue, r : &StringValue) => {                
                cast!{&Value} (BoolValue::new (value.getLoc (), (l == r)))
            }
            (l : &ArrayValue, r : &ArrayValue) => {
                cast!{&Value} (BoolValue::new (value.getLoc (), (l == r)))
            }
            _ => {
                cast!{&Value} (SliceCompareValue::new (value.getLoc (), value.getType (), left, right))
            }            
        };

        ret
    }
    
    /**
     * ================================================================================
     * ================================================================================
     * =========================            BINARY            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Compute the value of a binary operation
     * @params: 
     *   - bin: the value to compute
     * @returns: the result
     * @throws:
     *   - &ErrorMsg: if the value cannot be known at compile time
     */
    def computeBinary (self, bin : &BinaryOperatorValue)-> &Value
        throws &ErrorMsg
    {
        match bin {
            iBin : &BinaryMathIntOperatorValue => {
                return self.computeBinMathInt (iBin);
            }
            cmp : &CmpIntOperatorValue => {
                return self.computeCompareIntValue (cmp);
            }
            _ => {
                throw ErrorMsg::fatal (bin.getLoc (), format (ValidateErrorMessage::UNKNOWN_AT_COMPILE_TIME, bin.getType ()));
            }
        }
    }

    /**
     * Simplify a binary operator
     */
    def simplifyBinary (self, bin : &BinaryOperatorValue)-> &Value
        throws &ErrorMsg
    {
        match bin {
            iBin : &BinaryMathIntOperatorValue => {
                return self.simplifyBinMathInt (iBin);
            }
            cmp : &CmpIntOperatorValue => {
                return self.simplifyCompareIntValue (cmp);
            }
            _ => {
                bin
            }
        }
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================       BINARY CMP INT        ==========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Compute the value of int binary comparison
     * @params:
     *     - bin: the operator to compute
     * @returns: the result
     * @throws:
     *    - &ErrorMsg: if the value cannot be knwon at compile time
     */
    def computeCompareIntValue (self, bin : &CmpIntOperatorValue)-> &Value
        throws &ErrorMsg
    {
        let left = self.compute (bin.getLeft ());
        let right = self.compute (bin.getRight ());
        match (left, right) {
            (l : &IntValue, r : &IntValue) => {
                match bin.getOperator () {
                    BinaryOperators::INF => { return BoolValue::new (bin.getLoc (), l.getValue () < r.getValue ()); }
                    BinaryOperators::SUP => { return BoolValue::new (bin.getLoc (), l.getValue () > r.getValue ()); }
                    BinaryOperators::INF_EQUAL => { return BoolValue::new (bin.getLoc (), l.getValue () <= r.getValue ()); }
                    BinaryOperators::SUP_EQUAL => { return BoolValue::new (bin.getLoc (), l.getValue () >= r.getValue ()); }
                    BinaryOperators::NOT_EQUAL => { return BoolValue::new (bin.getLoc (), l.getValue () != r.getValue ()); }
                    BinaryOperators::DEQUAL => { return BoolValue::new (bin.getLoc (), l.getValue () == r.getValue ()); }
                    _ => __pragma!panic ();
                }                    
            }
            _ => __pragma!panic ();
        }
    }

    /**
     * Simplify a binary int comparison
     */
    def simplifyCompareIntValue (self, bin : &CmpIntOperatorValue)-> &Value
        throws &ErrorMsg
    {
        let left = self.simplify (bin.getLeft ());
        let right = self.simplify (bin.getRight ());
        match (left, right) {
            (l : &IntValue, r : &IntValue) => {
                match bin.getOperator () {
                    BinaryOperators::INF => { return BoolValue::new (bin.getLoc (), l.getValue () < r.getValue ()); }
                    BinaryOperators::SUP => { return BoolValue::new (bin.getLoc (), l.getValue () > r.getValue ()); }
                    BinaryOperators::INF_EQUAL => { return BoolValue::new (bin.getLoc (), l.getValue () <= r.getValue ()); }
                    BinaryOperators::SUP_EQUAL => { return BoolValue::new (bin.getLoc (), l.getValue () >= r.getValue ()); }
                    BinaryOperators::NOT_EQUAL => { return BoolValue::new (bin.getLoc (), l.getValue () != r.getValue ()); }
                    BinaryOperators::DEQUAL => { return BoolValue::new (bin.getLoc (), l.getValue () == r.getValue ()); }
                    _ => __pragma!panic ();
                }                    
            }
            _ => {
                return CmpIntOperatorValue::new (bin.getLoc (), bin.getOperator (), left, right);
            }
        }
    }
        
    /**
     * ================================================================================
     * ================================================================================
     * =========================       BINARY MATH INT        =========================
     * ================================================================================
     * ================================================================================
     */
    
    /**
     * Compute the value of a int binary math operator
     * @params: 
     *    - bin: the operator to compute
     * @returns: the result
     * @throws:
     *    - &ErrorMsg: if the value cannot be known at compile time
     */
    def computeBinMathInt (self, bin : &BinaryMathIntOperatorValue)-> &Value
        throws &ErrorMsg
    {    
        let left = self.compute (bin.getLeft ());
        let right = self.compute (bin.getRight ());
        
        match (left, right, bin.getType ()) {
            (l : &IntValue, r : &IntValue, t : &IntType) => {
                match bin.getOperator () {
                    BinaryOperators::PLUS => { return self.computeBinMathIntAdd (bin.getLoc (), t, l, r); }
                    BinaryOperators::MINUS => { return self.computeBinMathIntSub (bin.getLoc (), t, l, r); }
                    BinaryOperators::STAR => { return self.computeBinMathIntMul (bin.getLoc (), t, l, r); }
                    BinaryOperators::PERCENT => { return self.computeBinMathIntMod (bin.getLoc (), t, l, r); }
                    BinaryOperators::DIV => { return self.computeBinMathIntDiv (bin.getLoc (), t, l, r); }
                    BinaryOperators::DXOR => { return self.computeBinMathIntPow (bin.getLoc (), t, l, r); }
                    _ => __pragma!panic ();
                }
            }
            _ => __pragma!panic ();
        }        
    }

    /**
     * Simplify a math binary int
     */
    def simplifyBinMathInt (self, bin : &BinaryMathIntOperatorValue)-> &Value
        throws &ErrorMsg
    {
        let left = self.simplify (bin.getLeft ());
        let right = self.simplify (bin.getRight ());
        
        match (left, right, bin.getType ()) {
            (l : &IntValue, r : &IntValue, t : &IntType) => {
                match bin.getOperator () {
                    BinaryOperators::PLUS => { return self.computeBinMathIntAdd (bin.getLoc (), t, l, r); }
                    BinaryOperators::MINUS => { return self.computeBinMathIntSub (bin.getLoc (), t, l, r); }
                    BinaryOperators::STAR => { return self.computeBinMathIntMul (bin.getLoc (), t, l, r); }
                    BinaryOperators::PERCENT => { return self.computeBinMathIntMod (bin.getLoc (), t, l, r); }
                    BinaryOperators::DIV => { return self.computeBinMathIntDiv (bin.getLoc (), t, l, r); }
                    BinaryOperators::DXOR => { return self.computeBinMathIntPow (bin.getLoc (), t, l, r); }
                    _ => __pragma!panic ();
                }
            }
            _ => {
                return BinaryMathIntOperatorValue::new (bin.getLoc (), bin.getType (), bin.getOperator (), left, right);
            }
        }                
    }

    
    /**
     * Compute an addition between two int values
     * @params: 
     *    - type: the type of the addition
     *    - left: the left operand
     *    - right: the right operand
     * @returns: the result of the addition
     */
    def computeBinMathIntAdd (self, loc : &Word, type : &IntType, left : &IntValue, right : &IntValue)-> &Value
        throws &ErrorMsg
    {
        let r = left.getValue () + right.getValue ();
        self.verifyOverFlowInt (loc, type, r);
        
        IntValue::new (loc, type, r)
    }

    /**
     * Compute an substraction between two int values
     * @params: 
     *    - type: the type of the addition
     *    - left: the left operand
     *    - right: the right operand
     * @returns: the result of the addition
     */
    def computeBinMathIntSub (self, loc : &Word, type : &IntType, left : &IntValue, right : &IntValue)-> &Value
        throws &ErrorMsg
    {
        let r = left.getValue () - right.getValue ();
        self.verifyOverFlowInt (loc, type, r);
        
        IntValue::new (loc, type, r)
    }

    /**
     * Compute an multiplication between two int values
     * @params: 
     *    - type: the type of the addition
     *    - left: the left operand
     *    - right: the right operand
     * @returns: the result of the addition
     */
    def computeBinMathIntMul (self, loc : &Word, type : &IntType, left : &IntValue, right : &IntValue)-> &Value
        throws &ErrorMsg
    {
        let r = left.getValue () * right.getValue ();
        self.verifyOverFlowInt (loc, type, r);
        
        IntValue::new (loc, type, r)
    }

    /**
     * Compute a division between two int values
     * @params: 
     *    - type: the type of the addition
     *    - left: the left operand
     *    - right: the right operand
     * @returns: the result of the addition
     */
    def computeBinMathIntDiv (self, loc : &Word, type : &IntType, left : &IntValue, right : &IntValue)-> &Value
        throws &ErrorMsg
    {        
        let r = {
            left.getValue () / right.getValue () 
        } catch {
            _ => throw ErrorMsg::fatal (loc, ValidateErrorMessage::DIVISION_BY_ZERO);
        };
        
        self.verifyOverFlowInt (loc, type, r);
        
        IntValue::new (loc, type, r)
    }

    /**
     * Compute a modulo between two int values
     * @params: 
     *    - type: the type of the addition
     *    - left: the left operand
     *    - right: the right operand
     * @returns: the result of the addition
     */
    def computeBinMathIntMod (self, loc : &Word, type : &IntType, left : &IntValue, right : &IntValue)-> &Value
        throws &ErrorMsg
    {        
        let r = {
            left.getValue () % right.getValue () 
        } catch {
            _ => throw ErrorMsg::fatal (loc, ValidateErrorMessage::DIVISION_BY_ZERO);
        };
        
        self.verifyOverFlowInt (loc, type, r);
        
        IntValue::new (loc, type, r)
    }

    /**
     * Compute a power between two int values
     * @params: 
     *    - type: the type of the addition
     *    - left: the left operand
     *    - right: the right operand
     * @returns: the result of the addition
     */
    def computeBinMathIntPow (self, loc : &Word, type : &IntType, left : &IntValue, right : &IntValue)-> &Value
        throws &ErrorMsg
    {        
        let r = {
            left.getValue () ^^ right.getValue ()
        } catch {
            _ => throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::OVERFLOW_CAPACITY, right.getType (), right, u64::max));
        }
        
        self.verifyOverFlowInt (loc, type, r);
        
        IntValue::new (loc, type, r)
    }    

    /**
     * Verify that the int value does not exceed the capacities of the type
     * @params: 
     *    - type: the type of the int value
     *    - val: the content of the int value
     * @throws:
     *    - &ErrorMsg: if there is an overflow
     */
    def verifyOverFlowInt (self, loc : &Word, type : &IntType, val : &BigInt)
        throws &ErrorMsg
    {
        let (over_, max) =  match (type.getSize (), type.isSigned ()) {
            (0u64, true) => { (val > i64::max || val < i64::min, BigInt::new (i64::max)) }
            (0u64, false) => { (val > u64::max || val < 0us, BigInt::new (u64::max)) }
            (8u64, true) => { (val > cast!isize (i8::max) || val < cast!isize (i8::min), BigInt::new (cast!usize (i8::max))) }
            (8u64, false) => { (val > cast!usize (u8::max) || val < 0us, BigInt::new (cast!usize (u8::max))) }
            (16u64, true) => { (val > cast!isize (i16::max) || val < cast!isize (i16::min), BigInt::new (cast!usize (i16::max))) }
            (16u64, false) => { (val > cast!usize (u16::max) || val < 0us, BigInt::new (cast!usize (u16::max))) }
            (32u64, true) => { (val > cast!isize (i32::max) || val < cast!isize (i32::min), BigInt::new (cast!usize (i32::max))) }
            (32u64, false) => { (val > cast!usize (u32::max) || val < 0us, BigInt::new (cast!usize (u32::max))) }
            (64u64, true) => { (val > cast!isize (i64::max) || val < cast!isize (i64::min), BigInt::new (cast!usize (i64::max))) }
            (64u64, false) => { (val > cast!usize (u64::max) || val < 0us, BigInt::new (cast!usize (u64::max))) }
            _ => __pragma!panic ();
        }

        if (over_) {
            throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::OVERFLOW_CAPACITY, type, val, max));
        }
    }
    
    
    /**
     * ================================================================================
     * ================================================================================
     * =========================            UNARY             =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Compute the value of a unary operation
     * @params: 
     *   - un: the value to compute
     * @returns: the result
     * @throws:
     *   - &ErrorMsg: if the value cannot be known at compile time
     */
    def computeUnary (self, un : &UnaryOperatorValue)-> &Value
        throws &ErrorMsg
    {
        match un {
            b : &UnaryBoolOperatorValue => self.computeUnaryBool (b);
            _ => {
                throw ErrorMsg::fatal (un.getLoc (), format (ValidateErrorMessage::UNKNOWN_AT_COMPILE_TIME, un.getType ()));
            }
        }
    }

    /**
     * Simplify an unary operator
     */
    def simplifyUnary (self, un : &UnaryOperatorValue)-> &Value
        throws &ErrorMsg
    {
        match un {
            b : &UnaryBoolOperatorValue => {
                self.simplifyUnaryBool (b)
            }  
            _ => {
                cast!{&Value} (un)
            }
        }        
    }
    
    /**
     * Compute the value of an unary operator on a bool value
     * @params: 
     *    - un: the unary operator to validate
     * @returns: the result value
     * @throws: 
     *    - &ErrorMsg: if the value cannot be known at compile time
     */
    def computeUnaryBool (self, un : &UnaryBoolOperatorValue)-> &Value
        throws &ErrorMsg
    {
        let content = self.compute (un.getInner ());
        match un.getOperator () {
            UnaryOperators::NOT => {
                match content {
                    v : &BoolValue => {
                        if (v.isTrue ()) {
                            return BoolValue::new (un.getLoc (), false);
                        } else {
                            return BoolValue::new (un.getLoc (), true);
                        }
                    }
                    _ => throw ErrorMsg::fatal (un.getLoc (), format (ValidateErrorMessage::UNKNOWN_AT_COMPILE_TIME, un.getType ()));
                }
            }
            _ => __pragma!panic ();
        }
    }

    /**
     * Compute an unary operator on a bool value
     */
    def simplifyUnaryBool (self, un : &UnaryBoolOperatorValue)-> &Value
        throws &ErrorMsg
    {
        let content = self.simplify (un.getInner ());
        match un.getOperator () {
            UnaryOperators::NOT => {
                match content {
                    v : &BoolValue => {
                        if (v.isTrue ()) {
                            return BoolValue::new (un.getLoc (), false);
                        } else {
                            return BoolValue::new (un.getLoc (), true);
                        }
                    }
                    _ => {
                        return UnaryBoolOperatorValue::new (un.getLoc (), un.getOperator (), content);
                    }
                }
            }
            _ => __pragma!panic ();
        }
    }

    
    /**
     * ================================================================================
     * ================================================================================
     * =========================         SLICE ACCESS         =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Compute a slice access value
     * @params: 
     *   - slc: the value to compute
     * @returns: the result
     * @throws:
     *    - &ErrorMsg: if the value cannot be known at compile time
     */
    def computeSliceAccess (self, slc : &SliceAccessValue)-> &Value
        throws &ErrorMsg
    {
        let array = self.compute (slc.getSlice ());
        let index = self.compute (slc.getIndex ());
        let u_index = match index {
            i : &IntValue => {
                {
                    i.getValue ().to!usize ()
                } catch {
                    _ => throw ErrorMsg::fatal (i.getLoc (), format (ValidateErrorMessage::OVERFLOW_CAPACITY, IntType::new (i.getLoc (), size-> 0u16, signed-> false), i.getValue (), 12));                    
                }
            }
            _ => {
                throw ErrorMsg::fatal (index.getLoc (), format (ValidateErrorMessage::UNKNOWN_AT_COMPILE_TIME, index.getType ()));
            }
        };

        let res : &Value = match array {
            a : &ArrayValue => {
                if (a.getInners ().len <= u_index) {
                    throw ErrorMsg::fatal (a.getLoc (), format (ValidateErrorMessage::ARRAY_OVERFLOW, a.getInners ().len, u_index));
                }
                
                a.getInners ()[u_index]
            }
            str : &StringValue => {
                if (str.getLen () <= u_index) {
                    throw ErrorMsg::fatal (str.getLoc (), format (ValidateErrorMessage::ARRAY_OVERFLOW, str.getLen (), u_index));
                }

                let chType = str.getType ().asOf!{&SliceType} ().getInners ()[0];
                let size = chType.asOf!{&CharType} ().getSize ();
                if (size == 8u16) {
                    cast!{&Value} (CharValue::new (slc.getLoc (), chType, c8Val-> str.getUtf8 ()[u_index]))
                } else {
                    cast!{&Value} (CharValue::new (slc.getLoc (), chType, c32Val-> str.getUtf32 ()[u_index]))
                }
            }
            _ => {
                throw ErrorMsg::fatal (array.getLoc (), format (ValidateErrorMessage::UNKNOWN_AT_COMPILE_TIME, array.getType ()));
            }
        };

        res
    }

    /**
     * Simplify a slice access
     */
    def simplifySliceAccess (self, slc : &SliceAccessValue)-> &Value
        throws &ErrorMsg
    {
        let array = self.simplify (slc.getSlice ());
        let index = self.simplify (slc.getIndex ());
        let u_index = match index {
            i : &IntValue => {
                {
                    i.getValue ().to!usize ()
                } catch {
                    _ => throw ErrorMsg::fatal (i.getLoc (), format (ValidateErrorMessage::OVERFLOW_CAPACITY, IntType::new (i.getLoc (), size-> 0u16, signed-> false), i.getValue (), 12));                    
                }
            }
            _ => {
                return SliceAccessValue::new (slc.getLoc (), slc.getType (), array, index);
            }
        };

        let res : &Value = match array {
            a : &ArrayValue => {
                if (a.getInners ().len <= u_index) {
                    throw ErrorMsg::fatal (a.getLoc (), format (ValidateErrorMessage::ARRAY_OVERFLOW, a.getInners ().len, u_index));
                }
                
                a.getInners ()[u_index]
            }
            str : &StringValue => {
                if (str.getLen () <= u_index) {
                    throw ErrorMsg::fatal (str.getLoc (), format (ValidateErrorMessage::ARRAY_OVERFLOW, str.getLen (), u_index));
                }

                let chType = str.getType ().asOf!{&SliceType} ().getInners ()[0];
                let size = chType.asOf!{&CharType} ().getSize ();
                if (size == 8u16) {
                    cast!{&Value} (CharValue::new (slc.getLoc (), chType, c8Val-> str.getUtf8 ()[u_index]))
                } else {
                    cast!{&Value} (CharValue::new (slc.getLoc (), chType, c32Val-> str.getUtf32 ()[u_index]))
                }
            }
            _ => {
                cast!{&Value} (SliceAccessValue::new (slc.getLoc (), slc.getType (), array, index))
            }
        };

        res
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================         FIELD ACCESS         =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Compute the value of a struct field access
     * @params:
     *    - acc: the value to compute
     */
    def computeFieldAccess (self, acc : &StructFieldAccessValue)-> &Value
        throws &ErrorMsg
    {
        let inner = self.compute (acc.getStruct ());
        match inner {
            rng : &RangeValue => {
                self.computeFieldAccessRange (rng, acc.getFieldName ())
            }
            _ => {
                throw ErrorMsg::fatal (inner.getLoc (), format (ValidateErrorMessage::UNKNOWN_AT_COMPILE_TIME, inner.getType ()));   
            }
        }
    }

    /**
     * Simplify a struct field access
     */
    def simplifyFieldAccess (self, acc : &StructFieldAccessValue)-> &Value
        throws &ErrorMsg
    {
        let inner = self.simplify (acc.getStruct ());
        match inner {
            rng : &RangeValue => {
                self.computeFieldAccessRange (rng, acc.getFieldName ())
            }
            _ => {
                cast!{&Value} (StructFieldAccessValue::new (acc.getLoc (), acc.getType (), inner, acc.getFieldName ()))
            }
        }        
    }
    
    /**
     * Compute the value of a struct field access on a range value
     * @params:
     *    - rng: the range value that is accessed
     *    - field: the name of the field being accessed
     */
    def computeFieldAccessRange (self, rng : &RangeValue, field : [c8])-> &Value {
        match field {
            RangeKeys::STEP => {
                rng.getStep ()
            }
            RangeKeys::CONTAIN => {
                rng.getIsFull ()
            }
            RangeKeys::SCD => {
                rng.getRight ()
            }
            RangeKeys::FST => {
                rng.getLeft ()
            }
            _ => {
                __pragma!panic ();
            }            
        }
    }    
    
    /**
     * ================================================================================
     * ================================================================================
     * =========================      CONDITION / LOOPS       =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Compute a conditional value
     * @params:
     *   - cd: the value to compute
     * @returns: the result
     * @throws:
     *    - &ErrorMsg: if the value cannot be known at compile time
     */
    def computeConditional (self, cd : &ConditionalValue)-> &Value
        throws &ErrorMsg
    {
        let test = self.compute (cd.getTest ());
        let isTrue = match test {
            b : &BoolValue => {
                b.isTrue ()
            }
            _ => {
                throw ErrorMsg::fatal (test.getLoc (), format (ValidateErrorMessage::UNKNOWN_AT_COMPILE_TIME, test.getType ()));
            }
        };

        if (isTrue) {
            self.compute (cd.getContent ())
        } else match cd.getElse () {
            NoneValue () => {
                throw ErrorMsg::fatal (cd.getLoc (), format (ValidateErrorMessage::UNKNOWN_AT_COMPILE_TIME, cd.getType ()));
            }
            e : _ => {
                self.compute (e)
            }
        }     
    }

    /**
     * Simplify a conditional value
     */
    def simplifyConditional (self, cd : &ConditionalValue)-> &Value
        throws &ErrorMsg
    {
        let test = self.simplify (cd.getTest ());
        match test {
            b : &BoolValue => {
                if (b.isTrue ()) {
                    return self.simplify (cd.getContent ());
                } else {
                    return self.simplify (cd.getElse ());
                }
            }
        }

        let content = self.simplify (cd.getContent ());
        let else_ = self.simplify (cd.getElse ());
        ConditionalValue::new (cd.getLoc (), cd.getType (), test, content, else_, isComplete-> cd.isComplete ())
    }

    
    /**
     * Compute a block value
     * @params:
     *   - bl: the block value to compute
     * @returns: the result
     * @throws:
     *    - &ErrorMsg: if the value cannot be known at compile time
     */
    def computeBlock (self, block : &BlockValue)-> &Value 
        throws &ErrorMsg
    {
        if (block.getValues ().len > 1us) {
            throw ErrorMsg::warn (block.getLoc (), format (ValidateErrorMessage::CTE_IGNORED, block.getValues ().len - 1us));
        }

        if (block.getValues ().len == 0us) {
            throw ErrorMsg::fatal (block.getLoc (), format (ValidateErrorMessage::UNKNOWN_AT_COMPILE_TIME, block.getType ()));
        }

        self.compute (block.getValues ()[$ - 1us])
    }

    /**
     * Simplify a block 
     */
    def simplifyBlock (self, block : &BlockValue)-> &Value
        throws &ErrorMsg
    {
        if (block.getValues ().len == 1us) {
            self.simplify (block.getValues ()[0us])
        } else {
            let dmut v = Vec!{&Value}::new ();
            v:.reserve (block.getValues ().len);
            
            for i in 0us .. block.getValues ().len {
                v:.push (self.simplify (block.getValues ()[i]));
            }

            cast!{&Value} (BlockValue::new (block.getLoc (), block.getType (), v[], breakLoc-> block.getBreakerLoc (), returnLoc-> block.getReturnerLoc (), isSet-> block.isSet ()))
        }
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================             VARS             =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Compute a var ref value
     * @params:
     *   - bl: the value to compute
     * @returns: the result
     * @throws:
     *    - &ErrorMsg: if the value cannot be known at compile time
     */
    def computeVarRef (self, vref : &VarRefValue)-> &Value 
        throws &ErrorMsg
    {
        match vref.getValue () {
            NoneValue () => {
                throw ErrorMsg::fatal (vref.getLoc (), format (ValidateErrorMessage::UNKNOWN_AT_COMPILE_TIME, vref.getType ()));
            }
            c : _ => { self.compute (c) }
        }
    }

    /**
     * Simplify the value of a var ref
     */
    def simplifyVarRef (self, vref : &VarRefValue)-> &Value
        throws &ErrorMsg
    {
        match vref.getValue () {
            NoneValue () => {
                cast!{&Value} (vref)
            }
            c : _ => {
                self.simplify (c)
            }
        }
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================         MISC VALUES          =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Simplify a uniq value
     */
    def simplifyUniq (self, un : &UniqValue)-> &Value
        throws &ErrorMsg
    {
        let inner = self.compute (un.getValue ())?;
        match inner {
            Ok (x : _) => { x }
            _ => {
                cast!{&Value} (UniqValue::new (un.getLoc (), self.simplify (un.getValue ())))
            }
        }          
    }

    /**
     * Compute an address operator value
     * @params:
     *   - addr: the value to compute
     * @returns: the result
     * @throws:
     *    - &ErrorMsg: if the value cannot be known at compile time
     */
    def computeAddress (self, addr : &AddressValue)-> &Value
        throws &ErrorMsg
    {
        match (addr.getType (), addr.getInner ()) {
            (FuncPtrType (), PrototypeValue ()) => { // Ok if this is an address to a function 
                addr
            }
            _ => {
                throw ErrorMsg::fatal (addr.getLoc (), format (ValidateErrorMessage::UNKNOWN_AT_COMPILE_TIME, addr.getType ()));
            }
        }
    }
    
}
