in interpret;

use ymirc::semantic::generator::_;
use ymirc::semantic::symbol::function;
use ymirc::semantic::validator::utf;
use ymirc::errors::message;
use ymirc::utils::{bigint, bigfloat, format};

use ymirc::global::{core_, state};

use ymirc::lexing::word;
use ymirc::syntax::keys;
use ymirc::semantic::validator::errors;

use ymirc::semantic::generator::type::{_,
                                       custom::_,
                                       native::{_, scalar::_, compound::_},
                                       temporary::_};

use ymirc::semantic::generator::value::{_,
                                        construct::{_, delegate::_},
                                        literal::_,
                                        memory::_,
                                        operator::{_,
                                                   binary::{_, bool_::_, char_::_, int_::_, float_::_, pointer_::_},
                                                   call::_, fields::_, map::_, slice::_, unary::_},
                                        operator::map::iteration::_,
                                        prototypes::_,
                                        scope::_,
                                        syntax::_,
                                        template::_};


/**
 * The compile time interpreter, is the class that can compute the values at compilation time
 * It is used to compute some stuff, that must be known at compilation time, or for optimization purpose
 */
pub class CompileTimeInterpreter {

    let _isForRef : bool;
    let mut _reduced : [usize => mut &Value] = [];

    /**
     * Create an empty interpreter
     */
    pub self (forRef : bool = false, mut reduced : [usize => mut &Value])
        with _isForRef = forRef
        , _reduced = alias reduced
    {}

    /**
     * @returns: the list of values already reduce by the interpret
     * */
    pub fn getReduced (mut self)-> mut [usize => mut &Value] {
        alias self._reduced
    }

    /**
     * Optimize a value by reducing its content into its most simple version
     * @params:
     *     - context: the context of the validation
     *     - value: the value to reduce
     * @returns: the reduced value
     * @throws:
     *     - &ErrorMsg: if there was an error during the reduction (ex: overflow)
     * */
    pub fn reduce (mut self, value : &Value)-> &Value
        throws ErrorMsg
    {
        // If the value is already reduce no need to retry reducing it
        // It will only be a lose of time and allocation space
        if (value.isReduced ()) return value;
        if let Ok (v) = self._reduced [value.getUniqId ()]? {
            return v;
        }

        let rdc = match value {
            l : &LiteralValue           => { self:.reduceLiteral (l) }
            a : &AliaserValue           => { self:.reduceAliaser (a) }
            a : &ArrayAllocValue        => { self:.reduceArrayAlloc (a) }
            rng : &RangeValue           => { self:.reduceRange (rng) }
            o : &OptionValue            => { self:.reduceOption (o) }
            o : &ErrOptionValue         => { self:.reduceErrOption (o) }
            slc : &SliceConcatValue     => { self:.reduceSliceConcat (slc) }
            slc : &SliceCompareValue    => { self:.reduceSliceCompare (slc) }
            slc : &SliceAccessValue     => { self:.reduceSliceAccess (slc) }
            bin : &BinaryOperatorValue  => { self:.reduceBinary (bin) }
            un : &UnaryOperatorValue    => { self:.reduceUnary (un) }
            cd : &ConditionalValue      => { self:.reduceConditional (cd) }
            bl : &BlockValue            => { self:.reduceBlock (bl) }
            l : &ListComprValue         => { self:.reduceListCompr (l) }
            m : &MapValue               => { self:.reduceMap (m) }
            m : &MapAccessValue         => { self:.reduceMapAccess (m) }
            m : &MapInsertValue         => { self:.reduceMapInsert (m) }
            addr : &AddressValue        => { self:.reduceAddress (addr) }
            s : &StructFieldAccessValue => { self:.reduceFieldAccess (s, inOperator-> false) }
            s : &OptionFieldAccessValue => { self:.reduceFieldAccessOption (s, inOperator-> false) }
            t : &TupleFieldAccessValue  => { self:.reduceFieldAccessTuple (t, inOperator-> false) }
            c : &CallValue              => { self:.reduceCallValue (c) }
            c : &CastValue              => { self:.reduceCastValue (c) }
            a : &ArrayAccessValue       => { self:.reduceArrayAccessValue (a) }
            _ => {
                value
            }
        };

        self._reduced [value.getUniqId ()] = rdc;
        rdc
    }

    /**
     * @warning: assume the value is reduced
     * @params:
     *    - value: the value to check
     * @returns: true if the value is cte known
     * */
    pub fn isCte (self, value : &Value)-> bool {
        match value {
            r : &RangeValue => {
                if (!self.isCte (r.getLeft ())) return false;
                if (!self.isCte (r.getRight ())) return false;
                if (!self.isCte (r.getStep ())) return false;
                if (!self.isCte (r.getIsFull ())) return false;

                true
            }
            a : &ArrayValue => {
                for it in a.getValues () {
                    if (!self.isCte (it)) return false;
                }

                true
            }
            t : &TupleValue => {
                for it in t.getValues () {
                    if (!self.isCte (it)) return false;
                }

                true
            }
            o : &OptionValue => { // cte iif inner is cte
                if (!self.isCte (o.getValue ())) return false;

                true
            }
            e : &ErrOptionValue => { // cte iif none
                if (e.getValue () of NullValue) return true;

                false
            }
            MapValue () => { false }
            ProtoFuncPtrValue () => { true }
            lm : &LambdaValue => { !lm.isClosure () }
            LiteralValue () => { true }
            n : &NamedValue => { self.isCte (n.getValue ()) }
            a : &AliaserValue => { self.isCte (a.getValue ()) }
            c : &NameDelegateValue => {
                c.getClosure () of NullValue
            }
            e : &EnumFieldAccessValue => {
                self.isCte (e.getContent ())
            }
            _ => { false }
        }
    }

    /**
     * Reduce a value involved in a binary/unary operator
     * */
    fn reduceInOperator (mut self, value : &Value, checkCte : bool)-> &Value
        throws ErrorMsg
    {
        let res = match value {
            v : &VarRefValue => { self:.reduceVarRefInOperator (v) }
            b : &BlockValue => { self:.reduceBlock (b, inOperator-> true) }
            l : &LiteralValue => { self:.reduceLiteral (l, inOperator-> true) }
            s : &StructFieldAccessValue => { self:.reduceFieldAccess (s, inOperator-> true) }
            s : &OptionFieldAccessValue => { self:.reduceFieldAccessOption (s, inOperator-> true) }
            t : &TupleFieldAccessValue  => { self:.reduceFieldAccessTuple (t, inOperator-> true) }
            e : &EnumFieldAccessValue   => { self:.reduce (e.getContent ()) }
            _ => return self:.reduce (value);
        };

        if (checkCte && !self.isCte (res)) return self:.reduce (value);
        return res;
    }

    /**
     * Reduce a value involved in a field access operator
     * @warning: does not return the field, but the whole reduced value assuming only the field will be used
     * */
    fn reduceInStructAccess (mut self, value : &Value)-> &Value
        throws ErrorMsg
    {
        let res = match value {
            v : &VarRefValue => { self:.reduceVarRefInStructAccess (v) }
            b : &BlockValue => { self:.reduceBlock (b, inStruct-> true) }
            l : &LiteralValue => { self:.reduceLiteral (l, inOperator-> true) }
            r : &RangeValue => { self:.reduceRange (r, inOperator-> true) }
            o : &OptionValue => { self:.reduceOption (o, inOperator-> true) }
            r : &ErrOptionValue => { self:.reduceErrOption (r, inOperator-> true) }
            e : &EnumFieldAccessValue   => { self:.reduce (e.getContent ()) }
            _ => { self:.reduce (value) }
        }

        res
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =======================            COMPUTE LITERAL           ===================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Reduce a literal value
     * */
    fn reduceLiteral (mut self, lit : &LiteralValue, inOperator : bool = false)-> &Value
        throws ErrorMsg
    {
        match lit {
            a : &ArrayValue => { return self:.reduceArray (a, inOperator-> inOperator); }
            t : &TupleValue => { return self:.reduceTuple (t, inOperator-> inOperator); }


            _ => {
                return lit;
            }
        }
    }

    /**
     * Compute array value
     * */
    fn reduceArray (mut self, arr : &ArrayValue, inOperator : bool = false)-> &Value
        throws ErrorMsg
    {
        let inners = if (inOperator) {
            copy [self:.reduceInOperator (i, checkCte-> false) for i in arr.getValues ()]
        } else {
            copy [self:.reduce (i) for i in arr.getValues ()]
        };

        if let t : &ArrayType = arr.getType () {
            copy ArrayValue (arr.getLoc (),
                             t,
                             inners, isReduced-> true)
        } else panic;
    }

    /**
     * Compute a tuple value
     * */
    fn reduceTuple (mut self, t : &TupleValue, inOperator : bool = false)-> &Value
        throws ErrorMsg
    {
        let inners = if (inOperator) {
            copy [self:.reduceInOperator (i, checkCte-> false) for i in t.getValues ()]
        } else {
            copy [self:.reduce (i) for i in t.getValues ()]
        };

        if let ty : &TupleType = t.getType () {
            copy TupleValue (t.getLoc (),
                             ty,
                             inners,
                             isReduced-> true)
        } else panic;
    }

    /**
     * Reduce an array allocation literal
     * */
    fn reduceArrayAlloc (mut self, a : &ArrayAllocValue)-> &Value
        throws ErrorMsg
    {
        let inner = self:.reduce (a.getValue ());
        let len   = self:.reduce (a.getLen ());

        if let t : &SliceType = a.getType () && a.isDynamic () {
            copy ArrayAllocValue::dyn (a.getLoc (),
                                       t,
                                       inner,
                                       len,
                                       isReduced-> true)
        } else if let t : &ArrayType = a.getType () && !a.isDynamic () {
            copy ArrayAllocValue::stat (a.getLoc (),
                                        t,
                                        inner,
                                        len,
                                        isReduced-> true)
        } else panic;
    }

    /**
     * Reduce a map literal value
     * */
    fn reduceMap (mut self, m : &MapValue)-> &Value
        throws ErrorMsg
    {
        let keys   = copy [self:.reduce (i) for i in m.getKeys ()];
        let values = copy [self:.reduce (i) for i in m.getValues ()];

        if let t : &MapType = m.getType () {
            copy MapValue (m.getLoc (),
                           t,
                           keys,
                           values,
                           isReduced-> true)
        } else panic;
    }

    /*!
     * ================================================================================
     * ================================================================================
     * ====================            COMPUTE AND TRANSFORM           ================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Compute the value of "value" and try transforming it into a string literal directly usable
     * @params:
     *    - value: the value to compute and transform
     * @returns:
     *    - .0: the size of encoding (8, 16, 32)
     *    - .1: the content of the string (encoded)
     * @throws:
     *    - &ErrorMsg: if the value cannot be retreived at compilation time, or does not contain a string literal
     */
    pub fn computeString (mut self, value : &Value)-> (u16, StringValueContent)
        throws ErrorMsg
    {
        let inner = self:.reduceInOperator (value, checkCte-> false);
        match inner {
            s : &StringValue => {
                return (s.getEncodingSize (), s.getValue ());
            }
            _ => {
                if (self.isCte (inner)) {
                    let ch      = copy CharType (value.getLoc (), size-> 8u16);
                    let slcType = copy SliceType (value.getLoc (), ch);
                    throw copy ErrorMsg::fatal (inner.getLoc (),
                                                format (ValidateErrorMessage::INCOMPATIBLE_TYPE, inner.getType (), slcType));
                } else {
                    throw copy ErrorMsg::fatal (value.getLoc (), format (ValidateErrorMessage::UNKNOWN_AT_COMPILE_TIME, value.getType ()));
                }
            }
        };
    }

    /**
     * Compute the value of "value" and try transforming it into a decoded string value in utf8 directly usable
     * @params:
     *    - value: the value to compute and transform
     * @returns: the utf8 decoded string
     * @throws:
     *    - &ErrorMsg: if the value cannot be retreived at compilation time, or does not contain a string literal
     */
    pub fn decodeString (mut self, value : &Value)-> [c8]
        throws ErrorMsg
    {
        match self:.computeString (value) {
            (8u16, val : _) => {
                utf::instance ().decode (val.utf8)
            }
            (16u16, val : _) => {
                utf::instance ().decode (val.utf16)
            }
            (_, val : _) => {
                utf::instance ().decode (val.utf32)
            }
        }
    }

    /**
     * Compute the value of 'value' and try transforming it into a bool literal
     * @throws:
     *    - &ErrorMsg: if the value cannot be retreived at compilation time, or does not contain a bool literal
     */
    pub fn computeBool (mut self, value : &Value)-> bool
        throws ErrorMsg
    {
        let inner = self:.reduceInOperator (value, checkCte-> false);
        match inner {
            b : &BoolValue => {
                b.isTrue ()
            }
            _ => {
                if (self.isCte (inner)) {
                    let bType = copy BoolType (value.getLoc ());
                    throw copy ErrorMsg::fatal (inner.getLoc (),
                                                format (ValidateErrorMessage::INCOMPATIBLE_TYPE, inner.getType (), bType));
                } else {
                    throw copy ErrorMsg::fatal (value.getLoc (), format (ValidateErrorMessage::UNKNOWN_AT_COMPILE_TIME, value.getType ()));
                }
            }
        }
    }

    /**
     * Compute the value of 'value' and try transforming it into a int literal
     * @params:
     *     - size: the size of the int type (for error throwing only, does not check that on the literal value)
     *     - signed: true if the int type is signed (for error throwing only, does not check that on the literal value)
     * @throws:
     *    - &ErrorMsg: if the value cannot be retreived at compilation time, or does not contain a int literal
     */
    pub fn computeInt (mut self, value : &Value, size : u16 = 0u16, signed : bool = true)-> &BigInt
        throws ErrorMsg
    {
        let inner = self:.reduceInOperator (value, checkCte-> false);
        match inner {
            i : &IntValue => {
                i.getValue ()
            }
            _ => {
                if (self.isCte (inner)) {
                    let iType = copy IntType (value.getLoc (), size-> size, signed-> signed);
                    throw copy ErrorMsg::fatal (inner.getLoc (),
                                                format (ValidateErrorMessage::INCOMPATIBLE_TYPE, inner.getType (), iType));
                } else {
                    throw copy ErrorMsg::fatal (value.getLoc (), format (ValidateErrorMessage::UNKNOWN_AT_COMPILE_TIME, value.getType ()));
                }
            }
        }
    }

    /**
     * Compute the value of "value" and try to transform it into a float literal
     * @params:
     *     - size: the size of the int type (for error throwing only, does not check that on the literal value)
     * @throws:
     *    - &ErrorMsg: if the value cannot be retreived at compilation time, or does not contain a float literal
     * */
    pub fn computeFloat (mut self, value : &Value, size : u16 = 0u16)-> &BigFloat
        throws ErrorMsg
    {
        let inner = self:.reduceInOperator (value, checkCte-> false);
        match inner {
            f : &FloatValue => {
                f.getValue ()
            }
            _ => {
                if (self.isCte (inner)) {
                    let fType = copy FloatType (value.getLoc (), size-> size);
                    throw copy ErrorMsg::fatal (inner.getLoc (),
                                                format (ValidateErrorMessage::INCOMPATIBLE_TYPE, inner.getType (), fType));
                } else {
                    throw copy ErrorMsg::fatal (value.getLoc (), format (ValidateErrorMessage::UNKNOWN_AT_COMPILE_TIME, value.getType ()));
                }
            }
        }
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================            RANGE             =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Compute the content of a range value at compilation time
     * @params:
     *   - value: the range value to compute
     * @returns: a range value
     * @throws: &ErrorMsg if the value cannot be known at compilation time
     */
    fn reduceRange (mut self, value : &RangeValue, inOperator : bool = false)-> &Value
        throws ErrorMsg
    {
        if (inOperator) {
            let left  = self:.reduceInOperator (value.getLeft (),   checkCte-> false);
            let right = self:.reduceInOperator (value.getRight (),  checkCte-> false);
            let full  = self:.reduceInOperator (value.getIsFull (), checkCte-> false);
            let step  = self:.reduceInOperator (value.getStep (),   checkCte-> false);

            if let r : &RangeType = value.getType () {
                return copy RangeValue (value.getLoc (), r, left, right, full-> full, step-> step, isReduced-> true);
            }
        } else {
            let left  = self:.reduce (value.getLeft ());
            let right = self:.reduce (value.getRight ());
            let full  = self:.reduce (value.getIsFull ());
            let step  = self:.reduce (value.getStep ());

            if let r : &RangeType = value.getType () {
                return copy RangeValue (value.getLoc (), r, left, right, full-> full, step-> step, isReduced-> true);
            }
        }

        panic;
    }

    /*!
     * =================================================================================
     * =================================================================================
     * =========================            OPTION             =========================
     * =================================================================================
     * =================================================================================
     */

    /**
     * Reduce an option value
     * */
    fn reduceOption (mut self, value : &OptionValue, inOperator : bool = false)-> &Value
        throws ErrorMsg
    {
        let inner = if (inOperator) {
            self:.reduceInOperator (value.getValue (), checkCte-> false)
        } else {
            self:.reduce (value.getValue ())
        };

        if let o : &OptionType = value.getType () {
            copy OptionValue (value.getLoc (), o, inner, isReduced-> true)
        } else panic;
    }

    /**
     * Reduce an error option value
     * */
    fn reduceErrOption (mut self, value : &ErrOptionValue, inOperator : bool = false)-> &Value
        throws ErrorMsg
    {
        let inner = if (inOperator) {
            self:.reduceInOperator (value.getValue (), checkCte-> false)
        } else {
            self:.reduce (value.getValue ())
        };

        if let o : &OptionType = value.getType () {
            copy ErrOptionValue (value.getLoc (), type-> o, errValue-> inner, isReduced-> true)
        } else panic;
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================        CONCATENATION         =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Compute a slice concatenation operation
     * @params:
     *  - value: the value to compute
     * @returns: the value
     * @throws:
     *   - &ErrorMsg: if the value cannot be known at compilation time
     */
    fn reduceSliceConcat (mut self, value : &SliceConcatValue)-> &Value
        throws ErrorMsg
    {
        let left = self:.reduceInOperator (value.getLeft (), checkCte-> false);
        let right = self:.reduceInOperator  (value.getRight (), checkCte-> false);

        match (left, right) {
            (l : &StringValue, r : &StringValue) => {
                return self.concatStrings (value.getLoc (), value.getType (), l, r);
            }
        }

        return copy SliceConcatValue (value.getLoc (),
                                      value.getType (),
                                      self:.reduce (value.getLeft ()),
                                      self:.reduce (value.getRight ()),
                                      isReduced-> true);
    }

    /**
     * Concatenation of two string values
     * @params:
     *  - loc: the location of the operation
     *  - type: the type of the operation
     *  - left: the left operand of the concat
     *  - right: the right operand of the concat
     * @returns: a aliaservalue containing a new string value
     */
    fn concatStrings (self, loc : &Word, type : &Type, left : &StringValue, right : &StringValue)-> &Value {
        if (left.getEncodingSize () != right.getEncodingSize ()) { panic; }

        let res = match left.getEncodingSize () {
            8u16 => {
                StringValueContent (utf8-> left.getValue ().utf8 ~ right.getValue ().utf8)
            }
            16u16 => {
                StringValueContent (utf16-> left.getValue ().utf16 ~ right.getValue ().utf16)
            }
            _ => {
                StringValueContent (utf32-> left.getValue ().utf32 ~ right.getValue ().utf32)
            }
        };

        if let s : &SliceType = type {
            copy StringValue (loc, s, res)
        } else panic;
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================          COMPARISON          =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Compute the value of a slice comparison
     * @params:
     *   - value: the value to execute a cte
     * @returns: the result value
     * @throws:
     *  - &ErrorMsg: if the value cannot be known at compilation time
     */
    fn reduceSliceCompare (mut self, value : &SliceCompareValue)-> &Value
        throws ErrorMsg
    {
        let left = self:.reduceInOperator (value.getLeft (), checkCte-> false);
        let right = self:.reduceInOperator (value.getRight (), checkCte-> false);

        let res = match (left, right) {
            (l : &StringValue, r : &StringValue) => {
                copy BoolValue (value.getLoc (), (l == r))
            }
            (l : &ArrayValue, r : &ArrayValue) => {
                copy BoolValue (value.getLoc (), (l == r))
            }
            _ => {
                copy SliceCompareValue (value.getLoc (),
                                        value.getType (),
                                        self:.reduce (left),
                                        self:.reduce (right),
                                        isReduced-> true)
            }
        }

        res
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================            BINARY            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Compute the value of a binary operation
     * @params:
     *   - bin: the value to compute
     * @returns: the result
     * @throws:
     *   - &ErrorMsg: if the value cannot be known at compile time
     */
    fn reduceBinary (mut self, bin : &BinaryOperatorValue)-> &Value
        throws ErrorMsg
    {
        match bin {
            iBin : &BinaryMathIntOperatorValue => {
                return self:.reduceBinMathInt (iBin);
            }
            sBin : &SpecialMathIntOperatorValue => {
                return self:.reduceSpecialMathInt (sBin);
            }
            cmp : &CmpIntOperatorValue => {
                return self:.reduceCompareIntValue (cmp);
            }
            bBin : &LogicalBinBoolOperatorValue => {
                return self:.reduceLogicalBinBool (bBin);
            }
            bBin : &CmpBoolOperatorValue => {
                return self:.reduceCompareBoolValue (bBin);
            }
            fBin : &BinaryMathFloatOperatorValue => {
                return self:.reduceBinMathFloat (fBin);
            }
            sBin : &SpecialMathFloatOperatorValue => {
                return self:.reduceSpecialMathFloat (sBin);
            }
            fBin : &CmpFloatOperatorValue => {
                return self:.reduceCompareFloat (fBin);
            }
            cBin : &BinaryMathCharOperatorValue => {
                return self:.reduceBinMathChar (cBin);
            }
            cmp : &CmpCharOperatorValue => {
                return self:.reduceCompareChar (cmp);
            }
            rngContain : &RangeContainValue => {
                return self:.reduceRangeContain (rngContain);
            }
            a : &SpecialArrayOperatorValue => {
                return self:.reduceArraySpecialOp (a);
            }
            _ => {
                return bin;
            }
        }
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================       BINARY CMP INT        ==========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Compute the value of int binary comparison
     * @params:
     *     - bin: the operator to compute
     * @returns: the result
     * @throws:
     *    - &ErrorMsg: if the value cannot be knwon at compile time
     */
    fn reduceCompareIntValue (mut self, bin : &CmpIntOperatorValue)-> &Value
        throws ErrorMsg
    {
        let left = self:.reduceInOperator (bin.getLeft (), checkCte-> false);
        let right = self:.reduceInOperator (bin.getRight (), checkCte-> false);
        let ritype = if let ri : &IntType = right.getType () { ri } else { panic; };
        let litype = if let ri : &IntType = left.getType () { ri } else { panic; };

        match (left, right) {
            (l : &IntValue, r : &IntValue) => { // left and right are cte, easy
                match bin.getOperator () {
                    BinaryOperators::INF       => { return copy BoolValue (bin.getLoc (), l.getValue () < r.getValue ()); }
                    BinaryOperators::SUP       => { return copy BoolValue (bin.getLoc (), l.getValue () > r.getValue ()); }
                    BinaryOperators::INF_EQUAL => { return copy BoolValue (bin.getLoc (), l.getValue () <= r.getValue ()); }
                    BinaryOperators::SUP_EQUAL => { return copy BoolValue (bin.getLoc (), l.getValue () >= r.getValue ()); }
                    BinaryOperators::NOT_EQUAL => { return copy BoolValue (bin.getLoc (), l.getValue () != r.getValue ()); }
                    BinaryOperators::DEQUAL    => { return copy BoolValue (bin.getLoc (), l.getValue () == r.getValue ()); }
                }
            }
            (l : &IntValue, _) => { // only left is cte, but maybe there still s
                let min = self.createIntMinValue (litype);
                let max = self.createIntMaxValue (litype);
                let v = l.getValue ();
                match bin.getOperator () {
                    BinaryOperators::INF => {
                        if v == max { return copy BoolValue (bin.getLoc (), false); } // max < right (i.e. right > max => false)
                    }
                    BinaryOperators::INF_EQUAL => {
                        if v == min { return copy BoolValue (bin.getLoc (), true); } // min <= right (i.e. right >= min => true)
                    }
                    BinaryOperators::SUP => {
                        if v == min { return copy BoolValue (bin.getLoc (), false); }  // min > right (i.e. right < min => false)
                    }
                    BinaryOperators::SUP_EQUAL => {
                        if v == max { return copy BoolValue (bin.getLoc (), true); } // max >= right (i.e. right <= max => true)
                    }
                }
            }
            (_, r : &IntValue) => { // only right is cte, but maybe there still things we can know
                let min = self.createIntMinValue (ritype);
                let max = self.createIntMaxValue (ritype);
                let v = r.getValue ();
                match bin.getOperator () {
                    BinaryOperators::INF => {
                        if v == min { return copy BoolValue (bin.getLoc (), false); } // left < min => false
                    }
                    BinaryOperators::INF_EQUAL => {
                        if v == max { return copy BoolValue (bin.getLoc (), true); } // left <= max => true
                    }
                    BinaryOperators::SUP => {
                        if v == max { return copy BoolValue (bin.getLoc (), false); } // left > max => false
                    }
                    BinaryOperators::SUP_EQUAL => {
                        if v == min { return copy BoolValue (bin.getLoc (), true); }  // left >= min => true
                    }
                }
            }
        }

        let resLeft = self:.reduce (bin.getLeft ());
        let resRight = self:.reduce (bin.getRight ());
        if (resLeft is resRight) || (resRight.isFullLiteral () && resLeft.isFullLiteral () && resRight == resLeft) {
            match bin.getOperator () {
                BinaryOperators::DEQUAL    => { return copy BoolValue (bin.getLoc (), true); }
                BinaryOperators::NOT_EQUAL => { return copy BoolValue (bin.getLoc (), false); }
                BinaryOperators::SUP       => { return copy BoolValue (bin.getLoc (), false); }
                BinaryOperators::INF       => { return copy BoolValue (bin.getLoc (), false); }
                BinaryOperators::INF_EQUAL => { return copy BoolValue (bin.getLoc (), true); }
                BinaryOperators::SUP_EQUAL => { return copy BoolValue (bin.getLoc (), true); }
            }
        }

        copy CmpIntOperatorValue (bin.getLoc (), bin.getOperator (), resLeft, resRight, isReduced-> true)
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================       BINARY CMP BOOL        =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Compute the value of bool binary comparison
     * @params:
     *     - bin: the operator to compute
     * @returns: the result
     * @throws:
     *    - &ErrorMsg: if the value cannot be knwon at compile time
     */
    fn reduceCompareBoolValue (mut self, bin : &CmpBoolOperatorValue)-> &Value
        throws ErrorMsg
    {
        let left = self:.reduceInOperator (bin.getLeft (), checkCte-> false);
        let right = self:.reduceInOperator (bin.getRight (), checkCte-> false);
        match (left, right) {
            (l : &BoolValue, r : &BoolValue) => {
                match bin.getOperator () {
                    BinaryOperators::NOT_EQUAL => { return copy BoolValue (bin.getLoc (), l.isTrue () != r.isTrue ()); }
                    BinaryOperators::DEQUAL    => { return copy BoolValue (bin.getLoc (), l.isTrue () == r.isTrue ()); }
                    _ => panic;
                }
            }
        }

        let resLeft = self:.reduce (bin.getLeft ());
        let resRight = self:.reduce (bin.getRight ());
        if (resLeft is resRight) || (resLeft.isFullLiteral () && resRight.isFullLiteral () && resLeft == resRight) {
            match bin.getOperator () {
                BinaryOperators::NOT_EQUAL => { return copy BoolValue (bin.getLoc (), false); }
                BinaryOperators::DEQUAL    => { return copy BoolValue (bin.getLoc (), true); }
            }
        }

        copy CmpBoolOperatorValue (bin.getLoc (), bin.getOperator (),
                                   resLeft,
                                   resRight,
                                   isReduced-> true)
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================       BINARY LOGIC BOOL        =======================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Compute the value of a binary logical operation on bools
     * @params:
     *     - bin: the operator to compute
     * @throws:
     *    - &ErrorMsg: if the value cannot be knwon at compile time
     * */
    fn reduceLogicalBinBool (mut self, bin : &LogicalBinBoolOperatorValue)-> &Value
        throws ErrorMsg
    {
        let left  = self:.reduceInOperator (bin.getLeft (),  checkCte-> false);
        let right = self:.reduceInOperator (bin.getRight (), checkCte-> false);

        match (left, right) {
            (l : &BoolValue, r : &BoolValue) => {
                match bin.getOperator () {
                    BinaryOperators::DPIPE => { return copy BoolValue (bin.getLoc (), l.isTrue () || r.isTrue ()) }
                    BinaryOperators::DAND  => { return copy BoolValue (bin.getLoc (), l.isTrue () && r.isTrue ()) }
                    _ => panic;
                }
            }
            (l : &BoolValue, _) => { // only left is cte, but we can still say things without knowing right
                match bin.getOperator () {
                    BinaryOperators::DPIPE => {
                        if (l.isTrue ()) { // true || x => true
                            return copy BoolValue (bin.getLoc (), true);
                        } else { // false || x => x
                            return self:.reduce (bin.getRight ());
                        }
                    }
                    BinaryOperators::DAND => {
                        if (!l.isTrue ()) { // false && x => false
                            return copy BoolValue (bin.getLoc (), false);
                        } else { // true && x => x
                            return self:.reduce (bin.getRight ());
                        }
                    }
                }
            }
            (_, r : &BoolValue) => {
                match bin.getOperator () {
                    BinaryOperators::DPIPE => {
                        if (r.isTrue ()) { // x || true => true
                            return copy BoolValue (bin.getLoc (), true);
                        } else { // x || false => x
                            return self:.reduce (bin.getLeft ());
                        }
                    }
                    BinaryOperators::DAND => {
                        if (!r.isTrue ()) { // x && false => false
                            return copy BoolValue (bin.getLoc (), false);
                        } else { // x && true => x
                            return self:.reduce (bin.getLeft ());
                        }
                    }
                }
            }
        }

        let resLeft = self:.reduce (bin.getLeft ());
        let resRight = self:.reduce (bin.getRight ());
        if (resLeft is resRight) || (resLeft.isFullLiteral () && resRight.isFullLiteral () && resLeft == resRight) {
            return resLeft; // (a && a) == a and (a || a) == a
        }

        copy LogicalBinBoolOperatorValue (bin.getLoc (),
                                          bin.getOperator (),
                                          resLeft,
                                          resRight,
                                          isReduced-> true)
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================       BINARY MATH CHAR        ========================
     * ================================================================================
     * ================================================================================
     */


    /**
     * Compute the value of char binary comparison
     * @params:
     *     - bin: the operator to compute
     * @returns: the result
     * @throws:
     *    - &ErrorMsg: if the value cannot be knwon at compile time
     */
    fn reduceCompareChar (mut self, bin : &CmpCharOperatorValue)-> &Value
        throws ErrorMsg
    {
        let left = self:.reduceInOperator (bin.getLeft (), checkCte-> false);
        let right = self:.reduceInOperator (bin.getRight (), checkCte-> false);
        let litype = left.getType ().asOf!{&CharType} ();
        let ritype = right.getType ().asOf!{&CharType} ();

        match (left, right) {
            (l : &CharValue, r : &CharValue) => {
                let lV = l.getValueAsInt ();
                let rV = r.getValueAsInt ();
                match bin.getOperator () {
                    BinaryOperators::INF       => { return copy BoolValue (bin.getLoc (), rV > lV); }
                    BinaryOperators::SUP       => { return copy BoolValue (bin.getLoc (), lV > rV); }
                    BinaryOperators::INF_EQUAL => { return copy BoolValue (bin.getLoc (), rV >= lV); }
                    BinaryOperators::SUP_EQUAL => { return copy BoolValue (bin.getLoc (), lV >= rV); }
                    BinaryOperators::DEQUAL    => { return copy BoolValue (bin.getLoc (), lV == rV); }
                    BinaryOperators::NOT_EQUAL => { return copy BoolValue (bin.getLoc (), lV != rV); }
                }
            }
            (l : &CharValue, _) => {
                let min = self.createIntMinValue (litype.getSize (), false);
                let max = self.createIntMaxValue (litype.getSize (), false);
                let v = l.getValueAsInt ();
                match bin.getOperator () {
                    BinaryOperators::INF => {
                        if v == max { return copy BoolValue (bin.getLoc (), false); } // max < right (i.e. right > max => false)
                    }
                    BinaryOperators::INF_EQUAL => {
                        if v == min { return copy BoolValue (bin.getLoc (), true); } // min <= right (i.e. right >= min => true)
                    }
                    BinaryOperators::SUP => {
                        if v == min { return copy BoolValue (bin.getLoc (), false); }  // min > right (i.e. right < min => false)
                    }
                    BinaryOperators::SUP_EQUAL => {
                        if v == max { return copy BoolValue (bin.getLoc (), true); } // max >= right (i.e. right <= max => true)
                    }
                }
            }
            (_, r : &CharValue) => {
                let min = self.createIntMinValue (ritype.getSize (), false);
                let max = self.createIntMaxValue (ritype.getSize (), false);
                let v = r.getValueAsInt ();
                match bin.getOperator () {
                    BinaryOperators::INF => {
                        if v == min { return copy BoolValue (bin.getLoc (), false); } // left < min => false
                    }
                    BinaryOperators::INF_EQUAL => {
                        if v == max { return copy BoolValue (bin.getLoc (), true); } // left <= max => true
                    }
                    BinaryOperators::SUP => {
                        if v == max { return copy BoolValue (bin.getLoc (), false); } // left > max => false
                    }
                    BinaryOperators::SUP_EQUAL => {
                        if v == min { return copy BoolValue (bin.getLoc (), true); }  // left >= min => true
                    }
                }
            }
        }

        let resLeft = self:.reduce (bin.getLeft ());
        let resRight = self:.reduce (bin.getRight ());
        if (resLeft is resRight) || (resLeft.isFullLiteral () && resRight.isFullLiteral () && resLeft == resRight) {
            match bin.getOperator () {
                BinaryOperators::DEQUAL    => { return copy BoolValue (bin.getLoc (), true); }
                BinaryOperators::NOT_EQUAL => { return copy BoolValue (bin.getLoc (), false); }
                BinaryOperators::SUP       => { return copy BoolValue (bin.getLoc (), false); }
                BinaryOperators::INF       => { return copy BoolValue (bin.getLoc (), false); }
                BinaryOperators::INF_EQUAL => { return copy BoolValue (bin.getLoc (), true); }
                BinaryOperators::SUP_EQUAL => { return copy BoolValue (bin.getLoc (), true); }
            }
        }

        copy CmpCharOperatorValue (bin.getLoc (), bin.getOperator (),
                                   resLeft,
                                   resRight,
                                   isReduced-> true)
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================       BINARY MATH CHAR        ========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Compute a binary math operator on two char values
     * */
    fn reduceBinMathChar (mut self, bin : &BinaryMathCharOperatorValue)-> &Value
        throws ErrorMsg
    {
        let left = self:.reduceInOperator (bin.getLeft (), checkCte-> false);
        let right = self:.reduceInOperator (bin.getRight (), checkCte-> false);
        let t = if let t : &CharType = bin.getType () { t } else { panic; };

        match (left, right) {
            (l : &CharValue, r : &CharValue) => {
                match bin.getOperator () {
                    BinaryOperators::PLUS => {
                        let val = l.getValueAsInt () + r.getValueAsInt ();
                        self.verifyOverFlowChar (bin.getLoc (), t, val);

                        return copy CharValue (bin.getLoc (), t, val);
                    }
                    BinaryOperators::MINUS => {
                        let val = l.getValueAsInt () - r.getValueAsInt ();
                        self.verifyOverFlowChar (bin.getLoc (), t, val);

                        return copy CharValue (bin.getLoc (), t, val);
                    }
                }
            }
        }

        copy BinaryMathCharOperatorValue (bin.getLoc (),
                                          bin.getType (),
                                          bin.getOperator (),
                                          self:.reduce (bin.getLeft ()),
                                          self:.reduce (bin.getRight ()),
                                          isReduced-> true)
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================       BINARY MATH INT        =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Compute the value of a int binary math operator
     * @params:
     *    - bin: the operator to compute
     * @returns: the result
     * @throws:
     *    - &ErrorMsg: if the value cannot be known at compile time
     */
    fn reduceBinMathInt (mut self, bin : &BinaryMathIntOperatorValue)-> &Value
        throws ErrorMsg
    {
        let left = self:.reduceInOperator (bin.getLeft (), checkCte-> false);
        let right = self:.reduceInOperator (bin.getRight (), checkCte-> false);
        let type = if let t : &IntType = bin.getType () { t } else { panic; };

        match (left, right) {
            (l : &IntValue, r : &IntValue) => {
                let v = match bin.getOperator () {
                    BinaryOperators::PLUS  => { l.getValue () + r.getValue () }
                    BinaryOperators::MINUS => { l.getValue () - r.getValue () }
                    BinaryOperators::STAR  => { l.getValue () * r.getValue () }
                    BinaryOperators::PERCENT => {
                        if (r.getValue () == 0) {
                            throw copy ErrorMsg::fatal (bin.getLoc (), ValidateErrorMessage::DIVISION_BY_ZERO);
                        }

                        {
                            l.getValue () % r.getValue ()
                        } catch { _ => panic; }
                    }
                    BinaryOperators::DIV => {
                        if (r.getValue () == 0) {
                            throw copy ErrorMsg::fatal (bin.getLoc (), ValidateErrorMessage::DIVISION_BY_ZERO);
                        }

                        {
                            l.getValue () / r.getValue ()
                        } catch { _ => panic; }
                    }
                    _ => { // unknown operator ?
                        return copy BinaryMathIntOperatorValue (bin.getLoc (),
                                                                bin.getType (),
                                                                bin.getOperator (),
                                                                self:.reduce (bin.getLeft ()),
                                                                self:.reduce (bin.getRight ()),
                                                                isReduced-> true);
                    }
                };

                self.verifyOverFlowInt (bin.getLoc (), type, v);
                return copy IntValue (bin.getLoc (), type, v);
            }
            (_, r : &IntValue) => {
                if (bin.getOperator () == BinaryOperators::PERCENT || bin.getOperator () == BinaryOperators::DIV) {
                    if (r.getValue () == 0) {
                        throw copy ErrorMsg::fatal (bin.getLoc (), ValidateErrorMessage::DIVISION_BY_ZERO);
                    }
                }
                if (bin.getOperator () == BinaryOperators::STAR && r.getValue () == 1) {
                    return self:.reduce (bin.getLeft ());
                }
                if (bin.getOperator () == BinaryOperators::STAR && r.getValue () == 0) {
                    return r;
                }
                if (bin.getOperator () == BinaryOperators::PLUS && r.getValue () == 0) {
                    return self:.reduce (bin.getLeft ());
                }
                if (bin.getOperator () == BinaryOperators::MINUS && r.getValue () == 0) {
                    return self:.reduce (bin.getLeft ());
                }
                if (bin.getOperator () == BinaryOperators::DIV && r.getValue () == 1) {
                    return self:.reduce (bin.getLeft ());
                }
            }
            (l : &IntValue, _) => {
                if (bin.getOperator () == BinaryOperators::STAR && l.getValue () == 1) {
                    return self:.reduce (bin.getRight ());
                }
                if (bin.getOperator () == BinaryOperators::STAR && l.getValue () == 0) {
                    return l;
                }
                if (bin.getOperator () == BinaryOperators::PLUS && l.getValue () == 0) {
                    return self:.reduce (bin.getRight ());
                }
                if (bin.getOperator () == BinaryOperators::MINUS && l.getValue () == 0) {
                    return copy UnaryIntOperatorValue (bin.getLoc (), right.getType (), UnaryOperators::MINUS, self:.reduce (bin.getRight ()));
                }
            }
        }

        copy BinaryMathIntOperatorValue (bin.getLoc (),
                                         bin.getType (),
                                         bin.getOperator (),
                                         self:.reduce (bin.getLeft ()),
                                         self:.reduce (bin.getRight ()),
                                         isReduced-> true)
    }

    /**
     * Compute the value of a special int binary math operator
     * @params:
     *    - bin: the operator to compute
     * @returns: the result
     * @throws:
     *    - &ErrorMsg: if the value cannot be known at compile time
     */
    fn reduceSpecialMathInt (mut self, bin : &SpecialMathIntOperatorValue)-> &Value
        throws ErrorMsg
    {
        let left = self:.reduceInOperator (bin.getLeft (), checkCte-> false);
        let right = self:.reduceInOperator (bin.getRight (), checkCte-> false);
        let type = if let t : &IntType = bin.getType () { t } else { panic; };

        match (left, right) {
            (l : &IntValue, r : &IntValue) => {
                match bin.getOperator () {
                    BinaryOperators::DXOR => { return self:.computeBinMathIntPow (bin.getLoc (), type, l, r); }
                }
            }
        }

        copy SpecialMathIntOperatorValue (bin.getLoc (),
                                          bin.getType (),
                                          bin.getOperator (),
                                          self:.reduce (bin.getLeft ()),
                                          self:.reduce (bin.getRight ()),
                                          retValue-> self:.reduce (bin.getCall ()),
                                          isReduced-> true)
    }

    /**
     * Compute a power between two int values
     * @params:
     *    - type: the type of the addition
     *    - left: the left operand
     *    - right: the right operand
     * @returns: the result of the addition
     */
    fn computeBinMathIntPow (mut self, loc : &Word, type : &IntType, left : &IntValue, right : &IntValue)-> &Value
        throws ErrorMsg
    {
        let r = {
            left.getValue () ^^ right.getValue ()
        } catch {
            _ => throw copy ErrorMsg::fatal (loc, format (ValidateErrorMessage::OVERFLOW_CAPACITY, right.getType (), right, u64::max));
        }

        self.verifyOverFlowInt (loc, type, r);

        copy IntValue (loc, type, r)
    }

    /*!
     * ================================================================================
     * ================================================================================
     * ============================        INT UTILS        ===========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Verify that the int value does not exceed the capacities of the type
     * @params:
     *    - type: the type of the int value
     *    - val: the content of the int value
     * @throws:
     *    - &ErrorMsg: if there is an overflow
     */
    pub fn verifyOverFlowInt (self, loc : &Word, type : &IntType, value : usize)
        throws ErrorMsg
    {
        let max = self.createIntMaxValue (type);
        let min = self.createIntMinValue (type);

        if (value > max) {
            throw copy ErrorMsg::fatal (loc, format (ValidateErrorMessage::OVERFLOW_CAPACITY, type, value, max));
        }
        if (value < min) {
            throw copy ErrorMsg::fatal (loc, format (ValidateErrorMessage::OVERFLOW_CAPACITY_MIN, type, value, min));
        }
    }

    /**
     * Verify that the int value does not exceed the capacities of the type
     * @params:
     *    - type: the type of the int value
     *    - val: the content of the int value
     * @throws:
     *    - &ErrorMsg: if there is an overflow
     */
    pub fn verifyOverFlowInt (self, loc : &Word, type : &IntType, value : &BigInt)
        throws ErrorMsg
    {
        let max = self.createIntMaxValue (type);
        let min = self.createIntMinValue (type);

        if (value > max) {
            throw copy ErrorMsg::fatal (loc, format (ValidateErrorMessage::OVERFLOW_CAPACITY, type, value, max));
        }
        if (value < min) {
            throw copy ErrorMsg::fatal (loc, format (ValidateErrorMessage::OVERFLOW_CAPACITY_MIN, type, value, min));
        }
    }

    /**
     * Create the max value for the type 'i'
     * @params:
     *     - i: a int type
     * @returns: the maximum value the int can contain
     * */
    pub fn createIntMaxValue (self, i : &IntType)-> &BigInt {
        return self.createIntMaxValue (i.getSize (), i.isSigned ());
    }

    /**
     * Create the max value a type of size (size) and signed can encode
     * */
    pub fn createIntMaxValue (self, size : u16, signed : bool)-> &BigInt {
        match (size, signed) {
            (0u16, false) => { (copy BigInt (2us) ^^ (global::state::instance ().getSizeTypeSize ()) - 1us) }
            (0u16, true)  => { (copy BigInt (2us) ^^ (global::state::instance ().getSizeTypeSize () - 1us)) - 1us }
            (_, false)    => { (copy BigInt (2us) ^^ cast!usize (size) - 1us) }
            (_, true)     => { (copy BigInt (2us) ^^ cast!usize (size - 1u16)) - 1us }
            _ => {
                panic;
            }
        }
    } catch {
        _ : &BigIntError => {
            panic;
        }
    }

    /**
     * Create the min value for the type 'i'
     * @params:
     *     - i: a int type
     * @returns: the maximum value the int can contain
     * */
    pub fn createIntMinValue (self, i : &IntType)-> &BigInt {
        return self.createIntMinValue (i.getSize (), i.isSigned ());
    }

    /**
     * Create the min value a type of size (size) and signed can encode
     * */
    pub fn createIntMinValue (self, size : u16, signed : bool)-> &BigInt {
        match (size, signed) {
            (0u16, false) => { copy BigInt (0us) }
            (0u16, true)  => { 0us - (copy BigInt (2us) ^^ (global::state::instance ().getSizeTypeSize () - 1us)) }
            (_, false)    => { copy BigInt (0us) }
            (_, true)     => { 0us - (copy BigInt (2us) ^^ cast!usize (size - 1u16)) }
            _ => {
                panic;
            }
        }
    } catch {
        _ : &BigIntError => {
            panic;
        }
    }

    /*!
     * ================================================================================
     * ================================================================================
     * ============================        CHAR UTILS        ==========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Verify that the int value does not exceed the capacities of the type
     * @params:
     *    - type: the type of the int value
     *    - val: the content of the int value
     * @throws:
     *    - &ErrorMsg: if there is an overflow
     */
    pub fn verifyOverFlowChar (self, loc : &Word, type : &CharType, value : usize)
        throws ErrorMsg
    {
        let max = {
            copy BigInt (2us) ^^ cast!usize (type.getSize ()) - 1us
        } catch {
            _ : &BigIntError => panic;
        }

        if (value > max) {
            throw copy ErrorMsg::fatal (loc, format (ValidateErrorMessage::OVERFLOW_CAPACITY, type, value, max));
        }

        // if (value < 0) {
        //     throw copy ErrorMsg::fatal (loc, format (ValidateErrorMessage::OVERFLOW_CAPACITY_MIN, type, value, 0u64));
        // }
    }

    /**
     * Verify that the int value does not exceed the capacities of the type
     * @params:
     *    - type: the type of the int value
     *    - val: the content of the int value
     * @throws:
     *    - &ErrorMsg: if there is an overflow
     */
    pub fn verifyOverFlowChar (self, loc : &Word, type : &CharType, value : &BigInt)
        throws ErrorMsg
    {
        // Char are necessarily unsigned thus can be casted to usize
        self.verifyOverFlowChar (loc, type, value.toT!{usize} ());
    }

    /**
     * Verify that the char value does not exceed to capacities of the type
     * @params:
     *    - type: the type bounding the values
     *    - val: the content of the char value
     *  @throws:
     *    - &ErrorMsg: if there is an overflow
     * */
    pub fn verifyOverFlowChar (self, loc : &Word, type : &CharType, value : &CharValue)
        throws ErrorMsg
    {
        match value.getType ().asOf!{&CharType} ().getSize () {
            8u16 => {
                self.verifyOverFlowChar (loc, type, cast!{usize} (value.getValue ().utf8));
            }
            16u16 => {
                self.verifyOverFlowChar (loc, type, cast!{usize} (value.getValue ().utf16));
            }
            _ => {
                self.verifyOverFlowChar (loc, type, cast!{usize} (value.getValue ().utf16));
            }
        }
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================       BINARY CMP FLOAT        ========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Compute the value of float binary comparison
     * @params:
     *     - bin: the operator to compute
     * @returns: the result
     * @throws:
     *    - &ErrorMsg: if the value cannot be knwon at compile time
     */
    fn reduceCompareFloat (mut self, bin : &CmpFloatOperatorValue)-> &Value
        throws ErrorMsg
    {
        let left = self:.reduceInOperator (bin.getLeft (), checkCte-> false);
        let right = self:.reduceInOperator (bin.getRight (), checkCte-> false);
        match (left, right) {
            (l : &FloatValue, r : &FloatValue) => {
                match bin.getOperator () {
                    BinaryOperators::INF       => { return copy BoolValue (bin.getLoc (), l.getValue () < r.getValue ()); }
                    BinaryOperators::SUP       => { return copy BoolValue (bin.getLoc (), l.getValue () > r.getValue ()); }
                    BinaryOperators::INF_EQUAL => { return copy BoolValue (bin.getLoc (), l.getValue () <= r.getValue ()); }
                    BinaryOperators::SUP_EQUAL => { return copy BoolValue (bin.getLoc (), l.getValue () >= r.getValue ()); }
                    BinaryOperators::NOT_EQUAL => { return copy BoolValue (bin.getLoc (), l.getValue () != r.getValue ()); }
                    BinaryOperators::DEQUAL    => { return copy BoolValue (bin.getLoc (), l.getValue () == r.getValue ()); }
                }
            }
        }

        let resLeft = self:.reduce (bin.getLeft ());
        let resRight = self:.reduce (bin.getRight ());
        if (resLeft is resRight) || (resLeft.isFullLiteral () && resRight.isFullLiteral () && resLeft == resRight) {
            match bin.getOperator () {
                BinaryOperators::DEQUAL    => { return copy BoolValue (bin.getLoc (), true); }
                BinaryOperators::NOT_EQUAL => { return copy BoolValue (bin.getLoc (), false); }
                BinaryOperators::SUP       => { return copy BoolValue (bin.getLoc (), false); }
                BinaryOperators::INF       => { return copy BoolValue (bin.getLoc (), false); }
                BinaryOperators::INF_EQUAL => { return copy BoolValue (bin.getLoc (), true); }
                BinaryOperators::SUP_EQUAL => { return copy BoolValue (bin.getLoc (), true); }
            }
        }


        copy CmpFloatOperatorValue (bin.getLoc (), bin.getOperator (),
                                    self:.reduce (bin.getLeft ()),
                                    self:.reduce (bin.getRight ()),
                                    isReduced-> true)
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================       BINARY MATH FLOAT        =======================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Compute the value of a float binary math operator
     * @params:
     *    - bin: the operator to compute
     * @returns: the result
     * @throws:
     *    - &ErrorMsg: if the value cannot be known at compile time
     */
    fn reduceBinMathFloat (mut self, bin : &BinaryMathFloatOperatorValue)-> &Value
        throws ErrorMsg
    {
        let left = self:.reduceInOperator (bin.getLeft (), checkCte-> false);
        let right = self:.reduceInOperator (bin.getRight (), checkCte-> false);

        match (left, right, bin.getType ()) {
            (l : &FloatValue, r : &FloatValue, t : &FloatType) => {
                let v = match bin.getOperator () {
                    BinaryOperators::PLUS  => { l.getValue () + r.getValue () }
                    BinaryOperators::MINUS => { l.getValue () - r.getValue () }
                    BinaryOperators::STAR  => { l.getValue () * r.getValue () }
                    BinaryOperators::DIV   => {
                        if (r.getValue () == 0.0f) throw copy ErrorMsg::fatal (bin.getLoc (), ValidateErrorMessage::DIVISION_BY_ZERO);
                        {
                            l.getValue () / r.getValue ()
                        } catch { _        => panic; }
                    }
                    _ => {
                        return copy BinaryMathFloatOperatorValue (bin.getLoc (),
                                                                  bin.getType (),
                                                                  bin.getOperator (),
                                                                  self:.reduce (bin.getLeft ()),
                                                                  self:.reduce (bin.getRight ()),
                                                                  isReduced-> true);
                    }
                }

                return copy FloatValue (bin.getLoc (), t, v);
            }
            (_, r : &FloatValue, _) => {
                if (bin.getOperator () == BinaryOperators::DIV && r.getValue () == 0.0f) {
                    throw copy ErrorMsg::fatal (bin.getLoc (), ValidateErrorMessage::DIVISION_BY_ZERO);
                }
            }
        }

        return copy BinaryMathFloatOperatorValue (bin.getLoc (),
                                                  bin.getType (),
                                                  bin.getOperator (),
                                                  self:.reduce (bin.getLeft ()),
                                                  self:.reduce (bin.getRight ()),
                                                  isReduced-> true);
    }

    /**
     * Compute the value of a special float binary math operator
     * @params:
     *    - bin: the operator to compute
     * @returns: the result
     * @throws:
     *    - &ErrorMsg: if the value cannot be known at compile time
     */
    fn reduceSpecialMathFloat (mut self, bin : &SpecialMathFloatOperatorValue)-> &Value
        throws ErrorMsg
    {

        let left = self:.reduceInOperator (bin.getLeft (), checkCte-> false);
        let right = self:.reduceInOperator (bin.getRight (), checkCte-> false);

        match (left, right, bin.getType ()) {
            (l : &FloatValue, r : &IntValue, t : &FloatType) => {
                match bin.getOperator () {
                    BinaryOperators::DXOR => { return self:.computeBinMathFloatPow (bin.getLoc (), t, l, r); }
                }
            }
            (l : &FloatValue, r : &FloatValue, t : &FloatType) => {
                match bin.getOperator () {
                    BinaryOperators::DXOR => { return self:.computeBinMathFloatPow (bin.getLoc (), t, l, r); }
                    BinaryOperators::PERCENT => { return self:.computeBinMathFloatMod (bin.getLoc (), t, l, r); }
                }
            }
            (_, r : &FloatValue, _) => {
                if (bin.getOperator () == BinaryOperators::PERCENT && r.getValue () == 0.0f) {
                    throw copy ErrorMsg::fatal (bin.getLoc (), ValidateErrorMessage::DIVISION_BY_ZERO);
                }
            }
        }

        copy SpecialMathFloatOperatorValue (bin.getLoc (),
                                            bin.getType (),
                                            bin.getOperator (),
                                            self:.reduce (bin.getLeft ()),
                                            self:.reduce (bin.getRight ()),
                                            retValue-> self:.reduce (bin.getCall ()),
                                            isReduced-> true)
    }

    /**
     * Compute a mod division between two float values
     * @params:
     *    - type: the type of the addition
     *    - left: the left operand
     *    - right: the right operand
     * @returns: the result of the addition
     */
    fn computeBinMathFloatMod (mut self, loc : &Word, type : &FloatType, left : &FloatValue, right : &FloatValue)-> &Value
        throws ErrorMsg
    {
        if (right.getValue () == 0.0f) throw copy ErrorMsg::fatal (loc, ValidateErrorMessage::DIVISION_BY_ZERO);
        let r = {
            left.getValue () % right.getValue ()
        } catch {
            _ => panic;
        };

        copy FloatValue (loc, type, r)
    }

    /**
     * Compute a power between a float and a int value
     * @params:
     *    - type: the type of the addition
     *    - left: the left operand
     *    - right: the right operand
     * @returns: the result of the addition
     */
    fn computeBinMathFloatPow (mut self, loc : &Word, type : &FloatType, left : &FloatValue, right : &IntValue)-> &Value
        throws ErrorMsg
    {
        let r = {
            left.getValue () ^^ right.getValue ().to!{i64} ()
        } catch {
            _ => throw copy ErrorMsg::fatal (loc, format (ValidateErrorMessage::OVERFLOW_CAPACITY, right.getType (), right, u64::max));
        }


        copy FloatValue (loc, type, r)
    }

    /**
     * Compute a power between a float and a int value
     * @params:
     *    - type: the type of the addition
     *    - left: the left operand
     *    - right: the right operand
     * @returns: the result of the addition
     */
    fn computeBinMathFloatPow (mut self, loc : &Word, type : &FloatType, left : &FloatValue, right : &FloatValue)-> &Value {
        let r = left.getValue () ^^ right.getValue ();
        copy FloatValue (loc, type, r)
    }

    /*!
     * ================================================================================
     * ================================================================================
     * ===========================        FLOAT UTILS        ==========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Create the maximal finite value for the type 'f'
     * @params:
     *     - f: a float type
     * @returns: the maximal finite value the float can encode
     * */
    pub fn createFloatMaxValue (self, f : &FloatType)-> &BigFloat {
        match (f.getSize (), state::instance ().getFloatTypeSize ()) {
            (32u16, _) => { self.createFloatFromHex ("1"s8, "fffffe"s8, "127"s8) }
            (64u16, _) => { self.createFloatFromHex ("1"s8, "fffffffffffff"s8, "1023"s8) }
            (80u16, _) => { self.createFloatFromHex ("f"s8, "fffffffffffffff"s8, "16380"s8) }

            // fsize
            (_, 32u16) => { self.createFloatFromHex ("1"s8, "fffffe"s8, "127"s8) }
            (_, 64u16) => { self.createFloatFromHex ("1"s8, "fffffffffffff"s8, "1023"s8) }
            _ => {
                self.createFloatFromHex ("f"s8, "fffffffffffffff"s8, "16380"s8)
            }
        }
    }

    /**
     * Create the minimal finite value for the type 'f'
     * @params:
     *     - f: a float type
     * @returns: the minimal finite value the float can encode
     * */
    pub fn createFloatMinValue (self, f : &FloatType)-> &BigFloat {
        match (f.getSize (), state::instance ().getFloatTypeSize ()) {
            (32u16, _) => { self.createFloatFromHex ("1"s8, "0"s8, "-126"s8) }
            (64u16, _) => { self.createFloatFromHex ("1"s8, "0"s8, "-1022"s8) }
            (80u16, _) => { self.createFloatFromHex ("8"s8, "0"s8, "-16385"s8) }

            // fsize
            (_, 32u16) => {  self.createFloatFromHex ("1"s8, "0"s8, "-126"s8) }
            (_, 64u16) => {  self.createFloatFromHex ("1"s8, "0"s8, "-1022"s8) }
            _ => {
                self.createFloatFromHex ("8"s8, "0"s8, "-16385"s8)
            }
        }
    }

    /**
     * Create the nan value for the type 'f'
     * @params:
     *     - f: a float type
     * @returns: the nan value the float can encode
     * */
    pub fn createFloatNanValue (self, _ : &FloatType)-> &BigFloat {
        copy BigFloat (f32::nan)
    }

    /**
     * Create the precision for the type 'f'
     * @params:
     *     - f: a float type
     * @returns: the precision of the float
     * */
    pub fn createFloatDigValue (self, f : &FloatType)-> usize {
        match (f.getSize (), global::state::instance ().getFloatTypeSize ()) {
            (32u16, _) => { 6us }
            (64u16, _) => {  15us }
            (80u16, _) => {  18us }

            // fsize
            (_, 32u16) => { 6us }
            (_, 64u16) => {  15us }
            _ => {  18us }
        }
    }

    /**
     * Create the number of bits int the mantissa for the type 'f'
     * @params:
     *     - f: a float type
     * @returns: the number of bits in the mantissa
     * */
    pub fn createFloatMantDigValue (self, f : &FloatType)-> usize {
        match (f.getSize (), state::instance ().getFloatTypeSize ()) {
            (32u16, _) => { 24us }
            (64u16, _) => {  53us }
            (80u16, _) => {  64us }

            // fsize
            (_, 32u16) => { 24us }
            (_, 64u16) => {  53us }
            _ => {  64us }
        }
    }

    /**
     * Create the maximum values such that 10^^max is representable by type 'f'
     * @params:
     *     - f: a float type
     * */
    pub fn createFloatMax10ExpValue (self, f : &FloatType)-> usize {
        match (f.getSize (), state::instance ().getFloatTypeSize ()) {
            (32u16, _) => { 38us }
            (64u16, _) => { 308us }
            (80u16, _) => { 4932us }

            // fsize
            (_, 32u16) => { 38us }
            (_, 64u16) => { 308us }
            _ => { 4932us }
        }
    }

    /**
     * Create the minimum values such that 10^^min is representable by type 'f'
     * @params:
     *     - f: a float type
     * */
    pub fn createFloatMin10ExpValue (self, f : &FloatType)-> isize {
        match (f.getSize (), state::instance ().getFloatTypeSize ()) {
            (32u16, _) => { -37is }
            (64u16, _) => {  -307is }
            (80u16, _) => {  -4931is }

            // fsize
            (_, 32u16) => { -37is }
            (_, 64u16) => {  -307is }
            _ => {  -4931is }
        }
    }

    /**
     * Create the maximum values such that 2^^(max-1) is representable by type 'f'
     * @params:
     *     - f: a float type
     * */
    pub fn createFloatMax2ExpValue (self, f : &FloatType)-> usize {
        match (f.getSize (), state::instance ().getFloatTypeSize ()) {
            (32u16, _) => { 128us }
            (64u16, _) => {  1024us }
            (80u16, _) => { 16384us }

            // fsize
            (_, 32u16) => { 128us }
            (_, 64u16) => {  1024us }
            _ => { 16384us }
        }
    }

    /**
     * Create the minimum values such that 2^^(min) is representable by type 'f'
     * @params:
     *     - f: a float type
     * */
    pub fn createFloatMin2ExpValue (self, f : &FloatType)-> isize {
        match (f.getSize (), state::instance ().getFloatTypeSize ()) {
            (32u16, _) => { -125is }
            (64u16, _) => {  -1021is }
            (80u16, _) => { -16381is }

            // fsize
            (_, 32u16) => { -125is }
            (_, 64u16) => {  -1021is }
            _ => { -16381is }
        }
    }

    /**
     * Create the number of decimal digit of precision value for the type 'f'
     * @params:
     *     - f: a float type
     * @returns: the dig value the float can encode
     * */
    pub fn createFloatInfValue (self, _ : &FloatType)-> &BigFloat {
        copy BigFloat (f32::inf)
    }

    /**
     * Create the number of decimal digit of precision value for the type 'f'
     * @params:
     *     - f: a float type
     * @returns: the dig value the float can encode
     * */
    pub fn createFloatEpsilonValue (self, f : &FloatType)-> &BigFloat {
        match (f.getSize (), state::instance ().getFloatTypeSize ()) {
            (32u16, _) => { copy BigFloat (2.0) ^^ (-23i64) }
            (64u16, _) => {  copy BigFloat (2.0) ^^ (-52i64) }
            (80u16, _) => {  copy BigFloat (2.0) ^^ (-63i64) }

            // fsize
            (_, 32u16) => { copy BigFloat (2.0) ^^ (-23i64) }
            (_, 64u16) => {  copy BigFloat (2.0) ^^ (-52i64) }
            _ => {  copy BigFloat (2.0) ^^ (-63i64) }
        }
    }

    /**
     * Create a bigfloat from hexadecimal parts
     * @params:
     *    - int: the int part of the hex literal
     *    - frac: the fractional part of the hex literal
     *    - exp: the exponential part of the hex literal
     * @returns: a bigfloat
     * */
    pub fn createFloatFromHex (self, int : [c8], frac : [c8], exp : [c8])-> &BigFloat {
        let intPartV = copy BigFloat (copy BigInt (std::conv::to!{usize, 16us} (int)));
        let decPartV = copy BigFloat ((copy BigInt (std::conv::to!{usize, 16us} (frac)))) * (copy BigFloat (16.0) ^^ -cast!i64 (frac.len));
        let expPartV = if (exp [0] == '-'c8) {
            copy BigFloat (2.0) ^^ -std::conv::to!{i64} (exp[1 .. $])
        } else {
            copy BigFloat (2.0) ^^ std::conv::to!{i64} (exp)
        };

        (intPartV + decPartV) * expPartV
    } catch {
        _ => panic;
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================            RANGE             =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Compute a range contain value (x in z..y)
     * */
    fn reduceRangeContain (mut self, rng : &RangeContainValue)-> &Value
        throws ErrorMsg
    {
        let left = self:.reduceInStructAccess (rng.getLeft ());
        let right = self:.reduceInStructAccess (rng.getRight ());

        match right {
            r : &RangeValue => {
                let fstR = r.getLeft ();
                let scdR = r.getRight ();
                let containsR = r.getIsFull ();

                match (left, fstR, scdR, containsR) {
                    (x : &IntValue, fst : &IntValue, scd : &IntValue, contain : &BoolValue) => {
                        let res = if (contain.isTrue ()) {
                            if (fst.getValue () < scd.getValue ()) {
                                x.getValue () >= fst.getValue () && x.getValue () <= scd.getValue ()
                            } else {
                                x.getValue () >= scd.getValue () && x.getValue () <= fst.getValue ()
                            }
                        } else {
                            if (fst.getValue () < scd.getValue ()) {
                                x.getValue () >= fst.getValue () && x.getValue () < scd.getValue ()
                            } else {
                                x.getValue () > scd.getValue () && x.getValue () <= fst.getValue ()
                            }
                        };

                        return if (rng.getOperator () == Keys::NOT_IN) {
                            copy BoolValue (rng.getLoc (), !res)
                        } else {
                            copy BoolValue (rng.getLoc (), res)
                        };
                    }
                }
            }
        }

        copy RangeContainValue (rng.getLoc (),
                                rng.getType (),
                                rng.getOperator (),
                                self:.reduce (rng.getLeft ()),
                                self:.reduce (rng.getRight ()),
                                rng.getCall (),
                                isReduced-> true)
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================            UNARY             =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Compute the value of a unary operation
     * @params:
     *   - un: the value to compute
     * @returns: the result
     * @throws:
     *   - &ErrorMsg: if the value cannot be known at compile time
     */
    fn reduceUnary (mut self, un : &UnaryOperatorValue)-> &Value
        throws ErrorMsg
    {
        match un {
            b : &UnaryBoolOperatorValue  => return self:.reduceUnaryBool (b);
            i : &UnaryIntOperatorValue   => return self:.reduceUnaryInt (i);
            f : &UnaryFloatOperatorValue => return self:.reduceUnaryFloat (f);
            _ => {
                return un;
            }
        }
    }

    /**
     * Compute the value of an unary operator on a bool value
     * @params:
     *    - un: the unary operator to validate
     * @returns: the result value
     * @throws:
     *    - &ErrorMsg: if the value cannot be known at compile time
     */
    fn reduceUnaryBool (mut self, un : &UnaryBoolOperatorValue)-> &Value
        throws ErrorMsg
    {
        let content = self:.reduceInOperator (un.getOperand (), checkCte-> false);
        match un.getOperator () {
            UnaryOperators::NOT => {
                match content {
                    v : &BoolValue => {
                        if (v.isTrue ()) {
                            return copy BoolValue (un.getLoc (), false);
                        } else {
                            return copy BoolValue (un.getLoc (), true);
                        }
                    }
                }
            }
        }

        copy UnaryBoolOperatorValue (un.getLoc (),
                                     un.getOperator (),
                                     self:.reduce (un.getOperand ()),
                                     isReduced-> true)
    }

    /**
     * Compute the value of an unary operator on an int value
     * @params:
     *    - un: the unary operator to validate
     * @returns: the result value
     * @throws:
     *    - &ErrorMsg: if the value cannot be known at compile time
     */
    fn reduceUnaryInt (mut self, un : &UnaryIntOperatorValue)-> &Value
        throws ErrorMsg
    {
        let content = self:.reduceInOperator (un.getOperand (), checkCte-> false);
        match un.getOperator () {
            UnaryOperators::MINUS => {
                match (content, un.getType ()) {
                    (v : &IntValue, it : &IntType) => {
                        return copy IntValue (un.getLoc (), it, copy BigInt (0) - v.getValue ());
                    }
                }
            }
        }

        copy UnaryIntOperatorValue (un.getLoc (),
                                    un.getType (),
                                    un.getOperator (),
                                    self:.reduce (un.getOperand ()),
                                    isReduced-> true)
    }

    /**
     * Compute the value of an unary operator on a float value
     * @params:
     *    - un: the unary operator to validate
     * @returns: the result value
     * @throws:
     *    - &ErrorMsg: if the value cannot be known at compile time
     * */
    fn reduceUnaryFloat (mut self, un : &UnaryFloatOperatorValue)-> &Value
        throws ErrorMsg
    {
        let content = self:.reduceInOperator (un.getOperand (), checkCte-> false);
        match un.getOperator () {
            UnaryOperators::MINUS => {
                match (content, un.getType ()) {
                    (v : &FloatValue, ti : &FloatType) => {
                        return copy FloatValue (un.getLoc (), ti, copy BigFloat (0.0) - v.getValue ());
                    }
                }
            }
        }

        copy UnaryFloatOperatorValue (un.getLoc (),
                                      un.getType (),
                                      un.getOperator (),
                                      self:.reduce (un.getOperand ()),
                                      isReduced-> true)
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================         SLICE ACCESS         =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Reduce an array/slice comparison operator
     * */
    fn reduceArraySpecialOp (mut self, value : &SpecialArrayOperatorValue)-> &Value
        throws ErrorMsg
    {
        let left = self:.reduceInOperator (value.getLeft (), checkCte-> false);
        let right = self:.reduceInOperator (value.getRight (), checkCte-> false);
        match (left, right) {
            (l : &StringValue, r : &StringValue) => {
                if (value.getType () of BoolType) {
                    return self:.compareStringBool (value.getLoc (), value.getOperator (), l, r);
                } else {
                    return self:.compareStringInt (value.getLoc (), value.getOperator (), l, r);
                }
            }
        }

        copy SpecialArrayOperatorValue (value.getLoc (),
                                        value.getType (),
                                        value.getOperator (),
                                        self:.reduce (value.getLeft ()),
                                        self:.reduce (value.getRight ()),
                                        value.getCall (),
                                        isReduced-> true)
    }

    /**
     * Compare two string an return a bool value
     * */
    fn compareStringBool (mut self, loc : &Word, op : BinaryOperators, left : &StringValue, right : &StringValue)-> &Value {
        if (left.getEncodingSize () != right.getEncodingSize ()) panic;

        let result = (left == right);
        if (op == BinaryOperators::DEQUAL) {
            return copy BoolValue (loc, result);
        } else {
            return copy BoolValue (loc, !result);
        }
    }

    /**
     * Compare two string values an return a int value (-1 => "<", 1 => ">", 0 => "==")
     * */
    fn compareStringInt (mut self, loc : &Word, _ : BinaryOperators, left : &StringValue, right : &StringValue)-> &Value {
        if (left.getEncodingSize () != right.getEncodingSize ()) panic;
        let mi = if (left.getLen () > right.getLen ()) { left.getLen () } else { right.getLen () };

        match left.getEncodingSize () {
            8u16 => {
                for i in 0us .. mi {
                    if (left.getValue ().utf8 [i] < right.getValue ().utf8 [i]) return makeIntValue (loc, -1is, size-> 32u16, signed-> true);
                    else if (left.getValue ().utf8 [i] > right.getValue ().utf8 [i]) return makeIntValue (loc, 1is, size-> 32u16, signed-> true);
                }

                if (left.getLen () > right.getLen ()) return makeIntValue (loc, 1is, size-> 32u16, signed-> true);
                else if (left.getLen () < right.getLen ()) return makeIntValue (loc, -1is, size-> 32u16, signed-> true);
                return makeIntValue (loc, 0is, size-> 32u16, signed-> true);
            }
            16u16 => {
                for i in 0us .. mi {
                    if (left.getValue ().utf16 [i] < right.getValue ().utf16 [i]) return makeIntValue (loc, -1is, size-> 32u16, signed-> true);
                    else if (left.getValue ().utf16 [i] > right.getValue ().utf16 [i]) return makeIntValue (loc, 1is, size-> 32u16, signed-> true);
                }

                if (left.getLen () > right.getLen ()) return makeIntValue (loc, 1is, size-> 32u16, signed-> true);
                else if (left.getLen () < right.getLen ()) return makeIntValue (loc, -1is, size-> 32u16, signed-> true);
                return makeIntValue (loc, 0is, size-> 32u16, signed-> true);
            }
            _ => {
                for i in 0us .. mi {
                    if (left.getValue ().utf32 [i] < right.getValue ().utf32 [i]) return makeIntValue (loc, -1is, size-> 32u16, signed-> true);
                    else if (left.getValue ().utf32 [i] > right.getValue ().utf32 [i]) return makeIntValue (loc, 1is, size-> 32u16, signed-> true);
                }

                if (left.getLen () > right.getLen ()) return makeIntValue (loc, 1is, size-> 32u16, signed-> true);
                else if (left.getLen () < right.getLen ()) return makeIntValue (loc, -1is, size-> 32u16, signed-> true);
                return makeIntValue (loc, 0is, size-> 32u16, signed-> true);
            }
        }
    }

    /**
     * Compute a slice access value
     * @params:
     *   - slc: the value to compute
     * @returns: the result
     * @throws:
     *    - &ErrorMsg: if the value cannot be known at compile time
     */
    fn reduceSliceAccess (mut self, slc : &SliceAccessValue)-> &Value
        throws ErrorMsg
    {
        let array = self:.reduceInOperator (slc.getSlice (), checkCte-> false);
        let index = self:.reduceInOperator (slc.getIndex (), checkCte-> false);

        let u_index = match index {
            i : &IntValue => {
                {
                    i.getValue ().to!usize ()
                } catch {
                    _ => throw copy ErrorMsg::fatal (i.getLoc (),
                                                     format (ValidateErrorMessage::OVERFLOW_CAPACITY, copy IntType (i.getLoc (), size-> 0u16, signed-> false), i.getValue (), 12));
                }
            }
            _ => {
                return copy SliceAccessValue (slc.getLoc (),
                                              slc.getType (),
                                              self:.reduce (slc.getSlice ()),
                                              self:.reduce (slc.getIndex ()),
                                              isReduced-> true);
            }
        };


        if let a : &ArrayValue = array {
            if (a.getValues ().len <= u_index) {
                throw copy ErrorMsg::fatal (a.getLoc (), format (ValidateErrorMessage::ARRAY_OVERFLOW, a.getValues ().len, u_index));
            }

            return a.getValues ()[u_index];
        }

        else if let str : &StringValue = array {
            if (str.getLen () <= u_index) {
                throw copy ErrorMsg::fatal (str.getLoc (), format (ValidateErrorMessage::ARRAY_OVERFLOW, str.getLen (), u_index));
            }

            let chType = if let s : &SliceType = str.getType () {
                if let c : &CharType = s.getInners ()[0] { c } else { panic; }
            } else { panic; };

            return match str.getEncodingSize () {
                8u16 => {
                    copy CharValue (slc.getLoc (), chType, str.getValue ().utf8 [u_index])
                }
                16u16 => {
                    copy CharValue (slc.getLoc (), chType, str.getValue ().utf16 [u_index])
                }
                _ => {
                    copy CharValue (slc.getLoc (), chType, str.getValue ().utf32 [u_index])
                }
            };
        }

        copy SliceAccessValue (slc.getLoc (),
                               slc.getType (),
                               self:.reduce (slc.getSlice ()),
                               self:.reduce (slc.getIndex ()),
                               isReduced-> true)

    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================         ARRAY ACCESS         =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Compute an array access
     * */
    fn reduceArrayAccessValue (mut self, a : &ArrayAccessValue)-> &Value
        throws ErrorMsg
    {
        let value = self:.reduceInOperator (a.getArray (), checkCte-> false);
        let index = self:.reduceInOperator (a.getIndex (), checkCte-> false);

        let u_index = match index {
            i : &IntValue => {
                {
                    i.getValue ().to!usize ()
                } catch {
                    _ => throw copy ErrorMsg::fatal (i.getLoc (),
                                                     format (ValidateErrorMessage::OVERFLOW_CAPACITY, copy IntType (i.getLoc (), size-> 0u16, signed-> false), i.getValue (), 12));
                }
            }
            _ => {
                return copy ArrayAccessValue (a.getLoc (), a.getType (),
                                              self:.reduce (a.getArray ()),
                                              self:.reduce (a.getIndex ()),
                                              isReduced-> true);
            }
        };


        if let lit : &ArrayValue = value {
            if (lit.getValues ().len <= u_index) {
                throw copy ErrorMsg::fatal (a.getLoc (), format (ValidateErrorMessage::ARRAY_OVERFLOW, lit.getValues ().len, u_index));
            }

            return lit.getValues ()[u_index];
        }

        if let lit : &ArrayAllocValue = value {
            if let len : &IntValue = lit.getLen () {
                if (len.getValue () <= u_index) {
                    throw copy ErrorMsg::fatal (a.getLoc (), format (ValidateErrorMessage::ARRAY_OVERFLOW, len, u_index));
                }

                if (!lit.isDynamic ()) {
                    return lit.getValue ()
                }
            }
        }

        copy ArrayAccessValue (a.getLoc (), a.getType (),
                               self:.reduce (a.getArray ()),
                               self:.reduce (a.getIndex ()),
                               isReduced-> true)
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===============================          MAP ACCESS/INSERT          ================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Reduce a map access
     * */
    fn reduceMapAccess (mut self, m : &MapAccessValue)-> &Value
        throws ErrorMsg
    {
        let mp = self:.reduceInOperator (m.getMap (), checkCte-> true);
        let key = self:.reduceInOperator (m.getKey (), checkCte-> true);
        let err = self:.reduceInOperator (m.getKeyError (), checkCte-> true);

        if let inner : &MapValue = mp {
            for i in 0us .. inner.getLen () {
                if (inner.getKeys () [i] == key) return inner.getValues ()[i];
            }
        }

        copy MapAccessValue (m.getLoc (), m.getType (), mp, key, err, isReduced-> true)
    }

    /**
     * Reduce a map insert
     * */
    fn reduceMapInsert (mut self, m : &MapInsertValue)-> &Value
        throws ErrorMsg
    {
        let mp = self:.reduceInOperator (m.getMap (), checkCte-> true);
        let key = self:.reduceInOperator (m.getKey (), checkCte-> true);
        let value = self:.reduceInOperator (m.getValue (), checkCte-> true);

        copy MapInsertValue (m.getLoc (), m.getType (), mp, key, value, isReduced-> true)
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================         FIELD ACCESS         =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Compute a field access on a tuple
     * */
    fn reduceFieldAccessTuple (mut self, tu : &TupleFieldAccessValue, inOperator : bool)-> &Value
        throws ErrorMsg
    {
        let or = self:.reduce (tu.getTuple ());
        let mut defResult : &Value = copy TupleFieldAccessValue (tu.getLoc (), tu.getType (),
                                                                 or,
                                                                 tu.getFieldIndex (),
                                                                 isReduced-> true);

        if let lit : &TupleValue = or {
            if (lit.getValues ().len > tu.getFieldIndex ()) {
                defResult = lit.getValues ()[tu.getFieldIndex ()];
            }
        }


        if let lit : &TupleValue = self:.reduceInStructAccess (tu.getTuple ()) {
            if (lit.getValues ().len > tu.getFieldIndex ()) {
                if (inOperator || self.isCte (lit.getValues ()[tu.getFieldIndex ()])) {
                    defResult = lit.getValues ()[tu.getFieldIndex ()];
                }
            }
        }

        return defResult;
    }

    /**
     * Reduce a field access on an option value
     * */
    fn reduceFieldAccessOption (mut self, acc : &OptionFieldAccessValue, inOperator : bool)-> &Value
        throws ErrorMsg
    {
        let or = self:.reduce (acc.getOption ());
        let mut defResult : &Value = copy OptionFieldAccessValue (acc.getLoc (),
                                                                  acc.getType (),
                                                                  or,
                                                                  acc.getFieldName (),
                                                                  isReduced-> true);
        match or {
            r : &OptionValue => {
                defResult = self:.reduceFieldAccessOption (r, acc.getFieldName (), defResult, false);
            }
            e : &ErrOptionValue => {
                defResult = self:.reduceFieldAccessOption (e, acc.getFieldName (), defResult, false);
            }
        }

        let inner = self:.reduceInStructAccess (acc.getOption ());
        match inner {
            r : &OptionValue => {
                defResult = self:.reduceFieldAccessOption (r, acc.getFieldName (), defResult, !inOperator);
            }
            e : &ErrOptionValue => {
                defResult = self:.reduceFieldAccessOption (e, acc.getFieldName (), defResult, !inOperator);
            }
        }

        return defResult;
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ==============================          STRUCT FIELD ACCESS          ===============================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Compute the value of a struct field access
     * @params:
     *    - acc: the value to compute
     */
    fn reduceFieldAccess (mut self, acc : &StructFieldAccessValue, inOperator : bool)-> &Value
        throws ErrorMsg
    {
        match acc.getStruct ().getType () {
            RangeType () => {
                return self:.reduceFieldAccessRange (acc, inOperator);
            }
            SliceType () => {
                return self:.reduceFieldAccessSlice (acc, inOperator);
            }
            OptionType () => {
                return self:.reduceFieldAccessOption (acc, inOperator);
            }
        }

        let or = self:.reduce (acc.getStruct ());
        let mut defResult : &Value = copy StructFieldAccessValue (acc.getLoc (), acc.getType (),
                                                                  or,
                                                                  acc.getFieldName (),
                                                                  isReduced-> true);

        match or {
            s : &StructInitValue => {
                defResult = self:.reduceFieldAccessStructInit (acc.getLoc (), s, acc.getFieldName (), defResult, false);
            }
            c : &CopierValue => {
                match c.getValue () {
                    s : &StructInitValue => { defResult = self:.reduceFieldAccessStructInit (acc.getLoc (), s, acc.getFieldName (), defResult, false); }
                }
            }
        }

        match self:.reduceInStructAccess (acc.getStruct ()) {
            s : &StructInitValue => {
                defResult = self:.reduceFieldAccessStructInit (acc.getLoc (), s, acc.getFieldName (), defResult, !inOperator);
            }
            c : &CopierValue => {
                match c.getValue () {
                    s : &StructInitValue => { defResult = self:.reduceFieldAccessStructInit (acc.getLoc (), s, acc.getFieldName (), defResult, !inOperator); }
                }
            }
        }

        return defResult;
    }

    /**
     * Reduce a field access in a struct init value
     * */
    fn reduceFieldAccessStructInit (mut self, _ : &Word, v : &StructInitValue, acc : [c8], or : &Value, checkCte : bool)-> & Value {
        for i, f in v.getFieldNames () {
            if f == acc {
                if (!checkCte || self.isCte (v.getValues ()[i])) {
                    return v.getValues ()[i];
                }
            }
        }

        return or;
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===============================          RANGE FIELD ACCESS          ===============================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Compute the value of a struct field access on a range value
     * @params:
     *    - rng: the range value that is accessed
     *    - field: the name of the field being accessed
     */
    fn reduceFieldAccessRange (mut self, acc : &StructFieldAccessValue, inOperator : bool)-> &Value
        throws ErrorMsg
    {
        let or = self:.reduce (acc.getStruct ());
        let mut defResult : &Value = copy StructFieldAccessValue (acc.getLoc (), acc.getType (),
                                                                  or,
                                                                  acc.getFieldName (),
                                                                  isReduced-> false);
        match or {
            r : &RangeValue => {
                defResult = self:.reduceFieldAccessRange (r, acc.getFieldName (), defResult, false);
            }
            c : &CopierValue => {
                match c.getValue () {
                    r : &RangeValue => {
                        defResult = self:.reduceFieldAccessRange (r, acc.getFieldName (), defResult, false);
                    }
                }
            }
        }


        let inner = self:.reduceInStructAccess (acc.getStruct ());
        match inner {
            r : &RangeValue => {
                defResult = self:.reduceFieldAccessRange (r, acc.getFieldName (), defResult, !inOperator);
            }
            c : &CopierValue => {
                match c.getValue () {
                    r : &RangeValue => {
                        defResult = self:.reduceFieldAccessRange (r, acc.getFieldName (), defResult, !inOperator);
                    }
                }
            }
        }

        return defResult;
    }

    /**
     * Reduce the field access in a range ctor value
     * */
    fn reduceFieldAccessRange (mut self, rng : &RangeValue, field : [c8], defResult : &Value, checkCte : bool)-> &Value {
        let res = if (field == RangeKeys::FST) {
            rng.getLeft ()
        } else if (field == RangeKeys::SCD) {
            rng.getRight ()
        } else if (field == RangeKeys::CONTAINS) {
            rng.getIsFull ()
        } else if (field == RangeKeys::STEP) {
            rng.getStep ()
        } else {
            return defResult;
        };

        if (checkCte && !self.isCte (res)) return defResult;
        res
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===============================          SLICE FIELD ACCESS          ===============================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Compute the value of a struct field access on a slice value
     * @params:
     *    - rng: the range value that is accessed
     *    - field: the name of the field being accessed
     */
    fn reduceFieldAccessSlice (mut self, acc : &StructFieldAccessValue, inOperator : bool)-> &Value
        throws ErrorMsg
    {
        let or = self:.reduce (acc.getStruct ());
        let mut defResult : &Value = copy StructFieldAccessValue (acc.getLoc (), acc.getType (),
                                                                  or,
                                                                  acc.getFieldName (),
                                                                  isReduced-> false);
        match or {
            r : &SliceCtorValue => {
                defResult = self:.reduceFieldAccessSlice (r, acc.getFieldName (), defResult, false);
            }
            c : &CopierValue => {
                match c.getValue () {
                    r : &SliceCtorValue => {
                        defResult = self:.reduceFieldAccessSlice (r, acc.getFieldName (), defResult, false);
                    }
                }
            }
        }

        let mut inner = self:.reduceInStructAccess (acc.getStruct ());
        if let bl : &BlockValue = inner && acc.getFieldName () == SliceKeys::LEN && bl.getValues ().len > 0 {
            inner = bl.getValues ()[$ - 1];
        }

        match inner {
            r : &SliceCtorValue => {
                defResult = self:.reduceFieldAccessSlice (r, acc.getFieldName (), defResult, !inOperator);
            }
            c : &CopierValue => {
                match c.getValue () {
                    r : &SliceCtorValue => {
                        defResult = self:.reduceFieldAccessSlice (r, acc.getFieldName (), defResult, !inOperator);
                    }
                }
            }
        }

        return defResult;
    }

    /**
     * Reduce the field access in a slice ctor value
     * */
    fn reduceFieldAccessSlice (mut self, slc : &SliceCtorValue, field : [c8], defResult : &Value, checkCte : bool)-> &Value {
        let res = if (field == SliceKeys::PTR) {
            slc.getPointer ()
        } else if (field == SliceKeys::LEN) {
            slc.getLen ()
        } else {
            return defResult;
        };

        if (checkCte && !self.isCte (res)) return defResult;
        res
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ==============================          OPTION FIELD ACCESS          ===============================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Compute the value of a struct field access on a option value
     * @params:
     *    - rng: the range value that is accessed
     *    - field: the name of the field being accessed
     */
    fn reduceFieldAccessOption (mut self, acc : &StructFieldAccessValue, inOperator : bool)-> &Value
        throws ErrorMsg
    {
        let or = self:.reduce (acc.getStruct ());
        let mut defResult : &Value = copy StructFieldAccessValue (acc.getLoc (), acc.getType (),
                                                                  or,
                                                                  acc.getFieldName (),
                                                                  isReduced-> false);
        match or {
            r : &OptionValue => {
                defResult = self:.reduceFieldAccessOption (r, acc.getFieldName (), defResult, false);
            }
            e : &ErrOptionValue => {
                defResult = self:.reduceFieldAccessOption (e, acc.getFieldName (), defResult, false);
            }
        }

        let inner = self:.reduceInStructAccess (acc.getStruct ());
        match inner {
            r : &OptionValue => {
                defResult = self:.reduceFieldAccessOption (r, acc.getFieldName (), defResult, !inOperator);
            }
            e : &ErrOptionValue => {
                defResult = self:.reduceFieldAccessOption (e, acc.getFieldName (), defResult, !inOperator);
            }
        }

        return defResult;
    }

    /**
     * Reduce the field access in a slice ctor value
     * */
    fn reduceFieldAccessOption (mut self, opt : &OptionValue, field : [c8], defResult : &Value, checkCte : bool)-> &Value {
        let res = if (field == OptionKeys::SET) {
            copy BoolValue (opt.getLoc (), true)
        } else if (field == OptionKeys::HAS_ERROR) {
            copy BoolValue (opt.getLoc (), false)
        } else if (field == OptionKeys::VALUE) {
            opt.getValue ()
        } else {
            return defResult;
        };

        if (checkCte && !self.isCte (res)) return defResult;
        res
    }

    /**
     * Reduce the field access in a slice ctor value
     * */
    fn reduceFieldAccessOption (mut self, opt : &ErrOptionValue, field : [c8], defResult : &Value, checkCte : bool)-> &Value {
        let res = if (field == OptionKeys::SET) {
            copy BoolValue (opt.getLoc (), false)
        } else if (field == OptionKeys::HAS_ERROR) {
            if (opt.getValue () of NullValue) {
                copy BoolValue (opt.getLoc (), false)
            } else return defResult;
        } else if (field == OptionKeys::ERROR) {
            opt.getValue ()
        } else {
            return defResult;
        };

        if (checkCte && !self.isCte (res)) return defResult;
        res
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================      CONDITION / LOOPS       =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Compute a conditional value
     * @params:
     *   - cd: the value to compute
     * @returns: the result
     * @throws:
     *    - &ErrorMsg: if the value cannot be known at compile time
     */
    fn reduceConditional (mut self, cd : &ConditionalValue)-> &Value
        throws ErrorMsg
    {
        let test = self:.reduceInOperator (cd.getTest (), checkCte-> false);
        match test {
            b : &BoolValue => {
                if (b.isTrue ()) {
                    return self:.reduce (cd.getValue ());
                } else {
                    match cd.getElse () {
                        UnitValue () => return UNIT_VALUE;
                        e : _ => {
                            return self:.reduce (e);
                        }
                    }
                }
            }
        }

        copy ConditionalValue (cd.getLoc (), cd.getType (),
                               self:.reduce (cd.getTest ()),
                               self:.reduce (cd.getValue ()),
                               self:.reduce (cd.getElse ()),
                               isComplete-> cd.isComplete (),
                               isReduced-> true)
    }

    /**
     * Compute a block value
     * @params:
     *   - bl: the block value to compute
     * @returns: the result
     * @throws:
     *    - &ErrorMsg: if the value cannot be known at compile time
     */
    fn reduceBlock (mut self, block : &BlockValue, inOperator : bool = false, inStruct : bool = false)-> &Value
        throws ErrorMsg
    {
        let mut values : [mut &Value] = [];
        let mut lastVal : (&Value)? = none;
        let mut brLoc = EOF_WORD, mut rtLoc = EOF_WORD;

        for iv in block.getValues () {
            let v = if (inOperator) {
                self:.reduceInOperator (iv, checkCte-> false)
            } else if (inStruct) {
                self:.reduceInStructAccess (iv)
            } else {
                self:.reduce (iv)
            };

            if (v.isReturner ()) { rtLoc = v.getReturnerLoc (); }
            if (v.isBreaker ()) { brLoc = v.getBreakerLoc (); }
            lastVal = (v)?;

            if (!v.isFullLiteral () || v.isBreaker () || v.isReturner ()) {
                values ~= [v];
                lastVal = none;
            }
        }

        if (values.len == 0us && brLoc.isEof () && rtLoc.isEof ()) match lastVal {
            Ok (v : &Value) => {
                if (v !of UnitValue) return v;
            }
        }

        match lastVal {
            Ok (v : &Value) => {
                values ~= [v];
            }
        }

        if (values.len == 1us && values [0us] !of UnitValue) return values [0];
        copy BlockValue (block.getLoc (),
                         block.getType (),
                         values,
                         breakLoc-> brLoc,
                         returnLoc-> rtLoc,
                         isSet-> block.isSet (),
                         noValue-> block.noValue (),
                         isReduced-> true)
    }

    fn reduceListCompr (mut self, l : &ListComprValue)-> &Value
        throws ErrorMsg
    {
        let inner = self:.reduce (l.getContent ());
        match inner {
            b : &BlockValue => return copy ListComprValue (l.getLoc (), l.getType (), b, isReduced-> true);
            v : _ => return v;
        }
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================             VARS             =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Compute a var ref value
     * @params:
     *   - bl: the value to compute
     * @returns: the result
     * @throws:
     *    - &ErrorMsg: if the value cannot be known at compile time
     */
    fn reduceVarRefInOperator (mut self, vref : &VarRefValue)-> &Value
        throws ErrorMsg
    {
        if (!self._isForRef) {
            let inner = self:.reduceInOperator (vref.getValue (), checkCte-> false);
            if (inner.getType ().mutabilityFit (vref.getType ()) || !inner.getType ().needExplicitAlias ()) {
                if (vref.getValue () !of UnitValue && vref.canCte () && !vref.getType ().isMutable ()) {
                    return inner;
                }
            }
        }

        copy VarRefValue (vref.getLoc (),
                          vref.getDeclLoc (),
                          vref.getType (),
                          value-> self:.reduce (vref.getValue ()), // we don't want dangling reduced var if the operation fails
                          vref.getRefId (),
                          isSelf-> vref.isSelf (),
                          canCte-> false,
                          isReduced-> true)
    }

    /**
     * Compute a var ref value
     * @params:
     *   - bl: the value to compute
     * @returns: the result
     * @throws:
     *    - &ErrorMsg: if the value cannot be known at compile time
     */
    fn reduceVarRefInStructAccess (mut self, vref : &VarRefValue)-> &Value
        throws ErrorMsg
    {
        if (!self._isForRef) {
            let inner = self:.reduceInStructAccess (vref.getValue ());
            if (vref.getValue () !of UnitValue && vref.canCte () && !vref.getType ().isMutable ()) {
                match (inner.getType ()) {
                    RangeType () => return inner;
                    SliceType () => return inner;
                    OptionType () => return inner;
                    TupleType () => return inner;
                }
            }
        }

        copy VarRefValue (vref.getLoc (),
                          vref.getDeclLoc (),
                          vref.getType (),
                          value-> self:.reduce (vref.getValue ()),
                          vref.getRefId (),
                          isSelf-> vref.isSelf (),
                          canCte-> false,
                          isReduced-> true)
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================         CAST VALUES          =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Compute a cast value
     * */
    fn reduceCastValue (mut self, c : &CastValue)-> &Value
        throws ErrorMsg
    {
        let mut inner = self:.reduceInOperator (c.getValue (), checkCte-> false);
        let or = {
            let innerOr = self:.reduce (c.getValue ());
            if (innerOr.getType () == c.getType ()) {
                innerOr
            } else {
                cast!{&Value} (copy CastValue (c.getLoc (), c.getType (), innerOr, isLvalue-> c.isLvalue (), isReduced-> true))
            }
        };

        match c.getType () {
            iT : &IntType => { return self:.reduceCastToInt (c.getLoc (), inner, iT, or); }
            cT : &CharType => { return self:.reduceCastToChar (c.getLoc (), inner, cT, or); }
            fT : &FloatType => { return self:.reduceCastToFloat (c.getLoc (), inner, fT, or); }
            _ => {
                return or;
            }
        }
    }

    /**
     * Compute a cast to a int value
     * */
    fn reduceCastToInt (mut self, loc : &Word, value : &Value, iT : &IntType, or : &Value)-> &Value
        throws ErrorMsg
    {
        match (value) {
            i : &IntValue => {
                self.verifyOverFlowInt (loc, iT, i.getValue ());
                return copy IntValue (loc, iT, i.getValue ());
            }
            ch : &CharValue => {
                let ival = ch.getValueAsInt ();

                self.verifyOverFlowInt (loc, iT, ival);
                return copy IntValue (loc, iT, ival);
            }
            b : &BoolValue => {
                if (b.isTrue ()) {
                    return copy IntValue (loc, iT, copy BigInt (1));
                } else {
                    return copy IntValue (loc, iT, copy BigInt (0));
                }
            }
            f : &FloatValue => {
                let ival = copy BigInt (f.getValue ());
                self.verifyOverFlowInt (loc, iT, ival);

                return copy IntValue (loc, iT, ival);
            }
            _ => {
                return or;
            }
        };
    }

    /**
     * Compute a cast to a float value
     * */
    fn reduceCastToFloat (mut self, loc : &Word, value : &Value, fT : &FloatType, or : &Value)-> &Value {
        match value {
            i : &IntValue => {
                return copy FloatValue (loc, fT, copy BigFloat (i.getValue ()));
            }
            f : &FloatValue => {
                return copy FloatValue (loc, fT, f.getValue ());
            }
            _ => {
                return or;
            }
        }
    }

    /**
     * Compute a cast to a char value
     * */
    fn reduceCastToChar (mut self, loc : &Word, value : &Value, ct : &CharType, or : &Value)-> &Value
        throws ErrorMsg
    {
        match value {
            i : &IntValue => {
                self.verifyOverFlowChar (loc, ct, i.getValue ());
                return copy CharValue (loc, ct, i.getValue ());
            }
            c : &CharValue => {
                self.verifyOverFlowChar (loc, ct, c.getValueAsInt ());
                return copy CharValue (loc, ct, c.getValueAsInt ());
            }
            _ => {
                return or;
            }
        }
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================         CALL VALUES          =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Compute the value of a call value
     * @params:
     *    - cl: the call value to compute
     */
    fn reduceCallValue (mut self, cl : &CallValue)-> &Value
        throws ErrorMsg
    {
        match (cl.getParameters ().len, cl.getPrototype ().getSymbol ()) {
            (0us, func : &FunctionSymbol) => {
                match func.getFrameBody () {
                    v : &Value => {
                        // call to a function with no body
                        // Probably extern function, or method, or whatever actually
                        if (v of UnitValue) return cl;
                        let mut inner = self:.reduce (v);
                        match inner {
                            bl : &BlockValue => {
                                if (bl.isSet () && bl.getValues ().len == 1us) {
                                    inner = bl.getValues ()[$ - 1us];
                                }
                            }
                        }

                        let ret = match inner {
                            r : &ReturnValue => {
                                self:.reduce (r.getValue ())
                            }
                            _ => { inner }
                        };

                        if (self.isCte (ret)) {
                            return ret;
                        }
                    }
                }
            }
        }

        if (cl.getParameters ().len == 0us && cl.getAddParameters ().len == 0us) return cl;

        let params    = copy [self:.reduce (i) for i in cl.getParameters ()];
        let addParams = copy [self:.reduce (i) for i in cl.getAddParameters ()];

        copy CallValue (cl.getLoc (), cl.getType (), cl.getPrototype (), params, addParams-> addParams, isReduced-> true)
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================         MISC VALUES          =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Compute an address operator value
     * @params:
     *   - addr: the value to compute
     * @returns: the result
     * @throws:
     *    - &ErrorMsg: if the value cannot be known at compile time
     */
    fn reduceAddress (mut self, addr : &AddressValue)-> &Value
        throws ErrorMsg
    {
        // if we want the address of a var, we don't want the address of its value
        // So no operator reduction
        let inner = self:.reduce (addr.getValue ());
        return copy AddressValue (addr.getLoc (), addr.getType (), inner, isReduced-> true);
    }

    /**
     * Compute the value of an aliaser
     */
    fn reduceAliaser (mut self, al : &AliaserValue)-> &Value
        throws ErrorMsg
    {
        let inner = self:.reduceInOperator (al.getValue (), checkCte-> false);
        if (self.isCte (inner)) {
            return copy AliaserValue (al.getLoc (), al.getType (), inner, isReduced-> true);
        } else {
            return copy AliaserValue (al.getLoc (), al.getType (), self:.reduce (al.getValue ()), isReduced-> true);
        }
    }
}
