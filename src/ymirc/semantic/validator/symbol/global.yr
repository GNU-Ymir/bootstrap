in global;

use ymirc::semantic::validator::{visitor, errors, utf};
use ymirc::syntax::{_,
                    declaration::_,
                    expression::{_, literal::_, macro_::_, operator::_, template::_}};

use ymirc::semantic::{symbol::_, generator::_};
use ymirc::semantic::declarator::visitor;


use ymirc::errors::_;
use ymirc::utils::{format, log};
use ymirc::lexing::{word, tokens};
use ymirc::syntax::keys;
use std::{stream, io};

use ymirc::semantic::generator::type::{_,
                                       syntax::_,
                                       custom::_,
                                       native::{_, scalar::_, compound::_},
                                       temporary::_};

use ymirc::semantic::generator::value::{_,
                                        syntax::_,
                                        construct::{_, delegate::_},
                                        literal::_,
                                        memory::_,
                                        operator::{_, binary::_, call::_, fields::_, map::_, slice::_, unary::_},
                                        operator::map::iteration::_,
                                        prototypes::_,
                                        scope::_,
                                        syntax::_,
                                        template::_};


/**
 * The global validator is the class responsible for the validation of global variable
 */
@final
pub class GlobalValidator {

    // The list of enum symbols currently in validation to avoid infinite recursion, and validating multiple times the same symbol
    let mut _validation : [&Symbol => mut ()] = copy [];

    /**
     * Create a new empty validator
     * */
    pub self () {}

    /**
     * Validate a global symbol
     * @params:
     *    - context: the context of the validation
     *    - glb: the global variable to validate
     * @throws: &ErrorMsg, if the validation failed
     * */
    pub fn validate (mut self, dmut context : &Validator, dmut sym : &GlobalSymbol, fromModule : bool)
        throws ErrorMsg
    {
        if (!self.checkValidation (sym)) {
            logging::info ("Validate global variable %", sym.getPath ());
            self:.validateGlobalContent (alias context, alias sym, fromModule);
        }

        match sym.getGenerator () {
            g : &GlobalVarGenerator => {
                if (!sym.isExternal () && fromModule) {
                    context:.insertGenerator (alias sym, g);
                }
            }
            err : &ErrorGenerator => {
                throw err.getErrorMessage ();
            }
            _ => panic;
        }
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================      CONTENT VALIDATOR       =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate the global variable
     * @info: in case of error instead of throwing an exception, puts an ErrorGenerator in the symbol
     * @params:
     *    - context: the context of the validation
     *    - sym: the symbol to validate
     * */
    fn validateGlobalContent (mut self, dmut context : &Validator, dmut sym : &GlobalSymbol, fromModule : bool) {
        // If the validation of the global variable is not finished
        // a recursive reference will lead to a an infinite loop, we want to avoid that

        sym:.setGenerator (copy ErrorGenerator (sym.getLoc (),
                                                copy ErrorMsg::fatal (sym.getLoc (), ValidateErrorMessage::FORWARD_REFERENCE_TYPE)));
        self._validation [sym] = ();

        context:.pushReferent (alias sym);
        context:.enterForeign (isFnBody-> false);

        {
            if (sym.isExternal ()) {
                self.validateExternal (alias context, alias sym);
            } else {
                self.validateLazyLocal (alias context, alias sym, fromModule);
            }
        } catch {
            err : &ErrorMsg => {
                sym:.setGenerator (copy ErrorGenerator (sym.getLoc (), copy ErrorMsg::fatal (sym.getLoc (), ValidateErrorMessage::VALIDATING, notes-> copy [err])));
            }
        }

        context:.popReferent ();
        context:.exitForeign ();

        self._validation:.remove (sym);
    }

    /**
     * Validate the global variable assuming it is a global static external variable (from C language for example)
     * @params:
     *    - context: the context of the validation
     *    - sym: the symbol to validate
     * */
    fn validateExternal (self, dmut context : &Validator, dmut sym : &GlobalSymbol)
        throws ErrorMsg
    {
        let v = sym.getContent ().getContent ();
        match v.getValue () {
            EmptyExpression () => {}
            value : _ => {
                throw copy ErrorMsg::fatal (sym.getLoc (), end-> value.getLoc (), format (ValidateErrorMessage::EXTERN_GLOBAL_WITH_VALUE));
            }
        }

        let type = match v.getType () {
            EmptyExpression () => {
                throw copy ErrorMsg::fatal (sym.getLoc (), end-> v.getLoc (), format (ValidateErrorMessage::EXTERN_GLOBAL_NO_TYPE));
            }
            t : _ => {
                context:.validateTypeForVarDecl (t, v, canBeRef-> false, canBeLazy-> true)
            }
        };

        if (v.isLazy () && type.isMutable () && !type.needExplicitAlias ()) {
            throw copy ErrorMsg::fatal (v.getMutOrDmutLocation (), ValidateErrorMessage::MUTABLE_LAZY_VAR);
        }

        let gvar = copy GlobalVarGenerator (sym.getLoc (),
                                            sym.getPath (),
                                            type-> type,
                                            value-> UNIT_VALUE,
                                            isMutable-> (v.isMutable () || v.isDeeplyMutable ()),
                                            isLazy-> v.isLazy (),
                                            externLang-> sym.getExternalLanguage (),
                                            isWeak-> sym.isWeak (),
                                            isThreadLocal-> false);

        sym:.setGenerator (gvar);
    }

    /**
     * Validate the global variable assuming it is declared localy and it is a lazy variable
     * @params:
     *    - context: the context of the validation
     *    - sym: the symbol to validate
     * */
    fn validateLazyLocal (self, dmut context : &Validator, dmut sym : &GlobalSymbol, fromModule : bool)
        throws ErrorMsg
    {
        let v = sym.getContent ().getContent ();
        match v.getValue () {
            EmptyExpression () => {
                throw copy ErrorMsg::fatal (sym.getLoc (), end-> v.getLoc (), format (ValidateErrorMessage::GLOBAL_NO_VALUE));
            }
        };

        let value = context:.validateValue (v.getValue ());

        let declType = match v.getType () {
            EmptyExpression () => {
                context:.validateTypeForVarDecl (copy TypeWrapperExpr (value.getLoc (), value.getType ()), v, canBeRef-> false, canBeLazy-> true)
            }
            t : _  => {
                context:.validateTypeForVarDecl (t, v, canBeRef-> false, canBeLazy-> true)
            }
        };

        let finValue = context:.verifyCompatibleTypeWithValue (declType.getLoc (), declType, value, byReference-> false);
        let content = copy ValueWrapperExpr (v.getLoc (), finValue);
        let intrLazy = copy IntrinsicExpr (finValue.getLoc (), IntrinsicKeys::LAZY, content);

        let lazyVal = context:.getValueValidator ().validateLazy (alias context, intrLazy, content, canBeLazy-> true);
        context.verifyMemoryOwner (declType.getLoc (), declType, lazyVal, construct-> true, byReference-> false, byLazy-> true);

        if (declType.isMutable () && !declType.needExplicitAlias ()) {
            throw copy ErrorMsg::fatal (v.getMutOrDmutLocation (), ValidateErrorMessage::MUTABLE_LAZY_VAR);
        }

        let gvar = copy GlobalVarGenerator (sym.getLoc (),
                                            sym.getPath (),
                                            type-> declType,
                                            value-> lazyVal,
                                            isMutable-> (v.isMutable () || v.isDeeplyMutable ()),
                                            isLazy-> true,
                                            isWeak-> sym.isWeak (),
                                            isThreadLocal-> sym.isThreadLocal ());

        sym:.setGenerator (gvar);
        if (fromModule) {
            context:.insertGenerator (alias sym, gvar);
        }
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================           CHECKING           =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * @returns: true if the global variable was already validated, or is currently in validation
     */
    fn checkValidation (self, sym : &GlobalSymbol)-> bool {
        match sym.getGenerator () {
            EmptyGenerator () => { // The global variable has no value, but maybe it is currently in validation (recursive global var validation)
                if sym in self._validation {
                    return true;
                }

                false
            }
            _ => { true }
        }
    }
}
