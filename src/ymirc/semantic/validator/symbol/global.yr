mod ymirc::semantic::validator::symbol::global;

import ymirc::semantic::validator::visitor;
import ymirc::semantic::validator::errors;
import ymirc::syntax::declaration::protection;
import ymirc::syntax::expression::_;
import ymirc::syntax::declaration::_;
import ymirc::semantic::symbol::_;
import ymirc::semantic::declarator::visitor;
import ymirc::semantic::validator::utf;


import ymirc::semantic::generator::_;
import ymirc::errors::_;
import ymirc::utils::format;
import ymirc::lexing::word;
import ymirc::syntax::keys;
import ymirc::lexing::tokens;


import std::collection::set;
import std::collection::vec;
import std::io, std::fs::path;

/**
 * The global validator is the class responsible for the validation of global variable
 */
pub class GlobalValidator {

    /// The list of enum symbols currently in validation to avoid infinite recursion, and validating multiple times the same symbol
    let dmut _validation = HashSet!{&Symbol}::new ();

    /**
     * Create a new empty validator
     * */
    pub self () {}

    /**
     * Validate a global symbol
     * @params:
     *    - context: the context of the validation
     *    - glb: the global variable to validate
     * @throws: &ErrorMsg, if the validation failed
     * */
    pub fn validate (mut self, dmut context : &Validator, dmut sym : &GlobalSymbol)
        throws &ErrorMsg
    {
        if (!self.checkValidation (sym)) {
            self:.validateGlobalContent (alias context, alias sym);
        }

        match sym.getGenerator () {
            GlobalVarGenerator () => {}
            err : &ErrorGenerator => {
                throw err.getErrorMessage ();
            }
            _ => __pragma!panic ();
        }
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================      CONTENT VALIDATOR       =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate the global variable
     * @info: in case of error instead of throwing an exception, puts an ErrorGenerator in the symbol
     * @params:
     *    - context: the context of the validation
     *    - sym: the symbol to validate
     * */
    fn validateGlobalContent (mut self, dmut context : &Validator, dmut sym : &GlobalSymbol) {
        // If the validation of the global variable is not finished
        // a recursive reference will lead to a an infinite loop, we want to avoid that

        sym:.setGenerator (ErrorGenerator::new (sym.getLoc (), ErrorMsg::fatal (sym.getLoc (), ValidateErrorMessage::FORWARD_REFERENCE_TYPE)));
        self._validation:.insert (sym);

        {
            if (sym.isExternal ()) {
                self.validateExternal (alias context, alias sym);
            } else {
                self.validateLazyLocal (alias context, alias sym);
            }
        } catch {
            err : &ErrorMsg => {
                sym:.setGenerator (ErrorGenerator::new (sym.getLoc (), ErrorMsg::fatal (sym.getLoc (), ValidateErrorMessage::VALIDATING, notes-> [err])));
            }
        }

        self._validation:.remove (sym);
    }

    /**
     * Validate the global variable assuming it is a global static external variable (from C language for example)
     * @params:
     *    - context: the context of the validation
     *    - sym: the symbol to validate
     * */
    fn validateExternal (self, dmut context : &Validator, dmut sym : &GlobalSymbol)
        throws &ErrorMsg
    {
        match sym.getContent ().getContent () {
            v : &VarDeclExpr => {
                match v.getValue () {
                    EmptyExpression () => {}
                    value : _ => {
                        throw ErrorMsg::fatal (sym.getLoc (), end-> value.getLoc (), format (ValidateErrorMessage::EXTERN_GLOBAL_WITH_VALUE));
                    }
                }

                let type = match v.getType () {
                    EmptyExpression () => {
                        throw ErrorMsg::fatal (sym.getLoc (), end-> v.getLoc (), format (ValidateErrorMessage::EXTERN_GLOBAL_NO_TYPE));
                    }
                    t : _ => {
                        context:.validateTypeForVarDecl (t, v, canBeRef-> false, canBeLazy-> true)
                    }
                };

                let gvar = GlobalVarGenerator::new (sym.getLoc (), sym.getPath (), type-> type, value-> UNIT_VALUE,
                                                    isMutable-> (v.isMutable () || v.isDeeplyMutable ()), isLazy-> v.isLazy (),
                                                    externLang-> sym.getExternalLanguage (), isWeak-> sym.isWeak ());


                sym:.setGenerator (gvar);
            }
        }
    }

    /**
     * Validate the global variable assuming it is declared localy and it is a lazy variable
     * @params:
     *    - context: the context of the validation
     *    - sym: the symbol to validate
     * */
    fn validateLazyLocal (self, dmut context : &Validator, dmut sym : &GlobalSymbol)
        throws &ErrorMsg
    {
        context;
        sym;
        __pragma!fake_throw (&ErrorMsg);
        __pragma!panic ();
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================           CHECKING           =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * @returns: true if the global variable was already validated, or is currently in validation
     */
    fn checkValidation (self, sym : &GlobalSymbol)-> bool {
        match sym.getGenerator () {
            EmptyGenerator () => { // The global variable has no value, but maybe it is currently in validation (recursive global var validation)
                for it in self._validation {
                    if it is sym {
                        return true; // Indeed it is
                    }
                }

                false
            }
            _ => { true }
        }
    }

    
}
