in function;

use ymirc::semantic::validator::{visitor, template::_, errors};
use ymirc::semantic::{generator::_, symbol::_};
use ymirc::syntax::{_,
                    declaration::_,
                    expression::{_, literal::_, macro_::_, operator::_, template::_}};

use ymirc::errors::_;
use ymirc::utils::{format, log};
use ymirc::lexing::word;
use std::{stream, io};

use ymirc::semantic::generator::type::{_,
                                       syntax::_,
                                       custom::_,
                                       native::{_, scalar::_, compound::_},
                                       temporary::_};

use ymirc::semantic::generator::value::{_,
                                        syntax::_,
                                        construct::{_, delegate::_},
                                        literal::_,
                                        memory::_,
                                        operator::{_, binary::_, call::_, fields::_, map::_, slice::_, unary::_},
                                        operator::map::iteration::_,
                                        prototypes::_,
                                        scope::_,
                                        syntax::_,
                                        template::_};

/**
 * The function validator is the class responsible for function symbol validation
 */
@final
pub class FunctionValidator {

    // The list of validating symbol, to avoid infinite value call recursion (foo (a = bar()), bar (a = foo ()))
    let mut _validating : [&Symbol => mut ()] = copy [];
    
    /**
     * Create a new empty validator
     */
    pub self () {}


    /**
     * Validate a function
     * @info: insert the generator in the context for "generation"
     * @params: 
     *   - context: the context of the validation
     *   - sym: the function to validate
     * @throws: 
     *    - &ErrorMsg: if the func is not valid
     */
    pub fn validate (mut self, dmut context : &Validator, dmut sym : &FunctionSymbol)
        throws ErrorMsg
    {
        context:.pushReferent (alias sym);
        context:.enterForeign (isFnBody-> false);

        {
            self:.validateFunction (alias context, alias sym);
        }  catch {
            err : &ErrorMsg => {
                context:.exitForeign ();
                context:.popReferent ();
                throw copy ErrorMsg::fatal (sym.getLoc (), format (ValidateErrorMessage::VALIDATING_SYMBOL, sym.getPath ().toStr ()), notes-> copy [err]);
            }
        }
        
        context:.exitForeign ();
        context:.popReferent ();
    }

    /**
     * Validate a constructor symbol
     * @info: insert the generator in the context for "generation"
     * @params: 
     *    - context: the context of the validation
     *    - sym: the symbol to validate
     *    - clRef: the type of the class containing the ctor
     * @throws: 
     *    - &ErrorMsg: if the ctor is not valid
     */
    pub fn validateConstructor (mut self, dmut context : &Validator, dmut sym : &ConstructorSymbol, clRef : &ClassRefType)
        throws ErrorMsg
    {
        context:.pushReferent (alias sym);
        context:.enterForeign (isFnBody-> false, clContext-> clRef);
        {
            // Only one kind of constructor
            self:.validateConstructor (alias context, alias sym, clRef, validateBody-> true);
        }  catch {
            err : &ErrorMsg => {
                context:.exitForeign ();
                context:.popReferent ();
                throw copy ErrorMsg::fatal (sym.getLoc (), format (ValidateErrorMessage::VALIDATING_SYMBOL, sym.getPath ().toStr ()), notes-> copy [err]);
            }
        }
        
        context:.exitForeign ();
        context:.popReferent ();
    }

    /**
     * Fully validate a method definition  (not just the prototype)
     * @params: 
     *    - context: the context of the validation
     *    - sym: the method to validate
     *    - clRef: the type of self in the method
     * @throws:
     *     - &ErrorMsg: if there was an error in the validation
     */
    pub fn validateMethod (mut self, dmut context : &Validator, dmut sym : &FunctionSymbol, clRef : &ClassRefType)
        throws ErrorMsg
    {
        context:.pushReferent (alias sym);
        context:.enterForeign (isFnBody-> false, clContext-> clRef);

        {
            // Only one kind of method
            // We don't care if it was defined inside a trait, we don't use the method prototype that is generated
            self:.validateMethod (alias context, alias sym, sym.getContent (), clRef, fromTrait-> EMPTY_SYMBOL, validateBody-> true);
        } catch {
            err : &ErrorMsg => {
                context:.exitForeign ();
                context:.popReferent ();
                throw copy ErrorMsg::fatal (sym.getLoc (), format (ValidateErrorMessage::VALIDATING_SYMBOL, sym.getPath ().toStr ()), notes-> copy [err]);
            }
        }
        
        context:.exitForeign ();
        context:.popReferent ();
    }

    /**
     * Validate a destructor defined a class
     * @params:
     *    - context: the context of the validation
     *    - sym: the dtor to validate
     *    - clRef: the class defining the dtor
     * @throws:
     *     - &ErrorMsg: if there is an error in the validation
     */
    pub fn validateDestructor (mut self, dmut context : &Validator, dmut sym : &DestructorSymbol, clRef : &ClassRefType)
        throws ErrorMsg
    {
        let ancDtor = match clRef.getAncestor () {
            Ok (ancRef) => { // maybe the ancestor has a destructor
                ancRef.getDestructor ()
            }
            _ => { // No ancestor, so no destructor at all
                UNIT_VALUE
            }
        };

        context:.pushReferent (alias sym);
        context:.enterForeign (isFnBody-> false, clContext-> clRef);

        {
            self:.validateDestructor (alias context, alias sym, clRef, validateBody-> true, ancDtor-> ancDtor)
        } catch {
            err : &ErrorMsg => {
                context:.exitForeign ();
                context:.popReferent ();
                throw copy ErrorMsg::fatal (sym.getLoc (), format (ValidateErrorMessage::VALIDATING_SYMBOL, sym.getPath ().toStr ()), notes-> copy [err]);
            }
        }

        context:.exitForeign ();
        context:.popReferent ();
    }


    /*!
     * ================================================================================
     * ================================================================================
     * =========================          PROTOTYPES          =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate the prototype of a function
     * @params: 
     *    - context: the context of the validation
     *    - sym: the symbol to validate
     * @returns: a callable prototype of function
     * @throws: &ErrorMsg, if the function is malformed
     */
    pub fn validateFuncPrototype (mut self, dmut context : &Validator, dmut sym : &FunctionSymbol)-> &PrototypeValue
        throws ErrorMsg
    {
        match (sym.getFrameProto ()) {
            EmptyGenerator () => {
                let ret = {
                    context:.pushReferent (alias sym);
                    context:.enterForeign (isFnBody-> false);
                    
                    self:.validateFunction (alias context, alias sym, validateBody-> false)
                } exit {                
                    context:.exitForeign ();
                    context:.popReferent ();
                } catch {
                    err : &ErrorMsg => {
                        throw copy ErrorMsg::fatal (sym.getLoc (), format (ValidateErrorMessage::VALIDATING_SYMBOL, sym.getPath ().toStr ()), notes-> copy [err]);
                    }                    
                } 


                ret
            }
            v : &PrototypeValue => {
                v
            }
            g : _ => {
                println ("What is inside the function ???", g.__typeinfo__.name);
                panic;
            }
        }
    }

    /**
     * Validate a prototype of a symbol that is not declared, as it comes from a template rewrite
     * @params: 
     *    - context: the context of the validation
     *    - sym: the symbol declaring the template definition
     *    - func: the rewritten function declaration
     *    - rewriter: the template rewriter
     * @returns: the validate prototype value of the function
     * @throws:
     *    - &ErrorMsg: if the validation fails
     */
    pub fn validateFuncPrototypeFromTemplate (mut self, dmut context : &Validator, dmut sym : &Symbol, func : &FunctionDecl, rewriter : TemplateRewriter)-> &PrototypeValue
        throws ErrorMsg
    {
        context:.pushReferent (alias sym);
        context:.enterForeign (isFnBody-> false);

        let mut error : (&ErrorMsg)? = none;
        let throwers = self.validateThrowers (alias context, func.getThrowerLoc (), func.getThrowers ());
        self.verifyUndefAttributes (func.getAttributes ());

        let (retType, parameters) = {
            context:.enterBlock ();
            {
                {
                    self:.validatePrototype (alias context, sym, func.getFunctionProto ())      
                } catch {
                    err : &ErrorMsg => {
                        error = (copy ErrorMsg::fatal (sym.getLoc (), format (ValidateErrorMessage::VALIDATING_SYMBOL, sym.getPath ().toStr ()),
                                                      notes-> copy [err]))?;
                        (NONE_TYPE, [])
                    }                    
                }
            } exit {
                {
                    context:.quitBlock (warnUnused-> false);
                } catch {
                    _ =>  panic;
                }
            }
        }

        if let Ok (msg) = error { throw msg; }
        copy PrototypeValue (sym.getLoc (), sym, parameters, retType, throwers, fromTemplate-> rewriter?, attributes-> func.getAttributes ())
    } exit {
        context:.exitForeign ();
        context:.popReferent ();
    }
    
    /**
     * Validate the prototype of a constructor
     * @params: 
     *    - context: the context of the validation
     *    - sym: the symbol to validate
     *    - clRef: the type of the class that will be used as self
     * @returns: a callable prototype of function
     * @throws:
     *    - &ErrorMsg, if the constructor is malformed
     */
    pub fn validateCtorPrototype (mut self, dmut context : &Validator, dmut sym : &ConstructorSymbol, clRef : &ClassRefType, noValue : bool = false)-> &CtorPrototypeValue
        throws ErrorMsg
    {
        let ret = {
            context:.pushReferent (alias sym);
            context:.enterForeign (isFnBody-> false, clContext-> clRef);

            self:.validateConstructor (alias context, alias sym, clRef, validateBody-> false, noValue-> noValue)
        } exit {
            context:.exitForeign ();
            context:.popReferent ();
        } catch {
            err : &ErrorMsg => {
                throw copy ErrorMsg::fatal (sym.getLoc (), format (ValidateErrorMessage::VALIDATING_SYMBOL, sym.getPath ().toStr ()),
                                            notes-> copy [err]);
            }
        };

        ret
    }

    /**
     * Validate the prototype of a constructor that was declared as a template
     * @params:
     *    - context: the context of the validation
     *    - sym: the template symbol (used for context references only)
     *    - func: the constructor declaration defining the prototype
     *    - clRef: the class type that declared the method
     *    - rewriter: the rewriter defined by the template specialization solving
     * @returns:  A constructor prototype
     * @throws:
     *    - &ErrorMsg: if the validation of the prototype fails
     * */
    pub fn validateCtorPrototypeFromTemplate (mut self, dmut context : &Validator, dmut sym : &Symbol, func : &ConstructorDecl, clRef : &ClassRefType, rewriter : TemplateRewriter)-> &CtorPrototypeValue
        throws ErrorMsg
    {
        context:.pushReferent (alias sym);
        context:.enterForeign (isFnBody-> false, clContext-> clRef);
        let ret = {
            let mut errors : [&ErrorMsg] = [];
            let throwers = self.validateThrowers (alias context, func.getThrowerLoc (), func.getThrowers ());
            self.verifyUndefAttributes (func.getAttributes ());

            let parameters = {
                context:.enterBlock ();
                let clPtr = clRef.createInstance (true, true);
                let selfParam = copy ProtoVarValue (func.getLoc (), clPtr, UNIT_VALUE, true, isSelf-> true, isReference-> clRef.isStruct ());
                context:.insertLocal (selfParam.getLoc (), selfParam.getLoc ().str, selfParam, canShadow-> true);

                let (_, parameters) = self:.validatePrototype (alias context, sym, func.getFunctionProtoDecl (), forMethod-> false);

                parameters
            } catch {
                err : &ErrorMsg => {
                    errors ~= [err];
                    []
                }
            } exit {
                {
                    context:.quitBlock (warnUnused-> false);
                } catch {
                    err : &ErrorMsg => { errors ~= [err]; }
                }
            }

            if (errors.len != 0us) throw copy ErrorMsg::list (errors);

            copy CtorPrototypeValue (sym.getLoc (), sym, rename-> func.getRename ().str, parameters, throwers,
                                     clRef-> clRef, attributes-> func.getAttributes (), fromTemplate-> rewriter?)
        } exit {
            context:.exitForeign ();
            context:.popReferent ();
        } catch {
            err : &ErrorMsg => {
                throw copy ErrorMsg::fatal (sym.getLoc (), format (ValidateErrorMessage::VALIDATING_SYMBOL, sym.getPath ().toStr ()),
                                            notes-> copy [err]);
            }
        };

        ret
    }

    /**
     * Validate a method prototype defined inside a trait symbol
     * @params: 
     *   - context: the context of the validation
     *   - sym: the function to validate
     *   - clRef: the type of the class (used for the self parameter)
     *   - traitRef: the trait that defines the method
     * @returns: the prototype of the method
     * @throws:
     *   - &ErrorMsg: if the validation fails
     */
    pub fn validateMethodPrototype (mut self, dmut context : &Validator, dmut sym : &FunctionSymbol, clRef : &ClassRefType, traitRef : &TraitRefType, noValue : bool = false)-> &MethodPrototypeValue
        throws ErrorMsg
    {
        let ret = {
            context:.pushReferent (alias sym);
            context:.enterForeign (isFnBody-> false, clContext-> clRef);

            self:.validateMethod (alias context, alias sym, sym.getContent (), clRef, fromTrait-> traitRef.getSymbol (), validateBody-> false, noValue-> noValue)
        } exit {
            context:.exitForeign ();
            context:.popReferent ();
        } catch {
            err : &ErrorMsg => {
                throw copy ErrorMsg::fatal (sym.getLoc (), format (ValidateErrorMessage::VALIDATING_SYMBOL, sym.getPath ().toStr ()),
                                            notes-> copy [err]);
            }
        };

        ret
    }

    /**
     * Validate a method prototype defined inside a trait symbol
     * @params: 
     *   - context: the context of the validation
     *   - sym: the function to validate
     *   - clRef: the type of the class (used for the self parameter)
     *   - traitRef: the trait that defines the method
     * @returns: the prototype of the method
     * @throws:
     *   - &ErrorMsg: if the validation fails
     */
    pub fn validateMethodPrototype (mut self, dmut context : &Validator, dmut sym : &FunctionSymbol, clRef : &ClassRefType, noValue : bool = false)-> &MethodPrototypeValue
        throws ErrorMsg
    {
        let ret = {
            context:.pushReferent (alias sym);
            context:.enterForeign (isFnBody-> false, clContext-> clRef);

            self:.validateMethod (alias context, alias sym, sym.getContent (), clRef, fromTrait-> EMPTY_SYMBOL, validateBody-> false, noValue-> noValue)
        } exit {
            context:.exitForeign ();
            context:.popReferent ();
        } catch {
            err : &ErrorMsg => {
                throw copy ErrorMsg::fatal (sym.getLoc (), format (ValidateErrorMessage::VALIDATING_SYMBOL, sym.getPath ().toStr ()),
                                            notes-> copy [err]);
            }
        };

        ret
    }

    /**
     * Validate the prototype of a method that was declared as a template in a class
     * @params:
     *    - context: the context of the validation
     *    - sym: the template symbol (used for context references only)
     *    - func: the function declaration defining the prototype
     *    - clRef: the class type that declared the method
     *    - rewriter: the rewriter defined by the template specialization solving
     * @returns:  A method prototype
     * @throws:
     *    - &ErrorMsg: if the validation of the prototype fails
     * */
    pub fn validateMethodPrototypeFromTemplate (mut self, dmut context : &Validator, dmut sym : &Symbol, func : &FunctionDecl, clRef : &ClassRefType, rewriter : TemplateRewriter)-> &MethodPrototypeValue
        throws ErrorMsg
    {
        context:.pushReferent (alias sym);
        context:.enterForeign (isFnBody-> false, clContext-> clRef);

        let ret = {
            let throwers = self.validateThrowers (alias context, func.getThrowerLoc (), func.getThrowers ());
            self.verifyUndefAttributes (func.getAttributes ());

            let (retType, selfParam, parameters) = {
                context:.enterBlock ();
                let selfParam = self.validateSelfParamDecl (func.getFunctionProto ().getParameters()[0], clRef);
                context:.insertLocal (selfParam.getLoc (), selfParam.getLoc ().str, selfParam, canShadow-> true);

                let (retType, parameters) = self:.validatePrototype (alias context, sym, func.getFunctionProto (), forMethod-> true);
                (retType, selfParam, parameters)
            } exit {
                {
                    context:.quitBlock (warnUnused-> false);
                } catch {
                    _ => panic;
                }
            }

            copy MethodPrototypeValue (sym.getLoc (), sym, parameters, retType, throwers, clRef, trRef-> EMPTY_SYMBOL, isMutable-> selfParam.getType ().isMutable (),
                                       isEmpty-> func.getBody () of EmptyExpression, isOver-> false, isFinal-> true, attributes-> func.getAttributes (), fromTemplate-> rewriter?)
        } exit {
            context:.exitForeign ();
            context:.popReferent ();
        } catch {
            err : &ErrorMsg => {
                throw copy ErrorMsg::fatal (sym.getLoc (), format (ValidateErrorMessage::VALIDATING_SYMBOL, sym.getPath ().toStr ()),
                                            notes-> copy [err]);
            }
        };


        ret
    }

    /**
     * Validate a dtor prototype defined a class
     * @params:
     *    - context: the context of the validation
     *    - sym: the dtor to validate
     *    - clRef: the class defining the dtor
     *    - ancDtor: the prototype of the ancestor dtor (can be empty, aka UnitValue)
     * @throws:
     *     - &ErrorMsg: if there is an error in the validation
     * @returns: the prototype of the destructor
     */
    pub fn validateDtorPrototype (mut self, dmut context : &Validator, dmut sym : &DestructorSymbol, clRef : &ClassRefType, ancDtor : &Value)-> &DtorPrototypeValue
        throws ErrorMsg
    {
        let ret = {
            context:.pushReferent (alias sym);
            context:.enterForeign (isFnBody-> false, clContext-> clRef);

            self:.validateDestructor (alias context, alias sym, clRef, validateBody-> false, ancDtor-> ancDtor)
        } exit {
            context:.exitForeign ();
            context:.popReferent ();
        } catch {
            err : &ErrorMsg => {
                throw copy ErrorMsg::fatal (sym.getLoc (), format (ValidateErrorMessage::VALIDATING_SYMBOL, sym.getPath ().toStr ()),
                                            notes-> copy [err]);
            }
        };

        ret
    }

    
    /*!
     * ================================================================================
     * ================================================================================
     * =========================           FUNCTION           =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a normal function
     * @todo: this function is way too long, and way too close to validateMethod and validateConstructor. A refactorization would be great
     * @params: 
     *    - context: the context of the validation
     *    - sym: the symbol to validate
     * @returns: the prototype of the function
     */        
    fn validateFunction (mut self, dmut context : &Validator, dmut sym : &FunctionSymbol, validateBody : bool = true)-> &PrototypeValue
        throws ErrorMsg
    {
        let func = sym.getContent ();
        let mut errors : [&ErrorMsg] = [];
        let throwers = self.validateThrowers (alias context, func.getThrowerLoc (), func.getThrowers ());
        self.verifyUndefAttributes (func.getAttributes ());

        let (retType, parameters, body) = {
            context:.enterBlock ();
            let (retType, parameters) = self:.validatePrototype (alias context, sym, func.getFunctionProto ());
            if (func.getLoc ().str == Keys::MAIN && validateBody) {
                self.verifyMainPrototype (alias context, func.getLoc (), parameters, retType);
            } 

            let body = if (validateBody) {
                context:.enterFunctionBody ();
                let mut unsafeLoc = self.getUnsafeLoc (func.getAttributes ());
                let force = if (unsafeLoc.isEof () && sym.isUnsafe ()) {
                    unsafeLoc = func.getLoc (); // extern C function are unsafe without attributes
                    true
                } else {
                    false
                };

                self.validateFunctionBody (alias context, func.getLoc (), sym.getPath (), func.getBody (), retType, throwers, unsafeLoc, forceUnsafe-> force)
            } else {
                UNIT_VALUE
            }
            
            (retType, parameters, body)
        } catch {
            err : &ErrorMsg => {
                errors ~= [err];
                (NONE_TYPE, [], UNIT_VALUE)
            }
        } exit {
            {
                context:.quitBlock (warnUnused-> (errors.len == 0us && validateBody));
            } catch {
                err : &ErrorMsg => { errors ~= [err]; }
            }
        }

        if (errors.len != 0us) throw copy ErrorMsg::list (errors);
        if (validateBody && func.getBody () !of EmptyExpression) {
            let frame = copy FrameGenerator (func.getLoc (), sym.getPath (), parameters, retType, body, FrameKind::FUNC,
                                             externLang-> sym.getExternalLanguage (), isWeak-> sym.isWeak (), templateMapper-> sym.getTemplateMapper ());

            context:.insertGenerator (alias sym, frame);
        }

        let gen = match sym.getTemplateMapper () {
            Ok (map) => {
                copy PrototypeValue (sym.getLoc (), sym, parameters, retType, throwers, fromTemplate-> TemplateRewriter (map)?, attributes-> func.getAttributes ())
            }
            _ => {
                copy PrototypeValue (sym.getLoc (), sym, parameters, retType, throwers, attributes-> func.getAttributes ())
            }
        };

        if (func.getLoc ().str == Keys::MAIN && gen.isInline ()) {
            throw copy ErrorMsg::fatal (gen.getInlineLoc (), ValidateErrorMessage::MAIN_INLINE);
        }

        if (validateBody) { // If not validate body the prototype might be uncomplete
            self.verifyFunctionCollision (sym, func.getLoc ().str, gen);
            sym:.setFrameProto (gen, body);
        }

        gen
    }

    /**
     * Validate the body of a function
     * @params: 
     *     - context: the context of the validation
     *     - loc: the location of the function
     *     - name: the name of the function
     *     - body: the body of the function
     *     - throwers: the list of throwers
     * @returns: 
     *    - errors: the list of errors 
     *    - .0: the validated value of the body
     *    - .1: true iif the value is not a returner
     */
    fn validateFunctionBody (self, dmut context : &Validator, loc : &Word, name : &SymbolPath, body : &Expression, retType : &Type, throwers : [(&Word, &Type)], unsafeLoc : &Word, forceUnsafe : bool = false, preThrowing : [(&Word, &Type)] = [])-> &Value
        throws ErrorMsg
    {
        match body {
            EmptyExpression () => {
                context:.clearLocalScope ();
                copy UnitValue (loc-> loc)
            }
            _ => {
                if (!unsafeLoc.isEof ()) context:.enterUnsafeContext (unsafeLoc);
                logging::info ("Validate function %", name);

                context:.setFunctionReturn (retType);
                let mut bodyValue = context:.validateValue (body);
                let need = if (!bodyValue.isReturner ()) {
                    if (retType.getLoc ().isEof ()) {
                        bodyValue = context:.verifyCompatibleTypeWithValue (bodyValue.getLoc (), retType, bodyValue, byReference-> false);
                        context.verifyMemoryOwner (bodyValue.getLoc (), retType, bodyValue, byReference-> false);
                    } else {
                        bodyValue = context:.verifyCompatibleTypeWithValue (retType.getLoc (), retType, bodyValue, byReference-> false);
                        context.verifyMemoryOwner (retType.getLoc (), retType, bodyValue, byReference-> false);
                    }
                    
                    match retType {
                        VoidType () => { false }
                        _ => { true }
                    }
                } else { false };
                
                self.verifyThrowing (alias context, loc, name, bodyValue.getThrowers () ~ preThrowing, throwers);

                if (!unsafeLoc.isEof ()) context:.exitUnsafeContext (force-> forceUnsafe);

                if (need) {
                    cast!{&Value} (copy ReturnValue (bodyValue.getLoc (), bodyValue))
                } else {
                    bodyValue
                }
            }
        }
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================           METHODS            =========================
     * ================================================================================
     * ================================================================================
     */


    /**
     * Validate a method
     * @todo: this function is way too long, and way too close to validateFunction and validateConstructor. A refactorization would be great
     * @params:
     *    - context: the context of the validation
     *    - sym: the symbol to validate
     *    - clRef: the type of the class defining the method
     *    - fromTrait: the symbol of the trait if this method is defined inside a trait, (EmptySymbol otherwise)
     *    - validateBody: true iif the body must be validated
     * @returns: the prototype of the method
     * @throws:
     *    - &ErrorMsg: if the validation failed
     */
    fn validateMethod (mut self, dmut context : &Validator, dmut sym : &FunctionSymbol, func : &FunctionDecl, clRef : &ClassRefType, fromTrait : &Symbol, validateBody : bool = false, noValue : bool = false)-> &MethodPrototypeValue
        throws ErrorMsg
    {
        let mut errors : [&ErrorMsg] = [];
        let throwers = self.validateThrowers (alias context, func.getThrowerLoc (), func.getThrowers ());
        self.verifyUndefAttributesMethod (func.getAttributes ());

        let (retType, selfParam, parameters, body) = {
            context:.enterBlock ();
            let selfParam = self.validateSelfParamDecl (func.getFunctionProto ().getParameters()[0], clRef);
            context:.insertLocal (selfParam.getLoc (), selfParam.getLoc ().str, selfParam, canShadow-> true);

            let (retType, parameters) = self:.validatePrototype (alias context, sym, func.getFunctionProto (), forMethod-> true, noValue-> noValue);
            let fieldLoc = self.getFieldLoc (func.getAttributes ());
            if (!fieldLoc.isEof () && parameters.len > 1) {
                throw copy ErrorMsg::fatal (func.getLoc (), ValidateErrorMessage::FIELD_METHOD_PARAMS,
                                            notes-> copy [copy ErrorMsg::note (fieldLoc, ""s8)]);
            }

            if (!fieldLoc.isEof () && (retType of VoidType && parameters.len == 0)) {
                throw copy ErrorMsg::fatal (func.getLoc (), ValidateErrorMessage::FIELD_METHOD_ACCESS_NO_RETURN,
                                            notes-> copy [copy ErrorMsg::note (fieldLoc, ""s8)]);
            }

            if (!fieldLoc.isEof () && (retType !of VoidType && parameters.len == 1)) {
                throw copy ErrorMsg::fatal (func.getLoc (), ValidateErrorMessage::FIELD_METHOD_ASSIGN_WITH_RETURN,
                                            notes-> copy [copy ErrorMsg::note (fieldLoc, ""s8)]);
            }

            if (!fieldLoc.isEof () && (!selfParam.getType ().isMutable () && parameters.len == 1)) {
                throw copy ErrorMsg::fatal (func.getLoc (), ValidateErrorMessage::FIELD_METHOD_ASSIGN_CONST,
                                            notes-> copy [copy ErrorMsg::note (fieldLoc, ""s8)]);
            }



            let body = if (validateBody) {
                context:.enterFunctionBody ();
                let mut unsafeLoc = self.getUnsafeLoc (func.getAttributes ());
                if (unsafeLoc.isEof () && sym.isUnsafe ()) { unsafeLoc = func.getLoc (); } // extern C function are unsafe without attributes

                self.validateFunctionBody (alias context, func.getLoc (), sym.getPath (), func.getBody (), retType, throwers, unsafeLoc)
            } else {
                UNIT_VALUE
            }

            (retType, selfParam, parameters, body)
        } catch {
            err : &ErrorMsg => {
                errors ~= [err];
                (NONE_TYPE, UNIT_VALUE, cast!{[&ProtoVarValue]} ([]), UNIT_VALUE)
            }
        } exit {
            {
                context:.quitBlock (warnUnused-> (errors.len == 0us && validateBody));
            } catch {
                err : &ErrorMsg => { errors ~= [err]; }
            }
        }

        if (errors.len != 0us) throw copy ErrorMsg::list (errors);
        if (validateBody && func.getBody () !of EmptyExpression) {
            let frame = copy FrameGenerator (func.getLoc (), sym.getPath (), copy [selfParam] ~ parameters, retType, body, FrameKind::METHOD,
                                             externLang-> sym.getExternalLanguage (), isWeak-> (sym.isWeak () || clRef.getSymbol ().isWeak ()),
                                             templateMapper-> sym.getTemplateMapper ());

            context:.insertGenerator (alias sym, frame);
        }


        let gen = match sym.getTemplateMapper () {
            Ok (map) => {
                copy MethodPrototypeValue (sym.getLoc (), sym, parameters, retType, throwers, clRef, trRef-> fromTrait, isMutable-> selfParam.getType ().isMutable (),
                                           isEmpty-> func.getBody () of EmptyExpression, isOver-> sym.isOver (), isFinal-> sym.isFinal (), attributes-> func.getAttributes (),
                                           fromTemplate-> TemplateRewriter (map)?)
            }
            _ => {
                copy MethodPrototypeValue (sym.getLoc (), sym, parameters, retType, throwers, clRef, trRef-> fromTrait, isMutable-> selfParam.getType ().isMutable (),
                                           isEmpty-> func.getBody () of EmptyExpression, isOver-> sym.isOver (), isFinal-> sym.isFinal (), attributes-> func.getAttributes ())
            }
        };

        if (gen.isInline () && (!sym.isFinal () || sym.isOver ())) {
            throw copy ErrorMsg::fatal (gen.getInlineLoc (), format (ValidateErrorMessage::INLINE_VIRTUAL_METHOD, gen));
        }

        gen
    }
    
    /*!
     * ================================================================================
     * ================================================================================
     * =========================            DTORS             =========================
     * ================================================================================
     * ================================================================================
     */

    fn validateDestructor (mut self, dmut context : &Validator, dmut sym : &DestructorSymbol, clRef : &ClassRefType, ancDtor : &Value, validateBody : bool = false)-> &DtorPrototypeValue
        throws ErrorMsg
    {
        let func = sym.getContent ();
        let mut errors : [&ErrorMsg] = [];
        self.verifyUndefAttributesDtor (func.getAttributes ());

        let (retType, selfParam, parameters, body) = {            
            context:.enterBlock ();
            let selfParam = self.validateSelfParamDecl (func.getFunctionProto ().getParameters()[0], clRef);
            if (!selfParam.isMutable ()) {
                throw copy ErrorMsg::fatal (selfParam.getLoc (), format (ValidateErrorMessage::DTOR_SELF_NOT_MUT));
            }
            
            context:.insertLocal (selfParam.getLoc (), selfParam.getLoc ().str, selfParam, canShadow-> true);
            
            let (retType, parameters) = self:.validatePrototype (alias context, sym, func.getFunctionProto (), forMethod-> true);
            let body = if (validateBody) {
                context:.enterFunctionBody ();
                self.validateDtorBody (alias context, func, alias sym, clRef, ancDtor, retType, selfParam)
            } else {
                UNIT_VALUE
            };

            (retType, selfParam, parameters, body)
        } catch {           
            err : &ErrorMsg => {
                errors ~= [err];
                (NONE_TYPE, UNIT_VALUE, cast!{[&ProtoVarValue]} ([]), UNIT_VALUE)
            }
        } exit {
            {
                context:.quitBlock (warnUnused-> (errors.len == 0us && validateBody));
            } catch {
                err : &ErrorMsg => { errors ~= [err]; }
            }
        }

        if (errors.len != 0us) throw copy ErrorMsg::list (errors);
        if (validateBody && func.getBody () !of EmptyExpression) {
            let frame = copy FrameGenerator (func.getLoc (), sym.getPath (), copy [selfParam] ~ parameters, retType, body, FrameKind::DTOR,
                                             externLang-> sym.getExternalLanguage (), isWeak-> (sym.isWeak () || clRef.getSymbol ().isWeak ()),
                                             templateMapper-> sym.getTemplateMapper ());

            context:.insertGenerator (alias sym, frame);
        }


        copy DtorPrototypeValue (sym.getLoc (), sym, clRef)
    }

    /**
     * Finalize the body of the destructor
     * @params:
     *    - context: the context of the validation
     *    - func: the destructor to validate
     *    - sym: the symbol containing the declaration
     *    - clRef: the class ref containing the dtor
     * @returns: the body of the dtor
     * */
    fn validateDtorBody (self, dmut context : &Validator, func : &DestructorDecl, dmut sym : &DestructorSymbol, clRef : &ClassRefType, ancDtor : &Value, retType : &Type, selfParam : &Value)-> &Value
        throws ErrorMsg
    {
        logging::info ("Validate __dtor %", sym.getPath ());
        let innerBl = self.validateFunctionBody (alias context, func.getLoc (), sym.getPath (), func.getBody (), retType, [], EOF_WORD); // dtor can't be unsafe
        let retBl = match ancDtor {
            meth : &DtorPrototypeValue => {
                let selfValue = copy VarRefValue (selfParam.getLoc (), selfParam.getLoc (), selfParam.getType (), selfParam.getUniqId (), isSelf-> true, isReference-> clRef.isStruct ());
                let methDg = copy MethodDelegateValue (func.getLoc (), meth, closure-> selfValue, direct-> true, vtableIndex-> 0us, isStruct-> clRef.isStruct ());
                let call = copy MethodCallValue (func.getLoc (), copy VoidType (func.getLoc ()), methDg, []);
                copy BlockValue (func.getLoc (), copy VoidType (func.getLoc ()), copy [innerBl, call])
            }
            _ => { innerBl }
        }

        let finBl = if (clRef.getSymbol ().isEntity ()) {
            let selfValue = copy VarRefValue (selfParam.getLoc (), selfParam.getLoc (), selfParam.getType (), selfParam.getUniqId (), isSelf-> true, isReference-> clRef.isStruct ());
            match self.validateMovableFieldDtorCall (alias context, selfValue, clRef) {
                moveBl : &BlockValue => {
                    copy BlockValue (func.getLoc (), copy VoidType (func.getLoc ()), copy [retBl, moveBl])
                }
                _ => { retBl }
            }
        } else {
            retBl
        };

        finBl
    }

    /**
     * Validate the call to the dtor of the movable fields of the entity
     * @params:
     *    - context: the context of the validation
     *    - selfParam: the self parameter value
     *    - clRef: the type being destroyed
     * */
    fn validateMovableFieldDtorCall (self, dmut context : &Validator, selfParam : &Value, clRef : &ClassRefType)-> &Value
        throws ErrorMsg
    {
        context;
        let loc = selfParam.getLoc ();
        let mut calls : [&Value] = [];

        for v in clRef.getLocalFields () {
            if (v.getVarType ().isMovable ()) match v.getVarType () {
                c : &ClassPtrType => {
                    if let dt : &DtorPrototypeValue = c.getInner ().getDestructor () {
                        let fieldAccess = copy StructFieldAccessValue (loc, c, selfParam, v.getLoc ().str);
                        let methDg = copy MethodDelegateValue (loc,
                                                               dt,
                                                               closure-> fieldAccess, direct-> true, vtableIndex-> 0us, isStruct-> true);

                        let boolType = copy BoolType (loc);
                        let lSet = copy StructFieldAccessValue (loc, boolType, fieldAccess, ClassKeys::SET);
                        let call = copy MethodCallValue (loc, VOID_TYPE, methDg, []);
                        let postCall = copy AffectValue (loc, VOID_TYPE, lSet, copy BoolValue (loc, false));
                        let instrs = copy BlockValue (loc, VOID_TYPE, copy [call, postCall, UNIT_VALUE], isSet-> true);
                        // if field.#_set { __dtor (field); field.#_set = 0; }

                        let cond = copy ConditionalValue (loc, VOID_TYPE, lSet, instrs, UNIT_VALUE);
                        calls ~= [cond];
                    }
                }
            }
        }

        if (calls.len == 0us) return UNIT_VALUE;
        copy BlockValue (selfParam.getLoc (), VOID_TYPE, calls)
    }
    
    /*!
     * ================================================================================
     * ================================================================================
     * =========================            CTORS             =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a constructor
     * @todo: this function is way too long, and way too close to validateFunction and validateMethod. A refactorization would be great
     * @params: 
     *    - context: the context of the validation
     *    - sym: the symbol to validate
     *    - clRef: the class type for self
     *    - validateBody: validate the body of the constructor (and field/ancestor constructions)
     * @returns: the prototype of the ctor
     * @throws:
     *    - &ErrorMsg: if the validation failed
     */
    fn validateConstructor (mut self, dmut context : &Validator, dmut sym : &ConstructorSymbol, clRef : &ClassRefType, validateBody : bool = false, noValue : bool = false)-> &CtorPrototypeValue
        throws ErrorMsg
    {
        let func = sym.getContent ();
        let mut errors : [&ErrorMsg] = [];
        let throwers = self.validateThrowers (alias context, func.getThrowerLoc (), func.getThrowers ());
        self.verifyUndefAttributes (func.getAttributes ());

        let (selfParam, parameters, body, hasRedirect) = {
            context:.enterBlock ();
            // We need a class ptr for the self parameter
            let clPtr = clRef.createInstance (true, true);

            let selfParam = copy ProtoVarValue (copy Word (Keys::SELF, func.getLoc ()), clPtr, UNIT_VALUE, true, isSelf-> true, isReference-> clRef.isStruct ());   // Self parameters (first hidden param)
            let (_, parameters) = self:.validatePrototype (alias context, sym, func.getFunctionProtoDecl (), forMethod-> false, noValue-> noValue); // unlike methods self is not written in the prototype, so we need to validate all parameters

            let (body, hasRedirect) = if (validateBody) { // We validate the body
                self.validateCtorBody (alias context, sym, func, clPtr.getInner (), selfParam, throwers)
            } else { // we validate only the prototype
                (UNIT_VALUE, false)
            }

            (selfParam, parameters, body, hasRedirect) // don't add the self parameter in the prototype, we don't have it when calling the prototype
        } catch {
            err : &ErrorMsg => {
                errors ~= [err];
                (UNIT_VALUE, cast!{[&ProtoVarValue]} ([]), UNIT_VALUE, false)
            }
        } exit {
            {
                context:.quitBlock (warnUnused-> (errors.len == 0us && validateBody));
            } catch {
                err : &ErrorMsg => { errors ~= [err]; }
            }
        }

        if (errors.len != 0us) throw copy ErrorMsg::list (errors);
        if (validateBody && func.getBody () !of EmptyExpression) {
            if let selfV : &ProtoVarValue = selfParam {
                let frame = copy FrameGenerator (func.getLoc (), sym.getPath (), copy [selfV] ~ parameters, copy VoidType (sym.getLoc ()), body, FrameKind::CTOR,
                                                 isWeak-> (sym.isWeak () || clRef.getSymbol ().isWeak ()),
                                                 templateMapper-> sym.getTemplateMapper ());

                context:.insertGenerator (alias sym, frame);
            } else panic;
        }

        let gen = match sym.getTemplateMapper () {
            Ok (map) => {
                copy CtorPrototypeValue (sym.getLoc (), sym, parameters, throwers, clRef, rename-> func.getRename ().str,
                                         attributes-> func.getAttributes (), fromTemplate-> TemplateRewriter (map)?)
            }
            _ => {
                copy CtorPrototypeValue (sym.getLoc (), sym, parameters, throwers, clRef, rename-> func.getRename ().str,
                                         attributes-> func.getAttributes ())
            }
        }

        if (validateBody && hasRedirect) {
            sym:.setFrameProto (gen, body, hasRedirect);
            let mut entered : [&Symbol => mut ()] = copy [];
            context.verifyInfiniteCtorRecursion (gen, ref entered);
        }

        gen
    }

    /**
     * Validation of the body of the constructor
     * This function is different from validateFunctionBody, because it also validates the pre constructor
     * @params: 
     *    - context: the context of the validation
     *    - sym: the symbol being validated
     *    - ctor: the ctor whose body is being validated
     *    - clRef: the type of the class containing the ctor
     *    - selfParam: the protovarvalue of the hidden self parameter
     * @returns: the body of the ctor
     * @throws:
     *    - &ErrorMsg: if there was an error in the validation     
     */
    fn validateCtorBody (self, dmut context : &Validator, sym : &ConstructorSymbol, ctor : &ConstructorDecl, clRef : &ClassRefType, selfParam : &Value, throwers : [(&Word, &Type)])-> (&Value, bool)
        throws ErrorMsg
    {
        logging::info ("Validate ctor %", sym.getPath ());

        //
        //
        // insert self in the scope, alongside with parameters (its an hidden param)
        context:.insertLocal (selfParam.getLoc (), selfParam.getLoc ().str, selfParam, canShadow-> true);
        context:.getLocal (selfParam.getLoc (), selfParam.getLoc ().str, canBeInClosure-> false);

        // Reference to the self hidden param
        let selfValue = copy VarRefValue (selfParam.getLoc (), selfParam.getLoc (), selfParam.getType (), selfParam.getUniqId (), isSelf-> true);
        
        // Validate the pre construction of the constructor (construction of fields, and ancestor)
        let (preConstruct, hasRedirect) = self.validatePreConstructor (alias context, ctor, clRef, selfValue);


        // From this point, return is allowed
        context:.enterFunctionBody ();

        let mut unsafeLoc = self.getUnsafeLoc (ctor.getAttributes ());
        if (unsafeLoc.isEof () && sym.isUnsafe ()) { unsafeLoc = ctor.getLoc (); } // extern C function are unsafe without attributes

        // Validate the body of the constructor (return void type)
        let body = self.validateFunctionBody (alias context,
                                              ctor.getLoc (),
                                              sym.getPath (),
                                              ctor.getBody (),
                                              copy VoidType (sym.getLoc ()),
                                              preThrowing-> preConstruct.getThrowers (),
                                              throwers,
                                              unsafeLoc);

        // the body contains the pre construction, and the proper body
        let finalBody = match preConstruct {
            UnitValue () => { copy [body] }
            _ => { copy [preConstruct, body] }
        };

        (copy BlockValue (ctor.getLoc (), VOID_TYPE, finalBody), hasRedirect)
    }       

    /**
     * Validate the pre construction of a constructor
     * @params: 
     *    - context: the context of the validation
     *    - sym: the symbol being validated
     *    - func: the declaration to validate
     *    - clRef: the type of self
     *    - selfParam: the self parameter
     * @returns: the value containing the constructions statements
     * @throws: 
     *    - &ErrorMsg: if there was an error in the validation
     */
    fn validatePreConstructor (self, dmut context : &Validator, func : &ConstructorDecl, clRef : &ClassRefType, selfParam : &Value)-> (&Value, bool)
        throws ErrorMsg
    {
        if (func.getExplicitCstrsCall () == Keys::SELF) { // There is a redirection of construction
            return (self.validateRedirectCtor (alias context, func, clRef, selfParam), true);
        }

        let mut block : [&Value] = []; // list of instructions
        let ancCall = self.validateAncestorCtorCall (alias context, func, clRef, selfParam);
        match ancCall {
            UnitValue () => {} // Don't add an empty value
            _ =>  {
                block ~= [ancCall]; // There is an ancestor, and its ctor is called
            }
        }        

        let fieldCtor = self.validateFieldCtors (alias context, func, clRef, selfParam);
        match fieldCtor {
            UnitValue () => {} // Don't add an empty value
            _ => {
                block ~= [fieldCtor]; // there are field constructions
            }
        }

        let finVal = if (block.len != 0us) {
            // We create the block of instruction, containing super call, and field ctors
            copy BlockValue (func.getLoc (), VOID_TYPE, block)
        } else {
            UNIT_VALUE
        };

        (finVal, false)
    }

    /**
     * Validate the call of a redirect constructor
     * @params: 
     *    - context: the context of the validation
     *    - sym: the symbol being validated
     *    - func: the declaration of the constructor
     *    - clRef: the type of the class that is being validated
     * @returns: the instruction calling the redirect constructor
     * @throws: 
     *    - &ErrorMsg: if there is an error in the validation
     */
    fn validateRedirectCtor (self, dmut context : &Validator, func : &ConstructorDecl, clRef : &ClassRefType, selfParam : &Value)-> &Value
        throws ErrorMsg
    {
        let mut errors : [&ErrorMsg] = [];
        let mut rights : [&Value] = [];

        let selfLoc = func.getExplicitCstrsCall ();
        for v in func.getSuperParams () { // Validate the parameters that are passed to the redirect constructor
            rights ~= [context:.validateValue (v)];
        }
        
        let ret = {
            // Ignore the current constructor, it cannot be called by redirection
            let ctors = self.createCtorDelegate (alias context, selfLoc, clRef, selfParam, renameLoc-> func.getExplicitSuperName (), templateParams-> func.getSuperTemplateParams ());
            context:.getCallOpValidator ().validate (alias context, selfLoc, ctors, rights, inCopy-> true)
        } catch { 
            err : &ErrorMsg => { // None succeeded (TODO print private candidates)
                errors ~= [copy ErrorMsg::fatal (selfLoc, format (ValidateErrorMessage::UNDEFINED_REDIRECT_CALL_CTOR, rights),
                                                 notes-> copy [err])];
                UNIT_VALUE
            }
        }

        for it in func.getFieldConstructors () {
            errors ~= [copy ErrorMsg::fatal (it._0, format (ValidateErrorMessage::ALREADY_INIT_BY_CTOR_REDIRECT, it._0.str),
                                             notes-> copy [copy ErrorMsg::note (selfLoc, ""s8)])];
        }

        if (errors.len != 0us) throw copy ErrorMsg::list (errors);
        ret
    }
    
    /**
     * Validate the call of the ancestor constructor (if there is an ancestor)
     * @params: 
     *    - context: the context of the validation
     *    - func: the declaration of the constructor
     *    - clRef: the type of the class that is being validated
     *    - selfParam: the self parameters
     * @returns: the instruction calling the ancestor constructor (or Unit, if there is not call)
     * @throws: 
     *    - &ErrorMsg: if there is an error in the validation
     */
    fn validateAncestorCtorCall (self, dmut context : &Validator, func : &ConstructorDecl, clRef : &ClassRefType, selfParam : &Value)-> &Value
        throws ErrorMsg
    {
        match clRef.getAncestor () {
            Ok (ancestor) => {
                // If the super call is implicit, we need a valid location
                let superLoc = if (func.getExplicitCstrsCall ().isEof ()) { func.getLoc () } else { func.getExplicitCstrsCall () };
                let mut rights : [&Value] = copy [context:.validateValue (v) for v in func.getSuperParams ()];

                {
                    let ctors = self.createCtorDelegate (alias context, superLoc, ancestor, selfParam, renameLoc-> func.getExplicitSuperName (), templateParams-> func.getSuperTemplateParams ());
                    return context:.getCallOpValidator ().validate (alias context, superLoc, ctors, rights, inCopy-> true); // Call the ctors with the parameters and return the one that succeeded
                } catch { 
                    err : &ErrorMsg => { // None succeeded (TODO print private candidates)
                        throw copy ErrorMsg::fatal (superLoc, format (ValidateErrorMessage::UNDEFINED_SUPER_CALL_CTOR, rights),
                                                    notes-> copy [err]);
                    }
                }
            }
            _ => {
                // Class does not have any ancestor, so it can't be called
                if (func.getExplicitCstrsCall () == Keys::SUPER) {
                    throw copy ErrorMsg::fatal (func.getExplicitCstrsCall (), format (ValidateErrorMessage::NO_SUPER_CLASS, clRef));
                }
                
                return UNIT_VALUE;
            }            
        }        
    }

    /**
     * Create a mult sym containing all the constructor of the class with the given instance
     * @params: 
     *    - loc: the location of the call
     *    - clRef: the class whose constructors are used
     *    - selfParam: the instance for self
     *    - withPrivate: include PRV_PARENT constructors ?
     *    - prettyStr: the name of the call
     * @returns: a MultSymValue with all the available ctors (can be of len == 0us)
     */
    fn createCtorDelegate (self, dmut context : &Validator, loc : &Word, clRef : &ClassRefType, selfParam : &Value, renameLoc : &Word, templateParams : &Expression)-> &Value
        throws ErrorMsg
    {
        let rename = if (renameLoc.isEof ()) { "" } else { renameLoc.str };
        let ctors = context:.getSubTypeValidator ().validateClassCtors (alias context, loc, clRef, name-> rename, selfParam-> selfParam, fromSubType-> true);

        match templateParams {
            EmptyExpression () => { ctors }
            tmp : &TemplateCallExpr => {
                let mt = match ctors {
                    m : &MultSymValue => { m }
                    x : _ => { copy MultSymValue (x.getLoc (), copy [x], prettyStr-> format ("%", tmp)) }
                };

                let list = context:.validateTemplateArgumentList (tmp.getRights ());
                context:.getValueValidator ().validateTemplateCallMultSym (alias context, loc, mt, list)
            }
            _ => panic;
        }
    }
    
    /**
     * Validate the field constructors
     * @params: 
     *    - context: the context of the validation
     *    - func: the declaration of the constructor
     *    - clRef: the type of the class that is being validated
     *    - selfParam: the parameter self              
     * @returns: the instructions affecting values to the fields
     * @throws: 
     *     - &ErrorMsg: if there is an error in the validation
     */
    fn validateFieldCtors (self, dmut context : &Validator, func : &ConstructorDecl, clRef : &ClassRefType, selfParam : &Value)-> &Value
        throws ErrorMsg
    {
        let mut instrs : [&Value] = [];
        let mut errors : [&ErrorMsg] = [];
        context:.enterFieldConstruction (clRef); // Enter this context modifies the behavior of Dot operator, by saying the uninitialized fields of type 'clRef' cannot be accessed
        {
            let mut willBeValidated : [[c8] => mut ()] = copy [];
            for it in func.getFieldConstructors () { // We need a list of fields that will be validated by pre construction (ref 1)
                willBeValidated [it._0.str] = ();
            }

            for v in clRef.getLocalFields () {  // Validate all the fields that were not validated by pre construction
                {
                    if (v.getLoc ().str !in willBeValidated) { // (cite 1), so we can initialize the fields that are not pre constructed first
                        if (v.getValue () of UnitValue) {
                            errors ~= [copy ErrorMsg::fatal (v.getLoc (), format (ValidateErrorMessage::UNINIT_FIELD, v.getLoc ().str))];
                        } else {
                            let field = context:.getBinOpValidator ().validateClassFieldAccess (alias context, v.getLoc (), selfParam, copy VarExpr (v.getLoc ()), clRef, true, true, verifyValidation-> false, withAncestor-> false);
                            instrs ~= [copy AffectValue (v.getLoc (), field.getType (), field, v.getValue ())];
                            context:.setFieldValidated (v.getLoc ().str, v.getLoc ());
                        }
                    }
                } catch {
                    err : &ErrorMsg => { errors ~= [err]; }
                }
            }

            if (errors.len != 0us) throw copy ErrorMsg::list (errors);
            for it in func.getFieldConstructors () { // Validate all the fields that are written in the pre construction
                let name = it._0;
                if let Ok (w : &Word) = context.getFieldValidated ().content [name.str] {
                    let notes = copy [copy ErrorMsg::note (w, format (ValidateErrorMessage::HERE))];
                    errors ~= [copy ErrorMsg::fatal (name, format (ValidateErrorMessage::MULTIPLE_FIELD_INIT, name.str),
                                                     notes-> notes)];

                } else {
                    let field = context:.getBinOpValidator ().validateClassFieldAccess (alias context, name, selfParam, copy VarExpr (name), clRef, true, true, verifyValidation-> false, withAncestor-> false);
                    let value = context:.verifyCompatibleTypeWithValue (field.getLoc (), field.getType (), context:.validateValue (it._1), byReference-> false);
                    context.verifyMemoryOwner (field.getLoc (), field.getType (), value, byReference-> false);

                    instrs ~= [copy AffectValue (name, field.getType (), field, value)];
                    context:.setFieldValidated (name.str, name);
                }
            } catch {
                err : &ErrorMsg => { errors ~= [err]; }
            }
        } catch {
            err : &ErrorMsg => { errors ~= [err]; }
        }

        context:.quitFieldConstruction (); // We don't forget to quit the field validation, from that point all fields are accessible
        if (errors.len != 0us) throw copy ErrorMsg::list (errors);
        if (instrs.len != 0us) {
            // returns the list of constructions
            copy BlockValue (func.getLoc (), VOID_TYPE, instrs)
        } else { 
            UNIT_VALUE // No instrs, no need to open a block
        }
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================           THROWERS           =========================
     * ================================================================================
     * ================================================================================
     */
    
    /**
     * Validate the throwers a function
     * @params: 
     *    - context: the context of the validation
     *    - throwers: the list of throwers
     * @returns: 
     *    - errors: the list of errors that occurs in the validation
     *    - the list of throwers
     */
    fn validateThrowers (self, dmut context : &Validator, loc : &Word, throwers : [&Expression])-> [(&Word, &Type)]
        throws ErrorMsg
    {
        // No need to validate core::exception::Exception if there is no throws
        if (throwers.len == 0us) return [];

        let mut errors : [&ErrorMsg] = [];
        let mut rets : [(&Word, &Type)] = [];
        let exceptionType = context:.getExceptionType (loc-> loc);
        let innerExc = exceptionType.getInner ();

        for i in throwers {
            {
                let type = context:.validateType (i);
                match type {
                    cptr : &ClassRefType => {
                        if (context.isAncestor (exceptionType, cptr) || context.isDirectInstance (exceptionType, cptr)) {
                            rets ~= [(i.getLoc (), type)];
                        } else {
                            errors ~= [copy ErrorMsg::fatal (i.getLoc (), end-> exceptionType.getLoc (), format (ValidateErrorMessage::NOT_AN_EXCEPTION_CLASS, cptr, innerExc))];
                        }
                    }
                    cptr : &ClassPtrType => {
                        errors ~= [copy ErrorMsg::fatal (i.getLoc (), format (ValidateErrorMessage::CLASS_THROW_PTR, type))];
                        if (context.isAncestor (exceptionType, cptr) || context.isDirectInstance (exceptionType, cptr)) {
                            rets ~= [(i.getLoc (), type)];
                        } else {
                            errors ~= [copy ErrorMsg::fatal (i.getLoc (), end-> exceptionType.getLoc (), format (ValidateErrorMessage::NOT_AN_EXCEPTION_CLASS, cptr.getInner (), innerExc))];
                        }
                    }
                    _ => {                        
                        errors ~= [copy ErrorMsg::fatal (i.getLoc (), format (ValidateErrorMessage::NOT_A_CLASS, type))];
                    }
                }
            } catch {
                err : &ErrorMsg => { errors ~= [err]; }
            }
        }

        if (errors.len != 0us) {
            throw copy ErrorMsg::list (errors);
        }

        rets
    }

    /**
     * Verify that the declared throws and the actual thrown of the function are similar
     * @params: 
     *    - context: the context of the function
     *    - loc: the location of the definition of the function
     *    - name: the name of the function
     *    - thrown: the list of type that are thrown by the body
     *    - expected: the list of type that are declared in the prototype as throws
     * @returns: 
     *     - errors: the list of errors during the validation
     */
    fn verifyThrowing (self, dmut context : &Validator, loc : &Word, name : &SymbolPath, thrown : [(&Word, &Type)], expected : [(&Word, &Type)])
        throws ErrorMsg
    {
        let (notFound, unused) = self.listUnusedThrows (context, thrown, expected);
        let mut lst : [&Type] = [];
        let mut errors : [mut &ErrorMsg] = [];
        for i in notFound {
            let mut found = false;
            for index, j in lst {
                if i._1 == j {
                    found = true;
                    errors [index] = errors [index].withNote (copy [copy ErrorMsg::note (i._0, ""s8)]);
                    break;
                }
            }
            
            if (!found) {            
                errors ~= [copy ErrorMsg::fatal (loc, format (ValidateErrorMessage::THROWS_NOT_DECLARED, name.toStr (), i._1),
                                                notes-> copy [copy ErrorMsg::note (i._0, ""s8)])];
                lst ~= [i._1];
            }
        }

        for i in unused {
            errors ~= [copy ErrorMsg::fatal (loc, format (ValidateErrorMessage::THROWS_NOT_USED, name.toStr (), i._1),
                                             notes-> copy [copy ErrorMsg::note (i._0, ""s8)])];
        }

        if (errors.len != 0us) throw copy ErrorMsg::list (errors);
    }

    /**
     * List the throws that are unused, and not found
     * @params:
     *    - thrown: the list of exception thrown in the body of the function
     *    - expected: the list of exception declared in the prototype of the function
     * @returns:
     *    - .0: the list of exception thrown in the body but not declared
     *    - .1: the list of exception declared in the prototype but not found in the body
     */
    fn listUnusedThrows (self, context : &Validator, thrown : [(&Word, &Type)], expected : [(&Word, &Type)])-> ([(&Word, &Type)], [(&Word, &Type)])
        throws ErrorMsg
    {
        let dmut notFound : [(&Word, &Type)] = [];
        for i in thrown {
            let mut found = false;
            for j in expected  {
                if context.isDirectInstance (i._1, j._1) {
                    found = true;
                    break;
                } else if context.isAncestor (j._1, i._1) {
                    found = true;
                    break;
                }
            }

            if !found {
                notFound ~= [i];
            }
        }

        let dmut unused   : [(&Word, &Type)] = [];
        for i in expected {
            let mut found = false;
            for j in thrown {
                if (context.isDirectInstance (i._1, j._1)) {
                    found = true;
                    break;
                } else if (context.isAncestor (i._1, j._1)) {
                    found = true;
                    break;
                }
            }

            if !found {
                unused ~= [i];
            }
        }

        (notFound, unused)
    }
    
    /*!
     * ================================================================================
     * ================================================================================
     * =========================          PROTOTYPE           =========================
     * ================================================================================
     * ================================================================================
     */
    
    /**
     * Validate the prototype of a frame for generation
     * @params: 
     *   - context: the context of the validation
     *   - sym: the symbol being validated
     *   - proto: the prototype to validate
     *   - forMethod: true iif the validation is intended to create a method prototype
     * @returns:
     *    - .0: the return type of the prototype
     *    - .1: the list of parameters
     * @throws: &ErrorMsg, if there is a malformed parameter, or the return type is malformed
     */
    fn validatePrototype (mut self, dmut context : &Validator, sym : &Symbol, proto : &FunctionProtoDecl, forMethod : bool = false, noValue : bool = false)-> (&Type, [&ProtoVarValue])
        throws ErrorMsg
    {
        let mut parameters : [&ProtoVarValue] = [];
        let mut errors : [&ErrorMsg] = [];
        
        let noValue2 = noValue || (sym in self._validating);
        self._validating [sym] = ();
        {
            for i, param in proto.getParameters () {
                if (i != 0us || !forMethod) { // If we validate the prototype for a method, we don't validate the first parameter (which is always self)
                    let (isMutable, isReference, isLazy, type, value) = self.validateParamDecl (alias context, param, noValue-> noValue2);
                    let nbConsume = match param.getType () {
                        lst : &TypeListWrapperExpr => { cast!u32 (lst.getTypes ().len) }
                        _ => 1u32
                    };

                    let paramGen = copy ProtoVarValue (param.getLoc (), type, value, isMutable, isSelf-> false, isReference-> isReference, isLazy-> isLazy, nbConsume-> nbConsume);
                    parameters ~= [paramGen];
                    context:.insertLocal (paramGen.getLoc (), paramGen.getLoc ().str, paramGen);
                } catch {
                    err : &ErrorMsg => { errors ~= [err]; }
                }
            }
        }         
        self._validating:.remove (sym);

        let r : &Type = {
            let t = match proto.getRetType () {
                EmptyExpression () => { copy VoidType (proto.getLoc ()) }
                x : _ => { context:.validateType (x) }
            };

            context.verifyCompleteType (t.getLoc (), t, true);
            t
        } catch {
            err : &ErrorMsg => {
                errors ~= [err];
                throw copy ErrorMsg::list (errors);
            }
        };
        
        if (errors.len != 0us) throw copy ErrorMsg::list (errors);
        (r, parameters)
    }

    /**
     * Verify that the prototype is correct for the main function
     * @params: 
     *   - funcLoc: the location of the function definition
     *   - proto: the prototype of the frame 
     *   - parameters: the validated parameters of the function
     *   - retType: the return type of the function
     * @returns:
     *    - errors: add errors if the prototype is not valid
     */
    fn verifyMainPrototype (self, dmut context : &Validator, funcLoc : &Word, parameters : [&Value], retType : &Type)
        throws ErrorMsg
    {
        let mut errors : [&ErrorMsg] = [];
        if (parameters.len > 1us) {
            errors ~= [copy ErrorMsg::fatal (parameters [1us].getLoc (),
                                             ValidateErrorMessage::MAIN_FUNCTION_ONE_ARG)];
        } else if (parameters.len == 1us) {
            let test = copy SliceType (funcLoc, copy SliceType (funcLoc, copy CharType (funcLoc, size-> 8u16)));
            {
                context:.verifyCompatibleTypeWithValue (parameters [0].getLoc (), test, parameters [0], byReference-> false);
            } catch {
                err : &ErrorMsg => { errors ~= [err]; }
            }
        }

        match retType {
            VoidType () => {}
            _ => {
                let test = copy IntType (funcLoc, size-> 32u16, signed-> true);
                {
                    context.verifyCompatibleType (retType.getLoc (), test.getLoc (), test, retType);
                } catch {
                    err : &ErrorMsg => { errors ~= [err]; }
                }   
            }
        }

        if (errors.len != 0us) throw copy ErrorMsg::list (errors);
    }
    

    /**
     * Validate a parameter of a prototype
     * @params: 
     *    - context: the context of the validation
     *    - param: the parameter to validate
     *    - noValue: true iif we are recursevely validating and thus the value must not be validated (cf. Recursive default parameters)
     * @throws: &ErrorMsg, if there is an error
     * @returns: 
     *    - .0: true iif the parameter is declared mutable
     *    - .1: true iif the parameters is declared as a reference
     *    - .2: the type of the parameter
     *    - .3: the value of the parameter
     */
    fn validateParamDecl (self, dmut context : &Validator, vdecl : &VarDeclExpr, noValue : bool = false)-> (bool, bool, bool, &Type, &Value)
        throws ErrorMsg
    {
        let type = {
            context:.validateTypeForVarDecl (vdecl.getType (), vdecl, canBeRef-> true, canBeLazy-> true)
        } catch {
            err : &ErrorMsg => throw copy ErrorMsg::note (vdecl.getLoc (), ValidateErrorMessage::VALIDATING, notes-> copy [err]);
        };

        let value : &Value = if vdecl.getValue () !of EmptyExpression && !noValue {
            if (vdecl.getLoc () == Keys::UNDER) { // variable with a default value must have a name, otherwise it is impossible to change them
                throw copy ErrorMsg::fatal (vdecl.getLoc (), ValidateErrorMessage::DEFAULT_VAR_NO_NAME, notes-> copy [copy ErrorMsg::note (vdecl.getValue ().getLoc (), ""s8)]);
            }

            context:.validateValue (vdecl.getLoc (), vdecl.getValue (), type-> type)
        } else {
            UNIT_VALUE
        };

        if (type.isMutable () && !type.needExplicitAlias () && !type.isMovable () && !vdecl.isRef ()) {
            throw copy ErrorMsg::fatal (vdecl.getMutOrDmutLocation (), ValidateErrorMessage::MUTABLE_CONST_PARAM);
        }

        context.verifyNonVoidType (vdecl.getType ().getLoc (), type, true);
        return (type.isMutable (), vdecl.isRef (), vdecl.isLazy (), type, value);
    }

    /**
     * Validate a parameter of a template prototype
     * @params: 
     *    - context: the context of the validation
     *    - param: the parameter to validate
     *    - noValue: true iif we are recursevely validating and thus the value must not be validated (cf. Recursive default parameters)
     * @returns: 
     *    - .0: true iif the parameter is declared mutable
     *    - .1: the type of the parameter (can be none, if the validation failed)
     *    - .2: the value of the parameter (can be none if there is none, or the validation failed)
     */
    pub fn validateTemplateParamDecl (self, dmut context : &Validator, vdecl : &VarDeclExpr, noValue : bool = false)-> (bool, bool, bool, &Type, &Value) {
        let type = {
            context:.validateTypeForVarDecl (vdecl.getType (), vdecl, canBeRef-> true, canBeLazy-> true)
        } catch {
            _ => {
                NONE_TYPE
            }
        };

        let value : &Value = if vdecl.getValue () !of EmptyExpression && !noValue {
            {
                context:.validateValue (vdecl.getLoc (), vdecl.getValue (), type-> type)
            } catch {
                _ => {
                    // we put something, because we don't want the value to be set automatically
                    // It must be named, even if we don't know yet what it is it's default value, template specialization will tell
                    copy TemplateDefaultValue (vdecl.getValue ().getLoc ())
                }
            }
        } else {
            UNIT_VALUE
        };

        return (type.isMutable (), vdecl.isRef (), vdecl.isLazy (), type, value);
    }
    
    /**
     * Validate the self parameter of a method prototype
     * @params: 
     *   - param: the self parameter
     *   - clRef: the type of the class used
     * @returns: the protovar value
     */
    fn validateSelfParamDecl (self, vdecl : &VarDeclExpr, clRef : &ClassRefType)-> &ProtoVarValue
        throws ErrorMsg
    {
        let isMutable = vdecl.isMutable ();
        if (!vdecl.getLazyOrRefLocation ().isEof ()) { // ref,lazy self has no meaning
            throw copy ErrorMsg::fatal (vdecl.getLazyOrRefLocation (), format (ValidateErrorMessage::UNDEF_DECORATOR_TYPE, vdecl.getLazyOrRefLocation ().str));
        }

        if (vdecl.isDeeplyMutable ()) { // dmut self neither
            throw copy ErrorMsg::fatal (vdecl.getDeeplyMutableLocation (), format (ValidateErrorMessage::UNDEF_DECORATOR_TYPE, vdecl.getDeeplyMutableLocation ().str));
        }

        let clPtr = clRef.createInstance (isMutable, isMutable); // mut in that case means dmut
        copy ProtoVarValue (vdecl.getLoc (), clPtr, UNIT_VALUE, isMutable, isSelf-> true, isReference-> clRef.isStruct ()) // returns the protovar
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================           UNITTEST           =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a unit test
     * @params: 
     *   - context: the context of the validation
     *   - sym: the symbol to validate
     *   - uid: the uniq id of the unittest in the local module
     */
    pub fn validateTest (self, dmut context : &Validator, dmut sym : &Symbol, uid : usize)
        throws ErrorMsg
    {
        if let dmut unit : &UnitTestSymbol = alias sym {
            context:.pushReferent (alias unit);
            context:.enterForeign (isFnBody-> false);

            let mut hasErrors = false;
            let mut errors : [&ErrorMsg] = [];
            let body = {
                context:.enterBlock ();
                context:.enterFunctionBody ();
                context:.setFunctionReturn (copy VoidType (unit.getLoc ()));

                context:.validateValue (unit.getContent ().getBody ())
            } catch {
                err : &ErrorMsg => {
                    errors ~= [err];
                    UNIT_VALUE
                }
            } exit {
                {
                    context:.quitBlock (warnUnused-> !hasErrors);
                } catch {
                    err : &ErrorMsg => { errors ~= [err]; }
                }
            };

            context:.exitForeign ();
            context:.popReferent ();

            if (errors.len != 0us) throw copy ErrorMsg::list (errors);

            let path = unit.getPath ().push (format ("%", uid));
            let gen = copy UnitTestGenerator (unit.getLoc (), path, body);
            context:.insertGenerator (alias unit, gen);
        } else panic;
    }

    /*!
     * ================================================================================
     * ================================================================================
     * ==========================           COMMON           ==========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * @returns: the location of the unsafe attributes or EOF_WORD if none exist
     * */
    fn getUnsafeLoc (self, attributes : [AttributeWord])-> &Word {
        for it in attributes {
            if (it.attr == Attributes::UNSAFE) {
                return it.loc;
            }
        }

        EOF_WORD
    }

    /**
     * @returns: the location of the field attributes or EOF_WORD if none exist
     * */
    fn getFieldLoc (self, attributes : [AttributeWord])-> &Word {
        for it in attributes {
            if (it.attr == Attributes::FIELD) {
                return it.loc;
            }
        }

        EOF_WORD
    }

    /**
     * verify that attributes are applicable to a function
     * @params:
     *    - attributes: the list of attributes
     * */
    fn verifyUndefAttributes (self, attributes : [AttributeWord])
        throws ErrorMsg
    {
        let mut errors : [&ErrorMsg] = [];
        for it in attributes match it.attr {
            Attributes::UNSAFE => {}
            Attributes::INLINE => {}
            _ => { errors ~= [copy ErrorMsg::fatal (it.loc, format (ValidateErrorMessage::UNDEFINED_ATTRIBUTE, it.attr))]; }
        }

        if (errors.len != 0us) throw copy ErrorMsg::list (errors);
    }

    /**
     * verify that attributes are applicable to a dtor
     * @params:
     *    - attributes: the list of attributes
     * */
    fn verifyUndefAttributesDtor (self, attributes : [AttributeWord])
        throws ErrorMsg
    {
        let mut errors : [&ErrorMsg] = [];
        for it in attributes {
            errors ~= [copy ErrorMsg::fatal (it.loc, format (ValidateErrorMessage::UNDEFINED_ATTRIBUTE, it.attr))];
        }

        if (errors.len != 0us) throw copy ErrorMsg::list (errors);
    }

    /**
     * verify that attributes are applicable to a method
     * @params:
     *    - attributes: the list of attributes
     * */
    fn verifyUndefAttributesMethod (self, attributes : [AttributeWord])
        throws ErrorMsg
    {
        let mut errors : [&ErrorMsg] = [];
        for it in attributes match it.attr {
            Attributes::UNSAFE => {}
            Attributes::FINAL  => {}
            Attributes::INLINE => {}
            Attributes::FIELD  => {}
            _ => { errors ~= [copy ErrorMsg::fatal (it.loc, format (ValidateErrorMessage::UNDEFINED_ATTRIBUTE, it.attr))];  }
        }

        if (errors.len != 0us) throw copy ErrorMsg::list (errors);
    }

    /**
     * Verify that the function is not colliding with other function in the same module
     * */
    fn verifyFunctionCollision (self, sym : &Symbol, name : [c8], prototype : &PrototypeValue)
        throws ErrorMsg
    {
        let dmut mayCollide = sym.getReferent ().getLocalSymbols (name, protection-> Protection::PRIVATE);
        for f in mayCollide[] match f {
            iF : &FunctionSymbol => match iF.getFrameProto () {
                p : &PrototypeValue => {
                    if self.isFuncSimilar (p, prototype) {
                        throw copy ErrorMsg::fatal (p.getLoc (), end-> prototype.getLoc (), format (ValidateErrorMessage::COLLIDING_FUNCTION_DEFINITION, p, prototype, tags-> FormatTags (withParams-> true)));
                    }
                }
            }
        }
    }

    /**
     * @returns: true iif left and right have the same prototype
     * */
    fn isFuncSimilar (self, left : &PrototypeValue, right : &PrototypeValue)-> bool {
        if (left.getSymbol ().getPath ().file () != right.getSymbol ().getPath ().file ()) return false;

        if (left.getParameters ().len != right.getParameters ().len) { return false; }
        for i in 0us .. left.getParameters ().len {
            if (left.getParameters () [i].getType () != right.getParameters () [i].getType ()) {
                return false;
            }

            if (!left.getParameters () [i].getType ().sameMutability (right.getParameters () [i].getType ())) {
                return false;
            }

            if (left.getParameters () [i].isLazy () != right.getParameters () [i].isLazy ()) {
                return false;
            }

            if (left.getParameters () [i].isReference () != right.getParameters () [i].isReference ()) {
                return false;
            }
        }

        true
    }
}
