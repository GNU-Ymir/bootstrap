mod ymirc::semantic::validator::symbol::function;

import ymirc::semantic::validator::visitor;
import ymirc::semantic::validator::template::rewrite;
import ymirc::semantic::validator::errors;
import ymirc::semantic::symbol::_;
import ymirc::syntax::declaration::protection;
import ymirc::syntax::expression::_;
import ymirc::syntax::declaration::_;

import ymirc::syntax::keys;
import ymirc::semantic::generator::_;
import ymirc::errors::_;
import ymirc::utils::format;
import ymirc::lexing::word;

import std::collection::vec;
import std::collection::set;
import std::io, std::fs::path;

/**
 * The function validator is the class responsible for function symbol validation
 */
pub class FunctionValidator {

    /// The list of validating symbol, to avoid infinite value call recursion (foo (a = bar()), bar (a = foo ()))
    let dmut _validating = HashSet!{&Symbol}::new ();
    
    /**
     * Create a new empty validator
     */
    pub self () {}


    /**
     * Validate a function
     * @info: insert the generator in the context for "generation"
     * @params: 
     *   - context: the context of the validation
     *   - sym: the function to validate
     * @throws: 
     *    - &ErrorMsg: if the func is not valid
     */
    pub fn validate (mut self, dmut context : &Validator, dmut sym : &FunctionSymbol)
        throws &ErrorMsg
    {
        context:.pushReferent (alias sym);
        context:.enterForeign (isFnBody-> false);

        {
            self:.validateFunction (alias context, alias sym);
        }  catch {
            err : &ErrorMsg => {
                context:.exitForeign ();
                context:.popReferent ();
                throw ErrorMsg::fatal (sym.getLoc (), format (ValidateErrorMessage::VALIDATING_SYMBOL, sym.getPath ().toStr ()), notes-> [err]);
            }
        }
        
        context:.exitForeign ();
        context:.popReferent ();
    }

    /**
     * Validate a constructor symbol
     * @info: insert the generator in the context for "generation"
     * @params: 
     *    - context: the context of the validation
     *    - sym: the symbol to validate
     *    - clRef: the type of the class containing the ctor
     * @throws: 
     *    - &ErrorMsg: if the ctor is not valid
     */
    pub fn validateConstructor (mut self, dmut context : &Validator, dmut sym : &ConstructorSymbol, clRef : &ClassRefType)
        throws &ErrorMsg
    {
        context:.pushReferent (alias sym);
        context:.enterForeign (isFnBody-> false, clContext-> clRef);
        {
            // Only one kind of constructor
            self:.validateConstructor (alias context, alias sym, clRef, validateBody-> true);
        }  catch {
            err : &ErrorMsg => {
                context:.exitForeign ();
                context:.popReferent ();
                throw ErrorMsg::fatal (sym.getLoc (), format (ValidateErrorMessage::VALIDATING_SYMBOL, sym.getPath ().toStr ()), notes-> [err]);
            }
        }
        
        context:.exitForeign ();
        context:.popReferent ();
    }

    /**
     * Fully validate a method definition  (not just the prototype)
     * @params: 
     *    - context: the context of the validation
     *    - sym: the method to validate
     *    - clRef: the type of self in the method
     * @throws:
     *     - &ErrorMsg: if there was an error in the validation
     */
    pub fn validateMethod (mut self, dmut context : &Validator, dmut sym : &FunctionSymbol, clRef : &ClassRefType)
        throws &ErrorMsg
    {
        context:.pushReferent (alias sym);
        context:.enterForeign (isFnBody-> false, clContext-> clRef);

        {
            // Only one kind of method
            // We don't care if it was defined inside a trait, we don't use the method prototype that is generated
            self:.validateMethod (alias context, alias sym, sym.getContent (), clRef, fromTrait-> EMPTY_SYMBOL, validateBody-> true);
        } catch {
            err : &ErrorMsg => {
                context:.exitForeign ();
                context:.popReferent ();
                throw ErrorMsg::fatal (sym.getLoc (), format (ValidateErrorMessage::VALIDATING_SYMBOL, sym.getPath ().toStr ()), notes-> [err]);
            }
        }
        
        context:.exitForeign ();
        context:.popReferent ();
    }

    /**
     * Validate a destructor defined a class
     * @params:
     *    - context: the context of the validation
     *    - sym: the dtor to validate
     *    - clRef: the class defining the dtor
     * @throws:
     *     - &ErrorMsg: if there is an error in the validation
     */
    pub fn validateDestructor (mut self, dmut context : &Validator, dmut sym : &DestructorSymbol, clRef : &ClassRefType)
        throws &ErrorMsg
    {
        let ancDtor = match clRef.getAncestor () {
            ancRef : &ClassRefType => { // maybe the ancestor has a destructor
                ancRef.getDestructor ()
            }
            _ => { // No ancestor, so no destructor at all
                cast!{&Value} (UNIT_VALUE)
            }
        };

        context:.pushReferent (alias sym);
        context:.enterForeign (isFnBody-> false, clContext-> clRef);

        {
            self:.validateDestructor (alias context, alias sym, clRef, validateBody-> true, ancDtor-> ancDtor)
        } catch {
            err : &ErrorMsg => {
                context:.exitForeign ();
                context:.popReferent ();
                throw ErrorMsg::fatal (sym.getLoc (), format (ValidateErrorMessage::VALIDATING_SYMBOL, sym.getPath ().toStr ()), notes-> [err]);
            }
        }

        context:.exitForeign ();
        context:.popReferent ();
    }


    /*!
     * ================================================================================
     * ================================================================================
     * =========================          PROTOTYPES          =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate the prototype of a function
     * @params: 
     *    - context: the context of the validation
     *    - sym: the symbol to validate
     * @returns: a callable prototype of function
     * @throws: &ErrorMsg, if the function is malformed
     */
    pub fn validateFuncPrototype (mut self, dmut context : &Validator, dmut sym : &FunctionSymbol)-> &PrototypeValue
        throws &ErrorMsg
    {
        match (sym.getFrameProto ()) {
            EmptyGenerator () => {
                let ret = {
                    context:.pushReferent (alias sym);
                    context:.enterForeign (isFnBody-> false);
                    
                    self:.validateFunction (alias context, alias sym, validateBody-> false)
                } exit {                
                    context:.exitForeign ();
                    context:.popReferent ();
                } catch {
                    err : &ErrorMsg => {
                        throw ErrorMsg::fatal (sym.getLoc (), format (ValidateErrorMessage::VALIDATING_SYMBOL, sym.getPath ().toStr ()), notes-> [err]);
                    }                    
                } 


                ret
            }
            v : &PrototypeValue => {
                v
            }
            g : _ => {
                println ("What is inside the function ???", g::typeinfo.name);
                __pragma!panic ();
            }
        }
    }

    /**
     * Validate a prototype of a symbol that is not declared, as it comes from a template rewrite
     * @params: 
     *    - context: the context of the validation
     *    - sym: the symbol declaring the template definition
     *    - func: the rewritten function declaration
     *    - rewriter: the template rewriter
     * @returns: the validate prototype value of the function
     * @throws:
     *    - &ErrorMsg: if the validation fails
     */
    pub fn validateFuncPrototypeFromTemplate (mut self, dmut context : &Validator, dmut sym : &Symbol, func : &FunctionDecl, rewriter : &TemplateRewriter)-> &PrototypeValue
        throws &ErrorMsg
    {
        context:.pushReferent (alias sym);
        context:.enterForeign (isFnBody-> false);

        let mut error = ((&ErrorMsg)?)::__err__;
        let throwers = self.validateThrowers (alias context, func.getThrowerLoc (), func.getThrowers ());
        self.verifyUndefAttributes (func.getAttributes ());

        let (retType, parameters) = {
            context:.enterBlock ();
            {
                {
                    self:.validatePrototype (alias context, sym, func.getFunctionProto ())      
                } catch {
                    err : &ErrorMsg => {
                        error = ErrorMsg::fatal (sym.getLoc (), format (ValidateErrorMessage::VALIDATING_SYMBOL, sym.getPath ().toStr ()), notes-> [err])?;
                        (NONE_TYPE, [])
                    }                    
                }
            } exit {
                {
                    context:.quitBlock (warnUnused-> false);
                } catch {
                    _ => { __pragma!panic (); }
                }
            }
        }

        match error {
            Ok (msg : _) => throw msg;
        }

        PrototypeValue::new (sym.getLoc (), sym, parameters, retType, throwers, fromTemplate-> rewriter?, attributes-> func.getAttributes ())
    } exit {
        context:.exitForeign ();
        context:.popReferent ();
    }
    
    /**
     * Validate the prototype of a constructor
     * @params: 
     *    - context: the context of the validation
     *    - sym: the symbol to validate
     *    - clRef: the type of the class that will be used as self
     * @returns: a callable prototype of function
     * @throws:
     *    - &ErrorMsg, if the constructor is malformed
     */
    pub fn validateCtorPrototype (mut self, dmut context : &Validator, dmut sym : &ConstructorSymbol, clRef : &ClassRefType)-> &CtorPrototypeValue
        throws &ErrorMsg
    {
        let ret = {
            context:.pushReferent (alias sym);
            context:.enterForeign (isFnBody-> false, clContext-> clRef);

            self:.validateConstructor (alias context, alias sym, clRef, validateBody-> false)
        } exit {
            context:.exitForeign ();
            context:.popReferent ();
        } catch {
            err : &ErrorMsg => {
                throw ErrorMsg::fatal (sym.getLoc (), format (ValidateErrorMessage::VALIDATING_SYMBOL, sym.getPath ().toStr ()), notes-> [err]);
            }
        };

        ret
    }

    /**
     * Validate the prototype of a constructor that was declared as a template
     * @params:
     *    - context: the context of the validation
     *    - sym: the template symbol (used for context references only)
     *    - func: the constructor declaration defining the prototype
     *    - clRef: the class type that declared the method
     *    - rewriter: the rewriter defined by the template specialization solving
     * @returns:  A constructor prototype
     * @throws:
     *    - &ErrorMsg: if the validation of the prototype fails
     * */
    pub fn validateCtorPrototypeFromTemplate (mut self, dmut context : &Validator, dmut sym : &Symbol, func : &ConstructorDecl, clRef : &ClassRefType, rewriter : &TemplateRewriter)-> &CtorPrototypeValue
        throws &ErrorMsg
    {
        context:.pushReferent (alias sym);
        context:.enterForeign (isFnBody-> false, clContext-> clRef);
        let ret = {
            let dmut errors = Vec!{&ErrorMsg}::new ();
            let throwers = self.validateThrowers (alias context, func.getThrowerLoc (), func.getThrowers ());
            self.verifyUndefAttributes (func.getAttributes ());

            let parameters = {
                context:.enterBlock ();
                let clPtr = clRef.createInstance (true, true);
                let selfParam = ProtoVarValue::new (func.getLoc (), clPtr, UNIT_VALUE, true, isSelf-> true, isReference-> clRef.isStruct ());
                context:.insertLocal (selfParam.getLoc (), selfParam.getLoc ().str (), selfParam, canShadow-> true);

                let (_, parameters) = self:.validatePrototype (alias context, sym, func.getFunctionProtoDecl (), forMethod-> false);

                parameters
            } catch {
                err : &ErrorMsg => {
                    errors:.push (err);
                    []
                }
            } exit {
                {
                    context:.quitBlock (warnUnused-> false);
                } catch {
                    err : &ErrorMsg => { errors:.push (err); }
                }
            }

            if (errors.len () != 0us) throw ErrorMsg::list (errors []);

            CtorPrototypeValue::new (sym.getLoc (), sym, rename-> func.getRename ().str (), parameters, throwers,
                                     clRef-> clRef, attributes-> func.getAttributes (), fromTemplate-> rewriter?)
        } exit {
            context:.exitForeign ();
            context:.popReferent ();
        } catch {
            err : &ErrorMsg => {
                throw ErrorMsg::fatal (sym.getLoc (), format (ValidateErrorMessage::VALIDATING_SYMBOL, sym.getPath ().toStr ()), notes-> [err]);
            }
        };

        ret
    }

    /**
     * Validate a method prototype defined inside a trait symbol
     * @params: 
     *   - context: the context of the validation
     *   - sym: the function to validate
     *   - clRef: the type of the class (used for the self parameter)
     *   - traitRef: the trait that defines the method
     * @returns: the prototype of the method
     * @throws:
     *   - &ErrorMsg: if the validation fails
     */
    pub fn validateMethodPrototype (mut self, dmut context : &Validator, dmut sym : &FunctionSymbol, clRef : &ClassRefType, traitRef : &TraitRefType)-> &MethodPrototypeValue
        throws &ErrorMsg
    {
        let ret = {
            context:.pushReferent (alias sym);
            context:.enterForeign (isFnBody-> false, clContext-> clRef);

            self:.validateMethod (alias context, alias sym, sym.getContent (), clRef, fromTrait-> traitRef.getSymbol (), validateBody-> false)
        } exit {
            context:.exitForeign ();
            context:.popReferent ();
        } catch {
            err : &ErrorMsg => {
                throw ErrorMsg::fatal (sym.getLoc (), format (ValidateErrorMessage::VALIDATING_SYMBOL, sym.getPath ().toStr ()), notes-> [err]);
            }
        };

        ret
    }

    /**
     * Validate a method prototype defined inside a trait symbol
     * @params: 
     *   - context: the context of the validation
     *   - sym: the function to validate
     *   - clRef: the type of the class (used for the self parameter)
     *   - traitRef: the trait that defines the method
     * @returns: the prototype of the method
     * @throws:
     *   - &ErrorMsg: if the validation fails
     */
    pub fn validateMethodPrototype (mut self, dmut context : &Validator, dmut sym : &FunctionSymbol, clRef : &ClassRefType)-> &MethodPrototypeValue
        throws &ErrorMsg
    {
        let ret = {
            context:.pushReferent (alias sym);
            context:.enterForeign (isFnBody-> false, clContext-> clRef);

            self:.validateMethod (alias context, alias sym, sym.getContent (), clRef, fromTrait-> EMPTY_SYMBOL, validateBody-> false)
        } exit {
            context:.exitForeign ();
            context:.popReferent ();
        } catch {
            err : &ErrorMsg => {
                throw ErrorMsg::fatal (sym.getLoc (), format (ValidateErrorMessage::VALIDATING_SYMBOL, sym.getPath ().toStr ()), notes-> [err]);
            }
        };

        ret
    }

    /**
     * Validate the prototype of a method that was declared as a template in a class
     * @params:
     *    - context: the context of the validation
     *    - sym: the template symbol (used for context references only)
     *    - func: the function declaration defining the prototype
     *    - clRef: the class type that declared the method
     *    - rewriter: the rewriter defined by the template specialization solving
     * @returns:  A method prototype
     * @throws:
     *    - &ErrorMsg: if the validation of the prototype fails
     * */
    pub fn validateMethodPrototypeFromTemplate (mut self, dmut context : &Validator, dmut sym : &Symbol, func : &FunctionDecl, clRef : &ClassRefType, rewriter : &TemplateRewriter)-> &MethodPrototypeValue
        throws &ErrorMsg
    {
        context:.pushReferent (alias sym);
        context:.enterForeign (isFnBody-> false, clContext-> clRef);

        let ret = {
            let dmut errors = Vec!{&ErrorMsg}::new ();

            let throwers = self.validateThrowers (alias context, func.getThrowerLoc (), func.getThrowers ());
            self.verifyUndefAttributes (func.getAttributes ());

            let (retType, selfParam, parameters) = {
                context:.enterBlock ();
                let selfParam = self.validateSelfParamDecl (func.getFunctionProto ().getParameters()[0], clRef);
                context:.insertLocal (selfParam.getLoc (), selfParam.getLoc ().str (), selfParam, canShadow-> true);

                let (retType, parameters) = self:.validatePrototype (alias context, sym, func.getFunctionProto (), forMethod-> true);
                (retType, selfParam, parameters)
            } catch {
                err : &ErrorMsg => {
                    errors:.push (err);
                    (cast!{&Type}(NONE_TYPE), cast!{&Value} (UNIT_VALUE), [])
                }
            } exit {
                {
                    context:.quitBlock (warnUnused-> false);
                } catch {
                    err : &ErrorMsg => { errors:.push (err); }
                }
            }

            if (errors.len () != 0us) throw ErrorMsg::list (errors []);

            MethodPrototypeValue::new (sym.getLoc (), sym, parameters, retType, throwers, clRef, trRef-> EMPTY_SYMBOL, isMutable-> selfParam.getType ().isMutable (),
                                       isEmpty-> func.getBody ().isOf!{&EmptyExpression} (), isOver-> false, isFinal-> true, attributes-> func.getAttributes (), fromTemplate-> rewriter?)
        } exit {
            context:.exitForeign ();
            context:.popReferent ();
        } catch {
            err : &ErrorMsg => {
                throw ErrorMsg::fatal (sym.getLoc (), format (ValidateErrorMessage::VALIDATING_SYMBOL, sym.getPath ().toStr ()), notes-> [err]);
            }
        };


        ret
    }

    /**
     * Validate a dtor prototype defined a class
     * @params:
     *    - context: the context of the validation
     *    - sym: the dtor to validate
     *    - clRef: the class defining the dtor
     *    - ancDtor: the prototype of the ancestor dtor (can be empty, aka UnitValue)
     * @throws:
     *     - &ErrorMsg: if there is an error in the validation
     * @returns: the prototype of the destructor
     */
    pub fn validateDtorPrototype (mut self, dmut context : &Validator, dmut sym : &DestructorSymbol, clRef : &ClassRefType, ancDtor : &Value)-> &DtorPrototypeValue
        throws &ErrorMsg
    {
        let ret = {
            context:.pushReferent (alias sym);
            context:.enterForeign (isFnBody-> false, clContext-> clRef);

            self:.validateDestructor (alias context, alias sym, clRef, validateBody-> false, ancDtor-> ancDtor)
        } exit {
            context:.exitForeign ();
            context:.popReferent ();
        } catch {
            err : &ErrorMsg => {
                throw ErrorMsg::fatal (sym.getLoc (), format (ValidateErrorMessage::VALIDATING_SYMBOL, sym.getPath ().toStr ()), notes-> [err]);
            }
        };

        ret
    }

    
    /*!
     * ================================================================================
     * ================================================================================
     * =========================           FUNCTION           =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a normal function
     * @todo: this function is way too long, and way too close to validateMethod and validateConstructor. A refactorization would be great
     * @params: 
     *    - context: the context of the validation
     *    - sym: the symbol to validate
     * @returns: the prototype of the function
     */        
    fn validateFunction (mut self, dmut context : &Validator, dmut sym : &FunctionSymbol, validateBody : bool = true)-> &PrototypeValue
        throws &ErrorMsg
    {
        let func = sym.getContent ();
        let dmut errors = Vec!{&ErrorMsg}::new ();
        let throwers = self.validateThrowers (alias context, func.getThrowerLoc (), func.getThrowers ());
        self.verifyUndefAttributes (func.getAttributes ());

        let (retType, parameters, body) = {
            context:.enterBlock ();
            let (retType, parameters) = self:.validatePrototype (alias context, sym, func.getFunctionProto ());
            if (func.getLoc ().str () == Keys::MAIN && validateBody) {
                self.verifyMainPrototype (alias context, func.getLoc (), parameters, retType);
            } 

            let body = if (validateBody) {
                context:.enterFunctionBody ();
                let mut unsafeLoc = self.getUnsafeLoc (func.getAttributes ());
                let force = if (unsafeLoc.isEof () && sym.isUnsafe ()) {
                    unsafeLoc = func.getLoc (); // extern C function are unsafe without attributes
                    true
                } else {
                    false
                };

                self.validateFunctionBody (alias context, func.getLoc (), sym.getPath (), func.getBody (), retType, throwers, unsafeLoc, forceUnsafe-> force)
            } else {
                cast!{&Value} (UNIT_VALUE)
            }
            
            (retType, parameters, body)
        } catch {
            err : &ErrorMsg => {
                errors:.push (err);
                (cast!{&Type}(NONE_TYPE), [], cast!{&Value} (UNIT_VALUE))
            }
        } exit {
            {
                context:.quitBlock (warnUnused-> (errors.len () == 0us && validateBody));
            } catch {
                err : &ErrorMsg => { errors:.push (err); }
            }
        }

        if (errors.len () != 0us) throw ErrorMsg::list (errors []);
        if (validateBody && !func.getBody ().isOf!{&EmptyExpression} ()) {
            let frame = FrameGenerator::new (func.getLoc (), sym.getPath (), parameters, retType, body, FrameKind::FUNC,
                                             externLang-> sym.getExternalLanguage (), isWeak-> sym.isWeak (), templateMapper-> sym.getTemplateMapper ());

            context:.insertGenerator (alias sym, frame);
        }

        let gen = match sym.getTemplateMapper () {
            Ok (map : _) => {
                PrototypeValue::new (sym.getLoc (), sym, parameters, retType, throwers, fromTemplate-> TemplateRewriter::new (map)?, attributes-> func.getAttributes ())
            }
            _ => {
                PrototypeValue::new (sym.getLoc (), sym, parameters, retType, throwers, attributes-> func.getAttributes ())
            }
        };

        if (func.getLoc ().str () == Keys::MAIN && gen.isInline ()) {
            throw ErrorMsg::fatal (gen.getInlineLoc (), ValidateErrorMessage::MAIN_INLINE);
        }

        if (validateBody) { // If not validate body the prototype might be uncomplete
            sym:.setFrameProto (gen, body);
        }

        gen
    }

    /**
     * Validate the body of a function
     * @params: 
     *     - context: the context of the validation
     *     - loc: the location of the function
     *     - name: the name of the function
     *     - body: the body of the function
     *     - throwers: the list of throwers
     * @returns: 
     *    - errors: the list of errors 
     *    - .0: the validated value of the body
     *    - .1: true iif the value is not a returner
     */
    fn validateFunctionBody (self, dmut context : &Validator, loc : &Word, name : &SymbolPath, body : &Expression, retType : &Type, throwers : [(&Word, &Type)], unsafeLoc : &Word, forceUnsafe : bool = false, preThrowing : [(&Word, &Type)] = [])-> &Value
        throws &ErrorMsg
    {
        match body {
            EmptyExpression () => {
                context:.clearLocalScope ();
                cast!{&Value} (UnitValue::new (loc-> loc))
            }
            _ => {
                if (!unsafeLoc.isEof ()) context:.enterUnsafeContext (unsafeLoc);

                context:.setFunctionReturn (retType);
                let mut bodyValue = context:.validateValue (body);
                let need = if (!bodyValue.isReturner ()) {
                    if (retType.getLoc ().isEof ()) {
                        bodyValue = context:.verifyCompatibleTypeWithValue (bodyValue.getLoc (), retType, bodyValue, byReference-> false);
                        context:.verifyMemoryOwner (bodyValue.getLoc (), retType, bodyValue, byReference-> false);
                    } else {
                        bodyValue = context:.verifyCompatibleTypeWithValue (retType.getLoc (), retType, bodyValue, byReference-> false);
                        context:.verifyMemoryOwner (retType.getLoc (), retType, bodyValue, byReference-> false);
                    }
                    
                    match retType {
                        VoidType () => { false }
                        _ => { true }
                    }
                } else { false };
                
                self.verifyThrowing (alias context, loc, name, bodyValue.getThrowers () ~ preThrowing, throwers);

                if (!unsafeLoc.isEof ()) context:.exitUnsafeContext (force-> forceUnsafe);

                if (need) {
                    cast!{&Value} (ReturnValue::new (bodyValue.getLoc (), bodyValue))
                } else {
                    bodyValue
                }
            }
        }
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================           METHODS            =========================
     * ================================================================================
     * ================================================================================
     */


    /**
     * Validate a method
     * @todo: this function is way too long, and way too close to validateFunction and validateConstructor. A refactorization would be great
     * @params:
     *    - context: the context of the validation
     *    - sym: the symbol to validate
     *    - clRef: the type of the class defining the method
     *    - fromTrait: the symbol of the trait if this method is defined inside a trait, (EmptySymbol otherwise)
     *    - validateBody: true iif the body must be validated
     * @returns: the prototype of the method
     * @throws:
     *    - &ErrorMsg: if the validation failed
     */
    fn validateMethod (mut self, dmut context : &Validator, dmut sym : &FunctionSymbol, func : &FunctionDecl, clRef : &ClassRefType, fromTrait : &Symbol, validateBody : bool = false)-> &MethodPrototypeValue
        throws &ErrorMsg
    {
        let dmut errors = Vec!{&ErrorMsg}::new ();
        let throwers = self.validateThrowers (alias context, func.getThrowerLoc (), func.getThrowers ());
        self.verifyUndefAttributesMethod (func.getAttributes ());

        let (retType, selfParam, parameters, body) = {
            context:.enterBlock ();
            let selfParam = self.validateSelfParamDecl (func.getFunctionProto ().getParameters()[0], clRef);
            context:.insertLocal (selfParam.getLoc (), selfParam.getLoc ().str (), selfParam, canShadow-> true);

            let (retType, parameters) = self:.validatePrototype (alias context, sym, func.getFunctionProto (), forMethod-> true);
            let fieldLoc = self.getFieldLoc (func.getAttributes ());
            if (!fieldLoc.isEof () && parameters.len != 0us) {
                throw ErrorMsg::fatal (func.getLoc (), ValidateErrorMessage::FIELD_METHOD_PARAMS, notes-> [ErrorMsg::note (fieldLoc, ""s8)]);
            }

            let body = if (validateBody) {
                context:.enterFunctionBody ();
                let mut unsafeLoc = self.getUnsafeLoc (func.getAttributes ());
                if (unsafeLoc.isEof () && sym.isUnsafe ()) { unsafeLoc = func.getLoc (); } // extern C function are unsafe without attributes

                self.validateFunctionBody (alias context, func.getLoc (), sym.getPath (), func.getBody (), retType, throwers, unsafeLoc)
            } else {
                cast!{&Value} (UNIT_VALUE)
            }

            (retType, selfParam, parameters, body)
        } catch {
            err : &ErrorMsg => {
                errors:.push (err);
                (cast!{&Type}(NONE_TYPE), cast!{&Value} (UNIT_VALUE), [], cast!{&Value} (UNIT_VALUE))
            }
        } exit {
            {
                context:.quitBlock (warnUnused-> (errors.len () == 0us && validateBody));
            } catch {
                err : &ErrorMsg => { errors:.push (err); }
            }
        }

        if (errors.len () != 0us) throw ErrorMsg::list (errors []);
        if (validateBody && !func.getBody ().isOf!{&EmptyExpression} ()) {
            let frame = FrameGenerator::new (func.getLoc (), sym.getPath (), [selfParam] ~ parameters, retType, body, FrameKind::METHOD,
                                             externLang-> sym.getExternalLanguage (), isWeak-> (sym.isWeak () || clRef.getSymbol ().isWeak ()),
                                             templateMapper-> sym.getTemplateMapper ());

            context:.insertGenerator (alias sym, frame);
        }


        let gen = match sym.getTemplateMapper () {
            Ok (map : _) => {
                MethodPrototypeValue::new (sym.getLoc (), sym, parameters, retType, throwers, clRef, trRef-> fromTrait, isMutable-> selfParam.getType ().isMutable (),
                                           isEmpty-> func.getBody ().isOf!{&EmptyExpression} (), isOver-> sym.isOver (), isFinal-> sym.isFinal (), attributes-> func.getAttributes (), fromTemplate-> TemplateRewriter::new (map)?)
            }
            _ => {
                MethodPrototypeValue::new (sym.getLoc (), sym, parameters, retType, throwers, clRef, trRef-> fromTrait, isMutable-> selfParam.getType ().isMutable (),
                                           isEmpty-> func.getBody ().isOf!{&EmptyExpression} (), isOver-> sym.isOver (), isFinal-> sym.isFinal (), attributes-> func.getAttributes ())
            }
        };

        if (gen.isInline () && (!sym.isFinal () || sym.isOver ())) {
            throw ErrorMsg::fatal (gen.getInlineLoc (), format (ValidateErrorMessage::INLINE_VIRTUAL_METHOD, gen));
        }

        gen
    }
    
    /*!
     * ================================================================================
     * ================================================================================
     * =========================            DTORS             =========================
     * ================================================================================
     * ================================================================================
     */

    fn validateDestructor (mut self, dmut context : &Validator, dmut sym : &DestructorSymbol, clRef : &ClassRefType, ancDtor : &Value, validateBody : bool = false)-> &DtorPrototypeValue
        throws &ErrorMsg
    {
        let func = sym.getContent ();
        let dmut errors = Vec!{&ErrorMsg}::new ();
        self.verifyUndefAttributesDtor (func.getAttributes ());

        let (retType, selfParam, parameters, body) = {            
            context:.enterBlock ();
            let selfParam = self.validateSelfParamDecl (func.getFunctionProto ().getParameters()[0], clRef);
            if (!selfParam.isMutable ()) {
                throw ErrorMsg::fatal (selfParam.getLoc (), format (ValidateErrorMessage::DTOR_SELF_NOT_MUT));
            }
            
            context:.insertLocal (selfParam.getLoc (), selfParam.getLoc ().str (), selfParam, canShadow-> true);
            
            let (retType, parameters) = self:.validatePrototype (alias context, sym, func.getFunctionProto (), forMethod-> true);
            let body = if (validateBody) {
                context:.enterFunctionBody ();
                self.validateDtorBody (alias context, func, alias sym, clRef, ancDtor, retType, selfParam)
            } else {
                cast!{&Value} (UNIT_VALUE)
            };

            (retType, selfParam, parameters, body)
        } catch {           
            err : &ErrorMsg => {
                errors:.push (err);
                (cast!{&Type}(NONE_TYPE), cast!{&Value} (UNIT_VALUE), [], cast!{&Value} (UNIT_VALUE))
            }
        } exit {
            {
                context:.quitBlock (warnUnused-> (errors.len () == 0us && validateBody));
            } catch {
                err : &ErrorMsg => { errors:.push (err); }
            }
        }

        if (errors.len () != 0us) throw ErrorMsg::list (errors []);
        if (validateBody && !func.getBody ().isOf!{&EmptyExpression} ()) {
            let frame = FrameGenerator::new (func.getLoc (), sym.getPath (), [selfParam] ~ parameters, retType, body, FrameKind::DTOR,
                                             externLang-> sym.getExternalLanguage (), isWeak-> (sym.isWeak () || clRef.getSymbol ().isWeak ()),
                                             templateMapper-> sym.getTemplateMapper ());

            context:.insertGenerator (alias sym, frame);
        }


        DtorPrototypeValue::new (sym.getLoc (), sym, clRef)
    }

    /**
     * Finalize the body of the destructor
     * @params:
     *    - context: the context of the validation
     *    - func: the destructor to validate
     *    - sym: the symbol containing the declaration
     *    - clRef: the class ref containing the dtor
     * @returns: the body of the dtor
     * */
    fn validateDtorBody (self, dmut context : &Validator, func : &DestructorDecl, dmut sym : &DestructorSymbol, clRef : &ClassRefType, ancDtor : &Value, retType : &Type, selfParam : &Value)-> &Value
        throws &ErrorMsg
    {
        let innerBl = self.validateFunctionBody (alias context, func.getLoc (), sym.getPath (), func.getBody (), retType, [], EOF_WORD); // dtor can't be unsafe
        let retBl = match ancDtor {
            meth : &DtorPrototypeValue => {
                let selfValue = VarRefValue::new (selfParam.getLoc (), selfParam.getLoc (), selfParam.getType (), selfParam.getUniqId (), isSelf-> true, isReference-> clRef.isStruct ());
                let methDg = MethodDelegateValue::new (func.getLoc (), meth, closure-> selfValue, direct-> true, vtableIndex-> 0us, isStruct-> clRef.isStruct ());
                let call = MethodCallValue::new (func.getLoc (), VoidType::new (func.getLoc ()), methDg, []);
                cast!{&Value} (BlockValue::new (func.getLoc (), VoidType::new (func.getLoc ()), [innerBl, call]))
            }
            _ => { innerBl }
        }

        let finBl = if (clRef.getSymbol ().isMovable ()) {
            let selfValue = VarRefValue::new (selfParam.getLoc (), selfParam.getLoc (), selfParam.getType (), selfParam.getUniqId (), isSelf-> true, isReference-> clRef.isStruct ());
            match self.validateMovableFieldDtorCall (alias context, selfValue, clRef) {
                moveBl : &BlockValue => {
                    cast!{&Value} (BlockValue::new (func.getLoc (), VoidType::new (func.getLoc ()), [retBl, moveBl]))
                }
                _ => { retBl }
            }
        } else {
            retBl
        };

        finBl
    }

    /**
     * Validate the call to the dtor of the movable fields of the entity
     * @params:
     *    - context: the context of the validation
     *    - selfParam: the self parameter value
     *    - clRef: the type being destroyed
     * */
    fn validateMovableFieldDtorCall (self, dmut context : &Validator, selfParam : &Value, clRef : &ClassRefType)-> &Value
        throws &ErrorMsg
    {
        context;
        let loc = selfParam.getLoc ();
        let dmut calls = Vec!{&Value}::new ();

        for v in clRef.getLocalFields () {
            if (v.getVarType ().isMovable ()) match v.getVarType () {
                c : &ClassPtrType => {
                    if c.getInner ().getDestructor ().isOf!{&DtorPrototypeValue} () {
                        let fieldAccess = StructFieldAccessValue::new (loc, c, selfParam, v.getLoc ().str ());
                        let methDg = MethodDelegateValue::new (loc,
                                                               c.getInner ().getDestructor ().asOf!{&DtorPrototypeValue} (),
                                                               closure-> fieldAccess, direct-> true, vtableIndex-> 0us, isStruct-> true);

                        let boolType = BoolType::new (loc);
                        let lSet = StructFieldAccessValue::new (loc, boolType, fieldAccess, ClassKeys::SET);
                        let call = MethodCallValue::new (loc, VoidType::new (loc), methDg, []);
                        let postCall = AffectValue::new (loc, VOID_TYPE, lSet, BoolValue::new (loc, false));
                        let instrs = BlockValue::new (loc, VOID_TYPE, [call, postCall, UNIT_VALUE], isSet-> true);
                        // if field.#_set { __dtor (field); field.#_set = 0; }

                        let cond = ConditionalValue::new (loc, VOID_TYPE, lSet, instrs, UNIT_VALUE);
                        calls:.push (cond);
                    }
                }
            }
        }

        if (calls.len () == 0us) return UNIT_VALUE;
        BlockValue::new (selfParam.getLoc (), VoidType::new (selfParam.getLoc ()), calls[])
    }
    
    /*!
     * ================================================================================
     * ================================================================================
     * =========================            CTORS             =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a constructor
     * @todo: this function is way too long, and way too close to validateFunction and validateMethod. A refactorization would be great
     * @params: 
     *    - context: the context of the validation
     *    - sym: the symbol to validate
     *    - clRef: the class type for self
     *    - validateBody: validate the body of the constructor (and field/ancestor constructions)
     * @returns: the prototype of the ctor
     * @throws:
     *    - &ErrorMsg: if the validation failed
     */
    fn validateConstructor (mut self, dmut context : &Validator, dmut sym : &ConstructorSymbol, clRef : &ClassRefType, validateBody : bool = false)-> &CtorPrototypeValue
        throws &ErrorMsg
    {
        let func = sym.getContent ();
        let dmut errors = Vec!{&ErrorMsg}::new ();
        let throwers = self.validateThrowers (alias context, func.getThrowerLoc (), func.getThrowers ());
        self.verifyUndefAttributes (func.getAttributes ());

        let (selfParam, parameters, body, hasRedirect) = {
            context:.enterBlock ();
            // We need a class ptr for the self parameter
            let clPtr = clRef.createInstance (true, true);

            let selfParam = ProtoVarValue::new (Word::new (Keys::SELF, func.getLoc ()), clPtr, UNIT_VALUE, true, isSelf-> true, isReference-> clRef.isStruct ());   // Self parameters (first hidden param)
            let (_, parameters) = self:.validatePrototype (alias context, sym, func.getFunctionProtoDecl (), forMethod-> false); // unlike methods self is not written in the prototype, so we need to validate all parameters

            let (body, hasRedirect) = if (validateBody) { // We validate the body
                self.validateCtorBody (alias context, sym, func, clPtr.getInner (), selfParam, throwers)
            } else { // we validate only the prototype
                (cast!{&Value} (UNIT_VALUE), false)
            }

            (selfParam, parameters, body, hasRedirect) // don't add the self parameter in the prototype, we don't have it when calling the prototype
        } catch {
            err : &ErrorMsg => {
                errors:.push (err);
                (cast!{&Value} (UNIT_VALUE), [], cast!{&Value} (UNIT_VALUE), false)
            }
        } exit {
            {
                context:.quitBlock (warnUnused-> (errors.len () == 0us && validateBody));
            } catch {
                err : &ErrorMsg => { errors:.push (err); }
            }
        }

        if (errors.len () != 0us) throw ErrorMsg::list (errors []);
        if (validateBody && !func.getBody ().isOf!{&EmptyExpression} ()) {
            let frame = FrameGenerator::new (func.getLoc (), sym.getPath (), [selfParam.asOf!{&ProtoVarValue} ()] ~ parameters, VoidType::new (sym.getLoc ()), body, FrameKind::CTOR,
                                             isWeak-> (sym.isWeak () || clRef.getSymbol ().isWeak ()),
                                             templateMapper-> sym.getTemplateMapper ());

            context:.insertGenerator (alias sym, frame);
        }

        let gen = match sym.getTemplateMapper () {
            Ok (map : _) => {
                CtorPrototypeValue::new (sym.getLoc (), sym, parameters, throwers, clRef, rename-> func.getRename ().str (),
                                         attributes-> func.getAttributes (), fromTemplate-> TemplateRewriter::new (map)?)
            }
            _ => {
                CtorPrototypeValue::new (sym.getLoc (), sym, parameters, throwers, clRef, rename-> func.getRename ().str (),
                                         attributes-> func.getAttributes ())
            }
        }

        if (validateBody && hasRedirect) {
            sym:.setFrameProto (gen, body, hasRedirect);
            context:.verifyInfiniteCtorRecursion (gen);
        }

        gen
    }

    /**
     * Validation of the body of the constructor
     * This function is different from validateFunctionBody, because it also validates the pre constructor
     * @params: 
     *    - context: the context of the validation
     *    - sym: the symbol being validated
     *    - ctor: the ctor whose body is being validated
     *    - clRef: the type of the class containing the ctor
     *    - selfParam: the protovarvalue of the hidden self parameter
     * @returns: the body of the ctor
     * @throws:
     *    - &ErrorMsg: if there was an error in the validation     
     */
    fn validateCtorBody (self, dmut context : &Validator, sym : &ConstructorSymbol, ctor : &ConstructorDecl, clRef : &ClassRefType, selfParam : &Value, throwers : [(&Word, &Type)])-> (&Value, bool)
        throws &ErrorMsg
    {
        //
        //
        // insert self in the scope, alongside with parameters (its an hidden param)
        context:.insertLocal (selfParam.getLoc (), selfParam.getLoc ().str (), selfParam, canShadow-> true);
        context:.getLocal (selfParam.getLoc (), selfParam.getLoc ().str (), canBeInClosure-> false);

        // Reference to the self hidden param
        let selfValue = VarRefValue::new (selfParam.getLoc (), selfParam.getLoc (), selfParam.getType (), selfParam.getUniqId (), isSelf-> true);
        
        // Validate the pre construction of the constructor (construction of fields, and ancestor)
        let (preConstruct, hasRedirect) = self.validatePreConstructor (alias context, ctor, clRef, selfValue);


        // From this point, return is allowed
        context:.enterFunctionBody ();

        let mut unsafeLoc = self.getUnsafeLoc (ctor.getAttributes ());
        if (unsafeLoc.isEof () && sym.isUnsafe ()) { unsafeLoc = ctor.getLoc (); } // extern C function are unsafe without attributes

        // Validate the body of the constructor (return void type)
        let body = self.validateFunctionBody (alias context,
                                              ctor.getLoc (),
                                              sym.getPath (),
                                              ctor.getBody (),
                                              VoidType::new (sym.getLoc ()),
                                              preThrowing-> preConstruct.getThrowers (),
                                              throwers,
                                              unsafeLoc);

        // the body contains the pre construction, and the proper body
        let finalBody = match preConstruct {
            UnitValue () => { [body] }
            _ => { [preConstruct, body] }
        };

        (BlockValue::new (ctor.getLoc (), VoidType::new (sym.getLoc ()), finalBody), hasRedirect)
    }       
        
    /**
     * Validate the pre construction of a constructor
     * @params: 
     *    - context: the context of the validation
     *    - sym: the symbol being validated
     *    - func: the declaration to validate
     *    - clRef: the type of self
     *    - selfParam: the self parameter
     * @returns: the value containing the constructions statements
     * @throws: 
     *    - &ErrorMsg: if there was an error in the validation
     */
    fn validatePreConstructor (self, dmut context : &Validator, func : &ConstructorDecl, clRef : &ClassRefType, selfParam : &Value)-> (&Value, bool)
        throws &ErrorMsg
    {
        if (func.getExplicitCstrsCall () == Keys::SELF) { // There is a redirection of construction
            return (self.validateRedirectCtor (alias context, func, clRef, selfParam), true);
        }

        let dmut block = Vec!{&Value}::new (); // list of instructions        
        let ancCall = self.validateAncestorCtorCall (alias context, func, clRef, selfParam);
        match ancCall {
            UnitValue () => {} // Don't add an empty value
            _ =>  {
                block:.push (ancCall); // There is an ancestor, and its ctor is called
            }
        }        

        let fieldCtor = self.validateFieldCtors (alias context, func, clRef, selfParam);
        match fieldCtor {
            UnitValue () => {} // Don't add an empty value
            _ => {
                block:.push (fieldCtor); // there are field constructions
            }
        }

        let finVal = if (block.len () != 0us) {
            // We create the block of instruction, containing super call, and field ctors
            BlockValue::new (func.getLoc (), VoidType::new (func.getLoc ()), block[])
        } else {
            UnitValue::new (loc-> func.getLoc ())
        };

        (finVal, false)
    }

    /**
     * Validate the call of a redirect constructor
     * @params: 
     *    - context: the context of the validation
     *    - sym: the symbol being validated
     *    - func: the declaration of the constructor
     *    - clRef: the type of the class that is being validated
     * @returns: the instruction calling the redirect constructor
     * @throws: 
     *    - &ErrorMsg: if there is an error in the validation
     */
    fn validateRedirectCtor (self, dmut context : &Validator, func : &ConstructorDecl, clRef : &ClassRefType, selfParam : &Value)-> &Value
        throws &ErrorMsg
    {
        let dmut errors = Vec!{&ErrorMsg}::new ();
        let dmut rights = Vec!{&Value}::new ();

        let selfLoc = func.getExplicitCstrsCall ();
        for v in func.getSuperParams () { // Validate the parameters that are passed to the redirect constructor
            rights:.push (context:.validateValue (v));
        }
        
        let ret = {
            // Ignore the current constructor, it cannot be called by redirection
            let ctors = self.createCtorDelegate (alias context, selfLoc, clRef, selfParam, renameLoc-> func.getExplicitSuperName (), templateParams-> func.getSuperTemplateParams ());
            context:.getCallOpValidator ().validate (alias context, selfLoc, ctors, rights[], inCopy-> true)
        } catch { 
            err : &ErrorMsg => { // None succeeded (TODO print private candidates)
                errors:.push (ErrorMsg::fatal (selfLoc, format (ValidateErrorMessage::UNDEFINED_REDIRECT_CALL_CTOR, rights[]), notes-> [err]));
                cast!{&Value} (UnitValue::new (loc-> selfLoc))
            }
        }

        for it in func.getFieldConstructors () {
            errors:.push (ErrorMsg::fatal (it._0, format (ValidateErrorMessage::ALREADY_INIT_BY_CTOR_REDIRECT, it._0.str ()), notes-> [ErrorMsg::note (selfLoc, ""s8)]));
        }

        if (errors.len () != 0us) throw ErrorMsg::list (errors[]);

        ret
    }
    
    /**
     * Validate the call of the ancestor constructor (if there is an ancestor)
     * @params: 
     *    - context: the context of the validation
     *    - func: the declaration of the constructor
     *    - clRef: the type of the class that is being validated
     *    - selfParam: the self parameters
     * @returns: the instruction calling the ancestor constructor (or Unit, if there is not call)
     * @throws: 
     *    - &ErrorMsg: if there is an error in the validation
     */
    fn validateAncestorCtorCall (self, dmut context : &Validator, func : &ConstructorDecl, clRef : &ClassRefType, selfParam : &Value)-> &Value
        throws &ErrorMsg
    {
        match clRef.getAncestor () {
            ancestor : &ClassRefType => {
                // If the super call is implicit, we need a valid location
                let superLoc = if (func.getExplicitCstrsCall ().isEof ()) { func.getLoc () } else { func.getExplicitCstrsCall () };
                let dmut rights = Vec!{&Value}::new ();
                for v in func.getSuperParams () { // Validate the parameters that are passed to the parent constructor
                    rights:.push (context:.validateValue (v));
                }
                
                {
                    let ctors = self.createCtorDelegate (alias context, superLoc, ancestor, selfParam, renameLoc-> func.getExplicitSuperName (), templateParams-> func.getSuperTemplateParams ());
                    return context:.getCallOpValidator ().validate (alias context, superLoc, ctors, rights[], inCopy-> true); // Call the ctors with the parameters and return the one that succeeded
                } catch { 
                    err : &ErrorMsg => { // None succeeded (TODO print private candidates)
                        throw ErrorMsg::fatal (superLoc, format (ValidateErrorMessage::UNDEFINED_SUPER_CALL_CTOR, rights[]), notes-> [err]);
                    }
                }
            }
            _ => {
                // Class does not have any ancestor, so it can't be called
                if (func.getExplicitCstrsCall () == Keys::SUPER) {
                    throw ErrorMsg::fatal (func.getExplicitCstrsCall (), format (ValidateErrorMessage::NO_SUPER_CLASS, clRef));
                }
                
                return UNIT_VALUE;
            }            
        }        
    }

    /**
     * Create a mult sym containing all the constructor of the class with the given instance
     * @params: 
     *    - loc: the location of the call
     *    - clRef: the class whose constructors are used
     *    - selfParam: the instance for self
     *    - withPrivate: include PRV_PARENT constructors ?
     *    - prettyStr: the name of the call
     * @returns: a MultSymValue with all the available ctors (can be of len == 0us)
     */
    fn createCtorDelegate (self, dmut context : &Validator, loc : &Word, clRef : &ClassRefType, selfParam : &Value, renameLoc : &Word, templateParams : &Expression)-> &Value
        throws &ErrorMsg
    {
        let rename = if (renameLoc.isEof ()) { ""s8 } else { renameLoc.str () };
        let ctors = context:.getSubTypeValidator ().validateClassCtors (alias context, loc, clRef, name-> rename, selfParam-> selfParam, fromSubType-> true);

        match templateParams {
            EmptyExpression () => { ctors }
            tmp : &TemplateCallExpr => {
                let mt = match ctors {
                    m : &MultSymValue => { m }
                    x : _ => { MultSymValue::new (x.getLoc (), [x], prettyStr-> format ("%", tmp)) }
                };

                let list = context:.validateTemplateArgumentList (tmp.getRights ());
                context:.getValueValidator ().validateTemplateCallMultSym (alias context, loc, mt, list)
            }
            _ => __pragma!panic ();
        }
    }
    
    /**
     * Validate the field constructors
     * @params: 
     *    - context: the context of the validation
     *    - func: the declaration of the constructor
     *    - clRef: the type of the class that is being validated
     *    - selfParam: the parameter self              
     * @returns: the instructions affecting values to the fields
     * @throws: 
     *     - &ErrorMsg: if there is an error in the validation
     */
    fn validateFieldCtors (self, dmut context : &Validator, func : &ConstructorDecl, clRef : &ClassRefType, selfParam : &Value)-> &Value
        throws &ErrorMsg
    {
        let dmut instrs = Vec!{&Value}::new ();
        let dmut errors = Vec!{&ErrorMsg}::new ();
        context:.enterFieldConstruction (clRef); // Enter this context modifies the behavior of Dot operator, by saying the uninitialized fields of type 'clRef' cannot be accessed
        
        {
            let dmut willBeValidated = HashSet!{[c8]}::new ();            
            for it in func.getFieldConstructors () { // We need a list of fields that will be validated by pre construction (ref 1)
                willBeValidated:.insert (it._0.str ());
            }
            
            for v in clRef.getLocalFields () {  // Validate all the fields that were not validated by pre construction
                {
                    if (v.getLoc ().str () !in willBeValidated) { // (cite 1), so we can initialize the fields that are not pre constructed first
                        if (v.getValue ().isOf!{&UnitValue} ()) {
                            errors:.push (ErrorMsg::fatal (v.getLoc (), format (ValidateErrorMessage::UNINIT_FIELD, v.getLoc ().str ())));
                        } else {
                            let field = context:.getBinOpValidator ().validateClassFieldAccess (alias context, v.getLoc (), selfParam, VarExpr::new (v.getLoc ()), clRef, true, true, verifyValidation-> false, withAncestor-> false);
                            instrs:.push (AffectValue::new (v.getLoc (), field.getType (), field, v.getValue ()));
                            context:.setFieldValidated (v.getLoc ().str ());
                        }
                    }
                } catch {
                    err : &ErrorMsg => { errors:.push (err); }
                }
            }

            if (errors.len () != 0us) throw ErrorMsg::list (errors[]);
            for it in func.getFieldConstructors () { // Validate all the fields that are written in the pre construction 
                let name = it._0;
                if (name.str () in context:.getFieldValidated ()) {
                    errors:.push (ErrorMsg::fatal (name, format (ValidateErrorMessage::MULTIPLE_FIELD_INIT, name.str ())));
                } else {
                    let field = context:.getBinOpValidator ().validateClassFieldAccess (alias context, name, selfParam, VarExpr::new (name), clRef, true, true, verifyValidation-> false, withAncestor-> false);
                    let value = context:.verifyCompatibleTypeWithValue (field.getLoc (), field.getType (), context:.validateValue (it._1), byReference-> false);
                    context:.verifyMemoryOwner (field.getLoc (), field.getType (), value, byReference-> false);
                    
                    instrs:.push (AffectValue::new (name, field.getType (), field, value));
                    context:.setFieldValidated (name.str ());
                }
            } catch {
                err : &ErrorMsg => { errors:.push (err); }
            }        
        } catch {
            err : &ErrorMsg => { errors:.push (err); }
        }

        context:.quitFieldConstruction (); // We don't forget to quit the field validation, from that point all fields are accessible
        if (errors.len () != 0us) throw ErrorMsg::list (errors[]);
        if (instrs.len () != 0us) {
            // returns the list of constructions
            BlockValue::new (func.getLoc (), VoidType::new (func.getLoc ()), instrs[])
        } else { 
            UnitValue::new (loc-> func.getLoc ()) // No instrs, no need to open a block
        }
    }
    
    /*!
     * ================================================================================
     * ================================================================================
     * =========================           THROWERS           =========================
     * ================================================================================
     * ================================================================================
     */
    
    /**
     * Validate the throwers a function
     * @params: 
     *    - context: the context of the validation
     *    - throwers: the list of throwers
     * @returns: 
     *    - errors: the list of errors that occurs in the validation
     *    - the list of throwers
     */
    fn validateThrowers (self, dmut context : &Validator, loc : &Word, throwers : [&Expression])-> [(&Word, &Type)]
        throws &ErrorMsg
    {
        // No need to validate core::exception::Exception if there is no throws
        if (throwers.len == 0us) return [];

        let dmut errors = Vec!{&ErrorMsg}::new ();
        let dmut rets = Vec!{(&Word, &Type)}::new ();
        let exceptionType = context:.getExceptionType (loc-> loc);
        let innerExc = exceptionType.asOf!{&ClassPtrType} ().getInner ();

        for i in throwers {
            {
                let type = context:.validateType (i);
                match type {
                    cptr : &ClassRefType => {
                        if (context.isAncestor (exceptionType, cptr) || context.isDirectInstance (exceptionType, cptr)) {
                            rets:.push ((i.getLoc (), type));
                        } else {
                            errors:.push (ErrorMsg::fatal (i.getLoc (), end-> exceptionType.getLoc (), format (ValidateErrorMessage::NOT_AN_EXCEPTION_CLASS, cptr, innerExc)));
                        }
                    }
                    cptr : &ClassPtrType => {
                        errors:.push (ErrorMsg::fatal (i.getLoc (), format (ValidateErrorMessage::CLASS_THROW_PTR, type)));
                        if (context.isAncestor (exceptionType, cptr) || context.isDirectInstance (exceptionType, cptr)) {
                            rets:.push ((i.getLoc (), type));
                        } else {
                            errors:.push (ErrorMsg::fatal (i.getLoc (), end-> exceptionType.getLoc (), format (ValidateErrorMessage::NOT_AN_EXCEPTION_CLASS, cptr.getInner (), innerExc)));
                        }
                    }
                    _ => {                        
                        errors:.push (ErrorMsg::fatal (i.getLoc (), format (ValidateErrorMessage::NOT_A_CLASS, type)));
                    }
                }
            } catch {
                err : &ErrorMsg => { errors:.push (err); }
            }
        }

        if (errors.len () != 0us) {
            throw ErrorMsg::list (errors[]);
        }

        rets[]
    }

    /**
     * Verify that the declared throws and the actual thrown of the function are similar
     * @params: 
     *    - context: the context of the function
     *    - loc: the location of the definition of the function
     *    - name: the name of the function
     *    - thrown: the list of type that are thrown by the body
     *    - expected: the list of type that are declared in the prototype as throws
     * @returns: 
     *     - errors: the list of errors during the validation
     */
    fn verifyThrowing (self, dmut context : &Validator, loc : &Word, name : &SymbolPath, thrown : [(&Word, &Type)], expected : [(&Word, &Type)])
        throws &ErrorMsg
    {
        let (notFound, unused) = self.listUnusedThrows (context, thrown, expected);
        
        let dmut lst = Vec!{&Type}::new ();
        let dmut errors = Vec!{&ErrorMsg}::new ();
        for i in notFound {
            let mut found = false;
            for j, index in lst {
                if i._1 == j {
                    found = true;
                    (alias errors) [index] = errors [index].withNote ([ErrorMsg::note (i._0, ""s8)]);
                    break {}
                }
            }
            
            if (!found) {            
                errors:.push (ErrorMsg::fatal (loc, format (ValidateErrorMessage::THROWS_NOT_DECLARED, name.toStr (), i._1),
                                               notes-> [ErrorMsg::note (i._0, ""s8)]));
                lst:.push (i._1);
            }
        }

        for i in unused {
            errors:.push (ErrorMsg::fatal (loc, format (ValidateErrorMessage::THROWS_NOT_USED, name.toStr (), i._1),
                                           notes-> [ErrorMsg::note (i._0, ""s8)]));
        }

        if (errors.len () != 0us) throw ErrorMsg::list (errors[]);
    } catch {
        err : &ErrorMsg => throw err;
    }

    /**
     * List the throws that are unused, and not found
     * @params:
     *    - thrown: the list of exception thrown in the body of the function
     *    - expected: the list of exception declared in the prototype of the function
     * @returns:
     *    - .0: the list of exception thrown in the body but not declared
     *    - .1: the list of exception declared in the prototype but not found in the body
     */
    fn listUnusedThrows (self, context : &Validator, thrown : [(&Word, &Type)], expected : [(&Word, &Type)])-> ([(&Word, &Type)], [(&Word, &Type)])
        throws &ErrorMsg
    {
        let dmut notFound = Vec!{(&Word, &Type)}::new (), dmut unused = Vec!{(&Word, &Type)}::new ();
        for i in thrown {
            let mut found = false;
            for j in expected  {
                if context.isDirectInstance (i._1, j._1) {
                    found = true;
                    break {}
                } else if context.isAncestor (j._1, i._1) {
                    found = true;
                    break {}
                }
            }

            if !found {
                notFound:.push (i);
            }
        }

        for i in expected {
            let mut found = false;
            for j in thrown {
                if (context.isDirectInstance (i._1, j._1)) {
                    found = true;
                    break {}
                } else if (context.isAncestor (i._1, j._1)) {
                    found = true;
                    break {}
                }
            }

            if !found {
                unused:.push (i);
            }
        }

        (notFound[], unused[])        
    }
    
    /*!
     * ================================================================================
     * ================================================================================
     * =========================          PROTOTYPE           =========================
     * ================================================================================
     * ================================================================================
     */
    
    /**
     * Validate the prototype of a frame for generation
     * @params: 
     *   - context: the context of the validation
     *   - sym: the symbol being validated
     *   - proto: the prototype to validate
     *   - forMethod: true iif the validation is intended to create a method prototype
     * @returns:
     *    - .0: the return type of the prototype
     *    - .1: the list of parameters
     * @throws: &ErrorMsg, if there is a malformed parameter, or the return type is malformed
     */
    fn validatePrototype (mut self, dmut context : &Validator, sym : &Symbol, proto : &FunctionProtoDecl, forMethod : bool = false)-> (&Type, [&ProtoVarValue])
        throws &ErrorMsg
    {
        let dmut parameters = Vec!{&ProtoVarValue}::new ();
        let dmut errors = Vec!{&ErrorMsg}::new ();
        
        let noValue = sym in self._validating;
        self._validating:.insert (sym);
        {
            for i, param in proto.getParameters () {
                if (i != 0us || !forMethod) { // If we validate the prototype for a method, we don't validate the first parameter (which is always self)
                    let (isMutable, isReference, isLazy, type, value) = self.validateParamDecl (alias context, param, noValue-> noValue);
                    let nbConsume = match param.getType () {
                        lst : &TypeListWrapperExpr => { cast!u32 (lst.getTypes ().len) }
                        _ => 1u32
                    };

                    let paramGen = ProtoVarValue::new (param.getLoc (), type, value, isMutable, isSelf-> false, isReference-> isReference, isLazy-> isLazy, nbConsume-> nbConsume);
                    parameters:.push (paramGen);
                    context:.insertLocal (paramGen.getLoc (), paramGen.getLoc ().str (), paramGen);
                } catch {
                    err : &ErrorMsg => {
                        errors:.push (err);
                    }
                }
            }
        }         
        self._validating:.remove (sym);

        let r : &Type = {
            let t = match proto.getRetType () {
                EmptyExpression () => { cast!{&Type} (VoidType::new (proto.getLoc ())) }
                x : _ => { context:.validateType (x) }
            };

            context:.verifyCompleteType (t.getLoc (), t, true);
            t
        } catch {
            err : &ErrorMsg => {
                errors:.push (err);
                throw ErrorMsg::list (errors[]);
            }
        }
        
        if (errors.len () != 0us) throw ErrorMsg::list (errors[]);
        (r, parameters[])          
    }

    /**
     * Verify that the prototype is correct for the main function
     * @params: 
     *   - funcLoc: the location of the function definition
     *   - proto: the prototype of the frame 
     *   - parameters: the validated parameters of the function
     *   - retType: the return type of the function
     * @returns:
     *    - errors: add errors if the prototype is not valid
     */
    fn verifyMainPrototype (self, dmut context : &Validator, funcLoc : &Word, parameters : [&Value], retType : &Type)
        throws &ErrorMsg
    {
        let dmut errors = Vec!{&ErrorMsg}::new ();
        if (parameters.len > 1us) {
            errors:.push (ErrorMsg::fatal (parameters [1us].getLoc (),
                                           ValidateErrorMessage::MAIN_FUNCTION_ONE_ARG));
        } else if (parameters.len == 1us) {
            let test = SliceType::new (funcLoc, SliceType::new (funcLoc, CharType::new (funcLoc, size-> 8u16)));
            {
                context:.verifyCompatibleTypeWithValue (parameters [0].getLoc (), test, parameters [0], byReference-> false);
            } catch {
                err : &ErrorMsg => { errors:.push (err); }
            }
        }

        match retType {
            VoidType () => {}
            _ => {
                let test = IntType::new (funcLoc, size-> 32u16, signed-> true);
                {
                    context:.verifyCompatibleType (retType.getLoc (), test.getLoc (), test, retType);
                } catch {
                    err : &ErrorMsg => { errors:.push (err); }
                }   
            }
        }

        if (errors.len () != 0us) throw ErrorMsg::list (errors[]);
    }
    

    /**
     * Validate a parameter of a prototype
     * @params: 
     *    - context: the context of the validation
     *    - param: the parameter to validate
     *    - noValue: true iif we are recursevely validating and thus the value must not be validated (cf. Recursive default parameters)
     * @throws: &ErrorMsg, if there is an error
     * @returns: 
     *    - .0: true iif the parameter is declared mutable
     *    - .1: true iif the parameters is declared as a reference
     *    - .2: the type of the parameter
     *    - .3: the value of the parameter
     */
    fn validateParamDecl (self, dmut context : &Validator, vdecl : &VarDeclExpr, noValue : bool = false)-> (bool, bool, bool, &Type, &Value)
        throws &ErrorMsg
    {
        let type = {
            context:.validateTypeForVarDecl (vdecl.getType (), vdecl, canBeRef-> true, canBeLazy-> true)
        } catch {
            err : &ErrorMsg => throw ErrorMsg::note (vdecl.getLoc (), ValidateErrorMessage::VALIDATING, notes-> [err]);
        };

        let value : &Value = if !vdecl.getValue ().isOf!{&EmptyExpression} () && !noValue {
            if (vdecl.getLoc () == Keys::UNDER) { // variable with a default value must have a name, otherwise it is impossible to change them
                throw ErrorMsg::fatal (vdecl.getLoc (), ValidateErrorMessage::DEFAULT_VAR_NO_NAME, notes-> [ErrorMsg::note (vdecl.getValue ().getLoc (), ""s8)]);
            }

            context:.validateValue (vdecl.getLoc (), vdecl.getValue (), type-> type)
        } else {
            cast!{&Value} (UNIT_VALUE)
        }

        if (type.isMutable () && !type.needExplicitAlias () && !type.isMovable () && !vdecl.isRef ()) {
            throw ErrorMsg::fatal (vdecl.getMutOrDmutLocation (), ValidateErrorMessage::MUTABLE_CONST_PARAM);
        }

        context.verifyNonVoidType (vdecl.getType ().getLoc (), type, true);
        return (type.isMutable (), vdecl.isRef (), vdecl.isLazy (), type, value);
    }

    /**
     * Validate a parameter of a template prototype
     * @params: 
     *    - context: the context of the validation
     *    - param: the parameter to validate
     *    - noValue: true iif we are recursevely validating and thus the value must not be validated (cf. Recursive default parameters)
     * @returns: 
     *    - .0: true iif the parameter is declared mutable
     *    - .1: the type of the parameter (can be none, if the validation failed)
     *    - .2: the value of the parameter (can be none if there is none, or the validation failed)
     */
    pub fn validateTemplateParamDecl (self, dmut context : &Validator, vdecl : &VarDeclExpr, noValue : bool = false)-> (bool, bool, bool, &Type, &Value) {
        let type = {
            context:.validateTypeForVarDecl (vdecl.getType (), vdecl, canBeRef-> true, canBeLazy-> true)
        } catch {
            _ => {
                cast!{&Type} (NONE_TYPE)
            }
        };

        let value : &Value = if !vdecl.getValue ().isOf!{&EmptyExpression} () && !noValue {
            {
                context:.validateValue (vdecl.getLoc (), vdecl.getValue (), type-> type)
            } catch {
                _ => {
                    // we put something, because we don't want the value to be set automatically
                    // It must be named, even if we don't know yet what it is it's default value, template specialization will tell
                    cast!{&Value} (TemplateDefaultValue::new (vdecl.getValue ().getLoc ()))
                }
            }
        } else {
            cast!{&Value} (UNIT_VALUE)
        }

        return (type.isMutable (), vdecl.isRef (), vdecl.isLazy (), type, value);
    }
    
    /**
     * Validate the self parameter of a method prototype
     * @params: 
     *   - param: the self parameter
     *   - clRef: the type of the class used
     * @returns: the protovar value
     */
    fn validateSelfParamDecl (self, vdecl : &VarDeclExpr, clRef : &ClassRefType)-> &ProtoVarValue
        throws &ErrorMsg
    {
        let isMutable = vdecl.isMutable ();
        if (!vdecl.getLazyOrRefLocation ().isEof ()) { // ref,lazy self has no meaning
            throw ErrorMsg::fatal (vdecl.getLazyOrRefLocation (), format (ValidateErrorMessage::UNDEF_DECORATOR_TYPE, vdecl.getLazyOrRefLocation ().str ()));
        }

        if (vdecl.isDeeplyMutable ()) { // dmut self neither
            throw ErrorMsg::fatal (vdecl.getDeeplyMutableLocation (), format (ValidateErrorMessage::UNDEF_DECORATOR_TYPE, vdecl.getDeeplyMutableLocation ().str ()));
        }

        let clPtr = clRef.createInstance (isMutable, isMutable); // mut in that case means dmut
        ProtoVarValue::new (vdecl.getLoc (), clPtr, UNIT_VALUE, isMutable, isSelf-> true, isReference-> clRef.isStruct ()) // returns the protovar
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================           UNITTEST           =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a unit test
     * @params: 
     *   - context: the context of the validation
     *   - sym: the symbol to validate
     *   - uid: the uniq id of the unittest in the local module
     */
    pub fn validateTest (self, dmut context : &Validator, dmut sym : &UnitTestSymbol, uid : usize)
        throws &ErrorMsg
    {
        context:.pushReferent (alias sym);
        context:.enterForeign (isFnBody-> false);

        let mut hasErrors = false;
        let dmut errors = Vec!{&ErrorMsg}::new ();
        let body = {
            context:.enterBlock ();
            context:.enterFunctionBody ();
            context:.setFunctionReturn (VoidType::new (sym.getLoc ()));

            context:.validateValue (sym.getContent ().getBody ())
        } catch {
            err : &ErrorMsg => {
                errors:.push (err);
                cast!{&Value} (UNIT_VALUE)
            }
        } exit {
            {
                context:.quitBlock (warnUnused-> !hasErrors);
            } catch {
                err : &ErrorMsg => { errors:.push (err); }
            }
        };

        context:.exitForeign ();
        context:.popReferent ();

        if (errors.len () != 0us) throw ErrorMsg::list (errors[]);

        let path = sym.getPath ().push (format ("%", uid));
        let gen = UnitTestGenerator::new (sym.getLoc (), path, body);
        context:.insertGenerator (alias sym, gen);
    }


    /*!
     * ================================================================================
     * ================================================================================
     * ==========================           COMMON           ==========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * @returns: the location of the unsafe attributes or EOF_WORD if none exist
     * */
    fn getUnsafeLoc (self, attributes : [AttributeWord])-> &Word {
        for it in attributes {
            if (it.attr == Attributes::UNSAFE) {
                return it.loc;
            }
        }

        EOF_WORD
    }

    /**
     * @returns: the location of the field attributes or EOF_WORD if none exist
     * */
    fn getFieldLoc (self, attributes : [AttributeWord])-> &Word {
        for it in attributes {
            if (it.attr == Attributes::FIELD) {
                return it.loc;
            }
        }

        EOF_WORD
    }

    /**
     * verify that attributes are applicable to a function
     * @params:
     *    - attributes: the list of attributes
     * */
    fn verifyUndefAttributes (self, attributes : [AttributeWord])
        throws &ErrorMsg
    {
        let dmut errors = Vec!{&ErrorMsg}::new ();
        for it in attributes match it.attr {
            Attributes::UNSAFE => {}
            Attributes::INLINE => {}
            _ => { errors:.push (ErrorMsg::fatal (it.loc, format (ValidateErrorMessage::UNDEFINED_ATTRIBUTE, it.attr)));  }
        }

        if (errors.len () != 0us) throw ErrorMsg::list (errors []);
    }

    /**
     * verify that attributes are applicable to a dtor
     * @params:
     *    - attributes: the list of attributes
     * */
    fn verifyUndefAttributesDtor (self, attributes : [AttributeWord])
        throws &ErrorMsg
    {
        let dmut errors = Vec!{&ErrorMsg}::new ();
        for it in attributes {
            errors:.push (ErrorMsg::fatal (it.loc, format (ValidateErrorMessage::UNDEFINED_ATTRIBUTE, it.attr)));
        }

        if (errors.len () != 0us) throw ErrorMsg::list (errors []);
    }

    /**
     * verify that attributes are applicable to a method
     * @params:
     *    - attributes: the list of attributes
     * */
    fn verifyUndefAttributesMethod (self, attributes : [AttributeWord])
        throws &ErrorMsg
    {
        let dmut errors = Vec!{&ErrorMsg}::new ();
        for it in attributes match it.attr {
            Attributes::UNSAFE => {}
            Attributes::FINAL  => {}
            Attributes::INLINE => {}
            Attributes::FIELD  => {}
            _ => { errors:.push (ErrorMsg::fatal (it.loc, format (ValidateErrorMessage::UNDEFINED_ATTRIBUTE, it.attr)));  }
        }

        if (errors.len () != 0us) throw ErrorMsg::list (errors []);
    }


}
