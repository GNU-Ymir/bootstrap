mod ymirc::semantic::validator::symbol::function;

import ymirc::semantic::validator::visitor;
import ymirc::semantic::validator::errors;
import ymirc::semantic::symbol::_;
import ymirc::syntax::declaration::protection;
import ymirc::syntax::expression::_;
import ymirc::syntax::declaration::_;

import ymirc::syntax::keys;
import ymirc::semantic::generator::_;
import ymirc::errors::_;
import ymirc::utils::format;
import ymirc::lexing::word;

import std::collection::vec;
import std::collection::set;
import std::io, std::fs::path;

/**
 * The function validator is the class responsible for function symbol validation
 */
pub class FunctionValidator {

    /// The list of validating symbol, to avoid infinite value call recursion (foo (a = bar()), bar (a = foo ()))
    let dmut _validating = HashSet!{&Symbol}::new ();
    
    /**
     * Create a new empty validator
     */
    pub self () {}


    /**
     * Validate a function
     * @params: 
     *   - context: the context of the validation
     *   - sym: the function to validate
     */
    pub def validate (mut self, dmut context : &Validator, dmut sym : &FunctionSymbol)
        throws &ErrorMsg
    {
        context:.pushReferent (alias sym);
        context:.enterForeign (isFnBody-> false);
        if (sym.isTest ()) self.validateTest (alias context, alias sym);
        else self:.validateFunction (alias context, alias sym);                
    } exit {
        context:.exitForeign ();
        context:.popReferent ();
    } catch {
        err : &ErrorMsg => {
            throw ErrorMsg::fatal (sym.getLoc (), format (ValidateErrorMessage::VALIDATING_SYMBOL, sym.getPath ().toStr (sep-> "::"s8)), notes-> [err]);
        }
    }


    /**
     * Validate the prototype of a function
     * @params: 
     *    - context: the context of the validation
     *    - sym: the symbol to validate
     * @returns: a callable prototype of function
     * @throws: &ErrorMsg, if the function is malformed
     */
    pub def validatePrototype (mut self, dmut context : &Validator, dmut sym : &FunctionSymbol)-> &PrototypeValue
        throws &ErrorMsg
    {
        match (sym.getFrameProto ()) {
            EmptyGenerator () => {
                context:.pushReferent (alias sym);
                context:.enterForeign (isFnBody-> false);
                let ret = {
                    self:.validateFunction (alias context, alias sym, validateBody-> false)
                } exit {
                    context:.exitForeign ();
                    context:.popReferent ();
                } catch {
                    err : &ErrorMsg => {
                        throw ErrorMsg::fatal (sym.getLoc (), format (ValidateErrorMessage::VALIDATING_SYMBOL, sym.getPath ().toStr (sep-> "::"s8)), notes-> [err]);
                    }                    
                };

                ret
            }
            v : &PrototypeValue => 
                return v;            
            g : _ => {
                println ("What is inside the function ???", g::typeinfo.name);
                __pragma!panic ();
            }
        }
    }


    /**
     * Validate the prototype of a constructor
     * @params: 
     *    - context: the context of the validation
     *    - sym: the symbol to validate
     * @returns: a callable prototype of function
     * @throws: &ErrorMsg, if the constructor is malformed
     */
    pub def validatePrototype (mut self, dmut context : &Validator, dmut sym : &ConstructorSymbol)-> &Value
        throws &ErrorMsg
    {
        context;
        sym;
        __pragma!fake_throw (&ErrorMsg);
        __pragma!panic ();
    }

    /**
     * Validate a method prototype defined inside a trait symbol
     * @params: 
     *   - context: the context of the validation
     *   - sym: the function to validate
     *   - clRef: the type of the class (used for the self parameter)
     *   - traitRef: the trait that defines the method
     * @returns: the prototype of the method
     * @throws:
     *   - &ErrorMsg: if the validation fails
     */
    pub def validateMethodPrototype (mut self, dmut context : &Validator, dmut sym : &FunctionSymbol, clRef : &ClassRefType, traitRef : &TraitRefType)-> &MethodPrototypeValue
        throws &ErrorMsg
    {
        match (sym.getFrameProto ()) {
            EmptyGenerator () => {
                context:.pushReferent (alias sym);
                context:.enterForeign (isFnBody-> false);
                let ret = {
                    self:.validateMethod (alias context, alias sym, clRef, fromTrait-> traitRef.getSymbol (), validateBody-> false)
                } exit {
                    context:.exitForeign ();
                    context:.popReferent ();
                } catch {
                    err : &ErrorMsg => {
                        throw ErrorMsg::fatal (sym.getLoc (), format (ValidateErrorMessage::VALIDATING_SYMBOL, sym.getPath ().toStr (sep-> "::"s8)), notes-> [err]);
                    }                    
                };

                ret
            }
            v : &MethodPrototypeValue => {
                v
            }
            g : _ => {
                println ("What is inside the function ???", g::typeinfo.name);
                __pragma!panic ();
            }
        }
    }

    /**
     * Validate a method prototype defined inside a trait symbol
     * @params: 
     *   - context: the context of the validation
     *   - sym: the function to validate
     *   - clRef: the type of the class (used for the self parameter)
     *   - traitRef: the trait that defines the method
     * @returns: the prototype of the method
     * @throws:
     *   - &ErrorMsg: if the validation fails
     */
    pub def validateMethodPrototype (mut self, dmut context : &Validator, dmut sym : &FunctionSymbol, clRef : &ClassRefType)-> &MethodPrototypeValue
        throws &ErrorMsg
    {
        match (sym.getFrameProto ()) {
            EmptyGenerator () => {
                context:.pushReferent (alias sym);
                context:.enterForeign (isFnBody-> false);
                let ret = {
                    self:.validateMethod (alias context, alias sym, clRef, fromTrait-> EMPTY_SYMBOL, validateBody-> false)
                } exit {
                    context:.exitForeign ();
                    context:.popReferent ();
                } catch {
                    err : &ErrorMsg => {
                        throw ErrorMsg::fatal (sym.getLoc (), format (ValidateErrorMessage::VALIDATING_SYMBOL, sym.getPath ().toStr (sep-> "::"s8)), notes-> [err]);
                    }                    
                };

                ret
            }
            v : &MethodPrototypeValue => {
                v
            }
            g : _ => {
                println ("What is inside the function ???", g::typeinfo.name);
                __pragma!panic ();
            }
        }
    }
    
    /**
     * ================================================================================
     * ================================================================================
     * =========================           FUNCTION           =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a normal function
     * @params: 
     *    - context: the context of the validation
     *    - sym: the symbol to validate
     * @returns: the prototype of the function
     */        
    def validateFunction (mut self, dmut context : &Validator, dmut sym : &FunctionSymbol, validateBody : bool = true)-> &PrototypeValue
        throws &ErrorMsg
    {        
        let func = sym.getContent ();       
        let dmut errors = Vec!{&ErrorMsg}::new ();
        let throwers = self.validateThrowers (alias context, func.getThrowers (), alias errors);
        
        let (retType, parameters, body, needFinalReturn) = {            
            context:.enterBlock ();
            let (retType, parameters) = match sym.getFrameProto () {
                p : &PrototypeValue => {
                    (p.getRetType (), p.getParameters ())
                }
                _ => {
                    self:.validatePrototype (alias context, sym, func.getFunctionProto ())
                }
            }

            
            if (func.getLoc ().str () == Keys::MAIN && validateBody) {
                self.verifyMainPrototype (alias context, func.getLoc (), parameters, retType, alias errors);
            }

            let (body, needFinalReturn) = if (validateBody) {
                context:.enterFunctionBody ();
                self.validateBody (alias context, func.getLoc (), sym.getPath (), func.getBody (), retType, throwers, alias errors)
            } else {
                (cast!{&Value} (UnitValue::new ()), false)
            }
            
            (retType, parameters, body, needFinalReturn)
        } exit {
            {
                if (!validateBody) context:.clearLocalScope ();
                context:.quitBlock ();
            } catch {
                err : &ErrorMsg => { errors:.push (err); }
            }
        } catch {
            err : &ErrorMsg => {
                throw err;
            }
        }

        if (errors.len () != 0us) throw ErrorMsg::list (errors[]);
        if (validateBody) {
            match func.getBody () {
                EmptyExpression () => {}
                _ => {
                    let frame = FrameGenerator::new (func.getLoc (), sym.getPath (), parameters, retType, body, needFinalReturn-> needFinalReturn, externLang-> sym.getExternalLanguage (), isWeak-> sym.isWeak ());
                    context:.insertNewGenerator (frame);
                }
            }
        }

        match sym.getFrameProto () {
            p : &PrototypeValue => { p }
            _ => {
                let gen = PrototypeValue::new (sym.getLoc (), sym, parameters, retType, throwers);
                if (validateBody) { // If not validate body the prototype might be uncomplete
                    sym:.setFrameProto (gen);
                }
                
                gen
            }
        }
    }

    /**
     * Validate the body of a function
     * @params: 
     *     - context: the context of the validation
     *     - loc: the location of the function
     *     - name: the name of the function
     *     - body: the body of the function
     *     - throwers: the list of throwers
     * @returns: 
     *    - errors: the list of errors 
     *    - .0: the validated value of the body
     *    - .1: true iif the value is not a returner
     */
    def validateBody (self, dmut context : &Validator, loc : &Word, name : &Path, body : &Expression, retType : &Type, throwers : [&Type], dmut errors : &Vec!{&ErrorMsg})-> (&Value, bool)        
    {
        match body {
            EmptyExpression () => {
                context:.clearLocalScope ();
                (UnitValue::new (loc-> loc), false)
            }
            _ => {
                {
                    context:.setFunctionReturn (retType);
                    let bodyValue = context:.validateValue (body);
                    let need = if (!bodyValue.isReturner ()) {
                        if (retType.getLoc ().isEof ()) {
                            context:.verifyMemoryOwner (bodyValue.getLoc (), retType, bodyValue);
                        } else
                            context:.verifyMemoryOwner (retType.getLoc (), retType, bodyValue);
                        
                        match retType {
                            VoidType () => { false }
                            _ => { true }
                        }
                    } else { false };
                    
                    self.verifyThrowing (alias context, loc, name, bodyValue.getThrowers (), throwers, alias errors);
                    (bodyValue, need)
                } catch {
                    err : &ErrorMsg => {
                        errors:.push (err);
                        (UnitValue::new (loc-> loc), false)
                    }
                }
            }
        }
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================           METHODS            =========================
     * ================================================================================
     * ================================================================================
     */


    /**
     * Validate a method
     * @params: 
     *    - context: the context of the validation
     *    - sym: the symbol to validate
     *    - clRef: the type of the class defining the method
     *    - fromTrait: the symbol of the trait if this method is defined inside a trait, (EmptySymbol otherwise)
     *    - validateBody: true iif the body must be validated
     * @returns: the prototype of the method
     */        
    def validateMethod (mut self, dmut context : &Validator, dmut sym : &FunctionSymbol, clRef : &ClassRefType, fromTrait : &Symbol, validateBody : bool = false)-> &MethodPrototypeValue
        throws &ErrorMsg
    {
        let func = sym.getContent ();
        let dmut errors = Vec!{&ErrorMsg}::new ();
        let throwers = self.validateThrowers (alias context, func.getThrowers (), alias errors);
        
        let (retType, selfParam, parameters, body, needFinalReturn) = {            
            context:.enterBlock ();
            let selfParam = self.validateSelfParamDecl (func.getFunctionProto ().getParameters()[0], clRef);
            context:.insertLocal (selfParam.getLoc ().str (), selfParam);
            
            let (retType, parameters) = match sym.getFrameProto () {
                p : &PrototypeValue => {
                    (p.getRetType (), p.getParameters ())
                }
                _ => {
                    self:.validatePrototype (alias context, sym, func.getFunctionProto (), forMethod-> true)
                }
            }

            
           
            let (body, needFinalReturn) = if (validateBody) {
                context:.enterFunctionBody ();
                self.validateBody (alias context, func.getLoc (), sym.getPath (), func.getBody (), retType, throwers, alias errors)
            } else {
                (cast!{&Value} (UnitValue::new ()), false)
            }
            
            (retType, selfParam, [selfParam] ~ parameters, body, needFinalReturn)
        } exit {
            {
                if (!validateBody) context:.clearLocalScope ();
                context:.quitBlock ();
            } catch {
                err : &ErrorMsg => { errors:.push (err); }
            }
        } catch {
            err : &ErrorMsg => {
                throw err;
            }
        }

        if (errors.len () != 0us) throw ErrorMsg::list (errors[]);
        if (validateBody) {
            match func.getBody () {
                EmptyExpression () => {}
                _ => {
                    let frame = FrameGenerator::new (func.getLoc (), sym.getPath (), parameters, retType, body, needFinalReturn-> needFinalReturn, externLang-> sym.getExternalLanguage (), isWeak-> sym.isWeak ());
                    context:.insertNewGenerator (frame);
                }
            }
        }

        match sym.getFrameProto () {
            p : &MethodPrototypeValue => { p }
            _ => {
                let gen = MethodPrototypeValue::new (sym.getLoc (), sym, parameters, retType, throwers, clRef, trRef-> fromTrait, isMutable-> selfParam.getType ().isMutable (), isFinal-> sym.isFinal (), isEmpty-> func.getBody ().isOf!{&EmptyExpression} (), isOver-> sym.isOver ());
                if (validateBody) { // If not validate body the prototype might be uncomplete
                    sym:.setFrameProto (gen);
                }
                
                gen
            }
        }
    }
        
   
    
    /**
     * ================================================================================
     * ================================================================================
     * =========================           THROWERS           =========================
     * ================================================================================
     * ================================================================================
     */
    
    /**
     * Validate the throwers a function
     * @params: 
     *    - context: the context of the validation
     *    - throwers: the list of throwers
     * @returns: 
     *    - errors: the list of errors that occurs in the validation
     *    - the list of throwers
     */
    def validateThrowers (self, dmut context : &Validator, throwers : [&Expression], dmut errors : &Vec!{&ErrorMsg})-> [&Type] {
        let dmut rets = Vec!{&Type}::new ();
        for i in throwers {
            {
                rets:.push (context:.validateType (i));
            } catch {
                err : &ErrorMsg => { errors:.push (err); }
            }
        }

        rets[]
    }

    /**
     * Verify that the declared throws and the actual thrown of the function are similar
     * @params: 
     *    - context: the context of the function
     *    - loc: the location of the definition of the function
     *    - name: the name of the function
     *    - thrown: the list of type that are thrown by the body
     *    - expected: the list of type that are declared in the prototype as throws
     * @returns: 
     *     - errors: the list of errors during the validation
     */
    def verifyThrowing (self, dmut context : &Validator, loc : &Word, name : &Path, thrown : [&Type], expected : [&Type], dmut errors : &Vec!{&ErrorMsg}) {
        context;
        loc;
        name;
        thrown;
        expected;
        errors;
    }        
    
    /**
     * ================================================================================
     * ================================================================================
     * =========================          PROTOTYPE           =========================
     * ================================================================================
     * ================================================================================
     */
    
    /**
     * Validate the prototype of a frame for generation
     * @params: 
     *   - context: the context of the validation
     *   - sym: the symbol being validated
     *   - proto: the prototype to validate
     *   - forMethod: true iif the validation is intended to create a method prototype
     * @returns:
     *    - .0: the return type of the prototype
     *    - .1: the list of parameters
     * @throws: &ErrorMsg, if there is a malformed parameter, or the return type is malformed
     */
    def validatePrototype (mut self, dmut context : &Validator, sym : &FunctionSymbol, proto : &FunctionProtoDecl, forMethod : bool = false)-> (&Type, [&ProtoVarValue])
        throws &ErrorMsg
    {
        let dmut parameters = Vec!{&ProtoVarValue}::new ();
        let dmut errors = Vec!{&ErrorMsg}::new ();
        
        let noValue = sym in self._validating;
        self._validating:.insert (sym);
        {
            for i, param in proto.getParameters () {
                if (i != 0us || !forMethod) { // If we validate the prototype for a method, we don't validate the first parameter (which is always self)
                    let (isMutable, type, value) = self.validateParamDecl (alias context, param, noValue-> noValue);                
                    let paramGen = ProtoVarValue::new (param.getLoc (), type, value, isMutable, isSelf-> false);
                    parameters:.push (paramGen);
                    
                    if (param.getLoc ().str () != Keys::UNDER) {
                        context:.verifyShadow (paramGen.getLoc ());
                        context:.insertLocal (paramGen.getLoc ().str (), paramGen);
                    }
                } catch {
                    err : &ErrorMsg => {
                        errors:.push (err);
                    }
                }
            }
        } exit {
            self._validating:.remove (sym);
        }

        let r : &Type = {
            match proto.getRetType () {
                e : &EmptyExpression => { cast!{&Type} (VoidType::new (e.getLoc ())) }
                x : _ => { context:.validateType (x) }
            }
        } catch {
            err : &ErrorMsg => {
                errors:.push (err);
                throw ErrorMsg::list (errors[]);
            }
        }
        
        if (errors.len () != 0us) throw ErrorMsg::list (errors[]);
        (r, parameters[])          
    }

    /**
     * Verify that the prototype is correct for the main function
     * @params: 
     *   - funcLoc: the location of the function definition
     *   - proto: the prototype of the frame 
     *   - parameters: the validated parameters of the function
     *   - retType: the return type of the function
     * @returns:
     *    - errors: add errors if the prototype is not valid
     */
    def verifyMainPrototype (self, dmut context : &Validator, funcLoc : &Word, parameters : [&Value], retType : &Type, dmut errors : &Vec!{&ErrorMsg}) {
        if (parameters.len > 1us) {
            errors:.push (ErrorMsg::fatal (parameters [1us].getLoc (),
                                           ValidateErrorMessage::MAIN_FUNCTION_ONE_ARG));
        } else if (parameters.len == 1us) {
            let test = SliceType::new (funcLoc, SliceType::new (funcLoc, CharType::new (funcLoc, size-> 8u16)));
            {
                context:.verifyCompatibleTypeWithValue (parameters [0].getLoc (), test, parameters [0]);
            } catch {
                err : &ErrorMsg => { errors:.push (err); }
            }
        }

        match retType {
            VoidType () => {}
            _ => {
                let test = IntType::new (funcLoc, size-> 32u16, signed-> true);
                {
                    context:.verifyCompatibleType (retType.getLoc (), test.getLoc (), test, retType);
                } catch {
                    err : &ErrorMsg => { errors:.push (err); }
                }   
            }
        }        
    }
    

    /**
     * Validate a parameter of a prototype
     * @params: 
     *    - context: the context of the validation
     *    - param: the parameter to validate
     *    - noValue: true iif we are recursevely validating and thus the value must not be validated (cf. Recursive default parameters)
     * @throws: &ErrorMsg, if there is an error
     * @returns: 
     *    - .0: true iif the parameter is declared mutable
     *    - .1: the type of the parameter
     *    - .2: the value of the parameter
     */
    def validateParamDecl (self, dmut context : &Validator, param : &Expression, noValue : bool = false)-> (bool, &Type, &Value)
        throws &ErrorMsg
    {
        match param {
            vdecl : &VarDeclExpr => {
                let type : &Type = {
                    context:.validateType (vdecl.getType (), decos-> vdecl.getDecos ())
                } catch {
                    err : &ErrorMsg => throw ErrorMsg::note (param.getLoc (), ValidateErrorMessage::VALIDATING, notes-> [err]);
                }                
                
                let value : &Value = if !vdecl.getValue ().isOf!{&EmptyExpression} () && !noValue {
                    context:.validateValue (vdecl.getLoc (), vdecl.getValue (), type-> type)
                } else {                    
                    cast!{&Value} (NoneValue::new ())                    
                }

                
                if (type.isMutable () && !type.needExplicitAlias ()) {
                    throw ErrorMsg::fatal (vdecl.getLoc (), ValidateErrorMessage::MUTABLE_CONST_PARAM);
                }

                match type {
                    VoidType () => throw ErrorMsg::fatal (vdecl.getLoc (), format (ValidateErrorMessage::DECLARE_VOID_VAR, type));
                    NoneType () => throw ErrorMsg::fatal (vdecl.getLoc (), format (ValidateErrorMessage::DECLARE_VOID_VAR, type));
                    TemporaryType () => throw ErrorMsg::fatal (vdecl.getLoc (), format (ValidateErrorMessage::INCOMPLETE_TYPE, type));
                }


                return (type.isMutable (), type, value);
            }
            _ => {
                println ("TODO : ", param::typeinfo.name);
                __pragma!panic ();
            }
        }
    }

    /**
     * Validate the self parameter of a method prototype
     * @params: 
     *   - param: the self parameter
     *   - clRef: the type of the class used
     * @returns: the protovar value
     */
    def validateSelfParamDecl (self, param : &Expression, clRef : &ClassRefType)-> &ProtoVarValue
        throws &ErrorMsg
    {
        match param {
            vdecl : &VarDeclExpr => {
                let mut isMutable = false;
                for i in vdecl.getDecos () match i.deco { // The only decorator that has a meaning is MUT
                    Decorators::MUT => { isMutable = true; }
                    _ => {
                        throw ErrorMsg::fatal (i.loc, format (ValidateErrorMessage::UNDEF_DECORATOR_TYPE, i.deco));
                    }
                }

                let clPtr = match clRef.clone (isMutable-> isMutable) {
                    nRef : &ClassRefType => {                    
                        ClassPtrType::new (param.getLoc (), nRef, isMutable-> isMutable) // mut in that case means dmut
                    }
                    _ => __pragma!panic ();
                };
                
                ProtoVarValue::new (param.getLoc (), clPtr, NoneValue::new (), isMutable, isSelf-> true) // returns the protovar
            }
            _ => { // mmh, that's not usable as a self parameter, unless its a varexpr ? no it cannot
                __pragma!panic ();
            }
        }
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================           UNITTEST           =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a unit test
     * @params: 
     *   - context: the context of the validation
     *   - sym: the symbol to validate
     */
    def validateTest (self, dmut context : &Validator, dmut sym : &FunctionSymbol)
        throws &ErrorMsg
    {
        context;
        sym;
        println ("TODO");
        __pragma!fake_throw (&ErrorMsg);
        __pragma!panic ();
    }
    
}
