mod ymirc::semantic::validator::symbol::function;

import ymirc::semantic::validator::visitor;
import ymirc::semantic::validator::template::rewrite;
import ymirc::semantic::validator::errors;
import ymirc::semantic::symbol::_;
import ymirc::syntax::declaration::protection;
import ymirc::syntax::expression::_;
import ymirc::syntax::declaration::_;

import ymirc::syntax::keys;
import ymirc::semantic::generator::_;
import ymirc::errors::_;
import ymirc::utils::format;
import ymirc::lexing::word;

import std::collection::vec;
import std::collection::set;
import std::io, std::fs::path;

/**
 * The function validator is the class responsible for function symbol validation
 */
pub class FunctionValidator {

    /// The list of validating symbol, to avoid infinite value call recursion (foo (a = bar()), bar (a = foo ()))
    let dmut _validating = HashSet!{&Symbol}::new ();
    
    /**
     * Create a new empty validator
     */
    pub self () {}


    /**
     * Validate a function
     * @info: insert the generator in the context for "generation"
     * @params: 
     *   - context: the context of the validation
     *   - sym: the function to validate
     * @throws: 
     *    - &ErrorMsg: if the func is not valid
     */
    pub def validate (mut self, dmut context : &Validator, dmut sym : &FunctionSymbol)
        throws &ErrorMsg
    {
        context:.pushReferent (alias sym);
        context:.enterForeign (isFnBody-> false);

        {
            // There are two types of function
            // 1) unittest (uncallable)
            if (sym.isTest ()) self.validateTest (alias context, alias sym);

            // 2) callable functions
            else self:.validateFunction (alias context, alias sym);
        }  catch {
            err : &ErrorMsg => {
                context:.exitForeign ();
                context:.popReferent ();
                throw ErrorMsg::fatal (sym.getLoc (), format (ValidateErrorMessage::VALIDATING_SYMBOL, sym.getPath ().toStr (sep-> "::"s8)), notes-> [err]);
            }
        }
        
        context:.exitForeign ();
        context:.popReferent ();
    }

    /**
     * Validate a constructor symbol
     * @info: insert the generator in the context for "generation"
     * @params: 
     *    - context: the context of the validation
     *    - sym: the symbol to validate
     *    - clRef: the type of the class containing the ctor
     * @throws: 
     *    - &ErrorMsg: if the ctor is not valid
     */
    pub def validate (mut self, dmut context : &Validator, dmut sym : &ConstructorSymbol, clRef : &ClassRefType)
        throws &ErrorMsg
    {
        context:.pushReferent (alias sym);
        context:.enterForeign (isFnBody-> false, clContext-> clRef);
        {
            // Only one kind of constructor
            self:.validateConstructor (alias context, alias sym, clRef, validateBody-> true);
        }  catch {
            err : &ErrorMsg => {
                context:.exitForeign ();
                context:.popReferent ();
                throw ErrorMsg::fatal (sym.getLoc (), format (ValidateErrorMessage::VALIDATING_SYMBOL, sym.getPath ().toStr (sep-> "::"s8)), notes-> [err]);
            }
        }
        
        context:.exitForeign ();
        context:.popReferent ();
    }

    /**
     * Fully validate a method definition  (not just the prototype)
     * @params: 
     *    - context: the context of the validation
     *    - sym: the method to validate
     *    - clRef: the type of self in the method
     * @throws:
     *     - &ErrorMsg: if there was an error in the validation
     */
    pub def validateMethod (mut self, dmut context : &Validator, dmut sym : &FunctionSymbol, clRef : &ClassRefType)
        throws &ErrorMsg
    {
        context:.pushReferent (alias sym);
        context:.enterForeign (isFnBody-> false, clContext-> clRef);

        {
            // Only one kind of method
            // We don't care if it was defined inside a trait, we don't use the method prototype that is generated
            self:.validateMethod (alias context, alias sym, clRef, fromTrait-> EMPTY_SYMBOL, validateBody-> true);
        } catch {
            err : &ErrorMsg => {
                context:.exitForeign ();
                context:.popReferent ();
                throw ErrorMsg::fatal (sym.getLoc (), format (ValidateErrorMessage::VALIDATING_SYMBOL, sym.getPath ().toStr (sep-> "::"s8)), notes-> [err]);
            }
        }
        
        context:.exitForeign ();
        context:.popReferent ();
    }
    
    /**
     * ================================================================================
     * ================================================================================
     * =========================          PROTOTYPES          =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate the prototype of a function
     * @params: 
     *    - context: the context of the validation
     *    - sym: the symbol to validate
     * @returns: a callable prototype of function
     * @throws: &ErrorMsg, if the function is malformed
     */
    pub def validateFuncPrototype (mut self, dmut context : &Validator, dmut sym : &FunctionSymbol)-> &PrototypeValue
        throws &ErrorMsg
    {
        match (sym.getFrameProto ()) {
            EmptyGenerator () => {
                let ret = {
                    context:.pushReferent (alias sym);
                    context:.enterForeign (isFnBody-> false);
                    
                    self:.validateFunction (alias context, alias sym, validateBody-> false)
                } catch {
                    err : &ErrorMsg => {
                        context:.exitForeign ();
                        context:.popReferent ();
                        throw ErrorMsg::fatal (sym.getLoc (), format (ValidateErrorMessage::VALIDATING_SYMBOL, sym.getPath ().toStr (sep-> "::"s8)), notes-> [err]);
                    }                    
                } exit {                
                    context:.exitForeign ();
                    context:.popReferent ();
                }

                ret
            }
            v : &PrototypeValue => 
                return v;            
            g : _ => {
                println ("What is inside the function ???", g::typeinfo.name);
                __pragma!panic ();
            }
        }
    }

    /**
     * Validate a prototype of a symbol that is not declared, as it comes from a template rewrite
     * @params: 
     *    - context: the context of the validation
     *    - sym: the symbol declaring the template definition
     *    - func: the rewritten function declaration
     *    - rewriter: the template rewriter
     * @returns: the validate prototype value of the function
     * @throws:
     *    - &ErrorMsg: if the validation fails
     */
    pub def validateFuncPrototypeFromTemplate (mut self, dmut context : &Validator, dmut sym : &Symbol, func : &FunctionDecl, rewriter : &TemplateRewriter)-> &PrototypeValue
        throws &ErrorMsg
    {
        let dmut errors = Vec!{&ErrorMsg}::new ();
        
        context:.pushReferent (alias sym);
        context:.enterForeign (isFnBody-> false);

        let throwers = self.validateThrowers (alias context, func.getThrowerLoc (), func.getThrowers (), alias errors);        
        let (retType, parameters) = {            
            context:.enterBlock ();
            {
                {
                    self:.validatePrototype (alias context, sym, func.getFunctionProto ())      
                } catch {
                    err : &ErrorMsg => {
                        errors:.push (ErrorMsg::fatal (sym.getLoc (), format (ValidateErrorMessage::VALIDATING_SYMBOL, sym.getPath ().toStr (sep-> "::"s8)), notes-> [err]));
                        (NONE_TYPE, [])
                    }                    
                }
            } exit {
                {
                    context:.quitBlock (warnUnused-> false);
                } catch {
                    _ => { __pragma!panic (); }
                }
            } 
            
        } exit {        
            context:.exitForeign ();
            context:.popReferent ();
        };
        
        if (errors.len () != 0us) throw ErrorMsg::list (errors[]);
        
        PrototypeValue::new (sym.getLoc (), sym, parameters, retType, throwers, fromTemplate-> rewriter?)
    }
    
    /**
     * Validate the prototype of a constructor
     * @params: 
     *    - context: the context of the validation
     *    - sym: the symbol to validate
     *    - clRef: the type of the class that will be used as self
     * @returns: a callable prototype of function
     * @throws:
     *    - &ErrorMsg, if the constructor is malformed
     */
    pub def validateCtorPrototype (mut self, dmut context : &Validator, dmut sym : &ConstructorSymbol, clRef : &ClassRefType)-> &CtorPrototypeValue
        throws &ErrorMsg
    {
        match sym.getFrameProto () {
            EmptyGenerator () => { // probably, the prototype is computed when validating the class symbol so before class finalization                
                let ret = {
                    context:.pushReferent (alias sym);
                    context:.enterForeign (isFnBody-> false, clContext-> clRef);
                    
                    self:.validateConstructor (alias context, alias sym, clRef, validateBody-> false)
                } exit {
                    context:.exitForeign ();
                    context:.popReferent ();
                } catch {
                    err : &ErrorMsg => {
                        throw ErrorMsg::fatal (sym.getLoc (), format (ValidateErrorMessage::VALIDATING_SYMBOL, sym.getPath ().toStr (sep-> "::"s8)), notes-> [err]);
                    }                    
                };

                ret
            }
            v : &CtorPrototypeValue => {
                v
            }
            g : _ => {
                println ("What is inside the function ???", g::typeinfo.name);
                __pragma!panic ();
            }
        }
    }

    /**
     * Validate a method prototype defined inside a trait symbol
     * @params: 
     *   - context: the context of the validation
     *   - sym: the function to validate
     *   - clRef: the type of the class (used for the self parameter)
     *   - traitRef: the trait that defines the method
     * @returns: the prototype of the method
     * @throws:
     *   - &ErrorMsg: if the validation fails
     */
    pub def validateMethodPrototype (mut self, dmut context : &Validator, dmut sym : &FunctionSymbol, clRef : &ClassRefType, traitRef : &TraitRefType)-> &MethodPrototypeValue
        throws &ErrorMsg
    {
        match (sym.getFrameProto ()) {
            EmptyGenerator () => {                
                let ret = {
                    context:.pushReferent (alias sym);
                    context:.enterForeign (isFnBody-> false, clContext-> clRef);
                    
                    self:.validateMethod (alias context, alias sym, clRef, fromTrait-> traitRef.getSymbol (), validateBody-> false)
                } exit {
                    context:.exitForeign ();
                    context:.popReferent ();
                } catch {
                    err : &ErrorMsg => {
                        throw ErrorMsg::fatal (sym.getLoc (), format (ValidateErrorMessage::VALIDATING_SYMBOL, sym.getPath ().toStr (sep-> "::"s8)), notes-> [err]);
                    }                    
                };
                                
                ret
            }
            v : &MethodPrototypeValue => {
                v
            }
            g : _ => {
                println ("What is inside the function ???", g::typeinfo.name);
                __pragma!panic ();
            }
        }
    }

    /**
     * Validate a method prototype defined inside a trait symbol
     * @params: 
     *   - context: the context of the validation
     *   - sym: the function to validate
     *   - clRef: the type of the class (used for the self parameter)
     *   - traitRef: the trait that defines the method
     * @returns: the prototype of the method
     * @throws:
     *   - &ErrorMsg: if the validation fails
     */
    pub def validateMethodPrototype (mut self, dmut context : &Validator, dmut sym : &FunctionSymbol, clRef : &ClassRefType)-> &MethodPrototypeValue
        throws &ErrorMsg
    {
        match (sym.getFrameProto ()) {
            EmptyGenerator () => {                
                let ret = {
                    context:.pushReferent (alias sym);
                    context:.enterForeign (isFnBody-> false, clContext-> clRef);
                    
                    self:.validateMethod (alias context, alias sym, clRef, fromTrait-> EMPTY_SYMBOL, validateBody-> false)
                } exit {                
                    context:.exitForeign ();
                    context:.popReferent ();
                } catch {
                    err : &ErrorMsg => {
                        throw ErrorMsg::fatal (sym.getLoc (), format (ValidateErrorMessage::VALIDATING_SYMBOL, sym.getPath ().toStr (sep-> "::"s8)), notes-> [err]);
                    }                    
                };
                
                ret
            }
            v : &MethodPrototypeValue => {
                v
            }
            g : _ => {
                println ("What is inside the function ???", g::typeinfo.name);
                __pragma!panic ();
            }
        }
    }

    /**
     * Validate a dtor prototype defined a class
     * @params:
     *    - context: the context of the validation
     *    - sym: the dtor to validate
     *    - clRef: the class defining the dtor
     *    - ancDtor: the prototype of the ancestor dtor (can be empty, aka NoneValue)
     * @throws:
     *     - &ErrorMsg: if there is an error in the validation
     * @returns: the prototype of the destructor
     */
    pub def validateDtorPrototype (mut self, dmut context : &Validator, dmut sym : &FunctionSymbol, clRef : &ClassRefType, ancDtor : &Value)-> &DtorPrototypeValue
        throws &ErrorMsg
    {
        match (sym.getFrameProto ()) {
            EmptyGenerator () => {
                let ret = {
                    context:.pushReferent (alias sym);
                    context:.enterForeign (isFnBody-> false, clContext-> clRef);

                    self:.validateDestructor (alias context, alias sym, clRef, validateBody-> false, ancDtor-> ancDtor)
                } exit {
                    context:.exitForeign ();
                    context:.popReferent ();
                } catch {
                    err : &ErrorMsg => {
                        throw ErrorMsg::fatal (sym.getLoc (), format (ValidateErrorMessage::VALIDATING_SYMBOL, sym.getPath ().toStr (sep-> "::"s8)), notes-> [err]);
                    }
                };

                ret
            }
            v : &DtorPrototypeValue => {
                v
            }
            g : _ => {
                println ("Unknown symbol inserted in destructor ??", g::typeinfo.name);
                __pragma!panic ();
            }
        }
    }

    
    /**
     * ================================================================================
     * ================================================================================
     * =========================           FUNCTION           =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a normal function
     * @todo: this function is way too long, and way too close to validateMethod and validateConstructor. A refactorization would be great
     * @params: 
     *    - context: the context of the validation
     *    - sym: the symbol to validate
     * @returns: the prototype of the function
     */        
    def validateFunction (mut self, dmut context : &Validator, dmut sym : &FunctionSymbol, validateBody : bool = true)-> &PrototypeValue
        throws &ErrorMsg
    {
        if (!validateBody) {
            match sym.getFrameProto () {
                p : &PrototypeValue => return p;
            }
        }
                
        let func = sym.getContent ();
        let dmut errors = Vec!{&ErrorMsg}::new ();
        let throwers = self.validateThrowers (alias context, func.getThrowerLoc (), func.getThrowers (), alias errors);
        context:.enterBlock ();
        let (retType, parameters, body, needFinalReturn) = {            
            let (retType, parameters) = match sym.getFrameProto () {
                p : &PrototypeValue => {
                    (p.getRetType (), p.getParameters ())
                }
                _ => {
                    self:.validatePrototype (alias context, sym, func.getFunctionProto ())
                }
            }

            
            if (func.getLoc ().str () == Keys::MAIN && validateBody) {
                self.verifyMainPrototype (alias context, func.getLoc (), parameters, retType, alias errors);
            }

            let (body, needFinalReturn) = if (validateBody) {
                context:.enterFunctionBody ();
                self.validateFunctionBody (alias context, func.getLoc (), sym.getPath (), func.getBody (), retType, throwers, alias errors)
            } else {
                (cast!{&Value} (UnitValue::new ()), false)
            }
            
            (retType, parameters, body, needFinalReturn)
        } catch {
            err : &ErrorMsg => {
                errors:.push (err);
                (NONE_TYPE, [], NONE_VALUE, false)
            }
        }
        
        {
            if (!validateBody) context:.clearLocalScope ();
            context:.quitBlock ();
        } catch {
            err : &ErrorMsg => { errors:.push (err); }
        }

        if (errors.len () != 0us) throw ErrorMsg::list (errors[]);
        if (validateBody) {
            match func.getBody () {
                EmptyExpression () => {}
                _ => {
                    let frame = FrameGenerator::new (func.getLoc (), sym.getPath (), parameters, retType, body, needFinalReturn-> needFinalReturn, externLang-> sym.getExternalLanguage (), isWeak-> sym.isWeak ());
                    context:.insertNewGenerator (frame);
                }
            }
        }

        match sym.getFrameProto () {
            p : &PrototypeValue => { p }
            _ => {
                let gen = PrototypeValue::new (sym.getLoc (), sym, parameters, retType, throwers);
                if (validateBody) { // If not validate body the prototype might be uncomplete
                    sym:.setFrameProto (gen);
                }
                
                gen
            }
        }
    }

    /**
     * Validate the body of a function
     * @params: 
     *     - context: the context of the validation
     *     - loc: the location of the function
     *     - name: the name of the function
     *     - body: the body of the function
     *     - throwers: the list of throwers
     * @returns: 
     *    - errors: the list of errors 
     *    - .0: the validated value of the body
     *    - .1: true iif the value is not a returner
     */
    def validateFunctionBody (self, dmut context : &Validator, loc : &Word, name : &Path, body : &Expression, retType : &Type, throwers : [&Type], dmut errors : &Vec!{&ErrorMsg})-> (&Value, bool)        
    {
        match body {
            EmptyExpression () => {
                context:.clearLocalScope ();
                (UnitValue::new (loc-> loc), false)
            }
            _ => {
                {
                    context:.setFunctionReturn (retType);
                    let bodyValue = context:.validateValue (body);
                    let need = if (!bodyValue.isReturner ()) {
                        if (retType.getLoc ().isEof ()) {
                            context:.verifyMemoryOwner (bodyValue.getLoc (), retType, bodyValue);
                        } else
                            context:.verifyMemoryOwner (retType.getLoc (), retType, bodyValue);
                        
                        match retType {
                            VoidType () => { false }
                            _ => { true }
                        }
                    } else { false };
                    
                    self.verifyThrowing (alias context, loc, name, bodyValue.getThrowers (), throwers, alias errors);
                    (bodyValue, need)
                } catch {
                    err : &ErrorMsg => {
                        errors:.push (err);
                        (UnitValue::new (loc-> loc), false)
                    }
                }
            }
        }
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================           METHODS            =========================
     * ================================================================================
     * ================================================================================
     */


    /**
     * Validate a method
     * @todo: this function is way too long, and way too close to validateFunction and validateConstructor. A refactorization would be great
     * @params: 
     *    - context: the context of the validation
     *    - sym: the symbol to validate
     *    - clRef: the type of the class defining the method
     *    - fromTrait: the symbol of the trait if this method is defined inside a trait, (EmptySymbol otherwise)
     *    - validateBody: true iif the body must be validated
     * @returns: the prototype of the method
     * @throws:
     *    - &ErrorMsg: if the validation failed
     */        
    def validateMethod (mut self, dmut context : &Validator, dmut sym : &FunctionSymbol, clRef : &ClassRefType, fromTrait : &Symbol, validateBody : bool = false)-> &MethodPrototypeValue
        throws &ErrorMsg
    {
        let func = sym.getContent ();
        let dmut errors = Vec!{&ErrorMsg}::new ();
        let throwers = self.validateThrowers (alias context, func.getThrowerLoc (), func.getThrowers (), alias errors);
        
        let (retType, selfParam, parameters, body, needFinalReturn) = {            
            context:.enterBlock ();
            let selfParam = self.validateSelfParamDecl (func.getFunctionProto ().getParameters()[0], clRef);
            context:.insertLocal (selfParam.getLoc ().str (), selfParam);
            
            let (retType, parameters) = match sym.getFrameProto () {
                p : &PrototypeValue => {
                    (p.getRetType (), p.getParameters ())
                }
                _ => {
                    self:.validatePrototype (alias context, sym, func.getFunctionProto (), forMethod-> true)
                }
            };

            
           
            let (body, needFinalReturn) = if (validateBody) {
                context:.enterFunctionBody ();
                self.validateFunctionBody (alias context, func.getLoc (), sym.getPath (), func.getBody (), retType, throwers, alias errors)
            } else {
                (cast!{&Value} (UnitValue::new ()), false)
            }
            
            (retType, selfParam, [selfParam] ~ parameters, body, needFinalReturn)
        } catch {           
            err : &ErrorMsg => {
                context:.safeQuitBlock ();
                throw err;
            }
        }
        
        {
            if (!validateBody) context:.clearLocalScope ();
            context:.quitBlock ();
        } catch {
            err : &ErrorMsg => { errors:.push (err); }
        }

        if (errors.len () != 0us) throw ErrorMsg::list (errors[]);
        if (validateBody) {
            match func.getBody () {
                EmptyExpression () => {}
                _ => {
                    let frame = FrameGenerator::new (func.getLoc (), sym.getPath (), parameters, retType, body, needFinalReturn-> needFinalReturn, externLang-> sym.getExternalLanguage (), isWeak-> sym.isWeak ());
                    context:.insertNewGenerator (frame);
                }
            }
        }

        match sym.getFrameProto () {
            p : &MethodPrototypeValue => { p }
            _ => {
                let gen = MethodPrototypeValue::new (sym.getLoc (), sym, parameters, retType, throwers, clRef, trRef-> fromTrait, isMutable-> selfParam.getType ().isMutable (), isFinal-> sym.isFinal (), isEmpty-> func.getBody ().isOf!{&EmptyExpression} (), isOver-> sym.isOver ());
                if (validateBody) { // If not validate body the prototype might be uncomplete
                    sym:.setFrameProto (gen);
                }
                
                gen
            }
        }
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================            DTORS             =========================
     * ================================================================================
     * ================================================================================
     */

    def validateDestructor (mut self, dmut context : &Validator, dmut sym : &FunctionSymbol, clRef : &ClassRefType, ancDtor : &Value, validateBody : bool = false)-> &DtorPrototypeValue
        throws &ErrorMsg
    {
                let func = sym.getContent ();
        let dmut errors = Vec!{&ErrorMsg}::new ();
        let throwers = self.validateThrowers (alias context, func.getThrowerLoc (), func.getThrowers (), alias errors);
        
        let (retType, _, parameters, body) = {            
            context:.enterBlock ();
            let selfParam = self.validateSelfParamDecl (func.getFunctionProto ().getParameters()[0], clRef);
            if (!selfParam.isMutable ()) {}
            
            context:.insertLocal (selfParam.getLoc ().str (), selfParam);
            
            let (retType, parameters) = match sym.getFrameProto () {
                p : &PrototypeValue => {
                    (p.getRetType (), p.getParameters ())
                }
                _ => {
                    self:.validatePrototype (alias context, sym, func.getFunctionProto (), forMethod-> true)
                }
            };
            
            let (body_, _) = if (validateBody) {
                context:.enterFunctionBody ();
                self.validateFunctionBody (alias context, func.getLoc (), sym.getPath (), func.getBody (), retType, throwers, alias errors)
            } else {
                (cast!{&Value} (UnitValue::new ()), false)
            }

            let body = match ancDtor {
                NoneValue () => { body_ }
                _ => {
                    __pragma!panic ();
                }
            }
            
            (retType, selfParam, [selfParam] ~ parameters, body)
        } catch {           
            err : &ErrorMsg => {
                context:.safeQuitBlock ();
                throw err;
            }
        };
        
        {
            if (!validateBody) context:.clearLocalScope ();
            context:.quitBlock ();
        } catch {
            err : &ErrorMsg => { errors:.push (err); }
        }

        if (errors.len () != 0us) throw ErrorMsg::list (errors[]);
        if (validateBody) {
            match func.getBody () {
                EmptyExpression () => {}
                _ => {
                    let frame = FrameGenerator::new (func.getLoc (), sym.getPath (), parameters, retType, body, needFinalReturn-> false, externLang-> sym.getExternalLanguage (), isWeak-> sym.isWeak ());
                    context:.insertNewGenerator (frame);
                }
            }
        }

        match sym.getFrameProto () {
            p : &DtorPrototypeValue => { p }
            _ => {
                let gen = DtorPrototypeValue::new (sym.getLoc (), sym, clRef);
                if (validateBody) { // If not validate body the prototype might be uncomplete
                    sym:.setFrameProto (gen);
                }
                
                gen
            }
        }
    }
    
    
    /**
     * ================================================================================
     * ================================================================================
     * =========================            CTORS             =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a constructor
     * @todo: this function is way too long, and way too close to validateFunction and validateMethod. A refactorization would be great
     * @params: 
     *    - context: the context of the validation
     *    - sym: the symbol to validate
     *    - clRef: the class type for self
     *    - validateBody: validate the body of the constructor (and field/ancestor constructions)
     * @returns: the prototype of the ctor
     * @throws:
     *    - &ErrorMsg: if the validation failed
     */
    def validateConstructor (mut self, dmut context : &Validator, dmut sym : &ConstructorSymbol, clRef : &ClassRefType, validateBody : bool = false)-> &CtorPrototypeValue
        throws &ErrorMsg
    {
        let func = sym.getContent ();
        let dmut errors = Vec!{&ErrorMsg}::new ();
        let throwers = self.validateThrowers (alias context, func.getThrowerLoc (), func.getThrowers (), alias errors);

        let (selfParam, parameters, body) = {
            context:.enterBlock ();
            // We need a class ptr for the self parameter
            let clPtr = clRef.createInstance (true, true);

            let selfParam = ProtoVarValue::new (func.getLoc (), clPtr, NoneValue::new (), true, isSelf-> true);   // Self parameters (first hidden param)
            let (_, parameters) = match sym.getFrameProto () { 
                p : &PrototypeValue => { // already validated the prototype in previous call
                    (p.getRetType (), p.getParameters ())
                }
                _ => { // No previous call, need to validate the prototype
                    self:.validatePrototype (alias context, sym, func.getFunctionProtoDecl (), forMethod-> false) // unlike methods self is not written in the prototype, so we need to validate all parameters
                }
            };

            let body = if (validateBody) { // We validate the body
                self.validateCtorBody (alias context, sym, func, clPtr.getInner (), selfParam, throwers, alias errors)
            } else { // we validate only the prototype
                cast!{&Value} (NoneValue::new ())
            }
            
                                   
            (selfParam, parameters, body) // don't add the self parameter in the prototype, we don't have it when calling the prototype
        } catch {
            err : &ErrorMsg => {
                context:.safeQuitBlock ();
                throw err;
            }
        }

        {
            if (!validateBody) context:.clearLocalScope (); //ignore the inserted parameters, or there will be errors when quitting block
            context:.quitBlock ();
        } catch {
            err : &ErrorMsg => { errors:.push (err); }
        }
         

        if (errors.len () != 0us) throw ErrorMsg::list (errors[]);
        if (validateBody) {            
            match func.getBody () {
                EmptyExpression () => {}
                _ => {
                    let frame = FrameGenerator::new (func.getLoc (), sym.getPath (), [selfParam] ~ parameters, VoidType::new (sym.getLoc ()), body, needFinalReturn-> false, isWeak-> sym.isWeak ());
                    context:.insertNewGenerator (frame);
                }
            }
        }

        match sym.getFrameProto () {
            p : &CtorPrototypeValue => { p }
            _ => {
                let gen = CtorPrototypeValue::new (sym.getLoc (), sym, parameters, throwers, clRef, rename-> func.getRename ().str ());
                if (validateBody) { // If not validate body the prototype might be uncomplete
                    sym:.setFrameProto (gen);
                }
                
                gen
            }
        }
        
    }

    /**
     * Validation of the body of the constructor
     * This function is different from validateFunctionBody, because it also validates the pre constructor
     * @params: 
     *    - context: the context of the validation
     *    - sym: the symbol being validated
     *    - ctor: the ctor whose body is being validated
     *    - clRef: the type of the class containing the ctor
     *    - selfParam: the protovarvalue of the hidden self parameter
     * @returns: the body of the ctor
     * @throws:
     *    - &ErrorMsg: if there was an error in the validation     
     */
    def validateCtorBody (self, dmut context : &Validator, sym : &ConstructorSymbol, ctor : &ConstructorDecl, clRef : &ClassRefType, selfParam : &Value, throwers : [&Type], dmut errors : &Vec!{&ErrorMsg})-> &Value
        throws &ErrorMsg
    {
        // insert self in the scope, alongside with parameters (its an hidden param)
        context:.insertLocal (selfParam.getLoc ().str (), selfParam);

        // Reference to the self hidden param
        let selfValue = VarRefValue::new (selfParam.getLoc (), selfParam.getLoc (), selfParam.getType (), true, selfParam.getUniqId (), isSelf-> true);
        
        // Validate the pre construction of the constructor (construction of fields, and ancestor)
        let preConstruct = self.validatePreConstructor (alias context, sym, ctor, clRef, selfValue);

        // From this point, return is allowed
        context:.enterFunctionBody ();

        // Validate the body of the constructor (return void type)
        let (body, _) = self.validateFunctionBody (alias context, ctor.getLoc (), sym.getPath (), ctor.getBody (), VoidType::new (sym.getLoc ()), throwers, alias errors);

        // the body contains the pre construction, and the proper body
        BlockValue::new (ctor.getLoc (), VoidType::new (sym.getLoc ()), [preConstruct, body])
    }       
        
    /**
     * Validate the pre construction of a constructor
     * @params: 
     *    - context: the context of the validation
     *    - sym: the symbol being validated
     *    - func: the declaration to validate
     *    - clRef: the type of self
     *    - selfParam: the self parameter
     * @returns: the value containing the constructions statements
     * @throws: 
     *    - &ErrorMsg: if there was an error in the validation
     */
    def validatePreConstructor (self, dmut context : &Validator, sym : &ConstructorSymbol, func : &ConstructorDecl, clRef : &ClassRefType, selfParam : &Value)-> &Value
        throws &ErrorMsg
    {
        if (func.getExplicitCstrsCall () == Keys::SELF) { // There is a redirection of construction
            return self.validateRedirectCtor (alias context, sym, func, clRef, selfParam);
        }

        let dmut block = Vec!{&Value}::new (); // list of instructions        
        let ancCall = self.validateAncestorCtorCall (alias context, func, clRef, selfParam);
        match ancCall {
            NoneValue () => {} // Don't add an empty value
            _ =>  {
                block:.push (ancCall); // There is an ancestor, and its ctor is called
            }
        }        

        let fieldCtor = self.validateFieldCtors (alias context, func, clRef, selfParam);
        match fieldCtor {
            NoneValue () => {} // Don't add an empty value
            _ => {
                block:.push (fieldCtor); // there are field constructions
            }
        }

        if (block.len () != 0us) {
            // We create the block of instruction, containing super call, and field ctors
            BlockValue::new (func.getLoc (), VoidType::new (func.getLoc ()), block[])
        } else {
            UnitValue::new (loc-> func.getLoc ())
        }
    }

    /**
     * Validate the call of a redirect constructor
     * @params: 
     *    - context: the context of the validation
     *    - sym: the symbol being validated
     *    - func: the declaration of the constructor
     *    - clRef: the type of the class that is being validated
     * @returns: the instruction calling the redirect constructor
     * @throws: 
     *    - &ErrorMsg: if there is an error in the validation
     */
    def validateRedirectCtor (self, dmut context : &Validator, sym : &ConstructorSymbol, func : &ConstructorDecl, clRef : &ClassRefType, selfParam : &Value)-> &Value
        throws &ErrorMsg
    {
        let dmut errors = Vec!{&ErrorMsg}::new ();
        let dmut rights = Vec!{&Value}::new ();

        let selfLoc = func.getExplicitCstrsCall ();
        for v in func.getSuperParams () { // Validate the parameters that are passed to the redirect constructor
            rights:.push (context:.validateValue (v));
        }
        
        let ret = {
            // Ignore the current constructor, it cannot be called by redirection
            let ctors = self.createCtorDelegate (selfLoc, clRef, selfParam, withPrivate-> true, ignore-> sym, prettyStr-> "self"s8);
            context:.getCallOpValidator ().validate (alias context, selfLoc, ctors, rights[])
        } catch { 
            err : &ErrorMsg => { // None succeeded (TODO print private candidates)
                errors:.push (ErrorMsg::fatal (selfLoc, format (ValidateErrorMessage::UNDEFINED_SUPER_CALL_CTOR, rights[]), notes-> [err]));
                cast!{&Value} (NoneValue::new (loc-> selfLoc))
            }
        }

        for it in func.getFieldConstructors () {
            errors:.push (ErrorMsg::fatal (it._0, format (ValidateErrorMessage::ALREADY_INIT_BY_CTOR_REDIRECT, it._0.str ()), notes-> [ErrorMsg::note (selfLoc, ""s8)]));
        }

        if (errors.len () != 0us) throw ErrorMsg::list (errors[]);

        ret
    }
    
    /**
     * Validate the call of the ancestor constructor (if there is an ancestor)
     * @params: 
     *    - context: the context of the validation
     *    - func: the declaration of the constructor
     *    - clRef: the type of the class that is being validated
     *    - selfParam: the self parameters
     * @returns: the instruction calling the ancestor constructor (or Unit, if there is not call)
     * @throws: 
     *    - &ErrorMsg: if there is an error in the validation
     */
    def validateAncestorCtorCall (self, dmut context : &Validator, func : &ConstructorDecl, clRef : &ClassRefType, selfParam : &Value)-> &Value
        throws &ErrorMsg
    {
        match clRef.getAncestor () {
            ancestor : &ClassRefType => {
                // If the super call is implicit, we need a valid location
                let superLoc = if (func.getExplicitCstrsCall ().isEof ()) { func.getLoc () } else { func.getExplicitCstrsCall () };
                
                let dmut rights = Vec!{&Value}::new ();
                for v in func.getSuperParams () { // Validate the parameters that are passed to the parent constructor
                    rights:.push (context:.validateValue (v));
                }
                
                {
                    let ctors = self.createCtorDelegate (superLoc, ancestor, selfParam, withPrivate-> false);
                    return context:.getCallOpValidator ().validate (alias context, superLoc, ctors, rights[]); // Call the ctors with the parameters and return the one that succeeded
                } catch { 
                    err : &ErrorMsg => { // None succeeded (TODO print private candidates)
                        throw ErrorMsg::fatal (superLoc, format (ValidateErrorMessage::UNDEFINED_SUPER_CALL_CTOR, rights[]), notes-> [err]);
                    }
                }
            }
            _ => {
                // Class does not have any ancestor, so it can't be called
                if (func.getExplicitCstrsCall () == Keys::SUPER) {
                    throw ErrorMsg::fatal (func.getExplicitCstrsCall (), format (ValidateErrorMessage::NO_SUPER_CLASS, clRef));
                }
                
                return NoneValue::new ();
            }            
        }        
    }

    /**
     * Create a mult sym containing all the constructor of the class with the given instance
     * @params: 
     *    - loc: the location of the call
     *    - clRef: the class whose constructors are used
     *    - selfParam: the instance for self
     *    - withPrivate: include PRV_PARENT constructors ?
     *    - prettyStr: the name of the call
     *    - ignore: the ctor to ignore (for self redirection only)
     * @returns: a MultSymValue with all the available ctors (can be of len == 0us)
     */
    def createCtorDelegate (self, loc : &Word, clRef : &ClassRefType, selfParam : &Value, withPrivate : bool = false, prettyStr : [c8] = "super"s8, ignore : &Symbol = EMPTY_SYMBOL)-> &Value {    
        let prots = clRef.getCtorProtections ();
        let ptrType = clRef.createInstance (true, true); // the type returned by the calling of a constructor

        let dmut results = Vec!{&Value}::new ();
        for i, ctor in clRef.getCtors () { // traverse all defined ctor (TODO include template ctors)
            if (prots [i] != MethodProtection::PRV || withPrivate) { // Include only if the protection is ok
                match ctor {
                    proto : &CtorPrototypeValue => { // Necessarily that, previous compiler version has a bug, we have to deal with that
                        if (proto.getSymbol () !is ignore) {
                            results:.push (CtorDelegateValue::new (loc, ptrType, instance-> selfParam, proto)); // Don't forget to include the instance, otherwise a new instance is created
                        }
                    }
                    _ => __pragma!panic ();
                }
            }
        }

        MultSymValue::new (loc, results[], prettyStr-> prettyStr) 
    }
    
    /**
     * Validate the field constructors
     * @params: 
     *    - context: the context of the validation
     *    - func: the declaration of the constructor
     *    - clRef: the type of the class that is being validated
     *    - selfParam: the parameter self              
     * @returns: the instructions affecting values to the fields
     * @throws: 
     *     - &ErrorMsg: if there is an error in the validation
     */
    def validateFieldCtors (self, dmut context : &Validator, func : &ConstructorDecl, clRef : &ClassRefType, selfParam : &Value)-> &Value
        throws &ErrorMsg
    {
        let dmut instrs = Vec!{&Value}::new ();
        let dmut errors = Vec!{&ErrorMsg}::new ();
        context:.enterFieldConstruction (clRef); // Enter this context modifies the behavior of Dot operator, by saying the uninitialized fields of type 'clRef' cannot be accessed
        
        {
            let dmut willBeValidated = HashSet!{[c8]}::new ();            
            for it in func.getFieldConstructors () { // We need a list of fields that will be validated by pre construction (ref 1)
                willBeValidated:.insert (it._0.str ());
            }
            
            for it in clRef.getLocalFields () { match it { // Validate all the fields that were not validated by pre construction
                v : &VarDeclValue => {
                    if (v.getLoc ().str () !in willBeValidated) { // (cite 1), so we can initialize the fields that are not pre constructed first
                        if (v.getValue ().isOf!{&NoneValue} ()) {
                            errors:.push (ErrorMsg::fatal (v.getLoc (), format (ValidateErrorMessage::UNINIT_FIELD, v.getLoc ().str ())));
                        } else {
                            let field = context:.getBinOpValidator ().validateClassFieldAccess (alias context, selfParam, VarExpr::new (v.getLoc ()), clRef, true, true, verifyValidation-> false, withAncestor-> false);
                            instrs:.push (AffectValue::new (v.getLoc (), field.getType (), field, v.getValue ()));
                            context:.setFieldValidated (v.getLoc ().str ());
                        }
                    }
                }
            }} catch {
                err : &ErrorMsg => { errors:.push (err); }
            }

            if (errors.len () != 0us) throw ErrorMsg::list (errors[]);
            for it in func.getFieldConstructors () { // Validate all the fields that are written in the pre construction 
                let name = it._0;
                if (name.str () in context:.getFieldValidated ()) {
                    errors:.push (ErrorMsg::fatal (name, format (ValidateErrorMessage::MULTIPLE_FIELD_INIT, name.str ())));
                } else {
                    let field = context:.getBinOpValidator ().validateClassFieldAccess (alias context, selfParam, VarExpr::new (name), clRef, true, true, verifyValidation-> false, withAncestor-> false);
                    let value = context:.validateValue (it._1);                    
                    context:.verifyMemoryOwner (field.getLoc (), field.getType (), value, checkTypes-> true);
                    
                    instrs:.push (AffectValue::new (name, field.getType (), field, value));
                    context:.setFieldValidated (name.str ());
                }
            } catch {
                err : &ErrorMsg => { errors:.push (err); }
            }        
        } catch {
            err : &ErrorMsg => { errors:.push (err); }
        }

        context:.quitFieldConstruction (); // We don't forget to quit the field validation, from that point all fields are accessible
        if (errors.len () != 0us) throw ErrorMsg::list (errors[]);
        if (instrs.len () != 0us) {
            // returns the list of constructions
            BlockValue::new (func.getLoc (), VoidType::new (func.getLoc ()), instrs[])
        } else { 
            UnitValue::new (loc-> func.getLoc ()) // No instrs, no need to open a block
        }
    }
    
    /**
     * ================================================================================
     * ================================================================================
     * =========================           THROWERS           =========================
     * ================================================================================
     * ================================================================================
     */
    
    /**
     * Validate the throwers a function
     * @params: 
     *    - context: the context of the validation
     *    - throwers: the list of throwers
     * @returns: 
     *    - errors: the list of errors that occurs in the validation
     *    - the list of throwers
     */
    def validateThrowers (self, dmut context : &Validator, loc : &Word, throwers : [&Expression], dmut errors : &Vec!{&ErrorMsg})-> [&Type]
        throws &ErrorMsg
    {
        // No need to validate core::exception::Exception if there is no throws
        if (throwers.len == 0us) return [];
        
        let dmut rets = Vec!{&Type}::new ();        
        let exceptionType = context:.getExceptionType (loc-> loc);
        
        for i in throwers {
            {
                let type = context:.validateType (i);
                match type {
                    cptr : &ClassPtrType => {
                        if (context.isAncestor (exceptionType, cptr)) {
                            rets:.push (type);
                        } else {
                            errors:.push (ErrorMsg::fatal (i.getLoc (), end-> exceptionType.getLoc (), format (ValidateErrorMessage::INCOMPATIBLE_TYPE, type, exceptionType)));
                        }
                    }
                    _ => {                        
                        errors:.push (ErrorMsg::fatal (i.getLoc (), end-> exceptionType.getLoc (), format (ValidateErrorMessage::INCOMPATIBLE_TYPE, type, exceptionType)));
                    }
                }
            } catch {
                err : &ErrorMsg => { errors:.push (err); }
            }
        }

        rets[]
    }

    /**
     * Verify that the declared throws and the actual thrown of the function are similar
     * @params: 
     *    - context: the context of the function
     *    - loc: the location of the definition of the function
     *    - name: the name of the function
     *    - thrown: the list of type that are thrown by the body
     *    - expected: the list of type that are declared in the prototype as throws
     * @returns: 
     *     - errors: the list of errors during the validation
     */
    def verifyThrowing (self, dmut context : &Validator, loc : &Word, name : &Path, thrown : [&Type], expected : [&Type], dmut errors : &Vec!{&ErrorMsg}) {
        context;
        loc;
        name;
        thrown;
        expected;
        errors;
    }        
    
    /**
     * ================================================================================
     * ================================================================================
     * =========================          PROTOTYPE           =========================
     * ================================================================================
     * ================================================================================
     */
    
    /**
     * Validate the prototype of a frame for generation
     * @params: 
     *   - context: the context of the validation
     *   - sym: the symbol being validated
     *   - proto: the prototype to validate
     *   - forMethod: true iif the validation is intended to create a method prototype
     * @returns:
     *    - .0: the return type of the prototype
     *    - .1: the list of parameters
     * @throws: &ErrorMsg, if there is a malformed parameter, or the return type is malformed
     */
    def validatePrototype (mut self, dmut context : &Validator, sym : &Symbol, proto : &FunctionProtoDecl, forMethod : bool = false)-> (&Type, [&ProtoVarValue])
        throws &ErrorMsg
    {
        let dmut parameters = Vec!{&ProtoVarValue}::new ();
        let dmut errors = Vec!{&ErrorMsg}::new ();
        
        let noValue = sym in self._validating;
        self._validating:.insert (sym);
        {
            for i, param in proto.getParameters () {
                if (i != 0us || !forMethod) { // If we validate the prototype for a method, we don't validate the first parameter (which is always self)
                    let (isMutable, type, value) = self.validateParamDecl (alias context, param, noValue-> noValue);                
                    let paramGen = ProtoVarValue::new (param.getLoc (), type, value, isMutable, isSelf-> false);
                    parameters:.push (paramGen);
                    
                    if (param.getLoc ().str () != Keys::UNDER) {
                        context:.verifyShadow (paramGen.getLoc ());
                        context:.insertLocal (paramGen.getLoc ().str (), paramGen);
                    }
                } catch {
                    err : &ErrorMsg => {
                        errors:.push (err);
                    }
                }
            }
        }         
        self._validating:.remove (sym);

        let r : &Type = {
            match proto.getRetType () {
                e : &EmptyExpression => { cast!{&Type} (VoidType::new (e.getLoc ())) }
                x : _ => { context:.validateType (x) }
            }
        } catch {
            err : &ErrorMsg => {
                errors:.push (err);
                throw ErrorMsg::list (errors[]);
            }
        }
        
        if (errors.len () != 0us) throw ErrorMsg::list (errors[]);
        (r, parameters[])          
    }

    /**
     * Verify that the prototype is correct for the main function
     * @params: 
     *   - funcLoc: the location of the function definition
     *   - proto: the prototype of the frame 
     *   - parameters: the validated parameters of the function
     *   - retType: the return type of the function
     * @returns:
     *    - errors: add errors if the prototype is not valid
     */
    def verifyMainPrototype (self, dmut context : &Validator, funcLoc : &Word, parameters : [&Value], retType : &Type, dmut errors : &Vec!{&ErrorMsg}) {
        if (parameters.len > 1us) {
            errors:.push (ErrorMsg::fatal (parameters [1us].getLoc (),
                                           ValidateErrorMessage::MAIN_FUNCTION_ONE_ARG));
        } else if (parameters.len == 1us) {
            let test = SliceType::new (funcLoc, SliceType::new (funcLoc, CharType::new (funcLoc, size-> 8u16)));
            {
                context:.verifyCompatibleTypeWithValue (parameters [0].getLoc (), test, parameters [0]);
            } catch {
                err : &ErrorMsg => { errors:.push (err); }
            }
        }

        match retType {
            VoidType () => {}
            _ => {
                let test = IntType::new (funcLoc, size-> 32u16, signed-> true);
                {
                    context:.verifyCompatibleType (retType.getLoc (), test.getLoc (), test, retType);
                } catch {
                    err : &ErrorMsg => { errors:.push (err); }
                }   
            }
        }        
    }
    

    /**
     * Validate a parameter of a prototype
     * @params: 
     *    - context: the context of the validation
     *    - param: the parameter to validate
     *    - noValue: true iif we are recursevely validating and thus the value must not be validated (cf. Recursive default parameters)
     * @throws: &ErrorMsg, if there is an error
     * @returns: 
     *    - .0: true iif the parameter is declared mutable
     *    - .1: the type of the parameter
     *    - .2: the value of the parameter
     */
    def validateParamDecl (self, dmut context : &Validator, param : &Expression, noValue : bool = false)-> (bool, &Type, &Value)
        throws &ErrorMsg
    {
        match param {
            vdecl : &VarDeclExpr => {
                let type : &Type = {
                    context:.validateType (vdecl.getType (), decos-> vdecl.getDecos ())
                } catch {
                    err : &ErrorMsg => throw ErrorMsg::note (param.getLoc (), ValidateErrorMessage::VALIDATING, notes-> [err]);
                }                
                
                let value : &Value = if !vdecl.getValue ().isOf!{&EmptyExpression} () && !noValue {
                    if (vdecl.getLoc () == Keys::UNDER) { // variable with a default value must have a name, otherwise it is impossible to change them 
                        throw ErrorMsg::fatal (vdecl.getLoc (), ValidateErrorMessage::DEFAULT_VAR_NO_NAME, notes-> [ErrorMsg::note (vdecl.getValue ().getLoc (), ""s8)]);
                    }
                    
                    context:.validateValue (vdecl.getLoc (), vdecl.getValue (), type-> type)
                } else {                    
                    cast!{&Value} (NoneValue::new ())                    
                }

                
                if (type.isMutable () && !type.needExplicitAlias ()) {
                    throw ErrorMsg::fatal (vdecl.getLoc (), ValidateErrorMessage::MUTABLE_CONST_PARAM);
                }

                match type {
                    VoidType () => throw ErrorMsg::fatal (vdecl.getLoc (), format (ValidateErrorMessage::DECLARE_VOID_VAR, type));
                    NoneType () => throw ErrorMsg::fatal (vdecl.getLoc (), format (ValidateErrorMessage::DECLARE_VOID_VAR, type));
                    ClassRefType () => throw ErrorMsg::fatal (vdecl.getType ().getLoc (), format (ValidateErrorMessage::INCOMPLETE_TYPE, type),
                                                              notes-> [ErrorMsg::note (vdecl.getType ().getLoc (), ValidateErrorMessage::FORGET_AND_CLASS, oneLine-> true)]);
                    TemporaryType () => throw ErrorMsg::fatal (vdecl.getType ().getLoc (), format (ValidateErrorMessage::INCOMPLETE_TYPE, type));
                }


                return (type.isMutable (), type, value);
            }
            _ => {
                println ("TODO : ", param::typeinfo.name);
                __pragma!panic ();
            }
        }
    }

    /**
     * Validate a parameter of a template prototype
     * @params: 
     *    - context: the context of the validation
     *    - param: the parameter to validate
     *    - noValue: true iif we are recursevely validating and thus the value must not be validated (cf. Recursive default parameters)
     * @returns: 
     *    - .0: true iif the parameter is declared mutable
     *    - .1: the type of the parameter (can be none, if the validation failed)
     *    - .2: the value of the parameter (can be none if there is none, or the validation failed)
     */
    pub def validateTemplateParamDecl (self, dmut context : &Validator, param : &Expression, noValue : bool = false)-> (bool, &Type, &Value) {    
        match param {
            vdecl : &VarDeclExpr => {
                let type : &Type = {                    
                        context:.validateType (vdecl.getType (), decos-> vdecl.getDecos ())                       
                } catch {
                    _ => {
                        cast!{&Type} (NONE_TYPE)
                    }
                }                
                
                let value : &Value = if !vdecl.getValue ().isOf!{&EmptyExpression} () && !noValue {
                    {
                        context:.validateValue (vdecl.getLoc (), vdecl.getValue (), type-> type)
                    } catch {
                        _ => {
                            // we put something, because we don't want the value to be set automatically
                            // It must be named, even if we don't know yet what it is it's default value, template specialization will tell
                            cast!{&Value} (TemplateDefaultValue::new (vdecl.getValue ().getLoc ()))
                        }
                    }                        
                } else {                    
                    cast!{&Value} (NoneValue::new ())                    
                }
                
                return (type.isMutable (), type, value);
            }
            _ => {
                println ("TODO : ", param::typeinfo.name);
                __pragma!panic ();
            }
        }
    }

    /**
     * Validate the self parameter of a method prototype
     * @params: 
     *   - param: the self parameter
     *   - clRef: the type of the class used
     * @returns: the protovar value
     */
    def validateSelfParamDecl (self, param : &Expression, clRef : &ClassRefType)-> &ProtoVarValue
        throws &ErrorMsg
    {
        match param {
            vdecl : &VarDeclExpr => {
                let mut isMutable = false;
                for i in vdecl.getDecos () match i.deco { // The only decorator that has a meaning is MUT
                    Decorators::MUT => { isMutable = true; }
                    _ => {
                        throw ErrorMsg::fatal (i.loc, format (ValidateErrorMessage::UNDEF_DECORATOR_TYPE, i.deco));
                    }
                }

                let clPtr = clRef.createInstance (isMutable, isMutable); // mut in that case means dmut                
                ProtoVarValue::new (param.getLoc (), clPtr, NoneValue::new (), isMutable, isSelf-> true) // returns the protovar
            }
            _ => { // mmh, that's not usable as a self parameter, unless its a varexpr ? no it cannot
                __pragma!panic ();
            }
        }
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================           UNITTEST           =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a unit test
     * @params: 
     *   - context: the context of the validation
     *   - sym: the symbol to validate
     */
    def validateTest (self, dmut context : &Validator, dmut sym : &FunctionSymbol)
        throws &ErrorMsg
    {
        context;
        sym;
        println ("TODO");
        __pragma!fake_throw (&ErrorMsg);
        __pragma!panic ();
    }
    
}
