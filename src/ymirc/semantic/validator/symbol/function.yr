in function;

use ymirc::semantic::validator::{visitor, template::_, errors};
use ymirc::semantic::{generator::_, symbol::_};
use ymirc::syntax::{_,
                    declaration::_,
                    expression::{_, literal::_, macro_::_, operator::_, template::_}};

use ymirc::errors::_;
use ymirc::utils::{format, log};
use ymirc::lexing::word;
use std::{stream, io};

use ymirc::semantic::generator::type::{_,
                                       syntax::_,
                                       custom::_,
                                       native::{_, scalar::_, compound::_},
                                       temporary::_};

use ymirc::semantic::generator::value::{_,
                                        syntax::_,
                                        construct::{_, delegate::_},
                                        literal::_,
                                        memory::_,
                                        operator::{_, binary::_, call::_, fields::_, map::_, slice::_, unary::_},
                                        operator::map::iteration::_,
                                        prototypes::_,
                                        scope::_,
                                        syntax::_,
                                        template::_};

/**
 * The function validator is the class responsible for function symbol validation
 */
@final
pub class FunctionValidator {

    // The list of validating symbol, to avoid infinite value call recursion (foo (a = bar()), bar (a = foo ()))
    let mut _validating : [&Symbol => mut ()] = copy [];
    
    /**
     * Create a new empty validator
     */
    pub self () {}


    /**
     * Validate a function
     * @info: insert the generator in the context for "generation"
     * @params: 
     *   - context: the context of the validation
     *   - sym: the function to validate
     * @throws: 
     *    - &ErrorMsg: if the func is not valid
     */
    pub fn validate (mut self, dmut context : &Validator, dmut sym : &FunctionSymbol)
        throws ErrorMsg
    {
        context:.pushReferent (alias sym);
        context:.enterForeign (isFnBody-> false);

        {
            self:.validateFunction (alias context, alias sym);
        }  catch {
            err : &ErrorMsg => {
                context:.exitForeign ();
                context:.popReferent ();
                throw copy ErrorMsg::fatal (sym.getLoc (), format (ValidateErrorMessage::VALIDATING_SYMBOL, sym.getPath ().toStr ()), notes-> copy [err]);
            }
        }
        
        context:.exitForeign ();
        context:.popReferent ();
    }

    /**
     * Validate a constructor symbol
     * @info: insert the generator in the context for "generation"
     * @params: 
     *    - context: the context of the validation
     *    - sym: the symbol to validate
     *    - clRef: the type of the class containing the ctor
     * @throws: 
     *    - &ErrorMsg: if the ctor is not valid
     */
    pub fn validateConstructor (mut self, dmut context : &Validator, dmut sym : &ConstructorSymbol, clRef : &ClassRefType)
        throws ErrorMsg
    {
        context:.pushReferent (alias sym);
        context:.enterForeign (isFnBody-> false, clContext-> clRef);
        {
            // Only one kind of constructor
            self:.validateConstructor (alias context, alias sym, clRef, validateBody-> true);
        }  catch {
            err : &ErrorMsg => {
                context:.exitForeign ();
                context:.popReferent ();
                throw copy ErrorMsg::fatal (sym.getLoc (), format (ValidateErrorMessage::VALIDATING_SYMBOL, sym.getPath ().toStr ()), notes-> copy [err]);
            }
        }
        
        context:.exitForeign ();
        context:.popReferent ();
    }

    /**
     * Fully validate a method definition  (not just the prototype)
     * @params: 
     *    - context: the context of the validation
     *    - sym: the method to validate
     *    - clRef: the type of self in the method
     * @throws:
     *     - &ErrorMsg: if there was an error in the validation
     */
    pub fn validateMethod (mut self, dmut context : &Validator, dmut sym : &FunctionSymbol, clRef : &ClassRefType)
        throws ErrorMsg
    {
        context:.pushReferent (alias sym);
        context:.enterForeign (isFnBody-> false, clContext-> clRef);

        {
            // Only one kind of method
            // We don't care if it was defined inside a trait, we don't use the method prototype that is generated
            self:.validateMethod (alias context, alias sym, sym.getContent (), clRef, fromTrait-> EMPTY_SYMBOL, validateBody-> true);
        } catch {
            err : &ErrorMsg => {
                context:.exitForeign ();
                context:.popReferent ();
                throw copy ErrorMsg::fatal (sym.getLoc (), format (ValidateErrorMessage::VALIDATING_SYMBOL, sym.getPath ().toStr ()), notes-> copy [err]);
            }
        }
        
        context:.exitForeign ();
        context:.popReferent ();
    }

    /**
     * Validate a destructor defined a class
     * @params:
     *    - context: the context of the validation
     *    - sym: the dtor to validate
     *    - clRef: the class defining the dtor
     * @throws:
     *     - &ErrorMsg: if there is an error in the validation
     */
    pub fn validateDestructor (mut self, dmut context : &Validator, dmut sym : &DestructorSymbol, clRef : &ClassRefType)
        throws ErrorMsg
    {
        let ancDtor = match clRef.getAncestor () {
            Ok (ancRef) => { // maybe the ancestor has a destructor
                ancRef.getDestructor ()
            }
            _ => { // No ancestor, so no destructor at all
                UNIT_VALUE
            }
        };

        context:.pushReferent (alias sym);
        context:.enterForeign (isFnBody-> false, clContext-> clRef);

        {
            self:.validateDestructor (alias context, alias sym, clRef, validateBody-> true, ancDtor-> ancDtor)
        } catch {
            err : &ErrorMsg => {
                context:.exitForeign ();
                context:.popReferent ();
                throw copy ErrorMsg::fatal (sym.getLoc (), format (ValidateErrorMessage::VALIDATING_SYMBOL, sym.getPath ().toStr ()), notes-> copy [err]);
            }
        }

        context:.exitForeign ();
        context:.popReferent ();
    }


    /*!
     * ================================================================================
     * ================================================================================
     * =========================          PROTOTYPES          =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate the prototype of a function
     * @params: 
     *    - context: the context of the validation
     *    - sym: the symbol to validate
     * @returns: a callable prototype of function
     * @throws: &ErrorMsg, if the function is malformed
     */
    pub fn validateFuncPrototype (mut self, dmut context : &Validator, dmut sym : &FunctionSymbol)-> &PrototypeValue
        throws ErrorMsg
    {
        match (sym.getFrameProto ()) {
            EmptyGenerator () => {
                let ret = {
                    context:.pushReferent (alias sym);
                    context:.enterForeign (isFnBody-> false);
                    
                    self:.validateFunction (alias context, alias sym, validateBody-> false)
                } exit {                
                    context:.exitForeign ();
                    context:.popReferent ();
                } catch {
                    err : &ErrorMsg => {
                        throw copy ErrorMsg::fatal (sym.getLoc (), format (ValidateErrorMessage::VALIDATING_SYMBOL, sym.getPath ().toStr ()), notes-> copy [err]);
                    }                    
                } 


                ret
            }
            v : &PrototypeValue => {
                v
            }
            g : _ => {
                println ("What is inside the function ???", g.__typeinfo__.name);
                panic;
            }
        }
    }

    /**
     * Validate a prototype of a symbol that is not declared, as it comes from a template rewrite
     * @params: 
     *    - context: the context of the validation
     *    - sym: the symbol declaring the template definition
     *    - func: the rewritten function declaration
     *    - rewriter: the template rewriter
     * @returns: the validate prototype value of the function
     * @throws:
     *    - &ErrorMsg: if the validation fails
     */
    pub fn validateFuncPrototypeFromTemplate (mut self, dmut context : &Validator, implLoc : &Word, dmut sym : &Symbol, func : &FunctionDecl, rewriter : TemplateRewriter)-> &PrototypeValue
        throws ErrorMsg
    {
        context:.pushReferent (alias sym);
        context:.enterForeign (isFnBody-> false);

        let mut error : (&ErrorMsg)? = none;
        let throwers = self.validateThrowers (alias context, func.getThrowerLoc (), func.getThrowers ());
        self.verifyUndefAttributes (func.getAttributes ());

        let (retType, parameters) = {
            context:.enterBlock ();
            {
                {
                    self:.validatePrototype (alias context, sym, func.getFunctionProto ())      
                } catch {
                    err : &ErrorMsg => {
                        error = (copy ErrorMsg::fatal (sym.getLoc (), format (ValidateErrorMessage::VALIDATING_SYMBOL, sym.getPath ().toStr ()),
                                                      notes-> copy [err]))?;
                        (NONE_TYPE, [])
                    }                    
                }
            } exit {
                {
                    context:.quitBlock (warnUnused-> false);
                } catch {
                    _ =>  panic;
                }
            }
        }

        if let Ok (msg) = error { throw msg; }
        copy PrototypeValue (sym.getLoc (), implLoc, sym, parameters, retType, throwers, fromTemplate-> rewriter?, attributes-> func.getAttributes ())
    } exit {
        context:.exitForeign ();
        context:.popReferent ();
    }
    
    /**
     * Validate the prototype of a constructor
     * @params: 
     *    - context: the context of the validation
     *    - sym: the symbol to validate
     *    - clRef: the type of the class that will be used as self
     * @returns: a callable prototype of function
     * @throws:
     *    - &ErrorMsg, if the constructor is malformed
     */
    pub fn validateCtorPrototype (mut self, dmut context : &Validator, dmut sym : &ConstructorSymbol, clRef : &ClassRefType, noValue : bool = false)-> &CtorPrototypeValue
        throws ErrorMsg
    {
        let ret = {
            context:.pushReferent (alias sym);
            context:.enterForeign (isFnBody-> false, clContext-> clRef);

            self:.validateConstructor (alias context, alias sym, clRef, validateBody-> false, noValue-> noValue)
        } exit {
            context:.exitForeign ();
            context:.popReferent ();
        } catch {
            err : &ErrorMsg => {
                throw copy ErrorMsg::fatal (sym.getLoc (), format (ValidateErrorMessage::VALIDATING_SYMBOL, sym.getPath ().toStr ()),
                                            notes-> copy [err]);
            }
        };

        ret
    }

    /**
     * Validate the prototype of a constructor that was declared as a template
     * @params:
     *    - context: the context of the validation
     *    - sym: the template symbol (used for context references only)
     *    - func: the constructor declaration defining the prototype
     *    - clRef: the class type that declared the method
     *    - rewriter: the rewriter defined by the template specialization solving
     * @returns:  A constructor prototype
     * @throws:
     *    - &ErrorMsg: if the validation of the prototype fails
     * */
    pub fn validateCtorPrototypeFromTemplate (mut self, dmut context : &Validator, dmut sym : &Symbol, func : &ConstructorDecl, clRef : &ClassRefType, rewriter : TemplateRewriter)-> &CtorPrototypeValue
        throws ErrorMsg
    {
        context:.pushReferent (alias sym);
        context:.enterForeign (isFnBody-> false, clContext-> clRef);
        let ret = {
            let mut errors : [&ErrorMsg] = [];
            let throwers = self.validateThrowers (alias context, func.getThrowerLoc (), func.getThrowers ());
            self.verifyUndefAttributes (func.getAttributes ());

            let parameters = {
                context:.enterBlock ();
                let clPtr = clRef.createInstance (true, true);
                let selfParam = copy ProtoVarValue (func.getLoc (), clPtr, UNIT_VALUE, true, isSelf-> true, isReference-> clRef.isStruct ());
                context:.insertLocal (selfParam.getLoc (), selfParam.getLoc ().str, selfParam, canShadow-> true);

                let (_, parameters) = self:.validatePrototype (alias context, sym, func.getFunctionProtoDecl (), forMethod-> false);

                parameters
            } catch {
                err : &ErrorMsg => {
                    errors ~= [err];
                    []
                }
            } exit {
                {
                    context:.quitBlock (warnUnused-> false);
                } catch {
                    err : &ErrorMsg => { errors ~= [err]; }
                }
            }

            if (errors.len != 0us) throw copy ErrorMsg::list (errors);

            copy CtorPrototypeValue (sym.getLoc (), sym, rename-> func.getRename ().str, parameters, throwers,
                                     clRef-> clRef, attributes-> func.getAttributes (), fromTemplate-> rewriter?)
        } exit {
            context:.exitForeign ();
            context:.popReferent ();
        } catch {
            err : &ErrorMsg => {
                throw copy ErrorMsg::fatal (sym.getLoc (), format (ValidateErrorMessage::VALIDATING_SYMBOL, sym.getPath ().toStr ()),
                                            notes-> copy [err]);
            }
        };

        ret
    }

    /**
     * Validate a method prototype defined inside a trait symbol
     * @params: 
     *   - context: the context of the validation
     *   - sym: the function to validate
     *   - clRef: the type of the class (used for the self parameter)
     *   - traitRef: the trait that defines the method
     * @returns: the prototype of the method
     * @throws:
     *   - &ErrorMsg: if the validation fails
     */
    pub fn validateMethodPrototype (mut self, dmut context : &Validator, dmut sym : &FunctionSymbol, clRef : &ClassRefType, traitRef : &TraitRefType, noValue : bool = false)-> &MethodPrototypeValue
        throws ErrorMsg
    {
        let ret = {
            context:.pushReferent (alias sym);
            context:.enterForeign (isFnBody-> false, clContext-> clRef);

            self:.validateMethod (alias context, alias sym, sym.getContent (), clRef, fromTrait-> traitRef.getSymbol (), validateBody-> false, noValue-> noValue)
        } exit {
            context:.exitForeign ();
            context:.popReferent ();
        } catch {
            err : &ErrorMsg => {
                throw copy ErrorMsg::fatal (sym.getLoc (), format (ValidateErrorMessage::VALIDATING_SYMBOL, sym.getPath ().toStr ()),
                                            notes-> copy [err]);
            }
        };

        ret
    }

    /**
     * Validate a method prototype defined inside a trait symbol
     * @params: 
     *   - context: the context of the validation
     *   - sym: the function to validate
     *   - clRef: the type of the class (used for the self parameter)
     *   - traitRef: the trait that defines the method
     * @returns: the prototype of the method
     * @throws:
     *   - &ErrorMsg: if the validation fails
     */
    pub fn validateMethodPrototype (mut self, dmut context : &Validator, dmut sym : &FunctionSymbol, clRef : &ClassRefType, noValue : bool = false)-> &MethodPrototypeValue
        throws ErrorMsg
    {
        let ret = {
            context:.pushReferent (alias sym);
            context:.enterForeign (isFnBody-> false, clContext-> clRef);

            self:.validateMethod (alias context, alias sym, sym.getContent (), clRef, fromTrait-> EMPTY_SYMBOL, validateBody-> false, noValue-> noValue)
        } exit {
            context:.exitForeign ();
            context:.popReferent ();
        } catch {
            err : &ErrorMsg => {
                throw copy ErrorMsg::fatal (sym.getLoc (), format (ValidateErrorMessage::VALIDATING_SYMBOL, sym.getPath ().toStr ()),
                                            notes-> copy [err]);
            }
        };

        ret
    }

    /**
     * Validate the prototype of a method that was declared as a template in a class
     * @params:
     *    - context: the context of the validation
     *    - sym: the template symbol (used for context references only)
     *    - func: the function declaration defining the prototype
     *    - clRef: the class type that declared the method
     *    - rewriter: the rewriter defined by the template specialization solving
     * @returns:  A method prototype
     * @throws:
     *    - &ErrorMsg: if the validation of the prototype fails
     * */
    pub fn validateMethodPrototypeFromTemplate (mut self, dmut context : &Validator, implLoc : &Word, dmut sym : &Symbol, func : &FunctionDecl, clRef : &ClassRefType, rewriter : TemplateRewriter)-> &MethodPrototypeValue
        throws ErrorMsg
    {
        context:.pushReferent (alias sym);
        context:.enterForeign (isFnBody-> false, clContext-> clRef);

        let ret = {
            let throwers = self.validateThrowers (alias context, func.getThrowerLoc (), func.getThrowers ());
            self.verifyUndefAttributes (func.getAttributes ());

            let (retType, selfParam, parameters) = {
                context:.enterBlock ();
                let selfParam = self.validateSelfParamDecl (func.getFunctionProto ().getParameters()[0], clRef);
                context:.insertLocal (selfParam.getLoc (), selfParam.getLoc ().str, selfParam, canShadow-> true);

                let (retType, parameters) = self:.validatePrototype (alias context, sym, func.getFunctionProto (), forMethod-> true);
                (retType, selfParam, parameters)
            } exit {
                {
                    context:.quitBlock (warnUnused-> false);
                } catch {
                    _ => panic;
                }
            }

            copy MethodPrototypeValue (sym.getLoc (),
                                       implLoc-> implLoc,
                                       sym, parameters, retType, throwers, clRef, trRef-> EMPTY_SYMBOL, isMutable-> selfParam.getType ().isMutable (),
                                       isEmpty-> func.getBody () of EmptyExpression, isOver-> false, isFinal-> true, attributes-> func.getAttributes (), fromTemplate-> rewriter?)
        } exit {
            context:.exitForeign ();
            context:.popReferent ();
        } catch {
            err : &ErrorMsg => {
                throw copy ErrorMsg::fatal (sym.getLoc (), format (ValidateErrorMessage::VALIDATING_SYMBOL, sym.getPath ().toStr ()),
                                            notes-> copy [err]);
            }
        };


        ret
    }

    /**
     * Validate a dtor prototype defined a class
     * @params:
     *    - context: the context of the validation
     *    - sym: the dtor to validate
     *    - clRef: the class defining the dtor
     *    - ancDtor: the prototype of the ancestor dtor (can be empty, aka UnitValue)
     * @throws:
     *     - &ErrorMsg: if there is an error in the validation
     * @returns: the prototype of the destructor
     */
    pub fn validateDtorPrototype (mut self, dmut context : &Validator, dmut sym : &DestructorSymbol, clRef : &ClassRefType, ancDtor : &Value)-> &DtorPrototypeValue
        throws ErrorMsg
    {
        let ret = {
            context:.pushReferent (alias sym);
            context:.enterForeign (isFnBody-> false, clContext-> clRef);

            self:.validateDestructor (alias context, alias sym, clRef, validateBody-> false, ancDtor-> ancDtor)
        } exit {
            context:.exitForeign ();
            context:.popReferent ();
        } catch {
            err : &ErrorMsg => {
                throw copy ErrorMsg::fatal (sym.getLoc (), format (ValidateErrorMessage::VALIDATING_SYMBOL, sym.getPath ().toStr ()),
                                            notes-> copy [err]);
            }
        };

        ret
    }

    
    /*!
     * ================================================================================
     * ================================================================================
     * =========================           FUNCTION           =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a normal function
     * @todo: this function is way too long, and way too close to validateMethod and validateConstructor. A refactorization would be great
     * @params: 
     *    - context: the context of the validation
     *    - sym: the symbol to validate
     * @returns: the prototype of the function
     */        
    fn validateFunction (mut self, dmut context : &Validator, dmut sym : &FunctionSymbol, validateBody : bool = true)-> &PrototypeValue
        throws ErrorMsg
    {
        let func = sym.getContent ();
        let mut errors : [&ErrorMsg] = [];
        let throwers = self.validateThrowers (alias context, func.getThrowerLoc (), func.getThrowers ());
        self.verifyUndefAttributes (func.getAttributes ());

        let (retType, parameters, body) = {
            context:.enterBlock ();
            let (retType, parameters) = self:.validatePrototype (alias context, sym, func.getFunctionProto ());
            if (func.getLoc ().str == Keys::MAIN && validateBody) {
                self.verifyMainPrototype (alias context, func.getLoc (), parameters, retType);
            } 

            let body = if (validateBody) {
                context:.enterFunctionBody ();
                let mut unsafeLoc = self.getUnsafeLoc (func.getAttributes ());
                let force = if (unsafeLoc.isEof () && sym.isUnsafe ()) {
                    unsafeLoc = func.getLoc (); // extern C function are unsafe without attributes
                    true
                } else {
                    false
                };

                self.validateFunctionBody (alias context, func.getLoc (), sym.getPath (), func.getBody (), retType, throwers, unsafeLoc, forceUnsafe-> force)
            } else {
                UNIT_VALUE
            }
            
            (retType, parameters, body)
        } catch {
            err : &ErrorMsg => {
                errors ~= [err];
                (NONE_TYPE, [], UNIT_VALUE)
            }
        } exit {
            {
                context:.quitBlock (warnUnused-> (errors.len == 0us && validateBody));
            } catch {
                err : &ErrorMsg => { errors ~= [err]; }
            }
        }

        if (errors.len != 0us) throw copy ErrorMsg::list (errors);
        if (validateBody && func.getBody () !of EmptyExpression) {
            let frame = copy FrameGenerator (func.getLoc (),
                                             implLoc-> func.getLoc (),
                                             sym.getPath (),
                                             parameters,
                                             retType,
                                             body,
                                             FrameKind::FUNC,
                                             externLang-> sym.getExternalLanguage (),
                                             isWeak-> sym.isWeak (),
                                             templateMapper-> sym.getTemplateMapper ());

            context:.insertGenerator (alias sym, frame);
        }

        let gen = match sym.getTemplateMapper () {
            Ok (map) => {
                copy PrototypeValue (sym.getLoc (), func.getLoc (), sym, parameters, retType, throwers, fromTemplate-> TemplateRewriter (map)?, attributes-> func.getAttributes ())
            }
            _ => {
                copy PrototypeValue (sym.getLoc (), func.getLoc (), sym, parameters, retType, throwers, attributes-> func.getAttributes ())
            }
        };

        if (func.getLoc ().str == Keys::MAIN && gen.isInline ()) {
            throw copy ErrorMsg::fatal (gen.getInlineLoc (), ValidateErrorMessage::MAIN_INLINE);
        }

        if (validateBody) { // If not validate body the prototype might be uncomplete
            self.verifyFunctionCollision (sym, func.getLoc ().str, gen);
            sym:.setFrameProto (gen, body);
        }

        gen
    }

    /**
     * Validate the body of a function
     * @params: 
     *     - context: the context of the validation
     *     - loc: the location of the function
     *     - name: the name of the function
     *     - body: the body of the function
     *     - throwers: the list of throwers
     * @returns: 
     *    - errors: the list of errors 
     *    - .0: the validated value of the body
     *    - .1: true iif the value is not a returner
     */
    fn validateFunctionBody (self, dmut context : &Validator, loc : &Word, name : &SymbolPath, body : &Expression, retType : &Type, throwers : [(&Word, &Type)], unsafeLoc : &Word, forceUnsafe : bool = false, preThrowing : [(&Word, &Type)] = [])-> &Value
        throws ErrorMsg
    {
        match body {
            EmptyExpression () => {
                context:.clearLocalScope ();
                copy UnitValue (loc-> loc)
            }
            _ => {
                if (!unsafeLoc.isEof ()) context:.enterUnsafeContext (unsafeLoc);
                logging::info ("Validate function %", name);

                context:.setFunctionReturn (retType);
                let mut bodyValue = context:.validateValue (body);
                let need = if (!bodyValue.isReturner ()) {
                    if (retType.getLoc ().isEof ()) {
                        bodyValue = context:.verifyCompatibleTypeWithValue (bodyValue.getLoc (), retType, bodyValue, byReference-> false);
                        context.verifyMemoryOwner (bodyValue.getLoc (), retType, bodyValue, byReference-> false);
                    } else {
                        bodyValue = context:.verifyCompatibleTypeWithValue (retType.getLoc (), retType, bodyValue, byReference-> false);
                        context.verifyMemoryOwner (retType.getLoc (), retType, bodyValue, byReference-> false);
                    }
                    
                    match retType {
                        VoidType () => { false }
                        _ => { true }
                    }
                } else { false };
                
                self.verifyThrowing (alias context, loc, name, bodyValue.getThrowers () ~ preThrowing, throwers);

                if (!unsafeLoc.isEof ()) context:.exitUnsafeContext (force-> forceUnsafe);

                if (need) {
                    cast!{&Value} (copy ReturnValue (bodyValue.getLoc (), bodyValue))
                } else {
                    bodyValue
                }
            }
        }
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================           METHODS            =========================
     * ================================================================================
     * ================================================================================
     */


    /**
     * Validate a method
     * @todo: this function is way too long, and way too close to validateFunction and validateConstructor. A refactorization would be great
     * @params:
     *    - context: the context of the validation
     *    - sym: the symbol to validate
     *    - clRef: the type of the class defining the method
     *    - fromTrait: the symbol of the trait if this method is defined inside a trait, (EmptySymbol otherwise)
     *    - validateBody: true iif the body must be validated
     * @returns: the prototype of the method
     * @throws:
     *    - &ErrorMsg: if the validation failed
     */
    fn validateMethod (mut self, dmut context : &Validator, dmut sym : &FunctionSymbol, func : &FunctionDecl, clRef : &ClassRefType, fromTrait : &Symbol, validateBody : bool = false, noValue : bool = false)-> &MethodPrototypeValue
        throws ErrorMsg
    {
        let mut errors : [&ErrorMsg] = [];
        let throwers = self.validateThrowers (alias context, func.getThrowerLoc (), func.getThrowers ());
        self.verifyUndefAttributesMethod (func.getAttributes ());

        let (retType, selfParam, parameters, body) = {
            context:.enterBlock ();
            let selfParam = self.validateSelfParamDecl (func.getFunctionProto ().getParameters()[0], clRef);
            context:.insertLocal (selfParam.getLoc (), selfParam.getLoc ().str, selfParam, canShadow-> true);

            let (retType, parameters) = self:.validatePrototype (alias context, sym, func.getFunctionProto (), forMethod-> true, noValue-> noValue);
            let fieldLoc = self.getFieldLoc (func.getAttributes ());
            if (!fieldLoc.isEof () && parameters.len > 1) {
                throw copy ErrorMsg::fatal (func.getLoc (), ValidateErrorMessage::FIELD_METHOD_PARAMS,
                                            notes-> copy [copy ErrorMsg::note (fieldLoc, ""s8)]);
            }

            if (!fieldLoc.isEof () && (retType of VoidType && parameters.len == 0)) {
                throw copy ErrorMsg::fatal (func.getLoc (), ValidateErrorMessage::FIELD_METHOD_ACCESS_NO_RETURN,
                                            notes-> copy [copy ErrorMsg::note (fieldLoc, ""s8)]);
            }

            if (!fieldLoc.isEof () && (retType !of VoidType && parameters.len == 1)) {
                throw copy ErrorMsg::fatal (func.getLoc (), ValidateErrorMessage::FIELD_METHOD_ASSIGN_WITH_RETURN,
                                            notes-> copy [copy ErrorMsg::note (fieldLoc, ""s8)]);
            }

            if (!fieldLoc.isEof () && (!selfParam.getType ().isMutable () && parameters.len == 1)) {
                throw copy ErrorMsg::fatal (func.getLoc (), ValidateErrorMessage::FIELD_METHOD_ASSIGN_CONST,
                                            notes-> copy [copy ErrorMsg::note (fieldLoc, ""s8)]);
            }



            let body = if (validateBody) {
                context:.enterFunctionBody ();
                let mut unsafeLoc = self.getUnsafeLoc (func.getAttributes ());
                if (unsafeLoc.isEof () && sym.isUnsafe ()) { unsafeLoc = func.getLoc (); } // extern C function are unsafe without attributes

                self.validateFunctionBody (alias context, func.getLoc (), sym.getPath (), func.getBody (), retType, throwers, unsafeLoc)
            } else {
                UNIT_VALUE
            }

            (retType, selfParam, parameters, body)
        } catch {
            err : &ErrorMsg => {
                errors ~= [err];
                (NONE_TYPE, UNIT_VALUE, cast!{[&ProtoVarValue]} ([]), UNIT_VALUE)
            }
        } exit {
            {
                context:.quitBlock (warnUnused-> (errors.len == 0us && validateBody));
            } catch {
                err : &ErrorMsg => { errors ~= [err]; }
            }
        }

        if (errors.len != 0us) throw copy ErrorMsg::list (errors);
        if (validateBody && func.getBody () !of EmptyExpression) {            
            let frame = copy FrameGenerator (func.getLoc (),
                                             implLoc-> clRef.getSymbol ().getLoc (),
                                             sym.getPath (),
                                             copy [selfParam] ~ parameters,
                                             retType,
                                             body,
                                             FrameKind::METHOD,
                                             externLang-> sym.getExternalLanguage (),
                                             isWeak-> (sym.isWeak () || clRef.getSymbol ().isWeak ()),
                                             templateMapper-> sym.getTemplateMapper ());

            context:.insertGenerator (alias sym, frame);
        }


        let gen = match sym.getTemplateMapper () {
            Ok (map) => {
                copy MethodPrototypeValue (sym.getLoc (), sym, parameters, retType, throwers, clRef, trRef-> fromTrait, isMutable-> selfParam.getType ().isMutable (),
                                           isEmpty-> func.getBody () of EmptyExpression, isOver-> sym.isOver (), isFinal-> sym.isFinal (), attributes-> func.getAttributes (),
                                           fromTemplate-> TemplateRewriter (map)?)
            }
            _ => {
                copy MethodPrototypeValue (sym.getLoc (), sym, parameters, retType, throwers, clRef, trRef-> fromTrait, isMutable-> selfParam.getType ().isMutable (),
                                           isEmpty-> func.getBody () of EmptyExpression, isOver-> sym.isOver (), isFinal-> sym.isFinal (), attributes-> func.getAttributes ())
            }
        };

        if (gen.isInline () && (!sym.isFinal () || sym.isOver ())) {
            throw copy ErrorMsg::fatal (gen.getInlineLoc (), format (ValidateErrorMessage::INLINE_VIRTUAL_METHOD, gen));
        }

        gen
    }
    
    /*!
     * ================================================================================
     * ================================================================================
     * =========================            DTORS             =========================
     * ================================================================================
     * ================================================================================
     */

    fn validateDestructor (mut self, dmut context : &Validator, dmut sym : &DestructorSymbol, clRef : &ClassRefType, ancDtor : &Value, validateBody : bool = false)-> &DtorPrototypeValue
        throws ErrorMsg
    {
        let func = sym.getContent ();
        let mut errors : [&ErrorMsg] = [];
        self.verifyUndefAttributesDtor (func.getAttributes ());

        let (retType, selfParam, parameters, body) = {            
            context:.enterBlock ();
            let selfParam = self.validateSelfParamDecl (func.getFunctionProto ().getParameters()[0], clRef);
            if (!selfParam.isMutable ()) {
                throw copy ErrorMsg::fatal (selfParam.getLoc (), format (ValidateErrorMessage::DTOR_SELF_NOT_MUT));
            }
            
            context:.insertLocal (selfParam.getLoc (), selfParam.getLoc ().str, selfParam, canShadow-> true);
            
            let (retType, parameters) = self:.validatePrototype (alias context, sym, func.getFunctionProto (), forMethod-> true);
            let body = if (validateBody) {
                context:.enterFunctionBody ();
                self.validateDtorBody (alias context, func, alias sym, clRef, ancDtor, retType, selfParam)
            } else {
                UNIT_VALUE
            };

            (retType, selfParam, parameters, body)
        } catch {           
            err : &ErrorMsg => {
                errors ~= [err];
                (NONE_TYPE, UNIT_VALUE, cast!{[&ProtoVarValue]} ([]), UNIT_VALUE)
            }
        } exit {
            {
                context:.quitBlock (warnUnused-> (errors.len == 0us && validateBody));
            } catch {
                err : &ErrorMsg => { errors ~= [err]; }
            }
        }

        if (errors.len != 0us) throw copy ErrorMsg::list (errors);
        if (validateBody && func.getBody () !of EmptyExpression) {
            let frame = copy FrameGenerator (func.getLoc (),
                                             implLoc-> clRef.getSymbol ().getLoc (),
                                             sym.getPath (),
                                             copy [selfParam] ~ parameters,
                                             retType,
                                             body,
                                             FrameKind::DTOR,
                                             externLang-> sym.getExternalLanguage (),
                                             isWeak-> (sym.isWeak () || clRef.getSymbol ().isWeak ()),
                                             templateMapper-> sym.getTemplateMapper ());

            context:.insertGenerator (alias sym, frame);
        }


        copy DtorPrototypeValue (sym.getLoc (), sym, clRef)
    }

    /**
     * Finalize the body of the destructor
     * @params:
     *    - context: the context of the validation
     *    - func: the destructor to validate
     *    - sym: the symbol containing the declaration
     *    - clRef: the class ref containing the dtor
     * @returns: the body of the dtor
     * */
    fn validateDtorBody (self, dmut context : &Validator, func : &DestructorDecl, dmut sym : &DestructorSymbol, clRef : &ClassRefType, ancDtor : &Value, retType : &Type, selfParam : &Value)-> &Value
        throws ErrorMsg
    {
        logging::info ("Validate __dtor %", sym.getPath ());
        let innerBl = self.validateFunctionBody (alias context, func.getLoc (), sym.getPath (), func.getBody (), retType, [], EOF_WORD); // dtor can't be unsafe
        let retBl = match ancDtor {
            meth : &DtorPrototypeValue => {
                let selfValue = copy VarRefValue (selfParam.getLoc (), selfParam.getLoc (), selfParam.getType (), selfParam.getUniqId (), isSelf-> true, isReference-> clRef.isStruct ());
                let methDg = copy MethodDelegateValue (func.getLoc (), meth, closure-> selfValue, direct-> true, vtableIndex-> 0us, isStruct-> clRef.isStruct ());
                let call = copy MethodCallValue (func.getLoc (), copy VoidType (func.getLoc ()), methDg, []);
                copy BlockValue (func.getLoc (), copy VoidType (func.getLoc ()), copy [innerBl, call])
            }
            _ => { innerBl }
        }

        let finBl = if (clRef.getSymbol ().isEntity ()) {
            let selfValue = copy VarRefValue (selfParam.getLoc (), selfParam.getLoc (), selfParam.getType (), selfParam.getUniqId (), isSelf-> true, isReference-> clRef.isStruct ());
            match self.validateMovableFieldDtorCall (alias context, selfValue, clRef) {
                moveBl : &BlockValue => {
                    copy BlockValue (func.getLoc (), copy VoidType (func.getLoc ()), copy [retBl, moveBl])
                }
                _ => { retBl }
            }
        } else {
            retBl
        };

        finBl
    }

    /**
     * Validate the call to the dtor of the movable fields of the entity
     * @params:
     *    - context: the context of the validation
     *    - selfParam: the self parameter value
     *    - clRef: the type being destroyed
     * */
    fn validateMovableFieldDtorCall (self, dmut context : &Validator, selfParam : &Value, clRef : &ClassRefType)-> &Value
        throws ErrorMsg
    {
        context;
        let loc = selfParam.getLoc ();
        let mut calls : [&Value] = [];

        for v in clRef.getLocalFields () {
            if (v.getVarType ().isMovable ()) match v.getVarType () {
                c : &ClassPtrType => {
                    if let dt : &DtorPrototypeValue = c.getInner ().getDestructor () {
                        let fieldAccess = copy StructFieldAccessValue (loc, c, selfParam, v.getLoc ().str);
                        let methDg = copy MethodDelegateValue (loc,
                                                               dt,
                                                               closure-> fieldAccess, direct-> true, vtableIndex-> 0us, isStruct-> true);

                        let boolType = copy BoolType (loc);
                        let lSet = copy StructFieldAccessValue (loc, boolType, fieldAccess, ClassKeys::SET);
                        let call = copy MethodCallValue (loc, VOID_TYPE, methDg, []);
                        let postCall = copy AffectValue (loc, VOID_TYPE, lSet, copy BoolValue (loc, false));
                        let instrs = copy BlockValue (loc, VOID_TYPE, copy [call, postCall, UNIT_VALUE], isSet-> true);
                        // if field.#_set { __dtor (field); field.#_set = 0; }

                        let cond = copy ConditionalValue (loc, VOID_TYPE, lSet, instrs, UNIT_VALUE);
                        calls ~= [cond];
                    }
                }
            }
        }

        if (calls.len == 0us) return UNIT_VALUE;
        copy BlockValue (selfParam.getLoc (), VOID_TYPE, calls)
    }
    
    /*!
     * ================================================================================
     * ================================================================================
     * =========================            CTORS             =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a constructor
     * @todo: this function is way too long, and way too close to validateFunction and validateMethod. A refactorization would be great
     * @params: 
     *    - context: the context of the validation
     *    - sym: the symbol to validate
     *    - clRef: the class type for self
     *    - validateBody: validate the body of the constructor (and field/ancestor constructions)
     * @returns: the prototype of the ctor
     * @throws:
     *    - &ErrorMsg: if the validation failed
     */
    fn validateConstructor (mut self, dmut context : &Validator, dmut sym : &ConstructorSymbol, clRef : &ClassRefType, validateBody : bool = false, noValue : bool = false)-> &CtorPrototypeValue
        throws ErrorMsg
    {
        if validateBody {
            if clRef.isStruct () {
                return self:.validateStructConstructor (alias context, alias sym, clRef);
            } else {
                return self:.validateClassConstructor (alias context, alias sym, clRef);
            }
        }

        let func = sym.getContent ();
        let throwers = self.validateThrowers (alias context, func.getThrowerLoc (), func.getThrowers ());
        self.verifyUndefAttributes (func.getAttributes ());

        let mut errors : [&ErrorMsg] = [];
        let (parameters) = {
            context:.enterBlock ();
            // We need a class ptr for the self parameter
            let (_, parameters) = self:.validatePrototype (alias context, sym, func.getFunctionProtoDecl (), forMethod-> false, noValue-> noValue); // unlike methods self is not written in the prototype, so we need to validate all parameters

            parameters
        } catch {
            err : &ErrorMsg => {
                errors ~= [err];
                []
            }
        } exit {
            {
                context:.quitBlock (warnUnused-> (errors.len == 0us && validateBody));
            } catch {
                err : &ErrorMsg => { errors ~= [err]; }
            }
        }

        if (errors.len != 0us) throw copy ErrorMsg::list (errors);
        let rewrite = if let Ok (map) = sym.getTemplateMapper () {
            TemplateRewriter (map)?
        } else { none };

        copy CtorPrototypeValue (sym.getLoc (),
                                 sym,
                                 parameters,
                                 throwers,
                                 clRef,
                                 rename-> func.getRename ().str,
                                 attributes-> func.getAttributes (),
                                 fromTemplate-> rewrite)
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =============================          STRUCT CTOR VALIDATION          =============================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Validate a constructor for a structure (simpler than class ctors, as there is no closure to create)
     * @params:
     *    - context: the context of the validation
     *    - sym: the symbol to validate
     *    - clRef: the struct containing the constructor
     * @returns: the prototype of the ctor
     * */
    fn validateStructConstructor (mut self, dmut context : &Validator, dmut sym : &ConstructorSymbol, clRef : &ClassRefType)-> &CtorPrototypeValue
        throws ErrorMsg
    {
        let func = sym.getContent ();
        let throwers = self.validateThrowers (alias context, func.getThrowerLoc (), func.getThrowers ());

        let mut errors : [&ErrorMsg] = [];

        let (selfParam, parameters, preConstruct, body, hasRedirect) = {
            context:.enterBlock ();
            // We need a class ptr for the self parameter
            let clPtr = clRef.createInstance (true, true);

            // Self parameters (first hidden param)
            let selfParam = copy ProtoVarValue (copy Word (Keys::SELF, func.getLoc ()), clPtr, UNIT_VALUE, true, isSelf-> true, isReference-> true);

            // unlike methods self is not written in the prototype, so we need to validate all parameters (hence: forMethod-> false)
            let (_, parameters) = self:.validatePrototype (alias context, sym, func.getFunctionProtoDecl (), forMethod-> false, noValue-> false);

            // We validate the body
            let (preConstruct, body, hasRedirect) = self.validateStructCtorBody (alias context, sym, func, clPtr.getInner (), selfParam, throwers);

            // don't add the self parameter in the prototype, we don't have it when calling the prototypea
            (selfParam, parameters, preConstruct, body, hasRedirect)
        } catch {
            err : &ErrorMsg => {
                errors ~= [err];
                (UNIT_VALUE, cast!{[&ProtoVarValue]} ([]), UNIT_VALUE, UNIT_VALUE, false)
            }
        } exit {
            {
                context:.quitBlock (warnUnused-> (errors.len == 0us));
            } catch {
                err : &ErrorMsg => { errors ~= [err]; }
            }
        }

        if (errors.len != 0us) throw copy ErrorMsg::list (errors);
        let rewrite = if let Ok (map) = sym.getTemplateMapper () {
            TemplateRewriter (map)?
        } else { none };

        if (func.getBody () !of EmptyExpression) {
            if let selfV : &ProtoVarValue = selfParam {
                let params = copy [selfV] ~ parameters;
                let frame = copy FrameGenerator (func.getLoc (),
                                                 implLoc-> clRef.getSymbol ().getLoc (),
                                                 sym.getPath (),
                                                 params,
                                                 VOID_TYPE,
                                                 copy BlockValue (func.getLoc (), VOID_TYPE, copy [preConstruct, body]),
                                                 FrameKind::CTOR,
                                                 isWeak-> (sym.isWeak () || clRef.getSymbol ().isWeak ()),
                                                 templateMapper-> sym.getTemplateMapper ());

                context:.insertGenerator (alias sym, frame);
            } else panic;
        }

        let gen = copy CtorPrototypeValue (sym.getLoc (), sym, parameters, throwers, clRef, rename-> func.getRename ().str,
                                         attributes-> func.getAttributes (), fromTemplate-> rewrite);

        if (hasRedirect) {
            sym:.setFrameProto (gen, preConstruct, hasRedirect);
            let mut entered : [&Symbol => mut ()] = copy [];
            context.verifyInfiniteCtorRecursion (gen, ref entered);
        }

        gen
    }

    /**
     * Validation of the body of the constructor
     * This function is different from validateFunctionBody, because it also validates the pre constructor
     * @params:
     *    - context: the context of the validation
     *    - sym: the symbol being validated
     *    - ctor: the ctor whose body is being validated
     *    - clRef: the type of the class containing the ctor
     *    - selfParam: the protovarvalue of the hidden self parameter
     * @returns:
     *    - .0: the body of the preConstruction
     *    - .1: the body of the postConstruction
     *    - .2: true iif the ctor calls a redirect constructor
     * @throws:
     *    - &ErrorMsg: if there was an error in the validation
     */
    fn validateStructCtorBody (self, dmut context : &Validator, sym : &ConstructorSymbol, ctor : &ConstructorDecl, clRef : &ClassRefType, selfParam : &Value, throwers : [(&Word, &Type)])-> (&Value, &Value, bool)
        throws ErrorMsg
    {
        logging::info ("Validate struct ctor %", sym.getPath ());

        // Reference to the self hidden param
        let selfValue = copy VarRefValue (selfParam.getLoc (), selfParam.getLoc (), selfParam.getType (), selfParam.getUniqId (), isSelf-> true, isReference-> clRef.isStruct ());
        
        // Validate the pre construction of the constructor (construction of fields, and ancestor)
        let (preConstruct, hasRedirect) = self.validateStructPreConstructor (alias context, ctor, clRef, selfValue);

        // insert self in the scope, alongside with parameters (its an hidden param)
        context:.insertLocal (selfParam.getLoc (), selfParam.getLoc ().str, selfParam, canShadow-> true);
        context:.getLocal (selfParam.getLoc (), selfParam.getLoc ().str, canBeInClosure-> false);

        // From this point, return is allowed
        context:.enterFunctionBody ();

        let mut unsafeLoc = self.getUnsafeLoc (ctor.getAttributes ());
        if (unsafeLoc.isEof () && sym.isUnsafe ()) { unsafeLoc = ctor.getLoc (); } // extern C function are unsafe without attributes

        // Validate the body of the constructor (return void type)
        let body = self.validateFunctionBody (alias context,
                                              ctor.getLoc (),
                                              sym.getPath (),
                                              ctor.getBody (),
                                              copy VoidType (sym.getLoc ()),
                                              preThrowing-> preConstruct.getThrowers (),
                                              throwers,
                                              unsafeLoc);



        (preConstruct, body, hasRedirect)
    }       

    /**
     * Validate the pre construction of a constructor
     * @params: 
     *    - context: the context of the validation
     *    - sym: the symbol being validated
     *    - func: the declaration to validate
     *    - clRef: the type of self
     *    - selfParam: the self parameter
     * @returns: the value containing the constructions statements
     * @throws: 
     *    - &ErrorMsg: if there was an error in the validation
     */
    fn validateStructPreConstructor (self, dmut context : &Validator, func : &ConstructorDecl, clRef : &ClassRefType, selfParam : &Value)-> (&Value, bool)
        throws ErrorMsg
    {
        if (func.getExplicitCstrsCall () == Keys::SELF) { // There is a redirection of construction
            return (self.validateStructRedirectCtor (alias context, func, clRef, selfParam), true);
        }

        // Struct don't have ancestors
        else if (func.getExplicitCstrsCall () == Keys::SUPER) {
            throw copy ErrorMsg::fatal (func.getExplicitCstrsCall (), format (ValidateErrorMessage::NO_SUPER_CLASS, clRef));
        }

        let mut block : [&Value] = []; // list of instructions
        let fieldCtor = self.validateFieldCtors (alias context, func, clRef, selfParam);
        match fieldCtor {
            UnitValue () => {} // Don't add an empty value
            _ => {
                block ~= [fieldCtor]; // there are field constructions
            }
        }

        (copy BlockValue (func.getLoc (), VOID_TYPE, block), false)
    }

    /**
     * Validate the call of a redirect constructor
     * @params: 
     *    - context: the context of the validation
     *    - sym: the symbol being validated
     *    - func: the declaration of the constructor
     *    - clRef: the type of the class that is being validated
     * @returns: the instruction calling the redirect constructor
     * @throws: 
     *    - &ErrorMsg: if there is an error in the validation
     */
    fn validateStructRedirectCtor (self, dmut context : &Validator, func : &ConstructorDecl, clRef : &ClassRefType, selfParam : &Value, nextDg : &Value = UNIT_VALUE)-> &Value
        throws ErrorMsg
    {
        let mut errors : [&ErrorMsg] = [];
        let mut rights : [&Value] = [];

        let selfLoc = func.getExplicitCstrsCall ();
        for v in func.getSuperParams () { // Validate the parameters that are passed to the redirect constructor
            rights ~= [context:.validateValue (v)];
        }
        
        let ret = {
            // Ignore the current constructor, it cannot be called by redirection
            let ctors = self.createCtorDelegate (alias context, selfLoc, clRef, selfParam, nextDg-> nextDg,
                                                 renameLoc-> func.getExplicitSuperName (),
                                                 templateParams-> func.getSuperTemplateParams ());

            context:.getCallOpValidator ().validate (alias context, selfLoc, ctors, rights, inCopy-> true)
        } catch { 
            err : &ErrorMsg => { // None succeeded (TODO print private candidates)
                errors ~= [copy ErrorMsg::fatal (selfLoc, format (ValidateErrorMessage::UNDEFINED_REDIRECT_CALL_CTOR, rights),
                                                 notes-> copy [err])];
                UNIT_VALUE
            }
        }

        for it in func.getFieldConstructors () {
            errors ~= [copy ErrorMsg::fatal (it._0, format (ValidateErrorMessage::ALREADY_INIT_BY_CTOR_REDIRECT, it._0.str),
                                             notes-> copy [copy ErrorMsg::note (selfLoc, ""s8)])];
        }

        if (errors.len != 0us) throw copy ErrorMsg::list (errors);
        ret
    }


    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =============================          CLASS CTOR VALIDATION          ==============================
     * ====================================================================================================
     * ====================================================================================================
     */


    /**
     * Validate a constructor for a structure (simpler than class ctors, as there is no closure to create)
     * @params:
     *    - context: the context of the validation
     *    - sym: the symbol to validate
     *    - clRef: the struct containing the constructor
     * @returns: the prototype of the ctor
     * */
    fn validateClassConstructor (mut self, dmut context : &Validator, dmut sym : &ConstructorSymbol, clRef : &ClassRefType)-> &CtorPrototypeValue
        throws ErrorMsg
    {
        let func = sym.getContent ();
        let throwers = self.validateThrowers (alias context, func.getThrowerLoc (), func.getThrowers ());

        let mut errors : [&ErrorMsg] = [];

        let (selfParam, parameters, nextDg, body, hasRedirect) = {
            context:.enterBlock ();
            // We need a class ptr for the self parameter
            let clPtr = clRef.createInstance (true, true);

            // Self parameters (first hidden param)
            let selfParam = copy ProtoVarValue (copy Word (Keys::SELF, func.getLoc ()), clPtr, UNIT_VALUE, isMutable-> true, isSelf-> true, isReference-> false);

            // unlike methods self is not written in the prototype, so we need to validate all parameters (hence: forMethod-> false)
            let (_, parameters) = self:.validatePrototype (alias context, sym, func.getFunctionProtoDecl (), forMethod-> false, noValue-> false);

            // Class ctor have a delegate as last parameters if the class is not final
            // This delegate is called after field init, to init the fields of child class before entering ctor body
            let dgType = copy DelegateType (func.getLoc (), [], [], [], VOID_TYPE, canBeNull-> true);
            let nextDg = copy ProtoVarValue (copy Word (ClassKeys::NEXT, func.getLoc ()), dgType, UNIT_VALUE, isMutable-> false, isReference-> false);

            // We validate the body
            let (body, hasRedirect) = self:.validateClassCtorBody (alias context, alias sym, func, clPtr.getInner (), selfParam, parameters, nextDg, throwers);

            // don't add the self parameter in the prototype, we don't have it when calling the prototypea
            (selfParam, parameters, (nextDg)?, body, hasRedirect)
        } catch {
            err : &ErrorMsg => {
                errors ~= [err];
                (UNIT_VALUE, cast!{[&ProtoVarValue]} ([]), none, UNIT_VALUE, none)
            }
        } exit {
            {
                context:.quitBlock (warnUnused-> (errors.len == 0us));
            } catch {
                err : &ErrorMsg => { errors ~= [err]; }
            }
        }

        if (errors.len != 0us) throw copy ErrorMsg::list (errors);
        let rewrite = if let Ok (map) = sym.getTemplateMapper () {
            TemplateRewriter (map)?
        } else { none };

        if (func.getBody () !of EmptyExpression) {
            if let selfV : &ProtoVarValue = selfParam {
                let mut params = copy [selfV] ~ parameters;
                if let Ok (n : &ProtoVarValue) = nextDg { params ~= [n]; };

                let frame = copy FrameGenerator (func.getLoc (),
                                                 implLoc-> clRef.getSymbol ().getLoc (),
                                                 sym.getPath (),
                                                 params, VOID_TYPE,
                                                 body,
                                                 FrameKind::CTOR_CLASS,
                                                 isWeak-> (sym.isWeak () || clRef.getSymbol ().isWeak ()),
                                                 templateMapper-> sym.getTemplateMapper ());

                context:.insertGenerator (alias sym, frame);
            } else panic;
        }

        let gen = copy CtorPrototypeValue (sym.getLoc (), sym, parameters, throwers, clRef,
                                           rename-> func.getRename ().str,
                                           attributes-> func.getAttributes (),
                                           fromTemplate-> rewrite);

        if let Ok (call) = hasRedirect {
            sym:.setFrameProto (gen, call, true);
            let mut entered : [&Symbol => mut ()] = copy [];
            context.verifyInfiniteCtorRecursion (gen, ref entered);
        }

        gen
    }

    /**
     * Validation of the body of the constructor
     * This function is different from validateFunctionBody, because it also validates the pre constructor
     * @params:
     *    - context: the context of the validation
     *    - sym: the symbol being validated
     *    - ctor: the ctor whose body is being validated
     *    - clRef: the type of the class containing the ctor
     *    - selfParam: the protovarvalue of the hidden self parameter
     * @returns:
     *    - .0: the call to the preCtor
     *    - .1: the call to the postCtor
     *    - .2: true iif there is a redirection
     * @throws:
     *    - &ErrorMsg: if there was an error in the validation
     */
    fn validateClassCtorBody (mut self, dmut context : &Validator, dmut sym : &ConstructorSymbol, ctor : &ConstructorDecl, clRef : &ClassRefType, selfParam : &Value, parameters : [&ProtoVarValue], nextDg : &ProtoVarValue, throwers : [(&Word, &Type)])-> (&Value, (&Value)?)
        throws ErrorMsg
    {
        logging::info  ("Validate class ctor %", sym.getPath ());

        // Validate the pre constructor closure frame
        let (preBody, preThrowers, hasRedirect) = self:.validateClassPreCtor (alias context, alias sym, ctor, clRef, selfParam, parameters, nextDg);

        let mut bodyValues : [&Value] = [];
        if preBody !of UnitValue {
            bodyValues ~= [preBody];
        }

        // insert self in the scope, alongside with parameters (its an hidden param)
        context:.insertLocal (selfParam.getLoc (), selfParam.getLoc ().str, selfParam, canShadow-> true);
        context:.getLocal (selfParam.getLoc (), selfParam.getLoc ().str, canBeInClosure-> false);


        // From this point, return is allowed
        context:.enterFunctionBody ();

        let mut unsafeLoc = self.getUnsafeLoc (ctor.getAttributes ());
        if (unsafeLoc.isEof () && sym.isUnsafe ()) { unsafeLoc = ctor.getLoc (); } // extern C function are unsafe without attributes

        let body = self.validateFunctionBody (alias context,
                                              ctor.getLoc (),
                                              sym.getPath (),
                                              ctor.getBody (),
                                              VOID_TYPE,
                                              preThrowing-> preThrowers,
                                              throwers,
                                              unsafeLoc);

        bodyValues ~= [body];
        (copy BlockValue (selfParam.getLoc (), VOID_TYPE, bodyValues), if hasRedirect { preBody? } else { none })
    }


    /**
     * Validate the construction of the fields, and the call to parent ctor
     * */
    fn validateClassPreCtor (mut self, dmut context : &Validator, dmut sym : &ConstructorSymbol, func : &ConstructorDecl, clRef : &ClassRefType, selfParam : &Value, parameters : [&ProtoVarValue], nextDg : &ProtoVarValue)-> (&Value, [(&Word, &Type)], bool)
        throws ErrorMsg
    {
        let selfValue = copy VarRefValue (selfParam.getLoc (), selfParam.getLoc (),
                                          selfParam.getType (), selfParam.getUniqId (),
                                          isSelf-> true,
                                          isReference-> false);

        // There is a redirection of construction
        if (func.getExplicitCstrsCall () == Keys::SELF) {
            let nextValue = copy VarRefValue (nextDg.getLoc (), nextDg.getLoc (),
                                              nextDg.getType (), nextDg.getUniqId (),
                                              isSelf-> true,
                                              isReference-> false);

            let body = self.validateStructRedirectCtor (alias context, func, clRef, selfValue, nextDg-> nextValue);
            return (body, body.getThrowers (), true);
        }

        // No ancestor, everything can be inlined
        if !clRef.getAncestor ().hasValue {
            // Struct don't have ancestors
            if (func.getExplicitCstrsCall () == Keys::SUPER) {
                throw copy ErrorMsg::fatal (func.getExplicitCstrsCall (), format (ValidateErrorMessage::NO_SUPER_CLASS, clRef));
            }

            let mut block : [&Value] = [];
            let fieldCtor = self.validateFieldCtors (alias context, func, clRef, selfValue);
            if fieldCtor !of UnitValue {
                block ~= [fieldCtor];
            }

            let nextValue = copy VarRefValue (nextDg.getLoc (), nextDg.getLoc (),
                                              nextDg.getType (), nextDg.getUniqId (),
                                              isSelf-> true,
                                              isReference-> false);

            let nextCall = context:.getCallOpValidator ().validate (alias context, nextValue.getLoc (), nextValue, []);
            block ~= [nextCall];

            let body = copy BlockValue (func.getLoc (), VOID_TYPE, block);
            return (body, body.getThrowers (), false);
        }

        else { // If the class has an ancestor we have to validate a lambda function to initialize the fields of the class before calling the body of the parent ctor
            let (dgValue, throwers) = self:.validateClassLambdaPre (alias context, alias sym, func, clRef, selfParam, parameters, nextDg);
            let ancCall = self.validateAncestorCtorCall (alias context, func, clRef, selfValue, dgValue);

            return (ancCall, (ancCall.getThrowers () ~ throwers), false);
        }
    }

    fn validateClassLambdaPre (mut self, dmut context : &Validator, dmut sym : &ConstructorSymbol, func : &ConstructorDecl, clRef : &ClassRefType, selfParam : &Value, parameters : [&ProtoVarValue], nextDg : &ProtoVarValue)-> (&Value, [(&Word, &Type)])
        throws ErrorMsg
    {
        let refId = generator::generateUniqID ();
        let index = context.getCurrentClosingIndex ();
        let mut errors : [&ErrorMsg] = [];

        let name = format ("_%_%", sym.getLoc ().line, sym.getLoc ().col);
        let frameName = sym.getPath ().push (name);

        // Enter a foreign because we don't want to pollute the current function scope
        context:.enterForeign (isLambda-> true, isFnBody-> true, clContext-> context.getCurrentClassContext ());
        context:.enterBlock ();
        let dmut closureValues : [&Value] = [];
        let dmut closureTypes : [&Type] = [];

        let (body, closure) = {
            context:.enterClosure (func.getLoc (), refId, index);
            let body = {
                let selfValue = copy VarRefValue (selfParam.getLoc (), selfParam.getLoc (),
                                                  selfParam.getType (), selfParam.getUniqId (),
                                                  isSelf-> true,
                                                  isReference-> false);

                closureValues ~= [selfValue];
                closureTypes ~= [selfParam.getType ()];

                let closuredSelf = context:.forceInClosure (func.getLoc (), Keys::SELF, selfValue.getType (), byReference-> false);
                let nextDgValue = copy VarRefValue (nextDg.getLoc (), nextDg.getLoc (),
                                                    nextDg.getType (), nextDg.getUniqId (),
                                                    isSelf-> true,
                                                    isReference-> false);

                closureValues ~= [nextDgValue];
                closureTypes ~= [nextDg.getType ()];

                let closuredNext = context:.forceInClosure (func.getLoc (), ClassKeys::NEXT, nextDgValue.getType (), byReference-> false);
                for v in parameters {
                    let refVar : &Value = copy VarRefValue (v.getLoc (), v.getLoc (), v.getType (), v.getUniqId (),
                                                            isSelf-> false,
                                                            isReference-> v.isReference ());
                    let addrVar = copy AddressValue (v.getLoc (), copy PointerType (refVar.getLoc (), refVar.getType (), isMutable-> true), refVar);
                    context:.forceInClosure (func.getLoc (), v.getLoc ().str, refVar.getType (), byReference-> true);
                    closureValues ~= [addrVar];
                    closureTypes ~= [addrVar.getType ()];
                }

                context:.finalizeClosure ();

                let mut block : [&Value] = [];
                let fieldCtor = self.validateFieldCtors (alias context, func, clRef, closuredSelf);
                if fieldCtor !of UnitValue {
                    block ~= [fieldCtor];
                }

                let nextCall = context:.getCallOpValidator ().validate (alias context, closuredNext.getLoc (), closuredNext, []);
                block ~= [nextCall];

                copy BlockValue (func.getLoc (), VOID_TYPE, block)
            } catch {
                err => {
                    errors ~= [err];
                    UNIT_VALUE
                }
            };

            let closure = context:.exitClosure ();

            (body, closure)
        };

        {
            context:.quitBlock (warnUnused-> false);
            context:.exitForeign ();
        } catch {
            err => { errors ~= [err]; }
        }

        if errors.len != 0 {
            throw copy ErrorMsg::list (errors);
        }

        let closureType = copy TupleType (closure.getLoc (), closureTypes);
        let ptrType = copy PointerType (closure.getLoc (), closureType, isMutable-> false);

        let fstParam = copy ProtoVarValue (copy Word ("#{CLOSURE-VARREF}"s8, closure.getLoc ()), ptrType, refId-> refId);
        let frame = copy FrameGenerator (func.getLoc (),
                                         implLoc-> clRef.getSymbol ().getLoc (),
                                         frameName,
                                         copy [fstParam],
                                         VOID_TYPE,
                                         body,
                                         FrameKind::LMBD,
                                         isWeak-> (sym.isWeak () || clRef.getSymbol ().isWeak ()),
                                         templateMapper-> sym.getTemplateMapper ());


        let closureValue = copy AddressValue (func.getLoc (), ptrType, copy TupleValue (closure.getLoc (), closureType, closureValues));

        let proto = copy NamePrototypeValue (func.getLoc (), implLoc-> clRef.getSymbol ().getLoc (), frameName, copy [fstParam], VOID_TYPE, isLambda-> true);
        let dgValue = copy NameDelegateValue (func.getLoc (),
                                              proto,
                                              closure-> closureValue,
                                              references-> [],
                                              lazys-> [],
                                              parameters-> [],
                                              retType-> VOID_TYPE,
                                              fromFptr-> false);

        context:.insertGenerator (alias sym, frame);

        return (dgValue, body.getThrowers ());
    }

    /**
     * Validate the call of the ancestor constructor (if there is an ancestor)
     * @params: 
     *    - context: the context of the validation
     *    - func: the declaration of the constructor
     *    - clRef: the type of the class that is being validated
     *    - selfParam: the self parameters
     * @returns: An option if class has an ancestor
     *    - .0: the call to the pre part of the ancestor constructor
     *    - .1: the call to the post part of the ancestor constructor
     * @throws: 
     *    - &ErrorMsg: if there is an error in the validation
     */
    fn validateAncestorCtorCall (self, dmut context : &Validator, func : &ConstructorDecl, clRef : &ClassRefType, selfParam : &Value, childDg : &Value)-> &Value
        throws ErrorMsg
    {
        if let Ok (ancestor) = clRef.getAncestor () {
            // If the super call is implicit, we need a valid location
            let superLoc = if (func.getExplicitCstrsCall ().isEof ()) { func.getLoc () } else { func.getExplicitCstrsCall () };
            let mut rights : [&Value] = copy [context:.validateValue (v) for v in func.getSuperParams ()];

            {
                let ctors = self.createCtorDelegate (alias context, superLoc, ancestor, selfParam, childDg, renameLoc-> func.getExplicitSuperName (), templateParams-> func.getSuperTemplateParams ());

                // Call the ctors with the parameters and return the one that succeeded
                return context:.getCallOpValidator ().validate (alias context, superLoc, ctors, rights, inCopy-> true);
            } catch {
                err : &ErrorMsg => { // None succeeded (TODO print private candidates)
                    throw copy ErrorMsg::fatal (superLoc, format (ValidateErrorMessage::UNDEFINED_SUPER_CALL_CTOR, rights),
                                                notes-> copy [err]);
                }
            }
        }

        panic;
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ==================================          COMMON CTOR          ===================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Create a mult sym containing all the constructor of the class with the given instance
     * @params: 
     *    - loc: the location of the call
     *    - clRef: the class whose constructors are used
     *    - selfParam: the instance for self
     *    - withPrivate: include PRV_PARENT constructors ?
     *    - prettyStr: the name of the call
     * @returns: a MultSymValue with all the available ctors (can be of len == 0us)
     */
    fn createCtorDelegate (self, dmut context : &Validator, loc : &Word, clRef : &ClassRefType, selfParam : &Value, nextDg : &Value, renameLoc : &Word, templateParams : &Expression)-> &Value
        throws ErrorMsg
    {
        let rename = if (renameLoc.isEof ()) { "" } else { renameLoc.str };
        let ctors = context:.getSubTypeValidator ().validateClassCtors (alias context, loc, clRef, name-> rename, selfParam-> selfParam, nextDg-> nextDg, fromSubType-> true);

        match templateParams {
            EmptyExpression () => { ctors }
            tmp : &TemplateCallExpr => {
                let mt = match ctors {
                    m : &MultSymValue => { m }
                    x : _ => { copy MultSymValue (x.getLoc (), copy [x], prettyStr-> format ("%", tmp)) }
                };

                let list = context:.validateTemplateArgumentList (tmp.getRights ());
                context:.getValueValidator ().validateTemplateCallMultSym (alias context, loc, mt, list)
            }
            _ => panic;
        }
    }
    
    /**
     * Validate the field constructors
     * @params: 
     *    - context: the context of the validation
     *    - func: the declaration of the constructor
     *    - clRef: the type of the class that is being validated
     *    - selfParam: the parameter self              
     * @returns: the instructions affecting values to the fields
     * @throws: 
     *     - &ErrorMsg: if there is an error in the validation
     */
    fn validateFieldCtors (self, dmut context : &Validator, func : &ConstructorDecl, clRef : &ClassRefType, selfParam : &Value)-> &Value
        throws ErrorMsg
    {
        let mut instrs : [&Value] = [];
        let mut errors : [&ErrorMsg] = [];
        let mut init : [[c8] => mut &Word] = copy [];

        context:.enterFieldConstruction (clRef); // Enter this context modifies the behavior of Dot operator, by saying the uninitialized fields of type 'clRef' cannot be accessed
        context:.enterBlock ();


        if let Ok (anc : &ClassRefType) = clRef.getAncestor () {
            let superProxy = copy SuperProxyValue (selfParam.getLoc (),
                                                   copy ClassFieldAccType (selfParam.getLoc (), anc, full-> true),
                                                   selfParam);

            context:.insertLocal (selfParam.getLoc (), Keys::SUPER, superProxy, canShadow-> true);
        }

        let dmut selfProxyType = copy ClassFieldAccType (selfParam.getLoc (), clRef);
        let selfProxy = copy SuperProxyValue (selfParam.getLoc (),
                                               selfProxyType,
                                               selfParam, isSelf-> true);

        context:.insertLocal (selfParam.getLoc (), Keys::SELF, selfProxy, canShadow-> true);

        {
            let mut willBeValidated : [[c8] => mut ()] = copy [];
            for it in func.getFieldConstructors () { // We need a list of fields that will be validated by pre construction (ref 1)
                willBeValidated [it._0.str] = ();
            }

            // Verify that all fields have an initial value
            for v in clRef.getLocalFields () {
                {
                    if (v.getLoc ().str !in willBeValidated) { // (cite 1), so we can initialize the fields that are not pre constructed first
                        if (v.getValue () of UnitValue) {
                            errors ~= [copy ErrorMsg::fatal (v.getLoc (), format (ValidateErrorMessage::UNINIT_FIELD, v.getLoc ().str))];
                        } else {
                            let field = context:.getBinOpValidator ().validateClassFieldAccess (alias context, v.getLoc (), selfParam, copy VarExpr (v.getLoc ()), clRef, true, true, withAncestor-> false);
                            instrs ~= [copy AffectValue (v.getLoc (), field.getType (), field, v.getValue ())];
                            context:.setFieldValidated (v.getLoc ().str);
                            init [v.getLoc ().str] = v.getLoc ();
                            selfProxyType:.insertValidated (v.getLoc ().str);
                        }
                    }
                } catch {
                    err : &ErrorMsg => { errors ~= [err]; }
                }
            }

            // Validate all the fields that are written in the pre construction after fields that have default values
            for it in func.getFieldConstructors () {
                {
                    let name = it._0;
                    if let Ok (w : &Word) = init [name.str] {
                        let notes = copy [copy ErrorMsg::note (w, format (ValidateErrorMessage::HERE))];
                        errors ~= [copy ErrorMsg::fatal (name, format (ValidateErrorMessage::MULTIPLE_FIELD_INIT, name.str),
                                                         notes-> notes)];

                    } else {
                        let field = context:.getBinOpValidator ().validateClassFieldAccess (alias context, name, selfParam, copy VarExpr (name), clRef, true, true, withAncestor-> false);
                        let value = context:.verifyCompatibleTypeWithValue (field.getLoc (), field.getType (), context:.validateValue (it._1), byReference-> false);
                        context.verifyMemoryOwner (field.getLoc (), field.getType (), value, byReference-> false);

                        instrs ~= [copy AffectValue (name, field.getType (), field, value)];
                        context:.setFieldValidated (name.str);
                        init [name.str] = name;
                        selfProxyType:.insertValidated (name.str);
                    }
                } catch {
                    err : &ErrorMsg => { errors ~= [err]; }
                }
            }
        }

        {
            context:.quitBlock (warnUnused-> false);
        } catch {
            err => { errors ~= [err]; }
        }

        context:.quitFieldConstruction (); // We don't forget to quit the field validation, from that point all fields are accessible
        if (errors.len != 0us) throw copy ErrorMsg::list (errors);
        if (instrs.len != 0us) {
            // returns the list of constructions
            copy BlockValue (func.getLoc (), VOID_TYPE, instrs)
        } else { 
            UNIT_VALUE // No instrs, no need to open a block
        }
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================           THROWERS           =========================
     * ================================================================================
     * ================================================================================
     */
    
    /**
     * Validate the throwers a function
     * @params: 
     *    - context: the context of the validation
     *    - throwers: the list of throwers
     * @returns: 
     *    - errors: the list of errors that occurs in the validation
     *    - the list of throwers
     */
    fn validateThrowers (self, dmut context : &Validator, loc : &Word, throwers : [&Expression])-> [(&Word, &Type)]
        throws ErrorMsg
    {
        // No need to validate core::exception::Exception if there is no throws
        if (throwers.len == 0us) return [];

        let mut errors : [&ErrorMsg] = [];
        let mut rets : [(&Word, &Type)] = [];
        let exceptionType = context:.getExceptionType (loc-> loc);
        let innerExc = exceptionType.getInner ();

        for i in throwers {
            {
                let type = context:.validateType (i);
                match type {
                    cptr : &ClassRefType => {
                        if (context.isAncestor (exceptionType, cptr) || context.isDirectInstance (exceptionType, cptr)) {
                            rets ~= [(i.getLoc (), type)];
                        } else {
                            errors ~= [copy ErrorMsg::fatal (i.getLoc (), end-> exceptionType.getLoc (), format (ValidateErrorMessage::NOT_AN_EXCEPTION_CLASS, cptr, innerExc))];
                        }
                    }
                    cptr : &ClassPtrType => {
                        errors ~= [copy ErrorMsg::fatal (i.getLoc (), format (ValidateErrorMessage::CLASS_THROW_PTR, type))];
                        if (context.isAncestor (exceptionType, cptr) || context.isDirectInstance (exceptionType, cptr)) {
                            rets ~= [(i.getLoc (), type)];
                        } else {
                            errors ~= [copy ErrorMsg::fatal (i.getLoc (), end-> exceptionType.getLoc (), format (ValidateErrorMessage::NOT_AN_EXCEPTION_CLASS, cptr.getInner (), innerExc))];
                        }
                    }
                    _ => {                        
                        errors ~= [copy ErrorMsg::fatal (i.getLoc (), format (ValidateErrorMessage::NOT_A_CLASS, type))];
                    }
                }
            } catch {
                err : &ErrorMsg => { errors ~= [err]; }
            }
        }

        if (errors.len != 0us) {
            throw copy ErrorMsg::list (errors);
        }

        rets
    }

    /**
     * Verify that the declared throws and the actual thrown of the function are similar
     * @params: 
     *    - context: the context of the function
     *    - loc: the location of the definition of the function
     *    - name: the name of the function
     *    - thrown: the list of type that are thrown by the body
     *    - expected: the list of type that are declared in the prototype as throws
     * @returns: 
     *     - errors: the list of errors during the validation
     */
    fn verifyThrowing (self, dmut context : &Validator, loc : &Word, name : &SymbolPath, thrown : [(&Word, &Type)], expected : [(&Word, &Type)])
        throws ErrorMsg
    {
        let (notFound, unused) = self.listUnusedThrows (context, thrown, expected);
        let mut lst : [&Type] = [];
        let mut errors : [mut &ErrorMsg] = [];
        for i in notFound {
            let mut found = false;
            for index, j in lst {
                if i._1 == j {
                    found = true;
                    errors [index] = errors [index].withNote (copy [copy ErrorMsg::note (i._0, ""s8)]);
                    break;
                }
            }
            
            if (!found) {            
                errors ~= [copy ErrorMsg::fatal (loc, format (ValidateErrorMessage::THROWS_NOT_DECLARED, name.toStr (), i._1),
                                                notes-> copy [copy ErrorMsg::note (i._0, ""s8)])];
                lst ~= [i._1];
            }
        }

        for i in unused {
            errors ~= [copy ErrorMsg::fatal (loc, format (ValidateErrorMessage::THROWS_NOT_USED, name.toStr (), i._1),
                                             notes-> copy [copy ErrorMsg::note (i._0, ""s8)])];
        }

        if (errors.len != 0us) throw copy ErrorMsg::list (errors);
    }

    /**
     * List the throws that are unused, and not found
     * @params:
     *    - thrown: the list of exception thrown in the body of the function
     *    - expected: the list of exception declared in the prototype of the function
     * @returns:
     *    - .0: the list of exception thrown in the body but not declared
     *    - .1: the list of exception declared in the prototype but not found in the body
     */
    fn listUnusedThrows (self, context : &Validator, thrown : [(&Word, &Type)], expected : [(&Word, &Type)])-> ([(&Word, &Type)], [(&Word, &Type)])
        throws ErrorMsg
    {
        let dmut notFound : [(&Word, &Type)] = [];
        for i in thrown {
            let mut found = false;
            for j in expected  {
                if context.isDirectInstance (i._1, j._1) {
                    found = true;
                    break;
                } else if context.isAncestor (j._1, i._1) {
                    found = true;
                    break;
                }
            }

            if !found {
                notFound ~= [i];
            }
        }

        let dmut unused   : [(&Word, &Type)] = [];
        for i in expected {
            let mut found = false;
            for j in thrown {
                if (context.isDirectInstance (i._1, j._1)) {
                    found = true;
                    break;
                } else if (context.isAncestor (i._1, j._1)) {
                    found = true;
                    break;
                }
            }

            if !found {
                unused ~= [i];
            }
        }

        (notFound, unused)
    }
    
    /*!
     * ================================================================================
     * ================================================================================
     * =========================          PROTOTYPE           =========================
     * ================================================================================
     * ================================================================================
     */
    
    /**
     * Validate the prototype of a frame for generation
     * @params: 
     *   - context: the context of the validation
     *   - sym: the symbol being validated
     *   - proto: the prototype to validate
     *   - forMethod: true iif the validation is intended to create a method prototype
     * @returns:
     *    - .0: the return type of the prototype
     *    - .1: the list of parameters
     * @throws: &ErrorMsg, if there is a malformed parameter, or the return type is malformed
     */
    fn validatePrototype (mut self, dmut context : &Validator, sym : &Symbol, proto : &FunctionProtoDecl, forMethod : bool = false, noValue : bool = false)-> (&Type, [&ProtoVarValue])
        throws ErrorMsg
    {
        let mut parameters : [&ProtoVarValue] = [];
        let mut errors : [&ErrorMsg] = [];
        
        let noValue2 = noValue || (sym in self._validating);
        self._validating [sym] = ();
        {
            for i, param in proto.getParameters () {
                if (i != 0us || !forMethod) { // If we validate the prototype for a method, we don't validate the first parameter (which is always self)
                    let (isMutable, isReference, isLazy, type, value) = self.validateParamDecl (alias context, param, noValue-> noValue2);
                    let nbConsume = match param.getType () {
                        lst : &TypeListWrapperExpr => { cast!u32 (lst.getTypes ().len) }
                        _ => 1u32
                    };

                    let paramGen = copy ProtoVarValue (param.getLoc (), type, value, isMutable, isSelf-> false, isReference-> isReference, isLazy-> isLazy, nbConsume-> nbConsume);
                    parameters ~= [paramGen];
                    context:.insertLocal (paramGen.getLoc (), paramGen.getLoc ().str, paramGen);
                } catch {
                    err : &ErrorMsg => { errors ~= [err]; }
                }
            }
        }         
        self._validating:.remove (sym);

        let r : &Type = {
            let t = match proto.getRetType () {
                EmptyExpression () => { copy VoidType (proto.getLoc ()) }
                x : _ => { context:.validateType (x) }
            };

            context.verifyCompleteType (t.getLoc (), t, true);
            t
        } catch {
            err : &ErrorMsg => {
                errors ~= [err];
                throw copy ErrorMsg::list (errors);
            }
        };
        
        if (errors.len != 0us) throw copy ErrorMsg::list (errors);
        (r, parameters)
    }

    /**
     * Verify that the prototype is correct for the main function
     * @params: 
     *   - funcLoc: the location of the function definition
     *   - proto: the prototype of the frame 
     *   - parameters: the validated parameters of the function
     *   - retType: the return type of the function
     * @returns:
     *    - errors: add errors if the prototype is not valid
     */
    fn verifyMainPrototype (self, dmut context : &Validator, funcLoc : &Word, parameters : [&Value], retType : &Type)
        throws ErrorMsg
    {
        let mut errors : [&ErrorMsg] = [];
        if (parameters.len > 1us) {
            errors ~= [copy ErrorMsg::fatal (parameters [1us].getLoc (),
                                             ValidateErrorMessage::MAIN_FUNCTION_ONE_ARG)];
        } else if (parameters.len == 1us) {
            let test = copy SliceType (funcLoc, copy SliceType (funcLoc, copy CharType (funcLoc, size-> 8u16)));
            {
                context:.verifyCompatibleTypeWithValue (parameters [0].getLoc (), test, parameters [0], byReference-> false);
            } catch {
                err : &ErrorMsg => { errors ~= [err]; }
            }
        }

        match retType {
            VoidType () => {}
            _ => {
                let test = copy IntType (funcLoc, size-> 32u16, signed-> true);
                {
                    context.verifyCompatibleType (retType.getLoc (), test.getLoc (), test, retType);
                } catch {
                    err : &ErrorMsg => { errors ~= [err]; }
                }   
            }
        }

        if (errors.len != 0us) throw copy ErrorMsg::list (errors);
    }
    

    /**
     * Validate a parameter of a prototype
     * @params: 
     *    - context: the context of the validation
     *    - param: the parameter to validate
     *    - noValue: true iif we are recursevely validating and thus the value must not be validated (cf. Recursive default parameters)
     * @throws: &ErrorMsg, if there is an error
     * @returns: 
     *    - .0: true iif the parameter is declared mutable
     *    - .1: true iif the parameters is declared as a reference
     *    - .2: the type of the parameter
     *    - .3: the value of the parameter
     */
    fn validateParamDecl (self, dmut context : &Validator, vdecl : &VarDeclExpr, noValue : bool = false)-> (bool, bool, bool, &Type, &Value)
        throws ErrorMsg
    {
        let type = {
            context:.validateTypeForVarDecl (vdecl.getType (), vdecl, canBeRef-> true, canBeLazy-> true)
        } catch {
            err : &ErrorMsg => throw copy ErrorMsg::note (vdecl.getLoc (), ValidateErrorMessage::VALIDATING, notes-> copy [err]);
        };

        let value : &Value = if vdecl.getValue () !of EmptyExpression && !noValue {
            if (vdecl.getLoc () == Keys::UNDER) { // variable with a default value must have a name, otherwise it is impossible to change them
                throw copy ErrorMsg::fatal (vdecl.getLoc (), ValidateErrorMessage::DEFAULT_VAR_NO_NAME, notes-> copy [copy ErrorMsg::note (vdecl.getValue ().getLoc (), ""s8)]);
            }

            context:.validateValue (vdecl.getLoc (), vdecl.getValue (), type-> type)
        } else {
            UNIT_VALUE
        };

        if (type.isMutable () && !type.needExplicitAlias () && !type.isMovable () && !vdecl.isRef ()) {
            throw copy ErrorMsg::fatal (vdecl.getMutOrDmutLocation (), ValidateErrorMessage::MUTABLE_CONST_PARAM);
        }

        context.verifyNonVoidType (vdecl.getType ().getLoc (), type, true);
        return (type.isMutable (), vdecl.isRef (), vdecl.isLazy (), type, value);
    }

    /**
     * Validate a parameter of a template prototype
     * @params: 
     *    - context: the context of the validation
     *    - param: the parameter to validate
     *    - noValue: true iif we are recursevely validating and thus the value must not be validated (cf. Recursive default parameters)
     * @returns: 
     *    - .0: true iif the parameter is declared mutable
     *    - .1: the type of the parameter (can be none, if the validation failed)
     *    - .2: the value of the parameter (can be none if there is none, or the validation failed)
     */
    pub fn validateTemplateParamDecl (self, dmut context : &Validator, vdecl : &VarDeclExpr, noValue : bool = false)-> (bool, bool, bool, &Type, &Value) {
        let type = {
            context:.validateTypeForVarDecl (vdecl.getType (), vdecl, canBeRef-> true, canBeLazy-> true)
        } catch {
            _ => {
                NONE_TYPE
            }
        };

        let value : &Value = if vdecl.getValue () !of EmptyExpression && !noValue {
            {
                context:.validateValue (vdecl.getLoc (), vdecl.getValue (), type-> type)
            } catch {
                _ => {
                    // we put something, because we don't want the value to be set automatically
                    // It must be named, even if we don't know yet what it is it's default value, template specialization will tell
                    copy TemplateDefaultValue (vdecl.getValue ().getLoc ())
                }
            }
        } else {
            UNIT_VALUE
        };

        return (type.isMutable (), vdecl.isRef (), vdecl.isLazy (), type, value);
    }
    
    /**
     * Validate the self parameter of a method prototype
     * @params: 
     *   - param: the self parameter
     *   - clRef: the type of the class used
     * @returns: the protovar value
     */
    fn validateSelfParamDecl (self, vdecl : &VarDeclExpr, clRef : &ClassRefType)-> &ProtoVarValue
        throws ErrorMsg
    {
        let isMutable = vdecl.isMutable ();
        if (!vdecl.getLazyOrRefLocation ().isEof ()) { // ref,lazy self has no meaning
            throw copy ErrorMsg::fatal (vdecl.getLazyOrRefLocation (), format (ValidateErrorMessage::UNDEF_DECORATOR_TYPE, vdecl.getLazyOrRefLocation ().str));
        }

        if (vdecl.isDeeplyMutable ()) { // dmut self neither
            throw copy ErrorMsg::fatal (vdecl.getDeeplyMutableLocation (), format (ValidateErrorMessage::UNDEF_DECORATOR_TYPE, vdecl.getDeeplyMutableLocation ().str));
        }

        let clPtr = clRef.createInstance (isMutable, isMutable); // mut in that case means dmut
        copy ProtoVarValue (vdecl.getLoc (), clPtr, UNIT_VALUE, isMutable, isSelf-> true, isReference-> clRef.isStruct ()) // returns the protovar
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================           UNITTEST           =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a unit test
     * @params: 
     *   - context: the context of the validation
     *   - sym: the symbol to validate
     *   - uid: the uniq id of the unittest in the local module
     */
    pub fn validateTest (self, dmut context : &Validator, dmut sym : &Symbol, uid : usize)
        throws ErrorMsg
    {
        if let dmut unit : &UnitTestSymbol = alias sym {
            context:.pushReferent (alias unit);
            context:.enterForeign (isFnBody-> false);

            let mut hasErrors = false;
            let mut errors : [&ErrorMsg] = [];
            let body = {
                context:.enterBlock ();
                context:.enterFunctionBody ();
                context:.setFunctionReturn (copy VoidType (unit.getLoc ()));

                context:.validateValue (unit.getContent ().getBody ())
            } catch {
                err : &ErrorMsg => {
                    errors ~= [err];
                    UNIT_VALUE
                }
            } exit {
                {
                    context:.quitBlock (warnUnused-> !hasErrors);
                } catch {
                    err : &ErrorMsg => { errors ~= [err]; }
                }
            };

            context:.exitForeign ();
            context:.popReferent ();

            if (errors.len != 0us) throw copy ErrorMsg::list (errors);

            let path = unit.getPath ().push (format ("%", uid));
            let gen = copy UnitTestGenerator (unit.getLoc (), path, body);
            context:.insertGenerator (alias unit, gen);
        } else panic;
    }

    /*!
     * ================================================================================
     * ================================================================================
     * ==========================           COMMON           ==========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * @returns: the location of the unsafe attributes or EOF_WORD if none exist
     * */
    fn getUnsafeLoc (self, attributes : [AttributeWord])-> &Word {
        for it in attributes {
            if (it.attr == Attributes::UNSAFE) {
                return it.loc;
            }
        }

        EOF_WORD
    }

    /**
     * @returns: the location of the field attributes or EOF_WORD if none exist
     * */
    fn getFieldLoc (self, attributes : [AttributeWord])-> &Word {
        for it in attributes {
            if (it.attr == Attributes::FIELD) {
                return it.loc;
            }
        }

        EOF_WORD
    }

    /**
     * verify that attributes are applicable to a function
     * @params:
     *    - attributes: the list of attributes
     * */
    fn verifyUndefAttributes (self, attributes : [AttributeWord])
        throws ErrorMsg
    {
        let mut errors : [&ErrorMsg] = [];
        for it in attributes match it.attr {
            Attributes::UNSAFE => {}
            Attributes::INLINE => {}
            _ => { errors ~= [copy ErrorMsg::fatal (it.loc, format (ValidateErrorMessage::UNDEFINED_ATTRIBUTE, it.attr))]; }
        }

        if (errors.len != 0us) throw copy ErrorMsg::list (errors);
    }

    /**
     * verify that attributes are applicable to a dtor
     * @params:
     *    - attributes: the list of attributes
     * */
    fn verifyUndefAttributesDtor (self, attributes : [AttributeWord])
        throws ErrorMsg
    {
        let mut errors : [&ErrorMsg] = [];
        for it in attributes {
            errors ~= [copy ErrorMsg::fatal (it.loc, format (ValidateErrorMessage::UNDEFINED_ATTRIBUTE, it.attr))];
        }

        if (errors.len != 0us) throw copy ErrorMsg::list (errors);
    }

    /**
     * verify that attributes are applicable to a method
     * @params:
     *    - attributes: the list of attributes
     * */
    fn verifyUndefAttributesMethod (self, attributes : [AttributeWord])
        throws ErrorMsg
    {
        let mut errors : [&ErrorMsg] = [];
        for it in attributes match it.attr {
            Attributes::UNSAFE => {}
            Attributes::FINAL  => {}
            Attributes::INLINE => {}
            Attributes::FIELD  => {}
            _ => { errors ~= [copy ErrorMsg::fatal (it.loc, format (ValidateErrorMessage::UNDEFINED_ATTRIBUTE, it.attr))];  }
        }

        if (errors.len != 0us) throw copy ErrorMsg::list (errors);
    }

    /**
     * Verify that the function is not colliding with other function in the same module
     * */
    fn verifyFunctionCollision (self, sym : &Symbol, name : [c8], prototype : &PrototypeValue)
        throws ErrorMsg
    {
        let dmut mayCollide = sym.getReferent ().getLocalSymbols (name, protection-> Protection::PRIVATE);
        for f in mayCollide[] match f {
            iF : &FunctionSymbol => match iF.getFrameProto () {
                p : &PrototypeValue => {
                    if self.isFuncSimilar (p, prototype) {
                        throw copy ErrorMsg::fatal (p.getLoc (), end-> prototype.getLoc (), format (ValidateErrorMessage::COLLIDING_FUNCTION_DEFINITION, p, prototype, tags-> FormatTags (withParams-> true)));
                    }
                }
            }
        }
    }

    /**
     * @returns: true iif left and right have the same prototype
     * */
    fn isFuncSimilar (self, left : &PrototypeValue, right : &PrototypeValue)-> bool {
        if (left.getSymbol ().getPath ().file () != right.getSymbol ().getPath ().file ()) return false;

        if (left.getParameters ().len != right.getParameters ().len) { return false; }
        for i in 0us .. left.getParameters ().len {
            if (left.getParameters () [i].getType () != right.getParameters () [i].getType ()) {
                return false;
            }

            if (!left.getParameters () [i].getType ().sameMutability (right.getParameters () [i].getType ())) {
                return false;
            }

            if (left.getParameters () [i].isLazy () != right.getParameters () [i].isLazy ()) {
                return false;
            }

            if (left.getParameters () [i].isReference () != right.getParameters () [i].isReference ()) {
                return false;
            }
        }

        true
    }
}
