mod ymirc::semantic::validator::symbol::function;

import ymirc::semantic::validator::visitor;
import ymirc::semantic::validator::template::rewrite;
import ymirc::semantic::validator::errors;
import ymirc::semantic::symbol::_;
import ymirc::syntax::declaration::protection;
import ymirc::syntax::expression::_;
import ymirc::syntax::declaration::_;

import ymirc::syntax::keys;
import ymirc::semantic::generator::_;
import ymirc::errors::_;
import ymirc::utils::format;
import ymirc::lexing::word;

import std::collection::vec;
import std::collection::set;
import std::io, std::fs::path;

/**
 * The function validator is the class responsible for function symbol validation
 */
pub class FunctionValidator {

    /// The list of validating symbol, to avoid infinite value call recursion (foo (a = bar()), bar (a = foo ()))
    let dmut _validating = HashSet!{&Symbol}::new ();
    
    /**
     * Create a new empty validator
     */
    pub self () {}


    /**
     * Validate a function
     * @info: insert the generator in the context for "generation"
     * @params: 
     *   - context: the context of the validation
     *   - sym: the function to validate
     * @throws: 
     *    - &ErrorMsg: if the func is not valid
     */
    pub fn validate (mut self, dmut context : &Validator, dmut sym : &FunctionSymbol)
        throws &ErrorMsg
    {
        context:.pushReferent (alias sym);
        context:.enterForeign (isFnBody-> false);

        {
            self:.validateFunction (alias context, alias sym);
        }  catch {
            err : &ErrorMsg => {
                context:.exitForeign ();
                context:.popReferent ();
                throw ErrorMsg::fatal (sym.getLoc (), format (ValidateErrorMessage::VALIDATING_SYMBOL, sym.getPath ().toStr ()), notes-> [err]);
            }
        }
        
        context:.exitForeign ();
        context:.popReferent ();
    }

    /**
     * Validate a constructor symbol
     * @info: insert the generator in the context for "generation"
     * @params: 
     *    - context: the context of the validation
     *    - sym: the symbol to validate
     *    - clRef: the type of the class containing the ctor
     * @throws: 
     *    - &ErrorMsg: if the ctor is not valid
     */
    pub fn validateConstructor (mut self, dmut context : &Validator, dmut sym : &ConstructorSymbol, clRef : &ClassRefType)
        throws &ErrorMsg
    {
        context:.pushReferent (alias sym);
        context:.enterForeign (isFnBody-> false, clContext-> clRef);
        {
            // Only one kind of constructor
            self:.validateConstructor (alias context, alias sym, clRef, validateBody-> true);
        }  catch {
            err : &ErrorMsg => {
                context:.exitForeign ();
                context:.popReferent ();
                throw ErrorMsg::fatal (sym.getLoc (), format (ValidateErrorMessage::VALIDATING_SYMBOL, sym.getPath ().toStr ()), notes-> [err]);
            }
        }
        
        context:.exitForeign ();
        context:.popReferent ();
    }

    /**
     * Fully validate a method definition  (not just the prototype)
     * @params: 
     *    - context: the context of the validation
     *    - sym: the method to validate
     *    - clRef: the type of self in the method
     * @throws:
     *     - &ErrorMsg: if there was an error in the validation
     */
    pub fn validateMethod (mut self, dmut context : &Validator, dmut sym : &FunctionSymbol, clRef : &ClassRefType)
        throws &ErrorMsg
    {
        context:.pushReferent (alias sym);
        context:.enterForeign (isFnBody-> false, clContext-> clRef);

        {
            // Only one kind of method
            // We don't care if it was defined inside a trait, we don't use the method prototype that is generated
            self:.validateMethod (alias context, alias sym, sym.getContent (), clRef, fromTrait-> EMPTY_SYMBOL, validateBody-> true);
        } catch {
            err : &ErrorMsg => {
                context:.exitForeign ();
                context:.popReferent ();
                throw ErrorMsg::fatal (sym.getLoc (), format (ValidateErrorMessage::VALIDATING_SYMBOL, sym.getPath ().toStr ()), notes-> [err]);
            }
        }
        
        context:.exitForeign ();
        context:.popReferent ();
    }
    
    /*!
     * ================================================================================
     * ================================================================================
     * =========================          PROTOTYPES          =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate the prototype of a function
     * @params: 
     *    - context: the context of the validation
     *    - sym: the symbol to validate
     * @returns: a callable prototype of function
     * @throws: &ErrorMsg, if the function is malformed
     */
    pub fn validateFuncPrototype (mut self, dmut context : &Validator, dmut sym : &FunctionSymbol)-> &PrototypeValue
        throws &ErrorMsg
    {
        match (sym.getFrameProto ()) {
            EmptyGenerator () => {
                let ret = {
                    context:.pushReferent (alias sym);
                    context:.enterForeign (isFnBody-> false);
                    
                    self:.validateFunction (alias context, alias sym, validateBody-> false)
                } exit {                
                    context:.exitForeign ();
                    context:.popReferent ();
                } catch {
                    err : &ErrorMsg => {
                        throw ErrorMsg::fatal (sym.getLoc (), format (ValidateErrorMessage::VALIDATING_SYMBOL, sym.getPath ().toStr ()), notes-> [err]);
                    }                    
                } 

                ret
            }
            v : &PrototypeValue => 
                return v;            
            g : _ => {
                println ("What is inside the function ???", g::typeinfo.name);
                __pragma!panic ();
            }
        }
    }

    /**
     * Validate a prototype of a symbol that is not declared, as it comes from a template rewrite
     * @params: 
     *    - context: the context of the validation
     *    - sym: the symbol declaring the template definition
     *    - func: the rewritten function declaration
     *    - rewriter: the template rewriter
     * @returns: the validate prototype value of the function
     * @throws:
     *    - &ErrorMsg: if the validation fails
     */
    pub fn validateFuncPrototypeFromTemplate (mut self, dmut context : &Validator, dmut sym : &Symbol, func : &FunctionDecl, rewriter : &TemplateRewriter)-> &PrototypeValue
        throws &ErrorMsg
    {
        context:.pushReferent (alias sym);
        context:.enterForeign (isFnBody-> false);

        let mut error = ((&ErrorMsg)?)::__err__;
        let throwers = self.validateThrowers (alias context, func.getThrowerLoc (), func.getThrowers ());
        self.verifyUndefAttributes (func.getAttributes ());

        let (retType, parameters) = {
            context:.enterBlock ();
            {
                {
                    self:.validatePrototype (alias context, sym, func.getFunctionProto ())      
                } catch {
                    err : &ErrorMsg => {
                        error = ErrorMsg::fatal (sym.getLoc (), format (ValidateErrorMessage::VALIDATING_SYMBOL, sym.getPath ().toStr ()), notes-> [err])?;
                        (NONE_TYPE, [])
                    }                    
                }
            } exit {
                {
                    context:.quitBlock (warnUnused-> false);
                } catch {
                    _ => { __pragma!panic (); }
                }
            }
        }

        match error {
            Ok (msg : _) => throw msg;
        }

        PrototypeValue::new (sym.getLoc (), sym, parameters, retType, throwers, fromTemplate-> rewriter?, attributes-> func.getAttributes ())
    } exit {
        context:.exitForeign ();
        context:.popReferent ();
    }
    
    /**
     * Validate the prototype of a constructor
     * @params: 
     *    - context: the context of the validation
     *    - sym: the symbol to validate
     *    - clRef: the type of the class that will be used as self
     * @returns: a callable prototype of function
     * @throws:
     *    - &ErrorMsg, if the constructor is malformed
     */
    pub fn validateCtorPrototype (mut self, dmut context : &Validator, dmut sym : &ConstructorSymbol, clRef : &ClassRefType)-> &CtorPrototypeValue
        throws &ErrorMsg
    {
        match sym.getFrameProto () {
            EmptyGenerator () => { // probably, the prototype is computed when validating the class symbol so before class finalization                
                let ret = {
                    context:.pushReferent (alias sym);
                    context:.enterForeign (isFnBody-> false, clContext-> clRef);
                    
                    self:.validateConstructor (alias context, alias sym, clRef, validateBody-> false)
                } exit {
                    context:.exitForeign ();
                    context:.popReferent ();
                } catch {
                    err : &ErrorMsg => {
                        throw ErrorMsg::fatal (sym.getLoc (), format (ValidateErrorMessage::VALIDATING_SYMBOL, sym.getPath ().toStr ()), notes-> [err]);
                    }                    
                };

                ret
            }
            v : &CtorPrototypeValue => {
                v
            }
            g : _ => {
                println ("What is inside the function ???", g::typeinfo.name);
                __pragma!panic ();
            }
        }
    }

    /**
     * Validate the prototype of a constructor that was declared as a template
     * @params:
     *    - context: the context of the validation
     *    - sym: the template symbol (used for context references only)
     *    - func: the constructor declaration defining the prototype
     *    - clRef: the class type that declared the method
     *    - rewriter: the rewriter defined by the template specialization solving
     * @returns:  A constructor prototype
     * @throws:
     *    - &ErrorMsg: if the validation of the prototype fails
     * */
    pub fn validateCtorPrototypeFromTemplate (mut self, dmut context : &Validator, dmut sym : &Symbol, func : &ConstructorDecl, clRef : &ClassRefType, rewriter : &TemplateRewriter)-> &CtorPrototypeValue
        throws &ErrorMsg
    {
        context:.pushReferent (alias sym);
        context:.enterForeign (isFnBody-> false, clContext-> clRef);
        let ret = {
            let dmut errors = Vec!{&ErrorMsg}::new ();
            let throwers = self.validateThrowers (alias context, func.getThrowerLoc (), func.getThrowers ());
            self.verifyUndefAttributes (func.getAttributes ());

            let parameters = {
                context:.enterBlock ();
                let clPtr = clRef.createInstance (true, true);
                let selfParam = ProtoVarValue::new (func.getLoc (), clPtr, UNIT_VALUE, true, isSelf-> true, isReference-> false);
                context:.insertLocal (selfParam.getLoc ().str (), selfParam);

                let (_, parameters) = self:.validatePrototype (alias context, sym, func.getFunctionProtoDecl (), forMethod-> false);

                parameters
            } catch {
                err : &ErrorMsg => {
                    errors:.push (err);
                    []
                }
            } exit {
                {
                    context:.quitBlock (warnUnused-> false);
                } catch {
                    err : &ErrorMsg => { errors:.push (err); }
                }
            }

            if (errors.len () != 0us) throw ErrorMsg::list (errors []);

            CtorPrototypeValue::new (sym.getLoc (), sym, rename-> func.getRename ().str (), parameters, throwers,
                                     clRef-> clRef, attributes-> func.getAttributes (), fromTemplate-> rewriter?)
        } exit {
            context:.exitForeign ();
            context:.popReferent ();
        } catch {
            err : &ErrorMsg => {
                throw ErrorMsg::fatal (sym.getLoc (), format (ValidateErrorMessage::VALIDATING_SYMBOL, sym.getPath ().toStr ()), notes-> [err]);
            }
        };

        ret
    }

    /**
     * Validate a method prototype defined inside a trait symbol
     * @params: 
     *   - context: the context of the validation
     *   - sym: the function to validate
     *   - clRef: the type of the class (used for the self parameter)
     *   - traitRef: the trait that defines the method
     * @returns: the prototype of the method
     * @throws:
     *   - &ErrorMsg: if the validation fails
     */
    pub fn validateMethodPrototype (mut self, dmut context : &Validator, dmut sym : &FunctionSymbol, clRef : &ClassRefType, traitRef : &TraitRefType)-> &MethodPrototypeValue
        throws &ErrorMsg
    {
        match (sym.getFrameProto ()) {
            EmptyGenerator () => {                
                let ret = {
                    context:.pushReferent (alias sym);
                    context:.enterForeign (isFnBody-> false, clContext-> clRef);
                    
                    self:.validateMethod (alias context, alias sym, sym.getContent (), clRef, fromTrait-> traitRef.getSymbol (), validateBody-> false)
                } exit {
                    context:.exitForeign ();
                    context:.popReferent ();
                } catch {
                    err : &ErrorMsg => {
                        throw ErrorMsg::fatal (sym.getLoc (), format (ValidateErrorMessage::VALIDATING_SYMBOL, sym.getPath ().toStr ()), notes-> [err]);
                    }                    
                };
                                
                ret
            }
            v : &MethodPrototypeValue => {
                v
            }
            g : _ => {
                println ("What is inside the function ???", g::typeinfo.name);
                __pragma!panic ();
            }
        }
    }

    /**
     * Validate a method prototype defined inside a trait symbol
     * @params: 
     *   - context: the context of the validation
     *   - sym: the function to validate
     *   - clRef: the type of the class (used for the self parameter)
     *   - traitRef: the trait that defines the method
     * @returns: the prototype of the method
     * @throws:
     *   - &ErrorMsg: if the validation fails
     */
    pub fn validateMethodPrototype (mut self, dmut context : &Validator, dmut sym : &FunctionSymbol, clRef : &ClassRefType)-> &MethodPrototypeValue
        throws &ErrorMsg
    {
        match (sym.getFrameProto ()) {
            EmptyGenerator () => {                
                let ret = {
                    context:.pushReferent (alias sym);
                    context:.enterForeign (isFnBody-> false, clContext-> clRef);
                    
                    self:.validateMethod (alias context, alias sym, sym.getContent (), clRef, fromTrait-> EMPTY_SYMBOL, validateBody-> false)
                } exit {
                    context:.exitForeign ();
                    context:.popReferent ();
                } catch {
                    err : &ErrorMsg => {
                        throw ErrorMsg::fatal (sym.getLoc (), format (ValidateErrorMessage::VALIDATING_SYMBOL, sym.getPath ().toStr ()), notes-> [err]);
                    }
                };

                ret
            }
            v : &MethodPrototypeValue => {
                v
            }
            g : _ => {
                println ("What is inside the function ???", g::typeinfo.name);
                __pragma!panic ();
            }
        }
    }


    /**
     * Validate the prototype of a method that was declared as a template in a class
     * @params:
     *    - context: the context of the validation
     *    - sym: the template symbol (used for context references only)
     *    - func: the function declaration defining the prototype
     *    - clRef: the class type that declared the method
     *    - rewriter: the rewriter defined by the template specialization solving
     * @returns:  A method prototype
     * @throws:
     *    - &ErrorMsg: if the validation of the prototype fails
     * */
    pub fn validateMethodPrototypeFromTemplate (mut self, dmut context : &Validator, dmut sym : &Symbol, func : &FunctionDecl, clRef : &ClassRefType, rewriter : &TemplateRewriter)-> &MethodPrototypeValue
        throws &ErrorMsg
    {
        context:.pushReferent (alias sym);
        context:.enterForeign (isFnBody-> false, clContext-> clRef);

        let ret = {
            let dmut errors = Vec!{&ErrorMsg}::new ();

            let throwers = self.validateThrowers (alias context, func.getThrowerLoc (), func.getThrowers ());
            self.verifyUndefAttributes (func.getAttributes ());

            let (retType, selfParam, parameters) = {
                context:.enterBlock ();
                let selfParam = self.validateSelfParamDecl (func.getFunctionProto ().getParameters()[0], clRef);
                context:.insertLocal (selfParam.getLoc ().str (), selfParam);

                let (retType, parameters) = self:.validatePrototype (alias context, sym, func.getFunctionProto (), forMethod-> true);
                (retType, selfParam, parameters)
            } catch {
                err : &ErrorMsg => {
                    errors:.push (err);
                    (cast!{&Type}(NONE_TYPE), cast!{&Value} (UNIT_VALUE), [])
                }
            } exit {
                {
                    context:.quitBlock (warnUnused-> false);
                } catch {
                    err : &ErrorMsg => { errors:.push (err); }
                }
            }

            if (errors.len () != 0us) throw ErrorMsg::list (errors []);
            MethodPrototypeValue::new (sym.getLoc (), sym, parameters, retType, throwers, clRef, trRef-> EMPTY_SYMBOL, isMutable-> selfParam.getType ().isMutable (),
                                       isEmpty-> func.getBody ().isOf!{&EmptyExpression} (), isOver-> false, attributes-> func.getAttributes (), fromTemplate-> rewriter?)
        } exit {
            context:.exitForeign ();
            context:.popReferent ();
        } catch {
            err : &ErrorMsg => {
                throw ErrorMsg::fatal (sym.getLoc (), format (ValidateErrorMessage::VALIDATING_SYMBOL, sym.getPath ().toStr ()), notes-> [err]);
            }
        };


        ret
    }

    /**
     * Validate a dtor prototype defined a class
     * @params:
     *    - context: the context of the validation
     *    - sym: the dtor to validate
     *    - clRef: the class defining the dtor
     *    - ancDtor: the prototype of the ancestor dtor (can be empty, aka UnitValue)
     * @throws:
     *     - &ErrorMsg: if there is an error in the validation
     * @returns: the prototype of the destructor
     */
    pub fn validateDtorPrototype (mut self, dmut context : &Validator, dmut sym : &FunctionSymbol, clRef : &ClassRefType, ancDtor : &Value)-> &DtorPrototypeValue
        throws &ErrorMsg
    {
        match (sym.getFrameProto ()) {
            EmptyGenerator () => {
                let ret = {
                    context:.pushReferent (alias sym);
                    context:.enterForeign (isFnBody-> false, clContext-> clRef);

                    self:.validateDestructor (alias context, alias sym, clRef, validateBody-> false, ancDtor-> ancDtor)
                } exit {
                    context:.exitForeign ();
                    context:.popReferent ();
                } catch {
                    err : &ErrorMsg => {
                        throw ErrorMsg::fatal (sym.getLoc (), format (ValidateErrorMessage::VALIDATING_SYMBOL, sym.getPath ().toStr ()), notes-> [err]);
                    }
                };

                ret
            }
            v : &DtorPrototypeValue => {
                v
            }
            g : _ => {
                println ("Unknown symbol inserted in destructor ??", g::typeinfo.name);
                __pragma!panic ();
            }
        }
    }

    
    /*!
     * ================================================================================
     * ================================================================================
     * =========================           FUNCTION           =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a normal function
     * @todo: this function is way too long, and way too close to validateMethod and validateConstructor. A refactorization would be great
     * @params: 
     *    - context: the context of the validation
     *    - sym: the symbol to validate
     * @returns: the prototype of the function
     */        
    fn validateFunction (mut self, dmut context : &Validator, dmut sym : &FunctionSymbol, validateBody : bool = true)-> &PrototypeValue
        throws &ErrorMsg
    {
        if (!validateBody) match sym.getFrameProto () {
            p : &PrototypeValue => return p;
        }
                
        let func = sym.getContent ();

        let dmut errors = Vec!{&ErrorMsg}::new ();
        let throwers = self.validateThrowers (alias context, func.getThrowerLoc (), func.getThrowers ());
        self.verifyUndefAttributes (func.getAttributes ());

        let (retType, parameters, body) = {
            context:.enterBlock ();

            let (retType, parameters) = match sym.getFrameProto () {
                p : &PrototypeValue => {
                    for pi in p.getParameters () {
                        context:.insertLocal (pi.getLoc ().str (), pi);
                    }
                    (p.getRetType (), p.getParameters ())
                }
                _ => {
                    self:.validatePrototype (alias context, sym, func.getFunctionProto ())
                }
            }

            
            if (func.getLoc ().str () == Keys::MAIN && validateBody) {
                self.verifyMainPrototype (alias context, func.getLoc (), parameters, retType);
            } 

            let body = if (validateBody) {
                context:.enterFunctionBody ();
                let mut unsafeLoc = self.getUnsafeLoc (func.getAttributes ());
                if (unsafeLoc.isEof () && sym.isUnsafe ()) { unsafeLoc = func.getLoc (); } // extern C function are unsafe without attributes

                self.validateFunctionBody (alias context, func.getLoc (), sym.getPath (), func.getBody (), retType, throwers, unsafeLoc)
            } else {
                cast!{&Value} (UNIT_VALUE)
            }
            
            (retType, parameters, body)
        } catch {
            err : &ErrorMsg => {
                errors:.push (err);
                (cast!{&Type}(NONE_TYPE), [], cast!{&Value} (UNIT_VALUE))
            }
        } exit {
            {
                context:.quitBlock (warnUnused-> (errors.len () == 0us && validateBody));
            } catch {
                err : &ErrorMsg => { errors:.push (err); }
            }
        }

        if (errors.len () != 0us) throw ErrorMsg::list (errors []);
        
        if (validateBody && !func.getBody ().isOf!{&EmptyExpression} ()) {
            let frame = FrameGenerator::new (func.getLoc (), sym.getPath (), parameters, retType, body,
                                             externLang-> sym.getExternalLanguage (), isWeak-> sym.isWeak (), templateMapper-> sym.getTemplateMapper ());

            context:.insertGenerator (alias sym, frame);
        }

        match sym.getFrameProto () {
            p : &PrototypeValue => { p }
            _ => {
                let gen = match sym.getTemplateMapper () {
                    Ok (map : _) => {
                        PrototypeValue::new (sym.getLoc (), sym, parameters, retType, throwers, fromTemplate-> TemplateRewriter::new (map)?, attributes-> func.getAttributes ())
                    }
                    _ => {
                        PrototypeValue::new (sym.getLoc (), sym, parameters, retType, throwers, attributes-> func.getAttributes ())
                    }
                };

                if (func.getLoc ().str () == Keys::MAIN && gen.isInline ()) {
                    throw ErrorMsg::fatal (gen.getInlineLoc (), ValidateErrorMessage::MAIN_INLINE);
                }

                if (validateBody) { // If not validate body the prototype might be uncomplete
                    sym:.setFrameProto (gen, body);
                }
                
                gen
            }
        }
    }

    /**
     * Validate the body of a function
     * @params: 
     *     - context: the context of the validation
     *     - loc: the location of the function
     *     - name: the name of the function
     *     - body: the body of the function
     *     - throwers: the list of throwers
     * @returns: 
     *    - errors: the list of errors 
     *    - .0: the validated value of the body
     *    - .1: true iif the value is not a returner
     */
    fn validateFunctionBody (self, dmut context : &Validator, loc : &Word, name : &SymbolPath, body : &Expression, retType : &Type, throwers : [(&Word, &Type)], unsafeLoc : &Word)-> &Value
        throws &ErrorMsg
    {
        match body {
            EmptyExpression () => {
                context:.clearLocalScope ();
                cast!{&Value} (UnitValue::new (loc-> loc))
            }
            _ => {
                if (!unsafeLoc.isEof ()) context:.enterUnsafeContext (unsafeLoc);

                context:.setFunctionReturn (retType);
                let mut bodyValue = context:.validateValue (body);
                let need = if (!bodyValue.isReturner ()) {
                    if (retType.getLoc ().isEof ()) {
                        bodyValue = context:.verifyCompatibleTypeWithValue (bodyValue.getLoc (), retType, bodyValue, byReference-> false);
                        context:.verifyMemoryOwner (bodyValue.getLoc (), retType, bodyValue, byReference-> false);
                    } else {
                        bodyValue = context:.verifyCompatibleTypeWithValue (retType.getLoc (), retType, bodyValue, byReference-> false);
                        context:.verifyMemoryOwner (retType.getLoc (), retType, bodyValue, byReference-> false);
                    }
                    
                    match retType {
                        VoidType () => { false }
                        _ => { true }
                    }
                } else { false };
                
                self.verifyThrowing (alias context, loc, name, bodyValue.getThrowers (), throwers);

                if (!unsafeLoc.isEof ()) context:.exitUnsafeContext ();

                if (need) {
                    cast!{&Value} (ReturnValue::new (bodyValue.getLoc (), bodyValue))
                } else {
                    bodyValue
                }
            }
        }
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================           METHODS            =========================
     * ================================================================================
     * ================================================================================
     */


    /**
     * Validate a method
     * @todo: this function is way too long, and way too close to validateFunction and validateConstructor. A refactorization would be great
     * @params:
     *    - context: the context of the validation
     *    - sym: the symbol to validate
     *    - clRef: the type of the class defining the method
     *    - fromTrait: the symbol of the trait if this method is defined inside a trait, (EmptySymbol otherwise)
     *    - validateBody: true iif the body must be validated
     * @returns: the prototype of the method
     * @throws:
     *    - &ErrorMsg: if the validation failed
     */
    fn validateMethod (mut self, dmut context : &Validator, dmut sym : &FunctionSymbol, func : &FunctionDecl, clRef : &ClassRefType, fromTrait : &Symbol, validateBody : bool = false)-> &MethodPrototypeValue
        throws &ErrorMsg
    {
        let dmut errors = Vec!{&ErrorMsg}::new ();
        let throwers = self.validateThrowers (alias context, func.getThrowerLoc (), func.getThrowers ());
        self.verifyUndefAttributesMethod (func.getAttributes ());

        let (retType, selfParam, parameters, body) = {
            context:.enterBlock ();
            let selfParam = self.validateSelfParamDecl (func.getFunctionProto ().getParameters()[0], clRef);
            context:.insertLocal (selfParam.getLoc ().str (), selfParam);

            let (retType, parameters) = match sym.getFrameProto () {
                p : &PrototypeValue => {
                    for pi in p.getParameters () {
                        context:.insertLocal (pi.getLoc ().str (), pi);
                    }
                    (p.getRetType (), p.getParameters ())
                }
                _ => {
                    self:.validatePrototype (alias context, sym, func.getFunctionProto (), forMethod-> true)
                }
            }


            let fieldLoc = self.getFieldLoc (func.getAttributes ());
            if (!fieldLoc.isEof () && parameters.len != 0us) {
                throw ErrorMsg::fatal (func.getLoc (), ValidateErrorMessage::FIELD_METHOD_PARAMS, notes-> [ErrorMsg::note (fieldLoc, ""s8)]);
            }

            let body = if (validateBody) {
                context:.enterFunctionBody ();
                let mut unsafeLoc = self.getUnsafeLoc (func.getAttributes ());
                if (unsafeLoc.isEof () && sym.isUnsafe ()) { unsafeLoc = func.getLoc (); } // extern C function are unsafe without attributes

                self.validateFunctionBody (alias context, func.getLoc (), sym.getPath (), func.getBody (), retType, throwers, unsafeLoc)
            } else {
                cast!{&Value} (UNIT_VALUE)
            }

            (retType, selfParam, parameters, body)
        } catch {
            err : &ErrorMsg => {
                errors:.push (err);
                (cast!{&Type}(NONE_TYPE), cast!{&Value} (UNIT_VALUE), [], cast!{&Value} (UNIT_VALUE))
            }
        } exit {
            {
                context:.quitBlock (warnUnused-> (errors.len () == 0us && validateBody));
            } catch {
                err : &ErrorMsg => { errors:.push (err); }
            }
        }

        if (errors.len () != 0us) throw ErrorMsg::list (errors []);

        if (validateBody && !func.getBody ().isOf!{&EmptyExpression} ()) {
            let frame = FrameGenerator::new (func.getLoc (), sym.getPath (), [selfParam] ~ parameters, retType, body,
                                             externLang-> sym.getExternalLanguage (), isWeak-> sym.isWeak (), templateMapper-> sym.getTemplateMapper ());

            context:.insertGenerator (alias sym, frame);
        }

        match sym.getFrameProto () {
            p : &MethodPrototypeValue => { p }
            _ => {
                let gen = match sym.getTemplateMapper () {
                    Ok (map : _) => {
                        MethodPrototypeValue::new (sym.getLoc (), sym, parameters, retType, throwers, clRef, trRef-> fromTrait, isMutable-> selfParam.getType ().isMutable (),
                                                   isEmpty-> func.getBody ().isOf!{&EmptyExpression} (), isOver-> sym.isOver (), attributes-> func.getAttributes (), fromTemplate-> TemplateRewriter::new (map)?)
                    }
                    _ => {
                        MethodPrototypeValue::new (sym.getLoc (), sym, parameters, retType, throwers, clRef, trRef-> fromTrait, isMutable-> selfParam.getType ().isMutable (),
                                                   isEmpty-> func.getBody ().isOf!{&EmptyExpression} (), isOver-> sym.isOver (), attributes-> func.getAttributes ())
                    }
                };

                if (gen.isInline () && (!sym.isFinal () || sym.isOver ())) {
                    throw ErrorMsg::fatal (gen.getInlineLoc (), format (ValidateErrorMessage::INLINE_VIRTUAL_METHOD, gen));
                }

                if (validateBody) { // If not validate body the prototype might be uncomplete
                    sym:.setFrameProto (gen, EmptyGenerator::new ());
                }

                gen
            }
        }
    }
    
    /*!
     * ================================================================================
     * ================================================================================
     * =========================            DTORS             =========================
     * ================================================================================
     * ================================================================================
     */

    fn validateDestructor (mut self, dmut context : &Validator, dmut sym : &FunctionSymbol, clRef : &ClassRefType, ancDtor : &Value, validateBody : bool = false)-> &DtorPrototypeValue
        throws &ErrorMsg
    {
        let func = sym.getContent ();
        let dmut errors = Vec!{&ErrorMsg}::new ();
        let throwers = self.validateThrowers (alias context, func.getThrowerLoc (), func.getThrowers ());
        self.verifyUndefAttributesDtor (func.getAttributes ());

        let (retType, selfParam, parameters, body) = {            
            context:.enterBlock ();
            let selfParam = self.validateSelfParamDecl (func.getFunctionProto ().getParameters()[0], clRef);
            if (!selfParam.isMutable ()) {}
            
            context:.insertLocal (selfParam.getLoc ().str (), selfParam);
            
            let (retType, parameters) = match sym.getFrameProto () {
                p : &PrototypeValue => {
                    for pi in p.getParameters () {
                        context:.insertLocal (pi.getLoc ().str (), pi);
                    }
                    (p.getRetType (), p.getParameters ())
                }
                _ => {
                    self:.validatePrototype (alias context, sym, func.getFunctionProto (), forMethod-> true)
                }
            };
            
            let body_ = if (validateBody) {
                context:.enterFunctionBody ();

                self.validateFunctionBody (alias context, func.getLoc (), sym.getPath (), func.getBody (), retType, throwers, EOF_WORD) // dtor can't be unsafe
            } else {
                cast!{&Value} (UNIT_VALUE)
            }

            let body = match ancDtor {
                UnitValue () => { body_ }
                _ => {
                    __pragma!panic ();
                }
            }
            
            (retType, selfParam, parameters, body)
        } catch {           
            err : &ErrorMsg => {
                errors:.push (err);
                (cast!{&Type}(NONE_TYPE), cast!{&Value} (UNIT_VALUE), [], cast!{&Value} (UNIT_VALUE))
            }
        } exit {
            {
                context:.quitBlock (warnUnused-> (errors.len () == 0us && validateBody));
            } catch {
                err : &ErrorMsg => { errors:.push (err); }
            }
        }

        if (errors.len () != 0us) throw ErrorMsg::list (errors []);
        if (validateBody && !func.getBody ().isOf!{&EmptyExpression} ()) {
            let frame = FrameGenerator::new (func.getLoc (), sym.getPath (), [selfParam] ~ parameters, retType, body,
                                             externLang-> sym.getExternalLanguage (), isWeak-> sym.isWeak (), templateMapper-> sym.getTemplateMapper ());

            context:.insertGenerator (alias sym, frame);
        }

        match sym.getFrameProto () {
            p : &DtorPrototypeValue => { p }
            _ => {
                let gen = DtorPrototypeValue::new (sym.getLoc (), sym, clRef);
                if (validateBody) { // If not validate body the prototype might be uncomplete
                    sym:.setFrameProto (gen, EmptyGenerator::new ());
                }
                
                gen
            }
        }
    }
    
    
    /*!
     * ================================================================================
     * ================================================================================
     * =========================            CTORS             =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a constructor
     * @todo: this function is way too long, and way too close to validateFunction and validateMethod. A refactorization would be great
     * @params: 
     *    - context: the context of the validation
     *    - sym: the symbol to validate
     *    - clRef: the class type for self
     *    - validateBody: validate the body of the constructor (and field/ancestor constructions)
     * @returns: the prototype of the ctor
     * @throws:
     *    - &ErrorMsg: if the validation failed
     */
    fn validateConstructor (mut self, dmut context : &Validator, dmut sym : &ConstructorSymbol, clRef : &ClassRefType, validateBody : bool = false)-> &CtorPrototypeValue
        throws &ErrorMsg
    {
        let func = sym.getContent ();
        let dmut errors = Vec!{&ErrorMsg}::new ();
        let throwers = self.validateThrowers (alias context, func.getThrowerLoc (), func.getThrowers ());
        self.verifyUndefAttributes (func.getAttributes ());

        let (selfParam, parameters, body) = {
            context:.enterBlock ();
            // We need a class ptr for the self parameter
            let clPtr = clRef.createInstance (true, true);

            let selfParam = ProtoVarValue::new (func.getLoc (), clPtr, UNIT_VALUE, true, isSelf-> true, isReference-> false);   // Self parameters (first hidden param)
            let (_, parameters) = match sym.getFrameProto () {
                p : &PrototypeValue => { // already validated the prototype in previous call
                    for pi in p.getParameters () {
                        context:.insertLocal (pi.getLoc ().str (), pi);
                    }
                    (p.getRetType (), p.getParameters ())
                }
                _ => { // No previous call, need to validate the prototype
                    self:.validatePrototype (alias context, sym, func.getFunctionProtoDecl (), forMethod-> false) // unlike methods self is not written in the prototype, so we need to validate all parameters
                }
            };


            let body = if (validateBody) { // We validate the body
                self.validateCtorBody (alias context, sym, func, clPtr.getInner (), selfParam, throwers)
            } else { // we validate only the prototype
                cast!{&Value} (UNIT_VALUE)
            }


            (selfParam, parameters, body) // don't add the self parameter in the prototype, we don't have it when calling the prototype
        } catch {
            err : &ErrorMsg => {
                errors:.push (err);
                (cast!{&Value} (UNIT_VALUE), [], cast!{&Value} (UNIT_VALUE))
            }
        } exit {
            {
                context:.quitBlock (warnUnused-> (errors.len () == 0us && validateBody));
            } catch {
                err : &ErrorMsg => { errors:.push (err); }
            }
        }

        if (errors.len () != 0us) throw ErrorMsg::list (errors []);
        
        if (validateBody && !func.getBody ().isOf!{&EmptyExpression} ()) {
            let frame = FrameGenerator::new (func.getLoc (), sym.getPath (), [selfParam.asOf!{&ProtoVarValue} ()] ~ parameters, VoidType::new (sym.getLoc ()), body,
                                             isWeak-> sym.isWeak (), templateMapper-> sym.getTemplateMapper ());
            context:.insertGenerator (alias sym, frame);
        }

        match sym.getFrameProto () {
            p : &CtorPrototypeValue => { p }
            _ => {
                let gen = match sym.getTemplateMapper () {
                    Ok (map : _) => {
                        CtorPrototypeValue::new (sym.getLoc (), sym, parameters, throwers, clRef, rename-> func.getRename ().str (),
                                                 attributes-> func.getAttributes (), fromTemplate-> TemplateRewriter::new (map)?)
                    }
                    _ => {
                        CtorPrototypeValue::new (sym.getLoc (), sym, parameters, throwers, clRef, rename-> func.getRename ().str (),
                                                 attributes-> func.getAttributes ())
                    }
                }

                if (validateBody) { // If not validate body the prototype might be uncomplete
                    sym:.setFrameProto (gen);
                }
                
                gen
            }
        }
        
    }

    /**
     * Validation of the body of the constructor
     * This function is different from validateFunctionBody, because it also validates the pre constructor
     * @params: 
     *    - context: the context of the validation
     *    - sym: the symbol being validated
     *    - ctor: the ctor whose body is being validated
     *    - clRef: the type of the class containing the ctor
     *    - selfParam: the protovarvalue of the hidden self parameter
     * @returns: the body of the ctor
     * @throws:
     *    - &ErrorMsg: if there was an error in the validation     
     */
    fn validateCtorBody (self, dmut context : &Validator, sym : &ConstructorSymbol, ctor : &ConstructorDecl, clRef : &ClassRefType, selfParam : &Value, throwers : [(&Word, &Type)])-> &Value
        throws &ErrorMsg
    {
        //
        //
        // insert self in the scope, alongside with parameters (its an hidden param)
        context:.insertLocal (selfParam.getLoc ().str (), selfParam);

        // Reference to the self hidden param
        let selfValue = VarRefValue::new (selfParam.getLoc (), selfParam.getLoc (), selfParam.getType (), selfParam.getUniqId (), isSelf-> true);
        
        // Validate the pre construction of the constructor (construction of fields, and ancestor)
        let preConstruct = self.validatePreConstructor (alias context, sym, ctor, clRef, selfValue);

        // From this point, return is allowed
        context:.enterFunctionBody ();

        let mut unsafeLoc = self.getUnsafeLoc (ctor.getAttributes ());
        if (unsafeLoc.isEof () && sym.isUnsafe ()) { unsafeLoc = ctor.getLoc (); } // extern C function are unsafe without attributes

        // Validate the body of the constructor (return void type)
        let body = self.validateFunctionBody (alias context, ctor.getLoc (), sym.getPath (), ctor.getBody (), VoidType::new (sym.getLoc ()), throwers, unsafeLoc);

        // the body contains the pre construction, and the proper body
        let finalBody = match preConstruct {
            UnitValue () => { [body] }
            _ => { [preConstruct, body] }
        };

        BlockValue::new (ctor.getLoc (), VoidType::new (sym.getLoc ()), finalBody)
    }       
        
    /**
     * Validate the pre construction of a constructor
     * @params: 
     *    - context: the context of the validation
     *    - sym: the symbol being validated
     *    - func: the declaration to validate
     *    - clRef: the type of self
     *    - selfParam: the self parameter
     * @returns: the value containing the constructions statements
     * @throws: 
     *    - &ErrorMsg: if there was an error in the validation
     */
    fn validatePreConstructor (self, dmut context : &Validator, sym : &ConstructorSymbol, func : &ConstructorDecl, clRef : &ClassRefType, selfParam : &Value)-> &Value
        throws &ErrorMsg
    {
        if (func.getExplicitCstrsCall () == Keys::SELF) { // There is a redirection of construction
            return self.validateRedirectCtor (alias context, sym, func, clRef, selfParam);
        }

        let dmut block = Vec!{&Value}::new (); // list of instructions        
        let ancCall = self.validateAncestorCtorCall (alias context, func, clRef, selfParam);
        match ancCall {
            UnitValue () => {} // Don't add an empty value
            _ =>  {
                block:.push (ancCall); // There is an ancestor, and its ctor is called
            }
        }        

        let fieldCtor = self.validateFieldCtors (alias context, func, clRef, selfParam);
        match fieldCtor {
            UnitValue () => {} // Don't add an empty value
            _ => {
                block:.push (fieldCtor); // there are field constructions
            }
        }

        if (block.len () != 0us) {
            // We create the block of instruction, containing super call, and field ctors
            BlockValue::new (func.getLoc (), VoidType::new (func.getLoc ()), block[])
        } else {
            UnitValue::new (loc-> func.getLoc ())
        }
    }

    /**
     * Validate the call of a redirect constructor
     * @params: 
     *    - context: the context of the validation
     *    - sym: the symbol being validated
     *    - func: the declaration of the constructor
     *    - clRef: the type of the class that is being validated
     * @returns: the instruction calling the redirect constructor
     * @throws: 
     *    - &ErrorMsg: if there is an error in the validation
     */
    fn validateRedirectCtor (self, dmut context : &Validator, sym : &ConstructorSymbol, func : &ConstructorDecl, clRef : &ClassRefType, selfParam : &Value)-> &Value
        throws &ErrorMsg
    {
        let dmut errors = Vec!{&ErrorMsg}::new ();
        let dmut rights = Vec!{&Value}::new ();

        let selfLoc = func.getExplicitCstrsCall ();
        for v in func.getSuperParams () { // Validate the parameters that are passed to the redirect constructor
            rights:.push (context:.validateValue (v));
        }
        
        let ret = {
            // Ignore the current constructor, it cannot be called by redirection
            let ctors = self.createCtorDelegate (alias context, selfLoc, clRef, selfParam, renameLoc-> func.getExplicitSuperName (), ignore-> sym, templateParams-> func.getSuperTemplateParams ());
            context:.getCallOpValidator ().validate (alias context, selfLoc, ctors, rights[])
        } catch { 
            err : &ErrorMsg => { // None succeeded (TODO print private candidates)
                errors:.push (ErrorMsg::fatal (selfLoc, format (ValidateErrorMessage::UNDEFINED_SUPER_CALL_CTOR, rights[]), notes-> [err]));
                cast!{&Value} (UnitValue::new (loc-> selfLoc))
            }
        }

        for it in func.getFieldConstructors () {
            errors:.push (ErrorMsg::fatal (it._0, format (ValidateErrorMessage::ALREADY_INIT_BY_CTOR_REDIRECT, it._0.str ()), notes-> [ErrorMsg::note (selfLoc, ""s8)]));
        }

        if (errors.len () != 0us) throw ErrorMsg::list (errors[]);

        ret
    }
    
    /**
     * Validate the call of the ancestor constructor (if there is an ancestor)
     * @params: 
     *    - context: the context of the validation
     *    - func: the declaration of the constructor
     *    - clRef: the type of the class that is being validated
     *    - selfParam: the self parameters
     * @returns: the instruction calling the ancestor constructor (or Unit, if there is not call)
     * @throws: 
     *    - &ErrorMsg: if there is an error in the validation
     */
    fn validateAncestorCtorCall (self, dmut context : &Validator, func : &ConstructorDecl, clRef : &ClassRefType, selfParam : &Value)-> &Value
        throws &ErrorMsg
    {
        match clRef.getAncestor () {
            ancestor : &ClassRefType => {
                // If the super call is implicit, we need a valid location
                let superLoc = if (func.getExplicitCstrsCall ().isEof ()) { func.getLoc () } else { func.getExplicitCstrsCall () };
                
                let dmut rights = Vec!{&Value}::new ();
                for v in func.getSuperParams () { // Validate the parameters that are passed to the parent constructor
                    rights:.push (context:.validateValue (v));
                }
                
                {
                    let ctors = self.createCtorDelegate (alias context, superLoc, ancestor, selfParam, renameLoc-> func.getExplicitSuperName (), templateParams-> func.getSuperTemplateParams ());
                    return context:.getCallOpValidator ().validate (alias context, superLoc, ctors, rights[]); // Call the ctors with the parameters and return the one that succeeded
                } catch { 
                    err : &ErrorMsg => { // None succeeded (TODO print private candidates)
                        throw ErrorMsg::fatal (superLoc, format (ValidateErrorMessage::UNDEFINED_SUPER_CALL_CTOR, rights[]), notes-> [err]);
                    }
                }
            }
            _ => {
                // Class does not have any ancestor, so it can't be called
                if (func.getExplicitCstrsCall () == Keys::SUPER) {
                    throw ErrorMsg::fatal (func.getExplicitCstrsCall (), format (ValidateErrorMessage::NO_SUPER_CLASS, clRef));
                }
                
                return UNIT_VALUE;
            }            
        }        
    }

    /**
     * Create a mult sym containing all the constructor of the class with the given instance
     * @params: 
     *    - loc: the location of the call
     *    - clRef: the class whose constructors are used
     *    - selfParam: the instance for self
     *    - withPrivate: include PRV_PARENT constructors ?
     *    - prettyStr: the name of the call
     *    - ignore: the ctor to ignore (for self redirection only)
     * @returns: a MultSymValue with all the available ctors (can be of len == 0us)
     */
    fn createCtorDelegate (self, dmut context : &Validator, loc : &Word, clRef : &ClassRefType, selfParam : &Value, renameLoc : &Word, templateParams : &Expression, ignore : &Symbol = EMPTY_SYMBOL)-> &Value
        throws &ErrorMsg
    {
        let rename = if (renameLoc.isEof ()) { ""s8 } else { renameLoc.str () };
        let ctors = context:.getSubTypeValidator ().validateClassCtors (alias context, loc, clRef, name-> rename, selfParam-> selfParam, ignore-> ignore);

        match templateParams {
            EmptyExpression () => { ctors }
            tmp : &TemplateCallExpr => {
                let mt = match ctors {
                    m : &MultSymValue => { m }
                    x : _ => { MultSymValue::new (x.getLoc (), [x], prettyStr-> format ("%", tmp)) }
                };

                let list = context:.validateTemplateArgumentList (tmp.getRights ());
                context:.getValueValidator ().validateTemplateCallMultSym (alias context, loc, mt, list)
            }
            _ => __pragma!panic ();
        }
    }
    
    /**
     * Validate the field constructors
     * @params: 
     *    - context: the context of the validation
     *    - func: the declaration of the constructor
     *    - clRef: the type of the class that is being validated
     *    - selfParam: the parameter self              
     * @returns: the instructions affecting values to the fields
     * @throws: 
     *     - &ErrorMsg: if there is an error in the validation
     */
    fn validateFieldCtors (self, dmut context : &Validator, func : &ConstructorDecl, clRef : &ClassRefType, selfParam : &Value)-> &Value
        throws &ErrorMsg
    {
        let dmut instrs = Vec!{&Value}::new ();
        let dmut errors = Vec!{&ErrorMsg}::new ();
        context:.enterFieldConstruction (clRef); // Enter this context modifies the behavior of Dot operator, by saying the uninitialized fields of type 'clRef' cannot be accessed
        
        {
            let dmut willBeValidated = HashSet!{[c8]}::new ();            
            for it in func.getFieldConstructors () { // We need a list of fields that will be validated by pre construction (ref 1)
                willBeValidated:.insert (it._0.str ());
            }
            
            for it in clRef.getLocalFields () { match it { // Validate all the fields that were not validated by pre construction
                v : &VarDeclValue => {
                    if (v.getLoc ().str () !in willBeValidated) { // (cite 1), so we can initialize the fields that are not pre constructed first
                        if (v.getValue ().isOf!{&UnitValue} ()) {
                            errors:.push (ErrorMsg::fatal (v.getLoc (), format (ValidateErrorMessage::UNINIT_FIELD, v.getLoc ().str ())));
                        } else {
                            let field = context:.getBinOpValidator ().validateClassFieldAccess (alias context, selfParam, VarExpr::new (v.getLoc ()), clRef, true, true, verifyValidation-> false, withAncestor-> false);
                            instrs:.push (AffectValue::new (v.getLoc (), field.getType (), field, v.getValue ()));
                            context:.setFieldValidated (v.getLoc ().str ());
                        }
                    }
                }
            }} catch {
                err : &ErrorMsg => { errors:.push (err); }
            }

            if (errors.len () != 0us) throw ErrorMsg::list (errors[]);
            for it in func.getFieldConstructors () { // Validate all the fields that are written in the pre construction 
                let name = it._0;
                if (name.str () in context:.getFieldValidated ()) {
                    errors:.push (ErrorMsg::fatal (name, format (ValidateErrorMessage::MULTIPLE_FIELD_INIT, name.str ())));
                } else {
                    let field = context:.getBinOpValidator ().validateClassFieldAccess (alias context, selfParam, VarExpr::new (name), clRef, true, true, verifyValidation-> false, withAncestor-> false);
                    let value = context:.verifyCompatibleTypeWithValue (field.getLoc (), field.getType (), context:.validateValue (it._1), byReference-> false);
                    context:.verifyMemoryOwner (field.getLoc (), field.getType (), value, byReference-> false);
                    
                    instrs:.push (AffectValue::new (name, field.getType (), field, value));
                    context:.setFieldValidated (name.str ());
                }
            } catch {
                err : &ErrorMsg => { errors:.push (err); }
            }        
        } catch {
            err : &ErrorMsg => { errors:.push (err); }
        }

        context:.quitFieldConstruction (); // We don't forget to quit the field validation, from that point all fields are accessible
        if (errors.len () != 0us) throw ErrorMsg::list (errors[]);
        if (instrs.len () != 0us) {
            // returns the list of constructions
            BlockValue::new (func.getLoc (), VoidType::new (func.getLoc ()), instrs[])
        } else { 
            UnitValue::new (loc-> func.getLoc ()) // No instrs, no need to open a block
        }
    }
    
    /*!
     * ================================================================================
     * ================================================================================
     * =========================           THROWERS           =========================
     * ================================================================================
     * ================================================================================
     */
    
    /**
     * Validate the throwers a function
     * @params: 
     *    - context: the context of the validation
     *    - throwers: the list of throwers
     * @returns: 
     *    - errors: the list of errors that occurs in the validation
     *    - the list of throwers
     */
    fn validateThrowers (self, dmut context : &Validator, loc : &Word, throwers : [&Expression])-> [(&Word, &Type)]
        throws &ErrorMsg
    {
        // No need to validate core::exception::Exception if there is no throws
        if (throwers.len == 0us) return [];

        let dmut errors = Vec!{&ErrorMsg}::new ();
        let dmut rets = Vec!{(&Word, &Type)}::new ();
        let exceptionType = context:.getExceptionType (loc-> loc);
        let innerExc = exceptionType.asOf!{&ClassPtrType} ().getInner ();

        for i in throwers {
            {
                let type = context:.validateType (i);
                match type {
                    cptr : &ClassRefType => {
                        if (context.isAncestor (exceptionType, cptr)) {
                            rets:.push ((i.getLoc (), type));
                        } else {
                            errors:.push (ErrorMsg::fatal (i.getLoc (), end-> exceptionType.getLoc (), format (ValidateErrorMessage::NOT_AN_EXCEPTION_CLASS, cptr, innerExc)));
                        }
                    }
                    cptr : &ClassPtrType => {
                        errors:.push (ErrorMsg::fatal (i.getLoc (), format (ValidateErrorMessage::CLASS_THROW_PTR, type)));
                        if (context.isAncestor (exceptionType, cptr)) {
                            rets:.push ((i.getLoc (), type));
                        } else {
                            errors:.push (ErrorMsg::fatal (i.getLoc (), end-> exceptionType.getLoc (), format (ValidateErrorMessage::NOT_AN_EXCEPTION_CLASS, cptr.getInner (), innerExc)));
                        }
                    }
                    _ => {                        
                        errors:.push (ErrorMsg::fatal (i.getLoc (), format (ValidateErrorMessage::NOT_A_CLASS, type)));
                    }
                }
            } catch {
                err : &ErrorMsg => { errors:.push (err); }
            }
        }

        if (errors.len () != 0us) {
            throw ErrorMsg::list (errors[]);
        }

        rets[]
    }

    /**
     * Verify that the declared throws and the actual thrown of the function are similar
     * @params: 
     *    - context: the context of the function
     *    - loc: the location of the definition of the function
     *    - name: the name of the function
     *    - thrown: the list of type that are thrown by the body
     *    - expected: the list of type that are declared in the prototype as throws
     * @returns: 
     *     - errors: the list of errors during the validation
     */
    fn verifyThrowing (self, dmut context : &Validator, loc : &Word, name : &SymbolPath, thrown : [(&Word, &Type)], expected : [(&Word, &Type)])
        throws &ErrorMsg
    {
        let (notFound, unused) = self.listUnusedThrows (context, thrown, expected);
        
        let dmut lst = Vec!{&Type}::new ();
        let dmut errors = Vec!{&ErrorMsg}::new ();
        for i in notFound {
            let mut found = false;
            for j, index in lst {
                if i._1 == j {
                    found = true;
                    (alias errors) [index] = errors [index].withNote ([ErrorMsg::note (i._0, ""s8)]);
                    break {}
                }
            }
            
            if (!found) {            
                errors:.push (ErrorMsg::fatal (loc, format (ValidateErrorMessage::THROWS_NOT_DECLARED, name.toStr (), i._1),
                                               notes-> [ErrorMsg::note (i._0, ""s8)]));
                lst:.push (i._1);
            }
        }

        for i in unused {
            errors:.push (ErrorMsg::fatal (loc, format (ValidateErrorMessage::THROWS_NOT_USED, name.toStr (), i._1),
                                           notes-> [ErrorMsg::note (i._0, ""s8)]));
        }

        if (errors.len () != 0us) throw ErrorMsg::list (errors[]);
    } catch {
        err : &ErrorMsg => throw err;
    }

    /**
     * List the throws that are unused, and not found
     * @params:
     *    - thrown: the list of exception thrown in the body of the function
     *    - expected: the list of exception declared in the prototype of the function
     * @returns:
     *    - .0: the list of exception thrown in the body but not declared
     *    - .1: the list of exception declared in the prototype but not found in the body
     */
    fn listUnusedThrows (self, context : &Validator, thrown : [(&Word, &Type)], expected : [(&Word, &Type)])-> ([(&Word, &Type)], [(&Word, &Type)]) {
        let dmut notFound = Vec!{(&Word, &Type)}::new (), dmut unused = Vec!{(&Word, &Type)}::new ();
        for i in thrown {
            let mut found = false;
            for j in expected  {
                if context.isDirectInstance (i._1, j._1) {
                    found = true;
                    break {}
                }
            }

            if !found {
                notFound:.push (i);
            }
        }

        for i in expected {
            let mut found = false;
            for j in thrown {
                if (context.isDirectInstance (i._1, j._1)) {
                    found = true;
                    break {}
                }
            }

            if !found {
                unused:.push (i);
            }
        }

        (notFound[], unused[])        
    }
    
    /*!
     * ================================================================================
     * ================================================================================
     * =========================          PROTOTYPE           =========================
     * ================================================================================
     * ================================================================================
     */
    
    /**
     * Validate the prototype of a frame for generation
     * @params: 
     *   - context: the context of the validation
     *   - sym: the symbol being validated
     *   - proto: the prototype to validate
     *   - forMethod: true iif the validation is intended to create a method prototype
     * @returns:
     *    - .0: the return type of the prototype
     *    - .1: the list of parameters
     * @throws: &ErrorMsg, if there is a malformed parameter, or the return type is malformed
     */
    fn validatePrototype (mut self, dmut context : &Validator, sym : &Symbol, proto : &FunctionProtoDecl, forMethod : bool = false)-> (&Type, [&ProtoVarValue])
        throws &ErrorMsg
    {
        let dmut parameters = Vec!{&ProtoVarValue}::new ();
        let dmut errors = Vec!{&ErrorMsg}::new ();
        
        let noValue = sym in self._validating;
        self._validating:.insert (sym);
        {
            for i, param in proto.getParameters () {
                if (i != 0us || !forMethod) { // If we validate the prototype for a method, we don't validate the first parameter (which is always self)
                    let (isMutable, isReference, isLazy, type, value) = self.validateParamDecl (alias context, param, noValue-> noValue);
                    let paramGen = ProtoVarValue::new (param.getLoc (), type, value, isMutable, isSelf-> false, isReference-> isReference, isLazy-> isLazy);
                    parameters:.push (paramGen);
                    
                    if (param.getLoc ().str () != Keys::UNDER) {
                        context:.verifyShadow (paramGen.getLoc ());
                        context:.insertLocal (paramGen.getLoc ().str (), paramGen);
                    }
                } catch {
                    err : &ErrorMsg => {
                        errors:.push (err);
                    }
                }
            }
        }         
        self._validating:.remove (sym);

        let r : &Type = {
            match proto.getRetType () {
                EmptyExpression () => { cast!{&Type} (VoidType::new (proto.getLoc ())) }
                x : _ => { context:.validateType (x) }
            }
        } catch {
            err : &ErrorMsg => {
                errors:.push (err);
                throw ErrorMsg::list (errors[]);
            }
        }
        
        if (errors.len () != 0us) throw ErrorMsg::list (errors[]);
        (r, parameters[])          
    }

    /**
     * Verify that the prototype is correct for the main function
     * @params: 
     *   - funcLoc: the location of the function definition
     *   - proto: the prototype of the frame 
     *   - parameters: the validated parameters of the function
     *   - retType: the return type of the function
     * @returns:
     *    - errors: add errors if the prototype is not valid
     */
    fn verifyMainPrototype (self, dmut context : &Validator, funcLoc : &Word, parameters : [&Value], retType : &Type)
        throws &ErrorMsg
    {
        let dmut errors = Vec!{&ErrorMsg}::new ();
        if (parameters.len > 1us) {
            errors:.push (ErrorMsg::fatal (parameters [1us].getLoc (),
                                           ValidateErrorMessage::MAIN_FUNCTION_ONE_ARG));
        } else if (parameters.len == 1us) {
            let test = SliceType::new (funcLoc, SliceType::new (funcLoc, CharType::new (funcLoc, size-> 8u16)));
            {
                context:.verifyCompatibleTypeWithValue (parameters [0].getLoc (), test, parameters [0], byReference-> false);
            } catch {
                err : &ErrorMsg => { errors:.push (err); }
            }
        }

        match retType {
            VoidType () => {}
            _ => {
                let test = IntType::new (funcLoc, size-> 32u16, signed-> true);
                {
                    context:.verifyCompatibleType (retType.getLoc (), test.getLoc (), test, retType);
                } catch {
                    err : &ErrorMsg => { errors:.push (err); }
                }   
            }
        }

        if (errors.len () != 0us) throw ErrorMsg::list (errors[]);
    }
    

    /**
     * Validate a parameter of a prototype
     * @params: 
     *    - context: the context of the validation
     *    - param: the parameter to validate
     *    - noValue: true iif we are recursevely validating and thus the value must not be validated (cf. Recursive default parameters)
     * @throws: &ErrorMsg, if there is an error
     * @returns: 
     *    - .0: true iif the parameter is declared mutable
     *    - .1: true iif the parameters is declared as a reference
     *    - .2: the type of the parameter
     *    - .3: the value of the parameter
     */
    fn validateParamDecl (self, dmut context : &Validator, param : &Expression, noValue : bool = false)-> (bool, bool, bool, &Type, &Value)
        throws &ErrorMsg
    {
        match param {
            vdecl : &VarDeclExpr => {
                let type = {
                    context:.validateTypeForVarDecl (vdecl.getType (), vdecl, canBeRef-> true, canBeLazy-> true)
                } catch {
                    err : &ErrorMsg => throw ErrorMsg::note (param.getLoc (), ValidateErrorMessage::VALIDATING, notes-> [err]);
                };

                let value : &Value = if !vdecl.getValue ().isOf!{&EmptyExpression} () && !noValue {
                    if (vdecl.getLoc () == Keys::UNDER) { // variable with a default value must have a name, otherwise it is impossible to change them 
                        throw ErrorMsg::fatal (vdecl.getLoc (), ValidateErrorMessage::DEFAULT_VAR_NO_NAME, notes-> [ErrorMsg::note (vdecl.getValue ().getLoc (), ""s8)]);
                    }
                    
                    context:.validateValue (vdecl.getLoc (), vdecl.getValue (), type-> type)
                } else {                    
                    cast!{&Value} (UNIT_VALUE)
                }

                if (type.isMutable () && !type.needExplicitAlias () && !vdecl.isRef ()) {
                    throw ErrorMsg::fatal (vdecl.getMutOrDmutLocation (), ValidateErrorMessage::MUTABLE_CONST_PARAM);
                }

                match type {
                    VoidType () => throw ErrorMsg::fatal (vdecl.getLoc (), format (ValidateErrorMessage::DECLARE_VOID_VAR, type));
                    NoneType () => throw ErrorMsg::fatal (vdecl.getLoc (), format (ValidateErrorMessage::DECLARE_VOID_VAR, type));
                    ClassRefType () => throw ErrorMsg::fatal (vdecl.getType ().getLoc (), format (ValidateErrorMessage::INCOMPLETE_TYPE, type),
                                                              notes-> [ErrorMsg::note (vdecl.getType ().getLoc (), ValidateErrorMessage::FORGET_AND_CLASS, oneLine-> true)]);
                    TemporaryType () => throw ErrorMsg::fatal (vdecl.getType ().getLoc (), format (ValidateErrorMessage::INCOMPLETE_TYPE, type));
                }

                return (type.isMutable (), vdecl.isRef (), vdecl.isLazy (), type, value);
            }
            _ => {
                println ("TODO : ", param::typeinfo.name);
                __pragma!panic ();
            }
        }
    }

    /**
     * Validate a parameter of a template prototype
     * @params: 
     *    - context: the context of the validation
     *    - param: the parameter to validate
     *    - noValue: true iif we are recursevely validating and thus the value must not be validated (cf. Recursive default parameters)
     * @returns: 
     *    - .0: true iif the parameter is declared mutable
     *    - .1: the type of the parameter (can be none, if the validation failed)
     *    - .2: the value of the parameter (can be none if there is none, or the validation failed)
     */
    pub fn validateTemplateParamDecl (self, dmut context : &Validator, param : &Expression, noValue : bool = false)-> (bool, bool, bool, &Type, &Value) {
        match param {
            vdecl : &VarDeclExpr => {
                let type = {
                    context:.validateTypeForVarDecl (vdecl.getType (), vdecl, canBeRef-> true, canBeLazy-> true)
                } catch {
                    _ => {
                        cast!{&Type} (NONE_TYPE)
                    }
                };
                
                let value : &Value = if !vdecl.getValue ().isOf!{&EmptyExpression} () && !noValue {
                    {
                        context:.validateValue (vdecl.getLoc (), vdecl.getValue (), type-> type)
                    } catch {
                        _ => {
                            // we put something, because we don't want the value to be set automatically
                            // It must be named, even if we don't know yet what it is it's default value, template specialization will tell
                            cast!{&Value} (TemplateDefaultValue::new (vdecl.getValue ().getLoc ()))
                        }
                    }                        
                } else {                    
                    cast!{&Value} (UNIT_VALUE)
                }

                return (type.isMutable (), vdecl.isRef (), vdecl.isLazy (), type, value);
            }
            _ => {
                println ("TODO : ", param::typeinfo.name);
                __pragma!panic ();
            }
        }
    }
    
    /**
     * Validate the self parameter of a method prototype
     * @params: 
     *   - param: the self parameter
     *   - clRef: the type of the class used
     * @returns: the protovar value
     */
    fn validateSelfParamDecl (self, param : &Expression, clRef : &ClassRefType)-> &ProtoVarValue
        throws &ErrorMsg
    {
        match param {
            vdecl : &VarDeclExpr => {
                let isMutable = vdecl.isMutable ();
                if (!vdecl.getLazyOrRefLocation ().isEof ()) { // ref,lazy self has no meaning
                    throw ErrorMsg::fatal (vdecl.getLazyOrRefLocation (), format (ValidateErrorMessage::UNDEF_DECORATOR_TYPE, vdecl.getLazyOrRefLocation ().str ()));
                }

                if (vdecl.isDeeplyMutable ()) { // dmut self neither
                    throw ErrorMsg::fatal (vdecl.getDeeplyMutableLocation (), format (ValidateErrorMessage::UNDEF_DECORATOR_TYPE, vdecl.getDeeplyMutableLocation ().str ()));
                }

                let clPtr = clRef.createInstance (isMutable, isMutable); // mut in that case means dmut                
                ProtoVarValue::new (param.getLoc (), clPtr, UNIT_VALUE, isMutable, isSelf-> true, isReference-> false) // returns the protovar
            }
            _ => { // mmh, that's not usable as a self parameter, unless its a varexpr ? no it cannot
                __pragma!panic ();
            }
        }
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================           UNITTEST           =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a unit test
     * @params: 
     *   - context: the context of the validation
     *   - sym: the symbol to validate
     *   - uid: the uniq id of the unittest in the local module
     */
    pub fn validateTest (self, dmut context : &Validator, dmut sym : &UnitTestSymbol, uid : usize)
        throws &ErrorMsg
    {
        context:.pushReferent (alias sym);
        context:.enterForeign (isFnBody-> false);

        let mut hasErrors = false;
        let dmut errors = Vec!{&ErrorMsg}::new ();
        let body = {
            context:.enterBlock ();
            context:.enterFunctionBody ();
            context:.setFunctionReturn (VoidType::new (sym.getLoc ()));

            context:.validateValue (sym.getContent ().getBody ())
        } catch {
            err : &ErrorMsg => {
                errors:.push (err);
                cast!{&Value} (UNIT_VALUE)
            }
        } exit {
            {
                context:.quitBlock (warnUnused-> !hasErrors);
            } catch {
                err : &ErrorMsg => { errors:.push (err); }
            }
        };

        context:.exitForeign ();
        context:.popReferent ();

        if (errors.len () != 0us) throw ErrorMsg::list (errors[]);

        let path = sym.getPath ().push (format ("%", uid));
        let gen = UnitTestGenerator::new (sym.getLoc (), path, body);
        context:.insertGenerator (alias sym, gen);
    }


    /*!
     * ================================================================================
     * ================================================================================
     * ==========================           COMMON           ==========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * @returns: the location of the unsafe attributes or EOF_WORD if none exist
     * */
    fn getUnsafeLoc (self, attributes : [AttributeWord])-> &Word {
        for it in attributes {
            if (it.attr == Attributes::UNSAFE) {
                return it.loc;
            }
        }

        EOF_WORD
    }

    /**
     * @returns: the location of the field attributes or EOF_WORD if none exist
     * */
    fn getFieldLoc (self, attributes : [AttributeWord])-> &Word {
        for it in attributes {
            if (it.attr == Attributes::FIELD) {
                return it.loc;
            }
        }

        EOF_WORD
    }

    /**
     * verify that attributes are applicable to a function
     * @params:
     *    - attributes: the list of attributes
     * */
    fn verifyUndefAttributes (self, attributes : [AttributeWord])
        throws &ErrorMsg
    {
        let dmut errors = Vec!{&ErrorMsg}::new ();
        for it in attributes match it.attr {
            Attributes::UNSAFE => {}
            Attributes::INLINE => {}
            _ => { errors:.push (ErrorMsg::fatal (it.loc, format (ValidateErrorMessage::UNDEFINED_ATTRIBUTE, it.attr)));  }
        }

        if (errors.len () != 0us) throw ErrorMsg::list (errors []);
    }

    /**
     * verify that attributes are applicable to a dtor
     * @params:
     *    - attributes: the list of attributes
     * */
    fn verifyUndefAttributesDtor (self, attributes : [AttributeWord])
        throws &ErrorMsg
    {
        let dmut errors = Vec!{&ErrorMsg}::new ();
        for it in attributes {
            errors:.push (ErrorMsg::fatal (it.loc, format (ValidateErrorMessage::UNDEFINED_ATTRIBUTE, it.attr)));
        }

        if (errors.len () != 0us) throw ErrorMsg::list (errors []);
    }

    /**
     * verify that attributes are applicable to a method
     * @params:
     *    - attributes: the list of attributes
     * */
    fn verifyUndefAttributesMethod (self, attributes : [AttributeWord])
        throws &ErrorMsg
    {
        let dmut errors = Vec!{&ErrorMsg}::new ();
        for it in attributes match it.attr {
            Attributes::UNSAFE => {}
            Attributes::FINAL  => {}
            Attributes::INLINE => {}
            Attributes::FIELD  => {}
            _ => { errors:.push (ErrorMsg::fatal (it.loc, format (ValidateErrorMessage::UNDEFINED_ATTRIBUTE, it.attr)));  }
        }

        if (errors.len () != 0us) throw ErrorMsg::list (errors []);
    }


}
