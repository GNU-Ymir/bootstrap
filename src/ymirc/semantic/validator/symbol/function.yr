mod ymirc::semantic::validator::symbol::function;

import ymirc::semantic::validator::visitor;
import ymirc::semantic::validator::errors;
import ymirc::semantic::symbol::function;
import ymirc::semantic::symbol::constructor;
import ymirc::syntax::declaration::protection;
import ymirc::syntax::expression::_;
import ymirc::syntax::declaration::_;

import ymirc::syntax::keys;
import ymirc::semantic::generator::_;
import ymirc::errors::_;
import ymirc::utils::format;
import ymirc::lexing::word;

import std::collection::vec;
import std::io, std::fs::path;

/**
 * The function validator is the class responsible for function symbol validation
 */
pub class FunctionValidator {

    /**
     * Create a new empty validator
     */
    pub self () {}


    /**
     * Validate a function
     * @params: 
     *   - context: the context of the validation
     *   - sym: the function to validate
     */
    pub def validate (self, dmut context : &Validator, dmut sym : &FunctionSymbol)
        throws &ErrorMsg
    {
        context:.pushReferent (alias sym);
        context:.enterForeign ();
        if (sym.isTest ()) self.validateTest (alias context, alias sym);
        else self.validateFunction (alias context, alias sym);                
    } exit {
        context:.exitForeign ();
        context:.popReferent ();
    } catch {
        err : &ErrorMsg => {
            throw ErrorMsg::fatal (sym.getLoc (), format (ValidateErrorMessage::VALIDATING_SYMBOL, sym.getPath ().toStr (sep-> "::"s8)), notes-> [err]);
        }
    }


    /**
     * Validate the prototype of a function
     * @params: 
     *    - context: the context of the validation
     *    - sym: the symbol to validate
     * @returns: a callable prototype of function
     * @throws: &ErrorMsg, if the function is malformed
     */
    pub def validatePrototype (self, dmut context : &Validator, dmut sym : &FunctionSymbol)-> &Value
        throws &ErrorMsg
    {
        match (sym.getFrameProto ()) {
            EmptyGenerator () => {
                return self.validateFunction (alias context, alias sym, validateBody-> false);
            }
            v : &Value => 
                return v;            
            g : _ => {
                println ("What is inside the function ???", g::typeinfo.name);
                __pragma!panic ();
            }
        }
    }


    /**
     * Validate the prototype of a constructor
     * @params: 
     *    - context: the context of the validation
     *    - sym: the symbol to validate
     * @returns: a callable prototype of function
     * @throws: &ErrorMsg, if the constructor is malformed
     */
    pub def validatePrototype (self, dmut context : &Validator, dmut sym : &ConstructorSymbol)-> &Value
        throws &ErrorMsg
    {
        context;
        sym;
        __pragma!fake_throw (&ErrorMsg);
        __pragma!panic ();
    }


    /**
     * ================================================================================
     * ================================================================================
     * =========================          FUNCTION$           =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a normal function
     * @params: 
     *    - context: the context of the validation
     *    - sym: the symbol to validate
     * @returns: the prototype of the function
     */        
    def validateFunction (self, dmut context : &Validator, dmut sym : &FunctionSymbol, validateBody : bool = true)-> &Value
        throws &ErrorMsg
    {        
        let func = sym.getContent ();       
        let dmut errors = Vec!{&ErrorMsg}::new ();
        let throwers = self.validateThrowers (alias context, func.getThrowers (), alias errors);
        
        let (retType, parameters, body, needFinalReturn) = {            
            context:.enterBlock ();
            let (retType, parameters) = match sym.getFrameProto () {
                p : &PrototypeValue => {
                    (p.getRetType (), p.getParameters ())
                }
                _ => {
                    self.validatePrototype (alias context, func.getFunctionProto ())
                }
            }

            
            if (func.getLoc ().str () == Keys::MAIN) {
                self.verifyMainPrototype (alias context, func.getLoc (), parameters, retType, alias errors);
            }

            let (body, needFinalReturn) = if (validateBody) {
                self.validateBody (alias context, func.getLoc (), sym.getPath (), func.getBody (), retType, throwers, alias errors)
            } else {
                (cast!{&Value} (UnitValue::new ()), false)
            }
            
            (retType, parameters, body, needFinalReturn)
        } exit {
            {
                if (!validateBody) context:.clearLocalScope ();
                context:.quitBlock ();
            } catch {
                err : &ErrorMsg => { errors:.push (err); }
            }
        }

        if (errors.len () != 0us) throw ErrorMsg::list (errors[]);
        if (validateBody) {
            match func.getBody () {
                EmptyExpression () => {}
                _ => {
                    let frame = FrameGenerator::new (func.getLoc (), sym.getPath (), parameters, retType, body, needFinalReturn-> needFinalReturn, externLang-> sym.getExternalLanguage (), isWeak-> sym.isWeak ());
                    context:.insertNewGenerator (frame);
                }
            }
        }

        match sym.getFrameProto () {
            p : &PrototypeValue => p
            _ => {
                let gen = PrototypeValue::new (sym.getLoc (), sym, parameters, retType, throwers);
                sym:.setFrameProto (gen);
                
                gen
            }
        }
    }

    /**
     * Validate the body of a function
     * @params: 
     *     - context: the context of the validation
     *     - loc: the location of the function
     *     - name: the name of the function
     *     - body: the body of the function
     *     - throwers: the list of throwers
     * @returns: 
     *    - errors: the list of errors 
     *    - .0: the validated value of the body
     *    - .1: true iif the value is not a returner
     */
    def validateBody (self, dmut context : &Validator, loc : &Word, name : &Path, body : &Expression, retType : &Type, throwers : [&Type], dmut errors : &Vec!{&ErrorMsg})-> (&Value, bool)        
    {
        match body {
            EmptyExpression () => {
                context:.clearLocalScope ();
                (UnitValue::new (loc-> loc), false)
            }
            _ => {
                {
                    context:.setFunctionReturn (retType);
                    let bodyValue = context:.validateValue (body);
                    let need = if (!bodyValue.isReturner ()) {
                        context:.verifyMemoryOwner (loc, retType, bodyValue);
                        match retType {
                            VoidType () => { false }
                            _ => { true }
                        }
                    } else { false };
                    
                    self.verifyThrowing (alias context, loc, name, bodyValue.getThrowers (), throwers, alias errors);
                    (bodyValue, need)
                } catch {
                    err : &ErrorMsg => {
                        errors:.push (err);
                        (UnitValue::new (loc-> loc), false)
                    }
                }
            }
        }
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================           THROWERS           =========================
     * ================================================================================
     * ================================================================================
     */
    
    /**
     * Validate the throwers a function
     * @params: 
     *    - context: the context of the validation
     *    - throwers: the list of throwers
     * @returns: 
     *    - errors: the list of errors that occurs in the validation
     *    - the list of throwers
     */
    def validateThrowers (self, dmut context : &Validator, throwers : [&Expression], dmut errors : &Vec!{&ErrorMsg})-> [&Type] {
        let dmut rets = Vec!{&Type}::new ();
        for i in throwers {
            {
                rets:.push (context:.validateType (i));
            } catch {
                err : &ErrorMsg => { errors:.push (err); }
            }
        }

        rets[]
    }

    /**
     * Verify that the declared throws and the actual thrown of the function are similar
     * @params: 
     *    - context: the context of the function
     *    - loc: the location of the definition of the function
     *    - name: the name of the function
     *    - thrown: the list of type that are thrown by the body
     *    - expected: the list of type that are declared in the prototype as throws
     * @returns: 
     *     - errors: the list of errors during the validation
     */
    def verifyThrowing (self, dmut context : &Validator, loc : &Word, name : &Path, thrown : [&Type], expected : [&Type], dmut errors : &Vec!{&ErrorMsg}) {
        context;
        loc;
        name;
        thrown;
        expected;
        errors;
    }        
    
    /**
     * ================================================================================
     * ================================================================================
     * =========================          PROTOTYPE           =========================
     * ================================================================================
     * ================================================================================
     */
    
    /**
     * Validate the prototype of a frame for generation
     * @params: 
     *   - context: the context of the validation
     *   - proto: the prototype to validate
     * @returns:
     *    - .0: the return type of the prototype
     *    - .1: the list of parameters
     * @throws: &ErrorMsg, if there is a malformed parameter, or the return type is malformed
     */
    def validatePrototype (self, dmut context : &Validator, proto : &FunctionProtoDecl, noValue : bool = false)-> (&Type, [&Value])
        throws &ErrorMsg
    {
        let dmut parameters = Vec!{&Value}::new ();
        let dmut errors = Vec!{&ErrorMsg}::new ();
        
        for param in proto.getParameters () {
            {
                let (isMutable, type, value) = self.validateParamDecl (alias context, param, noValue-> noValue);
                
                match type {
                    VoidType () => throw ErrorMsg::fatal (param.getLoc (), format (ValidateErrorMessage::DECLARE_VOID_VAR, type));
                    NoneType () => throw ErrorMsg::fatal (param.getLoc (), format (ValidateErrorMessage::DECLARE_VOID_VAR, type));
                    TemporaryType () => throw ErrorMsg::fatal (param.getLoc (), format (ValidateErrorMessage::INCOMPLETE_TYPE, type));
                }

                let paramGen = ProtoVarValue::new (param.getLoc (), type, value, isMutable, isSelf-> false);
                parameters:.push (paramGen);
                
                if (param.getLoc ().str () != Keys::UNDER) {
                    context:.verifyShadow (paramGen.getLoc ());
                    context:.insertLocal (paramGen.getLoc ().str (), paramGen);
                }
            } catch {
                err : &ErrorMsg => {
                    errors:.push (err);
                }
            }
        }

        let r : &Type = {
            match proto.getRetType () {
                e : &EmptyExpression => { cast!{&Type} (VoidType::new (e.getLoc ())) }
                x : _ => { context:.validateType (x) }
            }
        } catch {
            err : &ErrorMsg => {
                errors:.push (err);
                throw ErrorMsg::list (errors[]);
            }
        }
        
        if (errors.len () != 0us) throw ErrorMsg::list (errors[]);
        (r, parameters[])          
    }

    /**
     * Verify that the prototype is correct for the main function
     * @params: 
     *   - funcLoc: the location of the function definition
     *   - proto: the prototype of the frame 
     *   - parameters: the validated parameters of the function
     *   - retType: the return type of the function
     * @returns:
     *    - errors: add errors if the prototype is not valid
     */
    def verifyMainPrototype (self, dmut context : &Validator, funcLoc : &Word, parameters : [&Value], retType : &Type, dmut errors : &Vec!{&ErrorMsg}) {
        if (parameters.len > 1us) {
            errors:.push (ErrorMsg::fatal (parameters [1us].getLoc (),
                                           ValidateErrorMessage::MAIN_FUNCTION_ONE_ARG));
        } else if (parameters.len == 1us) {
            let test = SliceType::new (funcLoc, SliceType::new (funcLoc, CharType::new (funcLoc, size-> 8u16)));
            {
                context:.verifyCompatibleTypeWithValue (parameters [0].getLoc (), test, parameters [0]);
            } catch {
                err : &ErrorMsg => { errors:.push (err); }
            }
        }

        match retType {
            VoidType () => {}
            _ => {
                let test = IntType::new (funcLoc, size-> 32u16, signed-> true);
                {
                    context:.verifyCompatibleType (retType.getLoc (), test, retType);
                } catch {
                    err : &ErrorMsg => { errors:.push (err); }
                }   
            }
        }        
    }
    

    /**
     * Validate a parameter of a prototype
     * @params: 
     *    - context: the context of the validation
     *    - param: the parameter to validate
     *    - noValue: true iif we are recursevely validating and thus the value must not be validated (cf. Recursive default parameters)
     * @throws: &ErrorMsg, if there is an error
     * @returns: 
     *    - .0: true iif the parameter is declared mutable
     *    - .1: the type of the parameter
     *    - .2: the value of the parameter
     */
    def validateParamDecl (self, dmut context : &Validator, param : &Expression, noValue : bool = false)-> (bool, &Type, &Value)
        throws &ErrorMsg
    {
        match param {
            vdecl : &VarDeclExpr => {
                let type : &Type = {
                    context:.validateType (vdecl.getType (), decos-> vdecl.getDecos ())
                } catch {
                    err : &ErrorMsg => throw ErrorMsg::note (param.getLoc (), ValidateErrorMessage::VALIDATING, notes-> [err]);
                }                
                
                let value : &Value = if !vdecl.getValue ().isOf!{&EmptyExpression} () && !noValue{
                    context:.validateValue (vdecl.getLoc (), vdecl.getValue (), type-> type)
                } else {
                    cast!{&Value} (NoneValue::new ())
                }

                
                if (!type.isRef () && type.isMutable () && !type.needImplicitAlias ()) {
                    throw ErrorMsg::fatal (vdecl.getLoc (), ValidateErrorMessage::MUTABLE_CONST_PARAM);
                }

                return (type.isMutable (), type, value);
            }
            _ => {
                println ("TODO : ", param::typeinfo.name);
                __pragma!panic ();
            }
        }
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================           UNITTEST           =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate a unit test
     * @params: 
     *   - context: the context of the validation
     *   - sym: the symbol to validate
     */
    def validateTest (self, dmut context : &Validator, dmut sym : &FunctionSymbol)
        throws &ErrorMsg
    {
        context;
        sym;
        println ("TODO");
        __pragma!fake_throw (&ErrorMsg);
        __pragma!panic ();
    }
    
}
