mod ymirc::semantic::validator::symbol::template;

import ymirc::semantic::validator::visitor;
import ymirc::semantic::validator::symbol::mapper;
import ymirc::semantic::validator::errors;
import ymirc::semantic::symbol::template;
import ymirc::syntax::declaration::protection;
import ymirc::syntax::expression::_;
import ymirc::syntax::declaration::_;

import ymirc::syntax::keys;
import ymirc::semantic::generator::_;
import ymirc::errors::_;
import ymirc::utils::format;
import ymirc::lexing::word;

import std::collection::vec;
import std::io, std::fs::path;

/**
 * The template validator is the template responsible for template symbol validation
 */
pub class TemplateValidator {

    /**
     * Create a new empty validator
     */
    pub self () {}

    /**
     * ================================================================================
     * ================================================================================
     * =========================             CALL             =========================
     * ================================================================================
     * ================================================================================
     */
    
    /**
     * Validate a template call that creates a value (function for example, or aka, etc.)
     * @params: 
     *    - context: the context of the validation
     *    - loc: the location of the call
     *    - left: the value that is template called
     *    - rights: the template arguments passed to the template
     * @returns: 
     *    - .0: the value
     *    - .1: the score of the call
     * @throws:
     *    - &ErrorMsg: if the call is impossible (for example left is not a valid template)    
     */
    pub def validateCallValue (self, dmut context : &Validator, loc : &Word, left : &Value, rights : [&Generator])-> (&Value, u32)
        throws &ErrorMsg
    {
        match left {
            x : &TemplateRefValue => {
                return self.validateCallTemplateRefValue (alias context, loc, x, rights);
            }
            _ => {
                throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_TEMPLATE_CALL, left, rights));
            }
        }
    }


    /**
     * Validate a template call that creates a value
     * @params: 
     *    - context: the context of the validation
     *    - loc: the location of the call
     *    - left: the value that is template called
     *    - rights: the template arguments passed to the template
     * @returns: 
     *    - .0: the value
     *    - .1: the score of the call
     * @throws:
     *    - &ErrorMsg: if the call is impossible
     */
    pub def validateCallTemplateRefValue (self, dmut context : &Validator, _ : &Word, left : &TemplateRefValue, rights : [&Generator])-> (&Value, u32)
        throws &ErrorMsg
    {
        let templateParams = left.getSymbol ().getContent ().getParameters ();
        let (mapper, consumed) = self.validateFromExplicit (alias context, templateParams, rights);

        if (consumed < rights.len) {
            throw ErrorMsg::fatal (rights[consumed].getLoc (), format (ValidateErrorMessage::TEMPLATE_REST, rights[consumed .. $]));
        } else {
            // Apply mapper on template
            println (mapper.getMapping ());
            __pragma!panic ();
        }        
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================           EXPLICIT           =========================
     * ================================================================================
     * ================================================================================
     */
    
    /**
     * Validate a template explicit specialization
     * @params: 
     *    - context: the context of the validation
     *    - params: the template parameters
     *    - values: the list of compile time knwon values passed to the template     
     * @returns: 
     *     - .0: a template mapper containing the template specialization
     *     - .1: the number of values that were consumed during the specialization
     * @throws: 
     *    - &ErrorMsg: if the specialization is impossible
     */
    pub def validateFromExplicit (self, dmut context : &Validator, params : [&Expression], values : [&Generator])-> (&TemplateMapper, usize)
        throws &ErrorMsg
    {
        let mut consumed = 0us;
        let dmut globalMapper = TemplateMapper::new ();
        let mut syntTemplate = params;
        
        while (consumed < values.len && syntTemplate.len != 0us) {
            // Create a slice on template arguments that have not been used yet
            // Template arguments are used in the order they are written, but sometimes several at a time
            let currentElems = values[consumed .. $];

            // Create a slice on the template parameters that are not directly referenced
            // Only the first template parameter is explicitly set, but maybe it will also set other parameters
            let rest = syntTemplate[1us .. $]; 

            {
                // Perform the explicit template validation, with the given template parameters, and call arguments
                let (mapper, localConsumed) = self.validateParamTemplateFromExplicit (alias context, rest, syntTemplate[0], currentElems);

                globalMapper:.merge (mapper);
                consumed += localConsumed;
                syntTemplate = self.replaceSyntaxTempl (syntTemplate, globalMapper);
            } catch {
                err : &ErrorMsg => { // TODO partial resolution note
                    throw err; 
                }
            }
        }
        
        (globalMapper, consumed)
    }

    /**
     * Validate a template parameter from an explicit call
     * @params: 
     *    - context: the context of the validation
     *    - syntTemplate: the template parameters
     *    - current: the template parameter to validate
     *    - values: the values passed to the template call
     * @returns:
     *    - .0: the mapper containing the template specialisation
     *    - .1: the number of values that were consumed
     * @throws:
     *    - &ErrorMsg: if the specialization is impossible
     */
    def validateParamTemplateFromExplicit (self, dmut context : &Validator, syntaxTemplate : [&Expression], current : &Expression, values : [&Generator])-> (&TemplateMapper, usize)
        throws &ErrorMsg
    {
        match current {
            v : &VarExpr => {
                return self.validateVarExprFromExplicit (alias context, v, values);
            }
            ov : &TemplateOfVarExpr => {
                if (ov.getKind () == TemplateOfVarType::OF) {
                    return self.validateOfVarExprFromExplicit (alias context, syntaxTemplate, ov, values);
                } else {
                    __pragma!panic ();
                }
            }
            _ => {
                println (format ("TODO %", current));
                __pragma!panic ();
            }
        }
    }    

    /**
     * Validate an explicit template specialization where template parameter is a simple varexpr
     * @params: 
     *    - context: the context of the validation
     *    - v: the var expression
     *    - values: the list of values passed to the template call
     * @returns:
     *    - .0: the template parameter specialization
     *    - .1: the number of consumed parameters (should be 1us)
     * @throws:
     *    - &ErrorMsg: if the values cannot be used to specialize the template parameter
     */
    def validateVarExprFromExplicit (self, dmut context : &Validator, v : &VarExpr, values : [&Generator])-> (&TemplateMapper, usize)
        throws &ErrorMsg
    {
        match values [0] {
            t : &Type => {
                context.verifyNotIsNativeType (v.getLoc ());
                let dmut mapper = TemplateMapper::new (score-> TemplateScore::VAR);
                mapper:.insert (v.getLoc ().str (), TypeWrapperExpr::new (t.getLoc (), t));
                
                return (mapper, 1us);
            }
            _ => {                  
                throw ErrorMsg::fatal (values[0].getLoc (), ValidateErrorMessage::USE_AS_TYPE,
                                       notes-> [ErrorMsg::note (v.getLoc (), ""s8)]);
            }
        }
    }


    /**
     * ================================================================================
     * ================================================================================
     * =========================       EXPLICIT OF VAR        =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate an explicit template specialization where template parameter is an of var
     * @params: 
     *    - context: the context of the validation
     *    - v: the template of var to validate
     *    - values: the list of values passed to the template call
     * @returns:
     *    - .0: the template parameter specialization
     *    - .1: the number of consumed parameters (should be 1us)
     * @throws:
     *    - &ErrorMsg: if the values cannot be used to specialize the template parameter
     */
    def validateOfVarExprFromExplicit (self, dmut context : &Validator, alls : [&Expression], v : &TemplateOfVarExpr, values : [&Generator])-> (&TemplateMapper, usize)
        throws &ErrorMsg
    {
        match values[0] {
            t : &Type => {                
                match v.getSpecialization () {
                    var : &VarExpr => {
                        return self.validateOfVarInnerExplicit (alias context, alls, v, var, t);
                    }
                    _ => {
                        __pragma!panic ();
                    }                    
                }
            }
            _ => {
                throw ErrorMsg::fatal (values[0].getLoc (), ValidateErrorMessage::USE_AS_TYPE,
                                       notes-> [ErrorMsg::note (v.getLoc (), ""s8)]);
            }
        }        
    }

    /**
     * Validate an explicit inner part of an of var, where the inner part is simply a VarExpr (A of T)
     * @params: 
     *    - context: the context of the validation
     *    - alls: the list of template parameters that are not validated yet
     *    - ofV: the template of var to validate
     *    - v: the inner part of the ofvar (=> ofV.getInner ())
     *    - values: the list of values passed to the template call
     * @returns:
     *    - .0: the template parameter specialization
     *    - .1: the number of consumed parameters (should be 1us)
     * @throws:
     *    - &ErrorMsg: if the values cannot be used to specialize the template parameter
     */
    def validateOfVarInnerExplicit (self, dmut context : &Validator, alls : [&Expression], ofV : &TemplateOfVarExpr, v : &VarExpr, type : &Type)-> (&TemplateMapper, usize)
        throws &ErrorMsg
    {
        // Search the inner value (A of T => search T in the parameters)
        let expr = self.findExpression (v.getLoc ().str (), alls);
        if !expr.isOf!{&EmptyExpression} () {

            let (mapper, _) = self.validateParamTemplateFromExplicit (alias context, alls, expr, [cast!(&Generator) (type)]);
            let dmut retMapper = TemplateMapper::new ();
            retMapper:.merge (mapper);
            retMapper:.insert (ofV.getLoc ().str (), TypeWrapperExpr::new (type.getLoc (), type));

            return (retMapper, 1us);
        } else {
            // TODO
            __pragma!panic ();
        }
    }
    

    /**
     * ================================================================================
     * ================================================================================
     * =========================            COMMON            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Create a new template parameter list from an old list and a pre template specialization
     * @params: 
     *    - syntaxTemplate: the old template parameters
     *    - mapper: the template specialization
     * @returns: The transformed list
     * @throws:
     *     - &ErrorMsg: if the transformation is impossible (?)    
     */
    def replaceSyntaxTempl (self, syntaxTemplate : [&Expression], mapper : &TemplateMapper)-> [&Expression]
        throws &ErrorMsg
    {
        syntaxTemplate;
        mapper;
        __pragma!fake_throw (&ErrorMsg);
        __pragma!panic ();
    }

    /**
     * Search in the list of template parameters a parameter whose name is 'name'
     * @params: 
     *    - name: the name to find
     *    - alls: the list of template params
     * @returns: an expression from 'alls' whose name is 'name' (&EmptyExpression if the expression does not exists)
     */
    def findExpression (self, name : [c8], alls : [&Expression])-> &Expression {   
        for i in alls match i {
            v : &VarExpr => {
                if v.getLoc ().str () == name {
                    return v;
                }
            }
            v : &TemplateOfVarExpr => {
                if v.getLoc ().str () == name {
                    return v;
                }
            }
            v : &TemplateVariadicVarExpr => {
                if v.getLoc ().str () == name {
                    return v;
                }
            }
            v : &TemplateVarExpr => {
                if v.getLoc ().str () == name {
                    return v;
                }
            }
        }


        EmptyExpression::new ()
    }
    
    
}
