mod ymirc::semantic::validator::symbol::template;

import ymirc::semantic::validator::visitor;
import ymirc::semantic::validator::symbol::mapper;
import ymirc::semantic::validator::errors;
import ymirc::semantic::symbol::template;
import ymirc::syntax::declaration::protection;
import ymirc::syntax::expression::_;
import ymirc::syntax::declaration::_;

import ymirc::syntax::keys;
import ymirc::semantic::generator::_;
import ymirc::errors::_;
import ymirc::utils::format;
import ymirc::lexing::word;

import std::collection::vec;
import std::io, std::fs::path;

/**
 * The template validator is the template responsible for template symbol validation
 */
pub class TemplateValidator {

    /**
     * Create a new empty validator
     */
    pub self () {}

    /**
     * ================================================================================
     * ================================================================================
     * =========================             CALL             =========================
     * ================================================================================
     * ================================================================================
     */
    
    /**
     * Validate a template call that creates a value (function for example, or aka, etc.)
     * @params: 
     *    - context: the context of the validation
     *    - loc: the location of the call
     *    - left: the value that is template called
     *    - rights: the template arguments passed to the template
     * @returns: 
     *    - .0: the value
     *    - .1: the score of the call
     * @throws:
     *    - &ErrorMsg: if the call is impossible (for example left is not a valid template)    
     */
    pub def validateCallValue (self, dmut context : &Validator, loc : &Word, left : &Value, rights : [&Generator])-> (&Value, u32)
        throws &ErrorMsg
    {
        match left {
            x : &TemplateRefValue => {
                return self.validateCallTemplateRefValue (alias context, loc, x, rights);
            }
            _ => {
                throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_TEMPLATE_CALL, left, rights));
            }
        }
    }


    /**
     * Validate a template call that creates a value
     * @params: 
     *    - context: the context of the validation
     *    - loc: the location of the call
     *    - left: the value that is template called
     *    - rights: the template arguments passed to the template
     * @returns: 
     *    - .0: the value
     *    - .1: the score of the call
     * @throws:
     *    - &ErrorMsg: if the call is impossible
     */
    pub def validateCallTemplateRefValue (self, dmut context : &Validator, _ : &Word, left : &TemplateRefValue, rights : [&Generator])-> (&Value, u32)
        throws &ErrorMsg
    {
        let templateParams = left.getSymbol ().getContent ().getParameters ();
        let (mapper, consumed) = self.validateFromExplicit (alias context, templateParams, rights);

        if (!mapper.isSucceed ()) __pragma!panic ();
        if (consumed < rights.len) {
            throw ErrorMsg::fatal (rights[consumed].getLoc (), format (ValidateErrorMessage::TEMPLATE_REST, rights[consumed .. $]));
        } else {
            // Apply mapper on template
            __pragma!panic ();
        }        
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================           EXPLICIT           =========================
     * ================================================================================
     * ================================================================================
     */
    
    /**
     * Validate a template explicit specialization
     * @params: 
     *    - context: the context of the validation
     *    - params: the template parameters
     *    - values: the list of compile time knwon values passed to the template     
     * @returns: 
     *     - .0: a template mapper containing the template specialization
     *     - .1: the number of values that were consumed during the specialization
     * @throws: 
     *    - &ErrorMsg: if the specialization is impossible
     */
    pub def validateFromExplicit (self, dmut context : &Validator, params : [&Expression], values : [&Generator])-> (&TemplateMapper, usize)
        throws &ErrorMsg
    {
        let mut consumed = 0us;
        let dmut globalMapper = TemplateMapper::new ();
        let mut syntTemplate = params;
        
        while (consumed < values.len && syntTemplate.len != 0us) {
            // Create a slice on template arguments that have not been used yet
            // Template arguments are used in the order they are written, but sometimes several at a time
            let currentElems = values[consumed .. $];

            // Create a slice on the template parameters that are not directly referenced
            // Only the first template parameter is explicitly set, but maybe it will also set other parameters
            let rest = syntTemplate[1us .. $]; 

            {
                // Perform the explicit template validation, with the given template parameters, and call arguments
                let (mapper, localConsumed) = self.validateParamTemplateFromExplicit (alias context, rest, syntTemplate[0], currentElems);

                globalMapper:.merge (mapper);
                consumed += localConsumed;
                syntTemplate = self.replaceSyntaxTempl (syntTemplate, globalMapper);
            } catch {
                err : &ErrorMsg => { // TODO partial resolution note
                    throw err; 
                }
            }
        }
        
        (globalMapper, consumed)
    }

    /**
     * Validate a template parameter from an explicit call
     * @params: 
     *    - context: the context of the validation
     *    - syntTemplate: the template parameters
     *    - current: the template parameter to validate
     *    - values: the values passed to the template call
     * @returns:
     *    - .0: the mapper containing the template specialisation
     *    - .1: the number of values that were consumed
     * @throws:
     *    - &ErrorMsg: if the specialization is impossible
     */
    pub def validateParamTemplateFromExplicit (self, dmut context : &Validator, syntaxTemplate : [&Expression], current : &Expression, values : [&Generator])-> (&TemplateMapper, usize)
        throws &ErrorMsg
    {
        println(format ("% % %", syntaxTemplate, current, values));
        context;
        syntaxTemplate;
        current;
        values;
        __pragma!fake_throw (&ErrorMsg);
        __pragma!panic ();
    }    


    /**
     * ================================================================================
     * ================================================================================
     * =========================            COMMON            =========================
     * ================================================================================
     * ================================================================================
     */


    /**
     * Create a new template parameter list from an old list and a pre template specialization
     * @params: 
     *    - syntaxTemplate: the old template parameters
     *    - mapper: the template specialization
     * @returns: The transformed list
     * @throws:
     *     - &ErrorMsg: if the transformation is impossible (?)    
     */
    pub def replaceSyntaxTempl (self, syntaxTemplate : [&Expression], mapper : &TemplateMapper)-> [&Expression]
        throws &ErrorMsg
    {
        syntaxTemplate;
        mapper;
        __pragma!fake_throw (&ErrorMsg);
        __pragma!panic ();
    }
    
    
}
