mod ymirc::semantic::validator::symbol::template;

import ymirc::semantic::validator::visitor;
import ymirc::semantic::validator::symbol::mapper;
import ymirc::semantic::validator::errors;
import ymirc::semantic::symbol::template;
import ymirc::syntax::declaration::protection;
import ymirc::syntax::expression::_;
import ymirc::syntax::declaration::_;

import ymirc::syntax::keys;
import ymirc::semantic::generator::_;
import ymirc::errors::_;
import ymirc::utils::format;
import ymirc::lexing::word;

import std::collection::vec;
import std::io, std::fs::path;

/**
 * The template validator is the template responsible for template symbol validation
 */
pub class TemplateValidator {

    /**
     * Create a new empty validator
     */
    pub self () {}

    /**
     * Validate a template call that creates a value (function for example, or aka, etc.)
     * @params: 
     *    - context: the context of the validation
     *    - loc: the location of the call
     *    - left: the value that is template called
     *    - rights: the template arguments passed to the template
     * @returns: 
     *    - .0: the value
     *    - .1: the score of the call
     * @throws:
     *    - &ErrorMsg: if the call is impossible (for example left is not a valid template)    
     */
    pub def validateCallValue (self, dmut context : &Validator, loc : &Word, left : &Value, rights : [&Generator])-> (&Value, u32)
        throws &ErrorMsg
    {
        match left {
            x : &TemplateRefValue => {
                return self.validateCallTemplateRefValue (alias context, loc, x, rights);
            }
            _ => {
                throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::UNDEFINED_TEMPLATE_CALL, left, rights));
            }
        }
    }


    /**
     * Validate a template call that creates a value
     * @params: 
     *    - context: the context of the validation
     *    - loc: the location of the call
     *    - left: the value that is template called
     *    - rights: the template arguments passed to the template
     * @returns: 
     *    - .0: the value
     *    - .1: the score of the call
     * @throws:
     *    - &ErrorMsg: if the call is impossible
     */
    pub def validateCallTemplateRefValue (self, dmut context : &Validator, _ : &Word, left : &TemplateRefValue, rights : [&Generator])-> (&Value, u32)
        throws &ErrorMsg
    {
        let mut consumed = 0us;
        let mut globalMapper = TemplateMapper::new ();
        let templateParams = left.getSymbol ().getContent ().getParameters ();
        {
            let (locMapper, consumed_) = self.validateFromExplicit (alias context, templateParams, rights);
            globalMapper = locMapper;
            consumed = consumed_;
        } catch {
            err : &ErrorMsg => { // TODO partial resolution note
                throw err;
            }
        }

        if (!globalMapper.isSucceed ()) __pragma!panic ();
        if (consumed < rights.len) {
            throw ErrorMsg::fatal (rights[consumed].getLoc (), format (ValidateErrorMessage::TEMPLATE_REST, rights[consumed .. $]));
        } else {
            // Apply mapper on template
            __pragma!panic ();
        }        
    }

    /**
     * Validate a template explicit specialization
     * @params: 
     *    - context: the context of the validation
     *    - params: the template parameters
     *    - values: the list of compile time knwon values passed to the template     
     * @returns: 
     *     - .0: a template mapper containing the template specialization
     *     - .1: the number of values that were consumed during the specialization
     * @throws: 
     *    - &ErrorMsg: if the specialization is impossible
     */
    pub def validateFromExplicit (self, dmut context : &Validator, params : [&Expression], values : [&Generator])-> (&TemplateMapper, usize)
        throws &ErrorMsg
    {
        context;
        println (format ("%", params));
        println (format ("%", values));
        __pragma!fake_throw (&ErrorMsg);
        __pragma!panic ();
    }
    

}
