mod ymirc::semantic::validator::symbol::module;

import ymirc::semantic::validator::visitor;
import ymirc::semantic::validator::errors;
import ymirc::semantic::declarator::errors;
import ymirc::semantic::symbol::module;
import ymirc::semantic::symbol::base;


import ymirc::syntax::declaration::protection;
import ymirc::syntax::declaration::use_;
import ymirc::syntax::expression::_;
import ymirc::syntax::keys;
import ymirc::lexing::word;


import ymirc::errors::_;
import ymirc::utils::format;

import std::fs::_;
import std::io;
import std::collection::vec;

/**
 * The module validator is the class responsible for module symbol validation
 */
pub class ModuleValidator {

    /**
     * Create a new empty validator
     */
    pub self () {}


    /**
     * Validate a module
     * @params: 
     *   - context: the context of the current validation 
     *   - sym: the symbol to validate
     */
    pub fn validate (self, dmut context : &Validator, dmut sym : &ModuleSymbol)
        throws &ErrorMsg
    {
        let dmut errors = Vec!{&ErrorMsg}::new ();
        
        context:.pushReferent (alias sym);
        if (!sym.isExtern ()) {
            let uses = sym.getAllUseDecls ();
            for i in 0us .. uses.len {
                {
                    self.validate (alias context, uses [i]);
                } catch {
                    err : &ErrorMsg => { errors:.push (err); }
                }
            }

            if (errors.len () == 0us) {
                let dmut inner = sym:.getAllLocalSymbols (protection-> Protection::PRIVATE);
                for i in 0us .. inner.len {
                    {
                        context:.validate (alias inner [i]);
                    } catch {
                        err : &ErrorMsg => { errors:.push (err); }
                    }
                }
            }
        }        
        context:.popReferent ();
        
        if (errors.len () != 0us) {
            throw ErrorMsg::list (errors[]);
        }
    }

    /**
     * Validate a use symbol in the current module
     * */
    pub fn validate (self, dmut context : &Validator, use_ : &UseDecl)
        throws &ErrorMsg
    {
        let dmut parent = alias context:.getReferent ();

        let useP = use_.getModulePath ();
        let p = self.toPath (useP);

        let mut root = context:.getDeclarator ():.getGlobal (p.root (), parent); // absolute access to the root of the path

        if (root.len == 0us) { // root of the path does not exist
            // this is an absolute access, thus an absolute error, thus absolute error has to be thrown
            throw context:.getDeclarator ().createGlobalAccessError (self.getPathIndexLoc (useP, 0us), p.root (), parent);
        }

        let mut current = parent, mut all = false;
        let parts = p.parts ();
        for i in 1us .. parts.len {
            let mut found = false;
            if (i == parts.len - 1us && parts [i] == Keys::UNDER) {
                let dmut subMods = Vec!{&Symbol}::new ();
                for r in root match r {
                    m : &ModuleSymbol => {
                        let loc = context:.getDeclarator ().getAllLocalFromContext (parent, m);
                        for s in loc { subMods:.push (s); }
                    }
                }

                root = subMods[];
                all = true;
            } else {
                for r in root match r {
                    m : &ModuleSymbol => { // there can be only one module with a given name in another module, otherwise error would have been thrown during module declaration
                        root = context:.getDeclarator ().getLocalFromContext (parts [i], parent, m); // relative access, while ensuring protection access
                        if (root.len == 0us) { // no module named parts[i] in current module
                            let errLoc = self.getPathIndexLoc (useP, i);
                            throw ErrorMsg::fatal (errLoc, format (DeclareErrorMessage::NO_MODULE_NAMED, parts [i], m.getPath ().toStr (sep-> "::"s8)),
                                                   notes-> context:.getDeclarator ().createLocalAccessError (errLoc, parts[i], m, parent));
                        }

                        found = true;
                        current = m;
                    }
                }

                // A symbol was found, but it was not a module
                if (!found) {
                    throw ErrorMsg::fatal (self.getPathIndexLoc (useP, i - 1us), format (DeclareErrorMessage::NO_MODULE_NAMED, parts[i - 1us], current.getPath ().toStr (sep-> "::"s8)));
                }
            }
        }

        for r in root match r {
            m : &ModuleSymbol => { // use all the module found at the end of the path
                if (parent is m) {
                    if (!all) {
                        throw ErrorMsg::warn (self.getPathIndexLoc (useP, parts.len - 1us), format (DeclareErrorMessage::SELF_USE, m.getPath ().toStr (sep-> "::"s8)));
                    }
                } else {
                    parent:.useModule (m.getPath (), alias context:.getDeclarator ():.getMutableSymbol (m));
                    all = true; // set all to true, because at least one module was found
                }
            }
        }

        if (!all) { // all is true if at least one module was used, or '_' was found, meaning use all sub modules from this path
            // if not all, then symbol was found in current, but it was not a module
            throw ErrorMsg::fatal (self.getPathIndexLoc (useP, parts.len - 1us),
                                   format (DeclareErrorMessage::NO_MODULE_NAMED, parts[parts.len - 1us], current.getPath ().toStr (sep-> "::"s8)));
        }
    }

    /**
     * Transform an expression into a path
     * @returns: a path
     * @panic
     */
    fn toPath (self, expr : &Expression)-> &Path {
        match expr {
            p : &PathExpr => {
                p.toStdPath ()
            }
            _ => {
                Path::new (expr.getLoc ().str ())
            }
        }
    }

    /**
     * @returns: the location of the 'index' path element in the path
     * */
    fn getPathIndexLoc (self, expr : &Expression, index : usize)-> &Word {
        match expr {
            p : &PathExpr => {
                let locs = p.getLocs ();
                if (locs.len < index) { expr.getLoc () }
                else { locs [index] }
            }
            _ => {
                expr.getLoc ()
            }
        }
    }


}
