in module;

use ymirc::global::state;
use ymirc::semantic::validator::{visitor, errors};
use ymirc::semantic::declarator::errors;
use ymirc::semantic::{symbol, symbol::{module, lazy_module, path}};

use ymirc::syntax::{expression::_, declaration::_};
use ymirc::syntax::keys;
use ymirc::lexing::word;
use ymirc::errors::_;
use ymirc::utils::{format, log};

use std::{stream, io, fs::path};

use ymirc::semantic::generator::type::{_,
                                       custom::_,
                                       native::{_, scalar::_, compound::_},
                                       temporary::_};

use ymirc::semantic::generator::value::{_,
                                        construct::{_, delegate::_},
                                        literal::_,
                                        memory::_,
                                        operator::{_, binary::_, call::_, fields::_, map::_, slice::_, unary::_},
                                        operator::map::iteration::_,
                                        prototypes::_,
                                        scope::_,
                                        syntax::_,
                                        template::_};

/**
 * The module validator is the class responsible for module symbol validation
 */
pub record ModuleValidator {

    /**
     * Create a new empty validator
     */
    pub self () {}


    /**
     * Validate a module
     * @params: 
     *   - context: the context of the current validation 
     *   - sym: the symbol to validate
     */
    pub fn validate (self, dmut context : &Validator, dmut sym : &ModuleSymbol)
        throws ErrorMsg
    {
        if (sym.isExtern ()) { return ; }

        // Module compilation filter to compile only some modules
        if !self.checkPassFilter (alias context, sym.getLoc ()) {
            if self.isParentOfFilter (sym.getPath ()) {
                self.validateOnlyChilds (alias context, alias sym);
            }
        }
        else {
            self.validateFull (alias context, alias sym);
        }
    }

    /**
     * Validate all the symbols in the module
     * */
    fn validateFull (self, dmut context : &Validator, dmut sym : &ModuleSymbol)
        throws ErrorMsg
    {
        if (sym.getPath ().parts () != []) {
            logging::info ("Validate module %", sym.getPath ());
        }

        let mut errors : [&ErrorMsg] = [];
        context:.pushReferent (alias sym);
        let dmut inner = sym:.getAllLocalSymbols (protection-> Protection::PRIVATE);
        for i in 0us .. inner.len {
            {
                context:.validate (alias inner [i]);
            } catch {
                err : &ErrorMsg => { errors ~= [err]; }
            }
        }

        let dmut tests = sym:.getUnitTests ();
        for i in 0us .. tests.len {
            {
                context:.getFunctionValidator ().validateTest (alias context, alias tests [i], i);
            } catch {
                err : &ErrorMsg => { errors ~= [err]; }
            }
        }

        if (sym.getPath ().parts () != []) {
            context:.insertCompiledModule (Path (sym.getLoc ().filename).removePrefix (context:.getDeclarator ().getPackageDir ()).stripExtension ());
        }

        context:.popReferent ();

        if (errors.len != 0us) {
            throw copy ErrorMsg::list (errors);
        }
    }

    /**
     * Validate only the sub modules that are not filtered out
     * */
    fn validateOnlyChilds (self, dmut context : &Validator, dmut sym : &ModuleSymbol)
        throws ErrorMsg
    {
        let mut errors : [&ErrorMsg] = [];
        context:.pushReferent (alias sym);
        let dmut inner = sym:.getAllLocalSymbols (protection-> Protection::PRIVATE);
        for i in 0us .. inner.len {
            {
                match alias inner [i] {
                    dmut m : &ModuleSymbol => {
                        if self.checkPassFilter (alias context, m.getLoc ()) || self.isParentOfFilter (m.getPath ()) {
                            self.validate (alias context, alias m);
                        }
                    }
                    dmut l : &LazyModuleSymbol => {
                        if self.checkPassFilter (alias context, l.getLoc ()) || self.isParentOfFilter (l.getPath ()) {
                            context:.validate (alias l);
                        }
                    }
                }
            } catch {
                err : &ErrorMsg => { errors ~= [err]; }
            }
        }

        context:.popReferent ();

        if (errors.len != 0us) {
            throw copy ErrorMsg::list (errors);
        }
    }


    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          FILTERING          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Check wether the module path is to be compiled by the filter
     * */
    fn checkPassFilter (self, dmut context : &Validator, loc : &Word)-> bool {
        // No module filters, thus we compile everything
        if (!state::instance ().hasModuleFilters ()) {
            return true;
        }

        let absLoc = Path (loc.filename).stripExtension ();
        if !context:.getDeclarator ().getPackageDir ().isPrefix (absLoc) { // I don't see how
            return false;
        }

        let relLoc = absLoc.removePrefix (context:.getDeclarator ().getPackageDir ());
        for p in state::instance ().getModuleFilters () {
            if p == relLoc { // in the file
                return true;
            }
        }

        return false;
    }

    /**
     * Check wether the module being compiled is the parent of a sub module in module filters
     * */
    fn isParentOfFilter (self, symPath : &SymbolPath)-> bool {
        let mut path = symPath.asStdPath ();

        for p in state::instance ().getModuleFilters () {
            if path.isPrefix (p) return true;
        }

        false
    }

}
