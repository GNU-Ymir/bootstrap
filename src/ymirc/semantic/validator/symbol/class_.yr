mod ymirc::semantic::validator::symbol::class_;

import ymirc::semantic::validator::visitor;
import ymirc::semantic::validator::errors;
import ymirc::semantic::declarator::errors;
import ymirc::semantic::symbol::_;
import ymirc::syntax::declaration::protection;
import ymirc::syntax::expression::_;
import ymirc::syntax::declaration::_;

import ymirc::syntax::keys;
import ymirc::semantic::generator::_;
import ymirc::errors::_;
import ymirc::utils::format;
import ymirc::lexing::word;
import ymirc::global::core_;

import std::collection::vec;
import std::collection::map;
import std::io, std::fs::path;
import std::collection::set;

import std::time::_;

/**
 * The class validator is the class responsible for class symbol validation
 */
pub class ClassValidator {    

    /// The list of class symbols currently in validation to avoid infinite recursion,
    /// and validating multiple times the same symbol
    let dmut _validation = HashSet!{&Symbol}::new ();
        
    /**
     * Create a new empty validator
     */
    pub self () {}

    /**
     * Validate an class symbol
     * @info: 
     * @params: 
     *    - context: the context of the validation
     *    - sym: the symbol to validate
     *    - inModule: iif true, this validation is "in module", "out module" otherwise meaning that the class was found inside a value (e.g. varref), and a full validation is not necessary
     * @throws:
     *    - &ErrorMsg, if the class is malformed
     */
    pub fn validate (mut self, dmut context : &Validator, dmut sym : &ClassSymbol, inModule : bool)-> &ClassRefType
        throws &ErrorMsg
    {
        if (!self.checkValidation (sym)) {
            self:.validateClassContent (alias context, alias sym); // This cannot throw (cf. the function def)
        }

        match sym.getClassRef () {
            r : &ClassRefType => {
                if (inModule) { // if we are "in module" we need to validate the symbols of the class (addMethods)
                    self:.finalizeClassValidation (alias context, alias sym, r);
                }
                
                return r;
            }
            err : &ErrorGenerator => {

                // The class was validated by self.validateClassContent, but it failed so the generator is an error
                // we simply throw it, unfortunately it will leads to printing the same error multiple times, but I don't see any way to avoid that efficiently (while making sure the error is at least printed one time)
                // Maybe add a uniq identifier to errors, and perform the verification directly in the error printing part
                throw err.getErrorMessage ();
            }
            _ => { 
                __pragma!panic ();
            }
        };
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================          FINALIZER           =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Finalize the validation of the methods of the class
     * @params:
     *    - context: the context of the validation
     *    - sym: the symbol to finalize
     *    - clRef: the type of the class to validate
     * @throws:
     *    - &ErrorMsg: if there was an error in the validation
     */
    pub fn finalizeClassValidation (mut self, dmut context : &Validator, dmut sym : &ClassSymbol, clRef : &ClassRefType)
        throws &ErrorMsg
    {
        let dmut errors = Vec!{&ErrorMsg}::new ();
        let dmut addMethods = sym:.getAddMethods ();
        for i in 0us .. addMethods.len {
            {
                match ref (addMethods[i]) {
                    dmut funcSym : &FunctionSymbol => { // Simply validate all the new symbols of the class
                        context:.getFunctionValidator ():.validateMethod (alias context, alias funcSym, clRef);
                    }
                    dmut ctorSym : &ConstructorSymbol => { // Validate the constructor symbol
                        context:.getFunctionValidator ():.validateConstructor (alias context, alias ctorSym, clRef);
                    }
                    dmut dtorSym : &DestructorSymbol => {
                        context:.getFunctionValidator ():.validateDestructor (alias context, alias dtorSym, clRef);
                    }
                    _ => __pragma!panic (); // we inserted a symbol that is not a function in the addMethods ??
                }
            } catch {
                e : &ErrorMsg => {
                    errors:.push (e);
                }
            }
        }

        if (errors.len () != 0us) { // error validating the methods
            let error = ErrorMsg::fatal (sym.getLoc (), ValidateErrorMessage::VALIDATING, notes-> errors[]);
            context:.insertMissingGenerator (error);
            if (sym.isTemplate ()) {
                sym:.setClassRef (ErrorGenerator::new (sym.getLoc (), error));
            }

            throw error;
        }

        context:.insertGenerator (alias sym, clRef);
    }    
    
    /*!
     * ================================================================================
     * ================================================================================
     * =========================       INNER VALIDATION       =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate the content of a class (fields, methods, etc.)
     * @warning: does not throw an error, but write it in the generator of the class if there was any.
     * @params: 
     *   - context: the context of the validation
     *   - sym: the symbol to validate
     *   - inModule: if true, then the methods of the class are validated and inserted in the generators of the context
     */
    fn validateClassContent (mut self, dmut context : &Validator, dmut sym : &ClassSymbol) {
        
        // The validation of the class is not finished
        // a recursive reference to itself in ancestor will lead to infinite loop, we want to avoid that
        sym:.setClassRef (ErrorGenerator::new (sym.getLoc (), ErrorMsg::fatal (sym.getLoc (), ValidateErrorMessage::FORWARD_REFERENCE_TYPE)));

        // We add the symbol to avoid infinite loops
        self._validation:.insert (sym);
        
        {            
            // First we need to validate the ancestor of the class, to generate the vtable, the child class vtable being an override of the one of the ancestor
            let ancestor = self.validateAncestor (alias context, alias sym);
            
            // Now that we have the ancestor, the class is a bit more usable for further validation
            sym:.setClassRef (ClassRefType::new (sym.getLoc (), sym, ancestor));        

            // Validate the static assertions of the class definition (@warning: this is only performed if the validation is a root validation-> self._validation.len () == 1us, to avoid too deep and unreadable errors)
            self.validateCtes (alias context, alias sym);
            
            // Validate the vtable (without validating the method bodies, just the prototypes)
            self.validateVtable (alias context, alias sym, ancestor);

            // Validate the fields of the class
            self.validateFields (alias context, alias sym, ancestor);

            // Validate the ctors prototypes of the class
            self.validateConstructors (alias context, alias sym);

            // Validate the typeinfo of the class
            self.validateTypeInfo (alias context, alias sym);

        } catch {
            err : &ErrorMsg => {
                // If there is an error in the validation, then write it in the type validation
                // Then each time a validation is tried, the same error is sent without needing a new validation
                sym:.setClassRef (ErrorGenerator::new (sym.getLoc (), ErrorMsg::fatal (sym.getLoc (), ValidateErrorMessage::VALIDATING, notes-> [err])));
            }
        }
        
        self._validation:.remove (sym);    
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================           ANCESTOR           =========================
     * ================================================================================
     * ================================================================================
     */
    
    /**
     * Validate the ancestor of the class
     * @params: 
     *    - context: the context of the validation
     *    - sym: the class symbol whose ancestor will be validated
     * @returns: the ancestor type (NoneType, if the class does not have an ancestor)
     * @throws:
     *   - &ErrorMsg: if the validation failed
     */
    fn validateAncestor (self, dmut context : &Validator, dmut sym : &ClassSymbol)-> &Type
        throws &ErrorMsg
    {
        match sym.getAncestor () {
            EmptyExpression () => { NONE_TYPE } // No ancestor specified
            ancestor : &Expression => {                                
                let type = context:.validateType (ancestor);                
                match type {
                    cr : &ClassRefType => { // The ancestor class must be a class, obviously
                        if (cr.getSymbol ().isFinal ()) { // and it cannot be final
                            throw ErrorMsg::fatal (ancestor.getLoc (), format (ValidateErrorMessage::INHERIT_FINAL_CLASS, cr));
                        }
                        
                        cr // if it is a class ref, and not final then no problem, it can be an ancestor
                    }
                    x : _ => { // This is not a class, cannot inherit non class types
                        throw ErrorMsg::fatal (ancestor.getLoc (), format (ValidateErrorMessage::INHERIT_NO_CLASS, x));
                    }
                }
            }
        }
    }
    
    /*!
     * ================================================================================
     * ================================================================================
     * =========================             CTES             =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate the static assertion of a class symbol
     * @warning: 
     * ----------------
     * the validation is only performed on root validation (meaning iif self._validation.len () == 1us)   
     * In order to avoid too deep errors, and complex error handling
     * ----------------
     * @params: 
     *    - context: the context of the validation
     *    - sym: the symbol to validate
     * @throws:
     *   - &ErrorMsg: if some assertion where invalid, or not true
     */
    fn validateCtes (self, dmut context : &Validator, dmut sym : &ClassSymbol)
        throws &ErrorMsg
    {
        self.validateCondBlocks (alias context, alias sym);
        if (self._validation.len () != 1us) return {}
        let dmut errors = Vec!{&ErrorMsg}::new ();
        
        if (sym.getAssertions ().len != 0us) {
            context:.pushReferent (alias sym); // The assertion are located in the class context
            context:.enterForeign (isFnBody-> false); // There are not inside function

            for it in sym.getAssertions () { 
                context:.validateCteValue (it); // validate the assertion
            } catch { 
                err : &ErrorMsg => errors:.push (err);
            }          
            
            context:.popReferent ();
            context:.exitForeign ();
        }

        // Some assertion failed
        if (errors.len () != 0us) throw ErrorMsg::list (errors[]);
    }
    
    /**
     * Validate the list of conditional block in the class
     * @params: 
     *    - context: the context of the validation
     *    - sym: the class to validate
     * @throws:
     *    - &ErrorMsg: if the validation fails
     */
    fn validateCondBlocks (self, dmut context : &Validator, dmut sym : &ClassSymbol)
        throws &ErrorMsg
    {
        let dmut errors = Vec!{&ErrorMsg}::new ();
        if (sym.getCondBlocks ().len != 0us) {
            context:.pushReferent (alias sym); // The assertion are located in the class context
            context:.enterForeign (isFnBody-> false); // There are not inside function

            for it in sym.getCondBlocks () { 
                self.validateCondBlock (alias context, it, alias sym);
            } catch { 
                err : &ErrorMsg => errors:.push (err);
            }          
            
            context:.popReferent ();
            context:.exitForeign ();
        }

        // Some cond block validation failed
        if (errors.len () != 0us) throw ErrorMsg::list (errors[]);
    }

    /**
     * Validate a declaration from a conditional block
     * @params: 
     *    - context: the context of the validation
     *    - decl: the declaration to validate
     *    - sym: the symbol of the class being validated
     * @throws:
     *    - &ErrorMsg: if the validation fails
     */
    pub fn validateCondBlock (self, dmut context : &Validator, decl : &Declaration, dmut sym : &ClassSymbol)
        throws &ErrorMsg
    {
        match decl {
            c : &CondBlockDecl => {
                let val = context:.validateValue (c.getTest ());
                let b = context:.getCompileTimeInterpreter ().computeBool (val);
                if (b) {
                    for j in c.getDeclarations () {
                        self.validateCondBlock (alias context, j, alias sym);
                    }
                } else {
                    self.validateCondBlock (alias context, c.getElse (), alias sym);
                }                                
            }
            _ => {
                let start = instant::now ();
                context:.getDeclarator ():.declareInnerClass (decl, alias sym, protection-> Protection::PROTECTED);
                context:.getDeclarator ():.finalizeDeclaration (alias sym);
                let end = instant::now ();
                context:.removeTime (end - start);
            }
        }
    }
    
           
    /*!
     * ================================================================================
     * ================================================================================
     * =========================            FIELDS            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate the fields of a class symbol, and populate the class definition
     * @params: 
     *   - context: the context of the validation
     *   - sym: the symbol to validate
     *   - ancestor: the ancestor type of the class
     *   - inModule: true if the validation of the class is "in module"
     * @throws:
     *   - &ErrorMsg: if there is an error in the validation of the fields
     */
    fn validateFields (self, dmut context : &Validator, dmut sym : &ClassSymbol, ancestor : &Type)
        throws &ErrorMsg
    {                
        let localFields = self.validateLocalFields (alias context, alias sym); // Validate the fields declared in the class def
        let allFields = match ancestor {
            cl : &ClassRefType => {
                let ancestorFields = cl.getFields (); // Get the fields declared in the ancestor class
                self.verifyFieldCollisions (alias context, ancestorFields, localFields); // Verify that there is no collistion between ancestor fields and local fields
                    
                ancestorFields ~ localFields            
            }
            _ => { localFields }
        };

        // Update the class type info definition in the symbol, so it has access to the fields
        match sym.getClassRef () {
            oldRef : &ClassRefType => {
                let dmut clRef = ClassRefType::withField (oldRef, allFields, localFields);
                sym:.setClassRef (alias clRef);
            }
            _ => __pragma!panic (); // The function was called where exactly ?!! verify that there is previous classref in the symbol
        }
    }

    /**
     * Validate the fields that are declared in the class definition
     * @params : 
     *    - context: the context of the validation
     *    - sym: the symbol whose field we will validate
     * @returns: The list of validated fields
     * @throws:
     *    - &ErrorMsg: if there was an error in one or more field validation
     */
    fn validateLocalFields (self, dmut context : &Validator, dmut sym : &ClassSymbol)-> [&Value]
        throws &ErrorMsg
    {
        context:.pushReferent (alias sym); // Fields are declared inside the class
        context:.enterForeign (isFnBody-> false); // A new foreign, we don't wan't to pollute current context
        context:.enterBlock (); // A block, we will add variable definitions

        let dmut errors = Vec!{&ErrorMsg}::new ();
        let dmut fields = Vec!{&Value}::new ();
        let dmut names = HashMap!{[c8], &Word}::new ();

        for it in sym.getFields () {
            match it {
                f : &VarDeclExpr => {
                    {
                        // Fields are just like variable decls
                        let field = context:.getValueValidator ().validateVarDecl (alias context, f, needInitValue-> false);
                        
                        // There are two reasons for clearing local space
                        // 1) we don't want warnings about unused fields
                        // 2) fields cannot refer to other fields in the value definition (e.g. "let a = 12, b = a;" is invalid)
                        context:.clearLocalScope ();

                        // We need to verify shadow ourselves, since we removed all locals at each iteration
                        self.verifyShadow (alias names, field);

                        // We add the validated field
                        fields:.push (field);
                    } catch {
                        err : &ErrorMsg => { errors:.push (err); }
                    }
                }
                _ => { // Something strange was declared as a field in the class definition
                    __pragma!panic ();
                }
            };
        }

        context:.quitBlock (warnUnused-> false); // We entered a block at the beginning of the function
        context:.exitForeign (); // We entered a foreign
        context:.popReferent (); // And we pushed a referent

        if (errors.len () != 0us) throw ErrorMsg::list (errors[]);

        fields [] // returning the list of fields
    }
    
    /**
     * Verify that there is no collision between fields declared in ancestor class, and fields declared in local class
     * @params:
     *   - context: the context of the validation 
     *   - ancestorFields: the list of fields declared in ancestor classes
     *   - localFields: the list of fields declared in local class
     * @throws:
     *   - &ErrorMsg: if there is a collision     
     */
    fn verifyFieldCollisions (self, dmut _ : &Validator, ancestorFields : [&Value], localFields : [&Value])
        throws &ErrorMsg
    {
        let dmut errors = Vec!{&ErrorMsg}::new ();

        // These loops are pretty self explanatory, we just traverse the fields and verify that there is no common names in local and ancestor fields
        for lt in localFields {
            for at in ancestorFields {
                match (lt, at) {
                    (lvar : &VarDeclValue, avar : &VarDeclValue) => {
                        if (lvar.getLoc ().str () == avar.getLoc ().str ()) {
                            errors:.push (ErrorMsg::fatal (lvar.getLoc (), // Shadowing error
                                                           format (ValidateErrorMessage::SHADOWING_DECL,
                                                                   lvar.getLoc ().str ()),
                                                           notes-> [ErrorMsg::note (avar.getLoc (), ""s8)]));
                        }
                    }
                }
            }
        }

        if (errors.len () != 0us) throw ErrorMsg::list (errors[]); // There are collisions
    }

    /**
     * Verify that there is no shadowing in field declarations
     * @params:
     *    - dones: the list of already declared fields
     *    - field: the newly declared field
     * @throws:
     *    - &ErrorMsg: if there is a shadowing problem
     * */
    fn verifyShadow (self, dmut dones : &HashMap!{[c8], &Word}, field : &Value)
        throws &ErrorMsg
    {
        match field {
            v : &VarDeclValue => {
                match dones.find (v.getLoc ().str ()) {
                    Ok (l : &Word) => {
                        throw ErrorMsg::fatal (v.getLoc (), format (ValidateErrorMessage::SHADOWING_DECL, v.getLoc ().str ()),
                                               notes-> [ErrorMsg::note (l, ValidateErrorMessage::FIRST_DEFINED)]);
                    }
                }

                dones:.insert (v.getLoc ().str (), v.getLoc ());
            }
            _ => { // only vardecl are defined as fields
                __pragma!panic ();
            }
        }
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================            CTORS             =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate the constructors of a class symbol
     * @assume: the vtable and fields of the class are already validated
     * @params: 
     *     - context: the context of the validation
     *     - sym: the class sybmol to validate
     *     - ancestor: the ancestor of the class symbol
     * @throws:
     *     - &ErrorMsg: if there is an error in the validation
     */
    fn validateConstructors (self, dmut context : &Validator, dmut sym : &ClassSymbol)
        throws &ErrorMsg
    {
        match sym.getClassRef () {
            oldRef : &ClassRefType => {
                let dmut errors = Vec!{&ErrorMsg}::new ();
                let dmut ctors = Vec!{&CtorPrototypeValue}::new (); // list of ctor prototypes
                let dmut ctorProts = Vec!{MethodProtection}::new (); // Protection of constructors

                let dmut templateCtors = Vec!{&TemplateRefCtorValue}::new ();
                let dmut templateCtorProts = Vec!{MethodProtection}::new ();

                for it in sym.getAllLocalSymbols (protection-> Protection::PRIVATE) { // traverse all contructor and validate their prototypes
                    {
                        match it {
                            ctor : &ConstructorSymbol => { // If this is a constructor we validate its constructor
                                match context:.getSymbolFromRef (ctor) {
                                    dmut mutCtor : &ConstructorSymbol => {
                                        self.validateConstructorProto (alias context, alias mutCtor, oldRef, alias ctors, alias ctorProts);
                                        sym:.insertAddMethod (alias mutCtor); // Add the symbol for finalization (if 'in module')
                                    }
                                    _ => __pragma!panic ();
                                }
                            }
                            tmp : &TemplateSymbol => {
                                match tmp.getContent ().getContent () {
                                    _ : &ConstructorDecl => {
                                        self.validateTemplateConstructorProto (alias context, tmp, oldRef, alias templateCtors, alias templateCtorProts);
                                    }
                                }
                            }
                        }
                    } catch {
                        err : &ErrorMsg => {
                            errors:.push (err);
                        }
                    }
                }

                if (errors.len () != 0us) throw ErrorMsg::list (errors[]);

                // Update the class type info definition in the symbol, so we have access to the ctors of the class
                let dmut clRef = ClassRefType::withCtors (oldRef, ctors[], ctorProts[]);
                clRef = ClassRefType::withTemplateCtors (clRef, templateCtors[], templateCtorProts[]);

                sym:.setClassRef (alias clRef); // Class validation is finished, it can be constructed now
            }
            _ => __pragma!panic (); // no supposed to be here, if we validate the ctors, we already validated vtable and fields
        }
    }


    /**
     * Validate the prototype of the constructor
     * @params:
     *    - context: the context of the validation
     *    - ctor: the constructor whose prototype to validate
     *    - clRef: the type of the class ref
     *    - ctorList: the list of already validated prototypes
     * @throws:
     *    - &ErrorMsg: if there is an error in the validation of the prototype (collision with other ctor, or an error in the types, etc..)
     * @returns:
     *    - ctorList: append the prototype of the ctor
     *    - ctorProts: append the protection of the ctor
     */
    fn validateConstructorProto (self, dmut context : &Validator, dmut ctor : &ConstructorSymbol, clRef : &ClassRefType, dmut ctorList : &Vec!{&CtorPrototypeValue}, dmut ctorProts : &Vec!{MethodProtection})
        throws &ErrorMsg
    {
        let proto = context:.getFunctionValidator ():.validateCtorPrototype (alias context, alias ctor, clRef);
        for it in ctorList {
            if proto.isSimilar (it) {
                throw ErrorMsg::fatal (proto.getLoc (), end-> it.getLoc (), format (ValidateErrorMessage::COLLIDING_METHOD_DEFINITION, proto, it));
            }
        }

        ctorList:.push (proto);
        match ctor.getProtection () {
            Protection::PRIVATE => ctorProts:.push (MethodProtection::PRV);
            Protection::PROTECTED => ctorProts:.push (MethodProtection::PROT);
            _ => ctorProts:.push (MethodProtection::PUB);
        };
    }

    /**
     * Validate a template constructor
     * @params:
     *     - context: the context of the validation
     *     - ctor: the template ctor (assuming it contains a template declaration, containing a constructor declaration)
     *     - clRef: the class ref being validated
     * @returns:
     *    - ctorList: append the prototype of the ctor
     *    - ctorProts: append the protection of the ctor
     * */
    fn validateTemplateConstructorProto (self, dmut context : &Validator, ctor : &TemplateSymbol, clRef : &ClassRefType, dmut ctorList : &Vec!{&TemplateRefCtorValue}, dmut ctorProts : &Vec!{MethodProtection}) {
        context;
        clRef;

        ctorList:.push (TemplateRefCtorValue::new (ctor.getLoc (), clRef.getSymbol (), ctor));
        match ctor.getProtection () {
            Protection::PRIVATE => ctorProts:.push (MethodProtection::PRV);
            Protection::PROTECTED => ctorProts:.push (MethodProtection::PROT);
            _ => ctorProts:.push (MethodProtection::PUB);
        };
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================            VTABLE            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate the vtable of a class and populates the class symbol definition
     * @params:
     *    - context: the context of the validation
     *    - sym: the symbol to validate
     *    - ancestor: the type of the ancestor of the class
     * @throws:
     *    - &ErrorMsg: if there is an error in the vtable validation
     */
    fn validateVtable (self, dmut context : &Validator, dmut sym : &ClassSymbol, ancestor : &Type)
        throws &ErrorMsg
    {
        match sym.getClassRef () {
            oldRef : &ClassRefType => {
                // Validate the vtable, and get the list of method prototypes, and their protections
                let (vtable, protection, implTraits, allImpls, templateMeths, templateProts) = self.validateVtable (alias context, alias sym, oldRef, ancestor);

                // Validate the destructor of the class (if any)
                // In order to be virtual (overridable and callable from child class), dtor must be defined in the vtable 
                let dtor = self.validateVtableDtor (alias context, alias sym, oldRef, ancestor);

                // Verify that all methods have a proper body
                // Only abstract class can have empty methods, because they don't generate a vtable
                let dmut notes = Vec!{&ErrorMsg}::new ();
                if (!sym.isAbstract ()) {
                    for v in vtable if v.isEmpty () {
                        notes:.push (ErrorMsg::note (v.getLoc (), format (ValidateErrorMessage::EMPTY_METHOD_NO_ABSTRACT, v, withTags-> ["withParams"s8]), oneLine-> true, withLoc-> true));
                    }

                    if (notes.len () != 0us) {
                        throw ErrorMsg::fatal (sym.getLoc (), format (ValidateErrorMessage::NON_ABSTRACT_NOT_COMPLETE, oldRef), notes-> notes[]);
                    }
                }

                // Update the class type info definition in the symbol, so it has access to the vtable
                let dmut clRef = ClassRefType::withVtable (oldRef, vtable, protection, dtor, implTraits, allImpls, templateMeths, templateProts);
                sym:.setClassRef (alias clRef);
            }
            _ => __pragma!panic (); // Mh, well no supposed to be here, verify that there is previous classref in the symbol, we need it to validate the vtable
        }
    }

    /**
     * Validate the vtable of the class declaration
     * @info: populate the addMethods in the class (the add methods are the methods that are not defined in parent class)
     * @params: 
     *    - context: the context of the validation
     *    - sym: the symbol to validate
     *    - clRef: the type of the class being validated (without vtable)
     *    - ancestor: the ancestor of the class
     * @throws: 
     *    - &ErrorMsg: if there is an error in the validation
     * @returns: 
     *    - .0: the list of methods prototype of the vtable
     *    - .1: the list of protection of the methods
     */
    fn validateVtable (self, dmut context : &Validator, dmut sym : &ClassSymbol, clRef : &ClassRefType, ancestor : &Type)-> ([&MethodPrototypeValue], [MethodProtection], [&TraitRefType], [&TraitRefType], [&TemplateRefMethodValue], [MethodProtection])
        throws &ErrorMsg
    {
        let dmut vtable = Vec!{&MethodPrototypeValue}::new ();
        let dmut prots = Vec!{MethodProtection}::new ();
        let dmut addMethods = Vec!{dmut &Symbol}::new ();
        let dmut allImpls = Vec!{&TraitRefType}::new ();
        let dmut impls = Vec!{&TraitRefType}::new ();

        let dmut templateMeths = Vec!{&TemplateRefMethodValue}::new ();
        let dmut templateProts = Vec!{MethodProtection}::new ();
        
        // Ok, this part is complex, so hang in there.

        // Retreive the vtable of the ancestor, the vtable of the current class is an update of it, and same symbols must be located at the same place
        self.retreiveAncestorVtable (ancestor, alias vtable, alias prots, alias addMethods, alias allImpls, alias templateMeths, alias templateProts);

        // Create the vector containing all the methods defined in implemented traits
        let implemented = self.retreiveImplsVtable (alias context, sym, clRef, alias vtable, alias prots, alias addMethods);
        for i in implemented { impls:.push (i._1); } // store the list of traits that were implemented by the class

        // At this point, vtable contains :
        //  1) All the methods declared in ancestor class
        //  2) All the methods declared in implemented traits
        // There is no method declared in the class (either new, over, of impl over) in the vtable
        // So we start by validating the methods that are declared outside implementations
        self.validateDirectVtable (alias context, sym, clRef, alias vtable, alias prots, alias addMethods, alias templateMeths, alias templateProts);

        // An now the methods that are declared inside implementations (overriding)
        self.validateImplsVtable (alias context, clRef, implemented, alias vtable, alias prots, alias addMethods);

        // Insert the symbol of the methods that has to be fully validated if the class is "in module"
        // These symbols are the methods that are declared inside the class (new, over or impl over)
        for i in 0us .. addMethods.len () { 
            __pragma!trusted ({
                let dmut meth = alias (alias addMethods)[i];
                match meth {
                    EmptySymbol () => {} // if it is an empty symbol, then the method was declared in ancestor or trait, and put in the class as it was (not over)
                    _ => {
                        sym:.insertAddMethod (alias meth); // The method is new or overriden
                    }
                }
            });
        }

        
        (vtable[], prots[], impls[], allImpls[] ~ impls[], templateMeths[], templateProts[])
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================       VTABLE ANCESTOR        =========================
     * ================================================================================
     * ================================================================================
     */
   
    /**
     * Retreive the vtable of the ancestor if the ancestor exists
     * @params:
     *    - ancestor: the ancestor type
     * @returns:
     *   - vtable: same as .0, but updatable
     *   - prots: almost same as .1, but updatable (and PRV is now PRV_PARENT)
     */
    fn retreiveAncestorVtable (self, ancestor : &Type, dmut vtable : &Vec!{&MethodPrototypeValue}, dmut prots : &Vec!{MethodProtection}, dmut addMethods : &Vec!{dmut &Symbol}, dmut allImpls : &Vec!{&TraitRefType}, dmut templateMeths : &Vec!{&TemplateRefMethodValue}, dmut templateProts : &Vec!{MethodProtection}) {
        match ancestor {
            clRef : &ClassRefType => { // there is an ancestor
                let ancVtable = clRef.getVtable ();
                let ancProts = clRef.getVtableProtections ();
                let ancImpls = clRef.getAllImplTraits ();
                let ancTempl = clRef.getTemplateMethods ();
                let ancTemplPr = clRef.getTemplateMethodProtections ();

                for i in ancVtable { // insert the method prototype in the vtable of the current class
                    vtable:.push (i);
                    addMethods:.push (alias EMPTY_SYMBOL);
                }

                for j in ancProts { // Insert the protection in the vtable of the current class 
                    if (j == MethodProtection::PRV) prots:.push (MethodProtection::PRV_PARENT); // private methods are not accessible in child class
                    else prots:.push (j);
                }

                for i in ancTempl { templateMeths:.push (i); }
                for i in ancTemplPr { templateProts:.push (i); }

                for ti in ancImpls { allImpls:.push (ti); }
            }
        }
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================         VTABLE IMPL          =========================
     * ================================================================================
     * ================================================================================
     */
    
    /**
     * Retreive the list of methods that are declared inside traits, and that are implemented by the class
     * @params: 
     *   - context: the context of the validation
     *   - sym: the symbol of the class being validated     
     *   - clRef: the type of the class being validated
     * @returns:
     *    - vtable: populate the vtable, or update it
     *    - vtableProt: populate the protections
     *    - addMethods: the list of methods that are either overriden or newly defined 
     *    - .0: the list of implemented traits, [(.0: the trait symbol, .1: the trait type)]
     * @throws:
     *   - &ErrorMsg: if there is an error in the validation    
     */
    fn retreiveImplsVtable (self, dmut context : &Validator, sym : &ClassSymbol, clRef : &ClassRefType, dmut vtable : &Vec!{&MethodPrototypeValue}, dmut vtableProt : &Vec!{MethodProtection}, dmut addMethods : &Vec!{dmut &Symbol})-> [(&ImplSymbol, &TraitRefType)]
        throws &ErrorMsg
    {
        let dmut implemented = Vec!{(&ImplSymbol, &TraitRefType)}::new ();
        let dmut errors = Vec!{&ErrorMsg}::new ();
        
        for it in sym.getAllLocalSymbols (protection-> Protection::PRIVATE) {
            {
                match it {
                    im : &ImplSymbol => { // If there is an implementation, then we need to validated its vtable
                        let ret = self.retreiveImplVtable (alias context, im, clRef, alias vtable, alias vtableProt, alias addMethods);
                        implemented:.push ((im, ret));
                    }
                }
            } catch {
                err : &ErrorMsg => {
                    errors:.push (err);
                }
            }
        }

        if (errors.len () != 0us) throw ErrorMsg::list (errors[]);
        
        implemented []
    }


    /**
     * Retreive the vtable of a trait implementation
     * @params: 
     *   - context: the context of the validation
     *   - im: the implementation to validated
     *   - clRef: the type of the class being validated
     * @returns:
     *    - vtable: populate the vtable, or update it
     *    - vtableProt: populate the protections
     *    - addMethods: the list of methods that are either overriden or newly defined 
     *    - .0: the trait ref type
     * @throws:
     *   - &ErrorMsg: if there is an error in the validation (for example, 'im' does not implement a trait) 
     */
    fn retreiveImplVtable (self, dmut context : &Validator, im : &ImplSymbol, clRef : &ClassRefType, dmut vtable : &Vec!{&MethodPrototypeValue}, dmut vtableProt : &Vec!{MethodProtection}, dmut addMethods : &Vec!{dmut &Symbol})-> &TraitRefType
        throws &ErrorMsg
    {
        let tr = context:.validateType (im.getContent ().getTrait ());
        match tr {
            trRef : &TraitRefType => {
                let dmut errors = Vec!{&ErrorMsg}::new ();
                for it in trRef.getSymbol ().getAllLocalSymbols (protection-> Protection::PRIVATE) {
                    let dmut mSym = alias context:.getSymbolFromRef (it);
                    match ref mSym {
                        dmut f : &FunctionSymbol => { // Method definition                        
                            self.retreiveImplVtableMethod (alias context, im.getLoc (), alias f, clRef, trRef, alias vtable, alias vtableProt, alias addMethods);                            
                        } catch {
                            err : &ErrorMsg => errors:.push (err);
                        }
                    };
                }
                
                if (errors.len () != 0us) throw ErrorMsg::list (errors[]);
                
                trRef
            }
            _ => { // It is not a trait, class can't implement that
                throw ErrorMsg::fatal (tr.getLoc (), format (ValidateErrorMessage::IMPL_NO_TRAIT, tr));
            }
        }
    }

    /**
     * Retreive the index of a method in the vtable, during a trait implementation
     * @params: 
     *   - context: the context of the validation
     *   - loc: the location of the impl
     *   - func: the method that is being implemented
     *   - clRef: the type of the class being validated
     *   - trRef: the type of the trait that is implemented
     * @returns:
     *    - vtable: populate the vtable, or update it
     *    - vtableProt: populate the protections
     *    - addMethods: the list of methods that are either overriden or newly defined 
     * @throws:
     *   - &ErrorMsg: if there is an error in the validation
     */
    fn retreiveImplVtableMethod (self, dmut context : &Validator, loc : &Word, dmut func : &FunctionSymbol, clRef : &ClassRefType, trRef : &TraitRefType, dmut vtable : &Vec!{&MethodPrototypeValue}, dmut vtableProt : &Vec!{MethodProtection}, dmut addMethods : &Vec!{dmut &Symbol})
        throws &ErrorMsg
    {
        // Validate the prototype of the method
        let meth = context:.getFunctionValidator ().validateMethodPrototype (alias context, alias func, clRef, trRef);
        // Create a delegate type, in order to compare the methods of the vtable
        // The idea behind the following loop is that if a an ancestor has already implemented the trait, we have to replace the implemented methods by this new implementation                
        for it, i in vtable {
            if (it.getSymbol ().getPath ().file () == meth.getSymbol ().getPath ().file ()) { // we already have a method with the same name
                if (meth.isSimilar (it)) { // And it is the same method (delta the classreftype of self)
                    if (it.getTrait () != trRef.getSymbol ()) { // They are not from the same trait, (or not from a trait at all)
                        throw ErrorMsg::fatal (loc, format (ValidateErrorMessage::IMPLICIT_OVERRIDE_BY_TRAIT, it),
                                               notes-> [ErrorMsg::note (it.getLoc (), end-> meth.getLoc (), ""s8)]);
                    } else { // They come from the same trait, then we replace the old version
                        __pragma!trusted ({
                            (alias vtable)[i] = meth;
                            (alias addMethods)[i] = alias func;
                        });
                        
                        return {};
                    }
                }
            }
        } 
        
        // The method is new (not implemented by an ancestor)
        vtable:.push (meth);
        addMethods:.push (alias func);
        match func.getProtection () { 
            Protection::PRIVATE => vtableProt:.push (MethodProtection::PRV);
            Protection::PROTECTED => vtableProt:.push (MethodProtection::PROT);
            _ => vtableProt:.push (MethodProtection::PUB);
        };            
    }    

    
    /*!
     * ================================================================================
     * ================================================================================
     * =========================      VTABLE VALIDATION       =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate the methods prototypes that are declared inside implementations
     * @params: 
     *    - context: the context of the validation
     *    - clRef: the type of the class being validated
     *    - implemented: the list of implementation defined in the class
     *    - vtableProt: the protections of the methods of the vtable
     * @returns:
     *    - vtable: update the vtable (cannot grow, otherwise a method was declared in the impl but is not an "over"??)
     *    - addMethods: the list of methods that are either overriden or newly defined 
     * @throws:
     *   - &ErrorMsg: if there is an error in the validation (for example, 'im' does not implement a trait) 
     */
    fn validateImplsVtable (self, dmut context : &Validator, clRef : &ClassRefType, implemented : [(&ImplSymbol, &TraitRefType)], dmut vtable : &Vec!{&MethodPrototypeValue}, dmut vtableProt : &Vec!{MethodProtection}, dmut addMethods : &Vec!{dmut &Symbol})
        throws &ErrorMsg
    {
        let dmut errors = Vec!{&ErrorMsg}::new ();        
        for im in implemented { // Validate the overriden methods inside implementations         
            self.validateImplVtable (alias context, im._0, im._1, clRef, alias vtable, alias vtableProt, alias addMethods);
        } catch {
            err : &ErrorMsg => errors:.push (err);
        }

        if (errors.len () != 0us) throw ErrorMsg::list (errors[]);
        
    }
    
    /**
     * Update the vtable of the method that are implemented inside an implementation
     * @params: 
     *    - context: the context of the validation
     *    - im: the implementation being validated
     *    - clRef: the type of the class being validated
     *    - vtableProt: the protections of the methods of the vtable
     * @returns:
     *    - vtable: update the vtable (cannot grow, otherwise a method was declared in the impl but is not an "over"??)
     *    - addMethods: the list of methods that are either overriden or newly defined 
     * @throws:
     *   - &ErrorMsg: if there is an error in the validation (for example, 'im' does not implement a trait) 
     */
    fn validateImplVtable (self, dmut context : &Validator, im : &ImplSymbol, trRef : &TraitRefType, clRef : &ClassRefType, dmut vtable : &Vec!{&MethodPrototypeValue}, dmut vtableProt : &Vec!{MethodProtection}, dmut addMethods : &Vec!{dmut &Symbol})
        throws &ErrorMsg
    {
        let dmut errors = Vec!{&ErrorMsg}::new ();
        
        for it in im.getAllLocalSymbols (protection-> Protection::PRIVATE) match it { // Traverse the list of methods overriden in the implementation
            func : &FunctionSymbol => {
                let dmut mutSym = context:.getSymbolFromRef (func);
                match ref mutSym {
                    dmut mutFunc : &FunctionSymbol => {
                        self.validateImplVtableMethod (alias context, im.getLoc (), alias mutFunc, clRef, trRef, alias vtable, alias vtableProt, alias addMethods);
                    }
                }
            } catch {
                err : &ErrorMsg => { errors:.push (err); }
            }
            _ => __pragma!panic (); // An unknown symbol in impl, maybe verify the declaration of the impl
        }

        if (errors.len () != 0us) throw ErrorMsg::list (errors[]);        
    }

    /**
     * Validate an overriden method declared inside an implementation
     * @params: 
     *   - context: the context of the validation
     *   - loc: the location of the impl
     *   - func: the function to validate
     *   - clRef: the class type that is being validated
     *   - trRef: the trait that is currently implemented
     *   - ancVtable: the vtable of the ancestor class
     *   - vtableProt: the protections of the methods of the vtable
     * @returns:
     *    - vtable: update the vtable, cannot grow
     *    - addMethods: the list of methods that are either overriden or newly defined (is necessarily updated, or an error is thrown)
     * @throws:
     *   - &ErrorMsg: if there is an error in the validation (for example, 'im' does not implement a trait) 
     */
    fn validateImplVtableMethod (self, dmut context : &Validator, loc : &Word, dmut func : &FunctionSymbol, clRef : &ClassRefType, trRef : &TraitRefType, dmut vtable : &Vec!{&MethodPrototypeValue}, dmut vtableProt : &Vec!{MethodProtection}, dmut addMethods : &Vec!{dmut &Symbol})
        throws &ErrorMsg
    {
        let meth = context:.getFunctionValidator ():.validateMethodPrototype (alias context, alias func, clRef, traitRef-> trRef);
        let methProt = match func.getProtection () { 
            Protection::PRIVATE => { MethodProtection::PRV }
            Protection::PROTECTED => { MethodProtection::PROT }
            _ => MethodProtection::PUB
        };
        
        for it, i in vtable { // traverse the vtable, and verify that there is no collision
            if (it.getSymbol ().getPath ().file () == meth.getSymbol ().getPath ().file ()) {
                if (meth.isSimilar (it)) { // Verify that there is no collision between the method, and the other method, there can be multiple factors (different protection, missing override, over outside trait, ...)
                    self.verifyCollisionDirectMethod (it, meth, __pragma!trusted (vtableProt [i]), methProt, func.isOver ());
                    
                    // Thre is a collision, but it is an acceptable one, it is an proper override
                    __pragma!trusted ({
                        (alias vtable)[i] = meth; // we update the vtable
                        (alias addMethods)[i] = alias func; // We add the method to the methods to rewrite      
                    });
                    
                    
                    return {}
                }
            }
        }

        // There is no method in the trait definition that could be overriden by this method, so it must not be defined inside an impl
        throw ErrorMsg::fatal (meth.getLoc (), format (ValidateErrorMessage::OVERRIDE_NOTHING, meth), notes-> [ErrorMsg::note (loc, ValidateErrorMessage::VALIDATING)]);
    }   
    
    /**
     * Validate the methods prototypes that are declared outside implementations
     * @params: 
     *    - context: the context of the validation
     *    - sym: the symbol of the class being validated
     *    - clRef: the type of the class being validated
     *    - ancVtable: the vtable of the ancestor class
     *    - vtableProt: the protections of the methods of the vtable
     * @returns:
     *    - vtable: update the vtable, can grow
     *    - vtableProt: grow when new methods are defined in the class (but cannot be updated, or the protection of a method change when it is overriden ??)
     *    - addMethods: the list of methods that are either overriden or newly defined 
     *    - .0: the trait ref type
     * @throws:
     *   - &ErrorMsg: if there is an error in the validation
     */
    fn validateDirectVtable (self, dmut context : &Validator, sym : &ClassSymbol, clRef : &ClassRefType, dmut vtable : &Vec!{&MethodPrototypeValue}, dmut vtableProt : &Vec!{MethodProtection}, dmut addMethods : &Vec!{dmut &Symbol}, dmut templateMeths : &Vec!{&TemplateRefMethodValue}, dmut templateProts : &Vec!{MethodProtection})
        throws &ErrorMsg
    {
        let dmut errors = Vec!{&ErrorMsg}::new ();
        for it in sym.getAllLocalSymbols (protection-> Protection::PRIVATE) { // traverse all the function defined inside the class
            {
                match it {
                    func : &FunctionSymbol => {
                        let dmut mutSym = context:.getSymbolFromRef (func);
                        match ref mutSym {
                            dmut mutFunc : &FunctionSymbol => {
                                self.validateDirectVtableMethod (alias context, alias mutFunc, clRef, alias vtable, alias vtableProt, alias addMethods); // validate the redefinition for the vtable
                            }
                        }
                    }
                    t : &TemplateSymbol => {
                        match t.getContent ().getContent () {
                            _ : &FunctionDecl => {
                                let methProt = match t.getProtection () {
                                    Protection::PRIVATE => { MethodProtection::PRV }
                                    Protection::PROTECTED => { MethodProtection::PROT }
                                    _ => MethodProtection::PUB
                                };

                                templateProts:.push (methProt);
                                templateMeths:.push (TemplateRefMethodValue::new (t.getLoc (), clRef.getSymbol (), t));
                            }
                        }
                    }
                }
            } catch {
                err : &ErrorMsg => {
                    errors:.push (err); 
                }
            }
        }
        
        if (errors.len () != 0us) throw ErrorMsg::list (errors[]);
    }

    /**
     * Validate the prototype of a method and put it inside the vtable (or update the vtable in case of override)
     *    - context: the context of the validation
     *    - sym: the symbol of the class being validated
     *    - clRef: the type of the class being validated
     *    - ancVtable: the vtable of the ancestor class
     *    - vtableProt: the protections of the methods of the vtable
     * @returns:
     *    - vtable: update the vtable, can grow
     *    - vtableProt: grow when new methods are defined in the class (but cannot be updated, or the protection of a method change when it is overriden ??)
     *    - addMethods: the list of methods that are either overriden or newly defined and must be validated at the end of the creation of the vtable
     *    - .0: the trait ref type
     * @throws:
     *   - &ErrorMsg: if there is an error in the validation 
     */
    fn validateDirectVtableMethod (self, dmut context : &Validator, dmut func : &FunctionSymbol, clRef : &ClassRefType, dmut vtable : &Vec!{&MethodPrototypeValue}, dmut vtableProt : &Vec!{MethodProtection}, dmut addMethods : &Vec!{dmut &Symbol})
        throws &ErrorMsg
    {
        let meth = context:.getFunctionValidator ():.validateMethodPrototype (alias context, alias func, clRef);
        let methProt = match func.getProtection () {
            Protection::PRIVATE => { MethodProtection::PRV }
            Protection::PROTECTED => { MethodProtection::PROT }
            _ => MethodProtection::PUB
        };
 
        for it, i in vtable { // traverse the vtable, and verify that there is no collision
            if (it.getSymbol ().getPath ().file () == meth.getSymbol ().getPath ().file ()) {
                if (meth.isSimilar (it)) { // Verify that there is no collision between the method, and the other method, there can be multiple factors (different protection, missing override, over outside trait, ...)
                    self.verifyCollisionDirectMethod (it, meth, __pragma!trusted (vtableProt [i]), methProt, func.isOver ());
                    
                    // Thre is a collision, but it is an acceptable one, it is an proper override
                    __pragma!trusted ({
                        (alias vtable)[i] = meth; // we update the vtable
                        (alias addMethods)[i] = alias func; // We add the method to the methods to rewrite      
                    });
                    
                    
                    return {}
                }
            }
        }

        if (func.isOver ()) throw ErrorMsg::fatal (meth.getLoc (), format (ValidateErrorMessage::OVERRIDE_NOTHING, meth));

        /// There is no override here, its a new method, we just add it at the end of the vtable
        vtable:.push (meth);
        addMethods:.push (alias func);
        vtableProt:.push (methProt);
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================     VTABLE VERIFICATION      =========================
     * ================================================================================
     * ================================================================================
     */
    
    /**
     * Verify that the collision that was detected between this two methods is acceptable
     * @params: 
     *   - oldMethod: the definition of the old method
     *   - nMethod: the definition of the new method
     *   - oldProt: the protection of the old method
     *   - nProt: the protection of the new method
     *   - isOver: the keyword over was used 
     * @throws:
     *   - &ErrorMsg: if there is a unacceptable collision
     */
    fn verifyCollisionDirectMethod (self, oldMethod : &MethodPrototypeValue, nMethod : &MethodPrototypeValue, oldProt : MethodProtection, nProt : MethodProtection, isOver : bool)
        throws &ErrorMsg
    {        
        if (oldMethod.getTrait () !is nMethod.getTrait ()) {
            match (nMethod.getTrait (), oldMethod.getTrait (), isOver) {
                (EmptySymbol (), EmptySymbol (), _) => {} // it can be a different empty symbol address, but still be valid
                (EmptySymbol (), _, true) => {
                    throw ErrorMsg::fatal (nMethod.getLoc (), end-> oldMethod.getLoc (), format (ValidateErrorMessage::OVERRIDE_TRAIT_OUTSIDE, oldMethod, nMethod, withTags-> ["withParams"s8]));
                }
                (_, EmptySymbol (), true) => {
                    throw ErrorMsg::fatal (nMethod.getLoc (), end-> oldMethod.getLoc (), format (ValidateErrorMessage::OVERRIDE_NON_TRAIT_INSIDE, oldMethod, nMethod, withTags-> ["withParams"s8]));
                }
                (_, _, _) => { // Same method but from two different traits                    
                    throw ErrorMsg::fatal (nMethod.getLoc (), end-> oldMethod.getLoc (), format (ValidateErrorMessage::COLLIDING_METHOD_DEFINITION, nMethod, oldMethod, withTags-> ["withParams"s8]));
                }
            }
        }

        if (oldMethod.getTrait () is nMethod.getTrait ()) {
            match oldMethod.getTrait () {
                TraitSymbol () => { // we define a method inside an impl, (so an override)
                    if (oldMethod.isOver ()) { // was an override, and come from a trait, then it was necessarily defined inside an impl
                        throw ErrorMsg::fatal (nMethod.getLoc (), end-> oldMethod.getLoc (), format (ValidateErrorMessage::OVERRIDE_MULTIPLE_TIMES_TRAIT, nMethod, withTags-> ["withParams"s8]));
                    }
                }
            }
        }


        if (oldMethod.getClassRef () == nMethod.getClassRef ()) {
            match (oldMethod.getTrait (), nMethod.getTrait ()) {
                (EmptySymbol (), EmptySymbol ()) => { // the definition of the method is made two times in the same class (and is not an override inside a trait)
                    throw ErrorMsg::fatal (nMethod.getLoc (), end-> oldMethod.getLoc (), format (ValidateErrorMessage::COLLIDING_METHOD_DEFINITION, nMethod, oldMethod, withTags-> ["withParams"s8]));
                }
            }
        }

        // Simple collision, over is not written in the definition of the method
        if (!isOver) throw ErrorMsg::fatal (nMethod.getLoc (), end-> oldMethod.getLoc (), format (ValidateErrorMessage::IMPLICIT_OVERRIDE, nMethod, oldMethod, withTags-> ["withParams"s8]));

        // override prv method is impossible, child class does not have access to ancestor private methods
        if (oldProt == MethodProtection::PRV_PARENT) {
            throw ErrorMsg::fatal (nMethod.getLoc (), end-> oldMethod.getLoc (), format (DeclareErrorMessage::PRIVATE_IN_THIS_CONTEXT, oldMethod, withTags-> ["withParams"s8]));
        }

        // override a pub method, mut be pub
        if (nProt != oldProt) {
            throw ErrorMsg::fatal (nMethod.getLoc (), end-> oldMethod.getLoc (), format (ValidateErrorMessage::OVERRIDE_MISMATCH_PROTECTION, self.toStr (nProt), nMethod, self.toStr (oldProt), withTags-> ["withParams"s8]));
        }

        // override a final method is impossible (that's the definition of final)
        if (oldMethod.isFinal ()) {
            throw ErrorMsg::fatal (nMethod.getLoc (), end-> oldMethod.getLoc (), format (ValidateErrorMessage::OVERRIDE_FINAL, oldMethod, withTags-> ["withParams"s8]));
        }

        // Field method can only be override by field method
        if (oldMethod.isField () && !nMethod.isField ()) {
            throw ErrorMsg::fatal (nMethod.getLoc (), format (ValidateErrorMessage::OVERRIDE_FIELD_NO_FIELD, nMethod, oldMethod, withTags-> ["withParams"s8]), notes-> [ErrorMsg::note (oldMethod.getFieldLoc (), end-> oldMethod.getLoc (), ""s8)]);
        }

        // A field method can only override a field method
        if (!oldMethod.isField () && nMethod.isField ()) {
            throw ErrorMsg::fatal (nMethod.getLoc (), end-> nMethod.getFieldLoc (), format (ValidateErrorMessage::OVERRIDE_NO_FIELD_BY_FIELD, nMethod, oldMethod, withTags-> ["withParams"s8]), notes-> [ErrorMsg::note (oldMethod.getFieldLoc (), ""s8)]);
        }

        // Override methods must have a body
        if (nMethod.isEmpty ()) throw ErrorMsg::fatal (nMethod.getLoc (), format (ValidateErrorMessage::OVERRIDE_EMPTY, nMethod, oldMethod, withTags-> ["withParams"s8]));
        
        nProt;
        oldProt;
    }    

    /*!
     * ================================================================================
     * ================================================================================
     * =========================      VTABLE DESTRUCTOR       =========================
     * ================================================================================
     * ================================================================================
     */
    
    /**
     * Validate the prototype of the destructor for the vtable
     * @params:
     *    - context: the context of the validation
     *    - sym: the symbol to validate
     *    - clRef: the type of the class being validated
     *    - ancestor: the ancestor of the class
     * @throws: 
     *    - &ErrorMsg: if there is an error in the validation
     * @returns: the prototype of the destructor
     */
    fn validateVtableDtor (self, dmut context : &Validator, dmut sym : &ClassSymbol, clRef : &ClassRefType, ancestor : &Type)-> &Value
        throws &ErrorMsg
    {
        let ancDtor = match ancestor {
            ancRef : &ClassRefType => { // maybe the ancestor has a destructor
                ancRef.getDestructor ()
            }
            _ => { // No ancestor, so no destructor at all
                cast!{&Value} (UNIT_VALUE)
            }
        };

        let dmut dtor = sym:.getDestructor ();
        match ref dtor {
            EmptySymbol () => { ancDtor } // no destructor in the class
            dmut func : &DestructorSymbol => { // a destructor is defined, we return its prototype
                sym:.insertAddMethod (alias func);
                cast!{&Value} (context:.getFunctionValidator ():.validateDtorPrototype (alias context, alias func, clRef, ancDtor-> ancDtor))
            }
            _ => { // another kind of symbol ? what is that ?
                __pragma!panic ();
            }
        }
    }

    /*!
     * ==================================================================================
     * ==================================================================================
     * =========================            TYPEINFO            =========================
     * ==================================================================================
     * ==================================================================================
     */

    /**
     * Validate the typeinfo part of a class symbol
     * @params:
     *    - context: the context of the validation
     *    - sym: the class symbol to validate
     * */
    fn validateTypeInfo (self, dmut context : &Validator, dmut sym : &ClassSymbol)
        throws &ErrorMsg
    {
        let loc = sym.getLoc ();
        match sym.getClassRef () {
            oldRef : &ClassRefType => {
                let type = context:.validateTypeInfo (sym.getLoc ());
                let id = context:.validateTypeIDs (sym.getLoc (), TypeInfoIDS::OBJECT);

                let idInt = {
                    id.asOf!{&EnumFieldAccessValue} ().getContent ()
                        .asOf!{&IntValue} ().getValue ().to!{usize} ()
                } catch {
                    _ => __pragma!panic ();
                };

                let size = context:.getSizeofValidator ():.validateType (sym.getLoc (), oldRef);

                let innerSlice = match oldRef.getAncestor () {
                    anc : &ClassRefType => {
                        let ancType = ArrayType::new (loc, type, 1us);
                        context.createSliceAliasFromArray (loc, ancType, ArrayValue::new (loc, ancType, [anc.getTypeInfo ()]))
                    }
                    _ => {
                        let ancType = ArrayType::new (loc, type, 0us);
                        context.createSliceAliasFromArray (loc, ancType, ArrayValue::new (loc, ancType, []))
                    }
                };

                let typeinfoFin = TypeInfoValue::new (loc, type,
                                                      idInt,
                                                      size,
                                                      innerSlice,
                                                      sym.getPath ().toStr ());


                let dmut newCl = ClassRefType::withTypeInfo (oldRef, typeinfoFin);
                sym:.setClassRef (alias newCl);
            }
            _ => __pragma!panic ();
        }
    }
            
    /*!
     * ================================================================================
     * ================================================================================
     * =========================           CHECKING           =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * @returns: true if the class was already validated, or is currently in validation
     */
    fn checkValidation (self, sym : &ClassSymbol)-> bool {
        match sym.getClassRef () {
            EmptyGenerator () => { // The class has no typeinfo, but maybe it is currently in validation (recursive class validation)
                for it in self._validation {
                    if it is sym {
                        return true; // Indeed it is
                    }
                }

                false
            }
            _ => { true }
        }
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================            UTILS             =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * @returns: the str containing the method protection
     */
    pub fn toStr (self, protection : MethodProtection) -> [c8] {
        match protection {
            MethodProtection::PUB => { Keys::PUBLIC }
            MethodProtection::PROT => { Keys::PROTECTED }
            _ => { Keys::PRIVATE }
        }
    }
    
}
