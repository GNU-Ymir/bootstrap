mod ymirc::semantic::validator::symbol::class_;

import ymirc::semantic::validator::visitor;
import ymirc::semantic::validator::errors;
import ymirc::semantic::symbol::_;
import ymirc::syntax::declaration::protection;
import ymirc::syntax::expression::_;
import ymirc::syntax::declaration::_;

import ymirc::syntax::keys;
import ymirc::semantic::generator::_;
import ymirc::errors::_;
import ymirc::utils::format;
import ymirc::lexing::word;

import std::collection::vec;
import std::io, std::fs::path;
import std::collection::set;

/**
 * The class validator is the class responsible for class symbol validation
 */
pub class ClassValidator {    

    /// The list of class symbols currently in validation to avoid infinite recursion, and validating multiple times the same symbol
    let dmut _validation = HashSet!{&Symbol}::new ();
        
    /**
     * Create a new empty validator
     */
    pub self () {}

    /**
     * Validate an class symbol
     * @info: 
     * @params: 
     *    - context: the context of the validation
     *    - sym: the symbol to validate
     *    - inModule: iif true, this validation is "in module", "out module" otherwise meaning that the class was found inside a value (e.g. varref), and a full validation is not necessary
     * @throws:
     *    - &ErrorMsg, if the class is malformed
     */
    pub def validate (mut self, dmut context : &Validator, dmut sym : &ClassSymbol, inModule : bool)-> &ClassRefType
        throws &ErrorMsg
    {
        if (inModule || !self.checkValidation (sym)) {
            self:.validateClassContent (alias context, alias sym, inModule-> inModule); // This cannot throw (cf. the function def)
        }

        match sym.getClassRef () {
            r : &ClassRefType => {
                return r;
            }
            err : &ErrorGenerator => { // The class was validated by self.validateClassContent, but it failed so the generator is an error
                // we simply throw it, unfortunately it will leads to printing the same error multiple times, but I don't see any way to avoid that efficiently (while making sure the error is at least printed one time)
                // Maybe add a uniq identifier to errors, and perform the verification directly in the error printing part
                throw err.getErrorMessage ();  
            }
            _ => { 
                __pragma!panic ();
            }
        };
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================       INNER VALIDATION       =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate the content of a class (fields, methods, etc.)
     * @warning: does not throw an error, but write it in the generator of the class if there was any.
     * @params: 
     *   - context: the context of the validation
     *   - sym: the symbol to validate
     *   - inModule: if true, then the methods of the class are validated and inserted in the generators of the context
     */
    def validateClassContent (mut self, dmut context : &Validator, dmut sym : &ClassSymbol, inModule : bool) {
        
        // The validation of the class is not finished
        // a recursive reference to itself in ancestor will lead to infinite loop, we want to avoid that
        sym:.setClassRef (ErrorGenerator::new (sym.getLoc (), ErrorMsg::fatal (sym.getLoc (), ValidateErrorMessage::FORWARD_REFERENCE_TYPE)));

        // We add the symbol to avoid infinite loops
        self._validation:.insert (sym);
        
        // First we need to validate the ancestor of the class, to generate the vtable, the child class vtable being an override of the one of the ancestor
        let ancestor = self.validateAncestor (alias context, alias sym);
        
        // Now that we have the ancestor, the class is a bit more usable for further validation
        sym:.setClassRef (ClassRefType::new (sym.getLoc (), sym, ancestor));        

        // Validate the static assertions of the class definition (@warning: this is only performed if the validation is a root validation-> self._validation.len () == 1us, to avoid too deep and unreadable errors)
        self.validateCtes (alias context, alias sym);
        
        // Validate the vtable (without validating the method bodies, just the prototypes)
        self.validateVtable (alias context, alias sym, ancestor);

        // Validate the fields of the class
        self.validateFields (alias context, alias sym, ancestor);

        inModule;
        // if (inModule) { // The class is defined in the module that is currently validated, we need to declare the inner symbols of the class (i.e. the methods)
        //     context:.insertClassValidation (alias sym);
        // }
        
    } exit {
        self._validation:.remove (sym);
    } catch {
        err : &ErrorMsg => {
            // If there is an error in the validation, then write it in the type validation
            // Then each time a validation is tried, the same error is sent without needing a new validation
            sym:.setClassRef (ErrorGenerator::new (sym.getLoc (), ErrorMsg::fatal (sym.getLoc (), ValidateErrorMessage::VALIDATING, notes-> [err])));
        }
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================           ANCESTOR           =========================
     * ================================================================================
     * ================================================================================
     */
    
    /**
     * Validate the ancestor of the class
     * @params: 
     *    - context: the context of the validation
     *    - sym: the class symbol whose ancestor will be validated
     * @returns: the ancestor type (NoneType, if the class does not have an ancestor)
     * @throws:
     *   - &ErrorMsg: if the validation failed
     */
    def validateAncestor (self, dmut context : &Validator, dmut sym : &ClassSymbol)-> &Type
        throws &ErrorMsg
    {
        match sym.getAncestor () {
            EmptyExpression () => { NONE_TYPE } // No ancestor specified
            ancestor : &Expression => {                
                let type = {
                    context:.validateType (ancestor)
                } catch {
                    err : &ErrorMsg => {
                        throw err.withNote ([ErrorMsg::note (ancestor.getLoc (), ValidateErrorMessage::VALIDATING)]);
                    }
                };
                
                match type {
                    cr : &ClassRefType => { // The ancestor class must be a class, obviously
                        if (cr.getSymbol ().isFinal ()) { // and it cannot be final
                            throw ErrorMsg::fatal (ancestor.getLoc (), format (ValidateErrorMessage::INHERIT_FINAL_CLASS, cr));
                        }
                        
                        cr // if it is a class ref, and not final then no problem, it can be an ancestor
                    }
                    x : _ => { // This is not a class, cannot inherit non class types
                        throw ErrorMsg::fatal (ancestor.getLoc (), format (ValidateErrorMessage::INHERIT_NO_CLASS, x));
                    }
                }
            }
        }
    }
    
    /**
     * ================================================================================
     * ================================================================================
     * =========================             CTES             =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate the static assertion of a class symbol
     * @warning: 
     * ----------------
     * the validation is only performed on root validation (meaning iif self._validation.len () == 1us)   
     * In order to avoid too deep errors, and complex error handling
     * ----------------
     * @params: 
     *    - context: the context of the validation
     *    - sym: the symbol to validate
     * @throws:
     *   - &ErrorMsg: if some assertion where invalid, or not true
     */
    def validateCtes (self, dmut context : &Validator, dmut sym : &ClassSymbol)
        throws &ErrorMsg
    {
        if (self._validation.len () != 1us) return {}

        let dmut errors = Vec!{&ErrorMsg}::new ();
        if (sym.getAssertions ().len != 0us) {
            context:.pushReferent (alias sym); // The assertion are located in the class context
            context:.enterForeign (isFnBody-> false); // There are not inside function

            for it in sym.getAssertions () { 
                context:.validateCteValue (it); // validate the assertion
            } catch { 
                err : &ErrorMsg => errors:.push (err);
            }          
            
        } exit {
            context:.popReferent ();
            context:.exitForeign ();
        }

        // Some assertion failed
        if (errors.len () != 0us) throw ErrorMsg::list (errors[]);
    }
           
    /**
     * ================================================================================
     * ================================================================================
     * =========================            FIELDS            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate the fields of a class symbol, and populate the class definition
     * @params: 
     *   - context: the context of the validation
     *   - sym: the symbol to validate
     *   - ancestor: the ancestor type of the class
     *   - inModule: true if the validation of the class is "in module"
     * @throws:
     *   - &ErrorMsg: if there is an error in the validation of the fields
     */
    def validateFields (self, dmut context : &Validator, dmut sym : &ClassSymbol, ancestor : &Type)
        throws &ErrorMsg
    {                
        let localFields = self.validateLocalFields (alias context, alias sym); // Validate the fields declared in the class def
        let allFields = match ancestor {
            cl : &ClassRefType => {
                let ancestorFields = cl.getFields (); // Get the fields declared in the ancestor class
                self.verifyFieldCollisions (alias context, ancestorFields, localFields); // Verify that there is no collistion between ancestor fields and local fields
                    
                ancestorFields ~ localFields            
            }
            _ => { localFields }
        };

        // Update the class type info definition in the symbol, so it has access to the fields
        match sym.getClassRef () {
            oldRef : &ClassRefType => {
                let dmut clRef = ClassRefType::withField (oldRef, allFields, localFields);
                sym:.setClassRef (alias clRef);
            }
            _ => __pragma!panic (); // The function was called where exactly ?!! verify that there is previous classref in the symbol
        }
    }

    /**
     * Validate the fields that are declared in the class definition
     * @params : 
     *    - context: the context of the validation
     *    - sym: the symbol whose field we will validate
     * @returns: The list of validated fields
     * @throws:
     *    - &ErrorMsg: if there was an error in one or more field validation
     */
    def validateLocalFields (self, dmut context : &Validator, dmut sym : &ClassSymbol)-> [&Value]
        throws &ErrorMsg
    {
        context:.pushReferent (alias sym); // Fields are declared inside the class
        context:.enterForeign (isFnBody-> false); // A new foreign, we don't wan't to pollute current context
        context:.enterBlock (); // A block, we will add variable definitions

        let dmut fields = Vec!{&Value}::new ();
        for it in sym.getFields () {
            match it {
                f : &VarDeclExpr => {
                    // Fields are just like variable decls 
                    let field = context:.getValueValidator ().validateVarDecl (alias context, f, needInitValue-> false);
                    
                    // There are two reasons for clearing local space
                    // 1) we don't want warnings about unused fields
                    // 2) fields cannot refer to other fields in the value definition (e.g. "let a = 12, b = a;" is invalid)
                    context:.clearLocalScope ();

                    // We add the validated field
                    fields:.push (field);
                }
                _ => { // Something strange was declared as a field in the class definition
                    __pragma!panic ();
                }
            };
        }
        
        fields [] // returning the list of fields
    } exit {
        context:.quitBlock (); // We entered a block at the beginning of the function
        
        context:.exitForeign (); // We entered a foreign
        context:.popReferent (); // And we pushed a referent
    }
    
    /**
     * Verify that there is no collision between fields declared in ancestor class, and fields declared in local class
     * @params:
     *   - context: the context of the validation 
     *   - ancestorFields: the list of fields declared in ancestor classes
     *   - localFields: the list of fields declared in local class
     * @throws:
     *   - &ErrorMsg: if there is a collision     
     */
    def verifyFieldCollisions (self, dmut _ : &Validator, ancestorFields : [&Value], localFields : [&Value])
        throws &ErrorMsg
    {
        let dmut errors = Vec!{&ErrorMsg}::new ();

        // These loops are pretty self explanatory, we just traverse the fields and verify that there is no common names in local and ancestor fields
        for lt in localFields {
            for at in ancestorFields {
                match (lt, at) {
                    (lvar : &VarDeclValue, avar : &VarDeclValue) => {
                        if (lvar.getLoc ().str () == avar.getLoc ().str ()) {
                            errors:.push (ErrorMsg::fatal (lvar.getLoc (), // Shadowing error
                                                           format (ValidateErrorMessage::SHADOWING_DECL,
                                                                   lvar.getLoc ().str ()),
                                                           notes-> [ErrorMsg::note (avar.getLoc (), ""s8)]));
                        }
                    }
                }
            }
        }

        if (errors.len () != 0us) throw ErrorMsg::list (errors[]); // There are collisions
    }
    
    /**
     * ================================================================================
     * ================================================================================
     * =========================            VTABLE            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate the vtable of a class and populates the class symbol definition
     * @params:
     *    - context: the context of the validation
     *    - sym: the symbol to validate
     *    - ancestor: the type of the ancestor of the class
     * @throws:
     *    - &ErrorMsg: if there is an error in the vtable validation
     */
    def validateVtable (self, dmut context : &Validator, dmut sym : &ClassSymbol, ancestor : &Type)
        throws &ErrorMsg
    {
        match sym.getClassRef () {
            oldRef : &ClassRefType => {
                // Validate the vtable, and get the list of method prototypes, and their protections
                let (vtable, protection) = self.validateClassDeclarations (alias context, alias sym, oldRef, ancestor);

                // Validate the destructor of the class (if any)
                // In order to be virtual (overridable and callable from child class), dtor must be defined in the vtable 
                let dtor = self.validateVtableDtor (alias context, sym, oldRef, ancestor);

                // Update the class type info definition in the symbol, so it has access to the vtable
                let dmut clRef = ClassRefType::withVtable (oldRef, vtable, protection, dtor);
                sym:.setClassRef (alias clRef);
                // TODO compute the TypeInfo value, and also put it in the class definition
            }
            _ => __pragma!panic (); // Mh, well no supposed to be here, verify that there is previous classref in the symbol, we need it to validate the vtable
        }
    }

    /**
     * Validate the vtable of the class declaration
     * @info: populate the addMethods in the class (the add methods are the methods that are not defined in parent class)
     * @params: 
     *    - context: the context of the validation
     *    - sym: the symbol to validate
     *    - clRef: the type of the class being validated (without vtable)
     *    - ancestor: the ancestor of the class
     * @throws: 
     *    - &ErrorMsg: if there is an error in the validation
     * @returns: 
     *    - .0: the list of methods prototype of the vtable
     *    - .1: the list of protection of the methods
     */
    def validateClassDeclarations (self, dmut context : &Validator, dmut sym : &ClassSymbol, clRef : &ClassRefType, ancestor : &Type)-> ([&Value], [MethodProtection])
        throws &ErrorMsg
    {
        let dmut vtable = Vec!{&Value}::new ();
        let dmut prots = Vec!{MethodProtection}::new ();
        let dmut addMethods = Vec!{dmut &Symbol}::new ();
        
        // Ok, this part is complex, so hang in there.

        // Retreive the vtable of the ancestor, the vtable of the current class is an update of it, and same symbols must be located at the same place
        let ancVtable = self.retreiveAncestorVtable (ancestor, alias vtable, alias prots, alias addMethods);

        // Create the vector containing all the methods defined in implemented traits
        let implemented = self.retreiveImplsVtable (alias context, sym, clRef, ancestor, alias vtable, alias prots, ancVtable, alias addMethods);
       
        // At this point, vtable contains :
        //  1) All the methods declared in ancestor class
        //  2) All the methods declared in implemented traits
        // There is no method declared in the class (either new, over, of impl over) in the vtable
        // So we start by validating the methods that are declared outside implementations
        self.validateDirectVtable (alias context, sym, clRef, ancestor, alias vtable, alias prots, ancVtable, alias addMethods);

        // An now the methods that are declared inside implementations
        self.validateImplsVtable (alias context, sym, clRef, ancestor, implemented, alias vtable, alias prots, alias addMethods);


        // Finally, verify that all method prototypes are uniqely identifiable
        self.verifyCollisionVtable (vtable[]);

        // Insert the symbol of the methods that has to be fully validated if the class is "in module"
        // These symbols are the methods that are declared inside the class (new, over or impl over)
        for i in 0us .. addMethods.len () { 
            __pragma!trusted ({
                let dmut meth = alias (alias addMethods)[i];
                match meth {
                    EmptySymbol () => {} // if it is an empty symbol, then the method was declared in ancestor or trait, and put in the class as it was (not over)
                    _ => {
                        sym:.insertAddMethod (alias meth); // The method is new or overriden
                    }
                }
            });
        }
        
        (vtable[], prots[])
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================       VTABLE ANCESTOR        =========================
     * ================================================================================
     * ================================================================================
     */
   
    /**
     * Retreive the vtable of the ancestor if the ancestor exists
     * @params:
     *    - ancestor: the ancestor type
     * @returns:
     *   - .0: the vtable of the ancestor (list of prototype of methods)
     *   - vtable: same as .0, but updatable
     *   - prots: almost same as .1, but updatable (and PRV is now PRV_PARENT)
     */
    def retreiveAncestorVtable (self, ancestor : &Type, dmut vtable : &Vec!{&Value}, dmut prots : &Vec!{MethodProtection}, dmut addMethods : &Vec!{dmut &Symbol}) -> [&Value]
    {
        match ancestor {
            clRef : &ClassRefType => { // there is an ancestor
                let ancVtable = clRef.getVtable ();
                let ancProts = clRef.getVtableProtections ();
                for i in ancVtable { // insert the method prototype in the vtable of the current class
                    vtable:.push (i);
                    addMethods:.push (alias EMPTY_SYMBOL);
                }

                for j in ancProts { // Insert the protection in the vtable of the current class 
                    if (j == MethodProtection::PRV) prots:.push (MethodProtection::PRV_PARENT); // private methods are not accessible in child class
                    else prots:.push (j);
                }
                
                return ancVtable; // return the vtable of the ancestor class
            }
        }

        [] // There is no ancestor to the current class
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================         VTABLE IMPL          =========================
     * ================================================================================
     * ================================================================================
     */
    
    /**
     * Retreive the list of methods that are declared inside traits, and that are implemented by the class
     * @params: 
     *   - context: the context of the validation
     *   - sym: the symbol of the class being validated     
     *   - clRef: the type of the class being validated
     *   - ancestor: the ancestor type of the class
     *   - ancVtable: the vtable of the ancestor class
     * @returns:
     *    - vtable: populate the vtable, or update it
     *    - vtableProt: populate the protections
     *    - addMethods: the list of methods that are either overriden or newly defined 
     *    - .0: the list of implemented traits, [(.0: the trait symbol, .1: the trait type)]
     * @throws:
     *   - &ErrorMsg: if there is an error in the validation    
     */
    def retreiveImplsVtable (self, dmut context : &Validator, sym : &ClassSymbol, clRef : &ClassRefType, ancestor : &Type, dmut vtable : &Vec!{&Value}, dmut vtableProt : &Vec!{MethodProtection}, ancVtable : [&Value], dmut addMethods : &Vec!{dmut &Symbol})-> [(&Symbol, &Type)]
        throws &ErrorMsg
    {
        let dmut implemented = Vec!{(&Symbol, &Type)}::new ();
        let dmut errors = Vec!{&ErrorMsg}::new ();
        
        for it in sym.getAllLocalSymbols (protection-> Protection::PRIVATE) {
            {
                match it {
                    im : &ImplSymbol => { // If there is an implementation, then we need to validated its vtable
                        let ret = self.retreiveImplVtable (alias context, im, clRef, ancestor, alias vtable, alias vtableProt, ancVtable, alias addMethods);
                        implemented:.push ((im, ret));
                    }
                }
            } catch {
                err : &ErrorMsg => {
                    errors:.push (ErrorMsg::fatal (it.getLoc (), ValidateErrorMessage::VALIDATING, notes-> [err]));
                }
            }
        }

        if (errors.len () != 0us) throw ErrorMsg::list (errors[]);
        
        implemented []
    }


    /**
     * Retreive the vtable of a trait implementation
     * @params: 
     *   - context: the context of the validation
     *   - im: the implementation to validated
     *   - clRef: the type of the class being validated
     *   - ancestor: the ancestor type of the class
     *   - ancVtable: the vtable of the ancestor class
     * @returns:
     *    - vtable: populate the vtable, or update it
     *    - vtableProt: populate the protections
     *    - addMethods: the list of methods that are either overriden or newly defined 
     *    - .0: the trait ref type
     * @throws:
     *   - &ErrorMsg: if there is an error in the validation (for example, 'im' does not implement a trait) 
     */
    def retreiveImplVtable (self, dmut context : &Validator, im : &ImplSymbol, clRef : &ClassRefType, ancestor : &Type, dmut vtable : &Vec!{&Value}, dmut vtableProt : &Vec!{MethodProtection}, ancVtable : [&Value], dmut addMethods : &Vec!{dmut &Symbol})-> &Type
        throws &ErrorMsg
    {
        let tr = context:.validateType (im.getContent ().getTrait ());
        match tr {
            TraitRefType () => {
                clRef;
                ancestor;
                vtable;
                vtableProt;
                ancVtable;
                addMethods;
                __pragma!panic ();
            }
            _ => __pragma!panic ();
        }
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================      VTABLE VALIDATION       =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate the methods prototypes that are declared inside implementations
     * @params: 
     *    - context: the context of the validation
     *    - sym: the symbol of the class being validated
     *    - clRef: the type of the class being validated
     *    - ancestor: the ancestor type of the class
     *    - vtableProt: the protections of the methods of the vtable
     * @returns:
     *    - vtable: update the vtable (cannot grow, otherwise a method was declared in the impl but is not an "over"??)
     *    - addMethods: the list of methods that are either overriden or newly defined 
     *    - .0: the trait ref type
     * @throws:
     *   - &ErrorMsg: if there is an error in the validation (for example, 'im' does not implement a trait) 
     */
    def validateImplsVtable (self, dmut context : &Validator, sym : &ClassSymbol, clRef : &ClassRefType, ancestor : &Type, implemented : [(&Symbol, &Type)], dmut vtable : &Vec!{&Value}, dmut vtableProt : &Vec!{MethodProtection}, dmut addMethods : &Vec!{dmut &Symbol})-> [&Value]
        throws &ErrorMsg
    {
        context;
        sym;
        clRef;
        ancestor;
        implemented;
        vtable;
        vtableProt;
        addMethods;
        __pragma!fake_throw (&ErrorMsg);
        __pragma!panic ();
    }
    
    /**
     * Validate the methods prototypes that are declared outside implementations
     * @params: 
     *    - context: the context of the validation
     *    - sym: the symbol of the class being validated
     *    - clRef: the type of the class being validated
     *    - ancestor: the ancestor type of the class
     *    - ancVtable: the vtable of the ancestor class
     *    - vtableProt: the protections of the methods of the vtable
     * @returns:
     *    - vtable: update the vtable, can grow
     *    - vtableProt: grow when new methods are defined in the class (but cannot be updated, or the protection of a method change when it is overriden ??)
     *    - addMethods: the list of methods that are either overriden or newly defined 
     *    - .0: the trait ref type
     * @throws:
     *   - &ErrorMsg: if there is an error in the validation (for example, 'im' does not implement a trait) 
     */
    def validateDirectVtable (self, dmut context : &Validator, sym : &ClassSymbol, clRef : &ClassRefType, ancestor : &Type, dmut vtable : &Vec!{&Value}, dmut vtableProt : &Vec!{MethodProtection}, ancVtable : [&Value], dmut addMethods : &Vec!{dmut &Symbol})-> [&Value]
        throws &ErrorMsg
    {
        context;
        sym;
        clRef;
        ancestor;
        vtable;
        vtableProt;
        ancVtable;
        addMethods;
        __pragma!fake_throw (&ErrorMsg);
        __pragma!panic ();
    }


    /**
     * ================================================================================
     * ================================================================================
     * =========================     VTABLE VERIFICATION      =========================
     * ================================================================================
     * ================================================================================
     */
    
    /**
     * Traverse the vtable, and verify that every method prototype is uniqely identifiable
     * @params: 
     *   - vtable: the list of methods in the vtable
     * @throws:
     *   - &ErrorMsg: if there is a collision
     */
    def verifyCollisionVtable  (self, vtable : [&Value])
        throws &ErrorMsg
    {
        vtable;
        __pragma!fake_throw (&ErrorMsg);
        __pragma!panic ();
    }    

    /**
     * ================================================================================
     * ================================================================================
     * =========================      VTABLE DESTRUCTOR       =========================
     * ================================================================================
     * ================================================================================
     */
    
    /**
     * Validate the prototype of the destructor for the vtable
     * @params:
     *    - context: the context of the validation
     *    - sym: the symbol to validate
     *    - clRef: the type of the class being validated
     *    - ancestor: the ancestor of the class
     * @throws: 
     *    - &ErrorMsg: if there is an error in the validation
     * @returns: the prototype of the destructor
     */
    def validateVtableDtor (self, dmut context : &Validator, sym : &ClassSymbol, clRef : &ClassRefType, ancestor : &Type)-> &Value
        throws &ErrorMsg
    {
        context;
        sym;
        clRef;
        ancestor;
        __pragma!fake_throw (&ErrorMsg);
        __pragma!panic ();
    }    
            
    /**
     * ================================================================================
     * ================================================================================
     * =========================           CHECKING           =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * @returns: true if the class was already validated, or is currently in validation
     */
    def checkValidation (self, sym : &ClassSymbol)-> bool {
        match sym.getClassRef () {
            EmptyGenerator () => {
                for it in self._validation {
                    if it is sym {
                        return true;
                    }
                }
                
                false
            }
            _ => { true }            
        }
    }
    
}
