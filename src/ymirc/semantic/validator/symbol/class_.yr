mod ymirc::semantic::validator::symbol::class_;

import ymirc::semantic::validator::visitor;
import ymirc::semantic::validator::errors;
import ymirc::semantic::symbol::_;
import ymirc::syntax::declaration::protection;
import ymirc::syntax::expression::_;
import ymirc::syntax::declaration::_;

import ymirc::syntax::keys;
import ymirc::semantic::generator::_;
import ymirc::errors::_;
import ymirc::utils::format;
import ymirc::lexing::word;

import std::collection::vec;
import std::io, std::fs::path;
import std::collection::set;

/**
 * The class validator is the class responsible for class symbol validation
 */
pub class ClassValidator {    

    /// The list of class symbols currently in validation to avoid infinite recursion, and validating multiple times the same symbol
    let dmut _validation = HashSet!{&Symbol}::new ();
    
    /// The list of class symbol that were found during the validation, but that needs to be fully validated once everything is done
    let dmut _postValidation = HashSet!{&Symbol}::new ();
    
    /**
     * Create a new empty validator
     */
    pub self () {}

    /**
     * Validate an class symbol
     * @info: this validation is "in module", meaning that this function must be called only for complete validation and generation of symbols     
     * @params: 
     *    - context: the context of the validation
     *    - sym: the symbol to validate
     * @throws:
     *    - &ErrorMsg, if the class is malformed
     */
    pub def validate (self, dmut context : &Validator, dmut sym : &ClassSymbol)
        throws &ErrorMsg
    {
        // This function can be called only if we are in a "in module validation", meaning that the symbol was found traversing the symbol tree
        // Thus it is in the module that is currently validated, so we force the validation, this only happen one time in any case
        // For an "out module validation" use validateOutModule, as it is found from a value (varref, multsym, etc.)
        self.validateClassContent (alias context, alias sym);

        match sym.getTypeInfo () {
            ClassRefType () => {
                // The validation of the class succedeed, but maybe it created some other class validation that are incomplete
                if (self._validation.len () == 0us && self._postValidation.len () != 0us) { // self._validation.len () is always 0, no ?
                    self.postValidateAll (alias context); // so we need to validate them
                }
            }
            err : &ErrorGenerator => { // The class was validated in a previous call, but failed so the generator is an error
                throw ErrorMsg::fatal (sym.getLoc (), format (ValidateErrorMessage::INCOMPLETE_TYPE_CLASS, sym.getPath ().toStr ()), notes-> [err.getErrorMessage ()]);
            }
            _ => { // There is something else in the class ? 
                __pragma!panic ();
            }
        };
    }

    /**
     * Validate a class symbol
     * @info: this validation is "out module", meaning that the class was found inside a value (e.g. varref), and a full validation is not necessary
          * @params: 
     *    - context: the context of the validation
     *    - sym: the symbol to validate
     * @returns: the type of the class (classref)
     * @throws:
     *    - &ErrorMsg, if the class is malformed
     */
    pub def validateOutModule (self, dmut context : &Validator, dmut sym : &ClassSymbol)-> &ClassRefType
        throws &ErrorMsg
    {
        context;
        sym;
        __pragma!fake_throw (&ErrorMsg);
        __pragma!panic ();
    }    

    /**
     * ================================================================================
     * ================================================================================
     * =========================       INNER VALIDATION       =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate the content of a class (fields, methods, etc.)
     * @params: 
     *   - context: the context of the validation
     *   - sym: the symbol to validate
     * @throws:
     *   - &ErrorMsg: if the class is malformed
     */
    def validateClassContent (self, dmut context : &Validator, dmut sym : &ClassSymbol)
        throws &ErrorMsg
    {
        context;
        sym;
        __pragma!fake_throw (&ErrorMsg);
        __pragma!panic ();
    }

    /**
     * Validate the content of all the pre validated classes 
     * @params: 
     *   - context: the context of the validation
     * @throws:
     *   - &ErrorMsg: if one or more of the class are malformed
     */
    def postValidateAll (self, dmut context : &Validator)
        throws &ErrorMsg
    {
        context;
        __pragma!fake_throw (&ErrorMsg);
        __pragma!panic ();
    }
    
    /**
     * ================================================================================
     * ================================================================================
     * =========================           CHECKING           =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * @returns: true if the class was already validated, or is currently in validation
     */
    def checkValidation (self, sym : &ClassSymbol)-> bool {
        match sym.getTypeInfo () {
            EmptyGenerator () => {
                for it in self._validation {
                    if it is sym {
                        return true;
                    }
                }
                
                false
            }
            _ => { true }            
        }
    }
    
}
