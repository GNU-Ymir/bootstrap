mod ymirc::semantic::validator::symbol::class_;

import ymirc::semantic::validator::visitor;
import ymirc::semantic::validator::errors;
import ymirc::semantic::symbol::_;
import ymirc::syntax::declaration::protection;
import ymirc::syntax::expression::_;
import ymirc::syntax::declaration::_;

import ymirc::syntax::keys;
import ymirc::semantic::generator::_;
import ymirc::errors::_;
import ymirc::utils::format;
import ymirc::lexing::word;

import std::collection::vec;
import std::io, std::fs::path;
import std::collection::set;

/**
 * The class validator is the class responsible for class symbol validation
 */
pub class ClassValidator {    

    /// The list of class symbols currently in validation to avoid infinite recursion, and validating multiple times the same symbol
    let dmut _validation = HashSet!{&Symbol}::new ();
    
    /// The list of class symbol that were found during the validation, but that needs to be fully validated once everything is done
    let dmut _postValidation = HashSet!{&Symbol}::new ();
    
    /**
     * Create a new empty validator
     */
    pub self () {}

    /**
     * Validate an class symbol
     * @info: 
     * @params: 
     *    - context: the context of the validation
     *    - sym: the symbol to validate
     *    - inModule: iif true, this validation is "in module", "out module" otherwise meaning that the class was found inside a value (e.g. varref), and a full validation is not necessary
     * @throws:
     *    - &ErrorMsg, if the class is malformed
     */
    pub def validate (mut self, dmut context : &Validator, dmut sym : &ClassSymbol, inModule : bool)-> &ClassRefType
        throws &ErrorMsg
    {
        if (inModule || !self.checkValidation (sym)) {
            self:.validateClassContent (alias context, alias sym, inModule-> inModule);
        }

        match sym.getTypeInfo () {
            r : &ClassRefType => {
                // The validation of the class succedeed, but maybe it created some other class validation that are incomplete
                if (self._validation.len () == 0us && self._postValidation.len () != 0us) { // self._validation.len () is always 0, no ?
                    self.postValidateAll (alias context); // so we need to validate them
                }

                return r;
            }
            err : &ErrorGenerator => { // The class was validated in a previous call, but failed so the generator is an error
                throw err.getErrorMessage ();
            }
            _ => {
                __pragma!panic ();
            }
        };
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================       INNER VALIDATION       =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate the content of a class (fields, methods, etc.)
     * @params: 
     *   - context: the context of the validation
     *   - sym: the symbol to validate
     *   - inModule: if true, then the methods of the class are validated and inserted in the generators of the context
     * @throws:
     *   - &ErrorMsg: if the class is malformed
     */
    def validateClassContent (mut self, dmut context : &Validator, dmut sym : &ClassSymbol, inModule : bool)
        throws &ErrorMsg
    {        
        let dmut _ = Vec!{&ErrorMsg}::new ();

        // The validation of the class is not finished
        // a recursive reference to itself in ancestor will lead to infinite loop, we want to avoid that
        sym:.setTypeInfo (ErrorGenerator::new (sym.getLoc (), ErrorMsg::fatal (sym.getLoc (), ValidateErrorMessage::FORWARD_REFERENCE_TYPE)));

        // We add the symbol to avoid infinite loops
        self._validation:.insert (sym);
        
        // First we need to validate the ancestor of the class, to generate the vtable, the child class vtable being an override of the one of the ancestor
        let _ = self.validateAncestor (alias context, alias sym);

        inModule;
        __pragma!fake_throw (&ErrorMsg);
        __pragma!panic ();    
    } exit {
        self._validation:.remove (sym);
    }

    /**
     * Validate the ancestor of the class
     * @params: 
     *    - context: the context of the validation
     *    - sym: the class symbol whose ancestor will be validated
     * @returns: the ancestor type (NoneType, if the class does not have an ancestor)
     * @throws:
     *   - &ErrorMsg: if the validation failed
     */
    def validateAncestor (self, dmut context : &Validator, dmut sym : &ClassSymbol)-> &Type
        throws &ErrorMsg
    {
        match sym.getAncestor () {
            EmptyExpression () => { NONE_TYPE } // No ancestor specified
            ancestor : &Expression => {                
                let type = {
                    context:.validateType (ancestor)
                } catch {
                    err : &ErrorMsg => {
                        throw err.withNote ([ErrorMsg::note (ancestor.getLoc (), ValidateErrorMessage::VALIDATING)]);
                    }
                };
                
                match type {
                    cr : &ClassRefType => { // The ancestor class must be a class, obviously
                        if (cr.getSymbol ().isFinal ()) { // and it cannot be final
                            throw ErrorMsg::fatal (ancestor.getLoc (), format (ValidateErrorMessage::INHERIT_FINAL_CLASS, cr));
                        }
                        
                        cr
                    }
                    x : _ => { // This is not a class, cannot inherit non class types
                        throw ErrorMsg::fatal (ancestor.getLoc (), format (ValidateErrorMessage::INHERIT_NO_CLASS, x));
                    }
                }
            }
        }
    }   
    
    /**
     * Validate the content of all the pre validated classes 
     * @params: 
     *   - context: the context of the validation
     * @throws:
     *   - &ErrorMsg: if one or more of the class are malformed
     */
    def postValidateAll (self, dmut context : &Validator)
        throws &ErrorMsg
    {
        context;
        __pragma!fake_throw (&ErrorMsg);
        __pragma!panic ();
    }
    
    /**
     * ================================================================================
     * ================================================================================
     * =========================           CHECKING           =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * @returns: true if the class was already validated, or is currently in validation
     */
    def checkValidation (self, sym : &ClassSymbol)-> bool {
        match sym.getTypeInfo () {
            EmptyGenerator () => {
                for it in self._validation {
                    if it is sym {
                        return true;
                    }
                }
                
                false
            }
            _ => { true }            
        }
    }
    
}
