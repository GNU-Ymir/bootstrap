in class_;

use ymirc::semantic::validator::{visitor, errors};
use ymirc::semantic::declarator::errors;
use ymirc::semantic::{generator::_, symbol::_};
use ymirc::syntax::{expression::_, declaration::_};

use ymirc::syntax::keys;
use ymirc::errors::_;
use ymirc::utils::{format, log, string};
use ymirc::lexing::word;
use ymirc::global::core_;
use std::{stream, io};

use ymirc::semantic::generator::type::{_,
                                       custom::_,
                                       native::{_, scalar::_, compound::_},
                                       temporary::_};

use ymirc::semantic::generator::value::{_,
                                        construct::{_, delegate::_},
                                        literal::_,
                                        memory::_,
                                        operator::{_, binary::_, call::_, fields::_, map::_, slice::_, unary::_},
                                        operator::map::iteration::_,
                                        prototypes::_,
                                        scope::_,
                                        syntax::_,
                                        template::_};


def MAX_RECURSIVE_LEVEL = 3;

/**
 * The class validator is the class responsible for class symbol validation
 */
@final
pub class ClassValidator {    

    // The list of class symbols currently in validation to avoid infinite recursion,
    // and validating multiple times the same symbol
    let mut _validation : [&Symbol => mut u32] = copy [];

    // The list of class symbol to finalize when self._validation.len == 0
    let mut _toFinalize : [&Symbol => dmut &ClassSymbol] = copy [];

    /**
     * Create a new empty validator
     */
    pub self () {}

    /**
     * Validate an class symbol
     * @info: 
     * @params: 
     *    - context: the context of the validation
     *    - sym: the symbol to validate
     *    - inModule: iif true, this validation is "in module", "out module" otherwise meaning that the class was found inside a value (e.g. varref), and a full validation is not necessary
     * @throws:
     *    - &ErrorMsg, if the class is malformed
     */
    pub fn validate (mut self, dmut context : &Validator, dmut sym : &ClassSymbol, inModule : bool)-> &ClassRefType
        throws ErrorMsg
    {
        // We don't validate if we already have an error
        if (!sym.getErrorGenerator ().hasValue) {

            if !sym.getClassRef ().hasValue {
                sym:.setClassRef (copy ClassRefType (sym.getLoc (), sym));
            }

            let validationLevel = if inModule { 1u32 } else { self.checkValidation (sym) };
            if validationLevel < MAX_RECURSIVE_LEVEL {
                self:.validateClassLayout (alias context, alias sym, inModule-> inModule, validationLevel-> validationLevel);
            }

            // If there is no error in the prototype of the class, and we are inModule, then we add it to finalizable classes
            if let Err () = sym.getErrorGenerator () && inModule {
                self._toFinalize [sym] = (alias sym);
            }

            if self._validation.len == 0 {
                self:.finalizeClassSymbols (alias context);
            }

            if let Ok (r) = sym.getClassRef () {
                return r;
            }
        }

        // not else, we might set the error within the previous if
        if let Ok (err) = sym.getErrorGenerator () {

            // The class was validated by self.validateClassContent, but it failed so the generator is an error
            // we simply throw it, unfortunately it will leads to printing the same error multiple times, but I don't see any way to avoid that efficiently (while making sure the error is at least printed one time)
            // Maybe add a uniq identifier to errors, and perform the verification directly in the error printing part
            throw err.getErrorMessage ();
        }

        panic;
    }

    /**
     * Finalize all the class symbols that need finalization when validation levels reaches 0 (to avoid forward complex dependencies)
     * */
    pub fn finalizeClassSymbols (mut self, dmut context : &Validator)
        throws ErrorMsg
    {
        let dmut toFinalize = alias self._toFinalize;
        self._toFinalize = copy [];

        let dmut errors : [&ErrorMsg] = [];
        for _, dmut sym in alias toFinalize {
            let r = sym:.getClassRefForce ();
            {
                logging::info ("Finalize class symbol %", sym.getPath ());
                self:.finalizeClassValidation (alias context, alias sym, r);
            } catch {
                err : &ErrorMsg => {
                    errors ~= [err];
                }
            }
        }

        if errors.len != 0 {
            throw copy ErrorMsg::list (errors);
        }
    }


    /*!
     * ================================================================================
     * ================================================================================
     * =========================          FINALIZER           =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Finalize the validation of the methods of the class
     * @params:
     *    - context: the context of the validation
     *    - sym: the symbol to finalize
     *    - clRef: the type of the class to validate
     * @throws:
     *    - &ErrorMsg: if there was an error in the validation
     */
    pub fn finalizeClassValidation (mut self, dmut context : &Validator, dmut sym : &ClassSymbol, clRef : &ClassRefType)
        throws ErrorMsg
    {
        let mut errors : [&ErrorMsg] = [];
        let dmut addMethods = sym:.getAddMethods ();
        for i in 0us .. addMethods.len {
            {
                match alias (addMethods [i]) {
                    dmut funcSym : &FunctionSymbol => { // Simply validate all the new symbols of the class
                        context:.getFunctionValidator ():.validateMethod (alias context, alias funcSym, clRef);
                    }
                    dmut ctorSym : &ConstructorSymbol => { // Validate the constructor symbol
                        context:.getFunctionValidator ():.validateConstructor (alias context, alias ctorSym, clRef);
                    }
                    dmut dtorSym : &DestructorSymbol => {
                        context:.getFunctionValidator ():.validateDestructor (alias context, alias dtorSym, clRef);
                    }
                    _ => panic; // we inserted a symbol that is not a function in the addMethods ??
                }
            } catch {
                e : &ErrorMsg => {
                    errors ~= [e];
                }
            }
        }

        if (errors.len != 0us) { // error validating the methods
            let error = copy ErrorMsg::fatal (sym.getLoc (), ValidateErrorMessage::VALIDATING, notes-> errors);
            context:.insertMissingGenerator (error);
            if (sym.isTemplate ()) {
                sym:.setErrorGenerator (copy ErrorGenerator (sym.getLoc (), error));
            }

            throw error;
        }

        context:.insertGenerator (alias sym, clRef);
    }    

    /*!
     * ================================================================================
     * ================================================================================
     * =========================       INNER VALIDATION       =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate the class layout of a class
     *
     * */
    pub fn validateClassLayout (mut self, dmut context : &Validator, dmut sym : &ClassSymbol, inModule : bool = false, validationLevel : u32 = 2u32) {
        self._validation [sym] = validationLevel + 1;

        {
            context:.pushReferent (alias sym);
            context:.enterForeign (isFnBody-> false);

            logging::info ("Validate class layout % (%)", sym.getPath (), validationLevel);

            // This cannot throw (cf. the function def)
            self:.validateClassContent (alias context, alias sym, inModule, validationLevel);
        } exit {
            context:.exitForeign ();
            context:.popReferent ();

            if validationLevel == 1 {
                self._validation:.remove (sym);
            }
        }
    }

    /**
     * Validate the content of a class (fields, methods, etc.)
     * @warning: does not throw an error, but write it in the generator of the class if there was any.
     * @params: 
     *   - context: the context of the validation
     *   - sym: the symbol to validate
     *   - inModule: if true, then the methods of the class are validated and inserted in the generators of the context
     */
    fn validateClassContent (mut self, dmut context : &Validator, dmut sym : &ClassSymbol, inModule : bool, validationLevel : u32) {
        {            
            // First we need to validate the ancestor of the class, to generate the vtable, the child class vtable being an override of the one of the ancestor
            let ancestor = self:.validateAncestor (alias context, alias sym);

            // Validate the static assertions of the class definition (@warning: this is only performed if the validation is a root validation-> self._validation.len == 1us, to avoid too deep and unreadable errors)
            self.validateCtes (alias context, alias sym);

            // Validate the ctors prototypes of the class
            // Ctors does not need fields to be validated
            self.validateConstructors (alias context, alias sym, inModule, validationLevel > 1);

            // Validate the vtable (without validating the method bodies, just the prototypes)
            self.validateVtable (alias context, alias sym, ancestor, inModule, validationLevel > 1);

            // Validate the fields of the class
            // But fields might need the ctors of other class to be validated
            self.validateFields (alias context, alias sym, ancestor, validationLevel > 1);

            // Validate the default movable ctor if the symbol is an entity
            self.validateMovableCtors (alias context, alias sym, inModule);

            // Validate the dtor of the class
            self.validateDestructor (alias context, alias sym, ancestor, inModule);

            // Validate the typeinfo of the class
            self.validateTypeInfo (alias context, alias sym);

        } catch {
            err : &ErrorMsg => {
                // If there is an error in the validation, then write it in the type validation
                // Then each time a validation is tried, the same error is sent without needing a new validation

                sym:.setErrorGenerator (copy ErrorGenerator (sym.getLoc (),
                                                             copy ErrorMsg::fatal (sym.getLoc (), ValidateErrorMessage::VALIDATING,
                                                                                   notes-> copy [err])));
            }
        }
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================           ANCESTOR           =========================
     * ================================================================================
     * ================================================================================
     */
    
    /**
     * Validate the ancestor of the class
     * @params: 
     *    - context: the context of the validation
     *    - sym: the class symbol whose ancestor will be validated
     * @returns: the ancestor type (NoneType, if the class does not have an ancestor)
     * @throws:
     *   - &ErrorMsg: if the validation failed
     */
    fn validateAncestor (mut self, dmut context : &Validator, dmut sym : &ClassSymbol)-> (&ClassRefType)?
    throws ErrorMsg
    {
        match sym.getAncestor () {
            EmptyExpression () => {} // No ancestor specified
            ancestor : &Expression => {                                
                let type = context:.validateType (ancestor);
                // an error was set to the type while validating its ancestor
                if let Ok (err) = sym.getErrorGenerator () {
                    throw err.getErrorMessage ();
                }

                match type {
                    ancRef : &ClassRefType => { // The ancestor class must be a class, obviously
                        if (ancRef.getSymbol ().isFinal ()) { // and it cannot be final
                            throw copy ErrorMsg::fatal (ancestor.getLoc (), format (ValidateErrorMessage::INHERIT_FINAL_CLASS, ancRef));
                        }

                        // if it is a class ref, and not final then no problem, it can be an ancestor
                        let dmut cref = alias sym:.getClassRefForce ();
                        cref:.setAncestor (ancRef);
                        self.checkRecursiveAncestor (cref);

                        if !ancRef.hasTypeInfo () {
                            if let dmut ancSym : &ClassSymbol = context:.getClassFromRef (ancRef.getSymbol ()) {
                                self:.validateClassLayout (alias context, alias ancSym, inModule-> false, validationLevel-> 2u32);
                            } else panic;
                        }

                        return ancRef?;
                    }
                    x => { // This is not a class, cannot inherit non class types
                        throw copy ErrorMsg::fatal (ancestor.getLoc (), format (ValidateErrorMessage::INHERIT_NO_CLASS, x));
                    }
                }
            }
        }

        none
    }
    
    /*!
     * ================================================================================
     * ================================================================================
     * =========================             CTES             =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate the static assertion of a class symbol
     * @warning: 
     * ----------------
     * the validation is only performed on root validation (meaning iif self._validation.len == 1us)
     * In order to avoid too deep errors, and complex error handling
     * ----------------
     * @params: 
     *    - context: the context of the validation
     *    - sym: the symbol to validate
     * @throws:
     *   - &ErrorMsg: if some assertion were invalid, or not true
     */
    fn validateCtes (self, dmut context : &Validator, dmut sym : &ClassSymbol)
        throws ErrorMsg
    {
        if !sym.getCondBlockValidated () {
            self.validateCondBlocks (alias context, alias sym);
            let mut errors : [&ErrorMsg] = [];

            if (sym.getAssertions ().len != 0us) {
                context:.enterForeign (isFnBody-> false); // There are not inside function

                for it in sym.getAssertions () {
                    context:.validateCteValue (it); // validate the assertion
                } catch {
                    err : &ErrorMsg => { errors ~= [err]; }
                }

                context:.exitForeign ();
            }

            sym:.setCondBlockValidated ();

            // Some assertion failed
            if (errors.len != 0us) throw copy ErrorMsg::list (errors);
        }
    }
    
    /**
     * Validate the list of conditional block in the class
     * @params: 
     *    - context: the context of the validation
     *    - sym: the class to validate
     * @throws:
     *    - &ErrorMsg: if the validation fails
     */
    fn validateCondBlocks (self, dmut context : &Validator, dmut sym : &ClassSymbol)
        throws ErrorMsg
    {
        let mut errors : [&ErrorMsg] = [];
        if (sym.getCondBlocks ().len != 0us) {
            context:.enterForeign (isFnBody-> false); // There are not inside function

            for it in sym.getCondBlocks () { 
                self.validateCondBlock (alias context, it, alias sym);
            } catch { 
                err : &ErrorMsg => { errors ~= [err]; }
            }

            if (errors.len == 0) {
                context:.getDeclarator ():.finalizeDeclaration (alias sym);
            } catch {
                err : &ErrorMsg => { errors ~= [err]; }
            }

            context:.exitForeign ();
        }

        // Some cond block validation failed
        if (errors.len != 0us) throw copy ErrorMsg::list (errors);
    }

    /**
     * Validate a declaration from a conditional block
     * @params: 
     *    - context: the context of the validation
     *    - decl: the declaration to validate
     *    - sym: the symbol of the class being validated
     * @throws:
     *    - &ErrorMsg: if the validation fails
     */
    pub fn validateCondBlock (self, dmut context : &Validator, decl : &Declaration, dmut sym : &ClassSymbol)
        throws ErrorMsg
    {
        match decl {
            c : &CondBlockDecl => {
                let val = context:.validateValue (c.getTest ());
                let b = context:.getCompileTimeInterpreter ():.computeBool (val);
                if (b) {
                    for j in c.getDeclarations () {
                        self.validateCondBlock (alias context, j, alias sym);
                    }
                } else {
                    self.validateCondBlock (alias context, c.getElse (), alias sym);
                }                                
            }
            _ => {
                context:.getDeclarator ():.declareInnerClass (decl, alias sym, protection-> Protection::PROTECTED);
            }
        }
    }
    

    /*!
     * ================================================================================
     * ================================================================================
     * =========================            FIELDS            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate the fields of a class symbol, and populate the class definition
     * @params: 
     *   - context: the context of the validation
     *   - sym: the symbol to validate
     *   - ancestor: the ancestor type of the class
     *   - inModule: true if the validation of the class is "in module"
     * @throws:
     *   - &ErrorMsg: if there is an error in the validation of the fields
     */
    fn validateFields (self, dmut context : &Validator, dmut sym : &ClassSymbol, ancestor : (&ClassRefType)?, precary : bool)
        throws ErrorMsg
    {
        // Update the class type info definition in the symbol, so it has access to the fields
        let dmut cref = alias sym:.getClassRefForce ();
        let localFields = self.validateLocalFields (alias context, alias sym, alias cref, precary); // Validate the fields declared in the class def
        if let Ok (cl) = ancestor {
            self.verifyFieldCollisions (cl.getFields (), localFields);
        }

        self.verifyFieldCollisionsMethods (localFields, cref.getVtable ());
    }

    /**
     * Validate the fields that are declared in the class definition
     * @params : 
     *    - context: the context of the validation
     *    - sym: the symbol whose field we will validate
     * @returns: The list of validated fields
     * @throws:
     *    - &ErrorMsg: if there was an error in one or more field validation
     */
    fn validateLocalFields (self, dmut context : &Validator, dmut sym : &ClassSymbol, dmut cref : &ClassRefType, precary : bool)-> [&VarDeclValue]
        throws ErrorMsg
    {
        context:.enterForeign (isFnBody-> false); // A new foreign, we don't wan't to pollute current context
        context:.enterBlock (); // A block, we will add variable definitions

        let mut errors : [&ErrorMsg]         = [];
        let mut fields : [mut &VarDeclValue] = copy [copy VarDeclValue (f.getLoc (), ERROR_TYPE, UNIT_VALUE, isMutable-> false) for f in sym.getFields ()];
        let mut names  : [[c8] => mut &Word] = copy [];
        cref:.setFields (fields);

        for i, f in sym.getFields () {
            {
                // Fields are just like variable decls
                let (isMut, isLazy, type, value) = self.validateFieldDecl (alias context, f, noValue-> precary);
                if (!sym.isEntity ()) {
                    if (type.isMovable ()) {
                        if (!sym.isStruct ()) {
                            throw copy ErrorMsg::fatal (f.getLoc (), end-> type.getLoc (), format (ValidateErrorMessage::CONTAIN_MOVABLE_TYPE, type),
                                                        notes-> copy [copy ErrorMsg::note (sym.getLoc (), format (ValidateErrorMessage::CONTAIN_MOVABLE_TYPE_NOTE))]);
                        } else {
                            throw copy ErrorMsg::fatal (f.getLoc (), end-> type.getLoc (), format (ValidateErrorMessage::CONTAIN_MOVABLE_TYPE, type),
                                                        notes-> copy [copy ErrorMsg::note (sym.getLoc (), format (ValidateErrorMessage::CONTAIN_MOVABLE_TYPE_RECORD))]);
                        }
                    }

                    if (sym.isUnion () && self.checkFieldBorrowingUnion (type)) {
                        throw copy ErrorMsg::fatal (f.getLoc (), end-> type.getLoc (), format (ValidateErrorMessage::CONTAIN_ALIASABLE_TYPE, type),
                                                    notes-> copy [copy ErrorMsg::note (sym.getLoc (), format (ValidateErrorMessage::CONTAIN_ALIASABLE_TYPE_NOTE))]);
                    }
                }


                let dmut field = copy VarDeclValue (f.getLoc (), type, value, isMutable-> isMut, isLazy-> isLazy);

                // we need to verify shadow ourselves, since we removed all locals at each iteration
                self.verifyShadow (ref names, field);

                // We add the validated field
                fields [i] = field;
            } catch {
                err : &ErrorMsg => {
                    errors ~= [err];
                }
            }
        }

        context:.quitBlock (warnUnused-> false); // We entered a block at the beginning of the function
        context:.exitForeign (); // We entered a foreign

        if (!precary && errors.len != 0us) throw copy ErrorMsg::list (errors);

        cref:.setFields (fields);
        fields // returning the list of fields
    }


    /**
     * Validate a field
     * @params:
     *    - context: the context of the validation
     *    - param: the parameter to validate
     *    - noValue: true iif we are recursevely validating and thus the value must not be validated (cf. Recursive default parameters)
     * @throws: &ErrorMsg, if there is an error
     * @returns:
     *    - .0: true iif the parameter is declared mutable
     *    - .1: true iif the parameters is declared as lazy
     *    - .2: the type of the parameter
     *    - .3: the value of the parameter
     */
    fn validateFieldDecl (self, dmut context : &Validator, vdecl : &VarDeclExpr, noValue : bool = false)-> (bool, bool, &Type, &Value)
        throws ErrorMsg
    {
        let type = {
            context:.validateTypeForVarDecl (vdecl.getType (), vdecl, canBeRef-> false, canBeLazy-> true)
        } catch {
            err : &ErrorMsg => {
                throw copy ErrorMsg::note (vdecl.getLoc (), ValidateErrorMessage::VALIDATING, notes-> copy [err]);
            }
        };

        let value : &Value = if vdecl.getValue () !of EmptyExpression && !noValue {
            if (vdecl.getLoc () == Keys::UNDER) { // variable with a default value must have a name, otherwise it is impossible to change them
                throw copy ErrorMsg::fatal (vdecl.getLoc (), ValidateErrorMessage::DEFAULT_VAR_NO_NAME, notes-> copy [copy ErrorMsg::note (vdecl.getValue ().getLoc (), ""s8)]);
            }

            context:.validateValue (vdecl.getLoc (), vdecl.getValue (), type-> type)
        } else {
            UNIT_VALUE
        };

        context.verifyNonVoidType (vdecl.getType ().getLoc (), type, true);
        return (type.isMutable (), vdecl.isLazy (), type, value);
    }

    /**
     * Verify that an union is not containing fields borrowing data, with the exception of pointers
     * */
    fn checkFieldBorrowingUnion (self, type : &Type)-> bool
        throws ErrorMsg
    {
        if (!type.borrowDatas ()) return false;
        match type {
            PointerType () => return false;
            t : &TupleType => {
                for j in t.getInners () {
                    if (self.checkFieldBorrowingUnion (j)) return true;
                }
                return false;
            }
            a : &ArrayType => {
                return self.checkFieldBorrowingUnion (a.getInners ()[0]);
            }
            o : &OptionType => {
                return self.checkFieldBorrowingUnion (o.getInners ()[0]);
            }
            f : &FutureType => {
                return self.checkFieldBorrowingUnion (f.getInners ()[0]);
            }
            c : &ClassPtrType => {
                if c.isRecord () || c.isUnion () {
                    {
                        for j in c.getInner ().getFields () match j {
                            v : &VarDeclValue => {
                            if (self.checkFieldBorrowingUnion (v.getVarType ())) return true;
                            }
                        }
                    } catch { _ => {} } // error generator in the symbol

                    return false;
                }
            }
            e : &EnumType => {
                return self.checkFieldBorrowingUnion (e.getProxy ());
            }
        }

        true
    }

    /**
     * Verify that there is no collision between fields declared in ancestor class, and fields declared in local class
     * @params:
     *   - context: the context of the validation
     *   - ancestorFields: the list of fields declared in ancestor classes
     *   - localFields: the list of fields declared in local class
     * @throws:
     *   - &ErrorMsg: if there is a collision
     */
    fn verifyFieldCollisions (self, ancestorFields : [&Value], localFields : [&Value])
        throws ErrorMsg
    {
        let mut errors : [&ErrorMsg] = [];

        // These loops are pretty self explanatory, we just traverse the fields and verify that there is no common names in local and ancestor fields
        for lt_ in localFields if let lvar : &VarDeclValue = lt_ {
            let mut lst : [&ErrorMsg] = [];
            for at_ in ancestorFields if let avar : &VarDeclValue = at_ {
                if (lvar.getLoc ().str == avar.getLoc ().str) {
                    lst ~= [copy ErrorMsg::note (avar.getLoc (), oneLine-> true, ValidateErrorMessage::DECLARED_HERE)];
                }
            }

            if lst.len != 0 {
                errors ~= [copy ErrorMsg::fatal (lvar.getLoc (), // Shadowing error
                                                 format (ValidateErrorMessage::SHADOWING_DECL,
                                                         lvar.getLoc ().str),
                                                 notes-> lst)];
            }
        }

        if (errors.len != 0us) throw copy ErrorMsg::list (errors); // There are collisions
    }

    /**
     * Verify that there is no collision between fields declared in local class and methods
     * @params:
     *   - context: the context of the validation
     *   - localFields: the list of fields declared in local class
     *   - vtable: the vtable of the class
     * @throws:
     *   - &ErrorMsg: if there is a collision
     */

    fn verifyFieldCollisionsMethods (self, localFields : [&Value], vtable : [&MethodPrototypeValue])
        throws ErrorMsg
    {
        let mut errors : [&ErrorMsg] = [];

        for lt in localFields if let lvar : &VarDeclValue = lt {
            let dmut lst : [&ErrorMsg] = [];

            for at in vtable {
                if (lvar.getLoc ().str == at.getSymbol ().getPath ().file ()) {
                    lst ~= [copy ErrorMsg::note (at.getLoc (), oneLine-> true, ValidateErrorMessage::DECLARED_HERE)];
                }
            }

            if lst.len != 0 {
                errors ~= [copy ErrorMsg::fatal (lvar.getLoc (), // Shadowing error
                                                 format (ValidateErrorMessage::SHADOWING_DECL,
                                                         lvar.getLoc ().str),
                                                 notes-> lst)];
            }
        }

        if (errors.len != 0us) throw copy ErrorMsg::list (errors); // There are collisions
    }

    

    /**
     * Verify that there is no shadowing in field declarations
     * @params:
     *    - dones: the list of already declared fields
     *    - field: the newly declared field
     * @throws:
     *    - &ErrorMsg: if there is a shadowing problem
     * */
    fn verifyShadow (self, ref mut dones : [[c8] => mut &Word], v : &VarDeclValue)
        throws ErrorMsg
    {
        if let Ok (l) = dones [v.getLoc ().str] {
            throw copy ErrorMsg::fatal (v.getLoc (), format (ValidateErrorMessage::SHADOWING_DECL, v.getLoc ().str),
                                        notes-> copy [copy ErrorMsg::note (l, ValidateErrorMessage::FIRST_DEFINED)]);
        }

        dones [v.getLoc ().str] = v.getLoc ();
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================            CTORS             =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate the constructors of a class symbol
     * @assume: the vtable and fields of the class are already validated
     * @params: 
     *     - context: the context of the validation
     *     - sym: the class sybmol to validate
     *     - ancestor: the ancestor of the class symbol
     * @throws:
     *     - &ErrorMsg: if there is an error in the validation
     */
    fn validateConstructors (self, dmut context : &Validator, dmut sym : &ClassSymbol, inModule : bool, noValue : bool)
        throws ErrorMsg
    {
        let dmut cref = alias sym:.getClassRefForce ();

        let mut errors    : [&ErrorMsg]           = [];
        let mut ctors     : [&CtorPrototypeValue] = []; // list of ctor prototypes
        let mut ctorProts : [MethodProtection]    = []; // Protection of constructors

        let mut templateCtors     : [&TemplateRefCtorValue] = [];
        let mut templateCtorProts : [MethodProtection]      = [];

        for it in sym.getAllLocalSymbols (protection-> Protection::PRIVATE) { // traverse all contructor and validate their prototypes
            {
                match it {
                    ctor : &ConstructorSymbol => { // If this is a constructor we validate its constructor
                        match context:.getSymbolFromRef (ctor) {
                            dmut mutCtor : &ConstructorSymbol => {
                                self.validateConstructorProto (alias context, alias mutCtor, cref, ref ctors, ref ctorProts, noValue);
                                if inModule {
                                    // Add the symbol for finalization (if 'in module')
                                    sym:.insertAddMethod (alias mutCtor);
                                }
                            }
                            _ => panic;
                        }
                    }
                    tmp : &TemplateSymbol => {
                        match tmp.getContent ().getContent () {
                            _ : &ConstructorDecl => {
                                self.validateTemplateConstructorProto (alias context, tmp, cref, ref templateCtors, ref templateCtorProts);
                            }
                        }
                    }
                }
            } catch {
                err : &ErrorMsg => {
                    errors ~= [err];
                }
            }
        }

        if (errors.len != 0us) throw copy ErrorMsg::list (errors);

        // Update the class type info definition in the symbol, so we have access to the ctors of the class
        cref:.setCtors (ctors, ctorProts);
        cref:.setTemplateCtors (templateCtors, templateCtorProts);
    }

    /**
     * Validate the prototype of the constructor
     * @params:
     *    - context: the context of the validation
     *    - ctor: the constructor whose prototype to validate
     *    - clRef: the type of the class ref
     *    - ctorList: the list of already validated prototypes
     * @throws:
     *    - &ErrorMsg: if there is an error in the validation of the prototype (collision with other ctor, or an error in the types, etc..)
     * @returns:
     *    - ctorList: append the prototype of the ctor
     *    - ctorProts: append the protection of the ctor
     */
    fn validateConstructorProto (self, dmut context : &Validator, dmut ctor : &ConstructorSymbol, clRef : &ClassRefType, ref mut ctorList : [&CtorPrototypeValue], ref mut ctorProts : [MethodProtection], noValue : bool)
        throws ErrorMsg
    {
        let proto = context:.getFunctionValidator ():.validateCtorPrototype (alias context, alias ctor, clRef, noValue-> noValue);
        for it in ctorList {
            if self.isCtorSimilar (proto, it) {
                throw copy ErrorMsg::fatal (proto.getLoc (), end-> it.getLoc (), format (ValidateErrorMessage::COLLIDING_METHOD_DEFINITION, proto, it));
            }
        }

        ctorList ~= [proto];
        match ctor.getProtection () {
            Protection::PRIVATE   => { ctorProts ~= [MethodProtection::PRV]; }
            Protection::PROTECTED => { ctorProts ~= [MethodProtection::PROT]; }
            _                     => { ctorProts ~= [MethodProtection::PUB]; }
        };
    }

    /**
     * Validate a template constructor
     * @params:
     *     - context: the context of the validation
     *     - ctor: the template ctor (assuming it contains a template declaration, containing a constructor declaration)
     *     - clRef: the class ref being validated
     * @returns:
     *    - ctorList: append the prototype of the ctor
     *    - ctorProts: append the protection of the ctor
     * */
    fn validateTemplateConstructorProto (self, dmut context : &Validator, ctor : &TemplateSymbol, clRef : &ClassRefType, ref mut ctorList : [&TemplateRefCtorValue], ref mut ctorProts : [MethodProtection]) {
        context;
        clRef;

        ctorList ~= [copy TemplateRefCtorValue (ctor.getLoc (), clRef.getSymbol (), ctor)];
        match ctor.getProtection () {
            Protection::PRIVATE   => { ctorProts ~= [MethodProtection::PRV]; }
            Protection::PROTECTED => { ctorProts ~= [MethodProtection::PROT]; }
            _                     => { ctorProts ~= [MethodProtection::PUB]; }
        };
    }

    /**
     * Verify that the movable class contains the appropriate default an move ctors
     * @params:
     *    - ctors: the list of ctors of the struct type
     *    - sym: the symbol declaring the struct
     * */
    fn validateMovableCtors (self, dmut context : &Validator, dmut sym : &ClassSymbol, inModule : bool)
        throws ErrorMsg
    {
        if (sym.isEntity ()) {
            let dmut cref = alias sym:.getClassRefForce ();
            let oldCtors = cref.getCtors ();
            let oldCtorProts = cref.getCtorProtections ();

            let mut hasDefault = false;
            for it in oldCtors if let ct : &CtorPrototypeValue = it && (ct.getRename () == "" && it.getParameters ().len == 0) {
                hasDefault = true;
                break;
            }

            if (!hasDefault) {
                let nCtor = self.createDefaultCtor (alias context, alias sym, cref, inModule);
                cref:.setCtors (oldCtors ~ [nCtor], oldCtorProts ~ [MethodProtection::PUB]);
            } catch {
                err : &ErrorMsg => {
                    throw copy ErrorMsg::fatal (sym.getLoc (), format (ValidateErrorMessage::NO_DEFAULT_CTOR_MOVE_STRUCT, sym.getPath ()),
                                                notes-> copy [err]);
                }
            }
        }
    }

    /**
     * Create a ctors that init all field with default value
     * */
    fn createDefaultCtor (self, dmut context : &Validator, dmut sym : &ClassSymbol, cl : &ClassRefType, inModule : bool)-> &MethodPrototypeValue
        throws ErrorMsg
    {
        let mut errors : [&ErrorMsg] = [];
        for v in cl.getLocalFields () if let fi : &VarDeclValue = v && fi.getValue () of UnitValue {
            errors ~= [copy ErrorMsg::fatal (fi.getLoc (), format (ValidateErrorMessage::UNINIT_FIELD, fi.getLoc ().str))];
        }

        if (errors.len != 0us) throw copy ErrorMsg::list (errors);
        let rename = copy Word (Keys::SELF, sym.getLoc ());
        let proto = copy FunctionProtoDecl (rename, [], EMPTY_EXPR);
        let body = copy BlockExpr (rename, rename, []);

        let ctor = copy ConstructorDecl (rename, " * *default constructor, generated by the compiler*", proto, body);
        let dmut ctorSym : &ConstructorSymbol = context:.getDeclarator ().declareConstructor (ctor, alias sym, protection-> Protection::PUBLIC);
        if inModule {
            sym:.insertAddMethod (alias ctorSym);
        }

        return context:.getFunctionValidator ():.validateCtorPrototype (alias context, alias ctorSym, cl);
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================            VTABLE            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate the vtable of a class and populates the class symbol definition
     * @params:
     *    - context: the context of the validation
     *    - sym: the symbol to validate
     *    - ancestor: the type of the ancestor of the class
     * @throws:
     *    - &ErrorMsg: if there is an error in the vtable validation
     */
    fn validateVtable (self, dmut context : &Validator, dmut sym : &ClassSymbol, ancestor : (&ClassRefType)?, inModule : bool, noValue : bool)
        throws ErrorMsg
    {
        let dmut cref = alias sym:.getClassRefForce ();
        // Validate the vtable, and get the list of method prototypes, and their protections
        let (vtable, protection, implTraits, allImpls, templateMeths, templateProts) = self.validateVtable (alias context, alias sym, cref, ancestor, inModule, noValue);

        // Verify that all methods have a proper body
        // Only abstract class can have empty methods, because they don't generate a vtable
        let mut notes : [&ErrorMsg] = [];
        if (!sym.isAbstract ()) {
            for v in vtable if v.isEmpty () {
                notes ~= [copy ErrorMsg::note (v.getLoc (), format (ValidateErrorMessage::EMPTY_METHOD_NO_ABSTRACT, v, tags-> FormatTags (withParams-> true)),
                                               oneLine-> true, withLoc-> true)];
            }

            if (notes.len != 0us) {
                throw copy ErrorMsg::fatal (sym.getLoc (), format (ValidateErrorMessage::NON_ABSTRACT_NOT_COMPLETE, cref),
                                            notes-> notes);
            }
        }

        // Update the class type info definition in the symbol, so it has access to the vtable
        cref:.setVtable (vtable, protection, implTraits, allImpls, templateMeths, templateProts);
    }

    /**
     * Validate the vtable of the class declaration
     * @info: populate the addMethods in the class (the add methods are the methods that are not defined in parent class)
     * @params: 
     *    - context: the context of the validation
     *    - sym: the symbol to validate
     *    - clRef: the type of the class being validated (without vtable)
     *    - ancestor: the ancestor of the class
     * @throws: 
     *    - &ErrorMsg: if there is an error in the validation
     * @returns: 
     *    - .0: the list of methods prototype of the vtable
     *    - .1: the list of protection of the methods
     */
    fn validateVtable (self, dmut context : &Validator, dmut sym : &ClassSymbol, clRef : &ClassRefType, ancestor : (&ClassRefType)?, inModule : bool, noValue : bool)-> ([&MethodPrototypeValue], [MethodProtection], [&TraitRefType], [&TraitRefType], [&TemplateRefMethodValue], [MethodProtection])
        throws ErrorMsg
    {
        let mut vtable     : [mut &MethodPrototypeValue] = [];
        let mut prots      : [mut MethodProtection]      = [];
        let mut addMethods : [dmut &Symbol]          = [];
        let mut allImpls   : [&TraitRefType]         = [];
        let mut impls      : [&TraitRefType]         = [];

        let mut templateMeths : [&TemplateRefMethodValue] = [];
        let mut templateProts : [MethodProtection]        = [];
        
        // Ok, this part is complex, so hang in there.

        // Retreive the vtable of the ancestor, the vtable of the current class is an update of it, and same symbols must be located at the same place
        self.retreiveAncestorVtable (ancestor, ref vtable, ref prots, ref addMethods, ref allImpls, ref templateMeths, ref templateProts);

        // Create the vector containing all the methods defined in implemented traits
        let implemented = self.retreiveImplsVtable (alias context, sym, clRef, noValue, ref vtable, ref prots, ref addMethods);

        for i in implemented { impls ~= [i._1]; } // store the list of traits that were implemented by the class

        // At this point, vtable contains :
        //  1) All the methods declared in ancestor class
        //  2) All the methods declared in implemented traits
        // There is no method declared in the class (either new, over, of impl over) in the vtable
        // So we start by validating the methods that are declared outside implementations
        self.validateDirectVtable (alias context, sym, clRef, noValue, ref vtable, ref prots, ref addMethods, ref templateMeths, ref templateProts);

        // An now the methods that are declared inside implementations (overriding)
        self.validateImplsVtable (alias context, clRef, implemented, noValue, ref vtable, ref prots, ref addMethods);

        // Insert the symbol of the methods that has to be fully validated if the class is "in module"
        // These symbols are the methods that are declared inside the class (new, over or impl over)
        for i in 0us .. addMethods.len {
            let dmut meth = alias (addMethods [i]);
            match meth {
                EmptySymbol () => {} // if it is an empty symbol, then the method was declared in ancestor or trait, and put in the class as it was (not over)
                _ => {
                    if inModule {
                        sym:.insertAddMethod (alias meth); // The method is new or overriden
                    }
                }
            }
        }

        
        (vtable, prots, impls, allImpls ~ impls, templateMeths, templateProts)
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================       VTABLE ANCESTOR        =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Retreive the vtable of the ancestor if the ancestor exists
     * @params:
     *    - ancestor: the ancestor type
     * @returns:
     *   - vtable: same as .0, but updatable
     *   - prots: almost same as .1, but updatable (and PRV is now PRV_PARENT)
     */
    fn retreiveAncestorVtable (self, ancestor : (&ClassRefType)?, ref mut vtable : [mut &MethodPrototypeValue], ref mut prots : [MethodProtection], ref mut addMethods : [dmut &Symbol], ref mut allImpls : [&TraitRefType], ref mut templateMeths : [&TemplateRefMethodValue], ref mut templateProts : [MethodProtection]) {
        if let Ok (clRef) = ancestor {  // there is an ancestor
            let ancVtable = clRef.getVtable ();
            let ancProts = clRef.getVtableProtections ();
            let ancImpls = clRef.getAllImplTraits ();
            let ancTempl = clRef.getTemplateMethods ();
            let ancTemplPr = clRef.getTemplateMethodProtections ();

            vtable ~= ancVtable;
            addMethods ~= copy [alias EMPTY_SYMBOL ; ancVtable.len];

            for j in ancProts { // Insert the protection in the vtable of the current class
                if (j == MethodProtection::PRV) { prots ~= [MethodProtection::PRV_PARENT]; } // private methods are not accessible in child class
                else { prots ~= [j]; }
            }

            templateMeths ~= ancTempl;
            templateProts ~= ancTemplPr;
            allImpls ~= ancImpls;
        }
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================         VTABLE IMPL          =========================
     * ================================================================================
     * ================================================================================
     */
    
    /**
     * Retreive the list of methods that are declared inside traits, and that are implemented by the class
     * @params: 
     *   - context: the context of the validation
     *   - sym: the symbol of the class being validated     
     *   - clRef: the type of the class being validated
     * @returns:
     *    - vtable: populate the vtable, or update it
     *    - vtableProt: populate the protections
     *    - addMethods: the list of methods that are either overriden or newly defined 
     *    - .0: the list of implemented traits, [(.0: the trait symbol, .1: the trait type)]
     * @throws:
     *   - &ErrorMsg: if there is an error in the validation    
     */
    fn retreiveImplsVtable (self, dmut context : &Validator, sym : &ClassSymbol, clRef : &ClassRefType, noValue : bool, ref mut vtable : [mut &MethodPrototypeValue], ref mut vtableProt : [mut MethodProtection], ref mut addMethods : [dmut &Symbol])-> [(&ImplSymbol, &TraitRefType)]
        throws ErrorMsg
    {
        let mut implemented : [(&ImplSymbol, &TraitRefType)] = [];
        let mut errors : [&ErrorMsg] = [];
        
        for it in sym.getAllLocalSymbols (protection-> Protection::PRIVATE) {
            {
                match it {
                    im : &ImplSymbol => { // If there is an implementation, then we need to validated its vtable
                        let tr = context:.validateType (im.getContent ().getTrait ());
                        for i in implemented {
                            if i._1 == tr {
                                throw copy ErrorMsg::fatal (im.getLoc (), format (ValidateErrorMessage::IMPL_MULTIPLE_TIMES, tr, clRef),
                                                            notes-> copy [copy ErrorMsg::note (i._0.getLoc (), format (ValidateErrorMessage::HERE))]);
                            }
                        }

                        let ret = self.retreiveImplVtable (alias context, im.getLoc (), tr, clRef, noValue, ref vtable, ref vtableProt, ref addMethods);
                        implemented ~= [(im, ret)];
                    }
                }
            } catch {
                err : &ErrorMsg => {
                    errors ~= [err];
                }
            }
        }

        if (errors.len != 0us) throw copy ErrorMsg::list (errors);
        implemented
    }

    /**
     * Retreive the vtable of a trait implementation
     * @params: 
     *   - context: the context of the validation
     *   - im: the implementation to validated
     *   - clRef: the type of the class being validated
     * @returns:
     *    - vtable: populate the vtable, or update it
     *    - vtableProt: populate the protections
     *    - addMethods: the list of methods that are either overriden or newly defined 
     *    - .0: the trait ref type
     * @throws:
     *   - &ErrorMsg: if there is an error in the validation (for example, 'im' does not implement a trait) 
     */
    fn retreiveImplVtable (self, dmut context : &Validator, loc : &Word, tr : &Type, clRef : &ClassRefType, noValue : bool, ref mut vtable : [mut &MethodPrototypeValue], ref mut vtableProt : [mut MethodProtection], ref mut addMethods : [dmut &Symbol])-> &TraitRefType
        throws ErrorMsg
    {
        match tr {
            trRef : &TraitRefType => {
                let mut errors : [&ErrorMsg] = [];
                for it in trRef.getSymbol ().getAllLocalSymbols (protection-> Protection::PRIVATE) {
                    let dmut mSym = alias context:.getSymbolFromRef (it);
                    if let dmut f : &FunctionSymbol = alias mSym { // Method definition
                        {
                            self.retreiveImplVtableMethod (alias context, loc, alias f, clRef, trRef, noValue, ref vtable, ref vtableProt, ref addMethods);
                        } catch {
                            err : &ErrorMsg => { errors ~= [err]; }
                        }
                    };
                }
                
                if (errors.len != 0us) throw copy ErrorMsg::list (errors);
                
                trRef
            }
            _ => { // It is not a trait, class can't implement that
                throw copy ErrorMsg::fatal (tr.getLoc (), format (ValidateErrorMessage::IMPL_NO_TRAIT, tr));
            }
        }
    }

    /**
     * Retreive the index of a method in the vtable, during a trait implementation
     * @params: 
     *   - context: the context of the validation
     *   - loc: the location of the impl
     *   - func: the method that is being implemented
     *   - clRef: the type of the class being validated
     *   - trRef: the type of the trait that is implemented
     * @returns:
     *    - vtable: populate the vtable, or update it
     *    - vtableProt: populate the protections
     *    - addMethods: the list of methods that are either overriden or newly defined 
     * @throws:
     *   - &ErrorMsg: if there is an error in the validation
     */
    fn retreiveImplVtableMethod (self, dmut context : &Validator, loc : &Word, dmut func : &FunctionSymbol, clRef : &ClassRefType, trRef : &TraitRefType, noValue : bool, ref mut vtable : [mut &MethodPrototypeValue], ref mut vtableProt : [mut MethodProtection], ref mut addMethods : [dmut &Symbol])
        throws ErrorMsg
    {
        // Validate the prototype of the method
        let meth = context:.getFunctionValidator ():.validateMethodPrototype (alias context, alias func, clRef, trRef, noValue-> noValue);

        // Create a delegate type, in order to compare the methods of the vtable
        // The idea behind the following loop is that if a an ancestor has already implemented the trait, we have to replace the implemented methods by this new implementation                
        for i, it in vtable {
            if (self.isMethSimilar (meth, it)) { // we already have a method with the same name
                if (it.getTrait () != trRef.getSymbol ()) { // They are not from the same trait, (or not from a trait at all)
                    throw copy ErrorMsg::fatal (loc, format (ValidateErrorMessage::IMPLICIT_OVERRIDE_BY_TRAIT, it),
                                                notes-> copy [copy ErrorMsg::note (it.getLoc (), end-> meth.getLoc (), "")]);
                } else { // They come from the same trait, then we replace the old version
                    vtable [i] = meth;
                    addMethods [i] = alias func;

                    return;
                }
            }
        } 
        
        // The method is new (not implemented by an ancestor)
        vtable ~= [meth];
        addMethods ~= [alias func];
        match func.getProtection () { 
            Protection::PRIVATE   => { vtableProt ~= [MethodProtection::PRV]; }
            Protection::PROTECTED => { vtableProt ~= [MethodProtection::PROT]; }
            _                     => { vtableProt ~= [MethodProtection::PUB]; }
        };
    }    

    
    /*!
     * ================================================================================
     * ================================================================================
     * =========================      VTABLE VALIDATION       =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate the methods prototypes that are declared inside implementations
     * @params: 
     *    - context: the context of the validation
     *    - clRef: the type of the class being validated
     *    - implemented: the list of implementation defined in the class
     *    - vtableProt: the protections of the methods of the vtable
     * @returns:
     *    - vtable: update the vtable (cannot grow, otherwise a method was declared in the impl but is not an "over"??)
     *    - addMethods: the list of methods that are either overriden or newly defined 
     * @throws:
     *   - &ErrorMsg: if there is an error in the validation (for example, 'im' does not implement a trait) 
     */
    fn validateImplsVtable (self, dmut context : &Validator, clRef : &ClassRefType, implemented : [(&ImplSymbol, &TraitRefType)], noValue : bool, ref mut vtable : [mut &MethodPrototypeValue], ref mut vtableProt : [mut MethodProtection], ref mut addMethods : [dmut &Symbol])
        throws ErrorMsg
    {
        let mut errors : [&ErrorMsg] = [];
        for im in implemented { // Validate the overriden methods inside implementations
            self.validateImplVtable (alias context, im._0, im._1, clRef, noValue, ref vtable, ref vtableProt, ref addMethods);
        } catch {
            err : &ErrorMsg => { errors ~= [err]; }
        }

        if (errors.len != 0us) throw copy ErrorMsg::list (errors);
    }
    
    /**
     * Update the vtable of the method that are implemented inside an implementation
     * @params: 
     *    - context: the context of the validation
     *    - im: the implementation being validated
     *    - clRef: the type of the class being validated
     *    - vtableProt: the protections of the methods of the vtable
     * @returns:
     *    - vtable: update the vtable (cannot grow, otherwise a method was declared in the impl but is not an "over"??)
     *    - addMethods: the list of methods that are either overriden or newly defined 
     * @throws:
     *   - &ErrorMsg: if there is an error in the validation (for example, 'im' does not implement a trait) 
     */
    fn validateImplVtable (self, dmut context : &Validator, im : &ImplSymbol, trRef : &TraitRefType, clRef : &ClassRefType, noValue : bool, ref mut vtable : [mut &MethodPrototypeValue], ref mut vtableProt : [mut MethodProtection], ref mut addMethods : [dmut &Symbol])
        throws ErrorMsg
    {
        let mut errors : [&ErrorMsg] = [];
        
        for it in im.getAllLocalSymbols (protection-> Protection::PRIVATE) match it { // Traverse the list of methods overriden in the implementation
            func : &FunctionSymbol => {
                let dmut mutSym = context:.getSymbolFromRef (func);
                if let dmut mutFunc : &FunctionSymbol = alias mutSym {
                    self.validateImplVtableMethod (alias context, im.getLoc (), alias mutFunc, clRef, trRef, noValue, ref vtable, ref vtableProt, ref addMethods);
                }
            } catch {
                err : &ErrorMsg => { errors ~= [err]; }
            }
            _ => panic; // An unknown symbol in impl, maybe verify the declaration of the impl
        }

        if (errors.len != 0us) throw copy ErrorMsg::list (errors);
    }

    /**
     * Validate an overriden method declared inside an implementation
     * @params: 
     *   - context: the context of the validation
     *   - loc: the location of the impl
     *   - func: the function to validate
     *   - clRef: the class type that is being validated
     *   - trRef: the trait that is currently implemented
     *   - ancVtable: the vtable of the ancestor class
     *   - vtableProt: the protections of the methods of the vtable
     * @returns:
     *    - vtable: update the vtable, cannot grow
     *    - addMethods: the list of methods that are either overriden or newly defined (is necessarily updated, or an error is thrown)
     * @throws:
     *   - &ErrorMsg: if there is an error in the validation (for example, 'im' does not implement a trait) 
     */
    fn validateImplVtableMethod (self, dmut context : &Validator, _ : &Word, dmut func : &FunctionSymbol, clRef : &ClassRefType, trRef : &TraitRefType, noValue : bool, ref mut vtable : [mut &MethodPrototypeValue], ref mut vtableProt : [mut MethodProtection], ref mut addMethods : [dmut &Symbol])
        throws ErrorMsg
    {
        let meth = context:.getFunctionValidator ():.validateMethodPrototype (alias context, alias func, clRef, traitRef-> trRef, noValue-> noValue);
        let methProt = match func.getProtection () { 
            Protection::PRIVATE   => { MethodProtection::PRV }
            Protection::PROTECTED => { MethodProtection::PROT }
            _                     => { MethodProtection::PUB }
        };
        
        for i, it in vtable { // traverse the vtable, and verify that there is no collision
            if (self.isMethSimilar (meth, it)) { // Verify that there is no collision between the method, and the other method, there can be multiple factors (different protection, missing override, over outside trait, ...)
                self.verifyCollisionDirectMethod (context, it, meth, vtableProt [i], methProt, func.isOver ());

                // Thre is a collision, but it is an acceptable one, it is an proper override
                vtable [i] = meth; // we update the vtable
                addMethods [i] = alias func; // We add the method to the methods to rewrite

                return;
            }
        }

        // There is no method in the trait definition that could be overriden by this method, so it must not be defined inside an impl
        let candidates = self.findCandidateOverMethods (meth, vtable, tr-> trRef.getSymbol ());
        throw copy ErrorMsg::fatal (meth.getLoc (), format (ValidateErrorMessage::OVERRIDE_NOTHING, meth),
                                    notes-> candidates);
    }   
    
    /**
     * Validate the methods prototypes that are declared outside implementations
     * @params: 
     *    - context: the context of the validation
     *    - sym: the symbol of the class being validated
     *    - clRef: the type of the class being validated
     *    - ancVtable: the vtable of the ancestor class
     *    - vtableProt: the protections of the methods of the vtable
     * @returns:
     *    - vtable: update the vtable, can grow
     *    - vtableProt: grow when new methods are defined in the class (but cannot be updated, or the protection of a method change when it is overriden ??)
     *    - addMethods: the list of methods that are either overriden or newly defined 
     *    - .0: the trait ref type
     * @throws:
     *   - &ErrorMsg: if there is an error in the validation
     */
    fn validateDirectVtable (self, dmut context : &Validator, sym : &ClassSymbol, clRef : &ClassRefType, noValue : bool, ref mut vtable : [mut &MethodPrototypeValue], ref mut vtableProt : [mut MethodProtection], ref mut addMethods : [dmut &Symbol], ref mut templateMeths : [&TemplateRefMethodValue], ref mut templateProts : [MethodProtection])
        throws ErrorMsg
    {
        let mut errors : [&ErrorMsg] = [];
        for it in sym.getAllLocalSymbols (protection-> Protection::PRIVATE) { // traverse all the function defined inside the class
            {
                match it {
                    func : &FunctionSymbol => {
                        if let dmut mutFunc : &FunctionSymbol = context:.getSymbolFromRef (func) {
                            self.validateDirectVtableMethod (alias context, alias mutFunc, clRef, noValue, ref vtable, ref vtableProt, ref addMethods); // validate the redefinition for the vtable
                        }
                    }
                    t : &TemplateSymbol => {
                        match t.getContent ().getContent () {
                            f : &FunctionDecl => {
                                let methProt = match t.getProtection () {
                                    Protection::PRIVATE   => { MethodProtection::PRV }
                                    Protection::PROTECTED => { MethodProtection::PROT }
                                    _                     => { MethodProtection::PUB }
                                };

                                if f.getAttributes ().len != 0 {
                                    for at in f.getAttributes () { // attributes are not applicable to template methods
                                        errors ~= [copy ErrorMsg::fatal (at.loc, format (DeclareErrorMessage::UNDEFINED_ATTRIBUTE_FOR_TEMPLATE_METHOD, at.attr),
                                                                         notes-> copy [copy ErrorMsg::note (f.getLoc (), format (DeclareErrorMessage::DECLARED_HERE))])];
                                    }
                                } else {
                                    templateProts ~= [methProt];
                                    templateMeths ~= [copy TemplateRefMethodValue (t.getLoc (), clRef.getSymbol (), t)];
                                }
                            }
                        }
                    }
                }
            } catch {
                err : &ErrorMsg => {
                    errors ~= [err];
                }
            }
        }
        
        if (errors.len != 0us) throw copy ErrorMsg::list (errors);
    }

    /**
     * Validate the prototype of a method and put it inside the vtable (or update the vtable in case of override)
     *    - context: the context of the validation
     *    - sym: the symbol of the class being validated
     *    - clRef: the type of the class being validated
     *    - ancVtable: the vtable of the ancestor class
     *    - vtableProt: the protections of the methods of the vtable
     * @returns:
     *    - vtable: update the vtable, can grow
     *    - vtableProt: grow when new methods are defined in the class (but cannot be updated, or the protection of a method change when it is overriden ??)
     *    - addMethods: the list of methods that are either overriden or newly defined and must be validated at the end of the creation of the vtable
     *    - .0: the trait ref type
     * @throws:
     *   - &ErrorMsg: if there is an error in the validation 
     */
    fn validateDirectVtableMethod (self, dmut context : &Validator, dmut func : &FunctionSymbol, clRef : &ClassRefType, noValue : bool, ref mut vtable : [mut &MethodPrototypeValue], ref mut vtableProt : [mut MethodProtection], ref mut addMethods : [dmut &Symbol])
        throws ErrorMsg
    {
        let meth = context:.getFunctionValidator ():.validateMethodPrototype (alias context, alias func, clRef, noValue-> noValue);
        let methProt = match func.getProtection () {
            Protection::PRIVATE   => { MethodProtection::PRV }
            Protection::PROTECTED => { MethodProtection::PROT }
            _                     => { MethodProtection::PUB }
        };

        for i, it in vtable { // traverse the vtable, and verify that there is no collision
            if (self.isMethSimilar (meth, it)) { // Verify that there is no collision between the method, and the other method, there can be multiple factors (different protection, missing override, over outside trait, ...)
                self.verifyCollisionDirectMethod (context, it, meth, vtableProt [i], methProt, func.isOver ());

                // Thre is a collision, but it is an acceptable one, it is an proper override
                vtable [i] = meth; // we update the vtable
                addMethods [i] = alias func; // We add the method to the methods to rewrite

                return;
            }
        }

        if (func.isOver ()) {
            let candidates = self.findCandidateOverMethods (meth, vtable);
            throw copy ErrorMsg::fatal (meth.getLoc (), format (ValidateErrorMessage::OVERRIDE_NOTHING, meth),
                                        notes-> candidates);
        }

        // There is no override here, its a new method, we just add it at the end of the vtable
        vtable ~= [meth];
        addMethods ~= [alias func];
        vtableProt ~= [methProt];
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================     VTABLE VERIFICATION      =========================
     * ================================================================================
     * ================================================================================
     */
    
    /**
     * Verify that the collision that was detected between this two methods is acceptable
     * @params: 
     *   - oldMethod: the definition of the old method
     *   - nMethod: the definition of the new method
     *   - oldProt: the protection of the old method
     *   - nProt: the protection of the new method
     *   - isOver: the keyword over was used 
     * @throws:
     *   - &ErrorMsg: if there is a unacceptable collision
     */
    fn verifyCollisionDirectMethod (self, context : &Validator, oldMethod : &MethodPrototypeValue, nMethod : &MethodPrototypeValue, oldProt : MethodProtection, nProt : MethodProtection, isOver : bool)
        throws ErrorMsg
    {        
        if (oldMethod.getTrait () !is nMethod.getTrait ()) {
            match (nMethod.getTrait (), oldMethod.getTrait (), isOver) {
                (EmptySymbol (), EmptySymbol (), _) => {} // it can be a different empty symbol address, but still be valid
                (EmptySymbol (), _, true) => {
                    throw copy ErrorMsg::fatal (nMethod.getLoc (), end-> oldMethod.getLoc (), format (ValidateErrorMessage::OVERRIDE_TRAIT_OUTSIDE, oldMethod, nMethod, tags-> FormatTags (withParams-> true)));
                }
                (_, EmptySymbol (), true) => {
                    throw copy ErrorMsg::fatal (nMethod.getLoc (), end-> oldMethod.getLoc (), format (ValidateErrorMessage::OVERRIDE_NON_TRAIT_INSIDE, oldMethod, nMethod, tags-> FormatTags (withParams-> true)));
                }
                (_, _, _) => { // Same method but from two different traits                    
                    throw copy ErrorMsg::fatal (nMethod.getLoc (), end-> oldMethod.getLoc (), format (ValidateErrorMessage::COLLIDING_METHOD_DEFINITION, nMethod, oldMethod, tags-> FormatTags (withParams-> true)));
                }
            }
        }

        if (oldMethod.getTrait () is nMethod.getTrait ()) {
            match oldMethod.getTrait () {
                TraitSymbol () => { // we define a method inside an impl, (so an override)
                    if (oldMethod.isOver ()) { // was an override, and come from a trait, then it was necessarily defined inside an impl
                        throw copy ErrorMsg::fatal (nMethod.getLoc (), end-> oldMethod.getLoc (), format (ValidateErrorMessage::OVERRIDE_MULTIPLE_TIMES_TRAIT, nMethod, tags-> FormatTags (withParams-> true)));
                    }
                }
            }
        }

        if (oldMethod.getClassRef () == nMethod.getClassRef ()) {
            match (oldMethod.getTrait (), nMethod.getTrait ()) {
                (EmptySymbol (), EmptySymbol ()) => { // the definition of the method is made two times in the same class (and is not an override inside a trait)
                    throw copy ErrorMsg::fatal (nMethod.getLoc (), end-> oldMethod.getLoc (), format (ValidateErrorMessage::COLLIDING_METHOD_DEFINITION, nMethod, oldMethod, tags-> FormatTags (withParams-> true)));
                }
            }
        }

        // Override must return a type of the same size and compatible
        self.verifyOverrideReturn (context, oldMethod, nMethod);

        // Simple collision, over is not written in the definition of the method
        if (!isOver) throw copy ErrorMsg::fatal (nMethod.getLoc (), end-> oldMethod.getLoc (), format (ValidateErrorMessage::IMPLICIT_OVERRIDE, nMethod, oldMethod, tags-> FormatTags (withParams-> true)));

        // override prv method is impossible, child class does not have access to ancestor private methods
        if (oldProt == MethodProtection::PRV_PARENT) {
            throw copy ErrorMsg::fatal (nMethod.getLoc (), end-> oldMethod.getLoc (), format (DeclareErrorMessage::PRIVATE_IN_THIS_CONTEXT, oldMethod, tags-> FormatTags (withParams-> true)));
        }

        // override a pub method, mut be pub
        if (nProt != oldProt) {
            throw copy ErrorMsg::fatal (nMethod.getLoc (), end-> oldMethod.getLoc (), format (ValidateErrorMessage::OVERRIDE_MISMATCH_PROTECTION, self.toStr (nProt), nMethod, self.toStr (oldProt), tags-> FormatTags (withParams-> true)));
        }

        // override a final method is impossible (that's the definition of final)
        if (oldMethod.isFinal ()) {
            throw copy ErrorMsg::fatal (nMethod.getLoc (), end-> oldMethod.getLoc (), format (ValidateErrorMessage::OVERRIDE_FINAL, oldMethod, tags-> FormatTags (withParams-> true)));
        }

        // Field method can only be override by field method
        if (oldMethod.isField () && !nMethod.isField ()) {
            throw copy ErrorMsg::fatal (nMethod.getLoc (), format (ValidateErrorMessage::OVERRIDE_FIELD_NO_FIELD, nMethod, oldMethod, tags-> FormatTags (withParams-> true)), notes-> copy [copy ErrorMsg::note (oldMethod.getFieldLoc (), end-> oldMethod.getLoc (), "")]);
        }

        // A field method can only override a field method
        if (!oldMethod.isField () && nMethod.isField ()) {
            throw copy ErrorMsg::fatal (nMethod.getLoc (), end-> nMethod.getFieldLoc (), format (ValidateErrorMessage::OVERRIDE_NO_FIELD_BY_FIELD, nMethod, oldMethod, tags-> FormatTags (withParams-> true)), notes-> copy [copy ErrorMsg::note (oldMethod.getFieldLoc (), "")]);
        }

        // Check that the declared throwers are compatible
        self.verifyOverrideThrowings (context, oldMethod, nMethod);

        // Override methods must have a body
        if (nMethod.isEmpty ()) throw copy ErrorMsg::fatal (nMethod.getLoc (), format (ValidateErrorMessage::OVERRIDE_EMPTY, nMethod, oldMethod, tags-> FormatTags (withParams-> true)));
        
        nProt;
        oldProt;
    }

    /**
     * Verify that the return type declared in the new method prototype is compatible with the return type of the super method
     * @params:
     *    - context: the context of the validation
     *    - oldMethod: the super method
     *    - nMethod: the overriden version of the method
     * @throws:
     *    - &ErrorMsg: if the types are not compatible
     * */
    fn verifyOverrideReturn (self, context : &Validator, oldMethod : &MethodPrototypeValue, nMethod : &MethodPrototypeValue)
        throws ErrorMsg
    {
        let mut innerError : (&ErrorMsg)? = none;
        let oldRT = oldMethod.getRetType ();
        let nRT = nMethod.getRetType ();
        if (oldRT != nRT) {
            {
                let infer = context.inferTypeBranching (oldRT.getLoc (), nRT.getLoc (), oldRT, nRT);
                if (infer != oldRT) {
                    innerError = (copy ErrorMsg::fatal (oldRT.getLoc (), end-> nRT.getLoc (), format (ValidateErrorMessage::INCOMPATIBLE_TYPE, oldRT, nRT)))?;
                }
            } catch {
                err : &ErrorMsg => { innerError = err?; }
            }
        } else if (!oldRT.sameMutability (nRT)) {
            innerError = (copy ErrorMsg::fatal (oldRT.getLoc (), end-> nRT.getLoc (), format (ValidateErrorMessage::INCOMPATIBLE_TYPE, oldRT, nRT)))?;
        }

        if let Ok (err : &ErrorMsg) = innerError {
            throw copy ErrorMsg::fatal (nMethod.getLoc (), format (ValidateErrorMessage::OVERRIDE_INCOMPATIBLE_RETURN_TYPE, nMethod, oldMethod, tags-> FormatTags (withParams-> true)),
                                        notes-> copy [err]);
        }
    }

    /**
     * Verify that the throwers declared in the new method prototype are compatible with the throwers of the super method
     * @params:
     *    - context: the context of the validation
     *    - oldMethod: the super method
     *    - nMethod: the overriden version of the method
     * @throws:
     *    - &ErrorMsg: if the throwers are not compatible
     * */
    fn verifyOverrideThrowings (self, context : &Validator, oldMethod : &MethodPrototypeValue, nMethod : &MethodPrototypeValue)
        throws ErrorMsg
    {
        let mut unlisted : [&ErrorMsg] = [];
        for thr in nMethod.getThrowers () {
            let mut found = false;
            for superThr in oldMethod.getThrowers () {
                if (context.isDirectInstance (thr._1, superThr._1)) {
                    found = true;
                    break;
                }
                if context.isAncestor (superThr._1, thr._1) {
                    found = true;
                    break;
                }
            }

            if !found {
                let mut notes : [&ErrorMsg] = copy [copy ErrorMsg::note (anc._0, format (ValidateErrorMessage::THROWING, anc._1), oneLine-> true)
                                                    for anc in oldMethod.getThrowers ()];

                unlisted ~= [copy ErrorMsg::fatal (thr._0, format (ValidateErrorMessage::THROWS_NOT_DECLARED_OVER, thr._1),
                                                   notes-> notes)];
            }
        }

        if (unlisted.len != 0us) {
            throw copy ErrorMsg::fatal (oldMethod.getLoc (), format (ValidateErrorMessage::OVERRIDE_MISMATCH_THROWERS, nMethod, oldMethod, tags-> FormatTags (withParams-> true)),
                                        notes-> copy [copy ErrorMsg::note (oldMethod.getFieldLoc (), "")] ~ unlisted);
        }
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================      VTABLE DESTRUCTOR       =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Validate the dtor of the class
     * @params:
     *    - context: the context of the validation
     *    - sym: the symbol to validate
     *    - clRef: the type of the class being validated
     *    - ancestor: the ancestor of the class
     * */
    fn validateDestructor (self, dmut context : &Validator, dmut sym : &ClassSymbol, ancestor : (&ClassRefType)?, inModule : bool)
        throws ErrorMsg
    {
        let dmut cref = alias sym:.getClassRefForce ();
        let dtor = self.validateVtableDtor (alias context, alias sym, cref, ancestor, inModule);
        cref:.setDtor (dtor);
    }

    /**
     * Validate the prototype of the destructor for the vtable
     * @params:
     *    - context: the context of the validation
     *    - sym: the symbol to validate
     *    - clRef: the type of the class being validated
     *    - ancestor: the ancestor of the class
     * @throws: 
     *    - &ErrorMsg: if there is an error in the validation
     * @returns: the prototype of the destructor
     */
    fn validateVtableDtor (self, dmut context : &Validator, dmut sym : &ClassSymbol, clRef : &ClassRefType, ancestor : (&ClassRefType)?, inModule : bool)-> &Value
        throws ErrorMsg
    {
        let ancDtor = match ancestor {
            Ok (ancRef) => { // maybe the ancestor has a destructor
                ancRef.getDestructor ()
            }
            _ => { // No ancestor, so no destructor at all
                UNIT_VALUE
            }
        };

        let mut forceMovable = false;
        if (sym.isEntity ()) {
            for vi in clRef.getLocalFields () match vi {
                v : &VarDeclValue => {
                    if (v.getVarType ().isMovable ()) match v.getVarType () {
                        c : &ClassPtrType => {
                            if (c.getInner ().getDestructor () of DtorPrototypeValue) {
                                forceMovable = true;
                                break;
                            }
                        }
                    }
                }
            }
        }

        let dmut dtor = sym:.getDestructor ();
        if let dmut func : &DestructorSymbol = alias dtor { // a destructor is defined, we return its prototype
            if inModule {
                sym:.insertAddMethod (alias func);
            }

            if (forceMovable || !func.isEmpty ()) {
                return context:.getFunctionValidator ():.validateDtorPrototype (alias context, alias func, clRef, ancDtor-> ancDtor);
            }

            return UNIT_VALUE;
        }

        if dtor of EmptySymbol { // no destructor in the class
            if (forceMovable) {
                return self.createDefaultDtor (alias context, alias sym, clRef, inModule);
            }

            return ancDtor;
        }

        panic;
    }

    /**
     * Create a default dtor for an entity that has no dtor but has fields needing to be destroyed
     * */
    fn createDefaultDtor (self, dmut context : &Validator, dmut sym : &ClassSymbol, clRef : &ClassRefType, inModule : bool)-> &Value
        throws ErrorMsg
    {
        let selfLoc = copy Word (Keys::SELF, sym.getLoc ());
        let var = copy VarDeclExpr (selfLoc,
                                    selfLoc,
                                    isMutOrDmut-> copy Word (Keys::MUTABLE, sym.getLoc ()),
                                    value-> EMPTY_EXPR,
                                    type-> EMPTY_EXPR);

        let body = copy BlockExpr (sym.getLoc (), sym.getLoc (), []);
        let dtor = copy DestructorDecl (copy Word (Keys::DTOR, sym.getLoc ()), [], var, body);
        let dmut dtorSym = context:.getDeclarator ().declareDestructor (dtor, alias sym);
        if inModule {
            sym:.insertAddMethod (alias dtorSym);
        }

        context:.getFunctionValidator ():.validateDtorPrototype (alias context, alias dtorSym, clRef, ancDtor-> UNIT_VALUE)
    }

    /*!
     * ==================================================================================
     * ==================================================================================
     * =========================            TYPEINFO            =========================
     * ==================================================================================
     * ==================================================================================
     */

    /**
     * Validate the typeinfo part of a class symbol
     * @params:
     *    - context: the context of the validation
     *    - sym: the class symbol to validate
     * */
    fn validateTypeInfo (self, dmut context : &Validator, dmut sym : &ClassSymbol)
        throws ErrorMsg
    {
        let loc = sym.getLoc ();
        let dmut cref = alias sym:.getClassRefForce ();
        let type = context:.validateTypeInfo (sym.getLoc ());
        let id = context:.validateTypeIDs (sym.getLoc (),
                                           if (sym.isStruct ()) { TypeInfoIDS::STRUCT } else { TypeInfoIDS::OBJECT });

        let idInt = {
            context:.getCompileTimeInterpreter ():.computeInt (id).to!{usize} ()
        } catch {
            _ => panic;
        };

        let size = context:.getSizeofValidator ():.validateType (sym.getLoc (), cref);
        let innerSlice = match cref.getAncestor () {
            Ok (anc) => {
                let ancType = copy ArrayType (loc, type, 1us);
                context.createSliceAliasFromArray (loc, ancType,
                                                   copy ArrayValue (loc, ancType, copy [anc.getTypeInfo ()]))
            }
            _ => {
                let ancType = copy ArrayType (loc, type, 0us);
                context.createSliceAliasFromArray (loc, ancType, copy ArrayValue (loc, ancType, []))
            }
        };

        let typeinfoFin = copy TypeInfoValue (loc, type,
                                              idInt,
                                              size,
                                              innerSlice,
                                              sym.getPath ().toStr ());

        cref:.setTypeInfo (typeinfoFin);
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================           CHECKING           =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * @returns: true if the class was already validated, or is currently in validation
     */
    fn checkValidation (self, sym : &ClassSymbol)-> u32 {
        if let Ok (cref) = sym.getClassRef () {
            if cref.getTypeInfo () !of UnitValue {
                return MAX_RECURSIVE_LEVEL;
            }

            if let Ok (level) = self._validation [sym] {
                if cref.hasCtors () { return MAX_RECURSIVE_LEVEL; }
                else return level;
            }

            return 1;
        }

        return 1;
    }

    /**
     * Check wether ancestor is recursively the children of itself
     * */
    fn checkRecursiveAncestor (self, cref : &ClassRefType)
        throws ErrorMsg
    {
        let mut curr = cref;
        let mut error = false;
        loop {
            if let Ok (anc) = curr.getAncestor () {
                if anc.getSymbol () == cref.getSymbol () {
                    error = true;
                    break;
                }

                curr = anc;
            } else break;
        }

        if error {
            curr = cref;
            let dmut notes : [&ErrorMsg] = [];
            loop {
                notes ~= [copy ErrorMsg::note (curr.getLoc (), format (ValidateErrorMessage::VALIDATING_SYMBOL, curr))];
                if let Ok (anc) = curr.getAncestor () && anc.getSymbol () != cref.getSymbol () {
                    curr = anc;
                } else break;
            }

            throw copy ErrorMsg::fatal (curr.getLoc (), format (ValidateErrorMessage::RECURSIVE_ANCESTOR, cref));
        }
    }

    /**
     * Create the list of notes for an overriding failure
     * */
    fn findCandidateOverMethods (self, left : &MethodPrototypeValue, vtable : [&MethodPrototypeValue], tr : &Symbol = EMPTY_SYMBOL)-> [&ErrorMsg] {
        let mut notes : [&ErrorMsg] = [];

        let name = left.getSymbol ().getPath ().file ();
        for v in vtable {
            let iname = v.getSymbol ().getPath ().file ();
            let sameContext = match tr {
                TraitSymbol () => { (tr is v.getTrait ()) }
                _ => match v.getTrait () {
                    EmptySymbol () => { true }
                    _ => { false }
                }
            };

            if (sameContext) {
                let add = if (name.len <= 3us) {
                    name == iname
                } else {
                    let levDist = string::levenshteinDistance (name, iname);
                    levDist <= 3us
                };

                if (add) {
                    notes ~= [copy ErrorMsg::note (v.getLoc (), format (ValidateErrorMessage::CANDIDATE_ARE, v, tags-> FormatTags (withParams-> true)),
                                                   oneLine-> true, withLoc-> true)];
                }
            }
        }

        notes
    }

    /**
     * @returns: true if left and right have the same prototype (and the same name)
     * @info: does not check the type of the closure, as it has to be used to find overriding methods
     * */
    fn isMethSimilar (self, left : &MethodPrototypeValue, right : &MethodPrototypeValue)-> bool {
        if (left.getSymbol ().getPath ().file () != right.getSymbol ().getPath ().file ()) return false;

        if (left.isMutable () != right.isMutable ()) { return false; }
        if (left.getParameters ().len != right.getParameters ().len) { return false; }
        for i in 0us .. left.getParameters ().len {
            if (left.getParameters () [i].getType () != right.getParameters () [i].getType ()) {
                return false;
            }

            if (!left.getParameters () [i].getType ().sameMutability (right.getParameters () [i].getType ())) {
                return false;
            }

            if (left.getParameters () [i].isLazy () != right.getParameters () [i].isLazy ()) {
                return false;
            }

            if (left.getParameters () [i].isReference () != right.getParameters () [i].isReference ()) {
                return false;
            }
        }

        return true;
    }

    /**
     * @returns: true if left and right have the same prototype (and the same name)
     * */
    fn isCtorSimilar (self, left : &CtorPrototypeValue, right : &CtorPrototypeValue)-> bool {
        if (left.getRename () != right.getRename ()) return false;

        if (left.getParameters ().len != right.getParameters ().len) return false;
        for i in 0us .. left.getParameters ().len {
            if (left.getParameters () [i].getType () != right.getParameters () [i].getType ()) return false;
            if (!left.getParameters () [i].getType ().sameMutability (right.getParameters () [i].getType ())) return false;
            if (!left.getParameters () [i].isLazy () != right.getParameters () [i].isLazy ()) return false;
            if (!left.getParameters () [i].isReference () != right.getParameters () [i].isReference ()) return false;
        }

        true
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================            UTILS             =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * @returns: the str containing the method protection
     */
    pub fn toStr (self, protection : MethodProtection) -> [c8] {
        match protection {
            MethodProtection::PUB  => { Keys::PUBLIC }
            MethodProtection::PROT => { Keys::PROTECTED }
            _                      => { Keys::PRIVATE }
        }
    }
    
}
