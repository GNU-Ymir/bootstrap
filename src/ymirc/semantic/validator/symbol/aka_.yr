mod ymirc::semantic::validator::symbol::aka_;

import ymirc::semantic::validator::visitor;
import ymirc::semantic::validator::errors;
import ymirc::semantic::symbol::aka_;
import ymirc::syntax::declaration::protection;
import ymirc::syntax::expression::_;
import ymirc::syntax::declaration::_;

import ymirc::syntax::keys;
import ymirc::semantic::generator::_;
import ymirc::errors::_;
import ymirc::utils::format;
import ymirc::lexing::word;

import std::collection::vec;
import std::io, std::fs::path;

/**
 * The aka validator is the class responsible for aka symbol validation
 */
pub class AkaValidator {

    /**
     * Create a new empty validator
     */
    pub self () {}


    /**
     * Validate an aka symbol found in the symbol tree
     * */
    pub fn validate (self, dmut context : &Validator, dmut sym : &AkaSymbol)
        throws &ErrorMsg
    {
        {
            self.validateType (alias context, alias sym);
        } catch {
            err : &ErrorMsg => {
                {
                    self.validateValue (alias context, alias sym);
                } catch {
                    secErr : &ErrorMsg => {
                        let innerType = err.getNotes ();
                        let innerVal = secErr.getNotes ();
                        throw ErrorMsg::fatal (sym.getLoc (), format (ValidateErrorMessage::VALIDATING_SYMBOL, sym.getPath ()), notes-> (innerType ~ innerVal));
                    }
                }
            }
        }
    }

    /**
     * Validate an aka symbol as a type
     * @params: 
     *    - context: the context of the validation
     *    - sym: the symbol to validate
     * @returns: the type contained in the aka
     * @throws: &ErrorMsg, if the aka is malformed, or is a value
     */
    pub fn validateType (self, dmut context : &Validator, dmut sym : &AkaSymbol)-> &Type
        throws &ErrorMsg
    {
        match sym.getGenerator () { // already validated
            t : &Type => return t.clone (0u32);
            v : &Value => {
                throw ErrorMsg::fatal (sym.getLoc (), end-> v.getLoc (), format (ValidateErrorMessage::USE_AS_TYPE));
            }
        }

        context:.pushReferent (alias sym);
        context:.enterForeign (isFnBody-> false);
        let (_, type) = {
            context:.validateType (sym.getContent ().getContent (), decos-> [], canBeRef-> false)
        } catch {
            err : &ErrorMsg => {
                context:.exitForeign ();
                context:.popReferent ();
                throw ErrorMsg::fatal (sym.getLoc (), format (ValidateErrorMessage::VALIDATING_SYMBOL, sym.getPath ()), notes-> [err]);
            }
        };

        context:.exitForeign ();
        context:.popReferent ();

        sym:.setGenerator (type.clone (mutLevel-> 0u32));

        type.clone (mutLevel-> 0u32)
    }

    /**
     * Validate an aka symbol as a value
     * @params: 
     *    - context: the context of the validation
     *    - sym: the symbol to validate
     * @returns: the value contained in the aka
     * @throws: &ErrorMsg, if the aka is malformed, or is a type
     */
    pub fn validateValue (self, dmut context : &Validator, dmut sym : &AkaSymbol)-> &Value
        throws &ErrorMsg
    {
        match sym.getGenerator () {
            v : &Value => return v;
            t : &Type => {
                throw ErrorMsg::fatal (sym.getLoc (), end-> t.getLoc (), format (ValidateErrorMessage::USE_AS_VALUE));
            }
        }


        context:.pushReferent (alias sym);
        context:.enterForeign (isFnBody-> false);
        let value = {
            context:.validateValue (sym.getContent ().getContent ())
        } catch {
            err : &ErrorMsg => {
                context:.exitForeign ();
                context:.popReferent ();
                throw ErrorMsg::fatal (sym.getLoc (), format (ValidateErrorMessage::VALIDATING_SYMBOL, sym.getPath ()), notes-> [err]);
            }
        };

        context:.exitForeign ();
        context:.popReferent ();
        sym:.setGenerator (value);

        value
    }

}
