in aka_;

use ymirc::semantic::validator::{visitor, errors};
use ymirc::semantic::{generator::_, symbol, symbol::aka_};

use ymirc::syntax::declaration::protection;
use ymirc::syntax::{expression::_, declaration::_};

use ymirc::syntax::keys;
use ymirc::errors::_;
use ymirc::utils::{format, log};
use ymirc::lexing::{word, tokens};
use std::{stream, io};

use ymirc::semantic::generator::type::{_,
                                       custom::_,
                                       native::{_, scalar::_, compound::_},
                                       temporary::_};

use ymirc::semantic::generator::value::{_,
                                        construct::{_, delegate::_},
                                        literal::_,
                                        memory::_,
                                        operator::{_, binary::_, call::_, fields::_, map::_, slice::_, unary::_},
                                        operator::map::iteration::_,
                                        prototypes::_,
                                        scope::_,
                                        syntax::_,
                                        template::_};


/**
 * The aka validator is the class responsible for aka symbol validation
 */
@final
pub class AkaValidator {

    // The list of akas currently in validation to avoid infinite recursion
    let mut _validation : [&Symbol => mut u32] = copy [];

    /**
     * Create a new empty validator
     */
    pub self () {}

    /**
     * Validate an aka symbol found in the symbol tree
     * */
    pub fn validate (mut self, dmut context : &Validator, dmut sym : &AkaSymbol)
        throws ErrorMsg
    {
        match sym.getGenerator () {
            Type () => { return; }
            Value () => { return; }
            e : &ErrorGenerator => throw e.getErrorMessage ();
        }

        logging::info ("Validate def %", sym.getPath ());
        let validationLevel = if let Ok (level) = self._validation [sym] { level } else { 0 };
        let maxLevel = if sym.getContent ().isValue () { 1u32 } else { 3u32 };

        if validationLevel < maxLevel {
            self._validation [sym] = validationLevel + 1;

            {
                if (sym.getContent ().isValue ()) {
                    self:.validateValue (alias context, alias sym);
                } else {
                    self:.validateType (alias context, alias sym);
                }
            } catch {
                err : &ErrorMsg => {
                    self._validation:.remove (sym);
                    throw err;
                }
            }

            if validationLevel == 0 {
                self._validation:.remove (sym);
            }
        } else {
            let error = copy ErrorMsg::fatal (sym.getLoc (), format (ValidateErrorMessage::FORWARD_REFERENCE_AKA, sym.getPath ()));
            sym:.setGenerator (copy ErrorGenerator (sym.getLoc (), error));
            throw error;
        }
    }

    /**
     * Validate an aka symbol as a type
     * @params: 
     *    - context: the context of the validation
     *    - sym: the symbol to validate
     * @returns: the type contained in the aka
     * @throws: &ErrorMsg, if the aka is malformed, or is a value
     */
    fn validateType (mut self, dmut context : &Validator, dmut sym : &AkaSymbol)
        throws ErrorMsg
    {
        context:.pushReferent (alias sym);
        context:.enterForeign (isFnBody-> false);

        let type = {
            let t = context:.validateType (sym.getContent ().getContent (), parentMutable-> false);
            match t {
                c : &ClassRefType => { c }
                c : &ClassPtrType => {
                    if (!c.isStruct ()) {
                        throw copy ErrorMsg::fatal (sym.getContent ().getContent ().getLoc (), format (ValidateErrorMessage::CLASS_THROW_PTR, c));
                    }

                    c.getInner ()
                }
                _ => {
                    context.verifyCompleteType (sym.getContent ().getContent ().getLoc (), t, false);
                    t
                }
            }
        } catch {
            err : &ErrorMsg => {
                context:.exitForeign ();
                context:.popReferent ();

                let error = copy ErrorMsg::fatal (sym.getLoc (), format (ValidateErrorMessage::VALIDATING_SYMBOL, sym.getPath ()),
                                                  notes-> copy [err]);

                sym:.setGenerator (copy ErrorGenerator (sym.getLoc (), error));
                throw error;
            }
        };

        context:.exitForeign ();
        context:.popReferent ();

        sym:.setGenerator (type.clone (mutLevel-> 0u32));
    }

    /**
     * Validate an aka symbol as a value
     * @params: 
     *    - context: the context of the validation
     *    - sym: the symbol to validate
     * @returns: the value contained in the aka
     * @throws: &ErrorMsg, if the aka is malformed, or is a type
     */
    fn validateValue (mut self, dmut context : &Validator, dmut sym : &AkaSymbol)
        throws ErrorMsg
    {
        context:.pushReferent (alias sym);
        context:.enterForeign (isFnBody-> false);

        let value = {
            let loc = sym.getContent ().getContent ().getLoc ();
            let v = context:.validateValue (sym.getContent ().getContent ());

            if (self.checkUnaddressableValue (loc, v)) {
                throw copy ErrorMsg::fatal (sym.getLoc (), end-> loc, format (ValidateErrorMessage::AKA_CLASS_CTOR),
                                       notes-> copy [copy ErrorMsg::note (loc, oneLine-> true, format (ValidateErrorMessage::MAYBE_TYPE_AKA))]);
            }

            v
        } catch {
            err : &ErrorMsg => {
                context:.exitForeign ();
                context:.popReferent ();

                let error = copy ErrorMsg::fatal (sym.getLoc (), format (ValidateErrorMessage::VALIDATING_SYMBOL, sym.getPath ()),
                                                  notes-> copy [err]);
                sym:.setGenerator (copy ErrorGenerator (sym.getLoc (), error));
                throw error;
            }
        };

        context:.exitForeign ();
        context:.popReferent ();

        sym:.setGenerator (value);
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================           CHECKING           =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Check wether the value can be used in an aka value
     * */
    fn checkUnaddressableValue (self, _ : &Word, v : &Value)-> bool {
        match v {
            CtorDelegateValue () => { return true; }
            CtorDelegateTemplateValue () => { return true; }
            m : &MultSymValue => {
                for i in m.getValues () {
                    if i of CtorDelegateValue || i of CtorDelegateTemplateValue {
                        return true;
                    }
                }

                return false;
            }
        }

        false
    }

}
