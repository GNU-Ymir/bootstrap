mod ymirc::semantic::validator::symbol::aka_;

import ymirc::semantic::validator::visitor;
import ymirc::semantic::validator::errors;
import ymirc::semantic::symbol::aka_;
import ymirc::semantic::symbol::base;

import ymirc::syntax::declaration::protection;
import ymirc::syntax::expression::_;
import ymirc::syntax::declaration::_;

import ymirc::syntax::keys;
import ymirc::semantic::generator::_;
import ymirc::errors::_;
import ymirc::utils::format;
import ymirc::utils::log;
import ymirc::lexing::word;
import ymirc::lexing::tokens;

import std::collection::vec;
import std::collection::set;
import std::io, std::fs::path;

/**
 * The aka validator is the class responsible for aka symbol validation
 */
pub class AkaValidator {

    // The list of akas currently in validation to avoid infinite recursion
    let dmut _validation = HashSet!{&Symbol}::new ();

    /**
     * Create a new empty validator
     */
    pub self () {}

    /**
     * Validate an aka symbol found in the symbol tree
     * */
    pub fn validate (mut self, dmut context : &Validator, dmut sym : &AkaSymbol)
        throws &ErrorMsg
    {
        match sym.getGenerator () {
            Type () => { return {} }
            Value () => { return {} }
            e : &ErrorGenerator => throw e.getErrorMessage ();
        }

        logging::info ("Validate def %"s8, sym.getPath ());
        self:.enterValidation (alias sym);

        {
            if (sym.getContent ().isValue ()) {
                self:.validateValue (alias context, alias sym);
            } else {
                self:.validateType (alias context, alias sym);
            }
        } catch {
            err : &ErrorMsg => {
                self:.exitValidation (sym);
                throw err;
            }
        }

        self:.exitValidation (sym);
    }

    /**
     * Validate an aka symbol as a type
     * @params: 
     *    - context: the context of the validation
     *    - sym: the symbol to validate
     * @returns: the type contained in the aka
     * @throws: &ErrorMsg, if the aka is malformed, or is a value
     */
    fn validateType (mut self, dmut context : &Validator, dmut sym : &AkaSymbol)
        throws &ErrorMsg
    {
        context:.pushReferent (alias sym);
        context:.enterForeign (isFnBody-> false);

        let type = {
            let t = context:.validateType (sym.getContent ().getContent (), parentMutable-> false);
            match t {
                c : &ClassRefType => { cast!{&Type} (c) }
                c : &ClassPtrType => {
                    if (!c.isStruct ()) {
                        throw ErrorMsg::fatal (sym.getContent ().getContent ().getLoc (), format (ValidateErrorMessage::CLASS_THROW_PTR, c));
                    }

                    cast!{&Type} (c.getInner ())
                }
                _ => {
                    context:.verifyCompleteType (sym.getContent ().getContent ().getLoc (), t, false);
                    t
                }
            }
        } catch {
            err : &ErrorMsg => {
                context:.exitForeign ();
                context:.popReferent ();

                let error = ErrorMsg::fatal (sym.getLoc (), format (ValidateErrorMessage::VALIDATING_SYMBOL, sym.getPath ()), notes-> [err])
                    sym:.setGenerator (ErrorGenerator::new (sym.getLoc (), error));
                throw error;
            }
        };

        context:.exitForeign ();
        context:.popReferent ();

        sym:.setGenerator (type.clone (mutLevel-> 0u32));
    }

    /**
     * Validate an aka symbol as a value
     * @params: 
     *    - context: the context of the validation
     *    - sym: the symbol to validate
     * @returns: the value contained in the aka
     * @throws: &ErrorMsg, if the aka is malformed, or is a type
     */
    fn validateValue (mut self, dmut context : &Validator, dmut sym : &AkaSymbol)
        throws &ErrorMsg
    {
        context:.pushReferent (alias sym);
        context:.enterForeign (isFnBody-> false);

        let value = {
            let loc = sym.getContent ().getContent ().getLoc ();
            let v = context:.validateValue (sym.getContent ().getContent ());

            if (self.checkUnaddressableValue (loc, v)) {
                throw ErrorMsg::fatal (sym.getLoc (), end-> loc, format (ValidateErrorMessage::AKA_CLASS_CTOR),
                                       notes-> [ErrorMsg::note (loc, oneLine-> true, format (ValidateErrorMessage::MAYBE_TYPE_AKA))]);
            }

            v
        } catch {
            err : &ErrorMsg => {
                context:.exitForeign ();
                context:.popReferent ();

                let error = ErrorMsg::fatal (sym.getLoc (), format (ValidateErrorMessage::VALIDATING_SYMBOL, sym.getPath ()), notes-> [err]);
                sym:.setGenerator (ErrorGenerator::new (sym.getLoc (), error));
                throw error;
            }
        };

        context:.exitForeign ();
        context:.popReferent ();

        sym:.setGenerator (value);
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================           CHECKING           =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Enter the validation of the symbol, to avoid infinite recursion
     */
    fn enterValidation (mut self, dmut sym : &AkaSymbol)
        throws &ErrorMsg
    {
        for it in self._validation {
            if it is sym {
                let error = ErrorMsg::fatal (sym.getLoc (), format (ValidateErrorMessage::FORWARD_REFERENCE_AKA, sym.getPath ()));
                sym:.setGenerator (ErrorGenerator::new (sym.getLoc (), error));
                throw error;
            }
        }

        self._validation:.insert (sym);
    }

    /**
     * Exit the validation of the symbol
     * */
    fn exitValidation (mut self, sym : &AkaSymbol) {
        self._validation:.remove (sym);
    }

    /**
     * Check wether the value can be used in an aka value
     * */
    fn checkUnaddressableValue (self, _ : &Word, v : &Value)-> bool {
        match v {
            CtorDelegateValue () => { return true; }
            CtorDelegateTemplateValue () => { return true; }
            m : &MultSymValue => {
                for i in m.getValues () {
                    if i.isOf!{&CtorDelegateValue} () || i.isOf!{&CtorDelegateTemplateValue} () {
                        return true;
                    }
                }

                return false;
            }
        }

        false
    }

}
