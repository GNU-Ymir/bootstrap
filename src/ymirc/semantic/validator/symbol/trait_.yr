in trait_;

use ymirc::semantic::validator::{visitor, errors};
use ymirc::semantic::{generator::_, symbol::_};
use ymirc::syntax::{declaration::_, expression::_};

use ymirc::lexing::keys;
use ymirc::errors::_;
use ymirc::utils::format;
use ymirc::lexing::word;
use std::{io, stream};

use ymirc::semantic::generator::type::{_,
                                       custom::_,
                                       native::{_, scalar::_, compound::_},
                                       temporary::_};

use ymirc::semantic::generator::value::{_,
                                        construct::{_, delegate::_},
                                        literal::_,
                                        memory::_,
                                        operator::{_, binary::_, call::_, fields::_, map::_, slice::_, unary::_},
                                        operator::map::iteration::_,
                                        prototypes::_,
                                        scope::_,
                                        syntax::_,
                                        template::_};

/**
 * The trait validator is the trait responsible for trait symbol validation
 */
pub record TraitValidator {

    /**
     * Create a new empty validator
     */
    pub self () {}

    /**
     * Validate an trait symbol
     * @params: 
     *    - context: the context of the validation
     *    - sym: the symbol to validate
     * @returns: the type of the trait
     * @throws: &ErrorMsg, if the trait is malformed
     */
    pub fn validate (self, dmut context : &Validator, dmut sym : &TraitSymbol)-> &Type
        throws ErrorMsg
    {
        if (!sym.isValidated ()) {
            let mut errors : [&ErrorMsg] = [];
            self.validateCondBlocks (alias context, alias sym, ref errors);
            if (errors.len != 0us) throw copy ErrorMsg::list (errors);

            self.validateAssertions (alias context, alias sym, ref errors);
            if (errors.len != 0us) throw copy ErrorMsg::list (errors);

            sym:.setValidated (true);
        }

        // Return a ref type, that can be used in class validator
        copy TraitRefType (sym.getLoc (), sym)
    }

    /**
     * Validate the conditional blocks of the trait
     * */
    fn validateCondBlocks (self, dmut context : &Validator, dmut sym : &TraitSymbol, ref mut errors : [&ErrorMsg]) {
        if (sym.getCondBlocks ().len != 0us) {
            context:.pushReferent (alias sym);
            context:.enterForeign (isFnBody-> false);

            for it in sym.getCondBlocks () {
                self.validateCondBlock (alias context, it, alias sym);
            } catch {
                err : &ErrorMsg => { errors ~= [err]; }
            }

            if (errors.len == 0us) {
                context:.getDeclarator ():.finalizeDeclaration (alias sym);
            } catch {
                err : &ErrorMsg => { errors ~= [err]; }
            }

            context:.exitForeign ();
            context:.popReferent ();
        }
    }

    /**
     * Validate declarations contained in a conditional block
     * @params:
     *    - context: the context of the validation
     *    - decl: the declaration to validate
     *    - sym: the symbol of the trait being validated
     * @throws:
     *    - ErrorMsg: of the validation fails
     * */
    fn validateCondBlock (self, dmut context : &Validator, decl : &Declaration, dmut sym : &TraitSymbol)
        throws ErrorMsg
    {
        match decl {
            c : &CondBlockDecl => {
                let val = context:.validateValue (c.getTest ());
                let b = context:.getCompileTimeInterpreter ():.computeBool (val);
                if (b) {
                    for j in c.getDeclarations () {
                        self.validateCondBlock (alias context, j, alias sym);
                    }
                } else {
                    self.validateCondBlock (alias context, c.getElse (), alias sym);
                }
            }
            _ => {
                context:.getDeclarator ():.declareInnerTrait (decl, alias sym, protection-> Protection::PROTECTED);
            }
        }
    }

    /**
     * Validate the static assertions of a trait symbol
     * @params:
     *   - context: the context of the validation
     *   - sym: the symbol to validate
     * @returns:
     *   - errors: if some assertions were invalid or not true
     * */
    fn validateAssertions (self, dmut context : &Validator, dmut sym : &TraitSymbol, ref mut errors : [&ErrorMsg]) {
        if (sym.getAssertions ().len != 0us) {
            context:.pushReferent (alias sym);
            context:.enterForeign (isFnBody-> false);

            for a in sym.getAssertions () {
                context:.validateCteValue (a);
            } catch {
                err : &ErrorMsg => { errors ~= [err]; }
            }
            
            context:.popReferent ();
            context:.exitForeign ();        
        }
    }

}
