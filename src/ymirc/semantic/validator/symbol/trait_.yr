in trait_;

use ymirc::semantic::validator::{visitor, errors};
use ymirc::semantic::symbol::trait_;
use ymirc::syntax::{declaration::_, expression::_};

use ymirc::syntax::keys;
use ymirc::semantic::generator::_;
use ymirc::errors::_;
use ymirc::utils::format;
use ymirc::lexing::word;
use std::{io, stream};

use ymirc::semantic::generator::type::{_,
                                       custom::_,
                                       native::{_, scalar::_, compound::_},
                                       temporary::_};

use ymirc::semantic::generator::value::{_,
                                        construct::{_, delegate::_},
                                        literal::_,
                                        memory::_,
                                        operator::{_, binary::_, call::_, fields::_, map::_, slice::_, unary::_},
                                        operator::map::iteration::_,
                                        prototypes::_,
                                        scope::_,
                                        syntax::_,
                                        template::_};

/**
 * The trait validator is the trait responsible for trait symbol validation
 */
pub record TraitValidator {

    /**
     * Create a new empty validator
     */
    pub self () {}

    /**
     * Validate an trait symbol
     * @params: 
     *    - context: the context of the validation
     *    - sym: the symbol to validate
     * @returns: the type of the trait
     * @throws: &ErrorMsg, if the trait is malformed
     */
    pub fn validate (self, dmut context : &Validator, dmut sym : &TraitSymbol)-> &Type
        throws ErrorMsg
    {
        let mut errors : [&ErrorMsg] = [];
        
        // Trait validation is really simple, because we don't really validate the inner symbols
        // They are validated when implemented, they requires elements that are defined inside classes (i.e. fields, and other methods)
        if (sym.getAssertions ().len != 0us) {
            context:.pushReferent (alias sym);
            context:.enterForeign (isFnBody-> false);
            
            for a in sym.getAssertions () {
                context:.validateCteValue (a);
            } catch {
                err : &ErrorMsg => { errors ~= [err]; }
            }
            
            context:.popReferent ();
            context:.exitForeign ();        
        }
        

        if (errors.len != 0us) throw copy ErrorMsg::list (errors);

        // Return a ref type, that can be used in class validator
        copy TraitRefType (sym.getLoc (), sym)
    }

}
