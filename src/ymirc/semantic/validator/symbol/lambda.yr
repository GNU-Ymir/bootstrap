in lambda;

use ymirc::semantic::validator::{visitor, errors};

use ymirc::syntax::{_,
                    declaration::_,
                    expression::{_, literal::_, macro_::_, operator::_, template::_}};

use ymirc::semantic::{generator::_, symbol::_};
use ymirc::errors::_;
use ymirc::utils::format;
use ymirc::lexing::{word, tokens};
use ymirc::global::core_;
use std::{io, stream};

use ymirc::semantic::generator::type::{_,
                                       syntax::_,
                                       custom::_,
                                       native::{_, scalar::_, compound::_},
                                       temporary::_};

use ymirc::semantic::generator::value::{_,
                                        syntax::_,
                                        construct::{_, delegate::_},
                                        literal::_,
                                        memory::_,
                                        operator::{_, binary::_, call::_, fields::_, map::_, slice::_, unary::_},
                                        operator::map::iteration::_,
                                        prototypes::_,
                                        scope::_,
                                        syntax::_,
                                        template::_};

/**
 * The lambda validator is the class responsible for lambda symbol validation
 */
@final
pub class LambdaValidator {

    // List of validated lambdas already inserted
    let mut _inserted : [[c8] => mut ()] = [];

    // The list of function created to cast fptr to dg
    let mut _fptrCasted : [[c8] => mut ()] = [];

    /**
     * Create a new empty validator
     */
    pub self () {}

    /**
     * Validate a lambda symbol
     * @params: 
     *    - context: the context of the validation
     *    - sym: the symbol to validate
     * @returns: the value of the lambda
     * @throws: &ErrorMsg, if the lambda is malformed
     */
    pub fn validate (mut self, dmut context : &Validator, sym : &LambdaValueExpr, isClosure : bool = false, forLazy : bool = false, copyLoc : &Word = EOF_WORD)-> &Value
        throws ErrorMsg
    {
        let name = format ("_%_%", sym.getLoc ().line, sym.getLoc ().col);
        let frameName = context:.getReferent ().getPath ().push (name);

        // We start by validating the prototype of the lambda
        // Unlike function prototype it can be uncomplete (missing some var decl type)
        let (paramVars, paramTypes, retType, uncomplete) = self.validateLambdaPrototype (alias context, sym.getFunctionProtoDecl ());

        // Each lambda has a uniq index, to be identified for closure in addition to there name
        let index = context.getCurrentClosingIndex ();
        let proto = copy LambdaValue (sym.getLoc (),
                                      copy LambdaType (sym.getLoc (), paramTypes, retType),
                                      frameName,
                                      paramVars,
                                      retType,
                                      sym.getValue (),
                                      isClosure,
                                      index,
                                      copyLoc-> copyLoc);
        
        if (uncomplete) { // Missing some types
            proto
        } else { // Have all the type we can validate it as a function
            let (retProto, frame) = self:.validateLambdaBody (alias context, proto, paramTypes, forLazy-> forLazy);
            self.insertGenerator (alias context, frame);

            retProto
        }
    }

    /**
     * Create a delegate that calls a function pointer to cast a function pointer to a delegate
     * @params:
     *    - context: the context of the validation
     *    - loc: the location of the casting
     *    - fptrType: the type to cast
     *    - func: the function to call (assuming its type is 'fptrType')
     * @returns: the prototype of the delegate
     * @throws:
     *    - &ErrorMsg: if the validation failed
     * */
    pub fn createDelegateFromFptr (mut self, dmut context : &Validator, loc : &Word, fptrType : &FuncPtrType, func : &Value)-> &Value {
        let frameName = copy SymbolPath (DelegateUtils::CAST_FPTR_TO_DG.toStr (sep-> "::"s8));
        let closureValue = func;
        let fstParam = copy ProtoVarValue (copy Word ("#{CLOSURE-VARREF}"s8, loc),
                                           fptrType,
                                           UNIT_VALUE,
                                           false,
                                           isSelf-> false,
                                           isReference-> false,
                                           isLazy-> false);

        let closureRef = copy VarRefValue (fstParam.getLoc (),
                                           fstParam.getLoc (),
                                           fptrType,
                                           fstParam.getUniqId (),
                                           isSelf-> false,
                                           isParam-> true,
                                           isReference-> false,
                                           isLazy-> false);

        let (paramVars, paramTypes, retType, body) = self.validateLambdaDGFromFptr (alias context, loc, fptrType, closureRef);
        let frameProto = copy NamePrototypeValue (loc, frameName, (copy [fstParam] ~ paramVars), retType, isLambda-> true);
        let retProto = copy NameDelegateValue (loc, frameProto, closure-> closureValue,
                                               fptrType.getReferences (),
                                               fptrType.getLazys (),
                                               paramTypes, retType, fromFptr-> true);

        let mnglName = Mangler ().mangle (frameProto);
        if (mnglName !in self._fptrCasted) {
            let frame = copy FrameGenerator (loc, frameName, parameters-> (copy [fstParam] ~ paramVars), retType, body, FrameKind::LMBD, isWeak-> true);
            self.insertGenerator (alias context, frame);
            self._fptrCasted [mnglName] = ();
        }

        retProto
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===============================          LAMBDA PARAMETERS          ================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Validate the prototype of a lambda expression
     * @params: 
     *   - context: the context of the validation
     *   - proto: the prototype of the lambda expression
     * @returns:
     *    - .0: the list of parameters of the lambda (ParamVar)
     *    - .1: the list of the types of the parameters (might be full of NoneType, if the lambda is not complete)
     *    - .2: the return type of the lambda (NoneType is possible even if the lambda is complete)
     *    - .3: true iif the lambda is complete and that the body can be validated
     * @throws: &ErrorMsg: if the lambda is malformed
     */
    fn validateLambdaPrototype (self, dmut context : &Validator, proto : &FunctionProtoDecl)-> ([&Value], [&Type], &Type, bool)
        throws ErrorMsg
    {
        let mut errors : [&ErrorMsg] = [];
        let mut uncomplete = false;
        let mut parameters : [&Value] = [];
        let mut types : [&Type] = [];

        // Enter a foreign because we don't want to pollute the current function scope (but this is only for the proto)
        context:.enterForeign (isFnBody-> false, clContext-> context.getCurrentClassContext ());
        context:.enterBlock ();
        
        for v in proto.getParameters () {
            {
                // If no type has been given in the definition of the lambda, then it is validated by calling it
                if (v.getType () of EmptyExpression) {
                    uncomplete = true;
                    parameters ~= [copy ExprWrapperValue (v.getLoc (), v)];
                    types ~= [NONE_TYPE];
                } else {
                    // Otherwise we can already make some validation
                    let (isRef, isLazy, type) = self.validateTypeParam (alias context, v);

                    let paramGen = copy ProtoVarValue (v.getLoc (), type, UNIT_VALUE, type.isMutable (), isSelf-> false, isReference-> isRef, isLazy-> isLazy);
                    parameters ~= [paramGen];
                    types ~= [type];
                    context:.insertLocal (paramGen.getLoc (), paramGen.getLoc ().str, paramGen);
                }
            } catch {
                err : &ErrorMsg => { errors ~= [err]; }
            }
        }

        let r : &Type = {        
            match proto.getRetType () {
                EmptyExpression () => {
                    // If no type is given as return type, it will take the type of the body (unlike normal function definition)
                    copy NoneType (proto.getLoc ())
                }
                x => { context:.validateType (x) }
            }
        } catch {
            err : &ErrorMsg => {
                errors ~= [err];
                NONE_TYPE
            }           
        };
        
        context:.quitBlock (warnUnused-> false);
        context:.exitForeign (); // Of course we exit the foreign a get back to the parent function definition

        if (errors.len != 0us) {
            throw copy ErrorMsg::list (errors);
        }
        return (parameters, types, r, uncomplete);
    }


    /**
     * Validate the type composant of a VarDeclExpr assuming it is not an EmptyExpression
     * @params: 
     *   - context: the context of the validation
     *   - v: the var decl whose type we have to validate
     * @returns: the type of the vardecl with correct mutable level
     * @throws: 
     *  - &ErrorMsg: if the type is not valid
     */
    fn validateTypeParam (self, dmut context : &Validator, vdecl : &VarDeclExpr)-> (bool, bool, &Type)
        throws ErrorMsg
    {
        let type = {
            context:.validateTypeForVarDecl (vdecl.getType (), vdecl, canBeRef-> true, canBeLazy-> true)
        } catch {
            err : &ErrorMsg => throw copy ErrorMsg::note (vdecl.getLoc (), ValidateErrorMessage::VALIDATING, notes-> copy [err]);
        };
        
        if (type.isMutable () && !type.needExplicitAlias () && !type.isMovable () && !vdecl.isRef ()) { // Verification that the value is mutable iif it is aliasable
            throw copy ErrorMsg::fatal (vdecl.getLoc (), ValidateErrorMessage::MUTABLE_CONST_PARAM);
        }

        context.verifyNonVoidType (vdecl.getType ().getLoc (), type, true);
        (vdecl.isRef (), vdecl.isLazy (), type)
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ==================================          LAMBDA BODY          ===================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Validate the body of a lambda expression, assuming that the lambda is complete
     * @params: 
     *    - context: the context of the validation
     *    - proto: the prototype of the lambda to validate
     *    - paramTypes: the type of the parameters of the lambda
     *    - declare: if true, finalize the validation and insert the frame generator
     * @throws: &ErrorMsg: if the lambda is malformed
     */
    pub fn validateLambdaBody (mut self, dmut context : &Validator, lmbd : &LambdaValue, paramTypes : [&Type], forLazy : bool = false, castClosure : bool = false)-> (&Value, &FrameGenerator)
        throws ErrorMsg
    {
        context:.enterForeign (isLambda-> true, isFnBody-> true, clContext-> context.getCurrentClassContext ()); // Enter a foreign because we don't want to pollute the current function scope
        context:.enterBlock ();
        {
            let mut error : (&ErrorMsg)? = none;
            let (proto, frame) = {
                // Validate the parameters with the correct types
                // insert them in context, and set the return type of the lambda
                let (references, lazys, types, params) = self.validateFinalParameters (alias context, lmbd, paramTypes);

                let refId = generator::generateUniqID ();
                // Validate the body of the lambda
                let (body, closure, retType) = self.validateLambdaBody (alias context, refId, lmbd, forLazy-> forLazy, castClosure-> castClosure);

                match closure {
                    cl : &ClosureType => {
                        let closureType = copy TupleType (cl.getLoc (), cl.getInnerTypes ());
                        let ptrType = copy PointerType (cl.getLoc (), closureType, isMutable-> false);

                        // We override the uniq Id of the next variable, so all the varref to closure are refering to this proto variable
                        let fstParam = copy ProtoVarValue (copy Word ("#{CLOSURE-VARREF}"s8, cl.getLoc ()), ptrType, refId-> refId);
                        let frame = copy FrameGenerator (lmbd.getLoc (), lmbd.getName (), parameters-> (copy [fstParam] ~ params), retType, body, FrameKind::LMBD, isWeak-> true);
                        let closureValue = if (cl.getInnerTypes ().len != 0us) {
                            copy CopierValue (cl.getLoc (),
                                              ptrType,
                                              copy TupleValue (cl.getLoc (), closureType, cl.getInnerValues ()))
                        } else {
                            copy NullValue (cl.getLoc (), ptrType)
                        }

                        let proto = copy NamePrototypeValue (lmbd.getLoc (), lmbd.getName (), copy [fstParam] ~ params, retType, isLambda-> true);
                        let dgValue = copy NameDelegateValue (lmbd.getLoc (), proto, closure-> closureValue, references, lazys, types, retType, fromFptr-> (castClosure && !lmbd.isClosure ()));
                        (dgValue, frame)
                    }
                    _ => {
                        let frame = copy FrameGenerator (lmbd.getLoc (), lmbd.getName (), parameters-> params, retType, body, FrameKind::LMBD, isWeak-> true);
                        let proto = copy NamePrototypeValue (lmbd.getLoc (), lmbd.getName (), params, retType, isLambda-> true);
                        (copy ProtoFuncPtrValue (lmbd.getLoc (), proto, references, lazys, types, retType), frame)
                    }
                }
            } catch {
                err : &ErrorMsg => {
                    let dmut stream = copy Formatter ();

                    if (!forLazy) {
                        stream:.write ('{');
                        for i, ti in paramTypes {
                            if (i != 0us) stream:.write (", ");
                            stream:.write (format ("%", ti));
                        }
                        stream:.write ('}');

                        throw copy ErrorMsg::fatal (lmbd.getLoc (), format (ValidateErrorMessage::TEMPLATE_SPECIALIZATION_FAILS_SIMPLE, stream),
                                                    notes-> copy [err]);
                    } else {
                        for i, ti in paramTypes {
                            if (i != 0us) stream:.write (", ");
                            stream:.write (format ("%", ti));
                        }

                        throw copy ErrorMsg::fatal (lmbd.getLoc (), format (ValidateErrorMessage::LAZY_VALIDATION, stream),
                                                    notes-> copy [err]);
                    }
                }
            } exit {
                {
                    context:.quitBlock (warnUnused-> match error { Ok () => { false }
                                                                   _ => { true }});
                } catch {
                    err : &ErrorMsg => {
                        error = err?;
                    }
                }
            }

            if let Ok (msg) = error { throw msg; }

            (proto, frame)
        } exit {        
            context:.exitForeign (); // Of course we exit the foreign a get back to the parent function definition
        }
    }     

    /**
     * Insert the frame generator (if the frame does not already exist)
     * */
    pub fn insertGenerator (self, dmut context : &Validator, frame : &FrameGenerator) {
        let name = Mangler ().mangle (frame); // .getName ().toStr ();
        if !context.hasCustomGenerator (name) {
            context:.insertNamedGenerator (name, alias context:.getReferent (), frame);
        }
    }

    /**
     * Validate the uncomplete parameters of the lambda, with the given paramTypes
     * @warning: complete var decl must have the same types as the corresponding paramTypes
     * @info: update the context by inserting param var decl in the current scope and setting current return type of function
     * @assume: a new foreign is entered, and there is at least one scope to fill
     * @params: 
     *   - context: the context of the validation
     *   - proto: the proto lambda to validate
     *   - paramTypes: the types of the var decls 
     * @returns: the list of parameters
     * @throws: 
     *   - &ErrorMsg: if there is a incompatibility between paramTypes and proto
     */
    fn validateFinalParameters (self, dmut context : &Validator, proto : &LambdaValue, paramTypes : [&Type])-> ([bool], [bool], [&Type], [&ProtoVarValue])
        throws ErrorMsg
    {
        if (proto.getParameters ().len != paramTypes.len) panic;
        
        let mut parameters : [&ProtoVarValue] = [];
        let mut types : [&Type] = [];
        let mut references : [bool] = [];
        let mut lazys : [bool] = [];
        let mut errors : [&ErrorMsg] = [];
        
        for i, param in proto.getParameters () {
            {
                match param {
                    v : &ProtoVarValue => {
                        context.verifyCompatibleType (v.getLoc (), paramTypes[i].getLoc (), v.getType (), paramTypes [i]);
                        parameters ~= [v];
                        references ~= [v.isReference ()];
                        lazys ~= [v.isLazy ()];
                        types ~= [v.getType ()];

                        context:.insertLocal (v.getLoc (), v.getLoc ().str, v);
                    }
                    w : &ExprWrapperValue => { // prototype value is not finished, we need to validate it
                        match w.getContent () {
                            inner : &VarDeclExpr => {
                                let vdecl = copy VarDeclExpr (w.getLoc (), inner.getName (), inner.getValue (),
                                                              copy TypeWrapperExpr (inner.getLoc (), paramTypes [i]),
                                                              isLazyOrRef-> inner.getLazyOrRefLocation (),
                                                              isMutOrDmut-> inner.getMutOrDmutLocation ());

                                let (isRef, isLazy, type) = self.validateTypeParam (alias context, vdecl);
                                context.verifyCompatibleType (vdecl.getLoc (), paramTypes [i].getLoc (), type, paramTypes [i]);
                                let paramGen = copy ProtoVarValue (inner.getLoc (), type, UNIT_VALUE, type.isMutable (), isSelf-> false, isReference-> isRef, isLazy-> isLazy);

                                parameters ~= [paramGen];
                                types ~= [type];
                                references ~= [isRef];
                                lazys ~= [isLazy];

                                context:.insertLocal (paramGen.getLoc (), paramGen.getLoc ().str, paramGen);
                            }
                            _ => panic;
                        }
                    }
                    _ => panic;
                }
            } catch {
                err : &ErrorMsg => { errors ~= [err]; }
            }
        }

        if (errors.len != 0us) throw copy ErrorMsg::list (errors);
        context:.setFunctionReturn (proto.getRetType ());


        (references, lazys, types, parameters)
    }

    /**
     * Validate the body of a lambda value
     * @assume: a new foreign is entered, and there is at least one scope to fill
     * @params: 
     *   - context: the context of the validation
     *   - lmbd: the lambda to finish validating
     *   - params: the list of parameters of the lambda proto
     * @returns: 
     *   - .0: the body of the lambda
     *   - .1: the closure type
     *   - .2: the return type of the lambda
     * @throws:
     *   - &ErrorMsg: if the lambda was no valid
     */
    fn validateLambdaBody (self, dmut context : &Validator, refId : usize, lmbd : &LambdaValue, forLazy : bool = false, castClosure : bool = false)-> (&Value, &Type, &Type)
        throws ErrorMsg
    {
        if (lmbd.isClosure ()) {
            context:.enterClosure (lmbd.getLoc (), refId, lmbd.getClosureIndex ());
        }
        
        let mut body = {
            context:.validateValue (lmbd.getContent ())
        } catch {
            err : &ErrorMsg => {
                if (lmbd.isClosure ()) context:.exitClosure ();
                throw err;
            }
        }
        
        let mut retType = context.getFunctionReturn ();
        
        let closure = if (lmbd.isClosure ()) {
            let ret = context:.exitClosure ();
            if (ret.getInnerTypes ().len == 0us && !forLazy) {
                throw copy ErrorMsg::fatal (lmbd.getCopyLoc (), format (ValidateErrorMessage::UNECESSARY_LMBD_COPY));
            }

            ret
        } else {
            if (castClosure) {
                copy ClosureType::empty (EOF_WORD, refId)
            } else {
                copy NoneType (lmbd.getLoc ())
            }
        };

        let mut need = false;
        if (!body.isReturner ()) { // If there is a path in the body that leads to an exit with no return
            match retType {
                NoneType () => { // There is no return in the body
                    if (forLazy) {
                        retType = copy VoidType (lmbd.getLoc ());
                    } else {
                        retType = body.getType ();
                        need = (retType !of VoidType && retType !of NoneType);
                    }
                }
                _ => { // There is a return, and we need to check the type mutability
                    body = context:.verifyCompatibleTypeWithValue (retType.getLoc (), retType, body, byReference-> false);
                    context.verifyMemoryOwner (retType.getLoc (), retType, body, construct-> true, byReference-> false);
                }
            }
        }

        if (body.getThrowers ().len != 0us) {
            let mut list = copy [copy ErrorMsg::note (it._0, format ("%", it._1)) for it in body.getThrowers ()];
            throw copy ErrorMsg::fatal (lmbd.getLoc (), notes-> list, ValidateErrorMessage::THROWS_IN_LAMBDA);
        }

        if (need) {
            (copy ReturnValue (body.getLoc (), body), closure, retType)
        } else {
            (body, closure, retType)
        }
    }


    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =================================          LAMBDA CASTING          =================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Validate a lambda prototype and body calling a function pointer to cast a fptr to a dg
     * @params:
     *    - context: the context of the validation
     *    - loc: the location of the casting
     *    - fptrType: the type to cast
     *    - func: the function to call (assuming its type is 'fptrType')
     * @returns:
     *    - .0: the parameters of the function
     *    - .1: the types of the parameters
     *    - .2: the return type of the function
     *    - .3: the body of the function
     * @throws:
     *    - &ErrorMsg: if the validation failed
     * */
    fn validateLambdaDGFromFptr (self, dmut context : &Validator, loc : &Word, fptrType : &FuncPtrType, closureRef : &Value)-> ([&ProtoVarValue], [&Type], &Type, &Value) {
        let mut parameters : [&ProtoVarValue] = [];
        let mut usedCall : [&Value] = [];
        let mut types : [&Type] = [];

        context:.enterForeign (isFnBody-> false, clContext-> context.getCurrentClassContext ());
        context:.enterBlock ();

        for i in 0us .. fptrType.getParameters ().len {
            let type = fptrType.getParameters ()[i];
            let paramGen = copy ProtoVarValue (copy Word (format ("v_%", i), loc),
                                               type,
                                               UNIT_VALUE,
                                               type.isMutable (),
                                               isSelf-> false,
                                               isReference-> fptrType.getReferences ()[i],
                                               isLazy-> fptrType.getLazys ()[i]);
            parameters ~= [paramGen];
            types ~= [type];
            context:.insertLocal (paramGen.getLoc (), paramGen.getLoc ().str, paramGen, canShadow-> true)?;
        }

        context:.enterFunctionBody ();

        for i in 0us .. fptrType.getParameters ().len {
            let pgen = parameters [i];
            let var : &Value = copy VarRefValue (pgen.getLoc (),
                                                 pgen.getLoc (),
                                                 pgen.getType (),
                                                 pgen.getUniqId (),
                                                 isSelf-> false,
                                                 isParam-> true,
                                                 isReference-> pgen.isReference (),
                                                 isLazy-> pgen.isLazy ());

            let p = if (pgen.isLazy ()) {
                copy LazyValue (var.getLoc (),
                                var.getType (),
                                var,
                                UNIT_VALUE,
                                byAlias-> false,
                                isDone-> true)
            } else {
                if (pgen.isReference ()) {
                    copy ReferencerValue (pgen.getLoc (), var.getType (), var)
                } else { var }
            };

            usedCall ~= [p];
        }

        let r = fptrType.getRetType ();
        let mut cl : &Value = copy FuncPtrCallValue (loc, r, closureRef, usedCall);
        if (r !of VoidType && r !of NoneType) {
            cl = copy ReturnValue (loc, cl);
        }

        {
            context:.quitBlock (warnUnused-> false);
        } catch { _ => panic; }

        context:.exitForeign ();

        return (parameters, types, r, cl);
    }
}
