mod ymirc::global::state;

import std::io, std::fs::path;
import std::collection::vec, std::collection::set;
import ymirc::utils::string;

static dmut __instance__ : &State = State::new ();

pub def instance () -> dmut &State {
    alias __instance__
}

/**
 * Global state of the compilation
 */
pub class State {

    let mut _isDebug = false;

    let mut _isVerbose = false;

    let mut _isStandalone = false;

    let mut _isDumpDoc = false;

    let mut _isTrusted = false;

    let mut _includePrefix = Path::new ("include/ymir/"s8);

    let mut _corePath = Path::new (""s8);

    let mut _prefixPath = Path::new (""s8);

    let mut _executable = Path::new (""s8);

    let dmut _includeDirs = HashSet!(&Path)::new ();

    let dmut _versions = HashSet!([c8])::new ();
    
    pub self () {}

    /**
     * ================================================================================
     * ================================================================================
     * =========================           SETTERS            =========================
     * ================================================================================
     * ================================================================================
     */

    pub def setExecutable (mut self, name : [c8]) {        
        self._executable = Path::new (name);
        self:.setPrefix (self._executable.parent ().toStr ());
    }

    pub def activateDebug (mut self) {
        self._isDebug = true;
    }

    pub def activateVerbose (mut self) {
        self._isVerbose = true;
    }

    pub def activateStandalone (mut self) {
        self._isStandalone = true;
    }

    pub def activateDocDumping (mut self) {
        self._isDumpDoc = true;
    }

    pub def addVersion (mut self, v : [c8]) {
        self._versions:.insert (v);
    }

    pub def addIncludeDir (mut self, dir : [c8]) {
        self._includeDirs:.insert (Path::new (dir));
    }
    
    pub def setPrefix (mut self, prefix : [c8]) {
        self._prefixPath = Path::new (prefix);
        let dmut path = Path::new (prefix);
        path:.push (self._includePrefix);
        self._includeDirs:.insert (path);
        path:.push ("core"s8);
        self._corePath = path;
    }
    
    /**
     * ================================================================================
     * ================================================================================
     * =========================           GETTERS            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * @returns: true of the version is active
     */
    pub def isVersionActive (self, v : [c8])-> bool {
        v in self._versions
    }

    /**
     * @returns: the path of the prefix of the executable (pwd of the executable)
     */
    pub def getIncludePrefix (self)-> &Path {
        self._includePrefix
    }

    /**
     * @returns: the directory containing the core files
     */
    pub def getCorePath (self)-> &Path {
        self._corePath
    }

    /**
     * @returns: the list of directories that are included (-I option)
     */
    pub def getIncludeDirs (self)-> [&Path] {
        self._includeDirs[]
    }

    
    impl Streamable;           
    
}

__version GYC {


    extern (C) def __bootstrap__set_executable_ (name : [c8]) {
        import std::conv;
        __instance__:.setExecutable (copy name);
    }

    extern (C) def __bootstrap__activate_debug_ () {
        __instance__:.activateDebug ()
    }

    extern (C) def __bootstrap__activate_verbose_ () {
        __instance__:.activateDebug ()
    }

    extern (C) def __bootstrap__activate_dump_doc_ () {
        __instance__:.activateDebug ()
    }

    extern (C) def __bootstrap__activate_standalone_ () {
        __instance__:.activateDebug ()
    }

    extern (C) def __bootstrap__activate_version_ (v : [c8]) {
        __instance__:.addVersion (copy v)
    }

    extern (C) def __bootstrap__add_include_dir_ (dir : [c8]) {
        __instance__:.addIncludeDir (copy dir)
    }

    extern (C) def __bootstrap__set_prefix_ (prefix : [c8]) {
        __instance__:.setPrefix (copy prefix)
    }

}
