mod ymirc::global::state;

import std::io, std::fs::path;
import std::collection::vec, std::collection::set;
import ymirc::utils::string;

static dmut __instance__ : &State = State::new ();

pub def instance () -> dmut &State {
    alias __instance__
}

/**
 * Global state of the compilation
 */
pub class State {

    let mut _isDebug = false;

    let mut _isVerbose = false;

    let mut _isStandalone = false;

    let mut _isDumpDoc = false;

    let mut _isTrusted = false;

    let mut _isUnitTest = false;

    let mut _includePrefix = Path::new ("include/ymir/"s8);

    let mut _corePath = Path::new ("/usr/include/ymir/core"s8);

    let mut _prefixPath = Path::new ("/usr/include/ymir/"s8);

    let mut _executable = Path::new (""s8);

    let dmut _includeDirs = HashSet!(&Path)::new ();

    let dmut _versions = HashSet!([c8])::new ();

    // The size of the size type in bits
    let mut _sizeTypeSize = 64u32;

    // The size of the biggest float type in bits
    let mut _floatTypeSize = 64u32;

    pub self () {
        self._includeDirs:.insert (Path::new ("/usr/include/ymir/"));
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================           SETTERS            =========================
     * ================================================================================
     * ================================================================================
     */

    pub def setExecutable (mut self, name : [c8]) {        
        self._executable = Path::new (name);
        self:.setPrefix (self._executable.parent ().toStr ());
    }

    pub def activateDebug (mut self) {
        self._isDebug = true;
    }

    pub def isDebugActive (self)-> bool {
        self._isDebug
    }

    pub def activateUnittest (mut self) {
        self._isUnitTest = true;
    }

    pub def isUnittestActive (self)-> bool {
        self._isUnitTest
    }
    
    pub def activateVerbose (mut self) {
        self._isVerbose = true;
    }

    pub def activateStandalone (mut self) {
        self._isStandalone = true;
    }

    pub def activateDocDumping (mut self) {
        self._isDumpDoc = true;
    }

    pub def addVersion (mut self, v : [c8]) {
        self._versions:.insert (v);
    }

    pub def addIncludeDir (mut self, dir : [c8]) {
        self._includeDirs:.insert (Path::new (dir));
    }
    
    pub def setPrefix (mut self, prefix : [c8]) {
        self._prefixPath = Path::new (prefix);
        let dmut path = Path::new (prefix);
        path:.push (self._includePrefix);
        self._includeDirs:.insert (path);
        path:.push ("core"s8);
        self._corePath = path;
    }

    pub def setSizeTypeSize (mut self, size : u32) {
        self._sizeTypeSize = size;
    }

    pub def setFloatTypeSize (mut self, size : u32) {
        self._floatTypeSize = size;
    }

    /**
     * ================================================================================
     * ================================================================================
     * =========================           GETTERS            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * @returns: true of the version is active
     */
    pub def isVersionActive (self, v : [c8])-> bool {
        v in self._versions
    }

    /**
     * @returns: the path of the prefix of the executable (pwd of the executable)
     */
    pub def getIncludePrefix (self)-> &Path {
        self._includePrefix
    }

    /**
     * @returns: the directory containing the core files
     */
    pub def getCorePath (self)-> &Path {
        self._corePath
    }

    /**
     * @returns: the list of directories that are included (-I option)
     */
    pub def getIncludeDirs (self)-> [&Path] {
        self._includeDirs[]
    }

    /**
     * @returns: true iif the standalone option is activated
     */
    pub def isStandalone (self)-> bool {
        self._isStandalone
    }

    /**
     * @returns: the size in bits of the size type (pointer size)
     */
    pub def getSizeTypeSize (self)-> u32 {
        self._sizeTypeSize
    }

    /**
     * @returns: the size in bits of the biggest float type (e.g. __float80)
     * */
    pub def getFloatTypeSize (self)-> u32 {
        self._floatTypeSize
    }

    impl Streamable;           
    
}
