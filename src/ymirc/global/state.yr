mod ymirc::global::state;

import std::io, std::fs::path;
import std::collection::vec, std::collection::set;
import ymirc::utils::string;

static dmut __instance__ : &State = State::new ();

pub def instance () -> dmut &State {
    alias __instance__
}

/**
 * Global state of the compilation
 */
pub class State {

    let mut _isDebug = false;

    let mut _isVerbose = false;

    let mut _isStandalone = false;

    let mut _isDumpDoc = false;

    let mut _isTrusted = false;

    let mut _includePrefix = "include/ymir/"s8;

    let mut _corePath = ""s8;

    let mut _prefixPath = ""s8;

    let mut _executable = ""s8;

    let dmut _includeDirs = HashSet!([c8])::new ();

    let dmut _versions = HashSet!([c8])::new ();
    
    pub self () {}

    /**
     * ================================================================================
     * ================================================================================
     * =========================           SETTERS            =========================
     * ================================================================================
     * ================================================================================
     */

    pub def setExecutable (mut self, name : [c8]) {        
        self._executable = name;
        let index = self._executable.findLast ('/'c8);
        self:.setPrefix (self._executable [0us .. index])?;
    }

    pub def activateDebug (mut self) {
        self._isDebug = true;
    }

    pub def activateVerbose (mut self) {
        self._isVerbose = true;
    }

    pub def activateStandalone (mut self) {
        self._isStandalone = true;
    }

    pub def activateDocDumping (mut self) {
        self._isDumpDoc = true;
    }

    pub def addVersion (mut self, v : [c8]) {
        self._versions:.insert (v);
    }

    pub def addIncludeDir (mut self, dir : [c8]) {
        self._includeDirs:.insert (dir);
    }
    
    pub def setPrefix (mut self, prefix : [c8]) {
        self._prefixPath = prefix;
        let dmut path = Path::new (prefix);
        path:.push (self._includePrefix);
        self._includeDirs:.insert (path.toStr ());
        path:.push ("core"s8)
            self._corePath = path.toStr ();
    }
    
    /**
     * ================================================================================
     * ================================================================================
     * =========================           GETTERS            =========================
     * ================================================================================
     * ================================================================================
     */
    
    pub def isVersionActive (self, v : [c8])-> bool {
        v in self._versions
    }

    
    impl Streamable;           
    
}

__version GYC {


    extern (C) def __bootstrap__set_executable_ (name : [c8]) {
        import std::conv;
        __instance__:.setExecutable (copy name);
    }

    extern (C) def __bootstrap__activate_debug_ () {
        __instance__:.activateDebug ()
    }

    extern (C) def __bootstrap__activate_verbose_ () {
        __instance__:.activateDebug ()
    }

    extern (C) def __bootstrap__activate_dump_doc_ () {
        __instance__:.activateDebug ()
    }

    extern (C) def __bootstrap__activate_standalone_ () {
        __instance__:.activateDebug ()
    }

    extern (C) def __bootstrap__activate_version_ (v : [c8]) {
        __instance__:.addVersion (copy v)
    }

    extern (C) def __bootstrap__add_include_dir_ (dir : [c8]) {
        __instance__:.addIncludeDir (copy dir)
    }

    extern (C) def __bootstrap__set_prefix_ (prefix : [c8]) {
        __instance__:.setPrefix (copy prefix)
    }

}
