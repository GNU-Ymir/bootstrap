in state;

use std::{io, env, fs::{sys, path}, stream};
use ymirc::utils::string;

lazy dmut __instance__ : [&State] = copy [copy State ()];
lazy __GLOB_CURRENT_LOC__ = env::currentDir ();
lazy mut __GLOB_REL__ : [mut [[c8] => mut [c8]]] = copy [copy []];

pub fn instance () -> dmut &State {
    alias __instance__ [0]
}

pub fn resetInstance () {
    __instance__ [0] = copy State ();
    __GLOB_REL__ [0] = copy [];
}

pub fn relativePath (p : [c8])-> [c8] {
    if (p == []) return p;

    match __GLOB_REL__ [0][p] {
        Ok (res : _) => { return res; }
        _ => {
            let loc = Path (p);
            if (__GLOB_CURRENT_LOC__.isPrefix (loc)) {
                let res = loc.removePrefix (__GLOB_CURRENT_LOC__).toStr ();
                __GLOB_REL__ [0][p] = res;
                return res;
            } else {
                return p;
            }
        }
    }
}


/**
 * Global state of the compilation
 */
@final
pub class State {

    let mut _isDebug : bool = false;

    let mut _isVerbose : bool = false;

    let mut _isStandalone : bool = false;

    let mut _isDumpDoc : bool = false;

    let mut _dumpDocFile : Path = Path ("");

    let mut _isYmirDump : bool = false;

    let mut _isSymTreeDump : bool = false;

    let mut _isDumpDeps : bool = false;

    let mut _dumpDepDir : Path = Path ("");
    
    let mut _exportYIL : bool = false;

    let mut _yilOutput : Path = Path ("");
    
    let mut _isTrusted : bool = false;

    let mut _isUnitTest : bool = false;

    let mut _includePrefix : Path = Path ("include/ymir/1.1");

    let mut _corePath : Path = Path ("/usr/include/ymir/1.1");

    let mut _executable : Path = Path ("");

    let mut _package : Path = Path ("");

    let mut _rootModule : Path = Path ("");

    let dmut _includeDirs : [Path => ()] = copy [];

    let dmut _versions : [[c8] => ()] = copy [];

    // The size of the size type in bits
    let mut _sizeTypeSize : u32 = 64u32;

    // The size of the biggest float type in bits (assuming by fnault its f80, aligned on 16 bytes)
    let mut _floatTypeSize : u32 = 128u32;

    // The number of cte for loop that can be unwinded at cte
    let mut _maxCteLoopIter : usize = 1024us;

    // The list of module to compile (iif self._filteringModules)
    let mut _pathFilters : [mut Path] = [];

    // True iif filtering out modules from compilation
    let mut _filteringModules : bool = false;

    pub self () {
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================           SETTERS            =========================
     * ================================================================================
     * ================================================================================
     */

    pub fn setExecutable (mut self, name : [c8]) {
        self._executable = Path (name);
        self:.setPrefix (self._executable.parent ().toStr ());
    }

    pub fn setPackage (mut self, package : Path) {
        self._package = package;
    }

    pub fn setRootModule (mut self, path : Path) {
        self._rootModule = path;
    }

    pub fn activateYILExport (mut self, path : Path) {
        self._exportYIL = true;
        self._yilOutput = path;
    }

    pub fn isExportYIL (self)-> bool {
        self._exportYIL
    }

    pub fn getYILOutput (self)-> Path {
        self._yilOutput
    }
    
    pub fn activateDebug (mut self) {
        self._isDebug = true;
    }

    pub fn isDebugActive (self)-> bool {
        self._isDebug
    }

    pub fn activateUnittest (mut self) {
        self._isUnitTest = true;
    }

    pub fn isUnittestActive (self)-> bool {
        self._isUnitTest
    }
    
    pub fn activateVerbose (mut self) {
        self._isVerbose = true;
    }

    pub fn isVerboseActive (self)-> bool {
        self._isVerbose
    }

    pub fn activateStandalone (mut self) {
        self._isStandalone = true;
    }

    pub fn activateDocDumping (mut self, loc : Path) {
        self._isDumpDoc = true;
        self._dumpDocFile = loc;
    }

    pub fn activateYmirDumping (mut self) {
        self._isYmirDump = true;
    }

    pub fn activateDependencyDumping (mut self, loc : Path) {
        self._isDumpDeps = true;
        self._dumpDepDir = loc;
    }

    pub fn activateSymTreeDumping (mut self) {
        self._isSymTreeDump = true;
    }

    pub fn addVersion (mut self, v : [c8]) {
        let version = copy [std::char::toUpper (i) for i in v];
        self._versions [version] = ();
    }

    pub fn addIncludeDir (mut self, dir : [c8]) {
        self._includeDirs [Path (dir)] = ();
    }
    
    pub fn setPrefix (mut self, prefix : [c8]) {
        let path = Path (prefix).push (self._includePrefix);
        if (fs::sys::isDir (path)) {
            self._corePath = path;
        }
    }

    pub fn setSizeTypeSize (mut self, size : u32) {
        self._sizeTypeSize = size;
    }

    pub fn setFloatTypeSize (mut self, size : u32) {
        self._floatTypeSize = size;
    }

    pub fn setMaxCteLoopIter (mut self, nb : usize) {
        self._maxCteLoopIter = nb;
    }

    pub fn insertPathFilter (mut self, p : Path) {
        self._filteringModules = true;
        self._pathFilters ~= [p];
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================           GETTERS            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * @returns: the path of the package being constructed
     * */
    pub fn getPackage (self)-> Path {
        self._package
    }

    /**
     * @returns: the root module passed to the compiler
     * */
    pub fn getRootModule (self)-> Path {
        self._rootModule
    }
    
    /**
     * @returns: true of the version is active
     */
    pub fn isVersionActive (self, v : [c8])-> bool {
        let version = copy [std::char::toUpper (i) for i in v];
        version in self._versions
    }

    /**
     * @returns: the path of the prefix of the executable (pwd of the executable)
     */
    pub fn getIncludePrefix (self)-> Path {
        self._includePrefix
    }

    /**
     * @returns: the directory containing the core files
     */
    pub fn getCorePath (self)-> Path {
        self._corePath
    }

    /**
     * @returns: the list of directories that are included (-I option)
     */
    pub fn getIncludeDirs (self)-> [Path] {
        copy [p for p, _ in self._includeDirs]
    }

    /**
     * @returns: true iif the standalone option is activated
     */
    pub fn isStandalone (self)-> bool {
        self._isStandalone
    }

    /**
     * @returns: true iif the ymir dump option is activated (dumping intermediate representation to a file)
     * */
    pub fn isYmirDumping (self)-> bool {
        self._isYmirDump
    }

    /**
     * @returns: true iif the dump dependency option is activated
     * */
    pub fn isDumpDependencies (self)-> bool {
        self._isDumpDeps
    }

    /**
     * @returns: the directory in which the dependency dumping has to be done
     * */
    pub fn getDependencyDumpDir (self)-> Path {
        self._dumpDepDir
    }

    /**
     * @returns: true iif the doc dumping option is activated
     * */
    pub fn isDocDumping (self)-> bool {
        self._isDumpDoc
    }

    /**
     * @returns: the file in which the doc dumping has to be done
     * */
    pub fn getDocDumpFile (self)-> Path {
        self._dumpDocFile
    }

    /**
     * @returns: true if the sym tree dump option is activated (dumping symbol tree to file)
     * */
    pub fn isSymTreeDumping (self)-> bool {
        self._isSymTreeDump
    }

    /**
     * @returns: the size in bits of the size type (pointer size)
     */
    pub fn getSizeTypeSize (self)-> u32 {
        self._sizeTypeSize
    }

    /**
     * @returns: the size in bits of the biggest float type (e.g. __float80)
     * */
    pub fn getFloatTypeSize (self)-> u32 {
        self._floatTypeSize
    }

    /**
     * @returns: the maximal number of unwindable loop iterations at cte
     * */
    pub fn getMaxCteLoopIter (self)-> usize {
        self._maxCteLoopIter
    }

    /**
     * @returns: true if the compiler has to only compile a subset of the declared module from the current package
     * */
    pub fn hasModuleFilters (self)-> bool {
        self._filteringModules
    }

    /**
     * @returns: the list of path that have to be compiled (only applies iif self.hasModuleFilters ())
     * */
    pub fn getModuleFilters (self)-> [Path] {
        self._pathFilters
    }


    impl Streamable;           
    
}
