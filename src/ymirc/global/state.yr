in state;

use std::{io, env, fs::{sys, path}, stream};
use ymirc::utils::string;

lazy dmut __instance__ : &State = copy State ();
lazy __GLOB_CURRENT_LOC__ = env::currentDir ();
lazy dmut __GLOB_REL__ : [[c8] => [c8]] = [];

pub fn instance () -> dmut &State {
    alias __instance__
}

pub fn resetInstance () {
    __instance__ = copy State ();
    __GLOB_REL__ = [];
}

pub fn relativePath (p : [c8])-> [c8] {
    if (p == []) return p;

    match __GLOB_REL__.find (p) {
        Ok (res : _) => { return res; }
        _ => {
            let loc = Path (p);
            if (__GLOB_CURRENT_LOC__.isPrefix (loc)) {
                let res = loc.removePrefix (__GLOB_CURRENT_LOC__).toStr ();
                __GLOB_REL__ [p] = res;
                return res;
            } else {
                return p;
            }
        }
    }
}


/**
 * Global state of the compilation
 */
@final
pub class State {

    let mut _isDebug = false;

    let mut _isVerbose = false;

    let mut _isStandalone = false;

    let mut _isDumpDoc = false;

    let mut _isYmirDump = false;

    let mut _isSymTreeDump = false;

    let mut _isTrusted = false;

    let mut _isUnitTest = false;

    let mut _includePrefix = Path ("include/ymir/");

    let mut _corePath = Path ("/usr/include/ymir/");

    let mut _prefixPath = Path ("/usr/include/ymir/");

    let mut _executable = Path ("");

    let mut _package = Path ("");

    let dmut _includeDirs : [Path => ()] = [];

    let dmut _versions : [[c8] => ()] = [];

    // The size of the size type in bits
    let mut _sizeTypeSize = 64u32;

    // The size of the biggest float type in bits (assuming by fnault its f80, aligned on 16 bytes)
    let mut _floatTypeSize = 128u32;

    // The number of cte for loop that can be unwinded at cte
    let mut _maxCteLoopIter = 1024us;

    pub self () {
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================           SETTERS            =========================
     * ================================================================================
     * ================================================================================
     */

    pub fn setExecutable (mut self, name : [c8]) {
        self._executable = Path (name);
        self:.setPrefix (self._executable.parent ().toStr ());
    }

    pub fn setPackage (mut self, package : Path) {
        self._package = package;
    }

    pub fn activateDebug (mut self) {
        self._isDebug = true;
    }

    pub fn isDebugActive (self)-> bool {
        self._isDebug
    }

    pub fn activateUnittest (mut self) {
        self._isUnitTest = true;
    }

    pub fn isUnittestActive (self)-> bool {
        self._isUnitTest
    }
    
    pub fn activateVerbose (mut self) {
        self._isVerbose = true;
    }

    pub fn isVerboseActive (mut self)-> bool {
        self._isVerbose
    }

    pub fn activateStandalone (mut self) {
        self._isStandalone = true;
    }

    pub fn activateDocDumping (mut self) {
        self._isDumpDoc = true;
    }

    pub fn activateYmirDumping (mut self) {
        self._isYmirDump = true;
    }

    pub fn activateSymTreeDumping (mut self) {
        self._isSymTreeDump = true;
    }

    pub fn addVersion (mut self, v : [c8]) {
        self._versions [v] = ();
    }

    pub fn addIncludeDir (mut self, dir : [c8]) {
        self._includeDirs [Path (dir)] = ();
    }
    
    pub fn setPrefix (mut self, prefix : [c8]) {
        let path = Path (prefix).push (self._includePrefix);
        if (fs::sys::isDir (path)) {
            self._prefixPath = Path (prefix);
            self._corePath = path;
        }
    }

    pub fn setSizeTypeSize (mut self, size : u32) {
        self._sizeTypeSize = size;
    }

    pub fn setFloatTypeSize (mut self, size : u32) {
        self._floatTypeSize = size;
    }

    pub fn setMaxCteLoopIter (mut self, nb : usize) {
        self._maxCteLoopIter = nb;
    }

    /*!
     * ================================================================================
     * ================================================================================
     * =========================           GETTERS            =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * @returns: the path of the package being constructed
     * */
    pub fn getPackage (self)-> Path {
        self._package
    }

    /**
     * @returns: true of the version is active
     */
    pub fn isVersionActive (self, v : [c8])-> bool {
        v in self._versions
    }

    /**
     * @returns: the path of the prefix of the executable (pwd of the executable)
     */
    pub fn getIncludePrefix (self)-> Path {
        self._includePrefix
    }

    /**
     * @returns: the directory containing the core files
     */
    pub fn getCorePath (self)-> Path {
        self._corePath
    }

    /**
     * @returns: the list of directories that are included (-I option)
     */
    pub fn getIncludeDirs (self)-> [Path] {
        [p for p, _ in self._includeDirs]
    }

    /**
     * @returns: true iif the standalone option is activated
     */
    pub fn isStandalone (self)-> bool {
        self._isStandalone
    }

    /**
     * @returns: true if the ymir dump option is activated (dumping intermediate representation to a file)
     * */
    pub fn isYmirDumping (self)-> bool {
        self._isYmirDump
    }

    /**
     * @returns: true if the sym tree dump option is activated (dumping symbol tree to file)
     * */
    pub fn isSymTreeDumping (self)-> bool {
        self._isSymTreeDump
    }

    /**
     * @returns: the size in bits of the size type (pointer size)
     */
    pub fn getSizeTypeSize (self)-> u32 {
        self._sizeTypeSize
    }

    /**
     * @returns: the size in bits of the biggest float type (e.g. __float80)
     * */
    pub fn getFloatTypeSize (self)-> u32 {
        self._floatTypeSize
    }

    /**
     * @returns: the maximal number of unwindable loop iterations at cte
     * */
    pub fn getMaxCteLoopIter (self)-> usize {
        self._maxCteLoopIter
    }

    impl Streamable;           
    
}
