mod templates;

import ymirc::parser;
import ymirc::errors::_;
import ymirc::utils::_;
import ymirc::args::_;
import std::io, std::conv;
import std::fs::_;

aka __TEST_1__ =
str8#{mod test1;

def foo {T of dmut U, U} () {
    let x : T = [];
    x;
}

def foo {T of const U, U} () {}

def main () {
    foo!{dmut [i32]} ();
    foo!{[i32]} ();
}
};

aka __TEST_1_OUT__ = "frame : [weak] test1::foo!{mut [mut i32], mut [mut i32]}::foo ()-> void {\n    let x(#67) : [i32] = alias ([]);\n    x(#67);\n    <unit-value>\n}\nframe : [weak] test1::foo!{[i32], [i32]}::foo ()-> void {\n\n}\nframe : test1::main ()-> void {\n    test1::foo!{mut [mut i32], mut [mut i32]}::foo ();\n    test1::foo!{[i32], [i32]}::foo ();\n    <unit-value>\n}\n"s8;

__test {
    logging::setRelativeTime ();
    logging::info (" Test template 1 start"s8);
    
    let path = tempDirectory ().push ("test1.yr");
    with dmut f = File::create (path, write-> true) {
        f:.write (__TEST_1__);
    }

    let args = YmirArguments (files-> [path.toStr ().to![c32] ()]);
    let dmut parser = Parser::new (args);
    let gens = {
        parser:.parseAll ()
    } catch {
        err : &ErrorMsg => {
            println (format ("%", err));
            for j in err.getRecursiveTrace () {                        
                println (j);
            }
            
            assert (false);
        }        
    };

    let dmut stream = Formatter::new ();
    for i in gens {
        stream:.write (i, '\n'c8);
    }
    assert (stream[] == __TEST_1_OUT__, stream[] ~ "\n"s8 ~ __TEST_1_OUT__);

    logging::info (" Test template 1 end"s8);
}

