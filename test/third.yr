mod third;

import ymirc::utils::_;
import ymirc::syntax::visitor;
import std::conv, std::io;
import ymirc::errors::_;

import std::fs::path;

pub aka __testSyntax_1_except = str8#{mod main ;
aka X = 12;

template X {T...} if is!{T}{class U} {
    aka X = T::init;

}

class @{final} X {
    pub self () {
    }
    
    pub def foo (self) {
    }
    
    pub def bar (self) {
    }
    
    prv {
        impl X;
        impl Y;
    }
    impl Z::Z {
        pub over foo (self)-> i32 {
            720
        }
        
    }
    
}

template U {T} if isBar!{T} () {
    class U {
    }

}

enum : [c8]
| A = 12
| B = 34
 -> A;

template enum {T} if is!{T}{struct U} {
    enum : T
    | A = T::init
     -> B;

}

def main () {
    x = 12 + 32;
    z = 84;
    w = "str in multiple words";
    <unit-expr>
}


template a {T...} if <unit-expr> {
    def a (a : T)-> U {
    }
    

}

};


__test {
    logging::setRelativeTime ();
    logging::info (" Test syntax 1 start"s8);

    let module = {
        SyntaxVisitor::new (Path::new ("./compilable/1/main.yr"s8)):.read ()
    } catch {
        err : &ErrorMsg => {
            println (format ("%", err));
            for j in err.getRecursiveTrace () {                        
                println (j);
            }
            throw AssertError::new ("");
        }
        x : _ => throw x;
    }
    
    let res = format ("%", module);
    
    assert (res == __testSyntax_1_except);
    logging::info (" Test syntax 1 end"s8);
}
