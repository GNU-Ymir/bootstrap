in utils;

use ymirc::parser;
use ymirc::semantic::generator::_;
use ymirc::syntax::{_, expression::empty};

use ymirc::lint::node::{_, global::_};
use ymirc::{errors::_, global::_, args, utils::_};

use std::{io, conv, config::_, time::_, fs::_};

pub record CompileResult {
    pub let synt : &SyntaxNode = EMPTY_EXPR;
    pub let sem : [&Generator] = [];
    pub let exp : [&YILNode] = [];
    pub let types : [&YILType] = [];
    pub let withLint : bool = true;
    pub let err : (&ErrorMsg)? = none;

    pub self (synt : &SyntaxNode = EMPTY_EXPR,
              sem : [&Generator] = [],
              exp : [&YILNode] = [],
              types : [&YILType] = [],
              withLint : bool = true,
              err : (&ErrorMsg)? = none)
        with synt = synt
        , sem = sem
        , exp = exp
        , types = types
        , err = err
        , withLint = withLint
    {}
}

/**
 * Register a test
 * @params:
 *    - package: the root file of the compilation
 *    - results: the name of the output files (where adding extension .err, .sem and .yil will point to those files)
 *    - withYIL: generate yil, or stop at semantic
 *    - withImports: list of external package to import
 *    - removeWeak: true iif not comparing weak symbols in yil
 * */
pub fn registerTest (package : [c8], results : [c8] = "", withImports : [[c8]] = [], removeWeak : bool = false)
    throws AssertError
{
    let rpath = if results == "" {
        Path (package).stripExtension ()
    } else { Path (results).stripExtension () };

    let withYIL = fs::sys::isFile (rpath.addExtension ("yil"));
    let compileRes = compileFile (Path (package).stripExtension ().addExtension ("yr"), withLint-> withYIL, withImports-> withImports);

    compareResultWithFiles (compileRes, rpath, removeWeak-> removeWeak);
}

/**
 * Compile a package
 * */
fn compileFile (filename : Path, withLint : bool = false, withImports : [[c8]] = [])-> CompileResult {
    ymirc::global::state::resetInstance (); // reset all global informations

    let args = YmirArguments (file-> filename.toStr (),
                              noLint-> !withLint,
                              includes-> withImports);

    let dmut parser = copy Parser (args);

    parser:.parseAll ();

    return CompileResult (synt-> parser.getSyntaxNode (),
                          sem-> parser.getSemGenerators (),
                          exp-> parser.getExpYILNodes (),
                          types-> parser.getExpYILTypes (),
                          withLint-> withLint);

} catch {
    err : &ErrorMsg => {
        return CompileResult (err-> err?);
    }
}

/**
 * Compare result of compilation with output files
 * */
fn compareResultWithFiles (result : CompileResult, loc : Path, removeWeak : bool = false)
    throws AssertError
{
    if fs::sys::isFile (loc.addExtension ("err")) {
        compareErrorWithFile (result.err, loc.addExtension ("err"));
    } else {
        ensureErrorEmpty (result.err);
        if fs::sys::isFile (loc.addExtension ("sem")) {
            compareResultWithFile (result.sem, loc.addExtension ("sem"), removeWeak-> removeWeak);
        }

        if result.withLint && fs::sys::isFile (loc.addExtension ("yil")) {
            compareResultWithFile (result.types, result.exp, loc.addExtension ("yil"), removeWeak-> removeWeak);
        }
    }
} catch {
    f : &FsError => {
        throw copy AssertError (format ("%", f));
    }
    err : &AssertError => throw err;
}


fn compareResultWithFile (gens : [&Generator], filename : Path, removeWeak : bool = false)
    throws AssertError, FsError
{
    let output = {
        let dmut f = File::open (filename);
        f:.readAll ()
    };

    let dmut stream = copy Formatter (tags-> FormatTags (forDebug-> true, withVarIds-> false));
    let mut valids : [mut ([c8], &FrameGenerator)] = [];
    for i in gens if let f : &FrameGenerator = i {
        valids ~= [(Mangler ().mangle (f), f)];
    }

    valids = std::algorithm::sorting::sort (alias valids, |a, b| => { a.0 < b.0 });
    for v in valids {
        if (!removeWeak || !v.1.isWeak ()) {
            stream:.write (format ("%\n", v.1, tags-> FormatTags (withParams-> false, forDebug-> true)));
        }
    }

    {
        compareResultWithString (stream, output);
    } catch {
        _ => {
            eprintln ("In file : ", filename.toStr ());
            assert (false);
        }
    }
}

fn compareResultWithFile (types : [&YILType], yil : [&YILNode], filename : Path, removeWeak : bool = false, onlyFrames : bool = false)
    throws AssertError, FsError
{
    let output = {
        let dmut f = File::open (filename);
        f:.readAll ()
    };

    let dmut stream = copy Formatter (tags-> FormatTags (forDebug-> true, withVarIds-> false));
    for t in std::algorithm::sorting::sort (copy types, |a, b| => { a.getUniqId () < b.getUniqId () }) {
        stream:.write (format ("%;\n", t, tags-> FormatTags (withParams-> true, forDebug-> true)));
    }

    for i in yil {
        let remove = if (removeWeak || onlyFrames) {
            match i {
                f : &YILFrame => { f.isWeak () && removeWeak }
                g : &YILGlobalVar => { g.isWeak () || onlyFrames }
                c : &YILConstant => { c.isWeak () || onlyFrames }
                _ => { false }
            }
        } else { false };

        if (!remove) {
            // use a new stream for each node, to reset counters
            stream:.write (format ("%", i, tags-> FormatTags (forDebug-> true)), '\n'c8);
        }
    }

    {
        compareResultWithString (stream, output);
    } catch {
        _ => {
            eprintln ("In file : ", filename.toStr ());
            assert (false);
        }
    }
}

pub fn compareResultWithString (stream : &Formatter, output : [c8])
    throws AssertError
{
    let res = removeColors (stream[]);
    if (res != output) {
        eprintln (res);
        let end = (if (res.len < output.len) { res.len } else { output.len });
        let mut i = 0us;
        let mut line = 1us;
        eprint (Colors::BLUE, line, ":  ", Colors::RESET);

        while i < end {
            if (res[i] != output[i]) {
                eprintln (Colors::RED, getUntilLineEnd (res [i .. $]), Colors::RESET, "||", Colors::YELLOW, getUntilLineEnd (output [i .. $]), Colors::RESET, '|');
                assert (false);
            } else eprint (res[i]);

            if (res [i] == '\n') {
                line += 1us;
                eprint (Colors::BLUE, line, ":  ", Colors::RESET);
            }
            i += 1us;
        }

        if (i < res.len) {
            eprint ("\n rest err [", res [i .. $], "]");
        }
        if (i < output.len) {
            eprint ("\n rest expect [", output [i .. $], "]");
        }

        eprintln ("<--  DIFF HERE");
        assert (false);
    }
}


fn compareErrorWithFile (error : (&ErrorMsg)?, filename : Path)
    throws AssertError
{
    let output = {
        let dmut f = File::open (filename);
        f:.readAll ().trimLineEnds ()
    };

    match error {
        Ok (err : &ErrorMsg) => {
            let dmut stream = copy Formatter (tags-> FormatTags (verbose-> true));
            stream:.write (err, "\n");

            let res = removeColors (stream[]).trimLineEnds ();

            if (res != output) {
                eprintln (res);
                let end = (if (res.len < output.len) { res.len } else { output.len });
                let mut i = 0us;
                let mut line = 1us;
                eprint (Colors::BLUE, line, ":  ", Colors::RESET);
                while i < end {
                    if (res[i] != output[i]) {
                        eprintln (Colors::RED, getUntilLineEnd (res [i .. $]), Colors::RESET, "||", Colors::YELLOW, getUntilLineEnd (output [i .. $]), Colors::RESET, '|');
                        eprintln ("<--  DIFF HERE");
                        assert (false);
                    } else eprint (res[i]);

                    if (res [i] == '\n') {
                        line += 1us;
                        eprint (Colors::BLUE, line, ":  ", Colors::RESET);
                    }

                    i += 1us;
                }

                if (i < res.len) {
                    eprint ("\n rest err [", res [i .. $], "]");
                }
                if (i < output.len) {
                    eprint ("\n rest expect [", output [i .. $], "]");
                }
                
                eprintln ("<--  DIFF HERE");
                assert (false);
            }
        }
        _ => {
            assert (output.len == 0us, output);
        }
    }

} catch {
    _ => {
        eprintln ("In file : ", filename.toStr ());
        assert (false);
    }
}


fn ensureResultEmpty (gens : [&Generator])
    throws AssertError
{
    if (gens.len != 0us) {
        let dmut stream = copy Formatter ();
        for i in gens {
            stream:.write (i, '\n');
        }

        eprintln ("Result not empty : ", stream[]);
        assert (false);
    }
}

fn ensureErrorEmpty (error : (&ErrorMsg)?)
    throws AssertError
{
    match error {
        Ok (err : &ErrorMsg) => {
            let dmut stream = copy Formatter ();
            stream:.write (err, "\n");

            let res = removeColors (stream[]).trimLineEnds ();

            eprintln ("Error not empty : \n", res);
            assert (false);
        }
    }
}

pub fn removeColors (txt : [c8])-> [c8] {
    let mut res : [c8] = [];
    let mut i = 0us;
    while i < txt.len {
        let col = isColor (txt [i..$]);
        if (col.len != 0) {
            i += col.len;
        } else if (txt[i] != '\u{0}') {
            res ~= [txt [i]];
            i += 1us;
        } else i += 1us;
    }

    res
}

pub fn isColor (current : [c8])-> [c8] {
    for i in Colors::__members__ {
        if (current.len >= i.len) {
            if (current [0us .. i.len] == i) return i;
        }
    }

    []
}

pub fn trimLineEnds (txt : [c8])-> [c8] {
    let mut res : [c8] = [];
    let mut nb = 0us;
    for i in 0us .. txt.len {
        if (txt [i] == ' ') {
            nb += 1us;
        } else if (txt [i] == '\t') {
            nb += 4us;
        } else {
            if (txt [i] != '\n') {
                for _ in 0us .. nb {
                    res ~= [' '];
                }
            }
            nb = 0us;
            res ~= [txt [i]];
        }
    }

    res
}

pub fn getUntilLineEnd (txt : [c8])-> [c8] {
    let mut e = 0us;
    while (e < txt.len) {
        if (txt [e] == '\n') return txt [0us .. e];
        e += 1us;
    }

    txt
}
