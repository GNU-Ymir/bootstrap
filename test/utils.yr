mod utils;

import ymirc::parser;
import ymirc::semantic::generator::base;
import ymirc::errors::_;
import ymirc::utils::_;
import ymirc::args::_;

import std::collection::vec;

import std::io, std::conv;
import std::fs::_;
import std::time::_;


def compileFile (filename : [c8])-> ([&Generator], (&ErrorMsg)?) {
    let args = YmirArguments (files-> [filename.(conv::to)![c32] ()]);
    let dmut parser = Parser::new (args);

    let ret = {
        (parser:.parseAll (), ((&ErrorMsg)?)::__err__)
    } catch {
        err : &ErrorMsg => {
            return ([], err?);
        }        
    }

    logSpentTime ();
    ret
}

/**
 * Returns the time spent in the three main phases of the compilation
 * @returns:
 *    - .0: the time spent in syntaxic validation
 *    - .1: the time spent in symbol validation
 * */
def getCompileTimes ()-> (Duration, Duration) {
    let mut syntax = dur::seconds (0);
    let mut valid = dur::seconds (0);
    for _, j in timer::instance ().getSyntaxMap () {
        syntax += j;
    }

    for _, j in timer::instance ().getValidationMap () {
        valid += j;
    }

    (syntax, valid)
}

def logSpentTime () {
    let (synt, valid) = getCompileTimes ();
    logging::info (format (" Syntax : %, Validation : %", synt.(dur::to)![c8] (), valid.(dur::to)![c8] ()));
}

def logSpentTimeDetailed () {
    for i, j in timer::instance ().getSyntaxMap () {
        logging::info (format ("Syntax of % took %", i, j.(dur::to)![c8] ()));
    }

    for i, j in timer::instance ().getSyntaxMap () {
        logging::info (format ("Validation of % took %", i, j.(dur::to)![c8] ()));
    }
}


def compareResultWithFile (gens : [&Generator], filename : [c8])
    throws &AssertError, &FsError
{
    let output = with dmut f = File::open (Path::new (filename)) {
        f:.readAll ().(conv::to)![c32] ()
    };
   
    let dmut stream = Formatter::new ();
    stream:.withVarIds (false);
    for i in gens {
        stream:.write (i, '\n'c8);
    }

    let res = removeColors (stream[].(conv::to)![c32] ());
    if (res != output) {
        eprintln (res);
        let end = (if (res.len < output.len) { res.len } else { output.len });
        let mut i = 0us;
        while i < end {
            if (res[i] != output[i]) {
                eprintln ("[", cast!u32 (res[i]), "][", cast!u32 (output[i]), "] ");
                eprintln ("<--  DIFF HERE");

                assert (false);
            } else eprint (res[i]);
            
            i += 1us;
        }

        if (i < res.len) {
            eprint ("\n rest err [", res [i .. $], "]");
        }
        if (i < output.len) {
            eprint ("\n rest expect [", output [i .. $], "]");
        }
        
        eprintln ("<--  DIFF HERE");
        assert (false);
    }
}


def compareErrorWithFile (error : (&ErrorMsg)?, filename : [c8])
    throws &FsError, &AssertError
{
    let output = with dmut f = File::open (Path::new (filename)) {
        f:.readAll ().(conv::to)![c32] ()
    };

    match error {
        Ok (err : &ErrorMsg) => {
            let dmut stream = Formatter::new ();
            stream:.withVarIds (false);
            stream:.withErrorIds (false);
            stream:.write (err, "\n");

            let res = removeColors (stream[].(conv::to)![c32] ());
            if (res != output) {
                eprintln (res);
                let end = (if (res.len < output.len) { res.len } else { output.len });
                let mut i = 0us;
                while i < end {
                    if (res[i] != output[i]) {
                        eprintln ("[", res[i], "]\n[", output[i], "] ");
                        eprintln ("<--  DIFF HERE");
                        assert (false);
                    } else print (res[i]);
                    
                    i += 1us;
                }

                if (i < res.len) {
                    eprint ("\n rest err [", res [i .. $], "]");
                }
                if (i < output.len) {
                    eprint ("\n rest expect [", output [i .. $], "]");
                }
                
                eprintln ("<--  DIFF HERE");
                assert (false);
            }
        }
        _ => {
            assert (output.len == 0us, output);
        }
    }
    
}

def ensureResultEmpty (gens : [&Generator])
    throws &AssertError
{
    if (gens.len != 0us) {
        let dmut stream = Formatter::new ();
        stream:.withVarIds (false);
        for i in gens {
            stream:.write (i, '\n'c8);
        }

        eprintln ("Result not empty : ", stream[]);
        assert (false);
    }
}

def ensureErrorEmpty (error : (&ErrorMsg)?)
    throws &AssertError
{
    match error {
        Ok (err : &ErrorMsg) => {
            let dmut stream = Formatter::new ();
            stream:.withVarIds (false);
            stream:.withErrorIds (false);
            stream:.write (err, "\n");

            let res = removeColors (stream[].(conv::to)![c32] ());

            eprintln ("Error not empty : \n", res);
            assert (false);
        }
    }
}

def removeColors (txt : [c32])-> [c32] {
    let dmut res = Vec!{c32}::new ();
    let mut i = 0us;
    while i < txt.len {
        let col = isColor (txt[i..$]);
        if (col.len != 0us) {
            i += col.len;
        } else if (txt[i] != '\u{0}') {
            res:.push (txt[i]);
            i += 1us;
        } else i += 1us;
    }

    res[]
}

def isColor (current : [c32])-> [c32] {
    for i in Colors32::__members__ {
        if (current.len >= i.len) {
            if (current [0us .. i.len] == i) return i;
        }
    }

    []
}
