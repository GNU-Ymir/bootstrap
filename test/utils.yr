in utils;

use ymirc::parser;
use ymirc::semantic::generator::_;
use ymirc::syntax::{_, expression::empty};

use ymirc::lint::node::{_, global::_};
use ymirc::{errors::_, global::_, args, utils::_};

use std::{io, conv, config::_, time::_, fs::_};

pub record CompileResult {
    pub let synt : &SyntaxNode = EMPTY_EXPR;
    pub let sem : [&Generator] = [];
    pub let exp : [&YILNode] = [];
    pub let opt : [&YILNode] = [];
    pub let err : (&ErrorMsg)? = none;

    pub self (synt : &SyntaxNode = EMPTY_EXPR,
              sem : [&Generator] = [],
              exp : [&YILNode] = [],
              opt : [&YILNode] = [],
              err : (&ErrorMsg)? = none)
        with synt = synt
        , sem = sem
        , exp = exp
        , opt = opt
        , err = err
    {}
}

pub fn compileFile (filename : [c8], withLint : bool = false, withImports : [[c8]] = [])-> CompileResult {
    ymirc::global::state::resetInstance (); // reset all global informations

    let args = YmirArguments (file-> filename,
                              noLint-> !withLint,
                              includes-> withImports);

    let dmut parser = copy Parser (args);

    parser:.parseAll ();

    return CompileResult (synt-> parser.getSyntaxNode (),
                          sem-> parser.getSemGenerators (),
                          exp-> parser.getExpYILNodes (),
                          opt-> parser.getOptYILNodes ());

} catch {
    err : &ErrorMsg => {
        return CompileResult (err-> err?);
    }
}

pub fn compareResultWithFile (gens : [&Generator], filename : [c8], removeWeak : bool = false)
    throws AssertError, FsError
{
    let output = {
        let dmut f = File::open (Path (filename));
        f:.readAll ()
    };

    let dmut stream = copy Formatter (tags-> FormatTags (forDebug-> true, withVarIds-> false));
    let mut valids : [mut ([c8], &FrameGenerator)] = [];
    for i in gens if let f : &FrameGenerator = i {
        valids ~= [(Mangler ().mangle (f), f)];
    }

    valids = std::algorithm::sorting::sort (alias valids, |a, b| => { a.0 < b.0 });
    for v in valids {
        if (!removeWeak || !v.1.isWeak ()) {
            stream:.write (v.1, '\n'c8);
        }
    }

    {
        compareResultWithFile (stream, output);
    } catch {
        _ => {
            eprintln ("In file : ", filename);
            assert (false);
        }
    }
}

pub fn compareResultWithFile (yil : [&YILNode], filename : [c8], removeWeak : bool = false, onlyFrames : bool = false)
    throws AssertError, FsError
{
    let output = {
        let dmut f = File::open (Path (filename));
        f:.readAll ()
    };

    let dmut stream = copy Formatter (tags-> FormatTags (forDebug-> true, withVarIds-> false));
    for i in yil {
        let remove = if (removeWeak || onlyFrames) {
            match i {
                f : &YILFrame => { f.isWeak () && removeWeak }
                g : &YILGlobalVar => { g.isWeak () || onlyFrames }
                c : &YILConstant => { c.isWeak () || onlyFrames }
                _ => { false }
            }
        } else { false };

        if (!remove) {
            // use a new stream for each node, to reset counters
            stream:.write (format ("%", i), '\n'c8);
        }
    }

    {
        compareResultWithFile (stream, output);
    } catch {
        _ => {
            eprintln ("In file : ", filename);
            assert (false);
        }
    }
}

pub fn compareResultWithFile (stream : &Formatter, output : [c8])
    throws AssertError
{
    let res = removeColors (stream[]);
    if (res != output) {
        eprintln (res);
        let end = (if (res.len < output.len) { res.len } else { output.len });
        let mut i = 0us;
        let mut line = 1us;
        eprint (Colors::BLUE, line, ":  ", Colors::RESET);

        while i < end {
            if (res[i] != output[i]) {
                eprintln (Colors::RED, getUntilLineEnd (res [i .. $]), Colors::RESET, "||", Colors::YELLOW, getUntilLineEnd (output [i .. $]), Colors::RESET, '|');
                assert (false);
            } else eprint (res[i]);

            if (res [i] == '\n') {
                line += 1us;
                eprint (Colors::BLUE, line, ":  ", Colors::RESET);
            }
            i += 1us;
        }

        if (i < res.len) {
            eprint ("\n rest err [", res [i .. $], "]");
        }
        if (i < output.len) {
            eprint ("\n rest expect [", output [i .. $], "]");
        }

        eprintln ("<--  DIFF HERE");
        assert (false);
    }
}


pub fn compareErrorWithFile (error : (&ErrorMsg)?, filename : [c8])
    throws AssertError
{
    let output = {
        let dmut f = File::open (Path (filename));
        f:.readAll ().trimLineEnds ()
    };

    match error {
        Ok (err : &ErrorMsg) => {
            let dmut stream = copy Formatter (tags-> FormatTags (verbose-> true));
            stream:.write (err, "\n");

            let res = removeColors (stream[]).trimLineEnds ();

            if (res != output) {
                eprintln (res);
                let end = (if (res.len < output.len) { res.len } else { output.len });
                let mut i = 0us;
                let mut line = 1us;
                eprint (Colors::BLUE, line, ":  ", Colors::RESET);
                while i < end {
                    if (res[i] != output[i]) {
                        eprintln (Colors::RED, getUntilLineEnd (res [i .. $]), Colors::RESET, "||", Colors::YELLOW, getUntilLineEnd (output [i .. $]), Colors::RESET, '|');
                        eprintln ("<--  DIFF HERE");
                        assert (false);
                    } else eprint (res[i]);

                    if (res [i] == '\n') {
                        line += 1us;
                        eprint (Colors::BLUE, line, ":  ", Colors::RESET);
                    }

                    i += 1us;
                }

                if (i < res.len) {
                    eprint ("\n rest err [", res [i .. $], "]");
                }
                if (i < output.len) {
                    eprint ("\n rest expect [", output [i .. $], "]");
                }
                
                eprintln ("<--  DIFF HERE");
                assert (false);
            }
        }
        _ => {
            assert (output.len == 0us, output);
        }
    }

} catch {
    _ => {
        eprintln ("In file : ", filename);
        assert (false);
    }
}


pub fn ensureResultEmpty (gens : [&Generator])
    throws AssertError
{
    if (gens.len != 0us) {
        let dmut stream = copy Formatter ();
        for i in gens {
            stream:.write (i, '\n');
        }

        eprintln ("Result not empty : ", stream[]);
        assert (false);
    }
}

pub fn ensureErrorEmpty (error : (&ErrorMsg)?)
    throws AssertError
{
    match error {
        Ok (err : &ErrorMsg) => {
            let dmut stream = copy Formatter ();
            stream:.write (err, "\n");

            let res = removeColors (stream[]).trimLineEnds ();

            eprintln ("Error not empty : \n", res);
            assert (false);
        }
    }
}

pub fn removeColors (txt : [c8])-> [c8] {
    let mut res : [c8] = [];
    let mut i = 0us;
    while i < txt.len {
        let col = isColor (txt [i..$]);
        if (col.len != 0) {
            i += col.len;
        } else if (txt[i] != '\u{0}') {
            res ~= [txt [i]];
            i += 1us;
        } else i += 1us;
    }

    res
}

pub fn isColor (current : [c8])-> [c8] {
    for i in Colors::__members__ {
        if (current.len >= i.len) {
            if (current [0us .. i.len] == i) return i;
        }
    }

    []
}

pub fn trimLineEnds (txt : [c8])-> [c8] {
    let mut res : [c8] = [];
    let mut nb = 0us;
    for i in 0us .. txt.len {
        if (txt [i] == ' ') {
            nb += 1us;
        } else if (txt [i] == '\t') {
            nb += 4us;
        } else {
            if (txt [i] != '\n') {
                for _ in 0us .. nb {
                    res ~= [' '];
                }
            }
            nb = 0us;
            res ~= [txt [i]];
        }
    }

    res
}

pub fn getUntilLineEnd (txt : [c8])-> [c8] {
    let mut e = 0us;
    while (e < txt.len) {
        if (txt [e] == '\n') return txt [0us .. e];
        e += 1us;
    }

    txt
}
