frame : [weak] core::types::map::compareKeys!{&(test12::X)}::compareKeys (a : *(&(test12::X)), b : *(&(test12::X)))-> bool {
    return test12::X::opEquals(*(a), *(b));
    <unit-value>
}
frame : [weak] core::types::map::hashKey!{&(test12::X)}::hashKey (a : *(&(test12::X)))-> u64 return core::types::hash::__hash!{&(test12::X), &(test12::X), &(test12::X)}::__hash (*(a))
frame : [weak] core::types::hash::__hash!{&(test12::X), &(test12::X), &(test12::X)}::__hash (a : &(test12::X))-> u64 return impl::toHash(a)
frame : impl::toHash (self : &(test12::X))-> u64 return 1u64
frame : test12::I::self::_21_9 (#{CLOSURE-VARREF} : *((mut &(mut test12::I), (dg ()-> void)[nullable])))-> void {
    {
        self.z = test12::Z::self(new)
    };
    if (next.func != null) (next.func)(next.closure)
}
frame : test12::I::self (mut self : mut &(mut test12::I), next : (dg ()-> void)[nullable])-> void {
    test12::X::self(self, {&((self, next));(#{CLOSURE-VARREF} : *((mut &(mut test12::I), (dg ()-> void)[nullable])))-> void});
    {
        <unit-value>
    }
}
frame : test12::X::self (mut self : mut &(mut test12::X), next : (dg ()-> void)[nullable])-> void {
    {
        {
            self.i = test12::I::self(new)
        };
        if (next.func != null) (next.func)(next.closure)
    };
    {
        <unit-value>
    }
}
frame : test12::X::opEquals (self : &(test12::X), _ : &(test12::X))-> bool return true
frame : test12::Z::self (mut self : mut &(mut test12::Z), next : (dg ()-> void)[nullable])-> void {
    {
        {
            self.x = []
        };
        if (next.func != null) (next.func)(next.closure)
    };
    {
        <unit-value>
    }
}
