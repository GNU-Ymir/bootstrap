fn end () {}
fn exiting () {}
fn caught () {}

entity A {
    let _items : [i32] = copy [1, 2, 3];

    pub self () {}

    pub fn begin (self)-> dmut &CIterator {
        copy CIterator (0, self._items)
    }

    pub fn end (self)-> usize {
        self._items.len
    }

    @field
    pub fn values (self)-> [i32] {
        self._items
    }

    __dtor (mut self) {
        end ();
    }

}


class CIterator {

    let _x : [i32];
    let mut _index : usize;


    pub self (index : usize, x : [i32])
        with _index = index
        , _x = x
    {}

    pub fn get {0us, 1us} (mut self)-> i32 {
        self._x [self._index]
    }

    impl Iterable {
        pub over next (mut self) {
            self._index += 1;
        }
    }

    pub fn opEquals (self, o : usize)-> bool {
        self._index == o
    }

}


fn baz (_ : i32)-> i32 { 1 }

fn main () {
    {
        let a = A ();
        a.values;
        let _ = copy [baz (i) for i in a];
        assert (false);
    } exit {
        exiting ();
    }
} catch {
    _ => caught ();

}
