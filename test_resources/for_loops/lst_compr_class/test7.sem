frame : impl::next (mut ref self : mut test7::SIterator)-> void {
    self.index = (self.index + 1us);
    <unit-value>
}
frame : test7::A::end (self : &(test7::A))-> usize return self._values.len
frame :[pre] test7::A::self (mut self : mut &(mut test7::A))-> void {
    {
        self._values = copy ({.len = 3us, .ptr = &([1, 2, 3])})
    }
}
frame :[post] test7::A::self (mut self : mut &(mut test7::A))-> void {
    <unit-value>
}
frame : test7::A::self (mut self : mut &(mut test7::A))-> void {
    test7::A::self[pre](self);
    test7::A::self[post](self)
}
frame : test7::A::begin (self : &(test7::A))-> test7::SIterator return test7::SIterator::self(new, 0us, self)
frame : test7::A::values (self : &(test7::A))-> [i32] return self._values
frame : test7::main ()-> void {
    let a : &(test7::A) = test7::A::self(new);
    let _ : [i32] = {
            let mut #_iter : mut test7::SIterator = test7::A::begin(a);
            let #_end : usize = test7::A::end(a);
            let mut #_value : mut [mut i32] = [<unit-value> ; new 0us];
            while !test7::SIterator::opEquals(#_iter, #_end) {
                let i : i32 = test7::SIterator::get!{0us, 1us}::get(#_iter:);
                #_value ~= {.len = 1us, .ptr = &([i])};
                impl::next(#_iter:)
            };
            #_value
        };
    <unit-value>
}
frame : [weak] test7::SIterator::get!{0us, 1us}::get (ref self : test7::SIterator)-> i32 return #{
    if (test7::A::values(self.a).len <= self.index) panic;
    test7::A::values(self.a) [self.index]
#}
frame : test7::SIterator::self (mut ref self : mut test7::SIterator, index : usize, a : &(test7::A))-> void {
    {
        {
            self.index = index;
            self.a = a
        }
    };
    {
        <unit-value>
    }
}
frame : test7::SIterator::opEquals (ref self : test7::SIterator, i : usize)-> bool return (self.index == i)
