pointer P_1 *(void);
pointer P_2 *(P_1);
tuple T_5 (minfo-> P_1, entries-> P_1, len-> u64, cap-> u64, loaded-> u64);
tuple T_7 (#_vtable-> P_2, #_monitor-> P_1);
pointer P_8 *(u8);
tuple T_9 (len-> u64, ptr-> P_8, blk_info-> P_1);
pointer P_10 *(T_9);
pointer P_11 *(i32);
tuple T_12 (len-> u64, ptr-> P_11, blk_info-> P_1);
tuple T_13 (P_1, P_1, u64, u64);
pointer P_14 *(T_5);
pointer P_15 *(P_14);
array A_16 [u8 ; 4];
pointer P_17 *(T_12);
array A_18 [i32 ; 1];
pointer P_19 *(T_7);
tuple T_20 (@union, error-> P_19, value-> T_12);
tuple T_21 (hasValue-> u8, content-> T_20);
array A_22 [u8 ; 32];
array A_23 [u8 ; 12];
array A_24 [i32 ; 3];
const : [weak] _YMP10S2c8_S3i32MI (&_Y4core5types3map11compareKeysNS2c8FP4S2c8P4S2c8Zb, &_Y4core5types3map7hashKeyNS2c8FP4S2c8Zu64, 24, 24)
frame :  [weak] _Y4core5types3map11compareKeysNS2c8FP4S2c8P4S2c8Zb (let a : P_10, let b : P_10)-> u8 {
    YI_1 = _Y4core5types5array8opEqualsFS2c8S2c8Zb(*a, *b);
    return YI_1;
}
frame :  [weak] _Y4core5types3map7hashKeyNS2c8FP4S2c8Zu64 (let a : P_10)-> u64 {
    YI_1 = _Y4core5types4hash6__hashNc8NS2c8FS2c8Zu64(*a);
    return YI_1;
}
frame :  [weak] _Y4core5types4hash6__hashNc8NS2c8FS2c8Zu64 (let a : T_9)-> u64 {
    p = 31;
    m = 1000000009;
    res = 0;
    p_pow = 1;
    #_value = a;
    #_iter = 0;
#GOTO test(#3);
#LABEL beg(#2);
    YI_1 = 1 * #_iter;
    YI_2 = #_value.ptr + YI_1;
    YI_3 = cast!{P_8} (YI_2);
    c = *YI_3;
    YI_4 = _Y4core5types4hash6__hashFc8Zu64(c);
    YI_5 = YI_4 + 1;
    YI_6 = YI_5 * p_pow;
    YI_7 = res + YI_6;
    YI_8 = YI_7 % m;
    res = YI_8;
    YI_9 = p_pow * p;
    YI_10 = YI_9 % m;
    p_pow = YI_10;
    YI_11 = #_iter + 1;
    #_iter = YI_11;
#LABEL test(#3);
    YI_12 = #_iter < #_value.len;
#IF YI_12
#THEN_GOTO beg(#2)
#ELSE_GOTO end(#1);
#LABEL end(#1);
    YI_13 = res;
    return YI_13;
}
frame :  _Y5test94mainFZv ()-> void {
    _yrt_map_empty(&__map_1, &_YMP10S2c8_S3i32MI);
    YI_1 = __map_1;
    a = YI_1;
    YI_2 = (len-> 3, ptr-> "foo", blk_info-> 0);
    YI_3 = [0];
    YI_4 = (len-> 1, ptr-> &YI_3, blk_info-> 0);
    YI_5 = YI_4;
    _yrt_dup_slice(&YI_6, &YI_5, 4);
    YI_7 = YI_6;
    _yrt_map_insert(&a, &YI_2, &YI_7);
    YI_8 = (len-> 3, ptr-> "foo", blk_info-> 0);
    YI_9 = _yrt_map_find(&a, &YI_8);
#IF YI_9 == 0
#THEN_GOTO then(#1)
#ELSE_GOTO else(#3);
#LABEL then(#1);
    YI_10 = (hasValue-> 0, content-> (error-> 0));
#GOTO end(#2);
#LABEL else(#3);
    YI_10 = (hasValue-> 1, content-> (value-> *YI_9));
#LABEL end(#2);
    YI_11 = YI_10.hasValue;
#IF YI_11
#THEN_GOTO then(#4)
#ELSE_GOTO else(#6);
#LABEL then(#4);
    z = YI_10.content.value;
    YI_12 = 1;
    YI_13 = YI_12;
#GOTO end(#5);
#LABEL else(#6);
    YI_13 = YI_11;
#LABEL end(#5);
#IF YI_13
#THEN_GOTO then(#9)
#ELSE_GOTO end(#a);
#LABEL then(#9);
    YI_14 = z.len <= 0;
#IF YI_14
#THEN_GOTO then(#7)
#ELSE_GOTO end(#8);
#LABEL then(#7);
    YI_15 = "test_resources/lit_map/test9.yr";
    YI_16 = "test9::main";
    _yrt_exc_panic(YI_15, YI_16, 6);
#LABEL end(#8);
    YI_17 = 4 * 0;
    YI_18 = z.ptr + YI_17;
    YI_19 = cast!{P_11} (YI_18);
    *YI_19 = 8;
    YI_20 = (len-> 3, ptr-> "foo", blk_info-> 0);
    YI_21 = [1, 2, 3];
    YI_22 = (len-> 3, ptr-> &YI_21, blk_info-> 0);
    _yrt_concat_slices(&YI_23, &z, &YI_22, 4);
    YI_24 = YI_23;
    _yrt_map_insert(&a, &YI_20, &YI_24);
#LABEL end(#a);
}
frame :  main (let argc : u32, let argv : P_1)-> i32 {
    _yrt_run_main(argc, argc, &_Y5test94mainFZv);
    return 0;
}
