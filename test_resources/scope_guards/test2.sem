frame : test2::A::self::_2_9 (#{CLOSURE-VARREF} : *((mut &(mut test2::A), (dg ()-> void)[nullable])))-> void {
    if (next.func != null) (next.func)(next.closure)
}
frame : test2::A::self (mut self : mut &(mut test2::A), next : (dg ()-> void)[nullable])-> void {
    core::exception::Exception::self(self, {&((self, next));(#{CLOSURE-VARREF} : *((mut &(mut test2::A), (dg ()-> void)[nullable])))-> void});
    {
        <unit-value>
    }
}
frame : test2::B::self::_6_9 (#{CLOSURE-VARREF} : *((mut &(mut test2::B), (dg ()-> void)[nullable])))-> void {
    if (next.func != null) (next.func)(next.closure)
}
frame : test2::B::self (mut self : mut &(mut test2::B), next : (dg ()-> void)[nullable])-> void {
    core::exception::Exception::self(self, {&((self, next));(#{CLOSURE-VARREF} : *((mut &(mut test2::B), (dg ()-> void)[nullable])))-> void});
    {
        <unit-value>
    }
}
frame : test2::C::self::_10_9 (#{CLOSURE-VARREF} : *((mut &(mut test2::C), (dg ()-> void)[nullable])))-> void {
    if (next.func != null) (next.func)(next.closure)
}
frame : test2::C::self (mut self : mut &(mut test2::C), next : (dg ()-> void)[nullable])-> void {
    test2::B::self(self, {&((self, next));(#{CLOSURE-VARREF} : *((mut &(mut test2::C), (dg ()-> void)[nullable])))-> void});
    {
        <unit-value>
    }
}
frame : test2::main ()-> void try {
    {
        let _ : i32 = try {
                let mut #_failed : bool = true
                {
                    test2::foo (0)
                }
            } finally {
                {
                    if #_failed {
                        test2::onFail ();
                        <unit-value>
                    } else {
                        test2::onSucc ();
                        <unit-value>
                    };
                    {
                        test2::onExit ();
                        <unit-value>
                    }
                }
            };
        <unit-value>
    }
} catch {
    let #_catch : &(core::exception::Exception)
    if (((#_catch of test2::A) && true) && #{
        true
    #}) {
        {
            test2::onA ();
            <unit-value>
        }
    } else if (((#_catch of test2::B) && true) && #{
        true
    #}) {
        {
            test2::onB ();
            <unit-value>
        }
    }
}
