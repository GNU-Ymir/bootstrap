frame : [weak] core::range::countNbIterations!{usize, isize}::countNbIterations (fst : usize, scd : usize, step : isize, contains : bool)-> usize return {
    #{
        let stepU : usize = if (step < 0) {
                let fstU : usize = scd;
                let scdU : usize = fst;
                (cast!{usize}(-step), fstU, scdU, (scdU - fstU))
            } else {
                let fstU : usize = fst;
                let scdU : usize = scd;
                (cast!{usize}(step), fstU, scdU, (scdU - fstU))
            }.0;
        let fstU : usize = if (step < 0) {
                let fstU : usize = scd;
                let scdU : usize = fst;
                (cast!{usize}(-step), fstU, scdU, (scdU - fstU))
            } else {
                let fstU : usize = fst;
                let scdU : usize = scd;
                (cast!{usize}(step), fstU, scdU, (scdU - fstU))
            }.1;
        let scdU : usize = if (step < 0) {
                let fstU : usize = scd;
                let scdU : usize = fst;
                (cast!{usize}(-step), fstU, scdU, (scdU - fstU))
            } else {
                let fstU : usize = fst;
                let scdU : usize = scd;
                (cast!{usize}(step), fstU, scdU, (scdU - fstU))
            }.2;
        let mut subU : mut usize = if (step < 0) {
                let fstU : usize = scd;
                let scdU : usize = fst;
                (cast!{usize}(-step), fstU, scdU, (scdU - fstU))
            } else {
                let fstU : usize = fst;
                let scdU : usize = scd;
                (cast!{usize}(step), fstU, scdU, (scdU - fstU))
            }.3
    #};
    let nbAll : usize = (subU / stepU);
    if (nbAll == 18446744073709551615us) {
        return nbAll;
        <unit-value>
    };
    if contains {
        return (nbAll + 1us);
        <unit-value>
    };
    let last : usize = ((nbAll * stepU) + fstU);
    if (last != scdU) {
        return (nbAll + 1us);
        <unit-value>
    };
    nbAll
}
frame : [weak] core::array::opEquals!{i32, [i32]}::opEquals (a : [i32], b : [i32])-> bool return {
    if (a.len != b.len) {
        return false
    };
    {
        let mut #_iter : usize = 0us;
        let mut #_nb_iter : usize = core::range::countNbIterations!{usize, isize}::countNbIterations (0us, (0us ..[false] a.len).step_by (if (0us < a.len) 1is else -1is).scd, (0us ..[false] a.len).step_by (if (0us < a.len) 1is else -1is).step, false);
        while (#_iter < #_nb_iter) {
            let i : usize;
            i = (0us + cast!{usize}((#_iter * cast!{usize}((0us ..[false] a.len).step_by (if (0us < a.len) 1is else -1is).step))));
            {
                if (#{
                    if (a.len <= i) core::array::outOfArray ();
                    a [i]
                #} != #{
                    if (b.len <= i) core::array::outOfArray ();
                    b [i]
                #}) {
                    return false;
                    <unit-value>
                }
            };
            #_iter = (#_iter + 1us)
        }
    };
    true
}
frame : [weak] core::array::opCmp!{i32, [i32]}::opCmp (a : [i32], b : [i32])-> i32 {
    let mi : usize = if (b.len > a.len) {
            a.len
        } else {
            b.len
        };
    {
        let mut #_iter : usize = 0us;
        let mut #_nb_iter : usize = core::range::countNbIterations!{usize, isize}::countNbIterations (0us, (0us ..[false] mi).step_by (if (0us < mi) 1is else -1is).scd, (0us ..[false] mi).step_by (if (0us < mi) 1is else -1is).step, false);
        while (#_iter < #_nb_iter) {
            let i : usize;
            i = (0us + cast!{usize}((#_iter * cast!{usize}((0us ..[false] mi).step_by (if (0us < mi) 1is else -1is).step))));
            {
                if (#{
                    if (a.len <= i) core::array::outOfArray ();
                    a [i]
                #} < #{
                    if (b.len <= i) core::array::outOfArray ();
                    b [i]
                #}) {
                    return -1;
                    <unit-value>
                } else if (#{
                    if (a.len <= i) core::array::outOfArray ();
                    a [i]
                #} > #{
                    if (b.len <= i) core::array::outOfArray ();
                    b [i]
                #}) {
                    return 1;
                    <unit-value>
                }
            };
            #_iter = (#_iter + 1us)
        }
    };
    if (a.len > b.len) {
        return 1;
        <unit-value>
    } else if (a.len < b.len) {
        return -1;
        <unit-value>
    } else {
        return 0;
        <unit-value>
    }
}
frame : test10::main ()-> void {
    let a : [i32 ; 5us] = [1, 2, 3, 4, 5];
    core::exception::abort (core::array::opEquals!{i32, [i32]}::opEquals ({.len = 5us, .ptr = &(a)}, {.len = 5us, .ptr = &([1, 2, 3, 4, 5])}), ""s8);
    core::exception::abort ((core::array::opCmp!{i32, [i32]}::opCmp ({.len = 5us, .ptr = &(a)}, {.len = 5us, .ptr = &([2, 3, 4, 5, 6])}) < 0), ""s8);
    core::exception::abort ((core::array::opCmp!{i32, [i32]}::opCmp ({.len = 5us, .ptr = &(a)}, {.len = 5us, .ptr = &([0, 3, 4, 5, 6])}) > 0), ""s8);
    core::exception::abort ((core::array::opCmp!{i32, [i32]}::opCmp ({.len = 5us, .ptr = &(a)}, {.len = 5us, .ptr = &([1, 3, 4, 5, 6])}) <= 0), ""s8);
    core::exception::abort ((core::array::opCmp!{i32, [i32]}::opCmp ({.len = 5us, .ptr = &(a)}, {.len = 5us, .ptr = &([0, 3, 4, 5, 6])}) >= 0), ""s8);
    core::exception::abort (!core::array::opEquals!{i32, [i32]}::opEquals ({.len = 5us, .ptr = &(a)}, {.len = 5us, .ptr = &([0, 3, 4, 5, 6])}), ""s8);
    <unit-value>
}
