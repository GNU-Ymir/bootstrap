frame : [weak] core::range::stepBy!{u32, i32}::stepBy (x : (..u32), s : i32)-> (..u32) {
    let mut z : mut (..mut u32) = x;
    let step : i32 = s;
    let zero : i32 = 0;
    if (((z.fst > z.scd) && (step > zero)) || ((z.fst < z.scd) && (step < zero))) {
        z.step = -step;
        <unit-value>
    } else {
        z.step = step;
        <unit-value>
    };
    return z;
    <unit-value>
}
frame : [weak] core::range::countNbIterations!{u32, i32}::countNbIterations (fst : u32, scd : u32, step : i32, contains : bool)-> usize return {
    #{
        let stepU : usize = if (step < 0) {
                let fstU : usize = cast!{usize}(scd);
                let scdU : usize = cast!{usize}(fst);
                (cast!{usize}(-step), fstU, scdU, (scdU - fstU))
            } else {
                let fstU : usize = cast!{usize}(fst);
                let scdU : usize = cast!{usize}(scd);
                (cast!{usize}(step), fstU, scdU, (scdU - fstU))
            }.0;
        let fstU : usize = if (step < 0) {
                let fstU : usize = cast!{usize}(scd);
                let scdU : usize = cast!{usize}(fst);
                (cast!{usize}(-step), fstU, scdU, (scdU - fstU))
            } else {
                let fstU : usize = cast!{usize}(fst);
                let scdU : usize = cast!{usize}(scd);
                (cast!{usize}(step), fstU, scdU, (scdU - fstU))
            }.1;
        let scdU : usize = if (step < 0) {
                let fstU : usize = cast!{usize}(scd);
                let scdU : usize = cast!{usize}(fst);
                (cast!{usize}(-step), fstU, scdU, (scdU - fstU))
            } else {
                let fstU : usize = cast!{usize}(fst);
                let scdU : usize = cast!{usize}(scd);
                (cast!{usize}(step), fstU, scdU, (scdU - fstU))
            }.2;
        let mut subU : mut usize = if (step < 0) {
                let fstU : usize = cast!{usize}(scd);
                let scdU : usize = cast!{usize}(fst);
                (cast!{usize}(-step), fstU, scdU, (scdU - fstU))
            } else {
                let fstU : usize = cast!{usize}(fst);
                let scdU : usize = cast!{usize}(scd);
                (cast!{usize}(step), fstU, scdU, (scdU - fstU))
            }.3
    #};
    let nbAll : usize = (subU / stepU);
    if (nbAll == 18446744073709551615us) {
        return nbAll;
        <unit-value>
    };
    if contains {
        return (nbAll + 1us);
        <unit-value>
    };
    let last : usize = ((nbAll * stepU) + fstU);
    if (last != scdU) {
        return (nbAll + 1us);
        <unit-value>
    };
    nbAll
}
frame : test1::main ()-> void {
    let a : (..u32) = core::range::stepBy!{u32, i32}::stepBy ((2147483747u32 ..[true] 2147483657u32).step_by (-1), -10);
    {
        let mut #_iter : usize = 0us;
        let mut #_nb_iter : usize = core::range::countNbIterations!{u32, i32}::countNbIterations (a.fst, a.scd, a.step, a.contain);
        while (#_iter < #_nb_iter) {
            let i : u32;
            i = (a.fst + cast!{u32}((#_iter * cast!{usize}(a.step))));
            {
                i;
                <unit-value>
            };
            #_iter = (#_iter + 1us)
        }
    }
}
